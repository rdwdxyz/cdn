<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"856d47e18aa870de731263a47c3a8b8bb33c03f54dbe7394189d540722c1467ba30da33ca1bf6918740eaba228f9314da4528909c968620742a0e69758d4b9b78ddb7b76b9bf35bd1c4ac3088792695749d03d13fbac12b18e468b3fe40ba787ffc9338da3352e7eacdd4a1bacf2c7ce3a5036341fb47f5818accff7d57cd631738a6e33b867048780bdd775648bb6cc7fd38904c179218436da3a4e30d3c0ebb0ef5d518833a70bb986f88949dddc454ab87ee8facb23f979824cd64bd383408afcd4f25233a5b47cfd4c995a3acc3d4b7fc3d76f21890d38ec7db69e198b1e80a34a2a4bbde5796e144457362db43db481dbeefb1a26ed02f32665950b82f2ab433dc4b120c68153f32043dcf63d017a9b51ef6bc50748b9b9da518c6829a94eddee24108aed7c9e74713edd4cda85d97a3f1bdc1098648035bbc0e6f65765fbfffd4d12fe1fc18b4d4c287a56d1c5d1e1295c5ce59a806973356b243f93b8346eb351693b7c83a75a2388fb052a76ee85f8f8eef52e62fc05f27809034c3e6824d963e704e7c6b413315667a4cb8155594c0829af4b18589229afeb225b03b4ddf01e2bffd0eeca1795db04a681da1a045197dedd4f9bb9a8208d0a196434ad6ef177dc3f41a6325d67cc2c9efe115afd421433321d7504781804276c37611767ac437dc38f4a9cd2e7e52ba320daf58d933f2d6c5825f62095573a5008d04f11b8d247ab608af348fec019d71ab21dd8f9b574bf496c106244f6473c8134dab192b7800782e59ddd9546eed39e41df56c62655dc515746d5e81810701aef69f7c90330342920ac378da37aac75cb9078553dfd57e7334779b07cf42be2c3c93ffc050baa07c936a2111f4d21414dc66608b00e1852cb853933c1fd349c646dce86254606362d9a5e1670d3070c04a118462b9596df3c655b3905b99ee45074dd314b234f0a5cbe0fa16808e53247eb7b7182fd73ad881bc0fbb8ea517d89cccb51e7c24e153ae331f5f2912495d5ca3ad92049adc3c3f2f472af10c913d48d56db6b0bd090fbe967c68e6ca892ce42e9c892e106de2bbf61dbbb003ee6a8c407dc05f687ae1a64c2edd140709d349f512220838d1705d3c97475b464aa8df4f6c3d694f5c76edcac6446d011d306ee8ad229eb36321654144f1eec2ae0f4fe0a36717d75920fbe6c1ef5ae9fcb6575b5c5059a1d1a8e12644d2d9aee72984bbab8d4c207bbeb0de32114abfc22e07dfc0e4faca146172a8ade2928400cbe3f8a7b3f4aec884525148681fdde9a3f74d716f26bedcb3771dde238b1d01903db7925ba0f1fd208e771fa63e007396878c0704cf081221ce717ce6815092aa11856033f177bae1e5bf6035e5b66cff30319e3a141620af5aaee975007564c8f3af800768dae7be07b3235113cf08ca574d101e1fb7987801703de949e8a319a2d91df9772a86dd2ca4f84a725ffef4b303e9264f8d785aebbe3e68cb41e7d333d034db5171debe4658829ec85a8126147c9778a4513d568269fc0c981f2bd24911291882793f16ca2c9c453a8e4d25982f1d8453866c987465c25b2774f5ff6e5832ddc916bcddd346f59541769ce4155a13d9601da59ef8efc1c299be190af207edbc27bc0059d973a5725ad59363014d235e0fe9fda78221498f8c0e3d74a3ff59409985b54e98d8f37e29bdbea365e7da9d6ef7c7ede1a6719b114b74f8de5528c7b0d72e705f719d9e68d69764e4f8e6fa247c2b129d4afa200d5c5387cf519e716d71c5c94c8ce5eacfbe11716a17e91b315fb3643cb550eb2fa06726975f461cb62f78ae0e945c1a8bf01a25ab007ac2dbf4fc9e508c4c8d7dbe1d04d246b44b16c60579f9046b1d2d8328988ccb89178942beed571a96f3481f7dc5ffe7f75e419adc9ed973225d93e961b7176e3469eaa6ca5abe31468b572a7b8ded92c8db624595c256653d8f9e228bc786ac6bb11094dc1ef2f2c1f084c129879337c5da7ca3cf9e36f84540754149b690e16f5a5141a467c3b81424a90415896b6bdf033a239b73f5f60348007f6c904cfefb1db2c958bf9da46b27a86acc768ca2b3c10e06a51037b005347648d034e33e054795cb017e0d4c03d0cc0e231939551c6e29ffc0b2c5cd570686e84141cfe1310a2a9e57547a18ff2f6f89bd7b2be989e843b546777c5e9e7349176be1233f5da2f024ca6d4b7a6f31180cf925ca8444c56de2db5fc784294439059e22dca739698c8054ed8e4b7441fb01f901c1f98ea2ab6f3b780a64c29884b96d991ffc641c93ae0c2a217816934e8b482f53b6df7d008cc605ebde876a22d48ca6fa49edde87389383c9ec09ee5c503043c5eb210383e57f9151c7e4b720a539ee7e163635800201811def93ba3b440686a70c5e4cd9fa7ae845110ae000a53d6ef5fc84842f1fe20d91132a1cdd9ed29b55235343ac41d50b46067afaa0386a39793e29b64372f50923d081dbb160abe69dbc28b1b2fbe69d92b94ccf486de67df6de2127a36dd1dd8ea6bb2824a9f57742fa012b8b2439f76b7d14e2ad998d9ce8568c149f7aad84689ebc81c19bbe950bc4c5820b0c59942e2ed875d537a9246e13a40ec03e8cc5b56f5734d97732533d4bbfdb8a3d266bcae5ddee01ab405856990020f516be19ebeb32d624c34fb6dffac5473bf8835213894ebfcc83fa073670e8d322206c6a9934c926100e6334f953ee6fbe4d7b3582e10d6445f33f8e9b4c712adef961be71e026abc84928fbdb98ae8737332bba9e460fb3d72964c07a726eaee05f80672026c11ef4a6c8731a949e1c7dea39fb4d6af02474587aae10cabe1acb4da3c05610252bbf37d7df66d58011fe2ebaf1eed7cface78c0c4b995b45cf570ee378bb621caaf2799ed4714a52211a057913c28e3d3039bb8e9f3e2c451586c3c11ec0f88635020ea536a9329043dce485f17c9d66772306857e1fecd774a27009a6b2f55143f4f20447938b6ff2f8c99065b71248c0279ec9d75dcca691cd2013356f1798198c585e04f8cd096f213cfe590668ee65e83ef593fe321855252d14347c46bb72d69fd7fd3cb98f9b1c153df26256b2bfe6b6f8234fc83ad24203b8bf1e4c97ab5b1369d7c04f38ac4ee77b43e7d7da3a35b51490bb23f07b94ead91e476d83b669bf83c3fc00efe6b8fc7f6c9a2a38e3c796abdff6b65dfe5182e5b8c3f66d34d2db223563bd45a30b9c8f349c0a4a1e4f2251aa9f99eb689ce37da61de0c8c931f544ce4ac9c8184d237ad4555cc7dca6c98f50d51adf88946598a1395628eb82366a4687110a3c06d0e9ce777e732b9f0b9a5b3db6c537226d2aa358f7db62cf030ace66b126fe6597f98e6a9cc59d7ede2371be082cb13fe2bd040032b9581c5cdbf59d57a28d8ec6188e5f6193dfa12c6e047fc2167cb3b56e79908dbcef1eb9cb6196e694270a80e6e1f2c1b45f61317bef30aa17eb6405b639e96a3cb33b5f553849f6520923cd50bb09c7340c4b45f295c1c662b2c1b88bd375b776f28b85d8788e2bab186ca36907b4b21f3c3b5ba4ae9f07f82826edbd218411786a9e960c4a6afa60c9b2fce689f8b68043d5efb469be4eda4c35ce0b0343edbca04a1df258287c4c94db4fb63d9a8acc3b5c3d0a292833796b9c3d534d649f0aa30f2245b77450833e23570b7932546f4c0ff4fbb5beb04ae1114d640cf7bc7b623ff3215cd4e066e9b41329cadfa63e7b67c659675433960a26a6350fe71edaf72b8ae147d11617f7c4fd4f02399253d487d91d4eea0f58c105d7b5d7b78e3ac00b01fd527c16955934adf032837946b29cbef2d789627c879780f164c682020fb4306c76e43bae44cf6989b6940a1ed54032fed6fcbce27a6162030c290b8a5172f4cda28691de614f8e69e284e56a5cb9ce4c44e9cadde5c449af613625fb69bc0cdb9b36a4a70343cf254656a2f5e9349f991265162669c259c16a6b21778f35f1fe11b93c8ed487d111fcb48acdf79349100069dba50b1f63fbee9c66b337420ea1c9265eea1948b77040f046bc1ef4f3d978672a8fc8f6a669d3305f048aac38e9b565721e288d4dca6674e9d2213b2d567890b7df80b8d60536661c1b61b80eaa2df1d1e541a7054b36021b9d1085546402d1d8a0d51a1e565b25a46b40bd921aa5a1037e5592dc3d4f8bf8fa008b123c6eee5612a2e119718013bdb4f3232e8937ef18cbb6d51abcc659a37c80261e095e53c29b1ea6ab1551c4a20c4198cd82d1fb33dde9a0ea7cf7d77086e10f7c5d770bcf0eca4257dabae14852f5dbb5f4baced93c90ed6d32270fb979388cfb86ec5988b66dd636dcb55959595900a40c0dc1eeceef72ffb9e94e5c2b743e32fb0022ef289dc03ef82d061cf1a6bcd2c553d7f4376b7435d1b297735117e742095a0c8ac475ecf7fec1edca64c403a97f0ecd935877e720cf9208bb3e41a3177a58891076ed5b11912fa2a0956496938cbbd478c46ecd2214ac5c79d32a0ec8944ecebfc8a8aba7c92c7f1db43eb5c00e43bf8644327a7c35e5d5c34b90028c681d69faf331f02741ef7cb71a1055c5802fd365e8eb3c6ad113d5ad79bb2d7f300ffe929408dc8bea49514433513f42554bdfc6ee17dac9139aa82c95043549d0872b066af1205fcd4c2813df319d2705d9b1eadeb42b5f0d7b746c59953424def702e2d7bdc9cba91523341cf69693120fc52d040a2e8f2e064612c54126d30e4b946c9adce9f388b7acbfa9ec5fe36ceb3aaa8917198570e3b37f19859bd1fdef65bde8946056fa8da8793c505e4ce7314423af6a70fd54af65633e594eeb9ef7c38aa216bbedb4b884f29568a742ead59e771cd2377ba0c3ac8beacdf95bacf0dfff1658bf94db027b745031acb1344bef46cb342785fda73e26266e3df79d3545326858e3a399945a710f8afb01df2ac34bea90743c613d617c64527e1f9059241bc3fcdf4173a4f0f5dc873a54d305d5c9cafa45e704bb4dabef62f5bbb90e66390364af9e7b2b9e58c482c7df60be4de259d8e93de81f0bd423c07868029a46d8e4245e8c9dde0186fb495c8ca815dae750d6e96ca3b3afe9e27d0f9b0a698f9ec837f41fea552339642b76b77ec3af0a889ef6299fb011072474b173221c3f25754e3e8776a879d645a75319e211e501cb589a0ff39f49a28bc3e6a1987b23a71aeb127810c05e762a760621a14a18d0f2e3c2615110428941f476519fbd6136f32ab8c39586593052c5976cfb5293e5c357c85b58d7292000949b1b8aae3435367f241e1514848af073cd6fd862a30e5803e3454a5bba8cd58ce3f3a46cf7c241108300b07ac0bfc8f469ff655304e1af53e11b962ec08dc4323556ceeb7b74b8e1b26e0749cd77f238aa68ffa63093c7c955711e7bbb419f4a944920d0afee2f02bc70fa1252f78f2e22f8e3c9c7c32674b85897a328e4c4bda06dce3cfcd55ff1422e09b507643dca49fb803e330209a209d94b92fcceee004df7f8ded9fcccf803851f464eb509da5e0998cef0fdc2d883f723d4aed242369933e5215aa7aacb3b67370fa518be93c12f4e2b99487be729a91e5c5e0c6c317e6e5967f458efcdaaeb43680e52ff81f33124463aab4a52f23f6d9d0a91db18d02fc9b7131fffdb505c8d527bfcc1ff1acd3fd54e5c233425020a0e9edc9d29061c64469cd0d1eae2c01519b8140bf2d6426c32514b92499ee69244f0a42549c44fee8419a41a18eb3814b96fe9e3649e4553675a9a47aa74714c00260db8414851d6240e1352714b2ce5cc0c9c8626ea0fdc42eff8332b139b02aeeaa6c29a42ff9336d375d38f89634038fc6cbd71c7a836963c4afb8433fd905d7dd972defbfe6c15d292768589d7f6735fcf1fe562d181cb393e09ccaeb818eec90f34d044c1cc689e2b7436cdabd51887a8eba7344c789979cf68685016034b002cd389c6d3604d18d6111bfdca74a2a03333df3d85f850f4444530113ecce43ac07b0f3ac4c493db818c43e6f79dd64e538fdc1bed502c8ff9e333ff066d91fdc4b7519dbab51018f5be81abe8c591dcbbd951c40d8d2ff249a8c23077e434ae7f01fffed22ba1a232c72d70528cc2a0ab00ac6d0b26fd60f5d758bd335ff2657dc5bb7be0dba575e412fff09f22a6df13b734c3591df5f8eda755fd3b9e755149a653060dfa421b01eec2707ff77f1d9dca7e997c9468d41a78fe2c98d387fd65d57636af92df3a4a751e9f23967f56d0734cda9c5b07f48555423a0a53b430e1ab75d7c7f5d068b9736b3d2252e0fa5ed59dac862cb3619faf6444c4ca185a1c3ed5ead077909cfc14947d808460e86e212e3bcfa9cd9bf2a4784e3cb29700d5c461bb684b376d7c2ca669fb5625f96b746997b63302b11bb3b26adb7a3375b909f2b412604cd0804609b56d01e43a35dcbf36069237db0c2523492cbdb9a126508c0fc48cf7bc297073b52d36e726cada04fb3cc2b7e6fc6bdbf5b6a7a521ca4f98c2e4e30c35dda8c9062361d3a72125bbaf73e1986c01741811b761c2568ee0730e1f5b177577f9bb637d434f40a14f6e713cc39d147ea28baf07c80a6b73e52e28a36b08d282ee148dbcf3bfa1544bbff6ae706d3a7d4218e1d8f497e068e7bc936740b3e088b0cee54072b7048ad6866d499238c757aae0c82edea14c935b59925b4d648673dd265a7efcf9032c50b2753c8363066bf11e78ffa2cda3e198308d920c7f66e48a05a8f0409c170147c6d4de6e1b15e3168e5be5d3d5ff1c7d6ab455e76a09f9c492db6fa668b92a218c3c30581b953340f9b51248b24b93a0a506572a6105278728d157785cca51aae6185a1719347501ac84376f6ee111a806f25fbfcb6bb72c7e8d5283f3df30b37450e10b9e1cad2f623efc8f2d4d9b107b13540ab37b85d88216374881a553863f55fb6347e4fe66551c847f27a9cb31d1b236342584a965ea801f472088dd422703eeb039539bbcad21d0c85a46f69c2489600d2651de753a605dd874c473e40e2cb6839e8143cda53a33aae3d31cabf38788c808795a0994101b2b0888e7bd4f19ad2cd629e76cd93808b73ed9550fbedf23b6478b041967cabe3180a9f9c7de29f7a82e3967156aa7739f440c15c6ad055cdd7b7589f18acfe717607dd2ca60f09769e02efaa348f4cc63cf4a2afde96c141f34bd038abfde6ecad8c2751e6f295452c2a77cc3b9f38be2f0f1db6c24473960e042cdd835894dc52a827fec1e1a83ccdfc05b8fcda644d05165217af78c5982156c0b0169a9df61f3afec13658bbf0ad18b21cd9795be9bb591da78fde2ca8856391654842e20374ac7b7c83939bfa754fe09fb4357a72745415db7ad7a18039255f16a75cb068df8d3f27618d0d485b1d2275a03c9da6e6093bd3dcd9396a239af2744c1b08415c9889424655f86ba11cecda13c16f322369335b25533028dc7febaffec665182326f250f0decfe73daf8ef6d7f7f539b4964f13ebe3c8c56d8754ea1294a1c5ac9546e91a24bf42df81d75923cc9e72543466b82fbd64738b88b391b0951db2c27c0f593450b6974cb5c636cbf410b98334393e5fe5d19f2db6bba97ef1a6c01463db36c966c7a33a4e19f2b3fcc73ea0ecd2eac83628ddc48829a13ba827e2dc7e5fd9ea137f1280c7e555614dd1e8b9f330d2609ea7cc2f6c243331977f7a9c073ee7acc18d1170674f70ff8ad9e6672e6dddf6d0f4481573d2936bc64ab65c3930130588c471a069c004e1f0ececdf4892629b0e2e0be7b28921df8d38183f3a90aa508459f427d15b866ac3c5e1aef3586075b6ab90a4d4fd75ee0869c8e04a1acfcd3796083a256e0d6cb1f8b51d00996aca8ab0d28d0d751dfd3f2db3109d5b91416293a442a1701cad5ed6a359b392779d4845a2ecf737dd4e035915b721cadd3d1d6e891069a30b72832c792c8ebf7511aa6d28921ec1ad8e338196267ee0dd3adbd7eb96ffc6887727aa488451aaca197d6440178ec86a7aada6986eeb9512393789d545b13ceec2ec20609b2d9f95f9959585c650f50e929c32c388724da5d2c32b156038a89458e73a0c63257b0df356aa44e6e92741406f5a7f90555e886e452e75542bc1d4f1fa019ca959041a3cf5b62eeca47e26add2aef335bbacf8767cae25ce75b2312c31ba7ee5c38e7a4d12f240e854ddf4580b7c29bb2c8dd05ac3bc30f423ba8c078a14b52695996688277a489be6ab7efdcf1a35c08a7d4e167489b8767d11faf055e2e529a7e59948aa54b0a3bc592c545072f0af093c702de4dcc0b07d8973d629700ef498a641052b6fc7e4f0fef9d44c4e03a2043396dbac3e8ef7067733a2b6cbd430525987aa8573d99db547feb6457ca6f1e991a03471d6ff663613bf1fb54dfe65e8de12e4019a51aa25af042f6252ab0771b425ff9289f01dbf1e7cec18844b3fc13e2ebf369ab3a129ec5382a0d24b3d27cfcf26503e7cf8329b0a61597ea2c86600f4d4dc8e04c84ef21d5f02eaf549813929373d5a7eb17134b0b06870d9cfad2a4e3cee91ba781636a2670b26f061c780f1f180d66829d6712287958e5831a0aa8b49e6f7cc61098d9db11085781661c9fa74bfb4c21d5267551f07c03cbe914df2f3a7949fadfd16318ac96f57671aa793218f7de2477eebe6f9da8a29129e35b44633699e7931248e8d442057793def57e90ee5c027c85bc651b18b92f5d2b8398c0e10d8f74e72862ae658b79ffcd1c003260fce8ba0199551eeda77db3ed29748ca358e1752f583eb81c50d86746c942ee3522b55fc3ca05f41a77af9ae0c102730376977fc8879ca8a620420e541e1ed86101d07368db8a51627ef0b702c0ab08d73d110b90269b46ca90721dce6143fdd482b9df2eb323e3128e162f8b121676d2d2b0350f53a5cb86e2632b3a8aa37d8bbea6ccd83f615afc75bddf2539582c3eb5bea19727ac0dd9dc43433a34ccb971009124fa930313afe39f585bd0c6ea9dae8c6c62eb2808c4538409f91ea52a8d3483a737347ada90e58788a4f350a245d9134f4a1899239546475b92231c71c3abce3d1a8eeb7f1989e8116830029f7d987a91aa821dc50a8f411e8de4018aa725a89a47d2dbfb98122e88b81d8d930ad64f499212dcf5337ef25d2075976cdb9879206825e89910fd7646ea9720177549f5e61c0263f2b413193a103dda0f43d4fb6ed81249b4bfbd1c1e707881a6e94c873ffbf65ecd65040d7dd89707e839a3de404e8ce78859c80a839a43450811118d11b78727827d054aa282114487e2f229e4b006400c104f484f66e77e9f1da3d0058f1bff483729dd97bc29dc6beb71107b6ed658e329eb5c20f4254b77e6f8d714451cc77ffa30df4e5dbea107bb09408930519047ec647b61c25063ed6bc6dfdd62bc135b741cb2ae6de72d4f4aaf68f4bc89351f4e27f2e1e80dc14c6d1179fa374a55342543977289fcc48fa5e09bab5ac08bf35201c475f596d7ca083584ae2e2c614ea674dd12c98f917cf14000ab0d13b099f657f1539e6c8d3b2f0d01ed57f15974edffb1042ccd3de06d4ae31244d85eb15d9eb5edc1f3cc9d856a8b8921fc248459b5956f63fe74b960e2a55f6b374c28a31b73973029b220e28a45bf3b97858f75dac2b89928ed9c228e5a509b65d433766ee524262e73eb30043292da98e0030369d59d3c279e64d115963b61e06761f678c8fabba71f45b2d61c143f71326cff89bf322aac34e25cb2c4d7d48cc1f926624ae88eee66fa87a33fe50841b813a1c7e590af1095ba4291d06965433a5d28127612f215543ad59f66ddc3a281a612b7f5ca62498c8c5d25251726a45eda940d48e5584e21855ebc451e29e4f68fd84ed4e58b7bcfb8fc166192125223b888185575692167ed22bb02db5d607681b1fcef7b3ff9b517d505577af8abd5b75022e5371ac14664e36138ed0382839d08d11cefbc50977cc2552bef1ed3be4c4f55ebda63fa1fec5a08f9aa0d7f02c42489f8c1ef51c0396d30bc0360e9a11f21fa403e57fb8cc106f06f1966cd0a7d3629500905c6093501e6cf3dd47f23020b312e703972c1df10e555d6dd179a5063adfda65f51867442259cb5d5fc30dc940481982f9dd3cac71c33e3af19bc5ebf0f4793dcd1d43c1669c17c163b5c064123cbdcc0fbd1083dce4d80375bbad0a68c827847896da1028f62c9d1a482a526b47cfced2c9cb3cbcacaa16af7dc89d6b5140ec485edab8cc90fc86aafe2714c1445579f871e778bc7d73cff0a130bb7a3a032d27263a1afbb5c835ae0b2d075413cd58cff3c8309eb5f05434cbfbf160e318a1d3a0b71cbf8a62109cd5c15fe631f67171e2a9eaf3c4930ec6c2b62f426967b7f110ba0b9a3db7c6136df76b81a86448532fc2a3f48cbc877e3ec0d2bf0fdbfb0a138ed9a85bd38d41d96b21f4d119f355c1a439769249dbf96a3fa9802af046405d991742d066eececd0d9e78f34bfe2377ad14c4e1016fcf13512c11d9e61346badf01b76531ad1bd0f9ee24e9c43ecc4a943e46ff5c6f6c7bb219bdfa2a2ef10f8750091dc949592efdf1bdf8040212b34bb2d61eecc535086ea24d19bb93d9a9d2f36d0c04ec2e3bff7f02b2e175cd4340627e3a93a8f91543c761c9013997b5670aa80ba7707d08622d5a73b74ca38893751b0c6500968537a2b4da46039c901594fb6ad29240646578dfb2e269a8c09e59949bba6a1bba7a93b40683eea33416f5a9b8beb1eb91549a451e20747cbb75f6e78dffdf3044fbca809c821c5a10a518e2a892cb5e00e209f22e23c7ca8f431346ca75c75bf4f3da42acfcd4cc37edaceb454d80bb600f9eb5586924a78162164a468c21a3fde0754062bd7e19391b1657ed3a9ff144db8a1ec2e135e042155f74884acf0f4bb116edc07f47343f3483ba266890b6b950d9b9beea04f32cadb751b2ee922e085171ca15b9d03e2405d8f81176a9ded0060deaccc487e6490e034b0a03b60a39bd78eaddb65fe3ac19faf4dc6d70aa6d5ead8900cefe17f1e318dc9e9b1722400bb963316d2dbdf67645a09785ec90cb5fad549eaaefa459184de424b64b4785ccd40e4821faaaf1cf2eacb3e5804b396cf9a1434bbe046b0646235fc7336c388db4de8e7b1d86b81bc6e55cc4c520dc1ec8add7d10883b8d96418de67fccc915af0e49376586d39f4dd42a14ef9b983e7cf49f79e55ac262db1017960e8ca1f03d5af095101dfd75dba502a12633dd2d3e1045aabd6c8ef6cd4a8e44a649349f150877c46eec2a6891d6dc6036888eda2100cf5dab41e0bef1415485a228b95635f1a639ea4968036335c6597b1173946ebbeb16c1ec7c5c812e7d250de19b2ddae9ea3e996831e83eacd6e378821ec555ab3eb0b70c708a96fbca98c02ac71217b6cb95536f5ee8dd21473ce36f9375eeb7c463394271ced4c41233da5f264308300f3deb65822ab6dcdb1613361ed8fc2c4cd0d4dace154edffdbebfef9f319f63a40fa9844672f86106f71b3cf79b86b0b387e53f58a4efdc693b83a52e4d25987d3a52e7712d13c55f573662f56fd17e907f7a4ffe0e536d0fe05722e287173e56192fd0d42557e9fabc18c7294b2329d682e14dfe17e91b5d2cd4496bde4fd03a19681fa735e61013d0a0e851886be9b756d0a3cc5b3187b98f8ca43a9c7f8d46cfff96b31c0af6b5cec15ad82a3c6f31bc0d91abae96629ceb137b029a7700f517ffa616a4439e0b957383616eb9169cc84e723831b22eea6315695dc4410987a6fc40c0a724520a31f611729e3997b90128e71d11f100b3788ea605a6bbab65e0dde02d096a220d5c1563ff05d09b3e6986d5fbc4d8f5c3e1100d1280a66d7e16a423d672a2aacde8bba9999477ed9a2aeb307c08109a046cf94511b153ffbf8ddcddbc93c2272ec6c7d6d250b6bd67f3bbdebe2b13545733f8076960c549e18cd406d14f5e5d0a5ad15c9b7bfbb4ef100caaf2f5f3bc8f18ca1febd120e9cb54e4aeb280c549b2460985cbff787c469eeda882d162085592424583b1cab69bad09950b9dd709bbd1b03b65731579aa9252147e05bc405bc1a725f5dd761553b0fd8d2d661aa3a0255bf8278cb5210b8bfdf502103754e343e04fa16f3047c79310ecdb85a6c8e05dcb9839171e3b138de5184a4100531f0846be738799d7c94d06c56336c47b7d91312beafb83a801598249a07f184cb33d0167c4d9de4f12c6d30b6df66048fad5da57dca9bc377a5abdaa099ef1782d58744c64354502282c254e7a8a5b9a2c7edf0969fae5eddedaf8944c9086a9c88290e75549f17e0281997d928947c5305fe6f7830440d7787fb0e3a40aeaf5c2f0fa149eee3f876ca13f6f2bfb859f024e437bbe39e6f16e054dace31176c3e3824d897d5d6e13afc7aa32c5a0123dd8ad2d5fa993584d5c6cc4d89ae385da155db8f000ce00bbdb786e3392da9215b4dbf19e48300d065be3cb53502c1d4f44d880c5d279678bdb742319d2ba5ad56213a70032db6a63fc6310325d7fe7b1e9ee3d819ef8209b94c1a27c73e4dc4ceab9c3c74daf5afa4956d88b7a776040b07926b58afcc57947dc87c4fb59afa66c7fc39053f15d314920cae4522c2cc50a467d9ec6eb32e4c953cfa1869334566f04ecf70d40e1b9e458b282df95a928d7e538585208b984d38291478c1a50ab09141acef68979dc9285d6ec5d849a0fead7fbc7f5316057b08c440160b3c3c58a23d5ed76e6217cf0f9e5396b41f710c5ea9017fe0391133db800a14b8305ce32366ab1c1e6ae1b3e1c50ceb11f5aa80f7a0856478e2c569e8d70d0918dfb3daf02ac03f84beffe7877a38693e70eb9230ac397a7721e098a424de4d17a6d78b30096f6da71d18adf36dd6362bc3325cc6982e8330209329b646dd8f03fe914870accc2db00e7b144487c03807694d8909ae93a98ca33d0b08da99c416aa568e962d6b14a028a14b7fdea4a3cb92695934f1f33b5980355c3be98c56e4326ef308c265f39f48e1b5210bea0b07a1227de3f930cc5917ef7f866f1f3f9a7c3759dec17218290b9db0145b6d88576d35c1d133393d00f8922da22226772f5e1c75782b17d732e774b6783bdd04cb43f513eebc1d9a8b16ff665cc5427273579639f34ec06e80388cbe047945f09ab327c9f3b8ba2b862f41363c32109c4f15281ee45b84d7a2adf840015a91e7c67a97cd1b58b72c0c53c52228eb111d46ab8241e282d61b0b3a3e6882cda19767aabe024922217353ac9d71bde8f15b758b5e82be25983c3986fe95c8d0787e98b56ae806e242642dcdd0f141b0d31572fbc23cc18c7e60d88b972a77bd5b2d9da96bd873784ae5c71ebf9e01f661fb890dc4e0d6b3dbedb0a9c7669384741b2e9491d25c20fc5cb66b8fb7ba616979d12fd28e7bbd124a959f713d3cce713cff453b21121e79c4eba7c6f97edb1779a0b25e059f429389c8955b79bebc2ed0ed55f3099ef4eddd4aec9caaa8053c6e4575f0b95e386aadbd6e9315aed84ea1a6dfb5b17685a9cc17acabed15cb793bb3bb90b05c143bd0d8df9422c675fa4eab386b9c628b08cb9339d623fb0c479b7ea4b61aeca957448c53a6cfaa347c43f5b6324ae5e67b1e64493d11be2142e2d8a3afbc79892af0042d119cfc95b17c28fd6fac7a0a9b6b95162765f997cd1980a8dff704dfd075b977d3093765737508aa4881c9f057d4315fc765cf5d081564ecf7562d6623153a07886c86a31270ae7f3a41266ff424d01b676524feda693c45fd94be2939c7d646997d672d0a864931acffd5027cb36079e26ceded3188c871a292222b89ee1ce535c2d511045849a983f593a9a1ba27c7abca4724a330f2d941de5fa3888064dd1ac939da36fc3b47449bee0ace66dc5484d1da7788144a4a29a0402d44610d598fbda3d63be6f1fbb550f9e10986dea2581b8a2fafee7bbdb67f1e000c54c146e3525535d8f6134183ad75216ded8f38cadb8eb566b44ccb4c9ab5a15203a081fa3026c8233ffc9c5117e8bf1daa500d7631b1f3c431213e9f98c48e890cce58e3988b71e80001da5cdda2d5a6259322715f43682b311f2dfe117d443138e27f968e042c8083aa897d30e07a7efdf4101b0dd739932d63521426463b14cdd8c2d5bd4e2857e1a2def433020af5219f7e4e5fb629ddd155f82ded72909cb17ed139185a670a0c0663b0cc855e9d5594034d90dfc818e25500d79f647af22dd75073141461503fde2fe507fc0b1378b193697da3618c16675b4808efcab51ff69062af38e1472b430b91395524f598b31fdae88057101f15eb81b2b0023cf098f94a52c35cdecfa40b7d21a4225df23a10e63fe20900e9ce187b138a58760091acd162d10674f004c5289289b826209ff8a58dcb6fc6d86395af3725a4267f2bbf8673a6a5f85e20235036378af89872af8779568e4e567d4a862912b5efb2fe532bc0fa4ebfa8c63d20df738d0ffff372b0f4f653b9f9e3158426bd629adadc4920ecb32cbcfe77c8e78963f09d9839278ed25276d42c1050767a71ea32cc782eaf264de0f2ed0f5fde93ab55374b30b0c9a41a808cf871a50a17df6d38a00c598e2812070798cb34677337d25a4ea844254ffb8a78303d7dd46e7215c688f4a3b9e35ee5c82e010bf1db4a95e18a77d8699c01c0f0eec38412672ddc443e78620e2c1bc7069015785b0487f51b645d9dfbe1f8825048fa5b73ac9d0d64a3af24912ae127c86185efcca86c54a5fbf195f62a5831f4dd407088885a89157aa2a552c2d4328f6a0ad45af82b49a90edb0b3a1c62c21f9456e129a0077ae691957b679049b7ebaca3ade9f68cd5242323c0d48a6aeb2b91a75cca7885129877013a34afd2737ea769b53cb20b43897c1731e55718e4324bf74d25281137b5a3b112081190560684fd0fd40de0aa0711bb1af7394153a534a55d10838a65c6bed505b712315bcfdff1cfdaeca1a9cf4aa1d036bcafc582e420c643288c7f3a17fd6c2c42f78cc659ebeb5109cf08773498d9b3ce7ea294bf6eac8c4223018611a155c66275f2278f5a4c0a544181716570739b738c0150697156c6bfd5dcc229e7ddb1bb0d24914a4fb7249837ee28f80fb222154e46d88ef98463c1054500b5cfc02989901da444eeee04180843af2a9c209c1448038d4675c61721ad4327690ae807eec2e4c02e95348cfb948de1c85f96421d54e19227855fd99a3efb9701066e243be5d8d57c29ed0d781801b2d03994efca00766e1a9efd618941120df8387d33c07b306ca6e178e275da1528ecc3e394f8155fdec8c29a59b06d64e687aaeb8d0188752914debaa6c9c8f77c6b143363357746b36ba41d54ab9e666282b92270a2f2d04d8cc8c4248f15e635a0af063fe30f67a46a8f2fa95b9a936914816ffa9b76d5b4ec307c8c47b86c8a2123f70a44bf19f885690165bb8d675867a678ced63d9eeb931659208c464befe99718987eb2d45e181715ff482a0b799051d4092c6a3206cd25a1461c7b5c28b3ed9ffdc06712fcf82e29db56c766b2e0e570c9a550c64e9bfd82831d7a84c43bf9fe06fc7b589ce38309abae07393a0d8b4dd4bc2a68877403ef43f521d49895ce8b6e2eddabebfa98b7f3a4da01cf247c5e54d559e34435f9329ff41479da76b1d3677c777a4fb7398caaebf7d8f34a5f1cedff06012cbe36d0fe0161897d1c618d9bd4e8fb365ee768238f82ebddb3eb3e0c33464d37a90dde99c75f9ec03d1e45430144a014100612b5a41600ed3e26870aa884728e501810dff4829cc257d919a6a300199c98b350abc7f2f23840b161c584ff4bf2743daa332eff4fbc026b798bc354f460be61ccc45be431c9fcc0f21e7aea70ce6c4d2289e57aa903611de40107f448df636b018059c4626aae892aa154b55ca9679bdcfa497dc45db21fdfb8a1d5b464b31e03693fdc4e022c4a89fb955995d551063f6115c22ffd1d74179b52f9b90cf33d53198bd6fc970e4e38293bc4260b97601a1f69778e97800f7075dfef33ae205fa6724cfd4ec8dd60716ccfd344b8c84e5b9319bee91ed236bde57110eb530edb5858455d02ce51d0a7436515f407188ad19d23bf504cd2dd6eb3019a1d9d265127a08ccd5e21502f298c7a0c70d251e7adc154ad4faec1d1f7a5eb15856a65cb6f27c3f5fad50d241931eb98e20a1dce858bcfd7498d9361ffe6183d1e266ad8a66ec98d3fcac67e9c19520bb6ffa2656da751d8be37f4701c652962daf612325b49beb409dac15e98881e315018399f699b5c53ab35fd4994f6111b2d7f083a3bb2acad64b9f2356558ab93217de71344c216b9ad184ab906fbbc0c3ab691ae50eb5b474869573b57119546d211a1828547874787051c4e37f487efa685503fbed3f94ee445bba39cd2e8eb6093bddc9726619afb7593668d903e1a6f5e77ec149cec1d826a4c331b0e75d11214deb318eda1fe25b228e7e98827b0b370700c9a7a9a44f07d925ee2b5ba5570e4667ace3d66f2d9979afc5e0c7e2c08718b62606657729a399f204f451b3fd7abd4e236a24c838a333aa64e077e1f1e940c82b21e643935bdd5b9b631a234171db2b6f9efc953a1dd7fd922bb7252eb0d8321cbd4f68c651adaac2d47900f5867c81f83ce4e705c4d63e9a745f9750d05947b537f75fb4b0519b27dd457401239b93a63e6b39003e7743134e86164a18f38a8f423ea0f9c53e14fbec2c589dffa252890eb7f14f61d3a665271ee34464fcd2d5f9ddd21ed0422ea1d1b339e47df213833eb3e23aeed7a40c9463372c60344790a542208ade87e29f2cff253d7d9650dd0c0ea103b07de488ac61830353a7630e03bcd9ee9f5369a1620eafc1876c43d5bb1f53abd005ba251db9c369a0c1fe0a57d0a30b7d6830111a88d4a6209e8ba46d1e10bbc420060dd8e0c0e1c6e9a114fbc30f668135af6b13eb05159dfc762876781a75193b05e8d4729934f8907e494713ff56f3798f75be473bf4c533bec3b435eae5cd382e39328712835b60255c253d8be10701bc9f618b5317c2ce77abcb9b3853ca246f3b99700a99c7a680ebe935fbd092b2645dc4a09e1d98d532c2ff7d27792b139262d9d3680617ed012ff3027122fbdb40a21e2c97fc2691fa9c947dc95a43a695b3caf51a66b65076bfc24f92fc9b956c5b9adf7930f345bda7f5ffab97748d631afd0b1b1c1a32b2d02187ac5d674562ba01e211eeb501f6593c88585f311e98e8d348124807af9f24caf11529b1f7a01d7611b0eb9de162e00b4aebc0ccb482351ce3f1c8254b5658e9a9b8124386e3e02b0ee667fa73c9ed2226b9a817682cfe7f2581ccc83f05d7055b15e8d4fa9f89f15d84d50c6ba9ffbc8bc00b381c12a194d9377a34cea4da7375eeb707012e2869fbed848ac58b5c6b23ef38935eb9fd75d0ec8b56920e2ba7fc073563fc63ab3cbc87197ae9cfc72c3a8e78b39de5633f48a62978f70f3b3c0f7d13868f7037ae18fdc7063121f8322e0cb740b3958203e64ec059f8634d90c748f27e78b168f6c6b85cdd3e884752cfba31c1768988d86b17212125eae1e0c95a19d82a5610a1e5555a6e618d54dd7faab56f8b340d01be87a746e53678f3e0efc4d9dab791532c8cf8692468764172bbd303cd135a4f0de1ae76adc32ca4a6108e717669fdbfd0f58df95dbc49b4ebf14f54284f3fd7a2403b5392ab698f8b9c582f371559b5b3e8ea72d0804c6919fbd2926543124977b7734690d4b7098e3950da26e67c71294df081c79569889fd1e7cd0b5ad9d7e85c7eb699515b3870b3507c28a06c87ef5d2f7a5c23453b94a767dae8a860357f90fc5babaf3a3f6fef10d184f08f943f3686e21be7bcfd87cc8b2a379b74dd244bdfd250820181464768f132cc46c0fe6d20ccf7590c2a495ce48fcc87b983e63e84b3ec0494b1ce788cf4f373a4bd2c936288c3341f97fdb01b3d155c289f3cd1dff3e0e33a448096825f0d040714af3656d4ab9aedca3c7b9186dfd4da462d30793260a323b1c2e623d27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
