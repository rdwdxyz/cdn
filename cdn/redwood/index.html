<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7175b831cad18a42999f405d6b41dfe4d1c57773774177a3e6e3de76448239eb2b35ba2ea629808c60297b6fc8dd556e0be2a5f0c059ec69cc0fd7f35f8002117127f3800b5118520bb6cb07590e81406febd5e628c8c6962de61d6357e609923d192cc1c79283838bf3cfde8be3dcb914c1400da249e21fc587e6e16d6b296d77c5df1e7bd7433b7ea7ee89b4a493bc9abf698e7b33dfdc44fd087f7ea5d2222acf26388018284f4b5b4a16ded5e181cd65df838f53dc26eb92216319d2e838d32f5fccbe2e4c92b059ca2318e294069aae8bcaba3760eeb2addc57dab39188a8fe4ee650b4884a3ceba2d7ed7e5cab48e9ec7dec298bcacb0a844576603946e8acf635b8ec0a58768fe5e00df87654b45a7788e9088f9176f804701cf097514c0c4b654ebb7c3170466574d380a8f419238c6a0e8deeda8aa48d394a23f2192ecce65bbab33b2ec8cc79bd88eb43b59aed65b85193aa0983c08f96b0af5cd2223df13640b3ba7a2667c9f02e3ae23c4614bc47b0704b7eb6a85aa233780d1b11188f6de5c4bc8a1895b17069c3fa7f751f844816d41396fbc8582a6c440be50b56fd500d31c277f37d89740704857a06c66304f91e1c8ad83bfbf847c8a349821d012e02a132159e8a0a522260b1bf625bcddcefbd3d3fdb4e7e106efb6c437452d934f4228f788cd0390bd58a940e16689907a36aec8be3cf1d7ae72e2d9d1600eafff1e3da7ad3654bd0571193e76d0c504b0009d52bcf9c78093631a24025d58f764603c0f54555211313605cb2ee00eb78201832b93b778461de2ab904ab0c776d358d1cf48b4979021fd9ea54cf154bf5830a3c9c8db4fc93fc5505be4184ff43bfbe884365177092b17cd2908882d10401369a6aff3642324d87b49e9e0b51e7bfa8fdb52679a4431d5c1381b39d7e501d246029f77a9c2465db3fcdafa0b04523e3e1ff152df6506efa3d89cd518e770f0a835447ce4cf08ccbbf326e735ffd07cb431fed38b50936f15e35e129dbda6d8720e68c82e1c1bcd6f7d8b1153962bc76612ee75edd03138a98ea2cd836d033fd1202f3476bea42dfac4206863cedc930bbcaa1d97837eb39fb88f4eb5cb6a902d75afdf18040d9a223c371dd41803b2b28dd064a4b6485dd3ec03509e4baeb34d0dfec57cf1b1eca7e1eea8a1bc28760cd0d6fc00904a6e9e5a7f69702841976be4757ae0bbff14f4b102bf7fc0a073ea97188dc61e00b8c102b5e3223878a4c7f1b494b9ee5dee9e9d5f35d24d00486bb8465617f61dabc87085ffae369c8c99ffd95d30b868c066b9149acac445eb8b487a66e976693adcbc98f1bb4ac90f8c78c2ad244fb6dea6608f65c2e588fd300242ff886ecdbb96b6bd7eea5405dc7b1f853f7d58bde8cb63fb5c738041f8323195efc57c7d79c16269b8b0bffc54b662c6421dcb87686dc98cf06bc2e1e7fac546f1e74620c959a7ed21327839aa77312c50974ee5365854c9891577335d8f875657467257b52e9c22d4f41e07cff8b1728e9e21b504e761910798f1d907a7edcd11c92150fe85b21b92f640c4186e171cbfd690dcb343093440b28fec4e61ff6b14252eb6065c848e9915397566307fccc9d9851c39a7d88126b7a1653b8f3db408cf3b56b54178a102f6132fb8e1a0a1710621cea46fcca3389d808a3c4ea29361ea2f6c43b0bc0417b8b2dd858c94cd8b8db7afdad58cb0672aee8d042ff9a832163cefa401d8f31a7c2b63ca61f7bda57949d1a132fc7b7b620ffce5a75426f9ede48294beb94e21d8a15f5a927f76f3fb07bf994d3f038f55e7e298a843400213aa28be49ad2bb08cf531a5e1ee2a0cff5eb015a2d2278eee7a2c60bac02024ddccf4cb441041d157e0366e2c3507e4c7e4e0e4e6e4149dd6502b8cb27eae824401b16ddb6062f5b9a38187ea786d5fdb2ac8df16a24b0833a111ea37245f5ab3359bfbd14590afa8caae6f6a22cfe1c8349b5d367fd8f06abe67715e8b6f01415d63d6f1dd67ab0c83a957ed4814efd87b330d475f13a0ae6a8029b5b1054c209c1e36b375d52eaf737e1925cee984025d6082bfd23e431e251f1f3964e5b1eb90486d6d44e8bfef0b607da0ee4e801379c3c9dcbd97afbe8649ecc1b613e8ac4de627facbf0a1a5aa014ff8c0c5e5ca91e4035990ed8d34cdea37ba9d3030d2c6e8d0c586096e181773c6f4666f3a63ceea5e62cbc300d7f181e7f1fcc65b8367083e8faf76838ccf2bb3abc286deb0af2dc48c9f7e4bdf0f5ea5ac8f75450119b70fac8b0da387b82752e978c58ce77c00c61ad92db219c51907bd42ef966b8eb2189899dab882a2e83e29fb30c16f4531d247e2e0a59bb2e93560918aedc5ffaaa3d4d0346590673a09fc383257cc8bd6564420f07ed6d19bddc5641ffaf4d0d17c40ccc897099d04cfd6b35490ecaf5b996f42f3227e360c448cbe6c1439aaa093b7e8dad88225223d50d0051a878172c354301dce2a12c8ad8e976c6c746a7c2b6c91166aa686152756bb92209d74b8daa9a9f7da07bd15f6d126e65a3b456c6e4a546a7e106e2ee9941cfb1ef5165754216930152f38ea564463058be74badc310e6573f89db38363a307a7041d1fb8551d8207307e41a73e1b0f86fc349e0a4397449c79bcf259f15def60d04a30c0c4974202e0ec3ac6152227630710a68d444c3b576e1982c3f26b116e6ac52eeaca116f4dbc9709b3f9e763a6fb7ef5a1dc7c2ed0e04c1366d3674b55d2a343b9ff6c07c0ec1e39fc0e2f5228c7b79252752a42e4f2511dd6b1150867a87ad161176b1cc870128c70af1bb9d707ef1c92887f85eaee4a9c6e71236263bbe6cd7a3c43126425cccfe1b9efae34cbdf9881946803c48a3c0d7ef0cceb7d742189cef6ab5d4b46142f0ae64593179e247920578475a34d76b1c4665110c23656d7c6ab836883c2acb05375bb4f7206374ea8682ded4d5755e80cf457e49cc876c65b2803ad64fddcd04cd0d4065a6b76b42224b331bfd540180af7e1a7f86c41180e1643ab179a1a7dee6dcba3457311ae52c998543e9a45775d89be12df2f4707b86db35078f1a49b38f92edb47ee3b2e41983e2ca294baeb78a02d9a457dee3afc1a69769304a226d56bf1ba92de6246533744c29ded3f548768a137491096abd39fafb009217459dcc22b7f2102e7d94db88492e8d991016f12d7a15f1599db05e5b6f5416c0d53310c94f17e1fdba268697efa821dbf56dce47397ecf40b04757974a5f0062263aa9d06fa37f9dc7c069c8c65045997d0f185e3c4dc009f73a3fedd4205cfeb2a1c4fe7a9499b087a9445eaec90a1c5b21a3d2d1068325b19025cebfe15d4959c196731aa705b2c28ce4539fd6f2e0fa41d670804b8a659381671b60c88b9adcfda92da42d922d259daba469d71083331024da5e93fa76c49a5b029b3830bcb1b13a023c07834062f9badf377cf6da717412e66abb174a60ecb197e2d86606faa31e5d7edfc6812a6f378b1b2f5777be5df6ec3dd2a6e1a5e917345b2978f01df11e7928f5d2821a59d768adaa74791fca0dfa1dc03aef5d4710d52545f825951cbb1dbe6e3b6d5a942a067824d2fd2b18e0b1248fc667731f545a6942ed24da5b269e2e43e1776d312c55fe68a933727f9e7b3540a291d48471fd22af8d217105b9bf9db72c98d20563251cde3bf0807ec3f70d67a1a9f8b95b4af11a925cdb9a757e22a453f5f49814806bf4beebcb90cf0e9ca41002baa70e7292d8095ad9fe6e9357fbea89de3faa439622a79e039c6763fe841702d701eab37bc7ec3ed0bffe35e015e93d71922fb47b2f7905491cbe239be78467476f7b9415007e01096189b42a96979eeae761347736b838b9ca4a737940a6347d1f0ba956580f6d10318e56573537f8d075feb543067b5f7f11d33aaa74ceb366b47acb6a1fe82e62193b85a9f3eed621489ec749e3207f332f4559cce37a5028d57ce92e596ee764d47cdc19bcc114bf1406b5b0eb09fa85bb1a60af78c6147625b286609c83a245c32f0ad3d4263e42fea06fbdb795d7a630f68f17aec7cca8b76b65ad1604bdb273718be264739a11bad80369be074ccafd615356b84816f2caa514eca9911fb184b5fd9984f0fceb39aa780e12bdbca5dc7c119e7825b6938d2c128ca5c2ba0fbd6396a6d52439b0659811e0f0c14858a4f7dfd6dd4d6dd9443c2ba8bd1763582a0ed684f6bbb2001143932e25c50ab886801a3ea1f72a2632b7868e7cc49aa02de8f7884dd1224915a441b32a9afa0a9ecbd13c01a50465374cea98cf726a104e57caa839474910c21ca1bc28a7de9817af9928a99ef81a07fdf31aa4d3b04855216d5f45d69a7c916e38219f17aac17633f650865e68bf3b38a905933be99c47c72d9c1283c15bd1e240cd6ee3245f546d6b7483dc6f920cb16a1ed940f6807af089688e50afb97ebe0112296396fe1f092f9b9b5f3bc2ac4193e8fb6526b44fd554a08288d9276d3986467308fdbb808c6aab9d557a9c4caa88bc9b260f74897865e7b8adbcb2e51531237fac05960834b0d5051bef0b3acc0ce46ff75fb3f49842c19fa1c2688ec46a2db3a971bf5e18dd153819659c558cf63f0ca616978737879331e697874224199f617c4bd8d75195ddde04c07b8d9cfb14b02038b91966e6e4f712e026d60778c7cf5ef3aa4ccee79faeeb59c8e3d0f17c64f5a9858eb1d3b712c7cc7920618552ab17c6c14745ee92231ba24b166abd4e47a762357435c3cc1d1603c80015f3e9c5558a8bd8944ebdc73b653b9212b09eb5a3f2c97cbecc5a16dc8656e7053e88e3453e9c60dde18a54a573539b4633476b6167fc5b65044ce2f9dbec8731051ab6773d3f816a48ecd180d4c0b734213cbee47dc331d0126547660518b3573d6917036171254860f9b96c31fd5ba5884df2fab86006d4d3b5d36b792eb44dd42bbe6ce1cad12951795ea27fc41106a13889404aae91f23a1ff2a32979a014ff4ea520eb9a810ef020976e1afe58c7c9742af64a07bc03956a524c632b72092599be44c88409db573a9891b4ced18b713f303fade287ba377d1e0a2350eff8684490a1b37da3db739506eb57173dd8c48cc6c6e5eb361437601a8ea8b50111aa7a778726e8a4e153fe2428e0f00ff12ee1510c75835424b3769975e6858d43947265b03200b4482cd5da4a1bdca5543846c22890606a9d4fc7e31d5023d8fe2bf2fe1fbae7a478b2e4897fdf03733b106b6af1a959f66d081fd93fbff679c46270a834ba671fa1e0503a5da5abf6f53a2c7537eabbf6ecb902abd6c0daaaf82a7ec80555591741284dd718274ce76a9685309b496577cd68e51ffbeae20d57bf736714fb70ddfcd9c3be4feb806b854d3e6cdfb25b0afc29955c071c1da5cbdde67eb37e4ea8058a9bc7115c544e19cad06decc3508633f54804da919fc7c47faa3ceb0fa46883bcf5f82112d078ce24b5f4a62466f263c606e1dc31f40526ae198425bdd7e00bc053cb36d805e227eba6cdc3eb5b25e53af0974e4e54e0e31976dc05dd64474037284816fc4b58cc1ea620c053b599d3af5f20db9b743258ecda4ac56982c80031b369b95d0916d496b8f53a98b4f7fc0a7b25cd3013316c167cd71d065000a687954b75311bcb309f1143bada45d8a7814d023bf52e6790bc248881c183435803eeba523e8b865a055610a049888493cb25c57202c9097d5cdf7f376c1f558304c09ea84df30c7ba3b7afba2f13270a45bd3200625ef331610cdd92f2c8648b65e8031e7b71bdd4bb7f623b01f681f58636eaf1283826e7be40aa5f6f9c340fdc078a012bd5bd236e3c4454bf7e33300f1b61171074aa81306fa7aba2b8d8211e8acc5183093ade9efbaea8eeaa8aa252ba46433ef76ea1f1c3f167f26c77d64bdb52be0b8e8c55e9e4dff3b2337a18c06f312caba290d190fcf412bcdb08d35c57b2643bc077d0af57e20e5570dc9d869d6b15649019f8aea2b33492aa660632267762f296b1f55b7caa623747a6d729e04805bf90267e66f268532ff65ebece0ea47d63c2f7f0acd60fb70bbcff6bf6ae88d6426bdeef6034aea067fadac701aa58bd1bc88e79ba7fb944acacd406faec54e6d2e348cbe60967ef6b6e52ff1934fd8b413a88c9342103a74d6696f3c731910b3651eaeff3114e28855459a5751a95bee76483d365d9e370144075ab2fcef3e40a453f33192da05d9ef2ebb84eff7167fa687f6ba69ad44c3aa91d582b5f6f1edb147bb8d9226d5d8ee999c1af858336ff830a2d9c43c0f3645e52abe331baec520711ab09e854bf3344872fbd7cd7ac9e873bb4a9c946730e3a110dc948fe6b71d9a19f5a3f95fe831a5d6660d8ac1b0eee07e2dd92a0a2721d2fb94f0e82f9cb8e93efab7625fdfe46653d1a3b6961ac4ad2731000c75351b38cfd97cf3719664fae9377a03b9081ce5fd1add92c7327d3fed1bb40b06a1c4629b50e28c108ed66eca7011deeee7a94a8b5c36b395286256b9989912776a01fa7a0b4284da97eec4fc70c57c015258384b1083273c15fc52b25e3d334a8b49bc423e7191b00fd49cc87382d8dfcbd880493856a591694d70ab9e13f07bb5e84996756c8e2072fca6fd2311e79275ea168baf537c466198b4b9b7288b75aca87a1501035fd6e578a8ad352cc860e15c3bad9f1bec74d3e822e6875dffa341738e7baea47fee967ad57026730736eaf961cdf8df10565936120ffb8d45660e3f920385d2e48835afa158b54e6be8ee4a585faded133b99a346dcb2fd64f64cbe772135b4ac3b7e13ff8591218e3605616b7fd7810e04375074d9c79f586c90a9bd64119b666d91fdd0457c80588bc798d7a73d98fc4e0fcc893daf82b603f489ed191633e86d65f7f5a20051e6908ad1d99253cf6357f59dd388c377abb5a9369c57cc04a1ec108b9b73d4d216e56741427226a725807dcc58e8ffa314d3c814ef8dacf6c832a13d26dde66b82a7a882aede0b893fec81b0af4c5e4ea7e767bda4bee7fbdef636a8eed3cc94b51d44c8686d19277cb9544168abb2eac17390746b923221018b63e05254da961961a11909f61e2c1acf5f87eec2a97b864a18bd688e2097d8c3a8eca047ca027b8becd7025352c8620dda52537594727f11f2261957ad4495fc55eff2491363faa5302f24192d5ad567911ec04b119712239979a5d0138b98c435458d49de0a4447e18d1ef98342d5594d355b6cfe83a44aa962e4ae261d3eceed1333082a36eb1a526649527a411f4f5586e854ac3054d725a4a4de54892ee0ae30eeb485c10c5b66ea65fbb081e74e64710dba08ff75a42fd2164e894e8a9e3de16b07d8c3a945fb61b6878f92df8d86ebd3859ddc02117d0961dc480be493a833d3a6158b8ba2ea54a21be7733b8d47a5c2db4683f32b58ee37ca82cc7cbf268db1313230acf6be93faf25c1fbf7a09f2e7c8c2d659b5c45bd50703ddf298e12d964d1a0c00a384113322259b33b19493bdc1a31c2796f527c629fc5b4c23698177269e85511cb3967be1864f9ba5abb7a498e9fae0c86dc6bcd6bdb5075ddc3a5af80fa5d80d5bc11c461a154d8913e2625e2f7d8d2229e272e3077b0e757540474198fd7420aa2dd33ca3561511e29b54e9f2a4f7f85ddb63a0c9688c410b7bd7515a031111a7d612e5cd562baeafbe5f223e96ec7b419d10260f72d31ad5d8afb772ad2488acaf6c956ac4565efa90bae396b1a8eb01aa5cf1df6a17fd37f3816ad004198c7206651b07f5b274ac46ef47ef6bb97382ffa208016837eace547b286a653119260398efb8cb9456ff3fbe76125f3d24ecfa3e233a75c3e437d5b17f0c226d661f92e8c02f139d0b97ea6ba39bac6259429f0139b01f741db0a0e2158623728549a71a00bb8bedd2041e302ffaaac8402eb7fe82b86c69cac628878e5518a41d813e4df5a273bdd11fa3f1e7473b4b02a4ecf51a20f7c1cbd9f644af6103fa3c1336c8fc13e6d730f35ba161163e724e33e00e2ebbe3a2e2a54414a9d4ad7a526e3720f9469ee45acefc75e78d84496e92ad50bf9f9240bc31bac35451211dcbfc23012a9e6aa113aac254142834caec77f0fc100736381e1fa05fe81ca93f34bec19b78ad39dd7d1bfafb2696c53c885b1df0fcfd7ed253c0cb70eab33a7d36b2757b74a6ef96df67983f433a7da6c3f989a263b57941cc7b2f2321fed2b3974945c0b9c87d7a8e8e50fb29b945a081be4c7f4477d0e1fca1f5f1ce1d8b243ea07f85cfe3f683ce3e282e3c5b556ec6fd3e422e66190cecf427370c84d393af3976ef748519d1deb622e069a5bedc1611e408935855621056c5964bb808a1c09b4f7370eadb1850b7febd91f72184a3d5f5a1ff2598f858ce7879972d781f94c8b65e8a47f2c443c5a037cda3c948814a66e26d035c316fbd14177054b697fc703d38e918e66d41a63d364ce043b70598b12cd73d81f92780dbeb5f5bfaa99281d13a40b907effb10d89143afcc718bbda5b5ab96fc30c3321d727e85303ac0354897c05872692a901e6e8b932420f4a12647b747ae1be51aeeeeed5fb0dd875c7ce485dd5bf8de9d262b385090d3b9fcb94742be831d07b31f5141327016c72c9a9838f6ab66cc53fed653516aa38556a8f4ee22bc5b520a8c8b2a9c169787753959205dab188bfb70f5c30b4f3a47bf20400a65ed876b92ce87057d33beb96ae537e6e11a5b8963985d34297cf6ad868549500779c0a1795772de460e0b474a62a02c134c23891017a61158698a63d3d427e5537d383c8a67369977ad1305de0f4c16d9ae03d75aae67eb81673877b7d1221c6d603db80c5c37c1e95d7dcf5f8cba19ed56531a1e83159d742493b52c09fa5d0a517393170f0cd6faccdaf8c57118b12c4c81a25d8973df23712ce118e541b85c7e45260c531435e76b4746e33824ac0083349d6d2b10cd10e75d7adfb844b1458a20610ee822205e131332d65cf9e2ab7138e2c310fd4d4bcf7f0c06dab1f979e2ef83cc3a058dc7b809b0db3f206b4ad2229ab6b6f4bacaf96ac5a31c9b6b8243c24ce93ef859cd8906b33d10d847f76e68d762af2b9281169fd0dcc7b0c1973d5a2e55b2d17c0379f82246ffbcfedf2fc927f66cd2463e6c346bf3738dae6fb2ca5ef41f8a73dfae133b043db651b1ada971784159e80689dfa915a6fbfa3810f7f6f934b3a927b3835d22b34661ac5032385ab449286f9c36093889168bfa08f15e7a112be02b4108f0dbe47351f5fed07d87ad3d41b9082fd1fae9cde43512dc7b4d880be2622818fe52d7cd8cf903c9470a95208165f527647abb838c345e2ffd4421408ed9aa66b541d8b2bc747e86fd6ed1272f7a69e8eb37b1931b1799d35e6fc3aacabb89e28a8ee795850a492dddce2303b1cdb8ea67be45be0d622c37da8c89387f691242ce54f67103d527f1fd1b4d1267b4800a5b00f9f41d6c4b44865b492040d749054b1c54daaa74f0f86f28b01d51d847e35dc03906fae4469f78f10db31bf6a5584445e601d8d7b5ce687a6dd8e5fe1d995c1f0cd177f53623ba6024155a783fbbd4491823b26cfb4f9d2ae7b615f1a355d645b0be989e8a39a6e85e70a842be5c5014df1ab7544bff76558e9f595fe01137fae451b10842e3a3b4eca72c6ee6bd8f51056c13ea224a1114f30e2e4e88937f0936c171f4a692d6cd866277e01ede6fdacc8a6bd1861841b2699711bb9787bc26485e765591db5fcf9dbc18885cdce88602e876bf63db1e6c3ec1b52de96512630fa69b2a890a326cbb8a84e962c8ceee2b32f9af1dbcf2dfc1c3024982201b7df521071b90933187d15b7366615e8bc65198e15b8b52cc97da0b94470cf1be9a07feb3a2533bdb50897958c48c4743c0f05395991ca59fd130e13a5e7ace77185255432c2be6bf9e3cf6748067a9c1ee90e339a512ace61f92df8b69bfa7199c9ea39fb4fb64690a71861a144683ab7a56e3876e48331933b8cd30c4ff1cbeb9305053fd69e18d3becaacf5aba5a6dff88f85012ed6185e5ea0d8e6ab7c15a0e4712988c4ac48b1d44414ec71241b1c17687a6f455bc27ccb44fc9ce8e0b3c3a8a739c7997306f0fe02c148f82cbe8b9f3c7f5297f80812f09fcfd3cd07e8ad8c12b6cadf429d3ef605b82e1bb42922b0bf651f1eeb914bb9edb52e8deea5a8b3bb4d2a4f972839ec8b6372d59c6fef40ff676f4b7204c9cea90829ef9fd66aecbc87604900df55d634c5be45166ac91e46122e8f98fc2ca49671962352efc093efa6ef94df10c87290d93ae3927c4aba6ede7244289aed521625480854fa973708dd9a4e169e689f02dea7eae4c3a2bf08febb03e2cf186fcb864f51ef651b9dbc4bfbfde2be8d9b57c6a3ef215fd5fb7b3a9eca5f83a028938ed1587fb24914408ab9ba6bb2afff0e390dfabcfd706cb03cea452ca863d352cfd3a9c97e8ba7d9eb5463a2820cb24745dd20fecf49124a55b50f5a4db59c9f7c3b068d0579d6c836b46b4fee6d9dc1636267ddc600518eef659154ebfad6a973353d07a389353943586df44dd7dbc36423bb36c15d0f2d3f49c16ecde83d2dd73677c0decf961d690db95fff11d47493b50366f0f7c39a8cce58738d8b94f6c7c2fc7a9e1a9b5ff61cb30b1326272a892f1eed32d2b312cd94db95939ae5fa903ae2a553bd29f575a9550f2c05bfb1a469afe768422a0dcfdbff54ab941978025754f61bf401fcca05ed71016932cc71c814421d37011cb9ee6db81396b96309d00812ec13f97cf7c17b5ef4dd2242c9f62b0ceb40908b8da09bd405125f4829b26e253306aff6317171add6459cb729f8b5052bb77bde3ad4474c05b15024469d463430811e53d0e3e2bc9b8bf259583ec0986b618093f46cc8599979489cbda6a3d52a07e43a9fdf836c7d08b35f16a55ab906ceb1387782b4004ac29919056490d7317621ac9f0957382420ee123ccafc8eb9e470f6ac0319aea966d40414f8e7c6b7f8d1dc228f7bd5bc3629d21d57c8a6dc529b9dbb20ba158d08e6c3cc39d98a524b91d9a7ba326a095250d5d65fab7165d747651dd65421bfbd4e823782d568f74cf576030627fccd508fee418cce7f4f2a933b41654426e78fe70a3b38bfef57b696dbad334a4cbbf69cdd0667399a1b94cbdec5fb023f40d04550af8b4c450fb3a31524b612ea138c78c1a843277fc9cd8eec0b922937c3a9ceb107ae3c6d29b0e04260906169f1e2f25aa0300d805094afc77895f176a8c5adcb2b0b091d0822126c36abef8124268c6490b2e658b442d7d23d1c1a25fe07e036aadbe177f56a093068300276e7b54848d335ac915b13361a1993545d172f0132d6395a93d061e6534174bf379dfcb9366f9faf5a07fd8cc088cc8c94cdf42c20fef8107986e9f2bd1382214da5a41a2bcb3cc26a0ca965e423c7323a4972a3ecdc2b92c62d53f8a968d6cdf52954b8b8ce1054500fb56dbb23eaa5ed365811721c5bd0167d0d09df2e04adda587bef5722f66b75db3c49b232885e4bf6d2d1d6a912b1381294655ff1a6b1e742490982f4640fe2a969ccb87a933421feb28f77bf8bed6a153ecb50bae69d2916eccc77ee05a1feaed5a9da9a041cb7fd38c285e162bb7e1aa8de568b250c3ee18142aabe096bf1f04712385d096fd63616301e2e9d2504b2087435a574b450a3f0cd50d45457f45cbe07046d488bb55914f4b4bbd80254692e774029603d4c9bd422ad310f5045888bad8e77cb329e67dc68cceca43709f87c83f933fec14d7d2f8246408dc179b616c9a7b467eaedbfd41b38c51120ab8c07ad32180ceafca28a2e6284b4afcee9147eb7ff552d0510dea2c99ac5048bbfe4f75341d67aac86a01f095180ae3871a66d7b1347d17492e7cc875f05bb922cdf7fbbe32f64dbb212b421a45b6570c3476cbd1f6961fb4a5d1531c827ad92b6aa4dae5327e8fed249e3eff949c0cc7a3115d33274e8dcea66f6df5b7eda26752b0f84c5cb6e7e7fb251e108f633916c164d9e7dae7bd1e0e36778ac1e6d8787725a8fc091c1bdae0cf9edbb6945c84c3880b94232bfeca847c1c8b8592f0cf744ce808d7fed353ccbc3f1824d9171cd7e9b561989f5d1f8607aee49e9853c6ef8594e2a71e0f22d911c74ad0f6d57d87e183b5eeb45f381917c300f9146a87855080eb56fe2d3a969a9f86317b6bf9fb5b1bff483300e2d781c484173dd839c3c2e601c67b1718308a3d5b4f4a747455198eee7d69982077a1227c87fea4d770dbddbbe329ff60d26278c47c3f87fb26f5e43920cd1bd5e08542348550009a08f4b955b16006891bf17aca47336d77b9224a7695aafb5ad8d3393d38ad5bcfbb1b554b1fd964d1fdbf8ef8e8ed5fc3f8b50c2f239b1107ad9f5bc162862efc1faff9ee29edbed0f7fb7b3b8e969ab51cf4c74d2ffc8dec35a9902e1e3f17d0abd9373325c1bbfb3e1665a8876aa1622739a0cc25378ddc296083065526e650d443446aede8db08e2811c26bd0e80b5ac8270f6f1574f931ef4daacb77ec57b8a5c73f5b69a7e02b15c4197d084077089bb3a3e6d116827b1093c4066d607ddfe0e57d871c507f1eb3e2530b536b957f503143eb624382f3ddee9079432a48759095c14583f1ee34be552cd3094932b40a870c05e13583a0913714da07ba53bf8b4ee2f22adf47942dc8a427558d69447179430e218d2e9d43ff7d7f405c579c410bff89bc0f9a7a48e766c570e072505c148589928192ce5cb73881a49729357b93c8f56e616aca1ddaacc72ba2b5a92abd04760c13c9a68082ec09f251aa38aad151aaac84240c57bd1c5295a2571db2a0f7fe1ccb88a9f60e76fa31579ac225f9ead5e23939352bb2bbe6fb84128a747b9d525cd61872ba6806e0950b88f82905e8783ce961de7e82b499a238a9566406d09c6a513dbbaf2f03e62c1df1197962fa0309bb48d5ffde9155170757ce369dbc7086a1ff4df0769c31aa2e76ab5e10df4d97d0d7b9b17c9f49da1eef6d3dda8d9e9a4f5a4d7141c02a6af5b443c837a4ae8a3316ad65f008392ab687e6292249f6dd141684e25c330b407e7dd37c5f240ebdc1a13a79707279c9470da07c622e36cf72a31993503c847bbbf25c198700cb5cb472e2285a71b701992e7988246e5be002ed5e06322691d702bdbb95154e82551f9284e21c808160623e6d258cb0abddc00e602aae16f74195aa9d549bd384da59222ed6ab3c35502687d334a35a393f7236d0313c6b5622c7d1ead9ce5f1cb84cf639b50da1403349608b69104bac8baf6a6e06bf4bf91216c15b8ba1ebf1c34fef9b662500288fb230c4b83cb7aae35fbc16c3e6d39280ef858b59e44e15d06cac692a9f457663214febe06219df6dd348814d65c10feb02dc2c55cbda84f1cf1679490138799c09b402d6e2f3311c17541447885c1d6e661fc78e7f8ee9c9be65dd0d45f47c299679c9c9b88291a2d9b6998d87370dcd711d592c4d0d01adc1c42ddde8cad5b39dcd8f4c23f824616cd730b4957fd2b4ff6a829008c72dffa0c4df0c1e0a72f2ee808896451719146048e867380e5deebeae48ebaa865d0b9217e499476979cd0624bb8bc0e732be42a9cf61a89ace3a81a938e3f37e74f409e51ad729dae8ff918cfefadf3bec92bfb69abd9b5c0592c866528efcc9a131b42fadc8b1b0262b9289036710bd6d6ffa6b1bf416b1bd524528f099c8c43f41bfb1894312a60c041f102b344bace06656394cf58941f770c798fa9d301f8a2d0c19cbc0099ca62370ecfa6edf03b4c50fafa6fb13550e90a5be19735100d92a24d7326fc400010ad72ef12e2a3b0d4d704140ab420e75914344cf7a3fc4ae1168d8632f3780c213b714cd53937a431bbae12a8f2be482294127e0b2d43331636c166993a4e4048465fc72da8cbb7d6f4caf41732ff2fc36fe99916bbbd7d38c0aa5146e6fc04cabb097a3118d52268bc6c73279c36c85067e028cb594842b36fc24e76b3d1f69eca85eec5c68859fad1aca9da35448f2622e503c710989988eb1424e9a93296bee6d96de9f61373e29c48dee490ab638bd47b550d18e8f78f2856a08eed7057e8510bf412acfbbf75556d1058bfa7db956e23afe74c0e8ce0fc7b55dfeae9fbed0ff282979a972c6644dc28199dd78cf2723b3cabe00d2be82ffde132b5c1482859bbd0764d5f5b1884e0d0854eb7aa4a9ba9723f0e3010b041f0af5f913f299e29de73d3e4f7a30445cc91b1602c8924f5f6b17ced213e7167eae78fc5ad1f3c6ea1ecb94187592e64dbf52499d693b5003a19064a47325bc1202cc12336dac50b7aa5e46df55ef8c9451969b4df3736a6bd4f54d7c1c2e6c30f0c5bb79df254848e0920b95843dd064c03253dbf7011ccfa3f035fa755fcb1e277d7dce4b497dabf93c42d4e8372896bb8422688e99b0fe5967e5d91919f301abef6849646e6654377643dc770e3bd5609bec4601a5905f1a7fecbf12102cbf8048e5d13adb281ace366cfb7fd0b2e71f44b56fda0dc158b175c1afc2fdad31aad3e68b76e4f7c73e48f610181cb2eef00ea27555665abf1b9f8f220123537cd3192b3f1f24d36de4638f8ab12a510aa589b72f602e9c7ad9f17766bf745bd8f7c6cfa2e1476a6b3c19d8fe995ef1e971278e78ba762a05054f649ac51d9712d27768b864bda66be55ed369188edc5d9d8698b4fa74bdf61d883810eae98f44b85ab3fb2502828777b45363933156a9a9ad7b9b7e29a0d2e57c0381e9d537d42c1c43ca5d01f609a20fa122a3ce267da14cbb7b0e2a01eec78ddc25c3431c88fe658af018e99acaf4897b29661820998398e7c0d17747fb6ab9d26c0d71a48caf769e6a90e7dbbac1461b9dca9ef8c5fe89e352d36914f565fc4d726b684d7fec10dada392cb0b6f35e9b75e60daf187252b74cd96ae90a61e0af2c20b8a6de0186e6758e54952f97f3afc6147e1d0a4eeeed019fa425761348d84981ce6b0408e2fccfdd3e201c0a3cd27cf556d6919d8ed4288430acf6c1bb6f6e7f75866dfdfbee728b5ce10f265771db8fd10e3fb4633cfdd7901ba05009899b7c7a0069233975c9ea166b185ae66e4e0f8266bd2efa06a3662cfaacd621cc69f7f35e770c424510f72f6439ccdcae1f47b83da937ddb061ab2c79638d08454dce55787b9bfe774963a267a382959083966eebb894bd318636c4ccc1aba931adc5c554424d5bf64f0d09d70c1e4ac5940a826a6e9801a5f24cc3fd31667d1ca594375424edb6dfb8afee0e672abf9535cc5d09579eeae1482ff8b6274d2c958f0b34b46b1f9096d24171adff57bfab5a1fdc82378955b71a3d340f6298c6ed5c3432bb4e7ef706e9e86db3a11726571943f7f5a0fd2fbc2d8ceda35a9f4af0d0d56e549a513437ae5b6d9bfd9ef7092731cc5ca48519615923a6e20a143a330362d5d0275138f3c235bcbc0aa396f046480a05ae0c6fd4d21ea28bf454b813f293e85793b3eb88ba91dcb40306db2f1be4f00d0d3b31bf4179fc2bd4953fc4172d1792a3c1996d107e8b674ca0bd96d66ec4de41d40ff9cfa4ffbf451f6605c11ddbb770266ddec9bd08d2112f882bff9b8d015e97f148d3c0f010eea52f71e87c8e6e47b61518419ce7bfed727611c63b5d2682af05e52dac7aaf24f333b16196f006cb1cbbe0ce6f30437ccf674a42c6fd93a037ac49e307f1504ce94bfef6ab1afcecdec000bea4c8e8ffdcdc9937faed1df14190dd099ba28655d833121148f9f3750163cb7b9ab785902c06e7fced9c256465118a7d08d2236fb29c88dc24e4e8a9d619c5b6522270e4f5db13f003bb9cad13c23cd4fec8ea8aad635456886d098f9b47af51bdc04c7f5af03c26ffdba5e1fe83f5676fbc41237583872c8685b3159d967063d0c55e5e373ed68764cc5a58b654e4a9c8b9261b5e94813548a0170558dff67a49760bd9b4057541e070838d387c4ef13903322c5dcf80202bb2e6c4b326692b11f47616e765b435d2566deac1a612bfd9ca807a8773f4345a32259e37cb3b879e809fed867d4a0a5487adfb2630158b9cc8f8c9d77f24facbbda363a23b756570c7fb3de7ea44ac06711ecf6aa093b38bd8265ba0544745fa501a1fff60d74e3230536312b3460e03de41a529c8e6f4bb4b3b0a387c0ff2724240e19e1890527bb272a81f7e2d90e45b4844e92e4ef90a08f31f88f1b4d0322ecd95b7f848b147ede59b98717f54ab98cdc724bb7d7d7c187b3aa85933a6dbcccfae6da60207cfb6ca96704e7b9348fe9481540eb49dce9f87ba682339d9d8e1875aad8f80c827946c2bf00082a511d1722d77aa856cd2df343b714442f305a39f1a18e2aa0c2325f104f9b0800cab4a0356cf897c393cb52378c46c5b41c772e39d13d9a33e56919ee9c87b827d6633d89f152fc212d08d9aacbe69cb0c1382a908122ebc5e0a13a8fb70b15eefcc907d94c13fba62e30d651a3db931ceba1664bf2c76e4bccdba5fdb02f0f7c894d61fe91a6f00254b2ca71df8ff3e5900fcec8b9371216739f76e888847f50b97503eb2bddb640b6263b2c53acec0a765cdf9728de33251fd144a1b5595324f84ee266c7ceed46b61746a69f2a440df68374b656b0bb7db81418d8c4d37659f74051bb1c0f8401e360570953a554679947b7b8c822baa0d4e327c31fe119c1e35b9d788ce454e914e35aaec7471d223d857c2558073d27b3544260149cba9d3e59875756bba7acc84428f8dd43577738073ad3ae0604b12b957d843345252ee89ab04ef3deb32de1d074ec80ae2a9ef7a43a4a02df04a8a1569c6c2c16a29e9a466ec35e101b2d94b0ca7f13922a715d9dd5abea0713ee7a307ac989fa9c9dabb83ebe0c3adcb26637fdee49f1cc8e1dded9d4cf3fad2f5bfd14a07996f5835818d96a61d08e1c72371d0ca8529488d7840eea07d040af24678ac14dfdd759e9b9adb1744bb01791accd737e15d19f738beb59122db3d52818218ba2c129dce8f3fc0eaf6dbe63b515d80abac5f2c4db8cdd3498feb99c4ad1048b150fada6f89e7a805915713f3325813284b03239249697603863df841d5b19dd48070a0f142f79aa437cbf99d1d8e081b7193afaaa54dfcf27862c47010202a782c31171b0f1b604394fd3c1e3a5194214b55c106133a762e0f3ff9ea4bdeab5f29995e2104fcdb590b8d57f79e091162d07db3e6beda38e83cad5ee042d51c3743ca6fbece64e7cedfde26d9b983236e388872eb42d6cdee89e66640592eab096af15dce89b68920bec3662117ab98a877f3e2bdbee900d2a94977beb8fb5fa0301dc1ee0cbf6fb0c488b2318dab881f9c44b4f6650daadbbd70ccf7c4dc09ba0abfa1986edbedf751285489f29b7da5b39ef42802d42a06851770f4549a6b2127256810d45395e00e79e17dc89643f11d6f7af157d3e964cf287dda8aae511b3c05e78db38d62e466ef81113e04834aaa0e2ce4f336f9e4f60c4b107f2417ba8b825512e33adc56767fde09e1916224ce518adc512e3b9ab2b637c29eee313c05a92a493a9ee3988513fb4dfdce62dc771ea63dc723a9a0e04d123ea68bb136d3248ed8da1313458ef7c958e882ca7736d988f56c77586adaaea4305d5277fee1ef071bd317dae3bb4051014f6dec50db80ba7a860a0de0fae52282e7932c3c6c415d0374a72ff432c45f841c795ef7a6a284080e6e266207fbf74acdb5d3af9180bc9e61c02300e33954f833ab133eb3348861caa5e3fac598f5f1ba4681846111cc154f492bc8a8bb20e128be18a73b8aab8e572438cb1e1c230351ddf648a4f4e3c0e85b1689302bc9f44e65bece5e8c296c0d8f52aaa3cd49cff55ca7d353b1884363f3eb780c5dd2dc750eae83b7a096e5b1e0171a93642ba6051fdc225ccdc6eb93941d9c51a659480d140dccb1dd31f2f29c3f8f11483f79adaac4a357a1a999384406e2ea5b82c0ce5712c327f3e04e960637615fc74d4e7a9890a337a8ea6b84013f4817a9e46fa27880dd2bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
