<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfbb73c65d7ce139fa5a8edb9c63d9bbfdb270459ab53f3de6aefda3f612bdd49a8ee8657fa65d73a3c77777399e0eeeb0eff1f6348c8f50df603022c13e947ccfb6b23614b72125854287a5b1e6895e66ae1f9c290f4c59a6037ff296e99eae48725991e7115c70221628b870735dc078f112f221409a0502fffa949a2f5d04ecce996dbf28d2bb180c9c28971ec9813f41cad59b30195cf603e65e9d39c55ae16f0ddb08a437015d499c5eb2fad268e5b25e61d33663962b45ecbc62f047b58f437c75bf3d707d7f89df4f624ed0e8b47d0d14b27c03949d29d3f5e33d0d158b53def723c958df7f30e51df7b3cdfee6e6c9592b68641fe4c2120ae8e4957b31778a108ff60cf7ee711c284d72ebe7579ae689ee093b278668f250aaf28a3015cbb6857710c708a8dc76d6c1f39f9cc755977a49612fed3d090d00c014fcf6ce12cfa1b18b7f145af4deb432adaf5c0e81f54051ec6aeb6f52317a2a30e4a4fcfbaf6ec1467b1626cf084580cfd2bfabfef519710ace8514c4b59bfd5ff8606d3fd16f8e4e27901b9bcc9538197e36bec358bbbd0c350b4fbf0d4ef6395b6d8c9396be6c4da7cea02ba79f65796dd9148a0d1923e9e6ffca5f0067fbb71875bf16baea05829edabaa4d017c65a0c17c3c214f911241021c7751ff3e379d6cae34ae9f333656a40cf1ca50c6eeca23a362786ec050064acbdb892b774fba17cfb1597f028dd17b2000348e909b0c46ad7e8f87521ccbad21a80e62153afa680305d0fceb3b0c1849056619238df35f24f8a72c6c1c1d9fa654cc00865d85935884a6f1dd7d40a7c4f494ab935d6753644d04af2f85f768edd324a29bb55ab5d25c2e4028278e9b18c93566e82ec2e24f9c432502f3b1a08013c8ad98d51c8b72e099f7dcd15e48cdbb927bb7eb407d8b6211e784e7f7af9375ed0a5732deb4fe2543fe076741f90ccfc74ba1714ae5c9a273c7ea1ea922cc9eac82c8fbb2dbe8ee80e9c955be462ab742de4a9ac2e7c87bb4a6d3c44d0c08c80915e3a47971bf958ec70fb6b7c56034160fa2a402e3d87822b020ac2d5470496e9d392a210432e0c4e86f68fab73f7aa2d516c4f095c53c17733f63167635622b3e421191a259ac021b8684446a26fba8ad4b13a0a19c3815f1f9233be0928c9cbcce7b11364c7c176120c0504b4394f71b38a304345cf26935d32d04013dfae6abc5879508ea11e4c027348a7b840436e9aacf9a7143d0649691ad9586cc9c577a35070198eb21486be4a9f51013f75bd990041d08ed0f192f26e13783a7caa16c8374c6dd5c51fd8bf4bb251248f3ef7f1f5b011485b695a3830d2514d9532af957363667b7f1db69555ee84593b7ac2e50b134740292295f959298f8185deb3c7f799776924bcd1c5eaad003faa440ba920d076f840badf18362b9f52151872d2d6788e05b69ff0975e16b82e4b296f3a4eb23b0d12e5f59fbdf3d4e99304efb271276b551ee6c2f9db620ef10eb4a050043a9040948d9e7abf514f8a278969459af6357f82c0523dcf47d95dd1909062c8bfe75e61dd3979d85528980571b28d8f08942ff43e2b42112bb9edaf5bc1122415c1051d071a61c9583a95cd7250c489e98a3d15bc58612edbd3a61e3a313730e8f7beaec71990471431d94b9e2456bc4c52b6cbdd4d13332067f8dc41c498f36ec6b5c07e4e48ec1857ead7c65deb79f6bc73f0ff139ed0446eb6dce8d8815d6b43e501f87ae9c4bdffe59536e5cd35ba888623d9c36cdd219a4cccf477082c3cf93a2faab0247541e8bff61ef93e0f6ba8b40319a06f599f750f5b958d93404972fe4f1f2c6a4e3a52baed757be0fcfa3c51f22898ffab959d9547ac605da21cb5544a9695db5422e6412b61a4e72861beebc6093758aa76097482cdbd9a472fc93b652e4544aa395e1fedac0a492a4465990b41362cf59bc87eea66053f6360518150a32e112b135d96330b8e6f2ab3fc8568750f5f0fed746283c2417df20826f74d4ac9d11164e6a06f10e0f0d39cfd2d0c41d04590cf5da8cedc9a7d225d624eeaf96739e95869f3adfbd9ec5a737f6a300e9300e0ba72f9cfb10424d73e8baf3f30c5a1aa14f34e05d2896247646af0cef05f470779d3553f59d974a62ca008b1f011aee9b3974f5b23b17edf684f07fd751011ac5743de5cc467f5904927e3e159791bc05f5b6801bd81ffc32806bafd68d0862e57ecca6cdc65ca5628354fed287ed4cbe9c7997419d990acad22478b5b6407daa3c06482971803906b91414196c58f298fcc04ead4d3f9ee853b7a96b5580b260d3b23bb3cbe1335b0f7a693cae3e2a43176c6eb863faf875f5effb5f4292dfb7bab87d68950be006bf852beb9873a4af311236a9844330f42475d1941e970d36726ec508f347090d45dd2529a1c98d9bb73e794217c6d1fbe668df5c4bb2da112ede2e1656068ea42488698f177dbda551752b2b493979aca5854384a66380f6c1fa376536dd232a795767d9584f903314c2268245b091ca1e74c7b6243404d4494d0867996ef158695a853f24bc2f1ef9ef2170eede2c3d93a7903037abdd4d421e96212637ac36d2b6964d95838b1022aefc5e9490e01e1fa6e41fb28c46417de81afe7de9a6b3b4d662d15515638c46365a2988ee3cb5c05c0ddac3eade09530a1416cdc66a79fe08d5987b5eb2c3433d3a7d881addf4c814f4e141ed2864708f602b9f4ac2fc33741f48ad3db2ce5d56a07441471b6eb80ed65606fbff21473c90536027119daa441abcfb77890b8874917d210669ce69a96264b9c0ac9df00dcae4042009cf485270c5b9e63102dfc5608f60838edd39bb3104cad945c489f1b1edb65ad1a12393a3f1f1809995762a90a01ec4d5f11d3a1beb2cff0a26d1c8bf78a09d2fc761d5366369ba5c5322802339ca189eb0d4a8d9dc8ca1012a61c1f2064d58a128ff64eec27e46806b8ce079b3c3f168f7d57874948b85b753c8990e22bb0e0eaa090a6e2b6cea5d896190ad4569f7d6d54ae81a7fd87dcf1c6cc0832319755113a89200f6656db1879e8d09c27f6a113ac48c1d2c99a58580b1e961adb6a0f1b498e9cab2d26a2837b8e0918e761fa69f1e4b96df2e9d223fe9cf8dad1a4e038137a056a34c437d6626ed19078b730800957160354bd192b179923d237d3aaf6b0dbe3f7dad60bcaff17754488a958dc34237f07bc96f2d2e6fe0f48ddc48fe2b38a79c024ea61c1187ccc20fc046ae6ca9628e10151fb96ac46f41f22ca7621458f9f74549209f3984124744def34dc4ef99150e1bce6fa75e019f6ca1fcce97cf129f771bdc13af2382bc0434f7d2b809509cd22b2486a093098a9e131743ca5be58267d6e281e75602aac9420d9c9aa94d77f2b084c6469635746a64c665413f92f5b9504c41f82c0d666410891fc13dda5f214157da30e33f35e6a8eeb9c490dd138e817beeaa723f3b90c2b452caad06294045d1fa7fd1bffd6a8f52a37cf460d900b6ab3ba225c1dbd715dfd4401a22bb69cc7ed6161c09f2309cd5eb1f3a8182337a697d0f8a563ddae9069e7b792e5932f19594db471ab84b7eeb8f9f7a94b30d56a31bb998547d131b2f59ccf04aeccfa94610f1b4b3580c5a1f215a16e2783bff09147fadd640085fb6a36abe5bd3794ec58363d3eb4b3bd1b08abe2de8bbe7a7c867f0a0be5c1dca5a1bc9ddd1976605fed6ef9c196e17e505eab62f16cf17a4f78f52a67eec2429c9c823ba29ac5d235839e013a3ca8b42396c0bae61bbf44ea646b9825ed4a5e579e0ecf44fd628d1381db612d5cbbcc99145f4d4bc9a7186658ec89b45a21399fc3b0d82bdfaf4dd9fc315c9c230b0b5d99f48e6a5fadc05c594e861a1665c50676fa43c187c9735439cf9c3f37929ad302a9ff3d26e6f8b2cd5e5c1cf75a8ce3cce176535f077942abb48368e6928d690b9f257229a4c75ea9a56098fe963bb550220f4308df02db560282407f4ea2f3f11eef61f49fa4a3313faa24bd5a97e88fb0553b3633cdbee4e8eaebe58999cafbe305d731b6e5c9c8ea89d94973c309a65e48cdb60fee16ab81d85a5c53941ebf138a181ea823285c7737a7192672ced25cf094362ed5864faf2671b0e3c0cc9861b17e2e5546dbd85ce85f589b2e32a1d7006c15fca53e5a1bdbff49c2580f4cf683ee3932f2740e7aee896ea1abbcc5d4d75586fff018fe05a0ba56d2302efd8a4facb6758598e130103fc4ea0c98a1de3656665e2ed9766ede9b955287a1ac226c65fae09d779f6c1863b604f647d4c73ec6d66e4cf2a6bbc391bcbac66e15a522b25b441d830683374e4196afc84a911ed559f3883cef978f923278a3ae5ec8399e5b6f45892f41f6c704582a022fc5adb7a44ffcdff45b41d34cbc0d903310dac338d6dfb82d3047d1a99f71e44b63e0e677a849d928548e5b49e5c606dd36fa80a697ff2c4bbc4e3a604468abe740a38bbf0eee1502201e209316c278cc6149648385050a3f6151e5fd94e4fa908da15f180349d771c0e07a6dcd1420c5ee7c0538918397ed5c3c54065305a8f7c61d17154cd152617c9dd8f05886a71448e20614f9bbb912f0dd4fc479048438353c79fafbcaa0c62b7057c98e777892b1c43d0138cf066b41b535fbb042d1d6062b9764fea4b73639a4fa6fb201eb790337481c3312783887d3d8fcebdc65efc49ad8c7f170b9f7d726742339c4419fbffcc06de7005398c4f21f71b352a3c18efe959fca22c8572f8b82e68054e66ebe6e863165c5a21328ecdf0eb28f492fadee8f6161269784a78bc0eacafe32d045851a1609b238ff086a084fbcc21c4d403a0a642430d69fc3f7b6498452722ab92d07d459c9a29d481b2abe4ee8106859eb7f76e94736223425703ea7ddffe496bd8a37e5175717e8ce51f7ea23da651b33c131160be3079618706091c0f57f4885091267f0ad6a02b848e77c0df8c7b3357e5c96c6c0732d977ad8f29e2a03d686bc9f19363fad7b1c211a8cb166db8d0d1ee2308a92e021cd83ba6a9edba5410ef759cdf165c8c7d98d950086032cd2067d0753a7306ed49ca582fb5bf1e2d23d93dd4f8ac8ab450007ab634cdbabf2ad32f97ca374fd36a2bbf6cbbce31609f27d8b5e013aec3f43d3e13aede39697b7c1b246cfa30ddd0c5e0604d4b5b92ee8f578691b1fcddc559dd67431f137b91e61abc8ec795107166799558d86d3e1e871b0753db5119de720107f227f4063ce82b652da732e8e8e658aac285f47c1b6c2a85fe35f773313a67ddc3a95a0fe96c6e8f4e34084174748866270179680b39c8298b3051d84100f7809326f671b177e68536f138be65274519afe06ce68e2a64ffafca7a9b14d89b2eb469c7c1f04e0191fb737d79a7f3ec0d9615673f62b0471cd2d2a0bcb0da992709ac2ea51c95b41e697c9646a71313356fd0ca6efcd8878ee9184e1a9bbf2613bbcc41e0bf0c2a40f339c24a684ca40b067a17df4b5787214e8ab85bc53b62f56c9d6d13847f0913598900157af0f70f7a42c04f14b41ee1b8cb60e7ed1ab6aa0baf63f631cf8edc79a6bab02db7838fb22ae2f8ef50dd08e5fe2d72505382f6df955805ea33b0baf6ea369db42f2f392c87acee7ee41e4205693c77cb1d63a0abdce07ec378ba5f8f14266df623740e6e5d9cd79d7e0e0204edb4a4f078454ebfb3b6685c3c762384dea2c47c9af54b0bc0e6039e0f047cdd1cae8bc4c6fe6c6f93f496bf5b01ee7497c850f1b545fff28e6afa13f650c064133301bdda85af31c643bb38541e53e310a8543f13b84aa66a085a17c7da8c65c103a9023b5a1164527ab3fe8c9aa16e16fcb8d2e3e3adb126da7bb63dddeb6bee7ed82c4d5a8c2b8afa75d7dd86491fc84125602a9b7c8c9af03dfde1d307c61d32ec16a13611b337b31caf137e193d12e80c8cd7e44ba87aefe669c667b4abab81bb6e42331b0b3cdce7c692729a77ec1e5d2fc1fdfec297355601f7dd7697a4204c4773cb80382f9bb41a328b1863d9864ceb75f83e89726d5b0d64f287ba2758556acd8aabf1567ff3b79d694ed0a0020adafeb8e7ed35575e79e0892e3add2a386cf863f8b1f60e2e86027594c2da7776949eda01e7162b5b9095adee46fa6b6060329efcb2eb3eadc9ade4708ba6a91328100ae83b2a6f3ea14f3f159c2c751f0bceda27260095dbe52ff9977be58a3c82dd19755771cba6a542fce06cda1cd8fd010c27574799b0d9577c7cd8ada8e2434cab32ed9969f91a31695623d28a6887b0b2a038832bdf4ff77e53f85ecca42753c092813c989d39d5ba0bcfdff1d4db8d413ab3003676be9eccbe1b29f79f9477759bddf73b837556f108970db96cfbea46f3f85b1df6a910874eba3884d2844584da6badbfbb9c5713566539a29ac29105ebab3eb649410051183f5d7f0c20f68061b39c829e7605dc44fec9119ea6f22c5060fac92d59df90f1e381761681af432243f4a9d4bf5dd3fe54adbd7a89a2b24d466ac4e4f0e9c8e1bdb61a45a553c2321ab22b040d87de5e4e176f2a08287a661e8314178fcd07571d1befaad50a554a1186608ab6808f708e37619ba85000a76328154dcc7bd688ecbce283f0a93da1a3a3abf2135185c88a999d5a4bfa352e98c7453cd7910d08556d96bedaedb3423aa77da48bf4ac2e7630025a495b64d47b70d14f63bc126adf7f8c7add9cbb6e4cd0ce5ee368ad548e7eae7c207b8a9f59c6cc8379cca4c23e057ebec5c583a34f19340ecb5f2c2bdf3ee7d97bbb3f96c084a4fdd41c41d61fc77d364989b797613de448c1928dd65b34a345f60e376578b0ea20acff9d690cd3ca7f2a7f549a313c7b27eec596c3b504733136f6901eb55469846e6b2238561c9546d84ddf4758eb804a9df275ddfd148294d424c3b917ec7d868ab8afd4917e9484488001e520979f747d76c1f02f753942738e839300c8450799150003298d56f61bff98c5da4cd5bae957a8d046fca08c74e28404402507a922c8b7e0d6fa0672a00bab5b5d9fc6d5f716ae9042cc5b2bd18a7425205f1e5322842162591937fa1225f664ca9f0e4810bef6b4bef3585afcec9fdccbc406be02d59ea0465da66d285dd95647cdb2e46465ecf31c773e8c65b81a06bdfb4cc7da18b9e39fafd627ca90f11763ce19148c994bf3c13f1413a98aa011ee95c00a2d5341ea8970eb400cd2c4fe0cfc0c0740ec0fee014c2d92061947769db7542f1283c77d4073ca8bc710bf354d64bd2852fe780c7b0d8e86c46a88b855e05054af5418c9d35419f47085ca0d3575c4ce4385f7bd88ac62104f7c0ef88635eb7b8b7a6b9b14cb411750f82a1d1d10b32f8db99509c003d247c562af0644f943953cfeb4310d532c23c87c29f4192724fcde2334471e46ad73b0849dbca71e4ad5f08245d7743d8063d37fc587707b45dfd35643593f6dd656f9e5d01832ec8269aa35e440702db509bd1321ea6ef19ec33ac7c7e32dd952db9e353546dbc3013ce88624c59ccc7e3d227ca382910646dcdaae11a1fbc3a4e7466b7fb8b1990a2cf1927ff80b124ff7b1fe82a1d2be2c3539332f4aa093ba21106c3a49fa9cb18a11942a1f93a7097c898bd35d6332049052504ac4eeac2f05601f6ce738e2a28322d093abb754d94c1ef902c79b3d4fea959867fc8f20eca11d1b74c278484367c00704e04dfb85156a9a834d942e56451c6fb9beb8ff4ae9d2a97c750d5075017f4ea2656ca80c1af2b6b1fc75cbc0cdd029ce875be15479560985e4caa01af443094a68f6c4f9585efae0c680f55854fdab2c4f89aad86dc2097ee7e8e0bee3e537c8bf1812bae4756402e68821fe9212931cdc8b7168808ca13aa8e6ef23d85cb679775655a9d1eefa1271d8cbb7837b812cfb6f3f468c920c4f1c90f413d7f650e9326b14afaa7a6b6b6c666f2f460f4e0fd256d9a5b5ebcb6ac12cda7e6db53865264f4eb247fefb1a7009e2e8518ebf9a3eeac77e849f617096fbfb308727af08583087e229140c9aa734dc6d22caca829165b40916316fb81b95e40e5ada7f69cf85fa6f57e2a58372a474f4eaa64057e45dcd0ee2c97bec0b3c780c8226af9a31b27b2409f5e97a586ad4dc6032eb24925a5b15c8db4a786a2671b906e57c4bb28c72e79afc8afe90e91b4f364d7c0c94576b233dc71509d711e9febe3e3cb8c46337fa2b282b4244acd10338f580a44df09e21129a8602ed251801c5d6c9deac6569afd9611fb0dc4d12e79707a7bab60e4a737d8b9328f0139cef313964c813227f3fbc9d8369ec9e18f7ca7586754c1b58ded1df656422c63faa8ae8fca6dda234f6d12cf1f7a23700a3cfe5382e718a814a09b93dd0184d0c5dad68e7a3e431577aa3a537bf41762b3b8e6b6a0072bec643841612c58c8bb55fe0c044e65ec3a1aaad7100c9b1539ddec8a76c0a08e910bdf91ebce51e5bdfb20877b70ad925590ecc2c1c22f82b62a7f80a9e428799c9a1c2c93499430b90b1a04c50bc4a8c181d657a764c3b8619d3e36e9d8526989ef04f1b5d342a2d09f2a8baf7f67d7e9bc79312aa742554756b77802d65f6b96702774acf4256807b0c5b9aaba0012ec8547ad019c40ab7f95908a8403d8b38a1023b67d5a42f201f00b785e3d03fa07ddbb69d524d3c38c0986ab15db02e2c6bb0b8d8365b809aad87193b7165df2d80cf84507f60b483ed74a5ba6535ecdc28daac27d2a9c4be0fc083567f7c7e17f6c99ff3692ffd5fe57992d952630dec042327d6e0a473a1a08cbfe8cbe9dde4e7c9dfcfb065d1a3d07794363bb09ba1c303af79005c58155f1a7bd7c59c4ac1ecdffe548ebdef3ba01453bf8b4084b0a39a616c4e8e6963a80ce46a750280eee48a4f9b563de8ab63929b8903ea59db792d5964caa000e784b296de24ebac1e0acf132367631db48bb30eedbe208ac91d1a4bf4aa4d0617706451ce2f4772c69660aaa762728fa6a12d57c9fa7d33d0947aa1ff68a6d4492fedcd99f5567a29ae80fd9db2498fb0062a2467c3d2ba76cc97dc47cad68913095519e09d17da84bb496a9d0270672998910e96accefdf87ec748dffcb0a251bf07ca87f6092cff72bf2087c6c2328a9cf663335e8bb46465cce93cd78c9957f24227ee6de93e7399bd4f9c651b4448584d4b9994f83e7880f4e26e51d1db7a82d50c13db4f78888d9348caabdf454d255e0b5cb09a97474bc74404004009cb2211590fd32146ed9ccc0851d066c376d0dff0b583f65eb91d6f3f3abd11e3676eb4b3669a03edb1b3d1a181b56552fe8b80ccec07806836e50666d7bc9fbc064eb8609d798a262fde1105c4c3cff35d91fcce884fcfc80b54f069d0401cbd2acd9a525b42224508535b5c924fc8164e4f9a2f4134957a29470fc88c2f0ca9194177f3477aef64c131d8114201e3574475690b5d54cf6cbc89d84926be23a948b15bca0a68ad8632ede15b1440ecba387a1c907790930e99b06f49b5a89573816f4533b1c275d082786d3ceeb4ce4f4fd54013e353d29367e592fdb029306fc212b73f262eab7c378b04d81dacd836945a9de3f444888175a4398ac4604fd3ae137ec4bde3732a288150e58c68abe1805c4aa506cfd6bbd57fdae495b0ea83b7df8aa326d4fd31b7f9668a665602846e0fad0157c8cf8529145dba019c61af0c0b1dafabc81ccc105870834de1652d5311608c2bc239a13daffab262182f840215388faa8834f8b2e94916c7bebe134aee174a71a34c80a2ae616ca77e0f92bc4056f267c87d164cdb92665ff2805c75916c76fba0735750cddd5f730e707d06dc98a833a267cbd56963f21f109aaca3136b94f11ce6ceb3757df2e03e17b15359494306063c5ca37c4a161172635b851ae2f57e9c565d57207b0f19a6a39b48dc4788014162fb91d77c66beeafb4722f2115667134c75887360ef1832f53efca2c40c115cd25b6776c5eba6ef27eb72d81711ad2ac7c4305f692cdb4d29fe0d285a26ce542822c22532a668486e7ba8a053a31860f5f490b6a3a5afc05640eb4bb60653ec6326a1a681ac2ec575a9f6b82d2bf99b6ec013e2c0f106fd97140f2b062c3f336b1d7faa3d98c8223c0dd6693244209101dc8244af27f5c0a776825cbba8d530af5194eb93e4e3386118369c3c6dcc2d7950c37d3cee373a6b022ccbdba87180c2d477d0177ced9cc92989bce2769b81f4fcab269384a3897fbc0e5d3b4339cfe08e8b5187d671450ad0b383ca84356cb94adb69863793de9673ee59490b35b5d71b8996d66d6bd5875c7e736d3199a1801e8c0e080e580a56965ca3a16be5efd94e2cc97a86f3139462f1c48e220464d51b9c5974520fd8fa0a9ad2c36b3a51070b01497aa5a9148fc94bf0a6ea2486b7593f193989ad3bb56b4a238b0aa36f01c2a01f65ad86405d3836a3974342774fa52e2457f6e0b00871b3776679ce181ca1d81211b7f2e8bcc442329ab3336ef7ea8dfbe9563d0cb702b88683b016e6fc2ef4960e21141bce60315120065a912eb474854d2440d81d515d3da5796b7f0619a5e43a3d463903d3e32ed693350ba984ba7ea7ec4c2478a502df5500a4a9140679fecd92c1cae50d8c0d483242dd59be4601af3ff57fb0029be432e9521e650f7555136ab1e7e8b4736f55f5fc413cb83fa5d39387ee93ecaeb6e9a0bbea6f1b59020e71eb20d62aabfeb402d9aed39968437351dab94ed3357038bba02df69940f33ea475b38e701d85ac743aad9ae410a7d4a2dc1c52f947911dde117a5a8605e395dfe95b81aa9c57e5a974faa1d4fe7897e7a4b00b4f985ea3228ee93dd5dd79bae9250751e32d807639ee691483cd172c8f6354fd5f9814255bc258c93e21873fbd37b59e40de6a3c5a6c93b7172c9ea6a3a219bfbb789290e48a5b1acb7358d66bf8657451450217af21fee1be9a94287d4aa412c82cca6d01b93e6f6de725136b4e547dd35914a845849ef14fb0d4f342f897f85892c923312c35a05d94d2ce5d18167f04aae0ee3ef84f0a5b3ddd210a4ce3107c42d57dfe101816991df0184976f04e2bf18095fad7470aacccdf66bf6c7e953bbd13cf6dacc5a8999d5cf80d912fc5d8f446a7530c1093a5a158e1fdd08fb354f2caef6e44d308ed765d9d3874b44a7126beef657bf0170262de4ac31d63ed86ce353978c931263e9922ff64cc1d4da84b93b7076152afc9aa8bb02a602b9cb879e25248270a48bc598ca2f0bd77e743dd34eca041b42d7a2add1771da990a8e67e526665febb85d8ab569700c4d2c258644124c67ee4c61cffb5ca35e652908eed63d5600469d7b5c75e1467a5373ab3017de9243b8f28c867769298c57194c6986424bbaabb64e36e55b64ff2058d1a9b2f83bf31040be1f8de4b8bbc269bcb8d79a2b691b6bab4af1ae8612e927acffa4a1c22db46c341571f7cf5999c778519280c9cf6531b0109f94bd457d926b8cf6ae2b0daeffd4b0ebea71e1bba8c267ed7a8febb4dd7ffaeb7b77348ad274bdd57cdc6a7816c06327d69c99f6ce69dbbb4494205d1da4bda115ff12fc417970cfabaa7456b5bd03486b9713c971c5e1da0d594803c1321c69c907dd3ce6e22ddc201822b90928ed6071d717f5391dd54b3288ec0190e076612f03d9ff4a2d4d2c71882d7ef110dc2c21a4188af7e7ca7f7e5cafad78e046d00c60b6f970a68ceca7bdfe10a5978b3bdc6667452fd1f565eb9baa0d85b50f0f69507de2dfbb97b57f86eed335ff1d83ef41367119149efe540ed4caccf0214dda5ff07e1530b482ad5a0ccecaa090f95595dce37fc5291c5e2a7d332cf26b969bde4bace85800b40b7f263e00e2d9884e9c851a6bc7bc1ab2cfdaa1284b95dd775aef73254a232dc458c90187fb3b09fa74e9ed5d8bcba3a700edcf6738dda2dec305c1e4a78bdbf48986f4dc096e1252726d9a06de654bb7f02dee7abf06af9f9ee425708f4bef53f34090b7dea367c1221e72c01af4ffdd41ff03957c2d34565d0404d43d58f763d521788beac538a151acb1d39a64743f6595a10a73b85ac819c78341694a14f7004e0331594a235157d4eee3fafd481998bc70bafe6a773bc41dc8b9a5c41cc348195346815528a4f57382fe83bf83156ba1069641ae18b64fe028553313b69a3dabaceb03227669e92461427e0daee0b724827b255b6653168626594711f712a4b5cee6d7e5cff93bfd04e9635def6e63ebef43d824bf6b8fe0c3a22b832ca2e17b2e022e510b0f5dda67dfc015e981cedd8320d47883a2e66c887ef57a255fe7c9f0e1fab07b3a57a197b8b2953d84f88a57904b506f24ddb526f7bc67bd50eaeb9c0e8fe8b5450bed4ca3137e6b88f4150ecef6711b998ea0eb9e2d53e758d004b98baa16ddd5d693284c95195638bf7cd2adc0baa330ce522757e4a7e9d2664721bd4a9bc30607a70dc9096d2d8c2b5a44ed1b9b0a749d96864f7bc30565d4842b9447ba7b2834bcbe5a2789353cc8079403dba76de8fcb2ce5ce14c6f6085ed5bdb6974c2f9db09b46e38ccd08a5101a3414745f823a5b8611f59bf8c29207185658621b0f8e75f7f2bdd8be798b7d6bddb4a0e2e97ffff1b8852bfc899103046dbd867e3b844cbecb8ef6b900999e58cfb18210d3c4fe357e0fbe8f9c0cb808c0b6eab8461c08fb3a278a3129dd21a017827ba7bc0975331bf1a909c73984fc3dc6003c1bd0868f66ad9450b85173a79e7ff14d70ec4fda3934819d8f2bddf284107246c8fd956a0ba12b551f452eb591ad380fc31606a53bebd4fb40b643eff34bae1d8b044ab43e5156eb69f44a6c612d01e1aa19b9899caf4a9d2080d51a764992341ba4dd9b952d9adb629b011f141d74588bcacfa0656947509aa8affe256275ebaf17c0d6488d28f75b91bbd1538ae5797d9e6e44ad47f804f1d8c44b0efdcae5ff46adb13be3a093d2d6e193fd34e4d7d3efc84deb3358f94770c72cdb2d5c278a4917b85b93bd4ce8a3e32e37fe5b5ecc953c53e560a29ec10cb3c890602937c128eac52f36482fae8ee17bcdd707db2a377142bf2de9fc15e560c08d8a1d8f65aac97e91155a5d23e73f8afaba864a57b22293ff06be33b7a49e186ca9a26aa0f6ef28aeb67dbffd55b2acd04f0c699279b35da26faf8d55f127342902816a190e603cbbfbbd20cedea9fdc6183ed75309842194ac2c4937304f776d4b70b454cd406b49ba9cf8feb572f46106b0e0375047c9c69edc4ebe8ed082f1189f8fef16b6f0f72c3520704b3354e1a98973afb563e63f55f2b830e2512e7bffb6b032b48ba1486b6ad9f8bd4548b4d479209a4444e04b5feaa91c2cb4cfd012c7d7150ec676d4b96f4e53f669e61c37e3e4667a4bce2216a761159a18d12f92e3da3a7bc3f54cc6435a707c1fdf4005b9ba14447e4bd382bf4a650849329b7a2c37be909a96dad9a33ab548e8aaac3b87b4270ef6f4a67102cc37b565ef44eb20b1ce998f2cfcaee7e98fe6e07301c72a2d6658b3fa10d819d8ffcc00f829f2087ab0148d95c8d23ad581acf4fb5091b3ea2e4580e89d837f0a43e178ace25aa720bc7aaed57ef3558d184d11a454683b9a53ae27ffb44e360b0f23f7bf12be59ae6eb34d8fecdc8c4ed9210e785e2c498c7a0e396da1cb936c41e0f9b7f5438d2e3985755d4f8717b13463b5c02fba0a92eb4ca14e41a1f38543babc62c8b9ac41a3e12bfd4db9de3524483ea738dc6f57d68a96ea63e5c3a1e0d7182a742b850963ffb1273a93363e4f250767a4e9b14bf34b617fb30a65896de3582496daea1ce224baeb530f669797e53b30160d9e7f0be137895b6bb78ca00240dc95649331f4ed9fdc961e7ec17880cc74908e00cef4265fcc07dc6bfa928d06b2a0573d01725aef37800b7c058bcf07afe702c414f921fa9600592285af1d1aba4f7be4332006706b0e50e9e7bea0735e7bd65234cac52a9726b33552452b580c79643c12086d6c9c0289a2131e39b4c0ff4a2ae71aa81a83bb2326d592998dcebb7a727224676763bea6112a0ab92b23689905a984b7729e970b7b3e5c5e464e4ed73489858a921f68ee34a70c99d762b174b11caedd34b667a61dcb68b1b650b87fb458333289204206c545ea8bda5209ab43d40b8bc84246f5add973c919fa57c8fe5519719fa81db9cf8781466802f80cee02f1e3f441f5763848c49ab25f4ef8bff9b1f8b93eabced58bdf9009dd18ead5b69f7e1b7a9fe18ed84f3a134e11872b337a63a45fc645998ed1cab3911fc910f0cd5be0b200c5aeb29a78e398b4b1d67a81c8d850883b7e9945a75372ab69d6f8fc9215b577882f0df3e5035c4f8af1c4c24d8a76f5659be38732beb2e66b606282368b2210b9d050aedb07fc4b1a7998067467b60f944ef6d014a4677bf582760bc4ef484e5fb8ef2a972158644596946ffa1edb6ac189d41a31949ec13df3e47cde1029fe66b11753eaf0c9de232734ecca0966d1335453bcd055c5bba516c22dcce6f0e60be31111eccfd21ca36165e1d8bc591cfd4e4e9bf49382a6bf2d416bf010ffb7f7755ccd7d30315339005d0a16ee2ff68e63365833ded151d18deb0b8aff4e4e0706c2767f8d91a026b0c013caa601a5a0c8784e5f352e844aefaa6cb972491944fa6a8fb540eabfeb618b14de93cc1da75e00d730f4d88484e356141b2d072ea37b104448903651f782e75bf004c26b497d73d32e92f5703058c345122984322a9089bfa9fe3a138e378695979303906c1daf3d734e069302d81131b04a0d3f0aef02d0a8a77e316b9b31fd0eb078b389133021179f723a18f9ab944dfd619c3d7d3de65e88afb02c57714060e70623e463fc4e4b139325f4f8c324ebae59e582ce612edcb80af469c4c2a1e5e3fa8395897fe758b8956746c06d4ff9e5ca56c73414677cf2087b161e27f7aefe8315c452cc3731a767b171eac699d48d9d8b87ef8eca95ec188990279b1e59e286248de01cf31739e1074da6050d6a1e33ab4f822e51e0271e412bc164fcb93e6cffdd58e016a2973df0d27a0709a21a496e302a537d45d422f86782c5e249523939e7f0d9dffefe894603d7b7ae5534c0d8e31307436a62fab8aa6007072d2601d76b5ce9beb782214ea15d79df5d1b095b8cf4a21eef3d0d8666af79c5d2e605bfdc1a9e40c48a87d895f8b75a12cd28d2b75931cd21840c2cb3379ca0d5a932a887d4334728f407477c4ffd5dc77da8cb592fef2401189c1ee3cd4126560eddf7dfd0ea167125d2865d9a18f99bd4197b81dd349a0a3ebec42f58873a5c29c7dab7c8f798f77453de85aeeef13032389491f3ffd12afc9044036b4a7ecc8f1892be7edcd14aa6c9d6a8f4e66d059b84dd24efa41f78acb82821808488bdc5f3d52836f4d4abe7b1b1af64b1f389791fac86e3d7f4744bbb09e5d50a33920611a65164961ad3e4ba08b368c139301cf042772b0d004efae3e89e25ec22637d83939b964a3f09235cbb295b88db7c0b00153e71c5ce1c463c89323992da26a4f256b3ae808207fda106155b4dea9221d769519b9c5e67c4f738aa40cdafeadb8ce7659f7bb2cced24e25542dbaa618bea40854511f1cc8588665c2a142f8faa7629e7b98d40454ce6898a105a07eef8ab98d45413338b56012c77e128f77b4092421f730a881843f80a5fd1c6ff994373c408dc4d72c6e073f6f6a63177b0a4e6e68d65613a4a921592329d1c402a763473c4afa9ea1daaa87723af46b66afc2c1bb4879add33c93ff5f71f23f234591ed244abc464010e427c6ebfbac3d01df245b5fc448b2cdd3bb2ce3a6754c3ccbac8cbb675a20a3fac22eef7fbac324491f8ed9265bf16741b48c4947e6c06b7e06cbc3d588aabd9b39d40e0681a1a5fc252bf2df9586d5639c675d78dd181dfeb3898b8efc1f2daec7d695ed0b3cd6c19be48e4d7a07c5382983c41c8f8ee804b28c2202e4728fef3178bfd3bd9045ac8405b2b4c174c050783760d58f7535bc0c7e1f70a5fd7c9d89c1f21387560d62486b66ace1670faab7a5e2f4672e9e8aa334226bfbee5fed0d9e946b940a6588b408b2e7821ebe384e90f0eab8d87765f86c924e84561b12dc5ead7bd370d1f7d69f30cadfc45c526e587b658188d9a8df6418e577dbde09c2e5aa9889f8aa356066cfb2a7a2347b4529ca220ad96f9c033fbe0354fa3dec2a7edb45935c3ae34633291da79dc4e86bcdccbf94daa418e437ad7f83fb21b912d0ae181bb5b5f718132e5d0efb22e8aa31e9838bfca64497c3cbb70939fac57b9150fdf2d09ec02a5397f0531086ad8c06b163dcc218ae08d8fca25dba9a875ed8e92d12f2c642e3f7fffb5285d85bdcc8dd2eb2a32c51c90be7a36c0b2f58e3fe0eb729b6cfc19d99d7880c437dade202d120ee4c551177089cafb8b5505568fbc627f8fc83bedf3dbc0ff730de7a2fee5d2d3ce6b2e3b39c98e5b693070b25d66406358e427c16f3d7e7ceb696520770cd944796f55464f7a40a74057a0b8edeac5f767e9ae8429651cdbe93553f6d20d55d3fc97828ce1e65375844b109a8acddfb28cbe040a4b88bdfea454c2b22082c22ae97852c8e5e13996043aef4dfb3d002a3b2dabaa0cd4fa2c310234c2470d8cf8e815aaa5cea45314adf811652692d564d807fb09f217536e0df486f0dc2343923f5d0a3ff00a1361f765e7a4639eae2a747d14d32232ed7103d8bef3b40922fac53481f32ada561c9b81d5ac25f81bb45af3a1af132eb4f1cfe8cf69f7e02663eb6ceb104c8752916a5f04cea448859916368cee3e8d4bf20f4974c5a4f4513a6c8c31a276ef2df4f2b1bbd2f41e21f18574ec09675525c02db10373b229614fdd33bf202c9a821c9a6b57547b473b76caf28c3b53a16f8aa78a2c44294a5a93ddd7dd8b7cdc89f14ce47074ba667d931c6c1b6043abcda1790291e171dfd87ee5f36381c276221a33a472d5686c1396deb7920c8e0556f189af55776df933ff20c800e15e86ea10d86577e235e2bbf1010252d38a468593c4338b43e3e9bdee686d2edcd9c2677c64ec4b326b04d99d9a8e5cb4586b4c034c87748ed58ddee0fbe0de3415a74074b05b1993288ee18d1d55df0f8d9b4fb4d78c3d0ae85bf8bc2c228a64a3e51ca1c8b305bacbec5ead9e49a2e490f6944f6382e3117bd52bd128cd9548fd5be4b45e48510eadc1e78114e465375e746375bd6b437a66f759f9f738385cda6eed2197f0e7477b675f11ff38b9a5f8d75726048275bbe915cb0f0e8535567092c6ed615d2b3f1d9ddec04e50e324548f1b89b9ccf40a4b0c40fe7a1ba1647b709c72b63c5995adb7f42c9a1e56140e5c68f4db64a4edf4ab872e6cfc174fa893ad301b189da38462380c8bf6f32c0f8cd56092818fabd2a4fbedab39d64fd9c138a56cfdb9ff9afecba2dbcf99fd28b8c34a7146c1e32c00faaa55c14613c09393311becdec300023ae5f57efbb6e19bd1e7e02fd49af8b16fdd74504c96f37dd4bb337f80ce5a0a3d3aadcf60dd7bac4f74f9998ba5089c1892ddff1eb7f938cf66dc1b433e25db899d858b2e835f7ec4fa13a833cb007596774afecd21524a0e0fb7c950b7eaed7283e8b4828d5eb25f9580db1e9ac548a151f6c26206ea2023319e776a85bd2775cd60cba937a9195710e33be33b7276ea311c1bad9054e9a712e5a5ffe243caab9ad279551d510b36de8143bd6c28b1c076a44a0af3b50b5424ab378285bd08e64ebc5fcd2020c94ba35080af2e4fdbbedea8d91cd2751442ea32c7c5eacaebca068cba3594e60229f32a160ae958d3707534a03aa3fef553ee608f0f08a4d083796de9292b32ac5f73c0d45fc5d0787902e6e7637d8369ba48b68c6576da9f295324df480082f811103654e17187efb07e7c305565001d443ff00d9722e3a6d633e304ff97ca8300a01a4b16465317d3ecfbcd5d2c3a8e4671695255e829c54c59f3ac7e498140ddbc3b0a242f06d0492bb92c3ec432a7be5876a5852257b7eee0bca5b0ee1a0341f81338e0d356a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
