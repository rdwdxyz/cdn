<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d0026a61b78850cbdc353c26afeb3f983c154b4709b473038106db5ed1c871002be085fb621278b3ce767a0c410118a8f2f0168059a48635614f09bc8db8fca47a4b0592667213f1e9d4b3f0c1a7255623247888c7eda2ec4ce8709fab52a156c9a0a80caa2798f500e3bddfee7582c75acd98239e62446bde87e8d254bbc32f9a91fd1877d0a46ea612011870653c805f325c8acc60f71728fe230efe81d7486d8f1357852496373d7273de79cb87120d580de8f410bcfb443d69f58cb798e7cb8d87a28d8e4458b27cbce6c179bac94d9af7e864bac4187b48cc6eb50cc9c3688715853d39263f78a35c44ec3d6bd1b23fdc9c3d31839362052ac017034c56c870e707cca9e5641eafd46867718f3aa1f1119693689660dba0671d6968c73d6fbcdfd359a682ebf40ab7aae1f09ad5567070b4cbb0f3fddb5069e2d03f0395a2c75a52ee7ed680475df974e664ee3b7baf92cec6c71a2a69f4897b76d1664b39aec0384f8614bc02aa25f44e4e2c727a449aa4951645e1b878050c02f9d95f9a51a050357c2f8ad51745099a978ab31f73bebde61f8bee7acf075a5f1af86c1c05f48bac51b16d3ec9f55765fc9e7b3abb2d4d00b707d399b7bbdf5950fc20bfcc7eb24cce1daa1c827ce6a6e0aa0c47f0fd058694964f7f76209fc580b5ba4d71bc400f02e451b6296da741101ea7ba5db5b27e2a89d0c5853d7b91155805bf19c8e9a82031e1f6053e60cce0a5493f47ddebade3fdff6e1ae15942447efbdd13bad63672573d5bf4a0f8028a790472879090665427ff089e9dbcb45dd37f520675a4c827cd48f523abb1f37ea19a49db44047d58bc3f097fc881e530b40b47f3f8e62615e9770a0ba99ee35e96f23145872d595a3625d1fe06750486c34584a2649223611b16a51786499ea75839d37bd34f281048bafd2eb2ee2e8c34dfacb296a67bb6cadc33b9e33c60d128521f82123eb4c3f02ab31bddf9ee210abf0142b80afd5897fdcec767545f2beb37da65b02bed1c9eea733e3865930d21b1700a3962b33a6e0f4e8a9cd77265555c46d0e0be509071d3a486053561a958e196bf1eec7eb1d82cb3da7ee6782f309754a1b63da650a6fc6a697d026a99e7059952283785c72d7e7aa0cd5b9c59f3bc6052daddec6691f3681c3887f3e5cb258a68270e564809ca2dddc3ce32c10ca86f37466613d8da6b6072d7d12d7c92a015dea25eeb18c8297998bd15002dd0c37d183d640483731ec4510e53ccac21bc9fcd8e04470d1c49c9b3008acfe0eb796b7a21d398085475974af685d440c48728fc7766333c162142f71b746d9041b9828c294d97ad4346f1c767387aa98092c73ee708624f30d9c0ca976ca45219781babef75da66eed86607e63e6227bb410ba4d43ac8ac555ee77482ec921a638472c32e5f8ab88ddd10097c87c843a4e97a436b68d6fc35af3699f96984336459efc37661acfd023c1eef093053c84e3fd820fcb3d3481057fab9a6fe94fc7d9e1fd7fd387c2322dd70671ffe51de06439788a685642bcf06bb95d4c47fc1f3c2eb365765dcc43d909421820cdef89377bf96e9d1c0180d1aacba9ab6f42b04e9dbc0b98c7250ca25bd28b14d4b600b04a22a100caf2f9bd0d1731a88cc6d68402b62a6768d217de7198e9ddfbcf337e71cdf30729c60b7e0cde495a69ac365b36dc2f48717a5c4ed09bdaa91d74c1e60206369a486639c1b589dcde2adcad8392c62c413760c4fce98148dec0a9b53c73e35b7cedb7c4c5ee0f7f028f422518091d4fe6079e3562e5495121b02d0cb4608139d511932fa6fa6acd7b0a9d5dc7c69bc489839d9531d1fea65abd3da1f4eeee54707a95faeec80a4a5c2eb02cbf2513bcdcb5d1669bd4d7750f60be654e0651896ecee661f34406614f8a7299286e518313ec0cae12a72f6eb6711eedff9f411fd733024bd7a93ad78d229e31d13bc9ae531f3e4af0618455d08d969054ba7690ed8acef3ff89a5a144bb9723dcec2ffe90646df2098309bfe4a2e2024254a410f7bda9ae58cb6cacc898a99a6b1e7a4816b5c1dadb65781ce85f6066cbf453ae39f83194fb7e63f669d373bcec16ef61bd341c25c9884eae48b4338b91801cf925623517cd91e7a645ab9569c9d70a8028450050e7055595e628d26698272e0bb5d53604c6d15e4089e36717225587d808c0b1aaaf573cc04308c8dd2f4cf498450a9634dafd804c73c643e4fdb80fd866ca75b0bcfd2ea7b810522fe9c49ccd798a5c2ad26dfe514446fdec553128687cb17d36cd066a310a53d182e83256f11f434a742bc3e6d2bec88f5561f7ce5bfddfce13fc0c627f5b802d8044fc894f899080fc2f4e815e52ad575f05df7d82aa303d03481c8f8d39bb5c4a00ff133388a4c3ec9de30bb5711948262868c33e995c543bfcbcf9040d335ef6f5033a3fd286b0e0aa11b235bc406ad145dba0e0e9ae74b80c50a964a74ce318521073c638358f169adabb90847b27fbc48aa7e4eb7317db6d6e0a7a2bb7613621f976432b8f764e671673c33e4f07d29844c021df80303e227a2f4d6a6fe936bbba15a076b8815f006676ac37973e397fdf74a18b617acb669250244f2bc51d755c2993439d1ec1b8d96e2950d4dba9361b383f96c753c52c5551de673f16155ac0db39e44b6c62a27203d318cbefba9a0a315ae3e7f4275d4807c40f5bb4e0e51b4aadd3ba5714083b944ad6d6defbbd7a002dcc1ae1c89420e3df4709e87b678bd84cf7b31ae8eb8f44472478f66418e7e66d944a2cc5351203a099a7872405e533ead29ccff92e7d23a1a5d51654caabe4abbf775294dc8ef004c11442bc98f004f004ae1bff6f6cedd7945b1a5d1d38ff56ccaf96a39e218e2695f1cbf277609a917219426f47c8baa89ff9f56e0f496531b00357b1eef0fc2afba60b1a907a542a8bfca487d0dde7b39b0daf3b951e26334d8c8c018d22392b09ee6ca3df1ecfeac8f9da3f6ff83c35f581ec1fe1d2f5681799f2f364111b30d1dc36793cab4a51143a5f3e12bee5cad94c2e6a8b7b961d3010708b55dc790b57af3b281916be5f8a94697b5f74c5cd69612f3ef3f5bdccd4715363e9ca74cd7680dbea18fd8e85703f697383cf8d59274e5ee04532fede3c3f608090ed58b0b5456d2790e28f6d152ea0324d54c0af96e7720f75ab116101ac2d72dd83ebc86d84e6e7aa1247ab5b04b0b2179e7b43b3ca1e4af581649ceb3330a5e74102e12f655d0889ceb7aed1c131c79b49d88aedc889799545916d832188a214da8c659a38e808a89223d695bc7ff69a232ff93dbf51f4a9ba707fd25594cee49e0654c39a99af4a1540ab29f33021e728fe19d791c7d0841eb0a28ee3ad8adc26d4bbb8d3f4f4e6b17a32bfb3c5cf007fbe4456e0b9fab9dd3b62af0333fb608ae211e2981365930470169917aae7a08d0ee81a7e76ca5c2d8b7809a7e927ad68360c4dd83e7eaff8cc46e955eababf3e934c44e476608aa2626894323b4ba6548383e15073f0bcf5ee509c7833631dde8f02abcd9aa69bd5186dbc636464a7af866f9658ca3fed624d65362d67dd908c83d72dc0ac358804351a3005932d7f73fd6d8f12804bb08ca47603c60fc2c8efdf5444dcce1207d4b15c00621c9feb773ee932438660358eefb5761adb0fea3a556ccd5f60460be199442d82707baef6c3dd4c7c10dc06fb764248cba76c2b415555f48858cb383971e45d7f6b4e55f9829c6c547940fe5fb7fe6b34450348c3963fe6abfe4a30d23edf2cf26490619231c7e78a872cce1f527dcc797a536245062426955ac5c82c711844c22502e62e1c13d1fe4d0b570bd72a67f6c32963dc5da9daba19a68b51bd552cb8698ee5c0deab438be497eb05f43d36b541121642d7d183ce603c914281ce4e804351b439a9c8dcdf77ae77146c83c818837347b54f4bcafd90c931af13cfad0529a25a85afe58f315ce0de7a338b00ff91093aea86cd28935bae4e40f7ad0fe60ac7b3084318c931616edde9a8a33869221405a6e1190257cebea0911a093b4e4f49e3d8c68d17d05ca975ca6249b5c722a3968f67e08da70208c7d1fa97bd416bd1075b293d6f51d6b3b97b576adbcfd7c52565716cf675c73bc828701ff080bf4d579ee9c70c01fdb16889c9d05b614330ad9c71fe02ac99c30ddfbad373b9ba306200ed12e644b1b1a5ce4aed5b27a56a2f28053fd6aae745746e565df1425de378cd4ac5b7b209d1a04fd7dd7bb01bf499a9e81d066976c0c8ab3b2e1e74741449bdad22ae2bd7f7d94a63d6b3545b6e0bd44bac5b78d78759bd07c0d45709344037382823c9e85d17d26159f1868b6ca891e4f6365a0cde32000d65b55dedcccdef4143a4fcb6f44ee17faefc0495300912fe210b5930bfc4a3c673a4dae37a6fcaa52734b203f5207c3693aa28828065bce0107aa827dff6774cc0aac7c87c8f4795649fdc0b0bd3dd4832afe5b975586c8dc872ac39273d09e4cbd77ad6ad33f11d1d4bea1d0003c34abcf435567fe179a3b74516cf234e3ce2ef552cd9d629838933301c2a1e71833f5407ed5c536f3b794814d1435ced4fbb8e7e27c2bfbd25b7a7e2157fe87d252e1a10f4cee97c86dee2b910efe1db73d0cb7761e7368694671f6cece4214bbff4845b44145fae49c8f7db2efa6dcc3ef2a6c0417374896544f7ac67886bb4df64c20ff04caca76f186358fc62fe7ed6f857a98c6d2f7d460d94e4decff2d98c0b7e0078d1ce745441d64667d3b5faea820f3e224cf3a1708631c4db9ee765172b897bd65d61291e3da3c9993c335e6c8be0574a15eba9c4717fb374b8e01329765be684d95b254830237e761d09bef1636549b84964b7d0cb6fdbdf6dab0472498606ba066a73d3dabe4acd6292b6dbb7837f982de2c5248ad749583262bf54595c7d49cd46a72df4e765dc15e7ee443bccb191a6f8e5fb26b66889d7b196b4c63c3653e80fba54ee01cc2618fd4cc9d721eac8725c16a257a4d3dc70ab952b6851db4adb8fd2fe6ca736496596304e08cde65bd145081aa8e4618aca6b04a25deac717696ba3e4d6b918789d89dcdb7eb7166a8879d3646c2722d9cdbe468b37f2cee21c7cb1f244c742619a3093db71c820c9572245a3db60ce19208bf896ca775cfd9a10b80ed6be3ab02adfb8471162b3aea7dfd68931222bde80eb5ca88294c34f193857e285e4277717108f4ca8ccd8a466cfe89b211ed71fc2659677a003b5cfaad2b369423bcc9080ebeb16edeaa1babc4275007a10635d6ba49268262e8bc1fc54894722af46d55272385d36910011a9a71668a6255b4700e2c1687d9624324111b5a5dd268bbfccf8706617c8abf1ac05cd83d11bd42e2d58bc5df1b9fdee72defe89848a81d1bcb114670a29ecbe7b2b8f92e9ba52ead1baec0fbab9e3c79ca896f92e901c40cdd83e16392cde63e095378cfe18ad652cdd2bf1e21e9c85fa3611aeb9db0ea0c2c5e83bbd9fdb789b88a18bd7d78bbd89fe3a9692a30cdc981b82ee05460e3f744eef0006f72b22531ce32083c024f83c78849f8998a75b55b9b4c659abea8cc2e0666bdea02310d12065584b6c083beeb17e3ea12c5755ce3a145c6b2d0675e577d01f790bee3d70466d82adb4cbef28c6f9225890e6576ddb9ebf51354e8d2a2449eb1ef3b6d82aa3ed373a5829f5be2e9900cd85565ee5d9c115a6991c8c15840d4845090f4703bc138722931f27fed4d940be65b41881d2ccec06f1c71da14d185ebf6ff039caf1ba3dd7a9681fb6d4558ad07a76db7d2f8f0772e498e92bd14c9069a0844ec57338db8d852ce4e1451a9f77d64d129fba4797b1a43674003c497a8581046a078fc2b239f5a68ced1a116591c78a488312044a59291f285481540ff41b599d0f1d188174039bc8249caa6f307754057a7403387b6bcaa3c580e8c2fea3205c277b526a162120d9dbc8a36846c6e6902cd272ee26e3902599ebee50cd62858a9963ff65d47de64eb84635d5c86c3c058764601530a083056b5213fed5d8cdb70c55f994cca4054552b984ba0fd79ff5bf37454a3ee3366bb57ca8a33ccb4ae777646c6821dd5183dc6645c813349804e1662cefdb05946797a41f8c59f7581786858ef38ac5229b0c40a8abf02f3ff4f148c6269163c73a6baefdd6a356c3fa96429576bfaa70041201d4f8e28e347c05f15a51d44308dfed8dd88275666c515a781aaa2968156713950db5a4a7841c8b0a6392017de24435e304da12cfe1537ba2a428299afb89cd50ff1536fc977e08de3d67624dccfee6ec819ede217f3a4ce65d739e45b714ceb890f883933163628f082b31216e3289ca81393dc0bc0aced316e58fe7b6090fcde8d7b97df66939cd96595dbc3bc0349df2fbd470cd362dcb7e9616f9aa2c3ddc927c59c28297e68ee6ec5aa1d8b29a81783ad5226708d31036d9180fd89fd481767a657663999c75cf7206cd7a1b27184d6134c648e04eebccaf3147892d7ba66e7b3ded3d9734ce8d722fa67afbd232a113793ace1264e04bbf36f127e7b0a7263a5d8ddbd958db62d8f4c03a2fce5c983bf49453ece98ffaa3798e2c4ee0b1c6c35d0b3e6270c248b0812a7b43787f7d9c940dea4c4d98351b4b107c72e25430c02162593df4a70d062b2b66b687f792227a60503174d4abbd7d57d74c845a63c40cd70f5f323c5e2ef5f6b928c166dc9f8360168b004357752f1fa0ba281005491f5c4de8da0f074e9a5f542ef2e8e3d3ec71337750cef98256c4d15ea9dd4f716892ec42c9abbe55ef46d69c079f79029302e028855d409bb10213f728e4ef57f50f5e6e69134172bc735652e590b67057bab4d931b303a95e12d520af1727280183887266364642f0546022056e2dae1bad5be4e07fb29cacc3296d440bf3603c2b7f43a62239cc0af479d0ff54df10172765235f80ec9c433b531c127da3df5fe2e725516589e2813f0694ef5b283bec32e2e349cb86084882d50a949c9f87c899b828b0e837e8817069c5953d1bc32835ea4cb41aa675ff65638f73ac1939f392281f03cb2bdb11ddec7bb8f62bd16036389d2d051a0c1c41727c8621859397dc260e0c8368dd4d8cb6bcf7df8df5bb092fcd5254d246c140856c0e70487c3c04a52753122906cf38750de28dd286aabcbcaf4a2319663a61d15dece2fc4a4956df935e15bc0af46205bb5f48749ac2469526274cb0b1ef4b24279fe8ff113f55c388c4165bb75b04f457a8f73e8ae0e1ff6449dcd62a4a9d3d020a310c26b19acbae693c0bc53426a86642f51f099c84d194e81813fc0e47014fe12f3a347b09e27fd75499a50823b87690c2ecf76cbc379c5c2f7624b4812eb1ea8174c78e594202cfef307e6654587973e54c0d7ff65d63f10766f26c6546e3b0724423ff83f470b68282e42b482e6e9a9d3e44b187297f8fe2c5a9badd9b387631071fd9292705c88d97b8f8cae02712995f42b89fe62009230733dd804ec7b0e715f3f1eeef859eee9029201364bcb28323fe0f60006827b14d4586fd7301e0e44e647f4942c14996cb7a38b49e3a76cde87396e8c145a8b6ae428de2e8d1f3d1db4bdae2bf08d5e7f43df50963b251207a05d7c6b0903898ba17b80c0df8335d296499837fdff1b0824da4e8673959efc786975d0dfb0acaacdef4f883b266d695a45fb3840f47aced19ff2080415c67f6ee1d63f3ee3ffc16c653c79e6e1cff46578ae79da5e6ee77f91410fe33344cd17a16c093be92d71aba9d186e6c75019e651ab303c4f8d77c512387ff7d0283e9cc48fa7124ef1f17def8b5c4b09ca85cd1304dacaf0adf915cb2dfa22f8b27b468f0a7a078b96e6f0857b59f58fbea0a62486231b4f69938ac45aa5428a7d022d00b0cdfd49970eba45310a55009eed01fba1c55853263fa54dd0f335b8c18256d9b19d406207031c0323776d56cdad2b00b2308176ec8dfd771570de45577105003f56aed6195e5052bf4da1d114f1bf7cf2d649ccbcb106814036f415686291e060ec9fa2d9beeef45da4f24f28830224ca035f634cab4a8814c724c6453f535e290288824723836ee8933d7a16d9866dc2f143393d835a6632f46cafaef7078ab69828199694d6ec9f4ee5257b3ddfac2171012e64d046061190e5ab56c197057151f62c7de56eb69429eb6220577da99201b6acf3a48023980b0dc581a3854682e12fbbcce86cbebfb6ef4c7f15f9f6227eec5415be222e96e79e550ad6cb6e3878f4dff451f47ae3b162a5317e75c5ba008e5e8e5d88b9f77a98fdcdddeabc0fd5e17eea664c3815f71d153d9f26b3cdfa8c5b0fe7d33f3772744d9f454381dc9119258f52bce7c619457061794fa441f5da68d1cdcb7f2018335feb8b40895702fe8146ec8aa51d9fcf813d784f89090a0e4c0787369f80d5145acd76ed78615ea6cd543bab2d4613611c11d4b0d0728323047480439c5d0cde290f938a54796dd887eac278aeec6d382885f68ef42725767a0c8a40be3d87b6ed8c3ea8527f1f4544e289f541957b4a46c555d813a7b31b0b0ad7e9fdbf4a554fa3032fcad467e1eb3dae3263bbfd6d42b451476de516a4f204500836aa44e38255d91be453ec2b00764e0a5025df22d9204b11237d380bf598db755e4bc4bf01f8b1a561f1478e40c8ec4cbc4343027718006eed5c95a50c76d02678c6fd8f465986231ce9fabedb73f08f4d51362e90c4c1c1e9f696fcd9d0b37c8f0ef6730f757553dd6830d0bf348faf2190d6d180403bf016acb0c06d57fd79a9d183d7760a2947dfbe6c9778142b188a3f4f1f3f77c09fb8e73d68122c6ddba8877674a748d6195e0b8ed0535b9e45f96d0e777dde6d63ece369bc763296b72ea189ac60f7656cf500a5a570992a5e3d3d2b25da2d44bd387cfe705bd1010e905f908bd425f63691faced76d4d740a84ac5d1533451b5224dd3860d3185a9ad7264ad081e455417b1e925e3b30f295deeb2694f6e04ab9a6820a222f9518fbfe8e845c3294860417e598519db2a1901308b7b88ee09aef901033c34448a3be85fa99e7ed87b7e31d91963c7b2075cb872830553ca640047a0249ccf165d75082596dba9bce5099244008337e5f5d5e43a5f468df02bb0cc9f7986953732c6cd11835f7413177e7b67f70a27944801847b0b1169ebc744ee4502dc2bb7ded20e2ca1bbada9955108d33b1541bc204072aba388b4eb20a0c7a9859f2b9c20cacf8b68a834ae3f42a1c29fbe55618c88c36e6529242d49027d83944a60c73604498980ba58510f62674a8d335b0ffc217b791a981c98b4a23ef2e9a687f8236032222eaabc9e323f352a68d9cd8befcdff00a34ba997c72b53a9f7736f3175e89cf85af7eaaa903d8cd9ae58880fb1d74ce13df2f695f669d39b2faa58f0ddb57369e491ac015a94bfc7f2ad4ce13f519720e5792368c80cff1039c0cc07fa5c94e4dfb167be808fbb6f867ea18957fb75d3551d9cd9001cec7b90da0fc7911aa7a0b9f3418ea4416129c5eaac199f1f26e2e2ff59ca38e658f54236a01d72b5c57a3f71a757c808537ab16f2844fcf692938a63449ef3cfac7bc8538f86d9800abcddea5a0c532c14dd555dacdda19ceed365002893879d8be2b99e7fc328c64992cc6bc148dda2ff9c80086e672ee5ed2596e6c6cb0da7c3adc948f6c7691b11dc0926bfd3320903168ca10a3be8eee321dba32a3ccc695c1b6932ef41e0f41e91a08f540729ade297fb76764c268166c7ac2a0936a3b198774fade9a5e830de63966b70167ca4fe98ee367c8205b3064ce1160906f44815e6e370f4e4658e7f0fa058626f75e51a3b2c946c6bba5d1f317d3719d4d29f3554f76965b6605ba26052619302a06298f03acc985ed51934502b1f3b02b63b2677d1718ab81b664be23957c19546f6796a3dda807203f5cf094eb0d2d5b2f2d1887d7b8fe24cbced4b15b14625f2c818f11f83c67dc18ea7fa653a9ff6bee40fcd98d2bfc95b1cb8b3c94933632972c8b5b59d7c3c520b11c1c720f7f9e7d1b3d7c767c71d4015c8d0445fb1929c88d7c88c7b9d48e7e120593748eb767c3a193d6a9872a3473f7293cb1be9e8baa74e7d72fc282d102044318cc84aa9fc2fcd649c53a90b0f671ecb32098f9cf4ce404fa84345a7f826df106d9e1ca8988e098a10a0a924160b7403e0e86bd7b4b05fcb9f12aa4baa3c0dd91c32201207fee4e07cf8ae0cf836978ae14be5d252850a94129b34306abc26e9a882320d5cf8698be7dc0691b4083b14d6687cca79d8500916b925348200dc1a6e2f082f3b428186eae2200afa3ad808196d514401a1827ff43edc40760a170fa946c6bbf67bf7eeadab9a325274b80ee0cc1d20a05cd57fa063c337f47dbb6b2ef2246eaa6492cbf9d165ed5146062306cd7e81f1ac2e8f25a88ba0ae2104e6b2e9549fa3122232a3ebbc1ee181b5e7c5d8c716b8f65a59c18d6a0f3a1d656393cdc8f229276fd476e11f7e09f2413501a6a87d4a81f3d031906d62040ffbff6da6b9276b8f69e8e83b4df2940427220dfb7bb1dc28f2a27afd31e630dc237ebda5982dd40fbed8f7faaa7ed9ad1ae5722480dd0800e7d7dcdb1d85cb5fbb3dc3f57566772875f2031ff9cd4203285e46cd6b3307cb7dd01623c6461e775f2e743fb67cba183da4c16b6def24ff4f767827a4ea14b4ca8aa71ec3b37490b32baa8b8818e275a38e8a816d43598619d937afc23a457c954cce67a798a4419b2c810999a1fd29e3fe1eb0490041797149c0b526e3ee5a4f8ec04720bcfb2d84ec4154ea5e9475ab3bf775a0661c60d5f97dcb375a3a673dd8beff57f82450a2c9344be14654cb1b01b3df4681e751e9b0bc5b32922506518568a5fb604b3d86ec95d1fe1f1f8b57ff604dd1b65c3e6b2b437b1d410884c160caaa2dc6dce2ac0e1b3ec20d553f1ad2a59ab8ae97285d2f755d7a7ef8cf2b39cedf40b77b4790b7444d351d1a86bd69e6d1403de7577356af8827ae4188fd1dd9caefcd3a34b675f533f0d80debf392464f762f53e34bc50b8eca235e77527cc5d996f489c38b7b8d6b56c7833d42863e65828124286dce2eb55f64a068194534957c73c593818421d039739084bd4a5523164e5176cd880cc97a1628a247ba5f67c01f4797a80f163a414ee737e1b407ace959d35b0964f4edaa6f7059dc1767f19ee6f4a0c928d32a8a51e47b13708ebf2738eaa6703ebfab7d575997faf3d9a7efefa182eff9feffe89f0640b4bfab8a7b30950118b7e5ca73c00cd1442ca0d0aa215339756f2d51ce0c21af9a7995ac4017fdb458b76f8c72c76c199ca643007e7081dc77117d110a4854fc54682c58b6f6dd1b70b5d6999aa971a9dfb1c1a263b6de92c35b3bd81fb72b31366da808cdf6189c97aaa18741574d1d0dc340e0e911af5d30c7db52cab225d0c7246802010b9540ed0d484c3153455df2e2909f5fd617a3f04ea275fd0e53f4c90c31bec64f3fd566f4078aea0a8753dcc52e0da38a504f403a26448e9ef74515b6f22ff88624184baac0ee58e1623acddfe2724cd0da6badc0aa56678b52db7050eb50eb2793bde980a71d3b28e029fb232af363a72560024f15d06404bd0ef9e26622eda90ea8d65da8864c3aa2cabb8fe6ecd9b18b2fdd399715e6e116d45d09ea1c0dc69c4addc95d0c40b14646688ac5e2005c4b475fb7e721fb92f5f0bab98526e48f9cd8f0100a2deaf6b41e630f3cc69324fbe06e2b4bb8a37f1243f42d0f50afb33212f2908c72d6bafe6bdfe079a22fc2a0433aecb5bcd284493bc6b8546db84b01f7610e9a656c86d2644ca763935e10137cf932da28b26e1371fd0d9c7ea62185b278b71b8334003bb24d3fb4e1a3b1993bfa3b4a23972cbea6c7b32d534427a4c7a3604d1ab10739757913f4f9c1aa7bea1da7891354af1afd4800062d5f73c75d11bbc48ba1e71cb8d809881e2448f33ebcefcabff5c934457ecdd91598b17408682419a5887a12d8a12a2a35c1ed52d24cf38e4d57cbae1f168324f582a1a58613b61e780e9cf6fbfeb7978f648f6dfb1491a3c78d89a94ed69e3de9eae15e218f09ad96e839868cb2c69c97778351d72378c0a0efd87383f583028e545c2fefc5beb3126a008bd5954da62fe60dd3891c273c5b131ee965f29f9d2c5b18d50d97e14c45ee8f72d58a0fae5df6978674092d9a30100e6aae16062399779689af1a5ea8eb8e931f52d55b4fbec76329aebfefe011cde99f12ad52323abd44dc1f74c17cd8bff124b93b1de9f21842fc08922437cd0958c39e451029204a95ec326ac517e87bb34d2bfd2772cc96966563991e703feed29566e2986abb5ad01241c5967fbdae6c06ab160ab7918c399ac5f994dd28332273f841aaf60f896fb0cbbbe167c930d7039fb755bd492f88331c747b99e5091e452ab88d768cc6f4a5680e66f373bafe5122b34df877a6955a808ab14409785dee94f33f0aff6027b4719d3335bafdf383fc0dbccc924c5895d78faab0a674d094d57a3a33e075a478715dbc82c6fe953499bb837d4469657fe3945d3062ae95809b6373f5f629bc5d21ae32be884e547505138a7277fab688a5c74a4d7052cca29d58ffd6f537c9f2076e68058c9a5aa4c7fee26aa3658104058a45b019c9e3b3a4256e49ac4481cb2213c11c0620d955089c76adea74817b90ab666bd807db3a9103877e044b68794b542c37d6a4f6cc7cca4679d00a392a04a24d119ca22391bb9984cb2da5f013a1a8f31cc20d5119e9a92df06dedcd79b9c2bc37b66ed0a9b445930857b76bdee7901441f2618fb3b394651dfd9accbcfef161984e06c884f97e12392342a6f443fb9a6a28baec86efb162ba13f865e1e6e95084fe3ce911f97fc6a93b4b307bff8ba492c1647aa42a005760be90c0a5cf2d0b07e3d9a3cd5428cc2870379c7be73d7613f8fc45f637c7f5808d20a75d271160828fce2cfb86d5d6b400d7912df5b5d5f34c429d7dd74085e64c3f86968fb9316d52c28fb1d15e927fe2e14c6788c17082dba8ad260d7d334953967c77e54530ea2474c594791fb3868bb5aafbe39edd7f34912a68c0abc83f270a37154cb4ecd1b9e51f330067a959eaab4171b68653758c08a71e67d71296cc7d62f6464a2bc8d2e54a0abc10222b5dccfe3ce6c71973b8ae5382bb9ba5ebad7ed699803c2a600a74320a8159e79bb3b68c0226fcac23657765c6d6638e8ca95c269a589a955be9147debe4fbc2b9aad0980cbd380a7361282f6b579a053e471c982d6f88dc334c628de669707ae4439df1e96ebcac6a0c080320ea40399d137f11381deda8da0e2298f34d9aa3c1fb5b92c7806cae0079e5ceddf420797384f39ece449650a3ac5e1ba31027fb8cd83562d3d87da7d0ebe2f4eba49431a1e194d3007a01ca8b7b83535d9e3f065b92ec5906f6f609d9984ee22cf292f94d494f4fb5ad75cde8ea45cc8d6810f59cc6007feba6596d2f2e7eb48ef01794e016a53d258c8d8bbc357fb1b394d410eb75ffa5b77a6c1a20d72729f4ff75b338d793245b25144c229fcb21d2aff37f192dcec4f26ad30a8ef459393aaa40a3dc684ef76d593c2132ba621cd895fd331b11ecb3865d793e6a8e520a1e8dd58e02f58252f91c6e2d9834756166129f364ffcc007b97fc2a7cb7481f2c2e4153204ace4c2309ebc64bc8e42715a2dd932319e4e1471d91b3f83bb1c597cbe8312d2c6a59967cbb79a34798a14d47171ae77ee7f9cfdaf0d194b81c58b5a11226a7660eb001d5f5d659e7c095fdb7904a54bf232824eb7b1806c4afd16083bb3200ca383e1ff686a91a267a4fd0813467a57eef6e988d4e696af18bcdc13153117f04db39edd3d62b604fe2bf2f512ab088e19f1a2583ff5a66f1d821ed4dc8d8c36ad817f43a5f08c0b3b8bea730e46169276159ff16129e7acbc103fc0ef6ab07b88e7fce73968bbc70adf0a5d47b23e3c649efd6360298da20268a9ca87e17b7499b782a6a0f7aa309090d0ce98e62bf2c35bd5deb7274f3fd3a96be694c81886aeda195029d9cb1cf07655dcf0abe76c94d0fc95ec6548baea4b850738801f4ba4205ed45248c537dcf0b355463c7af5e553508706883931f2b36a23df4ba94e25d881b16b9550ec8083a0d6692711c1516ae2d926126bfbad9b417c4ce6aa8c10b44f1b5fa1f8cb0a28d32278ad67f41d3d827457c81fe3d8ef6c7393bc57e8deb85f899167ad3d5dc9f672a27c672427ee351149deb384c0dd50ef744346072541cedf0dbfbfeacee0c9ad8a897ba61a04225109ce6f68ae45ec00e8ba4d102b79c82f10dd97f5e447f9bc3506de83a36c337ee5436c0271622fa20cdebdf47fcfa0692b4d1b839fbee6344df0314865d31152afa6b242fa68e5d78a7a545c6b26402768990b4d0d6c9435eea69fc576500dabd3beb8a6067f0389822d71d072fb32dc9dd35b82b564119a7d8b943c21d16384c63a678e0a88729d3bda1f23c39aa0faa0cd9847383915867c41f22085eea8788f0d6c7f4acaa3ca6b8149c1b91dc320f5bb952d8861afe9b3e02f7125c26a5c215f9d31bf20876e3c62c61e528db43d3402f9922e44ae456adff47a2dd1c0407bf7285e67b048442abfe604d47193b94e51525b6571123db774faa34fe79868dfa4caa01507efd6444e2c8250d682de56e0b13fa290c9b5d94848f3569ab262b1c8de3e810b31bd194624b5d0ca501c9e5a8bcea0f751acb008148094159694ebd165fae2365e0ef61b5c0c653a13bc624b97cbe3607a7f3f655f1f980b601ce153b49ebae371064c18d75f0ac3b062f5d8d49af33104e0d3b828c5b90eaf19c75e76b0025e540395760da23be628de3b4e8a45ee0129adb711ca2e6a612874545ed7241daa3e0955a6899039a4225214f4170f9ebe9eaaaf343e680865414f71e5bd743cf26274cd382606f67cb3d21db5e2a3dab9fd43778dee5911e28c5a68de45bea888dd6f60fa20f704b7c15bea724402edf9f2a82349e34943b0237801c4026a18b1619ae921cea6ff7e1e71223b1df68f9e39a900eede918e41dbda6057e249fb923d80a0de9bb63dcadb683e5a4accd799429a62d93ecab987e3f8eb14d222ee144b7118b721955ec613daadc9a823953b36e3799b8807f510e40090b50a447eab95230114978ac50a94c6d95baaae90ee4ce8e6ab334e49ef3979130507c2b909097299acb6f3ed994ae47c6e7c348c6cb89b3b946cf0618db4123de5ba1bad8b94d6c596862274ce5448df894075e97fe25c75cc2a7227047c483115e702dbf7d692a56ba0534df880de3db2b2d5f83caa8739e8f8459a465ca9777aeb3f4cf251bb4bf0d1e6c74efea9c19a4e81b36973505f35cf898d89544b778822c3dedc414b6d6697dbd53cb2224664f2c9fe5511ce3fc785e10a6664ac8ca7a728978b544dbef8f3faeadd16ffd4482d0d3fae025f4b56993391b136285a30b6572058af400b5f7a13280ba40f4f1ed53babc602f842a632e38defe6a062a7160e20611afa198a465b1b57f2d68be4577bb9e719c128cc78aa4b044763dae022316252bbb3c4cc4b0d72d4c740a31cf9588fc5d5819c1475c9d255c4ed6d51a5f2b75166ccc2fa7f3b9c7c6b39886a8923a705d0a648e0ef3b7c438a0ccfc7b8bbc7d26fc96e8c57ad1e9fad3adbc86a014d2f01a9de2c81d70bdcc9cd34177788577ce9a0964284d3d88113d6b4091bce482d06236d2748cdf6ebf06cd2e7ef8fd33810b35d327383d6db39d84b57246a3e7e432a547a63c14a1999f68603e200d659d2f2e5eb0c05813912d33fb0dcbcfd5f3faa201c8fcea0ed57785445b6239a151a65bdb2a9caa42804052fc6ce4bced472f759d119089aebe6fd38e0a3cb98552fc0638a11b396ad27838cac7541dc8c19d7bede74af3c4bb12bf33b9f657fa1c0186efcd5ab77c87dbdcdd34a09b3662db992c0112e158d8a472e49b70ffcacc843a39db625ac0c8515a3bdad988027b07738338eae9418ae025600a55cc75a43e5f31f86c512530bbc11cb8a63b5d55ab5df665fdd62797e4ca32baf92e4eb1a87703319b6ccf44c62edc766a13d5f7ebd5d20d15f200e2aa35589bafd06e00e60ea0feafae74c69337b1cd240180f645e4b6d28345494bab528c94cd4c8fe19ff2ecc42ce23f803da8db18e6ed1af22f3927d0f0729a367fa86992804573a0db495b3f8c1a259efc5222205da7c5c602e519007e2ce503f8aba1a666e021c7f15adb63da022927c1883aefa3746c99d1bdb193b4021a12e926d7d582ff44e9751f8581924dceebec8ad2a1d64682cd9dc5c394aa5852f431d6859a97ee78c3c1266e5f01285ff4558ab51ff1128a96291696fe130d6add321db1470a25db6d4685b7e3b2d4ccdeac6108d2a41528441fd6a95a97800a489bcdf33e841366e2139236d1ee21d10d872dca92422fa4fa5b5c834eed9193d9be99f824c8f773c7f1a9456272f955c6d022130ed1deab7ed1ce812001272d9eccb8ca7c83bb03c37bb7b888e393855bd871f89ce4966b24a0ae72cf359776c99c0101c14ab6b314d8b23c00fd13004dbdee35bddd8cab1c733f600198e81f7d90f02db02408a7d7fc1f2c45916250ce5890c408ffde003d2df9fcd8192ae61a822d357209a3d96cf0a289bd19959041e01d00a67d1486a52019d43eb1027d14f22ce08a31d9c183c06daaecbd74e3d77e3de0325839dda9d1256b98dcf5573f27f614f6ab726955007347e3336761de2aed3879dbf50ce3b119ef5dbc4e4466a8e55a54a54090a7e2b277dbc27560d7af9a05cdbde20da61d6388198bb0a11c78cb5fbb4d6a8e2e02695b5b62e8a088e0d2e2b6457d188772f23bbaa0024160f71688183ef26b76b463ea64aef84c6cf59bb97f2b352eaacf653f51f352d39f2c64e357dd626c5898c88f44d41dd62d264c4ddef6670c508cd07487e50352281affa3580064b9e477d25be97d2c4f8039f983d3bcbfec797d2fd44a17eee54a3f019fff7c35483c5223e672582e7d9b49eae17e91cf7446633c845710a0045171c3cedc57b9709d71133db5cfa57962993b14a48aa8c486485e7ff21d3448b101e4f90fc00321b7750370e3b6ee692481305627a9a281c36187b88ca8ac5830b482abca802df1f3a4b7e46409b199413db64784f67e6f7f53a64c54173fa748223ce71bcb8dc0be855108eee09fd5b9bb4ffe322f4672773f733dfeaa3e7c83b646e43539b797b37948f6d59dcde42fa7baaf1bbff7e3dd6b28da23446dfd782e8c017fb240cdcec717f77ac7fb7720c86b2932c9f44dcac4da40a56f6813e9887e8c7609cccdc3f38a18456586981d134451a0856e09f8c0646928c46ff81e1218a9ebe26e031b5e9a36ac04a0a907d66e088ab134121f981a5818b60373701803f512a1ff247468eaad73f2f3cc2e5cf2855afc818f36df91e648d42bdc02460fdcdec1def8c1193b1455fc5dcfed20d00e3c84acecd51b55a8693888353343a78891d3e19325d50f64e599d22866c2a259c629ec8e9898e06f010177d31eed9fe8e5cffeaa3fdbe3158b5e7535f765f97fa6029259190c5bc52ae0b9e7f700f9d2376229c82b87daec63afff255081df709c9c27b6e202c4b53d6407235e79371253021c4dc47c4122135cd58b945d19e21caeb3323abf45eb6cbdf8e3d09a7d206c0412fca2ba57e52b98b7bbc0bf241a575d314e5c01ad7805ab82f1f09c11cc56beedc790f63f66741bf195696c3a9a22e8667d3001e9a44af4e12ad11571153dbf865e663e8d6c27d2ea6cf34a37a01015f144e5a3c097e29c7a49b05dec3f5be957fe37bcf899d357eeebfe237d176e62dc0d902b0c22ba899af8115aab7d38732bfe371ad649079d1e60aa303e591273cb57c7dcdad361375a7cd47584107217ab52bdb1f563f75f9d298693d5454e8a920856d322e9776fefa07041f171794bd7a59a84574c770aa4c89cf1bd754b302d4c68449c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
