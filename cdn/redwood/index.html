<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d55a64e6cfd8977ed72fb61ce60df2eca6b6be7cf1c1c829397027a9ffac960298ef790cfa590e43a7188b905fcc070b7beadf5e264b8b22975ff5841b6d4db7ed3ed9806cf35a5a6108a8eccd075dfaff55ec1d293fbc079c3331128d9079105eb00c74f4e3df585cc81d8e388c995eca6b02932cdc04ce69330a3e28c4b4d6af294e10cd50e7356b7ea0666b6faa5c0983d40ae79829304b0ec127ff4675d860fdd1b858f1dfb208b33b64acfaa638cf4bb22c02a4cb14e4414bb530acbb6257b1239db66c9d11f3dd62d0729e479f5ec8a03a14a214fd514b5efe6f41c175d77cff6232f0cf7173c96697f9ec20e6d201ed5a10e05e469373c2d0b4d785003c17530527711dbd608d872261c24314914e59865423c2e7166e54275af396f32f28a3a369baf52d05439fc932d48849c0902f6bc2c8c4812394ebc5da655b76e25f3a3974cc988c112496e9573c745e57de08b3f7461e0c4d6ed44fe47e7d702fe1d26e10bdef1f9d60d4013c4c9b6042848a2d59da5751ddd01fad27ce0740412ee25ef9d6b1dca3ef7d9953d86b2453172dec087ff142a48f7020713977bb9db16c1a702f00ebf1bf8caecebadf7ddd1e3f40169b57da8536c186b68c63088b9a9c99dc12e6c0a94d32bdfc793401a75cfadb74da50600ee6f924f5dc8bddb1264bd6351cb03221ea360dc40856a3061ef240686c6473c5524658c22d72a29e0b5b18047beb134ce848b7060cbcbb2450c498fad00a549d1fa76443899a606c9a19dd09eae043e8170e2a7291874bfe357ef6f984deb831ff2881d522ed021ec8cdf7f0a065d204723a132d263e5a1f306245980224c4a0b50b181030b875e71cf5534db1ff29636b232a4b9847b900f7a94293c29f7f11702fd4ab510fba605ed85cf263f393987a1e8aa1cd201bc96b8a27d45230f6c100e3d1813b9248cdab008d2f8cae097b539ddacae73be9115ffd117b26294e9835b4977b36ce82ab6ae50142b4815e9438c14ec301a47936c62be86bd33d68056ea70ed6d148a217d30b4dce382b5d678ba840c42582f2d29a9c1c96034006eec9f779d68e64cb80ae8cfec4e0d90b382d0a130023a3a1830ec470c3f605714644ad7b12132f834ee981222abb7cbd97c04841b2cf219ee85a4f8610990543f13bff14e640f0458fc48ce3f55445933becebcb2ff83f210070cbb7deae7e1e57233f97f9714fb337136916ddcd02cf8c49e81b137e32d265244ced3ef128e9af3b797d6f3144ae0b8c0ec9e8ee627e3c8741b22c19b7ecfda3f1e2a2c85be41618c0d87748024c8d9f91dbc6dfcdae78893559626474b77ed45365ba9bba5aea156ca810cd4ee55759e623c8d3cc4b51f17bea0a8d875a879f5de548f17c92d9e3a313c6995d26b3011a123b7fcf58ae38a8517691aa6f6dd1cec67e55931f8aef38e8ae409cbc4e15412bf99c5b7f2108f580e00893578c41301b7ee30795fa241a93d09d86469c5cf566b93a304f596c2c14cc226d5d3afae452dc8fb46230796f4f6171bec09c55669e6a495028efe412326104001a0b23321c2d438346287b6ec768e3d1b07d956a090c8e1eb995988d2dc3a581fd0fff7b889c00539dfcefc2c09cc159e140c739acd0886861932d934658cd27784a1a398fd055df371a14463e107dc49907b4d6922f1b7cb495d51d2ff7f650d22d335d63b7e8614d14810b43253ec3f153725eedbcfdaa92045245a49d9ed9ec568a8551acd3bb75ade2962c675142188fda863e80e0826636a25ce3451b15cb027d8d4bbca6a453ceac7aca6785ab09cb6af26b06b4d75846ed5cdb3f2cd45f56bb6e78e4baa3aa4d26a306ee97ebc5079133551d19cb59544e3d0491b544c3b8bd62ac5380214167ff30abad897a962b9b7fae25febfca27ff2920d5717cf00e86bebcc5f3334a0ec181001e2d5b98891343b3cca1a511f95499f5627d05c03abf67ad4ab38e15909a99dd91cca37d09886e31438d59b0f6e2c50ab1024dc08eca01f412f8311763ba66b4a753d9099e08adb04a6e3fccf6dff28f14c468a1131e2473615641d2b22494098301973e8f1c8458a81963756e65ef20124cfaf2246f4e2bc01c454fd992be2e7634c42faad35805f7e4edfc0fcd65fcea11b4800b0f52efaa8a85369021af4ef9f884518b0c8b5d6d1c98f4c8ec3f3b91732005334885c2e09de7c91ee3f19a3e1881fe35b0faabea9cf4cb891bfdf23644945295944d7cc8ffc6cd64cb95033310e43796c28b62ed8430ba6700609d79290eab5bda131c7556e35274e42810e99a2e73372c2a2578e2587c1a5cf8e7baff4a53c235c88abed03e81404511742849e340d7584bccad1bfb7329fc8bfd2c1046f2b9fa39e623ce9df5c2434ac7e6ad546dd8402f80bab2c0d531cebce4c68a88241cf4ed33a670e5978277724fc3142f4ae9bbbd4217fabeb4f2730cae2eede7b0a50e54d5742fa3c4c2449b973d297bef9e7bdbbee4b834a1c557060c04c76cd6711aa294a73d1dcc6ee5979589bce29112e1ed2912c47b819b5f2475fc8be5b3f6148fa1cc979fbe0c2a2a562f86d7dd01392e9e499670b909fa1e98d0b4b0267c5bf0fe4728d7c002fdf5738e5ac8b8855cd6eff98a6ed41e2f86c2afc0be0b70dd733a138edcbb1f0d6cf07d819485b3be7a359747e873e1bf99fcbde3be6ce438da0a8ea06b0b8dffc9f0ade760ba90c7b523c3f3acf9fb347ec6c230260b814f6dc06ea5fe980dc21042a38c78cbcc39f035f9ec2e2fe3c3b2ee86aadc7f392aedef9d92f4913e712785d72ad91c2402c998ef61211f5d96f6c7f2df52fa55f699926acbe0cfeda018e84bf95bbb9e4f85417c8f1defb5ec5eb42f5d682d2f7e9e7a6a56f2696392398a543ca1874b9a64efd6dfe2fbe737b1b4e2a2cd9e2b53587227cf86341f41b03ff5c5a750dcb7416e4ba234a7de7ae4695b1617549affaf2e89958703e1e8c64d53c32485e145845197ee7677c7465616d9d21508373e69914ee9deb686537d4b9179731c17945e1e27dd87eb7a59f29f7ef5e34213d28db9b133a6c4eae86e4421dd155875d3a112e1cc1c9518c3b028c9818a587041dbe9c8bab69da4c6e81b92a2b6cba4b0b49c902604d310c88881711b73905fe2a6c9f2dff582b1d3a85297f6e759348875ecbd0e051a6d33d1f8f188a19781836fc34a7c766cd1a7473f5256184bea2539402bb33dfa4d01124d613c37bb762bd4bbaf908f0d07f062009b67dd29462fd8e662268396ff405cc84cc055cdcb73cbfb135b5e16a861f7160535f7ffb737a21e09a8e37e1f972cf504d88134f06a759bd87579e6c288aa6b510fa478b64e5f2043e54c8479fe52a31a3acc60da00ecb3b5fcfe6370febfb312f2ecd39acc0fe092f07fa1e6a0aaeec0ac33e1f949ff30430829a7f96065f673832d21e9ede138ba3ae5c21cb4cdbefe0d983f8e0f9f3b2d30ba6c2c765cac402a2be6e1c895a5f08d0219395a881e8d12ce3c443078fe9fdec3df711ae991dfad52fea65d9f620e7d22e46e4e42fe4edce69a9a1c2acdb5856b602d7c38f6ff38bae53ed292e5aac00363637e80482605da86f9be07a18cd8c08f05fdd16554f9a443f33471ec5d143e11f2817edb3f550e90d9caefd77de32f5969279b804f950ae74345814a68f9cfaa1443153f774de5930d54fb7e46bd145557d6414b57009af68b83268c980a3ad3d71777ca13b0c589eca579696c6178208293671646855273bbe39a7043c7d8e480523746378e7dded5d236d297a1062959cbb27e16960e393545db40aff4e535f44c5f2a1599f3e5a6cdb6709a00b66e5f0a42d41b3c76f3e6a1004e741c141c4c6884147a03884be77a4eddc2729d67c8eb662cd469cea23de5a5a052ad76fff22c1969fb7e63edbf0520cb2f2f3255598a36868615eb2ddd09d31ac99130251267e1b349cbd217f2844f31fe99ed5c643f86785ecede427f27e78a4f4a80678ade8390ab0ed41d6699c0da9d77bdeea88dbbcc00ec94e2f07a238a615b3eff43ddad3890f8b39554bee5bfd5e34211d809bda2b7ea1303606ffd3eee59224dc11ef1b472d9395820ca0c91096d21ef0d10debc16de907e87d49419d1c5cd1627f97a0de8b94c2f5401f15a733a4db05cd7054e44d444c738d17a3c9ce4314a6d2f81f782af010ec18f6512294d7050da0a671f1d9744272a7d9b55b763ee82a9005f5d70aef3ba95aa2b289bdbd25498a6acd178fcc34625ea834ab70d03e685bbfbc7dab3013260bfb2486f769b8e6ed7e18c35180c19f5275e5bd3c3102823b270025683af05e8c086c11c0822149962f618985f98cd607e92ff908bdb00f7148f7657d97975b6dc310701b8e28f10676ed54e30171100d37fec8ee87cf8dd690d6316b3cfa2570aa68ab1680e62e1187eb892b7185df3f23819ee4fff470862aa2c53ba834bccb4b08e8a09725862e1f290664c31c080899b4a5572bbd3abd57984c3d44061af3169c30e05bfadb92d89490146d9c713b65abdf014e9138b1b14d52ba90b81b3232d513a203b3c3e28a69a96006d6827bfeb56e71615f0598f839c29706e90cc0c28cf7e714ced17738603032a41a5f8d1fdc1c90bcc6318b2738e431c5f046e88699e473636321a2d95d2893b88475d0eef9eaaac8a6df33390ac42706b683f8dee0e1193e055570b06c3d4dab50827ec3f210c80154c487820eee6bc9afed19dfb28ead3e462f8f29221f7992b357c5c6becde1aec32c6cee2866bf37e4bc851093b3f55ed0fb2c2c4e0e52c2487a20639c31f432ff18ce749ba850072be2abab280aefe73a67657f55ad34c98d64569107c3b670cec4056bf5b60b674e111790430c531a8d053100a136215e2da601f4cfaca2d79fce9db97bd31bd1108843496beb5fc709770a7578faf81fbec422c7309b16879eb6810c7063bb644babf4c3c38cd0ef61e1413d8ee6c88eeeb8fabd2d0ac04d5d0ecaef2bbd8280bce35a95f8015991f2c08cdd19361cf06d3618de3ea3bda96e75338ce3038f4afc198f75eb28baf961d80e115c9accf79a78859d2d4d1cde337079f10a6c47956c1deb8817464b199800f6a50f6730081fd5578ff2fccca4445b389bf7114f18bc11adad0b8fa156a466c1087354148fecc9d40ff5ab435fa127d4b0ef4ee2c8a713863476b42df8122c9aad966a0526e26145b02807cb5e9d8eec0331cedb5a56deffb4074b211c2cd2f11a23680ceb5abeb754d69ce1e6e7f6ff2a01616d429d0f23ac2bcefbba8ebca46cd6e757c930fd8e4dcb881af287ef9d99279f444b81cef2d829c236d921ea84d85d0022da5a630d64baae858b4a013513e2af8d866024dd79c0217097e2b71c9824f36308a8ea815f8e4db873392e7f61e1fdf8898d60ef95824850288fbb2eafc3856e31dbc4e8eb81afe7af4579251e7469ed413f01dd2427558cd9ec9754b99dad53c7f6e085ee52c92326d3a10420510109bfb3eeb2aab87e4319a8d802e5eb00f9f8e0254a18185a6670195dedc9ef9810403b131efdcf71280bee4f2e063d88aa214ba97999f746762312708d58da53391779c95bdecfe79796242fa7f372e8912ee51ed01482b995a5ba6eec3f3d1c5f119ae03d1d9aaa164cd367004374b9be8198e60fee82ce35634f0b07295b4f0fbef2e867ae7e542037dfc2ff4b57bd9ec48c1f04c0a9018a016d4bf3a5134b656feee571c18cda2339de5105b62d4f1ae5036ff7c9cc08b9a23ac98c011c9851d94d666b3b747210191819647571a606579ff814ea61dc59961254993cc199dfe87a3f675a06568c8225d30179d9170ac45f7cc39173b2db0e3cfaa032ebd41f6f642c13db309cf6a440bec5360d1e8ce39887c4f7b12b9261f28fccdf9b92ebd2ad49e194da247a38f8e972477b909b80d5e42f10e3121c53c5d6d381d6aeca821bb91b6cb048eaff503c99d62adaaddcefe50417b55e2d9e6f3884b1fc3e9130aca32dbc08cb23051cdffd28f4c4edec5b422135666f0d8691a29245c2cefaf7c1cb9b150f5abc6b589a05421a195254ff696d25ea85a947b9a9d1f7850c0266a41f2c8af7954288cfd64e388e6f357431dcae6fc91c246869732b74be1b9c99b454e5a4f8c6c53aa77e319c62e239b271863f9f13b3b20ddbcba54907f78ae188569e5fff30b205958d9a6a8df473c2918dc59882d0f91fc8b54b62f1f8515785e985e0505afa97832b4c0e86a2bcf996b340dfb105f9bec5c90eb159dce89b9fd3ca98df3aca836583710a252b04807912d071a08c6b8b7b39e3bb29248bf49f2602165bde3537a50cf58428f14fab6bbfd2be3b299ee0976c183054b42824149cfb7998b7f514c0474beffa54dca79c85bf1267205b9137f2a1c05aadf9f1fa01e7b2fa85af016fee98e55b93a80521da5a11a386fd71e35bb4d5461139412019345dd08972ac13e120c0defa8af99ba53b65885afcb7365122dfe08a6b66024a3a51b9ea0f9fc50c64219914f797b4c0ffa34c24114ad21d69a7268de768762205d0042bda95da90aedf2d8fdd6f75200b9e7876a45fb179c139b4b0f1b8956b7ec658d596b89400c006fcf2cd6bdf1857f4e38c501ee8afe96afb3c1ce7621c0c049306ae3f9a100128a28d50c431d62c3f2cd2949ba3de6a8b6264690d62eabd070cf63060040c5e9623b68f94232bf0161845f97ffccb4fbe164ea767578f8a76bd9e415c237342e3607f99245dcf0fcbd757a0222f227f48227ba4f259b505c52b55cba79119d260168ae85c50d643645c8a410b417b70dc918df8bb4e780c75ff2f43a735077052c74cc435c4779e0a3bf34b5de77af324ace21aeeec7c4b1c311459f11f896f5f11628deddcc0cbb60de6122891ed208335f04512bbb408c00e8739040f848ab1d04c953f439750e80d47828bbab7e3f1486c4c18fbd355baa977b8cf26554faad674430a7d40454d79ef126b9ab1b7285aceb11edd37841cb1254730d4b10e146f0977d33fc0eabf52a983ad97382fde5c4360e9a392e3899b644616045e5d6a1fc33d841e57037af163f1f3c3c63bf5bab490ec301fcfd1ecf9fbe4f759cdcc46eac9420515ab1a1f9a37ce397c2c74827f92ad1700ce6d50542ad5fec11e31131965a03cba7542020a95b286b0b9ac0b16cf6ec3619bb5fe56b335823fa582dce1f862232b52ccc1fc447ba63da736535da17842083521d2be270fedcc37239e752c68509bc6b73e87c773cd5a2db4d87ce69d0292599b733a3238d8682bd8bc92d6d5c70e0f0db85801ed56081c53488edfad01568a5351314267324f82200c340bf052f78d8a3ae2a62d8779861e11bcd3fc7e861650f4fec3416c05c3f325f86ae0c52433e7872c4806a1f04c7add5f831000571ff70e86eabccd405b397cd64f3a2fae5a2b7ec6779393abe29cea5658d87ab16baddc476e30b1959545ad01ec8913f20646f546b21d356a3183f34fa694d12777c3d68e119b1b27e165eafe18eb3d17eadfcdab9ce2a19ca50ba17a0ab08e90db66c162cff19e5a60edcd44286cd7018353d73f56e9902d81a8e588d7a789f11255e700e46fd81e637bc964233dd4fdefc40795d5f20eb172e63e15c1302221275423a7f33753a93680e0d3a780d86ee9bc61515dbe5fd2a5b99e336b26e75f700224d45d3c6f9ea540b51db95d0d5e32e09b5ef89f26f4d60e57ff201e599f0502aebe8a000ddc01d0312b6a2d65b69e436b3bb291a7811a3a6a822b84726075208ddf79e3745984e646b6062d7110f9287c496564e6d9bef86058983fc59bca14e2ec873df47d63781b638825136ac8f39d1168c190c18baa4646c6c62d3d5a89c3fcec33fdd024c7b153d81507cc7e7f9bf95507ff5d84648d4e5a8c8fb729e2e5bc2c2f68c05838e1075fbd9fa91855135488ebbe968193cc03506feeb8d3dd4e4e4fff2d6bae1fed7d0b696f8b76d98f5d65778675e60f4e184b703790b1faf9a13ef627b680929dae8256b51173e07543898296a8845e6692558a456982327e2262df9710726995bd8c13544c05476b63bdd379deaa8966bd15ac0540a375a79d1b7011f79dbbb74089178153833733f89d5115f747cd3cb4a45198bae057cb63dd1de816d1c3df65c0f58676dd4de1e1d22bd8c6405fa56859b2ac776924754038f9524ec6a927b0b1c658cd8e7dcf2729e806a0e1d58a89416cac5134071c6513dddb01f5d6dee3577eed723b76103c16628b90e8a7a1f70f1d3740403c214436ad78461adb029c36bf51daa82e14ab914e72524426286f0091b0273892b6d175c6307ce70f012609761da5a94fb7749610fb310077db731963bd7a34df15648e4edcbe4821d5ace19ae8c5a10a24a66b04da7bb65647d05307cf9388727f8c82d3cbb015fb95226e69374b529cac0d63ff1d97eec03d6a9d3600d36185585867a6de92caa64a496c2b7eb5ddd56c10e9f6f049ceba391e9c7d4f44397bf8025d3e02885b4bce2d7ecb98736345616bda6b2078f3cd5366d97709f413430f6aea01d42e26be2b35c905fd66cc36da43a9cc83034502574f3812f0c8781de5da896ea6b71f4a5d0263315ea5cd9157bdb829c6ad2d5486590937f9c3cce90fe3f585828e8a97921467d9cc1e6011a67f6545004dec177235935d33b9214a572f68da7771caa09c78ef3581161eea6c7b3eece3e4887eb776614ee9d2fafea21d249a9f09885debed7c3a7494e344c0c69520873d447ceeca01e3e2d0f69d18be5924135caa873b8863a8c89313483947d39bddb59dd538099b79d44bb887c5cba22bc39c3119177f0c6ad610fe64efb4a49b40c1cffa4b567beb3264cc605b5016672edf638b79d53d222f00214200b49b3c7f4a45d8eec29de3508e5ecd049282121c27c1909e115ce2a08bf300ae06e1f76dfd7dd8460dcd71598680cc7ebcfd30c11f109ab0b2cd2e07c6a5018da961e4ae0cb7edafbde29c6c46ea9307ceb432c7534f606b916d2edbbb8e9e091ae426446bf40c9111ea64ca5cfea1140df10ce816213aacb9814b3f3456b9dbe2156a62dcd6fe3e4f9a41110e70c3d8bb7a9d5952c8b5e2d6f416e1021d9c65f191be157d17b8f15ba3c12e8b9296d81de85b8e553fc5db2b4dff18b4b23333b786d23992f97229d74b27b7d39240616ddcabc95add6fca5e8cfe325ac345837a6f9ff75a95a6c77aeb5038e5305c6943a3683f80ab4bbff0db7bf06bae2549c5707d2b678a7042c7ee4226b7663bcc8e634a14a7e9ab3b06cb54c386424911c37aa237ba0578f7567e7250ecea84da0f35cafa73c38220c055533a49d72f23c0e1768560e876d6da69041a49a0e4d65aafcd3d2a7380bcb73445bee258c86cb1208bce233e85f0cde7aa9e8c082b77d396630ffcb8fd574f225b4882bc737730c7e5ef50c7753f89e9f70e56b8f6fa1a8676332bac24d58d33d8c590977a33b1e5347c1e12e9c1900c258cf40551b94347e9bca87767f37964d74280ca646f4cb97a298f308ea07ccbd90b681b9d68f05af2b48309a4608545239eaadc0eb82d2fbbff3000666015f00d6429394ea685745ce395b1a8fe0a59ab85c0dc0ddfd6a8410f25b63d78003be7aaf1159a45d1be9522ed4d3c02569860ef3909009935882fe1188c31b0b77f98331f34e35936204e65fceb7395151ee46edc33a545b9647776721af672bcc066a6cf6c44e57489f05f917f5edb099c4b1d6022f3774f15d2be62548781e5f1befb5bb73f7656fb87785a84573a00f2dbcde8c822db51cdc8d87bfa115c7c49d6a71e0f4a849509485b5884ddce88d815486fa2f57e0717e6946896a8b6b312be7d0c5bf75061991e40ead8583fa15164d104d8de172469ce2f0d6c2455a34b0515f70efdce5c24092c3e253e31bd32d4eb4744e7c8b95ade9e6a416ba45cc9a27af3a815d4a48574d7805bca1dd6712c9688540caa6e63d8188767d4879b4819c5660bcb7843eeca0b73bb8ff50c9aadb4505cd92282ed66f9b86f541fea15f813e5ffd57e49b992baaf1fc5844cc6bd9186092a81b8c85a877ae75278fd0d8680fa56975189e0c52722bf7ce5fff412a4c6ea6ce0ba9a343eb4ead7d83813993fb586186bee85a34bc2fbdd0d39f1062a55aec95e3aaab67f5aec46e87ae34d3eda26fac765a8a8a91256a91eb8d90a71cd26b7437ec610137adcad1a8ad6249395b3931a8d00c5f308a03a904762d95329d9a0591594ed37e1d8df86373a7053bcc81fe7f6b866316cbb3b7c8638e991168074e5085bb9606823f36bf97f7615bbf0b5258bba0b0da1119a7c6da61127949e0036723f17fe909698a72f02bf67cad63a2ed60eb15dbab45df1681a2a49edcc8a0aa42dcdfea6e606375fe01115e59de85ad580f01516811132ebff73f195374973672308e3237de31c596093d9e316c46028bd0a9d0ad33996148385c88e8edd0f20b5387c51d6e91adb53bb2d944dec045de8678a266a9e69a60271b11dd0a49c25f77c275e42d9f271d01d8d51c163b7e111edeb8379b7f0bfc2952533d458042761c93e66d3d5cc21df781faa25ff159151c248d62a534edb682a61221f6aa776670ae96665eb5f3ce0e1cfb69e6ffcb24575db7c426ba710548cfba69f79bd908029976ea0dc2dfd0a3670f9e86a8dda60783786562edaee72a432c7df38eb475c14121c376249c1af65555586630b0b4a6819e4e0c129fbd74535045242f0d683f099ecec4a3eafb7149cd3aa85920572c46663011b16cda5196410c5e76b2f71811fa2a50d9287c246633676e868dafb5038774ace7b67fd5a37e70257b73378d1c8baea5bc6bfcb69d6c8ae490f732c21c4bc0a54706a2f4a0cb6655f6f03e01fda65f48902a3a66cd0f249282d1396d382d3b474cfb672d5a7ec67b1d6fa1c1e4cab3970d7312468b78045921c4c3d782888fe09af45ffd25641da70123ab7149442bd859df76df1906a2bfe29f97de3949da432a7b515d6532a65818373dcd8ac884fb6decfeab3af65121504e7a39234727a75c13acc010ea0f2fcbcb958608d72e3eb62848759b7b69486a351c123ab4e643bb6353c25f7fea9ba3cf805bc96c2edb4f2f1f1e9f122ea0dc052142ab311ff0955477473bbdd2cf37f9946c1eab36ea91fb472e18a6a0fe67d5101541d99a5bac2814a9600707eb99afb5a25639c8db8141a2bdd88dfeb5594fab6516ad6bca9ae7781431c3c7d94c7fb28866c8b43cedea22bff120b9e32bbdb5624f47c38a4ac94182d9662db38a47267cc59f76e82131b67559c8d73b5ecc87d6fb3203ee301a2ca0faf273bc7b4bd7da64a5d316fb62ceba125e03ec5b65dbe7f6e0e3dcafc80f49f10ca0a10b9a11b954f4a32386facc2d5fa2bc7d0f3b7f6ac77eef94acf83b074a81bb8019d529b3d529ca1e95d741dd27237629a3c7fd42d7a92437ffe9d095c618cd59058ac14210eb01e1948eb361912e2e2ff77f447273edcc5ca09dd8763bf96767d9eaa287bfecc85e2442dae8dd987671af0d7a4f8391e38e714d433d585cbf5546e18d23e347c979a52ab66adba8d9d9b1d2b92dfb6be2b28a3c520a7b82c46408b2ca057ba1cc76ce8ad3637050f63fe4962bfa7f01eb0b50a33605800a8bd2c836d30a77e19a4f84e47d38287de32e024a8b97081f16305e0b27708bca97bd857cf5a6fdc81e172295c3de7a180e23b3f5f9a60bf82b6e0fa7359f543958a9b19c9f8c7f44b76de62b5bfcd4b6eab3eacd9ecfdfcce1651c97ca9151d4d77234dc4e9f4900a69908c5cf74460d64bcc087528e4a575462fd87207d1ea82ed4792ad9087ba833d83a7345f7eccf5f5bca7f0ecfe9c0efde84d3f036bedbd49d4e68104d96cdac21a959d3d9da6911e019fe3a37d678d2f4868893c4de17e835edc5457e393c2a2f7c38f902a4b654cbf0426e3dae056c475581735a6cd944e5c30a987ec5e71c8c156817f7d81db392b1fa91fdc0505be2ff90cd0a04841834d5f9d7e1fd80eb2a139c668bc976ce6b4c1cf4169de3c7591dadd916ca25757d3c62c8cc49403e705605724972e08cb15dbc0f1c927dd83c210e065fa4ea8b592e016168fc90945682ff24ff7c0408768b600426f4754cad85d92cfe9e03ec2acc05f19045c5efc7bb384346933d8688a32c68fb04a336cce5ebdfc0b42f6d55f969c529362f781bc6e3318bae35276bd91231eafa9271bd08b28faf3d6dd4ae3f15e1611a9e0d75e2f30e2222313872a43fcbd280568c1adce7f3a800f4a736ee107b5121c568c729c6fea214059edd666ac10975335cfd65079cc313a4a0efb391966bfc4a7fefb17a8df1d0611f49e2077b8288411960bab958f38fc1b7fa1e7d186b3c894fe042ed2682916de8f3e153f48faa4b5b761e8e98671286524c8ce3d6882cced4454d7f9c746cea8767df3a036c5111a7790c4621a645c3d95570e58a17abbce60bf4edb5d98c8271f885d5de45a0de06c3206b04b3772cdce4a401ffe6a6d54d2b9f690ebe4e03116307aad9ecd02e99432605797bd47d0df1419ad27818f97f9e865a22c424388e5210435d8b7aac1fe8192a0d5c271358ebad6e1edbb64d9527b6f47c7a8312f367d7769b82da953eb74ff3ffdb52f54c31a19524c9bedff22b50c365e06ad00f05b1037e3e58184f6f9a1a107049289dddc0b4516b8a65927dafa742787724ca1d8a3a52a02921cdcc36350a6f0c6863174d0f8e7924296b4a1001936301182862e3a7928b4af81511ce4469a6d558dab00414fa161ee6edb8612e37165479416bce861469076511405678bc206bb04e036e4b778b5a108e85068a17740b5409c71a666b4d0928e2f13ca606ddba7ed53036d569793ad783a58cfb95d57e861315a59593f7c1d3c51a5d50663dbb549a8c15964dedde9a0e8e9d1c29475a2e1ef21c15bf81fd3cc0e0f8d1bf7267afce2dd0284c281ccd618d65f8e83afce55b0922531852c0c0092bc4f053d5eeb6275cb60d72182210114ebab9fd768719430e24afe976e741af7ed3c76a9ef547bdc33c97bf659cb02bd22b60979e98fc98efbf1f4930f708d9c72224cdf3ff4271290e04dc90fbcf48d0214b85f13b39b6b85332f4b6da3b3b2440772e6c270f9c1bd48fbc2e5978b8752bfc99f941a55ca6b6f2ca96b267d5c2a87df1d8013e86de5f438f7c0b83114098de801419dea115ddcee58e5cf7531ac6cc47639a0dbf92fd821f220c524aa34a672740a7d4f37306059e6f3adb59c68ea1ed7fe9d514cff88b713c4a230a7c08c357994addf3f2a9f9f6de46da1d15218ae8cb9646e258833fba699af16d0d44c2754096d7124b4f95dc5a03863f201e14c97ba92b24bf7fdf59443c8a1a11e2372c9d09f29e1da9ee2ed9558ce92afe9950b695e415ed9b813b3ec6df16dee6ec6c6ccccc83741e2d8d1ce9e1d431a68ecb277e9d851aab7e4de697a362178a2dbe584ed7e992474e64cbf0588d5828dbd8918006d4f4b91ebe654dbb3aa16f8b0d7bf5c727c9f51ef53abe3c103c9e37646610b2296542f7aba2f4e75abe7c6421f4c24cc48125393d17c11bc30afbf30df9f4138a497cbab9e7e11796d85978c7f3964dfdb97ca206c1d090d856f379f9041a0ddda8c7bf3476e1a92817ba7d2e2c9a260437820f05868d9a943cc2256eb78a4fecd3bbbaa8f1edf27c734cb054e8263da028e11a337b2ad2c7f5e1ec20b3530664defecd58dacad260a822b1664ac3175146e0a3882652415589f517ff7e85852d131103236011e723c126b0618e03a3590751b0a86abf4dffbf20ada31022f6344a9505b2d8ccaf1552cec8c7dbf29e34e70c16f91839fb1e39bcff836ffd481ab78ee514c4882166ce9522ee795001a2ceca6d823800b077d3c670e1db5e20960977dc8366f5a57b83c81cdc089d6078ae9c229dcbb2e598d7a6dc33b3c009e3252444492a486fbfbfed80831b2fbf45b13761bbbe94608777d1ee6ead090b8a1b3fa6d209c4a687f0d07296bd41f72cce0217089e5446ddc750707540e832923872549df667a8077d8ed6ca6e6fa8eacf18b01fc73e2026bf0d81851b5d3b6318249e64a2ec92298268cfafe750807c4f0f788960980cb7b78a2e393e3b4aa9bc3879d5d857dbfb9e8d5576212100f2cae8d3f1230f7fe5f899a87a75708cdbd8e6723006733b32d60821a7455d09f7811c9710739d5b6b19cca649a5826298a781e8e1d0e9d6ee6cb5431f2b237b2d17df659ebadc29d9e30a6439a6af87de12c782ad4106dddf52024e212c3ffd04e34a5a74317b22af078e3efc8c6bf6b1d0b9b40a0a745f4aaf3ccfa2cd30bdb74ef0a4402406ad12970c1a47986daab71ce1b338baeebe906c276650b187a0ed190d2b565a834f3df6e79ccf080e3ac65a9d1054767890eabe99854eedd9917fd9773ffc86979d659514893397e078c0fc43477effcecc1a68ff2fb3bc51175e190467acdc298ab76199c923b5006da7e87559b963da769a5aea302589d1adcf233682fdd62ecace38bea644c5f2869978489aba7c455aa538b9e090cf990f6bcc20df626f867de6365cca1ff35b0499f663e986dc8375629c2af346dd3b58977cca7e41bbd608211426be37e3efc077fddbb1ec92a433823fa046df32c8b6b42da876ffd8a1f98dff9faa4f22351ef5b4e7208700ec807a4bf13f7e8ecf3a603977a26008b80cbaa4863c0461df6bb6cbcf7f9381997d264ae283d14b4c8a47d7d0f1c6dc0c8a9c1cf368ae189d5d74c90d6fb0053c5bfe50038bf51dbab139713067cdcdef0973b8555f04a749f254524ff0a84e086e1dd1fccca6b0edb547c9161da3d76bfb0b30dc16107aba1b90f2495090cd3b369a688a680c7bd8f1bc998703c7491ecdd7575ec10866d408108824d95375d5057b0f99f849dc9d12aa185d8f824590a571438c493fceb7a043002eb38338e841dc8cab385dcceab22a23e7d5884e832951450607dab84f74833b6127a5d7ee088aa41162819075bbb257084ddc920348b3c494b020c4d3429ee26c41ac1ac369026c91c1edc0eaedfd8248f2b8dc17b930e71fcc31ecd9e02d4fd4f03ac7415acdff5384f0ae5daa654d0634ba8a1a48e3295f3af3ee0cd43d8652206e70755c318fdbcd74c021d0c2abd5016b50b1c0c34bea401ab3caac8e4a1dcdb1afd6cfd1cc6973eb091852decc3ac35e25e72f147e1a8e83b5ed5c5920111796766fcea66d7e1d66484ddb423aa807129fb82450a49990ffbbcc9bb007c0e182042f88a23da92020584ac62fc3b6579d9edc54b71f50e36f6caf50e55b1e48de9b9bd7f2ba248f896d1ec0dc54d57d3ca2ce77b2c4b2342f847c55fda3bf3edd90c4a8009e9cef593636cd680e754cb986d22da19bb693d88af3c76445419185cffd968d6517503d8d8186197f7ef36e7f31b8bfb845249a75f7112330bdec471aa716814f06f6eb14cf4ee635583bb401e56885be10fe94eba37b455c42287b4637b7a02e6dd01dfe86b9fc03bf49eed326b305b252c4853cd2fa7d3eab738b0f79925c224eebaa7c28cf32a46fd07d8eb18fd5a62b2570e9f3e768a89b8589b643419aa22fdbbe6bd14dc7159201a6d759707f38b73fff71ac31c23b21c145519013522681b861b42d0f75e71647e4b7fe5b67bbf30ff5d8cc20104e111982bf1035624dc93692ae28a3eb84169a38dc055f2fd10873ab46f7fc10b932c72609d41a21694e30a00bd71fbcef9d25789d15757e763751e02fc448471b941ef194907bd59b4bd12cd68121b5282defe5461ac46265cf4e47a1a4cd60daadc06881b72688b98be4dd90670b4c52e78bd5fadd7492a7dee933700967dabaaa3d5702c4f50f9b2e1635cb41aad777fb156e633f5f20ca154ac09d174306cd640876fb7e17355b347e4cb11d9bb75dbeacfa45c8b29df41dff9830524f8d0409c9020e145df2651ddd604a0da05e5ebac441dc349371aa8afb8dcf07afea1a64501b7157965fc9f74c87312d534f8c932e396aa39f89a21f818ad277c3343f6eb1cf29a9d1819ffe9b72650e5252a72f1750631c9b9db175cb975033c73d099355340ef51156151bb72aa2b1f763748dec7d12289c06d8f5cb4043a977dfcb99b262ba69001ca98c6d89c4f8ae285cacc1179718b7495f0be0f89945939643df78f1e3ac10a4f9a2c916c2a02a40d7041bc258d3745bbac5d14d4c1ac574e3e70eae73c7dc9116783dd3f6b38ea88c59df9d4ba91b9a02f5be0dd592c4a58b18476acd8479fa56f1352dc1760d03a52c187aad0bb939cb02995204e4a5e89f85de6caf6a75e34ca89f3c1353edb654a526efe11bab1e76d07d35429d8fb12a2008c66c9aaf232f1e51db98d480ee721c6d2268f10bcc924f3be5007273dbf3f4b8ccd85736ec3d666040383b00faef29066fec2e6356d7c496d626a7e85eb51247882cc811f8538e3acd4a596faddef3b4c6e0af203d97ea42d08277cb417b790225eb77b65d33e99f036ef5b6119a5e99a968441f73ddf84d34c4ab9c30080d94f43c1f33a9aad4392b51b8eaeadf78dcd9850b01aa5ddd0665fce072582c80f7e0465bc5e5f60eb31ced7314e3a11e2d3f71a89a68c7fffd2f0818b3b433649eb5da7b69fba6c53a10ca1d28d539c84c8184bc9f28d095c6869756c99cc867158c584cc8f4645de22840cd5847d20a998f39543e769553b448ceafc6000803a10d80c6a2e126efb8660c1e18c01f5bc694e70ee20f2c2aa217cc0dd59bf6d65dbc91a1425a4991909611b2e9ba49e1b76ebe1f79b4c013f877a3236af7f9c9851a5dc988068dae84c4bb580e632a6e4245bb37334b352f910f5fd7c3e25da0b6fa760692f23e182fc21bace021d8cce44dfdd3181d22e8e610fe587b0d3fbf44d6213b1a4498684d2d283a58bf47358b3017006e03178745d94206850eb0a0a53a908157f649f21c4b9ee1d6c9bae06cc90d873035c65f2c2209cc9e08595a96ce61b3c29450bceaba9c598c1825b0c9f88e61cd2e3555221b136aa0030bfeb252e485cb410c52f2a8167c509a32a82a8b5c25b943a41b0c821e1cb99b7c1a66136c98f3e0c13d523839987c326be7a70bdcd6cec4b8d338a4251805139a7eb3d5833d0771ee349c15189db5523971914f2da43c22eef5d3f690fbba0949587f067d46c5936f0708c6d7010038f23089588b3e8a0f6b0744d93a20d25e040805a5ea3e8fb4ef1ed7d70da3d9dec323ed236b96cc32a775d9fc31dd0b25d95d8ca7701c30a9db8624aa8fb37812a34121ed51449b1dda060b6f55d4a94f7dadf182a6bdf8ab8bbbde6beaa89b4127a415b0951d164479ec0a72e3befa51edb40ba7b242b7b4aa32012d9553f54290bf9275099fe7f1bc5a22dd56b20d120303a5f7c45d46855008f7d4af7b1066c21ff2e4231197599af4d5689542c62cef408e90cef5ae1fcffe3d4899ff1be35648d4d76954cfa0cdbd99d6393a884c275a2f85c9ececba9605ca16c153137bfca143668c586635c59d7eaccb8edd43beb90c62a23f72d8772a058098cc03529287fe9598d186a9a0b2a65d8696843206e70627c210c541e6158fe7414cbc599326951dd53ad96ccdda12df43099b9c268ef1c28148da291d10da0ced58a877b21ef5cb8b1b0c62bc3f95862a8ac5e04987ad345b198f31cd9b0499278297f6d6e62d49f01d66246d1328ea388bdc3b91b810d746a7463332c3c32abfbcfacb554646e38d9fe79b659754aa6ab41b360295b8f91646f6aab1afdf3040c54bc83c90415a64e9fa334164fd8a9755caad6b067ae11af795e35d4f7863e59c8d14a843e541c8c181d8720fb575ed4e1201b826167380f73a821f7d921b5fef20865aff0d467e7617b2ba93bd96187e3c70b67500878bd807e35b7798aac4ccc5cef28714906d93b84f8956118823b2c130cc3900e2e57b39889a7fc9e5880f62be89bfecae94ae800b098c27fcfdb363f4206fa0b7fd0e410e851d94741ecc78c23da504993faccb155ef6779ede6380","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
