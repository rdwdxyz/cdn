<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b06894bec623bde6242165deb50718052df740edf56e8adadc1160534e3fab1ad3fad348910845311beee6edde37384b2e5c9a467fce367e063248bb06041fe0cf0eb2780d5a442d7421286958a0ae8989146109c5842df7b61797c9458d3458792ed935c60c8eeb6471828105046a69b403e0b1251f88a72d37be0a1c67f576bc21dbbd2d5cd3c46ef0673dedac884250cc6427dc12fff704331adf44fad1be08801566d98a55d7d3a6285c2767dd7b4e8c991fee19f6f27d85d318804990de32c6f07b169e9190a4b235ec01cdd58ee5ef035c429ca92027096c0ee47f4c514d42d73e5ae0ffa2d4d0850cfc2e3fa2957d808c7246b3b02a89e9e96739905519823c187d040d8779e3bc4d0b12038a798989d1deb005caf14d3b8fa98081a1290e78b5932b45ecf58c11ce4f8f342cd2f292536c3e81b882549211dadb34c9811d64c9c08f8c21231da61493676378ff1021f5db5d7cfd41c0b3989760807fba660346a403222c6e82eef477dcf3c02fb36f10a134e7647c5c5b9811f9d3a9b730c04f40246ea425a7dbe3ce57983a498ae87bf072ac58476d69515d7650b069dcfd80175ab6916dbfe3da51401e9fa0dfe61eb3f16f2023b8c43ac0f2558b91b1b98c38740400750c69cc33174a745cb0c58660626c7358103c34b48c81d14ca74f69565ffe582973cffbd7a012735aa935495c650998435332909919d74cdb02e21d97a5bd7ec3a23151ef760867e5ce88b235bd46836b93e1000ec89eeb3fd038e842677df667ee1ee1994eac8cd9e929748bf0eb3e63a1140359cc96008a0c06c32a16d55c0e7177ecbab34afe9b5b618ef74e609709a36b945c9b1654c5a7c8f0b94f6df43df27980e71703b6102e049c05f7cdf33344b9f57a2aad512d3958e4c29d8c658b054917d70026f4c06d469af92ccaf9a0828875f69c67458c3a7e0f99c78bdc57b6a3762e206c64c21102f44df2bef8ce5b8ca1fa5f1c94930dee238528311e6cb5a53756b3768f15c5c041a31e00d665260885a04081a5eebd230ef91dc23a7244d108f4a861c70be259625acef37664a7c11175152d278ada0e556f2c6b2a6504e2bf1ce5a9844a44fb3ca7f5e8513b08ef1947d43bbb37221abe0cd913d5e62e835707b1edab226051971deb50875bf210128d88c7d37509a1a5cfee6110d7732d5b3440afbe67f534c0394b08bb19117a9acfd72436b62ac8276293dda3284fa228c79cafad97c0352f58f939c1abe8b4e6e670dd4564c213a0ceeacaaef40161f0e05a152205e4a15428877fc5fb4f8864133de9e96697f70543551a567c4316eb8a4111b17f87b9973408e54e919babf1c6d192ebf000f265622e9df8cedd6fc5540ac28442c7e1b58760274bb876a50e2788a2cf8ee3d70991bfb21457ffafe490a0bb58cfdec15a5a8506581fd168ca9edff56d86fd45d2881e8fcbd68cb23dce52d3b7a90b7f52890356b5479edb0a5f23d1dc281af37c7d548d020697ab911074982ed58d517c671008be057b3bb89c0687b854d77cff0e426af0a58061c02b132da9c0a20a0e67896ea0098e51937acbcc7d44f972b53b65c5e25b2cf5a71901446845607e40c9f090a7a0e1731e5fa568ac4ff625af9efb6f9153389744eb419961645c6969c4565ecf25c0b927ecfbfb9c9dd890aaaf594ebe25c6e9d9bdc44be108eac5e81bc71b20edd2f7a078be07c44a8f18a3f43672170cf5d7e7eb2e288baf58724faa4025638c89d9baad52019d87efe0ee0ae65ea9ddb12b81c524a3814644ed84124ad759212e874799b4022a406806bf9cf7873a1f3cae5ff27155c6e583ebb4dd0e1414471d9ce93df0cb837e91319f56085863982b6d3de014f49dd9f249c6743734569e1cc97f69d5413004d6e0d1ebf38d2e6c300efbec5ea9e0c9556037f7565d1190d4be6c5ed6dfef24cbe2650fff0ec19b6f600b5f0b37a89a203db3ab13ccd73edb1633fe9041b5c3885b1a91ff4eec5e894d32f7efae5ca3db638ee7091343ec072cf70b8b8c561c23bcba37f581803ed65e95885df62014917ff75f093d85491ef61c5e1ae72de751309cfee26b48b1265829ee222f2ef2d31cae28a7c393327be44e5bfd9d0b88620ea4910072671ec7b668bfe004ce7c22b336dce74c3d21dcd17ec58ba683a58ad453e5b063956f75a5f5025bc37b71ea7ff4cf4d070185d92facaafa6dcb692327652f489bdff981b0585965dd92fafd810247499e9934d281eccc6db1427464460954707b9a1e51def27c52fd85a1078848767583b9e5275e07e6480cae61f698e2731babe2c9254481716c93aa3bbac95897f74015331afdcbd788a088a9ff7f0ddf5d98032a2ef0f233c2372bbd5772ba40d189ca9b5ad21c09d36ef1b9a66b01edc70f855109c93bcac9b8367b60474e9d0a3ed4216f634a02df71e7f162bb9906608b901831ee667d5ce7fd8f8df5fe49b6e98c5bf12f5d272d4dae1d47924a9e79c5cd4b8dc378d8e82de487a230fa3936fbcbdee503ac5e1d45f95b6a6a416118d36ce79505dc818954eb6f3175bf7e9306327ae86126891d823bdd92db0d5865d1d9d5c18be6584a18043e055c73181bc361efcabfb4eb09c5a5ea76dc1b3dc9588b955ffa7ed123af7dc991bff05ac24bd38220d295a9f502bcfdf129798bf6016863639e071ea8b0a2a4f02a7403f4b9625e7803583594a52d058e4bf831f6c10dbb70e37b1946b3001133eb012a3a0e6a67ab93a7662cc1109909874436db03c4327d469ecc22db0851557f7268829115c594d4ebd465ba2ddc532a337904b2e778efabcea953be879cbe44013c9405a0442ac5baa4ca5a835f7c4e15db3dd7142c927402be58a51c416c6bc4360062be63d6f0f40937f416a7398e22a67538eac91d73067d71867e245142318e551a5729f80bffa7544ee687c6096722a5d2b0dd92461548fb39ee6344441b89e0b86aa448790bd2b36dacec906090482d7141ca34065405d9536644de8cc0bcb25e188949fd7dda4ea9a9d6f0dc3ca403a09969db0b8ee37b1e37d3c56ce4b5ee975c726683d30a5c36692cfcc977617de2ef4034db35648716090bd7919f69154d6d67e9c085c521ceb37c5e38a13ac97cbc98ad3d54cea7bc67c7b98778b59039ad16c5a8441cf259660b7efe305d5fc917c3fbcc50becad74f9daa6fd7cd2bbd581c4d0ebde7a998bebc88b249ac85e2e313a0cc8f24ba607dd29e483a009c7c6ac11f573da8eb93274312aee57ab1fbbfb3b7d6bc1c9c7d6367f570dc349bc3121cad416f0a947dbb392db9a3805fa058a54d9e5ab36bd3f2dfcb0c074657d21db9286e37f59596cb0d48a088613b7e54c85e782d6013e059582a23a2fc0e8f2831bd3127e164fc373e771c4549e82fac5e669cf08ad588e97c0c65b89b52e4fd59a2bf82f3b3fb814e55851d474b84f7d971a93e77696c08313e025c16e74237eca670b8869268a8cb58d702ac60d0aad9a0be371bc632760ce31d0e2f704f0b26daf152e79858dc061cd6fa55cd93bfd9e66aa2e75038a12c71cc305d6e015e1aeee55a666590501d70cdadd9ebaeb2ec332ff3426bb4246f2983c05f0c7ab2e74e9ac6436fe6f0300b66f0d8d0d283a75d01459aa8131005addea9466751da54ba64cf3e5163b9c9d32c350079f0cc86d523c0827b246d15dd202cf7fe5b0c82d6244b04572483450276d10b23756a2cb330eac9ef5202f30fcb4f1d013709ea7cc95504a5a193cde299d63c7217625f9fb91ed987676067a7fefee32fa6acf34cb6db662d3793cd7ac91c08ac087cdcfd7f3615c68af0c822caf7990ad8b4d69487be23a0801a0db16acaafe1c07a2e1949ff2d546ab30446da9b8b9cd55f5a7d6238f7d5884621f560854c37754e3cd8cc3503a4c26854871b542a738179c3bbab33c579c9d1c53dbeaf3ffacd1b97162a411131fd7700ecba5c9ca053e08a41d90562a83a833632b0f8db3054dd5ef027d4496f5e5520276ea6660230974c44e6ac71fb545291e9d3123fb69ec00ea7e6b7d23afd3c9b568c477942109d49f0220e8b3af0de6b9c198c16e4cc32dee1ae9b1c035b7ea6d24f1bcf15294a92c97fb8700b87824959ff38de9e4aa9ef3c2af53fa734616b4ab302c6eb7b2c7f2d5d3f04a70aa2a0755c1ace73da70d716ef1a84b50d808e71edcca8014e2c13eb8ee67da630f72b45d900b7df5dc3a9bccc4d460c07fd420fd218c63740a1de3c6e369622262aaa8a18ea8f89aa013575df17f9a5de2ad2ae7a35bc08ddd121bb643d9966595256e9e1dba3c4d3a1d15f869bfd85592cbd4e9d3edb1d547a28544359a882cfb154afc82d4f44462bd8dd3f235b8a32ec542afe36306ac3c5156641f543b2891d212fdf7423cc992205df53d937f92e3f55bd873f41839f3322d1c4df579aea6aeb329ee0fe45da6604bea4c408fa416250ab45cd21204cd47c717cc6f7c997b2d2d70093cb1980c15bd56104983cef66f7d97955028bf6a9a8eca57b369e44646db9d4926c466e79c67eba68907a75c9348566595a5c0fdc8ade28dc0a1b607acf637cb3ee4ec2bf56906c85274ff06f24ef613e1bff2a8bec27376a9c9b57facc617fe91b27a4f84dc1c7bac0ffbceb8d23ccb2f7fbd20c4d3f31e0fda2fcb71e568f0b9b61e167c045f5fe113bbe2b286dfcbd5ddf81969e631beb2dac668e50aad883b8db3453bd00fb50a728e84e2740989adb763a58aa95203ebffdeae5581cb94f7bad57b786b1de8d459c94232359584e1a119d5819a84a15653ed16c7e088c9e5c24ad6f3625fb96f6c7b94e176f70f59e5296f940cd5958d44b0ea6baef90e04725685a1d2487a44fc19ede174d19e60a8c4f5ccfb3cad36eb611ca1dc60b4e2e214e3c752eee0eece3ea889565f88d4591a0c5d3a7c834e00fe7a3082bb421544de860c247896355163001e9a08357435a2fea9033ba6b214235ad1f14414ecc6a874fe92a7d6d63e2e6fb930b64994c97ae19d60205053d5c9506036d01fed2025c3a200021d91a271470c3c2e6d9779c1a1f84e5d273a19270a520be8832e94d826243680e4fb58efad8cc25031cd2343971ec52a0462d1dc24e1b0210a6a41a500c2ca0775d2bb6561e21f4ad7d347162774ef31bad79da131be2a01b1a0e9abc3005761401d2e84c23751f0b824eda83e7a00f8e3fa305cd14ac304449bf39fd62813f11be95b5992f627d0d8e14a86cd523ed09b2948833dccd84dd531195bd437b71209a45dfff8bee52e06c2840c6ae7402bbc54554a52c0194f5667e40b97989d3085c9ec382b7282ff190018b4e3e3a3a319ebad9c3ffeceda8d04b8d454485fd0debb6a85d284ccef9f3ac7edc333e91ef860daf65be460af1ec0d68a4d3725fe3e8149f919d54e6cbd6e9affc966b81f4594f0ff0ce0b2e8d225e545c1caa5c1224ad46ee94290f76e786467a6a5e9311e3222d68e5f702adceaab14520e9fcecc74795e1095293a56a6ebea0576600695508b22689803d5decf6e7bf52d5ae83697d6f1f5bdbfda64a80122306b4a8dab97f2e8b99208ab0ff36c73ffd79266516796257c0a38018a1c19fa6d09947096804db9ac1211b13b99d29af8c9797c130b76c152001ce87f1ed9e4f7ad3cfd9b752fdd6cb9a02eb708d9292f76ca78c2e8e3e2cda5d11531ac1b3c1f1f34e9a5a9f928a1a523310c0fd623e13bc71886bfc0f13ab010d8a49b29cd98c4ee1e9e883e23bb302db9b992d1a099f9eb4f428b8a3943920f23416695bede945129e526124145c17175a960f9f0282ae5e65c5514e1f2371cf43ff375ffa162ab09ad375e1ce5d0147091c2da6194872ceec27d51999c2e2bee8cbb8dc00d3c0f27844a347d44be489285592deb6be6343d0150964738e8f9c41708b60338d0eeebd53bcd8efa99f87264f14e1b1536a3e25a032128f2dfa0ccc4328fb1ff40e1ef184d15cb5e1bc2f76acbf843aeab86a588b1ab9a4d56d9ec04dd40662398c102b71c60020183bdc10f353040d72e296f3a9c4a4ab2145670c0a13265330823c37b5d46a93f92b9bb04c906db7b969cbf730d2d74d1a0b4d2f3d3d36978fff59add0de49d9c220d028c721fbbf460b09c15cac34bf6dea7961e504f8cbc0940e8402106d2c31dffc89d6a19a30d8235530e522a019ec8e30e27a7b75c6255718e86415cd59f386be57d3b26add25515e46c3a3624b00ffe2b00356cef3aa91f2635fada768a55d14e5421e29614318df22981620c631ddab6bc26400943f4bd8423604bdf7601a771062b2198e8087c946ebff5b4a38a4271f682f3e8c4407eeee78e172151cf24dd718689d109b642f1d685996971671ee3f3a50f3f5b3c4ed439990b6f5cb3403043a05e7994a5d3116dd98b685fcb85155dc188c02fdd996bf83cdba23ae10adc25b3e0e176158f96e97f5ca3fa02811e215e6fc0e44825fad4cd387c1137e718de4b6e53a6b8acf1a924205d49e4c700ba1ac1a859e7c30b6229ba434289af79579ac3d37cf4aa1e9f2217e45a6ef43c30f813ce867aedf883df3218b30f6f80c70e2d00ca49da0bcd4721fcf7f40ad47c2d4798442c29a86990272b74e30fdb99a22c7e22fb245d7a1bd108cc3e3c466fd63f45d3bf81f44f2260a50ce73aba74e7d2554593180ba3a0632441ce19034e262a82efab8e46ff11db793078ff44059deb45ab43c61f531832eb134ae41f79181e5ad57ab0e062aa20e0765d229246dc14115eb6bfc57528f505ed9fd256073d6a4dda64457386e06f454caa797de04ac379e9942430c7c0867d9a63b24687c3f7099e268943ecb777d19e6fedb90d81710023b0f4caf3f8d3b3dace18c84073ebcf87f92014997a5cd4c9259bbb6ece38b99608d2b57febf5b379af945aee04a4fac8eacdbfb558ca00a7eeca1ee8557eea0ae8df787ff9c502b9111ac833be70ed43bce9fd8f013f379d6ce5dfa0e29fcf596c6e8fb23f2dba8c17dc1af2af291626bab19cf6976329036e21f5a2ccdaf237f7f217bfd1b3954b187f71a83df3ff59e202cebca678c0ba78aa8e88bfaecfe1354cad0fe3efe1486eebcb814c8df65cda9db905b83b2a347da58eb107f77a0fe55b4b1a6a1bd40dd70f85f03a0008da1190611f2e71ef68f7ee656758281f60204d49157ab3d668a8615c6acc76770d60f98cfc14936d04cfe13b707c97773f311eff338c8de0da550c966699ceb1e91940828b13d6090b2a0e0ab697fb233e488b00b9dc4bb1705e38d722626a276dc1fdaaf106fa0eb17a4ae601415d9171dcf9c71a50d89edb118b5f3bc1e9fad44edc91627cbaeb8865fc2d31a254cd5128c45ecdfe807783f3c96bc9d876929b86a4368914f6cd13a4bdd11f1840c6803eff0dfd3c045b2e89d64640c187d1bbe5679df9b73b927599f0db23460ced06a6f799be1225ac06d04cd0eb0c11d6461ec792bd961d984af4341f8f153d94fa3a1c8e093e5d0149f24b1e0e05ef74b213930f5fddc70b6d4e6f6db3389b26296cdd9ad3d049c89d9b046833b0d8ecfe98a0e18c875751f939ecc6c84df7a3ad09ca7c1ee9977de44651d7119fe3a7f75fa236969fe8e7718a64d85e33c0dd4f516768f61c191c76bfa88f21aaff2e2b5f1b35da016888775a73d6997b26d9e91a67e12e51d44be5478f5c33aa216d028a1365298f5347cc49b5fcdcf2597faeaac9c2c9b19c5e8a7af88487631558e30a13a071e2133a8ecd21adadc66e43f07f4b904351814720996e3ec797b8864961ce904a33de58e55dc87c70f48a7f5374f66b19095b37c6e99bc4b448055e58528e47da1372c85b45046c30d527814664d41a4ca7b91ea0f5dff82fb6305017219a60b86755f1e83050f57efc18e6a23c86255aebec9c6e114d0937147dc984dfcbcd90fde2f93d041b95e4d5400385c23f8072e532abbdb532c853877fbe854059fa3592ede95a6a2ef58b2dc8d17950bf26f2e7e0bea50e4dc6c1e1ae2787683161bdc0eb9628770d382286c754522ba145c33b42e2ba8d177794c35aaf39dbf1579afec42d525a7fe016081b69bf1eb06cba0415061089b70786235581f90afd04b812e9f58f70c604583c8632ebb64da2d9e30523d9d6566423a4cf124bda9130e5af70863b17ef0d1e253e7e783c951cdbc1557196041f8d400497c53535f2bdc86c1a8a56406e898bf44337216d9ef07af5f42c51c4057aed88046e52ea54e3449189f254fbb1a10f8ab697dce08c5cd3aea5bfd61bcdf8f63d376e4937d083531e404f7029d8b8ea408d6bd22758ca0556c6ed4a1f5d13bb6428f1b8a2ee2a396e9c776242a3c12a9b8e44f805c2e69d6e2881913af51414e4beb4dc2ebe7c0d21d455de296491b6b7987fd6a9e51dd9ef67eaca6d07c71137640b0c093a52e36a7e0e712e46b4297d844692bfce9b4112370aa39b88ced02e619c7f9cc92c36a462809a92ad5837230b3e7129242338788305869b02053f9b7e01f526d5c654e0565cc29ca0f5e73938ebcee02ed9214b8e686ca3ee5f47e2eed8c53f8fcd21af1c16f0ad15c6a2b9773086c98703b31f25c0c60ff587b140034f352838d07c2be77f24c420b1ac62528cba08d8c3210a0a6e9b23a7113fbe57878c697fb7c70045e521a81493c28ae3e5742edcd65dcd061901a2cea2e4f2c15ec727af81a519e557eec67619f3185609fdd825ecdd6ea409a234a314a830a3388015c1a10fbd62831a14d0be53f2abcf52db89cdcabb259fa11a13dd53dd3f046ec3b6869327f6bd85412901898c64195ccdf09f3182d6854101491e20ae64f0f7ac9dc58bd37fe7c97f3f6c30e4a53cc9c538d5b9b8d8929eedff8e7494615b9f0ed4f550313ff555489feba232b2f0a35f036aecfbad9bac9bd0e17a33f2c05b2b1cd49c01dbe40d7866c914cf268591063cab6aaaa2aa2f783b6f5eb9cadf96cc0543f6a63343b49bb12321b3e6ff6903c8535c0a3c57423c05cbb562946e35b1cb3a2d651863e9f902fc2e61a6d42eae55859115d2c2a82b15f7cfaaa3e7c71b87e41561956567cf199dd056cea2317d7635c753fbb191cd817461b0a019a2e905e072d637ee64b5d106e5669b1f1a5401bd1287a11ed4ca7b9962c69200abd62145453dcf28a7592dc5b6e9d22e00b7af3b5cfca068a1d1f02de654dbb63b7a533fa33ca22438c54a5df22279d715e8c87aea8078e0abf943926ad0b7672c4f33c7395e7f29986853e87a2279568a6d946947f99af22fbcbd39af12a1ee53658995a76cb35d6970c64919298dfd308fbdf23cb0f40b9b3c6c1321347a31913825901d114fbf0e7b9cd4759b29c18235c24eb2e17a9b24717cb753346ae8b9a3391912a43bebee1dc8a759ec05a0c7f2430f047afd6326b0d1dd779c7509a94cd6f45311d74a8726028ad19667ff18a5896e389c1a5960dbf32d267c8a0ca4b342907a7e978f211266515af39ff74d1137750c7f0bb0df5193466ffb614f2995c82af2cf665a7ac29e7de5eb2809c046d5394eaba908eaabe871911b52b1a82633cf4fafa58b3fc19593240ee8ed9bc7aef0deb9a6fca6c308d19d651167c7ea7e0b9441d73334b45f9f7f6a0a3248db86cc4c4d812722d2c46300b0d92bee07cc4f8851897228e60ae3d6671ff576474bfb20abc2aaf7f652f084ecbcd5b39547d05fa0968da0f133cf7531c9e1521429295aa3740e9e598fcc445d6f6e03445d4463ecabb492564536f225aeb2b864f54770c689562049af5cec0105f89286e2a4317b885385322ddd0c2a2676331d2834b2dc55788c7684567e64ec26930a036c4ee82233bb9dc7a2727d584485da2c455f1e97744b386ddfb8bb67bb417f4f68dfee6030e192b3d2ffc28d67846e9b267b1803df0a8500d04cd4e1ed8b474278ccb02f11e9fc3d50191d1f7bfa17039d1984e2f1379296242b132678a72cd96a557e5e6c24314b78b91e1f4f6f650a537be55e0d977294750e1baf25bd9f7bb25ea68e1c6f454b28b44684c430c9427cf4269edc1c949463794b7b1dada37f05de9a97fe271541937000493449cb6f5d241569e36d311d38317e9859a1a288bdfd8d9d479bcdd5762c32aa5670b336378bb9954f8d3334c41d56054a9a06dda007ae63c64b3fb167ccf356ca8974e4818b8f7ecd7cfa7b55d250cc5a9ea0e6c8bbedbd36f1c37edcc9f5e10ce5827301163ce91440314733ca93e3404a3b8911bd5b589146a137a28b7cc3019aefd6427e518fb844bf2abb68e707154ee48de366d8a918dc93d01f1f7bb8e51aac8f95b25a81674a2d9ed2184dd2d1f102975f5805d8dc2354157a23b10843e09912d116fd19e1e932067bfd417004a4f703c6ca433848c92e52eb784c1b74127be7e29d3df81bf4e2a8b8daee2cd435dde5012d87a46bc4fb116e115ac0979e760f96911553a3f3018286671b406e0cb12ed7c010563ec5ce6c6edc5f42a0728b85c083b90669482d4e6f62f9f9ea03b93d64fd750230f60332cbdf9c9e751e32ca814bed9e0240327992b3156ea1f09b3871c45aff8a338ec49de999fc43704688dda9c034fd95b4f6dc4962b57790955ac559c560ce982f6821fb57206c5dab5b9eb6f5446f016d16eb4282d420bfe4578bfc7e240d36ffce84b8f973f774c894ccadea897f26cf98e677cbd88857e9913d848ba337f82207863ca4c9c8491632d961e6ec743eedd4a1b86589d9898669fcbf32484e7af144fad343f7da2ebc1968b70ce148d495ee3012b89cc4edb8e14cfbd3a55667fc8088ca5bcb1a7268feb7eb4bbf1e0d225d07e3e36647e0390a60f0a7ec66208b3625295761dc2bee05a67a42d2665818ff26fb7fb9dec8fa19e58b49d92149f081807c2708b8f815fd1d0dd4ae9274fdd1cf25e9d701eca28d1332feb7d8ddcd92e3257a924fdd63fadb307b5b2f5b9da65d45ddd5abaa8d99ea4c3ffd99e5e6ba063e3eb56e14a45beb751c899e629bed8634a06c86b4b057d541656bfbfad107ddf7b6b12932a74dbe98598c8519e3df6ea2b94d931a4e3fc6a9ffd14e481f3d69adb6fadf141651de0bf04067632a700072ececcfbde88b3078250f62b57cfacf06553942d42c7a8291a382da8f9a905984cafd165754f668d995feecf62aa38e0b783dc6e58d77a3561fe47e03e00144bc07c1bb32bfaffc4b3680771eaea1b482e41f5eae5c2e4b6e9cadd45f1c50a389175ac881d7b5a5d6dc1e819b1ade4b58a0211a33ad1ecb90e4133dd5792274fa443e586ca55f4c1e47bb7139f12321f9ef40d2a3351e4075040e4bbcb2e6093f25c7a0c2d972477b4d5213f2ab2ac30de1c436d32d3a8908e02efe9a792ad0644c945f49c525e3f9ca84778edd7e3d0cd7c669cc8975ae832300d57ebf24711ac246ccf78081105349245f414b9d1f77f76fc40c969525d726cf8d46d164c1df4ea819f00d86a984d92a0e6d9ab0b19679e296bc351029bbd600ff21403534009c7a768371ced797bc044120861648faf617bf9b1fd6bd242fba2dc330035ac5a811734323d9ff4ed70e43fd89f7d032ca13eb291ba8663d6de853968ab2692de852d73ab7da8aef16766b7d4d62c9e21fef04c885a49a79344f5cb5648cc65ff118fa0b2e4a62d59adb555fe904e5226c7b5433b98511f64fda8923a741ce3162f5ee79af636b387810fcba3198e2cd3aa340a931ebe66b3dbe492aeedabfd7ef78eb962206bfdd4d7a0df46416e5178345d8269148bf227942a2be0e4681aa105b4e694f3901ad2073664b3f5b3dac856fce67d119da7558a1912a3d6c9ac05870fc5cff067e7a4b603162986731f9e463dbcfeb6582cc2db37082c4167303727798f21027193c95b1653ec167d76e4d91583b683fd5837299b1c797129f4e5e92069d8ad0b5224876c66e52918ecf0ccd1941d73577226c95be5bf0204d587f7f06433fd032a89b117f0b2481d3f8fdfc5aed3fed9b5c4142a8a7d3c4e782becc7d0c4efdcf6831c257f49aba697cf257e3c3421773a95a5195b7735ea10f83c30d35b2b7d32c870a7f4839071961db495cc75cc4f0f0921cbd464f577593a35d8085f7b03bb2dedf6ba2a68b2dd3e973057833e0052aae13d9d2ad2c0d29fe7a066adf475716330bfb49027d1b108086dca0b824bebf55e768826be1fe58a93c2918e6c8a1f74904c1d5ebf7414de79cc721b6c998ca2aba77feedaca0861f3b388910496829152375a213616c089ea230f7386f7a15486c5ef86eedae770d7e01cfac1d72b78694d5fa41a2d0cce4557788ebd0340ca38c28b4f462517d1709d478d39075244398d526d38f45ebd2d327723d2a4c1df5e57c2a0e1056ef8d888285f6d9cfe58fe2dd6ae5266bbd9340f0de7b9cbab4403fcb7ca4d78c5f7567b96c3e4dcf2e425bbd0bd6b7490c406262ae6bda12b1994b1f92bd4f28525db31b7c1e56798e864779aaa65d1e018080c0b1c0c0ffe0bd3a4b0f899fb1e23e5bcc28789b4ed9ebac668ff71f40feebbd05a29ba556ad48206b6d5aaf7c9f30b448048ed32046e8ab109f83b281fba44ea8a2ba764539da7d5ddd0d37341010d4e32bcf89dffc6db17376d6e193fbda6ea932e9214470712711531c037111c0e1a1a54cab698707be2234ebcb1d3c1cf89afb9a6d1b9768763ebd993a174b31600d95f1ff1b008d89711bafc173e6515f29516ef4c6984a78cb797ba72bfb47e05f70f5ae24108aaa1360d72271540d1368486e4177d240c7f34b2ebec5b3034605e0ebe05ed654b3e52ee953a298b993220bf7714fd732e69df7a2a0d79669ffc234400654684d2d5d8239192ebffa57c3ca49a87dc22193b89bafd7b093386f2a85f64aba9fc8da6da3f4dd22b0b0c0544ca123de8a7657f74c722f96ac06598a25f0d8f968993a8eee9b8cba737fab99c86f99c9adfa61900a981d56a34f2259dfbe3e31797fc72d99c240b80c24bc013d1abc8dffd43dc9298c8b68cc8009544d0df4b2c9e32154dd89d8e8b0de79df7ae122ed4521666e039c621a525d3e0fe51e3592e4ef61512af088579a458304eb9b78431df083039728e876e5a6b3dbf4fb86059ed19a69c5224c883a541448b917ea5894948b410a96bee691b2bbb739df167a7ac555377492f1c3d8f498d30597526fc21ce163c8f368e9b8eab39a6beb9689e89ae65edeea4c9692644a79f36bf5832f0db95d7676e982d03377b5c6c6eea990be5aaff7b4d91067400cd724f0d649b3967b710d6e535d3f7cbd6d4c924a5f7df856d0718c661918d37a0d00886923ef40e4e4ed53a96c295421709697dfcc9c48e692e2bf87c229b959a679a651c5ce3f14af1f3760b63b9dd56ff371751142397ca66615937a868d95e29d6ffdc40f25b4772b5296226a24bff4f299b0ad397f74202fbfdb71698eff4a479d9b5ca0a72cff27951c730c151dd44bc871b33e4b40d03354e1b2ad8256e6d978838ea9d81ee561f662583944ce8557408ebfab2f0e4de1c4ceafb7a5d9f5d182505ebb53b487fd0bc093a5b017888645c8125d1e37eb5d921d667179269ce71cc40760ad846f8b740a49e38a2756be675313dd51645f1e6942d2ea1b01e2c9cf65749bccbbf7b5d18d5f170d5b632a4f2a2c765cd2af7b467e044c7111c6a131fb7df332c0f3962bc865bfb1a10145298af00dd2bad8570803caa8cf04bea3e32ce3671f080a381c00ae895c82f7981e055779578222c674ed248e4ea05fa9dafa5d9d9943279f29fcde843ee46606ce09ef41bd43cc72be58a87cd4657a2d3c59941e2da7a8bb45bced028b3648a83c171949721164eac8757159c47a7dd1cbb57b22e37127b139733ee0be92cd24c6c6e9e3bbcf45cfe9acd2f98bafda4a6150e46551d9078a413c8ac7e24dcb090505e1ae4a01e88bbb2b78ac408d1a3dc8da3e5e256159d7c732d98c3fd9416d3940c206b53dc95cb535d63fdb8fffda1ff997190d3a53b0045b4ac25b91acda9942f700d593a6071976cd638720aae858bebfcfdcb351788954c049a845adfaba4a9ccb32c96a84cf26028f05f44aa233ddfc0fb8fd09ea8e616adb2a4de6b1a6383b68650f3284b02041763f0fd1265facde21bf0e7f2c3dadd523f41865803a6a6323ef1afd0b77c9ae7df6ed7afe9889a360f527a4a9f41ad1d26e2edfcedd5ee979aef20b8803b74fc10f63e7f2195262c91fec4dfde43cf86d9471d2f3e8a524ba89d5b681fcaa564f78d3400f1ad204911453cfa36acdd9073c942666769cd8d4220688dcd391f39abc2785bf05a98cb687d689002c18cd9021d0a2a446cbcf154c07ac07f5d81f658d6d2c25beb00274b652917b6276dadacb4e61eedd4da6b0c63f01b93524bfff7b110e76dd62a40339469b8af0afdc2fd742c8afa3b1f6e74b9420100d5168735d2494c9b8a4bf505578271bbb7597a1a127087afd015ac53facb349631089c54d4de592af8bbf11837c1281e0b288ed0ba93ab45fd3f40e3e73e6eb3e58e157bb6e2bbd8b4f7d4392a295c449912d2070da6f7aced98632b949cfa6ced07acfe57c23b6c6b7c8dbf27923c36d00b4a084ca2a60a33a006998764c4e012ef40adf227cf7a1b84a430c98c31b374e1143276736f9fb4e7a7aa9e498107123a0eafea2c5dccc87cb9221b9fcbfd84256edc9332a53bad5bc0bb1ab3d180738ca5f4ce10abf619ef9a31149757c95ed6dc94bef9ed63a6bad7705f81cb0021fd3909ce5973af8dadbff3e63dc903b6307d21c4f9dd3a22bd5564e713773926c7c625a47f8841f922f9a6191b73162074cbf2a7aa113149380c679a4cf175f4fa02ed2720eb664ba0e12cf184e2374b0876b88e9a1425019d71f09200aa59a6369f3e42c116ace5be0d467b3f734a610ca996a9560dba363ea159f66e8f11003bb47dc8cee630f20bf91ef7da0d2a66fb24aa9836042f95e80a02d34a64ea2c15abcfb78d12636d338beab8b6a856adf20f9b2e718a8c912b67cf13b5cdba867ba20d29ea5cea258e9fa7f8c4af122cc987bac317c95cf261f7e8604ed7e7b97efd614b2a890ccf103813bc294faa63403f5eda5f0e40b5eb317b7e917f0b21681dd87c48bbb1a0347b150ae144a2f88ed4fd96852fe38744c32c8b74d8add93d87e5c1fa6607bc04b2e00227592a19c3969fd6955dec986fe9641b9bd81a00b5462acfd46e7f921447c72bfc805e54b4bde21c058560d66b1a739a115c6665b8d8ee282af52293b213e17fd6273f0e0aaf6d713c40aa2978a65426d2ac983e5c896b29580c77144a238f5ff1e7d10feb5be6788136521627c8c1993cdaf75a8724c935cd4d05f106aeae1b653e233e0e27314cdcc9a3f5102cc7983b48a8da345a800b9fd0bfdebdfce094cbc335e4abab10ef33c49d7187daa3914689422a549df1b28aa41b82722f3ceadbd594cfb0886d647ddd4904272e7b91d6d3c8898280f1dae82e44a8ad5ff233a91eafa7c793cd80bb108c67391c4347688704625ce0a962c0634e93df789efceffd5967b00b66e3baf5c68b7c8540680b67ac02a05e0ad39ab5bc284238d004f2849b886485cc2c1d7ff34b04585483f82c50cefa0f38020195b7dbc3c710563307915caba0c57bb5edeea78da34800a2425833ef7aa1edd57b8446e47cc062bab33e68726c257e8c1d3a16865c095a9394e5138edb9708b49b0681d3aabb7614641612751e4ab267679f924420f50af73140a6dba61d5cbcf8878a10e0d5266a7f39b4b3e9711d0a088ff8a48c8dadbf46f46c68edec1a0b95ed454c1e2f8d622fd7421e33fbf61bb25980a2759fb9aa99647de9b86e389303752cc0bd2851ebcf65b73d03df72a817fb8528199eac6b90230abf89f5a7d999dc2261a799f467900a686b056f6289ba2d60d73be826577bf48ea3ccce056c561a5483c65759cdcc96c353633ce6ae661203717a56471ecf7fc6fef1a908abe07a24051b8467fa052e1d1e12365e51b3d62c1055f2624fc491fd0a7e7b3358f377e0462eb57e446ce7b560a6891cc8ee9f8c589fa04b1eb2e333de7ae3c90c5f96beace977a5da3846a5590fb5ff70b684f9ebab2c75c4405ff2364cce5c73b9753da733f9bef6dd2912f342c8f9b1ade7fab43b46685cd828cbbe1933a7cce2e712511bdb34a6ede7aa2f0a86eb5fc4837acbd1055734133225a40b8ec98dda35ad13a7656e6be20f72a9b11c5562da04c43725568a04203fe19d34d6da7fa7dc804ac6bf9d1691812e70abfaf7b4ec66b93e7a9b0ce683d639032fa3fdf560ae970b0ab24968ff4e93b7d164ab27fd5f6c9e365265fdfc9760208c09f77bebbe0fcd4087285730b842cb8e7b547a7219c3700a19fb63724515992d016276e9cc6c332d8532fcad24829dcca2644ad75dad99d005465e8df192d12f43c14b443dcdfbeac1d2fad37ae5a970ccc55cb410b5c10984f3e7a726ab800c34d8182170eedd14a857af2fe8d0c3100ab8b675d0596c2cc0d57fa26f8c6c2086d2d443cc67ed3911586cc5336042156535c64a1087539fd4e07029ee036868896c2803a4810e307a8e5b27fc2286f2880fe423f382df2df877023841c4511743f7d28449205bb1be1d4b18e08ed52b99709ba36c68e74cf105ef8216673a2cdef49fe05b5849d9ef71d49071c641276d2ae57ba1fd1534dc50ccae39bea1d888f4779746680ccfbe13ee661c7a2a482fa22ecd496f8cb72fdb7e69e37efa942eff01a83c29c67fffe6ceb8dde66d767b10379a80c84765380c3d16588289eae8ebeed9d8b8d9531fb88a7f3e7f85f9c8b55863a54ba393f75a37c875475e616123ecdd533bb1a8cbf69c7214b5a6e12038ebda276ef5eef00c56be501164b66a818ce72bb6b9cf18e84d8cfd308cdb0c38773d7f7c9cd087e658afe582c1b703b0b14f1593ffe38c7d7ecaf6dc8702e46e3df64689123011158de1795ed09612b00d3471c5b28905e4290623f8cf677001a616c8ffcfd99ee57cd5cc266b5f6f96f00f8019c76ae7a9e134e465ede54e758a4384660f43e1c7961466f1d8473dcf82cf8cb3be90b1a8847f563e55aea950cea48f9980c4a46721a32fcb9c270d18d796cd1954cc515950cfcac3a2bd9af607fd4a5aaf1982bfba16a3ac7db47304979bb17f0f443674ec37c8d846f9cab2484e280f5759cd31953e95e1024200543296100b57ed522d6d26637a711a62ce71bcf194ce953bee70ff295c3615fe81c1b42f69bf7dbdf46b5139089de286c9cdfb67bef1cbd5efbd91ace8e27f433fe94835c76940974c6b0b7d9fc93d172e13fdb668c5106adf39e138a266c5f0bf57eba12eeba1fdc09f3de9e972a63078f9e6e2e3b1286f1583a17aaaaf57a2d7c3315e99f4e77665e4cfa9d5da8761af70e4c3869c0dd28d4db6d29d577a3f42f9727b5ce40c4fc82ba2a83808f4b2e5d59c91a4c51552643f4ded6602583dbe1b2212a7829ec762083d93ca2cfe12c3839df363487b3da9fa3b89b383790386c880426202c98ca082facc920f2d339144ed1577eb06abdc6a3e0e08fe072439fc96d703cde6ec8c0147c06960a8d05e78f0119c7e4a114f09ee1533825aa721fb1f5e9f08ec60ec44f9ba573f2d073db62462aeb1872e3451a71b8cd61d960f9c758a48ca6bf754751724f3407edf320274c5e932aaabdec8f56183b02d17ff3dd77d7738d33438e1638a121e14b1a8ced9184be53ee33a0ed84f8f9d8e1dc53a5a9c0255cd113419f991b4e7cc42a4bbf97652bbd98021cd57aed74c42dc8abbfb0a099cd732d0cce7d8e21a81a845b9aa5d990a39e094a93b6139b6fc1d681dd81f7bfb4d9f4e2eac4429e4872e990edc8093bb7e5eee70ae20436107e06c851cafeab87913b8479f1c3604659597c574828863d57ff0f9c2d7a30711b6a0f64dd77d19999bab2a61c90bf9f2338c0af454025abbafa455f69b8d613e3ac9448c4e3143cdce0c066b1789c5477efc0f5eaad67b97fb5597bfcfb1239c12648d5736de221356f151ef06ba0861319cd299be2f916b7f3f2ee91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
