<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6121ccaf89c52e90e3c637b8aaafcf42f8daa0274b507cecabfe11509428163c207b476678cba022ce14d1bfc27e0170622c69ca4165c82706beb2ae2893c486975e319e93ce7e37061941f7ff9d2b9dd53d880848f1987303d0c52c68ec6cf342352ba53d6a127d224e59dd51e4ea38cabd75365a918b20946134d701f4338fa09753ae2dd0b4d6a6220c35079fb1f9c670fe099776e142db3557a34ea10a35b0c177f4f6c618fbce13963ab783e53b1c73186342bd061e1917eeb3e332cd739930baabb06048b84768e8cdd1dfc1e60076c4099cb2aa2bc0602c6311abd8c5d93b63c533572a0ca949954141b0b882d834b3cb0b9612523fd3a0367184b438f17d1db65a34edff0a4800425a612663428f2c38649d04cca332a3fc0590b7f141492e55b042288e97b7a8d2941114f3fb1986460bcd4a41109bc58ea3ac5eb955e33a288c6f65f058f3f1c144684b9899e8d96ee8f7582d89bff36fcd2608c3ead67a49c65e64acebdcb71790a33222c966158610ecc50dadd9d2cfbf336b178a606481c940e8408b41101680412c5800d069406de23f1cdfb624865bb20448a591d40cca829d37a0c171ade7a54200dd281625a792912a4af26c58a02b89a22c49266edf6ea1ad12a0840e3c54148d9e7ae3be18c4493ddfc9c6deb43ee84ebf1c6fe34e3d607d996ca8555ff3c438147eab6737d055dd856cb076064a23c267f402b66ea668566c304e39f0a1e9a65b477498d25df91a067b57eede3e50f7d303ca0c38c388cf780cacee6dcd7ff4f5fecf87218891b24b6f47a30727a41d6f62294e2623dea59057761e3f796291abd5b3e51673b778c51aa3dba2f9f699aa018fc26697f0d8e6e66b2afdc692d8698f25d00e7740a798e9b81b3b4fbb9b8f5e236c87a4186d56dc6fddc46c664460f0b38b6cf2f6074994d073b7963534a0be1ef6b92e1c7d0b5e25a4d3a9893b170a6f539a4a484f56c77d656bc6c432d86c704fe9e9b924279972ab430b606ee04413378deaf3652b70940c6028f096faa3a1c0337e54987401faa3fbdd395b11f1ee1a1c918e26bacd1ca93dc6e343209aca6adc9bbf47b1f6325db6b0a3f447d7d91d7de20c61441e7244c5ee7419a5bd86ac29d34c1ee27a8ccf55dbb41ee884f1335e621424bb1812d31b32557438b19313586e19426cf6c4fc82e2c2c5e226914d58a64ae994c92cb956db8f4d3f52094d5f7ac9f645950812417fda1ed5be42e044316881653c0ed6dcee325c70254ce25bcae424439c7ac52c3136414ae23d13fcba5f17f8d795a62a987838a93c741063d5a4fa4f4585176dfef272ac31999b00360bf477dca7731573e450ac5ea848450d18e71fa9a102223a8755bcaf0355e6a03260d23f798fa087d62894ddf28925d2677d31e225a22f5f6d18509304ecb64a59f203e29e0bfe6c2cbbf1e5840014e356847782b8326e7afc9dcf2c27806d44c6092efbd509548a622ef9ed34a1c6ccb9ae8cb6ab78b97351bd81d2794b9f5b4c1daeb599121f1f033a4dd206c55246cc7630982c25cb56f62db00339b40753363b867711ffa09f69fcbece71d972aa05b233417362f33df96e83a6f6e81bc873517e5886b5b3e577573666eff0dc3f4cb52bbef46603f803259cfe3ced0a57d6b0312cdfc73973575bde41a2ec601b120e7a4494d99ab52acdf304262fd73a5d64227e1dc15d4784ffb2b66e76dcdcf72ecd7d80a6fa11c7a6f08719514bf3a31040a5e1a09af0b6c6d6425c7bf060b79c74d2de26e023ca96c9ed23a2ea2f707ad1f5f97feee4fd3736a540e99f13be9275e13f49c7518b3412b315f426744911102abe28dec3d8c82185d82274590060fdcf356194ba0c7370ef4b28ce744d38c3e16db4b9f5d4e79d1d3a6c4777fb15c751ac493de070b517667f020f03f59334558ad1a890992d1dcc9dfd1e4727a785233855bad93f146004b81488e6edae54c278e98343c773f95672bde8712b8a8aac265109b687b96f8160fc104e30f8fa7d24c8301f89bfbdea3b1e26696e7d906c9c686a1d46c8018098af162e485ed4d2e259f5bc326406e32b84164372dc6e39269410d62c2149302bbe0739976fe5774af3e514c8cd09e5b879c536ee2363d40636d9134aabe2bbd24113b85b8fea510d56e1cfdd87f9ed9ab3924851b186c708b0e1217303f396bc8e5ac41d947064507ecee783a8819f7c26f8597406061ab962e7c71df42b16c8df4b8b87262a42b655961144b038fbd2d8bd1569f3af503e238032db0c7b3286f3323b145d2a46fae237a4741ec2a5835c4c0cfb1791f954f947ff80bb2aabed46ff4ff0df88d812784c4990bbc1ac0e8eb4f3508c55c236113c141b0baa205e85207d5e5251d654db9df5ba8a8b6dbf45c18323110442219a2fbd1d58a4795de8a127e1bd5d2177df134397e3ba5b2dfb547a21c244958ce9b5273f215a0e43c14d49c186b88376fc2ce02befdf4dbdb92ff1d223da6c96adab38c462bafa4778083322e613c0982729791b4d5b7d682ab333db79dd715cfb0144448f6bd28521a2b29e15bc4545b54de8b336ba655e56f9a1247823fd526ff9c5d837db8771ec5a1fa86010ccaddfafe23fcfc9163bf168eea46e78b3751315bbec5c9f145024daa8b57b10bbdb131949d4d4b2cd61f7b530638ce609d8e0ffad8aae1a3558d8a41490b2ca14354eed5da8b26dbf55a3f8ab54e1e3261a77fa0db93771c72050134910cf6fc6c3ceee4111745fb80232864c34e6b7a3fbae0eddbeda9c25cf32a62968fc73648f02ecec2764e5c10d5d8140b1a660137b6afe4ed57588a03a56606f83d719b18478c3297bb77b9b4f29966bb0aeec1ddf8eefa4da68169a008c40811e242f67241c19db7440ebcf8c51a3fae2be456a868c1bf0171aa66c3c4ac8a783550c27e9b785da91c6c177cc8ac43c3833e0ed11376e7f3deda562991d273f482cc736e64594d0fd49e2a9a1d2b2f9f75a2cfd1fd59d49b4d818f82373b85d5be96f138ef44381ec16c207017bb89e6981843c20a033130996c01b0360a85c75f830152d74ba5c095d2de1b51201127e9f0f670415643f6473bb6fb24a1486ba0be9e33c6ba74e76a5a86307e19edbf970b7b086d7341e1fbba0a8478a4537a94443c309200fcc3892f34dd9b000198a8c6a8855cfdd60c77c3c06d90c7739d6bf786a6116accc9d26cd7ef57d0bfadf2881704acce40b3dd4e290dd0ea7fd3a95bdd0281837ad34a857133e9aa393cc54393d18af2a3a48e3e2f4b1706a33d0f7ec9159e9c4affad2665edb136001bc205a280f99d701283d712b6194c2719fb40dc77a85139e20ed75e0a5421883e9d6d3022b5b666a79e760618cf2b1c7521e4be5c024d335cecb9f6f7d796e07c4d0b74b700028ded922348efa952127ef839ee8519860d9cc2b1208aafed1754a48583f25468ccfb2e1dd817d29682dfbf9fcb311568b978b73afe6ce36fc928676f94a059e5a5e1d244fc4ef96d3270036da529555d6632c6442d552ae9cc887d0b62e075fbea81af4e4e02e3ac7f4261bc74b9f09d362011453d7d496118094d29130f7c8156c6b222a1e3e27aac6ceeeeedd5a2ed6e2c43842daa0ebe830fdb0194b8fd823d192f3efdf96ba49ba1e1d87c5d15871a4616dea1426fed7457588a7dda0afc558b1f58e6ea2c05b9da2f8a249b4751fc42e858df1b6fa948be58aee9b872728b6b0b89e904963908453a55fc75d5d7e6ee7ecd8ee5dc814d0852e32b2d2f70d64bb3ecfa0ed2ac8e7f2712ecb5ab93d5fa56cd5f4e9c2d53a904b668d7055fee88489a2dc72237063118c02a6a36e03b8dd35057f4234c488e7c663773813059bd0cb60ff37a70bd4bf82ce84d2352fe708c4070a707a352f4ec390a13f97273b600f80bd54dbff7e8e1938e4b32a093df4dafb83ddaa78a002f184f92a6aa0412552a66e480c088a91e5fc539f51147d55651b5c6cd5e7af7da438fe9cc8f7d516c9e7300ffe18e2296af8634cdd802c3f5a2d1e64246c38d6fe7e4d183279ef549453e4bfa2a5aaa9902dd11db3162b6f1e84ff210733cd59b2a8833e5eda13f6b62af8212d16815ecc3a4ad010480567caf2af2fcf772b27144265ee38933e5fdf82488357d0dce50b2831898ee2cf4a245591c844fdd96315fe2a6840e6513c7f33be9eac3939926408b409b5a8b62bf8e6b184ac8634807233c3ad1d49d6dcf1c647b7a527b43f0e8629a3d269d2136092f31ed9f0db8f0a999f165bf6f8f0401cf575b9d92369b9fe649796e105b6368e2c91f7f448c72e9fa59e925d835f46d74651b2d95b3298ae6c7c5065a2cb0fd6214f5b6431f545abecb29f43025f947e5981c0b940edbe68dfec5caa5e16eba42dae69864f582ca01bec357a24f2b066172d7d89f97866b69ab802e94aebdc72749574ae98063519109c2b0669e0b58176506def54ef10d348a2fa8ee5ff449e5b2065ed5afef2e36184600489d8f7ae325b7d9277e065fac4765d8bbdfafe96cb6c77364df6c255d195b0c8d1de23df575641edd1de110bd1c51272453a87b152ae8cb7781408eca4f2750dfddc362e13567c17f5b2216f36695b3c6e02e927084230dad434a6539184fb865c74b4eff7cb1729d4aeb74c2069a6d3cc0063704e86b99b3cf81f8e943e92aadc868bcc3e244d3b17ac557c7b6f5853410f90fb3374d7a5c6837659d380328d3330df92b35350c571f7c5abdd352a237e5c00df4d73c49e154bd2b247712352dd2ed210b0f5529aabaf174ec52cf7493fe99f6035aae69221a62c3655c39920e2c0fab05ea33d572d0defd9c78da5bc094f6b059a24eb9f583513be9ad5a9abe14aee307bd6840fe73fdd628483cd3eeabf65c4cdafd0dd37f6dea8cb283e537749ff6a56b7d088120fad6ae6f9d932d942db0aac288cce1fb8e5220a99b93954a24d821f5be3807489bb568d57dbe976e2927af6b8f3b6282b210c1ae8f3d3c44710d9498fbd25867850b9cadd19cdb620f0655e12723ec65f110f023c160f51ac6b85e6ba86e2f74427c128c71540ca5926ae1472de092dd022fd6a003dc53f3ce4b58132812c24e94e9a5b18cd212d45aceb8b5b659a594994090e957a0696334bf959a274bf6a5829df3eac3a7972f18f8f3a07053d18b52f6251b9a954937b5022fb5daac6da178cdeafbec1dde857d90d6d5a56d69eb3a872caa257d7c1f6f6422dc8d6f861e2409f03480e279fcb844b05744ed4b8839e31b2095dfcec38a7702c55321b6f894ca24a5428203b90511b50bbff0164fe1e96f649731c77adbc4e8845eec57f29d3945982251eb1388bac2161eb64a25b28a72c17da7fc6ee55383134f0a27e6a2b52517c48c2a53b95655c78de06d530b03d6bd542d80d52a39b68cfab11f65a2361da0bf089975ad7d1829c186b4a0179a4dfdcb7a0acb691cd978650c29247f975632a15059de668c80f4d84e99e2ef74ae5d75d2fa9f50ce294d8b278446012828a87fac986d6751088b6de837ed6c8e0a5198ebd3f844d4f5d81ff7261c19407496b19ca2d4af9b1006a4ec9882477803df696986733be8e9ebb4cb661fabc1bc44290a7126b476758e280952160c6e6ff076dc1c15f8de9bdf5c096fb9b9dd1a260b5867e41906a810dbbd4dea1fb41ccd442be79e37c41f2ef2d8928c3dba89ea095be7361c0fa4496cd5ebd47e206efe5b7e1f9a0434ae2b23d212bdfcc8dcc452e508867c68147df50aab90a5bfd0fd310b01cd0543b89d5aeef2323155be62b3c14c80443a1b26141a78397bc72bc6d4f3204211c3e4fe853e9005d802aaa8dee7c636baaeb258d2b3719d84f1c2ab57a9a4fc75ac8fb983ea3bd00732cf0a76a207b80940d16297227b00e88aa27d726aa328451035dd82c4a5750e29fb56bd17bf87d835eecd26289cfbdc47f8843abc274d409ed6ca6905ce8f1baba8546eecdebe7cee4546c9fcf50037d741e83d8ad18799242089d3e30277de34b27df296fcbdd88e1e74b7fd2e94d8ec2cdde4a9107e0386818e17b886af55f3a9bc61fe46ada7c3451c5c1e128f969d979419144afb6a049426046a984c51666061c0f4807b78f7f136567b1503f80805f867dd2ebf89b62d6d957b9ae84cce71f7030df73d4103e8dac4b7e18cc967587be17c81833a18132d7c62d016990043fb5d424e4bd88b8bb5b2268a19b61587666bf90f82f2641c6effdd236b1871ce406e14c822315e9747cb20951f7ef62375fd6058bfd93332b015f09db054cb28b7862836e77d4c62740836c6dd86a246a7b42f1fdb9fa128998c0ab789a84c95269f85bd21c793f9df75f3ae132b6ac029a2944ffd891babc7776a97a1298c595b129795c3f5d4a22dff177b0067346d48aedf8edbd39eb505921d3a43b6f18149305ab0fc7b2a488c7acd0bc38c5a5b6aa5a92b25de691d50be5508add0109437b4c480adcfa97bc4b817790f6dedff426613ccd96449e1b0745bb2a3b925e68d285c7b86fad84137e697653b5af95126c5f804311f842dbee29288c476e99a9eb686fda58b7793f1e73503285c4e8fabdb89a69bb7dc8a044dc4a97b99bc1d78c62662fe8dd09e79145e2faaf653ae430d276a6a73e101c05d0eedffdaa9cceca6f52ef2e4bd1ea31371aa702aae3f15921f976ebceae5827360ae6a97f80ee8593107576b0499a177cce888f09427baf2e040d3668deb9d14eb884a83c1c44f95a7cd19204b2aa9999181198f637f89b0458ce8771fe7b0b766ca6f9ace69c9e7205ab5eda6bb7ca70797e374e8b7104067032b2fb6960682a6e7483d53300b921735b94d141c040d0eafb5819631bee9bb39d46d5c4a03c977c1b03124e9bf452c9389661ef380a43f801a421bb78d5c9743be251f5348a0fbd5ab30eda29550f22ea091065b47c8327d041823546487e298bdc5d37242f7a38bcc02542b50c9cabfdba0e0b51ecd3065113e16dfecb007998a1edecb85b607936261a9dab23a0a4fa607d48738b413215f2949f843ba3d0f36a6b40d062d273c4a1be7c02629be1b103bab8bb92c1579fddda20ad491bf1bb163072419f9ce530d893bb7b736adef94b4b8ad2fdd89f5eb08b83356ac84f1be4b4d8f1f31446932e4cf8c2defaa2265f7d082b070605c81a78c1015c1662bbfbcdb74c3e924dbc5bf0ce4cca1f2f233818ed32db523cb3b897a44e95d8199c2b9373bc331a9c0b70312c77e453550895314eac26d64435420eef5f006a1dcc85d6ef3194d43e28d0a66b1ed87def1a5c3a19834891926424342596f7de45f15d1c5ef01c738af1837efb23f13d25cc0695cb9394bc5d8becd6f03aa766875a973f59f154d29ad57e5033fac7b931eaa2bc760fcc26a6d76a102fa481789321d44a2d9a90c81e985f3599edd321d404a4ea07c832b06901e8b087f68da48d1eef61c2c1e3b1b53e67e01990b1d52af024426af4f4896d7385a251a46dfbca9533589c0e31a4b4cd56c18fb9b3db6da9bfac26e89b8b19ece660afe96564f4fa20b7f269539ace5b1da1f8526a6fe57dd75e673ecb2e17b582f48e34dc3cee392f8ed784d95db85831961b025ddeb790f6e218dd6d38c6843f5b00348553fd45fe4f9fb4cb724ca9e0a09a9744119d53f3fe5373880cfa4bc97fee7e6d986a2052e1e90de34626bd129424bca6b1d03d25c66375bac90380b1e13f438c4e141a6f853305c89133b1edd8af485d82b440ab9040492823fcfbc6090ec88e51e0f49eb802cc72d1fb5b057ffb8bb1e4ee6b53c15e85d37b47a2315ef9f80366c2e80bc9fb33e256c93fd822a67874e554f5c630e6b65447ca45389d38f17064ae31fa3ab2af0aff762a2d9d18ed93ff001c78209940e522f45a7546080d496f6d8f4164b38c4b12fa245db7c9fa0f449ed9a0c7369ae92f271a50d4f16d631616498fe3617777aff15ed1468681e83f92cc3fc54192187d0abc664412a9030a013ee22630f668ef9d6a3de95b8a08d7bd1bd988058b77963626b8cfcce859396b10bd00ea28d49518208c009fd041ba3c851e23bdbfa3819a9fd4edef212bc136f27b4f988382effd22a382d77a06d0cf7f38c88dc426166e5c888b12ddade3772c965003f493ee8588042e49d8ef54dfc8c1a270474ba17f4ef26b48f886233e367cc60d828a16267f805f0fe77e7fb450c489b4139d845b772a1e7c9650ed99270ed0fc607c00b96c9ae3610fba1680c6713994753851ca48f350a01f4846d16bcd3075c7967826e60fffb58931db308b7adb4e12ee598c5fb5cb36d06572d7d74992846556c418549e9c6a342a8e98e71199fa71bc954b99b9e999ee5b89fe50d8ee3f3b21d70811058e9bfc093fcecce7715768c1b4ee953031915dd68ee244026ad12a040b2fd3cbea3242591d2445fac3e0f7e40852ea1f5bb16bd19f0c5da759938c175ca311e8c2d3969cc5137093fa7d8bd23dccb182095eaa74ae34b3bc75a441da637428f1921b8d16b6e6260f73637cdb4f25f5243c49b539e886348fb3d5b457cc40a509cea3061c387d42c93a0b6d0378d1a5ff103a8ab50acd331063bf2d5fecc770cd03cf4d052df77728e27f7d39d43924c4b61c3234754adb204257c39226e4c56928dbf1145d63d17b1da1f8ef76b8d22cea63a18df254e641d2c5803a70df56b9cd774b3c8c9377b12b15e22c24b3c72710804cb12b9b7848dd97d02e403d58cbc1bc8f96116d4093a4b11e50c0283f743233bb9eb64a6b5cd34b91322403728dea733d5a7a727615f638b0bffe24fe4077ae7e7b581293fd97600420d52e406e5ad144cc825ce720c5b0a056a20056857df27a9cf05177156294ed9d6db6bf96f6975b85aefb58b781b0b78956abdf60ce923974f26c3f4ad592f67dfae7af6741b8e16a278f14cffdd8caf6f5bd7dcbaee29a195afd8b5901037686c1f4ba96331b8abef7b669bf6c90e4334995aee9899a50ca76ffcbec67bd89d424c31ce4f9367b0d7fd56151cc0fdb38434998814b3ed4638f077208b07b9956440727b536bac3bf382ed61126ec1eaf336895c9dbcea8589ce98dbce112514be5648fb207b675c62691a0273b6dab32e17ba8925efb81b7eda046c6dbe468a04669939deaefc8499c754bbf5ac403b62776e3732bdb066ffdd5631ba3d7f44da3eab1e846748f24f9d3019f2f19928ee9e771cc8e372c75d53c0fd91fe8b2651b3e74e555c6917727a34de643f3c03a010738fc920c27b74c57dab39ff9d29c303c95bbef74109d7a3dd727b7b4f53236896a64ac1f31aedb9f382bee86937bca63824eccc2eacf423c6e5dcadd556e19de9f2e7118295d2075b47b8f5fc37319e7aac529b7211d2be12a5009dd0567811f5c0ba6b85c5a6244e175f8551955d38470c9a6087b361ce83029edcef7dc7e8efb62ee13a5dd8f894b2086f31ac5810764b9630927511b3f447ff30bdc98dc019bc1f46de335f8f090280199ec844f453fa615b0aab1068dd77f4f5291e54e84bac43c474089fd66e08b4295fd7910c9dc9e3dcc0cf9cde2e4b0e30cdddaf8c78240421474a1293e149ffd16e35ef53d715bd698adcb4adef202cb1124e4ea1e59dcb6e61d943cf8f427c874382a5b195624ca573ad0ec043d594bc3ad15cd50cdba8189e0aff0d5cb238228e196d5bcb7fea76e16490bb683eabf8e916395c02a530c645c5a7362acad0d738fa62cffabb497f2b406d6e166f0979c830928f1f93e079b193c471624dc54265dcff3d44074bf06a116129f79164c4fdce1a86043ac2da355d27233f7a6640c4cd8118906aaf7851986496fb090c1f5bed68633b679ed168faf9048a9a52fd382a6e6cca7086ab407e831a6ca591b1fd5d8f9a0097f3d58e9fb1b4d4417753bb93b8b9286e64c0ae203b564fd4e9e5e1a33be88bc8cdb83f6d56059f306781c1d0901a68c1d7119d2fd2287e96e74b7776f680bf30616c0ba1676d7755086b9efb89519f7ef604cb54a5e667a58fe5e5f4f45f8931688c5478a8093ff798c2547c83af8fdc9e1ffe2f5eff8ab7e2dae155bc1cbce6f3a0ab4fb0efd099546d32e42feda3d4fadb172741d3c1a1983888226cda9e382c987525db68d0b4f5df9f23c5d92524ea91b623d9cbf97a9741eae58f30226b076d7ea3266e466dcc15201246e7bc43ae0454b239f98494235c92790fa17e2b76e079ee484278d9c1fcb497705ebdfd69c5d0e3252c49e9ad1eaa59e366ab552f9d5b6cefd7cdf635ff4f8b99f136b02d892969a81a79feb156f0a26c6f36398019caf644b0fa84955d3a87b559c29bcdcc73540626fca05af04872d755a83b67adffd93e4cfd2a93f3ec486bf0cfd7965765f445f00759cc741d14a23068ab6ac7c246c5bbe8a0575d61df8756c6bfc785d1b806b31c01f25c176516218d086d2f2227f6aad74d6f79820fbea0e766aa471a45533a7d1bb0f8ba5dbc668703304202e944955a25fa583d89ac528c65e7f32232be0308b26316bd2b0604e87221c01edeba8a5394d8274352376d704df80ef562acb54253e9066bdf590c90528d9fb4d20c744dfd901c7824c37219228fa98818f53de711f0963439aac1c6f2cf3e882078527928b3c027b025cce4ceb3027175af09b2ca5645f603ee211dfd822a160ccccdddbba5cf82c51824228a8a45ee24f37f19dff8518c3b0f0a7cbfd3825580dbbd80daa4bbdf8e03d41eebbdd69afbd571ceeeff48d379ade5a5f62752352d7da0f8a7d37330fdd5ccdbe09cad81e0866f8ca8639445c3c588e6442a47c2326179351265c0cec014bc7c8d505b44ba3bef6ec1c1886c81a143ba208ab2219158a13c5647284895128520d9efdeaea8941e143de7de763c70da7ed4dd3a8384dbeea3d31a8c8227c2ca86c0c72ce883b5fe3ddbdd9667f7659f6e2de3b1150cc35e955a72e001d0b546b9a3b8ac05d2739e5515e0c13ce5f66d7a414a26d68f74b179dfcab2366ff933234f82438759a9d7332b60f93f20dded9731e19f250a5ba32c9af3ea4399d6a757804153e3270b4f2796992877e2abb559e5f732a8f5ebfa61b9c749ab5d5a991c9bb5dad8657c6baadac5b76b6725ac998f4a38ef704d5663bc543ec681d7ef08de960461b6b4a5997e34077ded41a8e2cc6e6a54d57d550dc4510399c1f595994e16ac58b22490f1c2e3fae9fe9f4cb61672865b3941c5da0350e13264892a4fe0ba135b789d62ad8907160f75635de0d2c89fa4194a3874c31ec0e2a524890a1b472370aa1c6851e711d3d4439cd0bf10d9a886aac3cfc3e84fbd9b67959e3f2649ee3cee0fcc8be7469ac41428f14a44e23271e4bc23ae78bf792d15027290bbf38fb7cdfbfe052420a6a6f8136ea81f173a08d0901f1d2cfbb1d8c6db575d132c2c6c553add13ce291a66092b1630a75dbd0ba84b9c79b061984d725e3f4038efed6ade51b892d66f421e8ef7217000feeaa98f9caae137ad6492e665c22647d0f97b45a489723cf7ddc18d03323a12b27cad04bec6bf90c691a16d1d734cf216b5b5b2294d8f50ec38eee583528ab6403304fffa43e24d0d1dd9130d4a5963b28cbbcd9bafe7a1a890a48afe54803295d99074388acb52515f175dfa96d275e69fe90d325b197f0bf2a7d0ca48f3127e2adb9ffb2402db85f667ce16c314418bb26684a99076cf359ab2107e3bd6fa963ab3a2b997fc7fa238d40d66e50d5981af91c37a53492cd32361704a4b49312dfbd6671609022b015f87717ec37fc96061122f44250f3a00f95f8b1db0dab06b07da46a49d12c40b21cdf935a6a738d23c94978bbca71be5d998bfcc5f5b266a620d0214ee1d0d5a914f645b608c2a49696aca6403d594134631bb5e2c9423c01f261bc33418750c70b18bfafea00995667dde90e1fcbc2f1fae15aa96e3df4300d4b4ca751d542ccfe7f021659e98c73ecbbe5380f84c9478c31c2e984570ed54ab885f86d51ba398db45c22ee6a8a5ec0cbbbe8e6a7176503ab585c46405ae3a1803aad960014fdcdb51b3fa0e43881d4dc4772ce03946bba569c51574776ceebfbd00498492f7df15006c07631db1a864837ed56d3be0907dab87b9cf29e9141c7c6d134743d7e53268b6220862242c51038611162c2b11f061fa16b1ec38a48b4c9dc5609f4b24ca3b8626d5fffb5cbbb8b4bb9ac65b5bd34614aab6a4c9939de75398b69c88fd19e0ad306eb4e709591adfa0fd095467229d7074e245bba9b288ddc55d46f6dd87a1cdbac8c55af33f9e8d551d0c908d7621dbe5266273d50a4ab0cfaa7aa3f0af2d2072b6a6b9f5b6f8c1dafbfaf50ae70395c76a9c0f72e4d8a5cd89caef890bb22422bd2997d8eb805557c0956b99abcf7d540a98e468f6c8f83c59af334686c0bd1d4b61017a15305b7859890c44d016502880e316cb08a45f652941f00d770368cbc8b360f4c8fd449528a225e89d63e058bc44b8b0fbaf85d8bd5f21f314ae806dad1d60ed70526be2e3f8b0b9d60abb648262eae0277807b7a487628870f4212430c32f80eaf398d09fc25c11815f56b7c26de8e3c5eff7546536cf09a6e5e77406d2922903230718396ea02d4cca4a67084889bc1260258ae3ef705db099d2de03a5f455b4fbcd1a95531c413247f8bc4b667baaf175bb7603b3f0799062cfd51bc285c050376213a739435c98f11c9d87077942568e0fbcac0c3e398c093fa9061aa94a470f4a8440cb981785b62a7bc1e1be2011798875b8d644b45bf68a6d7c63aa17fb34a63283d094c2729dd81ce8b905359190401edcadb00946836ed59d687a3a220cba3c9baac3ef6cddfdd7e2a1cf12e0ff58f7da8c96e903e7e2c79770aa2ee181493672e1c8aa44c34aa3a904b75c27155ab6c3fdfd0057459f32d5670539c9d7d0a7131e49c5857c51d4f6f810f415bc750539dd1a9ffe34001513bda4c4a97f6a852f9b1a8d77f33957c218255610cf30a36116fac55cdd1604e80bee064317007a00052fffbed229c240bb7719c08d74f5c898dd475e85cbfdfb2b31ae5349a375bdae78901e4a112cbca3c3cf4c9d641430b021c8712fcea305bbf4446e21d37978237c854abb0320ff309223addf9275ce43dfdb46d723b9526405ecb0669afb85904aa31a41924d9b0392573129275bc0780496361daa2204452ee324a4c2ef28d4b6e6e3ae9f369cd803a6d78593c1f14a5aa565c0b79fa911d34133e797d9f110e4b2109a50fef3aa063fc73b3f7679e71e3567da7623c8a6a440e881347c54e8ad159d648a9d5ed5959bed7746f95280bc60cde1635a92e76aa4d825b08beac9dc62656ee734a53ab7b976c23149fb032b0ed77d501a28f7575735924e97baac3ac765169d82044b6e11d2c0e70a08d1b60a2e483439354b1b404df3fdac1ef1486299b52b877cc4efc441095eec05db837d0a16ed75181b5829605f07b73a62ae4c1e99bd858fb24def05575ff13ca7fd150e9fa4f4a449c8be60e6d40b5869e7f8b9555aac6cfa0d51760a0792f85c18481f9b7c8cee3a0a24f906dfa0652b594f25668e64c11e47129b4b69c4f018cc75dc3faa606f5a4f3531bd29bd31d4a518a8197565e7a327ea654a54fb4da887048cdb9cbc4d4bcdcb2261e61b9d03de2b36ef9beacade59bb0190d4ee1d62f643a9275de81825efae977e6dbfa2682f752f86f519c359a0216dcebad2f357f78ae8e90dbee23f9dde934399f39e2e01926ec7ae6fd6506aecd780679975bece50b38d9e2741f86ebc6e4de86f74cf42f6664346e0c3ffe2a4ce6282fe51e604205ae247567eda0746b2e81b299aaa20eb46eb4f9dcf02a0e32090877f6fccda435d3cc245f69ac11b0e1212228ed177f4ba3569f7c0afab6cf26bd4bd9f188e8bc3380bc2e29c9086c0c3f9d075262f2be1a2ae98acc81c22b750ef1a079110b81753ce20055886e658c86efee958c96ec7e715f08e58ae8521f740715275a0db6ea0458b9500a095f3425eaba5b8cbca22797fb6729917b7ff24a4ca20a10d90ebee56f7738f830cf0b31d1a53d9e05ded224bff3bbfd51efe6d35c5e106f20dd6732abadfa1fa4752f9575b4ecafec5131e17ef5fc8ca4928579d4133f5b387c63d499a4d90d2763e8bc66b92db96f7a77afef3a7a0fb0f51b979e67107677385120d3038a30fb31e95cf9b4490c5475b233dbf20f35b0c50984a48f76a2147f4c93c8ff67b2da25f813a369b715d4eaf26e5ffdeaed948389f81cdcc9ad864d27e48bcc5e096ee97ad9908067baed6d64e8fdd5abd4d41544a3db76ee05508333fd1299e82cd66a68dd95fc26e2996ee4f74231f63a0abeb2334e58186ffbc3a8649bf8cbba3e0da2ed2814412453e242e64b15571c9e53b9d52d5085eb2e67ff64e35029e7500abc2bf0999dfd7eb253d3ae005177e1751417772d7eae7c01e48aec8d84321e396681c0ebbea1e21df340a9501adbdbce8fe1610812239466bbc44e42ddf841621b96b79236a69286bc8b4a1dc98a7c054b7943245f368c93e54dd7819b74ccfcdf579b45093cf66573f9c9fd9a12b64d6d03e36bcd3bdd35bf0d4c7cb8873150dbaab3e5a0142c8b893c137411f013fd1160c74b20e6974af352c5779ef98bb088f19094d2609295adc74b9a396545dc3b031329238d469a2e3cf3ab9d3002fff281af872797f75663f4020b89d142c96b24970ee7d7653e672e2636767bd461b0d2b75d90fffc413114041204c8ae58781b31462d6ed158ee3a3f018ad658b9e84c232c982229b93807b4d18d79b73a104b5ff6d4ccb45cf9c9ddca60e8669e61f914bda6a93c2564279a486a05c90dc8fa0b593224b1161e4a99f8310a4ab25dcce307216880cf18d17e41d80f12109f9eee007956f8c42d626d78ba6ea86c225efa28caf6cf0e8282b5dcf94e4bba3926b45ef8b555d9491e966069e17b2ceb7a9ee291c0c9c378f3d86c1ba2412321dd99e3051883cc028ba834f5f242dee6412d589c46d27496b6565335112b05ca89c8959b75e33b46249f61836bdd6ecdb4c095f64753296865eca2d13f4c68a179e2ab288254f41e5504ee65a72c4a19f2bea94127686ad61d10f8fa5eed98d6ad14d21b3b9cb760fe33b5a844fd8edb6675fca48e40bfe60956e7ae1b003520a43512023d29f7182d033d9665e6f1981f8527e1a27a1a6619ff175cf68255a1c45f12ba4dee61b1095b2ef22f0fd049c758e9d4bbcef4d5118e34a360fcbd5a3233aa201390c6586db63e6dfa6f90ecdf6e8043f4f501edee78ec1605d6f783d28b3eab3aa3e7ba8c664aae941bf9a5e965b1adc78b546d510efc63e2b74530fd73a68526df141bceb6a403dadba981c51566889a6951fb9e4aae8b996714d8a67c5e5166ff44701aa3ad87ff324dc69fc080611d455ccfed137d6d455108f20b17d5e93f93f083eb59725d880332f1d310d8539d3e92558d2fb126afbe0e9c7c298cf789561f08481ec3e3945e118283cac8fe1fd11051cbedb19fc893d1003d4bab4fdec0d81300142808665dd2ac26286ab9b0db5332621d25ffe73d3911127cc2595c494cd5cf9ef51be518ea47dad5983f42b7ed5822cba8740e5a52784de15086b22b8be3784a9e44f96a6fbd0974454f564ce7e4ae4588cac8ba5d58bf0587613d0f829ad4a4f0fb960a72fdf4d29a1d1a47e7af890cc41fd3bbf30a6f24d618d3c7f66fe15d25f84941cc45d8eeed83547b106ed8e848522e8f2e1e087c2fe0a1fb7db5fa1666231b7549ae6aab6572184fa4e9fa5875f9f7b2d9b9f3585438798946ead9dee16c77b2517fa7df09a9e2a0fccdf992e8a128014add3d198469edfc809a5a3c93ec440438db5467c65c4ae269868eba0ddd72d9a51dae216dd3359956f014d9e8425b9e3aa4cbe4ee83f50e735ce6466f6c6c6ea289d09ad3d44fae9df6ecdebbb3b41ef28343af3d01380554731f7395a8e2c49501c4f5d0b66f176a964ee4fd184d56abcb3ca30c247f08e6282e7a689db69932b3ccc5c932de19c666aa3673b7ac1d96a42287d9ee7feccba631b406e65a39580944a5bee7f9a1836ff7a639ffb0148fa270f1b560e955271e0a039138d40fad62875f6626cd3396e3ef669faa6238609af6c63564c587cc148b1e13bf0ffc8e1f0a31937fc134c3d87f6e971ab13a5eabdf8acacbb50ebfc193a5820f339fb552179d6aea978ea3688714418f0268c1e5131da9205b0c55fe2499f7cf05b522e036830f625b2133262a0044a8abf51e36c31ed003af7413fe9a84d73fef9914c72613e844442a7ebb5844580aaa3e93bed892387975fd02654634604784e9ee009bbf2638cdf9fca28c1fe35bf1a624c4cbb882d7ecc66f39c1b98272839d4b38dddb335350559c1b6d7a177c3d8b4ce5fe356361ae90cdcbec04f8478481ab2783172db4ad07f907273c1c6d92a047eeb88832ad401ea270c58cecdd89e56e9077db162fb83890eea61e7887a5efc03b1a928da05f04d181f4849da632af488af3f643db79fc85e529097b391bce4c5a65a08ed30cab81819d3ade557110df471c1a883fe0e2a07ec9e2f3cf551e4890d4dc979da90816e5839085c49083c1bc30d2266e6ffdf331961e0edeaf328d68986b1ee389a66dcf4868a06cb178d29ef7ea3f1840b37544900f07f1c2797f0fb39cc597e4b39647b07ce58fbc79a462c45d7d34d9dbd28012022903f1704d7947cc603760fd24c8c23f984c90c729c7a0b35d173c62329113728633949621097f6ee16bb1ca14fc0769d55f897782b05bde8761ecb34fce6d9c23e4d587cea3cce36ac156095a812d5a8d7eaa3de80a41abd77df9009b52659a25c16ea054b3330549950c31224dee21b341ac371837853fa45d5e544433e03a3f3ec5fe49977c909def6ecc4b0d71eba31b979fed5ccea8b9f17c73fe3f97c90487e90528323ddb058ef3450cb82f4c44774cdd29f0f0e66331e560cb016a7254bd2f99fa668d1c00ceedb1fc10d692d32a96f6190be0cf5ac9e99d7f91b212571f584d9e00e6085df95983de521743a1c589fdebe2a6e2ad21fdcfaf727c445dfb660c7597057dd2affcdaf190c5948ce6426add6a2af13138aeb02615ee16344d442e7a88aa4b7e55a48b38269ab1a3b4611f9d80348afcec8a39f0dc19233dac1f54e2710cda2749a8a0f45f46a56abbd919e24b9a26109fd02c49fcde7dc2c80add8bdd9c9b26579e771e34a62c5ef5482bf67f8b1732dd27f87b8ab4884f874d833c5c3c833a71313cb037b456bbd42f2f6e1a45693feeb45fbe3f2148b8d607793559d201ca4151a1c0352eb52d8f56fd4f114a4c07aa7ec66798148e97ac2c8882d4b5e2013e3f4facb4b910ac1443e06e63ec35f3f7c3b90dd0e9c6c1fa5d339dba497cec5eb6cebd1a8d4e62d14790961b11c12cffaabfd00bed312197c29356a8383c66b0d62a7a94b44ab33dbed04ab74bcd9c61748a95c7026f7332aa091c21f6244e890f4165f0ddec23512eefb505bdbbcdddd7fbfcb074ce4235eb87603d934edd59235eee0a7bffe91b5c7192469af009bdfdc841cff552e0cfcc02db771c0dcee6a2685f2271ef39a3e521e1e06cc6daf305b8424b0558794cf8a7c02e4f0bdca804bb7b82df5db5a00607c445e0d3bab0dda8e11b306db4a3ba0b3bf463bad29debedf24fc487363fad30b84e3b10aa834d2f8be431763447b8b6e8886daf3b1d3883ba76232806b72055f3d32c71396e63a384e036f883b9aa8c8538c513efe159f34b0d5ebdbc2ccbc6a192e7392ea95b4e38fe2434e932cfb099aa22d7f35f0bac8a0efd6bbd01df1494b80cf3be276c38a8017e05ed90604cc3081129e0eb718d87fef00c584bfdaf0e464c86501e64ce095454b67c6c9c8a8454cafe6aa5323b8397f0977a2558f3af9c13f583b74f76581781ee0aa9bb8b590d953023b9222b765cedd7dc8b30317d4cd8d9dcd0a31e5d15120efe098431d8871ce0cc49e2debf14e7468a480fcb7553654e49f6823d241dfe808520c67189afd497d093222a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
