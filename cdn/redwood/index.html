<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9e16666f162ae4d1443b96c08ea293e938bf74145af259ab3fae028800c7cdc9ae045389da2271091928c8c6069293d003d953bb4db2c5a49ce4ef7400b1f0b1553144cc6ac56e1a469c548c076dd0b0d65251e21ac8ca56421e53538a7909c7a48b2446907502b1cdebd438f5899dce7d8e4f8910833fbda30379ddffeed9a7e0b7d39965930b5bb08def06b8eedfa43c35bbdd7057ad7867af87d617070ccf8320c405234f2ec17b4c63f060136d392196e7df8ade7a860d6db4bf8c78695fb62f8607414089fe98f21e37bdff978bc04838d4806bac0921206fabc377d1b424c8bc7f773519ed517334f581d9fb81eb0282b493526dca553f6f3838fa99fd427f46c64842a4299977712a8dfa3d84a9b6af3288b32e22eb048d2e46d5f22962e58b2fba057fff26002b6e7101b17d23a8852dd5933f8aaabc75595b7598e6871958b4272afbcc9edd0ea9caeeb6cfa9af5a36596346ab35398d410d01c6cf422460fed3f89c1c130233d64a778c881a4105ed0809ce3fe0da6f05dbc4136acd8f1584475699c52bbda1699e185cfecc496c7246dd251ba40875871349947d1b38b5fe81121b7762af0de7af84895ed87bdcd248c2a3ad74705cb1697bf9ce85b6d44200d358f4ec5842e9defbfaf0d8a9699bac762c359703d5577fe5fe02548b1c585c6d9ac8b76ba527d7861daf8cac6d74524721f5acbaa3204c31075e17d2ed9a6906f2b43ab09ac3e47ca18458c3ae6a0e4fbb9c412424c8bd8d3f25de487f8537803220bbd86930e1bc9b1f3bd76e48a2396ccd4832b36d32a9ec6947f40a12d293b851040c7c02c0a9f15c33868951d20c068f66f2b642814bfcda78c1e831bd2bad8b45dfb62e2b1f2ec56568c3e342a3f15f7fa9ae3c44a32ce54e9e26b7532b7f9abe1ed6131457b71d2bb4f48eda2e09d4f6f94e2eab7cf22df183394729e2432b76760d8abd355762107c8daf0bf175d821e87693ccac8124366441f09833dd414af638a2e1d551f57874b34c5eda57aa814a7c2629bd38648bb31d7d951158c0e4bb02fca6a6d51e2134663439e402bbabed2d4e39162c986075921107f9695dbcb3c7a89b04bd499883265d7b414c45e33eecb54d0e24e9ec65c64652f613b9c5959d50ae0651e244f59d1529b10988c5edf732a747958c690d10301d98030678210258574356094d84be9b38004b523481b0ecc402e8182086b11cdde099bcba364200b37b6dcd9d7c26e79734a3a50b4c6c0f16d0d91296af66a4970e6be1dfd565e0582d461b8bde7056cf32fa749b0b6b2b16337e3feb2c48c196f7487162bc25b6d1e58570538517b919d3b1f5680bcb5b9661827dadee785dd5ad80d90a5b5f5bb72fab3e0822f7b499e1cb67c0252e807fc259fdfdd6b604079ff516faddc1be6c619b714b384386f5410a072d6516632688b3d08bec9c401ca312338745b49995bc92bf0952f1508d294c815ef9b5702620ab91d398e1d9d5177cf1915def600fc8f5c6761b6e81fdee033c476557dcc714ea1325fa7cac550b4b77c3f7e2d0bd0632c78bc216a84693451cd0fc4c853ef6350977211c095608f6a5d8a6e4243c32549982f1d9bf6fa3908399578d8c23e5fa1f97420bc5f09136f325b0fec6cb961b5275fb18d274927e46c3d8fbcba4c934fe5925fd9bc876a0096b0a3861dd668c7ce77ebc1dccbad502c864c0968f6b96fbdbcb5dfd1b75b95f0d8339f68fe91df4a3637adcdd7e0417742a98aa6c8fda810b9568710e6bf0228ad9d53d9d745dc2c86b767967da3b44f0f339e0f12c365399b57568ac0ca1077c17628f93a0d4d6ffe85cfd30ca81d4977a29e3a9fcd6ad594a07542eb7bdfb627b62b25611b1c2b57b6b3a888a60ecb5e28e7d4f5e2fd2728b553098b1eb0cb65107df4e7b49e240782dbcc9ee95a2d7c8df74831c4526003ae83b4e7b43f631b1f471f512933d6dbf25292f0e0fb6cfde770fbce2145951830c899a2f2c48ef41cf16b5f1651d1934b581edc0c07d8bdc6f6d1fb26a8f7296c3b7889081ff867ed47de0ca72e3bd00d52c5dcb29b0ed9dba677a4ae79c86590cf1896266b47598db3dd119e328ade4b0774c166a7ecaea3a75cc8a49bd449bdf3fd885c73f6c92c9810239602f84ea4a30c3ddade6eec8eb7bfff675ac3cf9c985d9b59fb001fcc21d18f33966a6ea3fb2fe4e82d2d0ad3ed8b487fc9ad0bae2d4ed716468206cd8811a2df631e4466bbee7765672659e01b9b1906974d320c9e850f26dbc80dbd0afc3a0e165d5fda8d3a249c74b3dbe91f26e9577e59baf4e9f494ca3512972aeaaf444399df4e94fd70b4d13a469386e5f09fd58da0c646c9880825462880854d310ecb2f7ffd478cf2ce2e959d20cbe3b214bf2c4e959a95f890550520bce24f3f1f4257b2bac2a38180b1aa487f514c49f02bff799e684935e597783cf036b46699194e5d609b9b846d420ff268694f2951487afd2f82f865a52c919d5b979483afa6de798f5a6a0bb44a598c7f1beb58010afc8a0ae9d691395dadc7ae18f76a951797e7e97f0b360a868cb5764b4b0310254e0e6f1562e2d5ee253c6954eb9f704c8d89c865d6ca314150a53bf90e905c801e730ae9d0b7c17c61f25c5ed484e844b5513eba922a00d06289b58c1f704f72f67b828deb87ea497f5eb52e8ec39f2809a5c0879cf9cfa7445741536b8aff37ba45d6f63b3c874b8e240ee620357d7fe05ce721e36297882fbb73c2cb991b121276cad4793ca0288be961226cef4bbf122e47734c74e4a513232a1c0c4af53f33d167adc776710e73b6ed213fc6d1181d417f02020d10a4a6328092731ea51e92182be788eabb9d9beaad0c7ecb01e5fa66f91446d4e17e540d273e359639ed4560ea56f2aa78c702b6ece462dc61ca8059ce704c6332b4d03354bc9ed9e7c875563b4521970352b43b95b6f878bbefca453808efd5fd7af5bffb2812ae1217b0ab9cf56905b276798988b14e0a4837686033aaa3f3f2ec0e000d0c9c67f4301559df097f603d50289e263b3b0262bca633fd78774f134aa12fc3793b17d90a349d1da6e87ac2e2462ca70afdfb179227b2537586687f26e47675c68c7ef6c7ea47798082c9437fa3e1d8715c0357985c4f8161df155449c86eca05b931234115ab7036abea5df8dbce019df6ea7a47d63019be71be27c63d467bd1086d10106bab271ea6a1239198f4956361cdcd37d5ef23de66760b8910d805a1922978fb42990a472234e0c08d0f01d11e5908979fab0d4a3cd077edb15aa92d953a3b63038a1285d687cfbd05aedaaf4888a6f1b1bed212e335244bffd53e507c7683f0ec0489b2432b05e7d2c5a21150148eca1dd0dce46a2b731847223a0387e80b182aace7efba10d833db74361a02a18009ab91eff50b5e0bf44a0c39409c4a303211be0ddc0c2af072c2d0652da7bf810c7aab47814cdf1e27c60f2bded7bb82e64d47796205650319086dcd95f5c61e9a5ed9a2a41a3c4ab550c821738d398db500121b97ddd50edaa9e50eb2ba03badad496ae5e4657ed64816d3a8e57c417422f637ec94387bd3317bd83a8d13893def7463e7733efc8564e9f9db62059eebe12eadab2161830c2424488cc5646240ad3a4520c4cde0b1a1776e62212f9ebc1ce6f5231fb7f3adecbf1eabf94d1055d512959449a8049f571c2317747c3cf106fbe00526990097c6b240c94491eee3825f0989662a99f1786a9c83cb17d4e73418fc3f7e5824d522cf35c5c062f18d28a7e87980cb789ee86ccf46169f816962c076693a2b83e92304f2244f16effab806ec8d3adcefdedfc9d3f120b653268f56bf202d021ae6f59895f80e09b7de06857a3673df0112f16800cabc1e19e2fde07b93a808bc6390a977a2f0be5c974f7bca0d79d6d4d9e042c42983656fbc367ffd7ce2be20c6866e7d0ef6147419e98f69113ca5f3fbbbd6de11bfe529d8a3a776eaec8c5d27cce40114b6fa0dc4b5b4f2ae1be5f32a8aee065453a5e9b0c2017a4faf5d21df7a5bb13b11d5371eaa317f785dbe2f09bcee6c4cf2a8b790568bbf29f4eeee05a1bdef7f0a36603cd165e9f912f9453388ab6c080fc3499b5401c1584c292000c1f59f09227ef8104e5d610f2bde686e3186451acf7a44f792374de2d4ee47a03ce9b794349d055116c9240923ca4f5341c4753847ac0146b4d838cb11be8f66125f49d3ab06f9fe6dcae0d2d8712d15b1cb2218cafb02f83ac774f2174cec46cbf2de66936868c8cd57f929fc833f2786d67dd524a32c3bf24bad423779732ae298e4963ae87b324653689d32bf3906d97116d3d75349204db9ca41939a69740fe8293acc9e2af1d73e8629e545cb676f47e54bb22a478dc357dcdab22621e3028966b67cb3511e16f1debd9caf07d35ca842687bf9705ebac6f831850d96f6ed510b6a06f0d111593b3b0c1411b184df0076511e885db1f566e2b08a3fb373d4116d0d3322e34d7b97ed392eca663bad5a20f40be1eda3260b84839b0a272bdfffd03191f7c1deb907c5ed825972136b5b9b5f58c76c7c68d6dc5c1a0f264818ea082796d1fcf0d1762d2987761a35d6bf79f76daca74149ea61e44dc76a9f77f0c4e59c5db10718b2fa43e962e77eef15305490c1420389f7d83c7276658ea975627b8025c49a3fe0c35ee7af8f49bcfdd5e17b4c7325b63a0f13318de4a2fe856768f7df6cc24ebca7887c55958bb0f30ac0bd10a7c76a0454804b72f589c038dca0538b7dc409c4e2c9af891cec8d564dcf0008a9a2a04c984555ccefa41eb7e6d967fcbbe03f0043cd47d0a2c12276ab409589664a07c5cd02d004850248dcd7a64f5d8d01a2655f0214fd026f998010893ad865287de033c2408e0ca9a4b862cc0948cb8ed48ebcea3be0bac5046906912a9f4a9e601a304bc0d647c04618fae90a715d1c597df51bafbb2387fe94b583aaa3344f0896093dc6444cf4714986eff08c65534af7d9b2be6721a5b7b7fb30457bec2d2e91a2c7d6366630c5d03818920bfe18e6432228cb03b6e3dfa077e7397a012fd113f9cd896360480593b4f44ff381b801017e5fb37b3a89a24580bf31073e0202475cf234f916a26be6c0d1eb7f5f2351cba5872f25939f68d761c89af34adc0ed81d6fa7fe631b1a8e6182a2e14f1747a1da0574cc514bd2ea67ef2d1353fff8f469a157b25d8d7e37109d187a8d74bb2b489f7a562300147921a8ff84ba39db37dfdc3126ac0701926be39825dc48584e5ae395801e401da9dfd0ffd659223ca848420fbcb00d09d8f477c27e2578445aff2060a06a4bcbe13007e2096288a2dbf7a0c9544737296ebcaaa388e69e0c56713d308c40ec74255b0d1f68b972aef7f1db316bb73843eef033348bff7778b97686b177332e92d9acf629a853c0c9213718494a52507eda5382f53355a1c83e57ab98ae90af9aeca734651eb1568b2c0a4bc4f28dab0ad2ee91419c14b0557df2e186fd9101448aca28bb11a2d181277fb5911df4f275fbd92472d31402620c662e3dfb9f8f6fd1b720e6aeac3450d569cea1edc517e99bb7430f059c8cbbb69a64f07d955a47350f4e9ecc1982d064ee7eff4b7eeb77aaf8f73d26193bff40bc3aa796334c98c867d21b957c28e375172697e78fc7b68ab0f7b41815bc216f9286f31a2683ef019095695864e13491d41f348025d077c58e41219ae26bf1d5dfee66154675686fddddd3d9d4f35c97c4ba53bae79b69bc21ea1e9ff6e7725c5c951a2cf7470cb4e5383cad295cbc2c5452fa9b6388cae75db9beef7331b58ecc9a6353d0402d40724de56c33165a156307715b79f9744b8b549b635792610f7483a809ad0495c22541de9f69ef1f13fa3b69c0a52da2508de3e4b8c61e33c60894f817a5638a520a44c7ccbfafbfdc1554171f6cdb1f4361c49fa014b2e143203a8fb864a9856b3e4f9fcfa2fef49b4f0176eb55d79e128b3cf6d08fd9620c021be023d5547babd2a5c5e0917ca16a59b85269cc59f538485fcc2e3edfb9d80fe44cf4d42799db800b10334347dbb757a4c4061242c7bed3aa6f497a47d45140ebd46e98e651692246e6d5953c7c2681721e4929d23b5a34d6481cb1cb60d501eea86c31056379e0e9288db65fc36250a30dd0ff26e1e1137a7de5e06cf492f37f9d6caaec72bdd1222829b8d4da5de46ba9246a41d951b1cc5f7797cf5e4439e24e9e92c6ff4d8ec72bc73628632a4340ffb68a04eae0971d9a78af4ac617fdb0f9ddbd8c46de376f6e39c8ff3d505e1bfb2667a6ccdbffb6fdd943b45daca6ea38ac026c1c825382f44e95017322d609abcce3de00353edc629059f4918cb498a4fbc760f954d9b8375273cbdb3d25f0422e1a343e12ed3af89127aa3b366d1051ab92a688415fff8fad271bcea93f3d07402a87a7ebc4825a6e5e043c6bd533e0d11d751d314746d8918661f59b7054bdcf651faff9dd3481ce496261fdf2552a3e0ffaaf48911517306a7c11ccf1852ef53bf39928763e200c4ec14429f1b788fba186ecc3724976c455ec3780c2d6d08361ca8cea953dae3c2038dcbdd95cee5f332dfe8cd46fb932fa42eef2f33b5345b72c402cf1f98ee8e788efaf52846c4b0138337354b3c41d29f49a690cd1e74ceb665276d72919624c74c8f6b8d4224676dd18b3fd89a786d7c1809e957e924675e927f5b2603f2b9cbf89184e4c026e6aab20c9c5e4483b156a826b53c3378e53243236071e42a666ba51e6ff25b4d5580126a5bfe971103546e7c06af0230fcf70c57942c4725b32363256345f0dc44ab39e2c9899f9ad0ffecbf6f78d6035668dd8e27c39132c21b069764b6349e076fa887eae05eadd8471b23e050411544a7bb15e14ad79ac4c6fac186315a63f55599bbc8aa5d144cdf7e617705158abe55ce0e36c34441f162c354d76b495a460271c8ba0877dee843f9e1e860fabf1d28a07cd6c2a70a0695e2325be64d6b1c3af4235131ed54e1cc195c8ee203b4003bdb2ad9e3ef5f42b797b9c82971074330acceb2ef7570037fcd79513887484c59cb217d85845a425eb4bb961bd73b0a9b5fa177cff4b9fe2194d846c5b0c0dca0f88cfdb2ce5a8d75c13e569b4cfc2c8c3df9df18c7aad14f100bb00543303862eec72f3fc3ea97e265b1a943c69aae8691e80dec23cb8db7a86e9e08a3c19bc0cd9d5227c2d161bbe996f195faba431d4f317d15eab334588dcd36bf014f7a08f2afc335f965af97270dea59ce23de23ec7e2e6a9971331c1b153634539777f5ca9eda8d8728dba2ec3c8d9f1d9b863c2ffd9c8dbfc062132b098386d1c213b56c1413881efb60ddb15a4c33113f500098dba080ed154320470e50de8c6e7d1ec8fa2cb50c2c680024645eab175c4ed12af0526399c6b87849b4cc0cba6fbc2654b3b58ee473917441c016e8031610e58f18a5d98026844b18d0bc6a1791ca46059669d60afb7b08eb42bc4f2cfea5ac1e032ab2a33fa75de8b13e79e6a64c2364eb3480f9f0b708d46c2b26c4b5034566de91f4a1cbd1dcab3ec8c19255bfb33656cfddf86e674b5b31c85128956498fe7a9b9ab92b6865d5fc7ec7ab3fcef7df2c25cd6f2b4002d0ff67854767d8835790a8c94a134831e20e76c8ed4aa54bbe9e48baec6148857729a1574370fc8839080b1edd27959ead621754ce89a61b69b0b122ab07b8d38863f840d63c8ac1eb570efd561ef42ae34e71452002a990d784b4517a270c6849d0253f86fc38154658a849b81caf390612d18d0aabd1fe107cded7eeef20c37a9bc2b0e23df1869dc30e3000088e73df125cc14d810cb0b4edd1e2e048e2e4b374c41ee1d0974e69700c1691ff6184f5bba29e7b3cc5744aa913e1c3727048e714713a868c4c3ead5f279f33d6253a72d3b1aa80a7597c0ad096596d3e4e618ee6513c8763f1465719dcffb5afd47102e711713996bf18a6a9f018340ce175aa568adfc1455a9e97cffa133af59cacabd357f13e421f1fd6545d5b317d4c5612197f14b88e54d74f39e79bc580d93d1dbcd336c339a8d3e0ee8c4ce75f9deb88aefa1ce7f37e5e4e9db01d8af3a60d4b553441dc030b5d615ad79a92bcf35330bac2785b79f75c315049aa85aa86c0de59bdb4654922dee02646f63a682cba718a7d6b9265e135a53952c5a14b697fd08424488efb932a3cbd5865baeb389c58a27a93d0c7c1a40705cd74aa532fd7c0676b257acdc52539f09f4f78f35dc6e71758b9b18938baaca310df26a295f0101f9fe487e350514e178ecf00b95fa3bf3802a25d43b4de3c23913ea2a7e5ff91df2b99f27eff64b3be757fc4f2254b69782f1e262517649679858d6f804677fc4e809510471eae92a222d81d00d4d17871e6cb7edb6a01041f50fa9a2a2d58ff1e28a143c97adadd3b0c06c6c44e554598d121a6ac639a1a9420b7bc8bd05cb67f2342686c7a65d3bb77cba7a1cfae3b55e0a8aef7b6b545567522c6a3adab8b849f032064eb6cae7e13107000fb5f74b81a98c6a54ce3b3073c8767e3ca3adfa3d66117d1ae1d38768c07f6521721fb70983083e769eada5ce73787cfea53ec3e65db369901c2c66e8ff8647af60e30aa42f2fc1de0e8335ce42bf297d03803c06e5d55babca6184f75bd3b2950c3bbe0f2db202e66c0b652c41f29ce737ae233394c4fb20fe2af969682645c55829387d4b668d30ffccef907912873327fd9c5e4cadc01fc45ec3f89721f70cb1750d46b38dbac26d98b59dbfe11bfd4565d05bd27b685eda455fe37cca04ee2acdc9d7478aacd918de492aa7e6c8faca101f303741497bd1900b59bc9119a554790909792f45ab99df4ab8801905aa2e86ed2f094637514afc555ff16ec877683227c62cf4fd26536684c55a753acdc704c9c37dbe12811552a4253b11eb6736423e5b2f04b60cb333e9c5daba8710268339012613e65daf17634af1a0e255ce032e68d5f436f54c62bc89299beca806e46b421cda41cfef4314bf0bdaf718a51d239983b999f331a87529bc8893405570fc9fd10f6c54f9161cee9196fd102dd5254f77e2af40d050679301596af98672be670107257c7916a269f970101e630bdb1a8b6da8f169a50bc59b5694f314c4a66235f83eaedb0fd55c850e6729ea2a95b78154f3af5e2420f360020f9142b08f353170556e8a3c63f296f83e0509f5537abbfe17a6350e5250b904be15a95d5e51a409518255d020e795cf5efd10736cba61054d5670a4716358568470e8da315df45f7da2bdc55c2df8582601969e57960570a3085e42a95f62e9257a43a154e253b528ea1eb0e09674ec2d5c3bec73e1dde932eb49efaa088d396e6e048afe0584692ce494dd717f40aafd6b15f7af0ddbd829607c0f774e366449da3f422bbbcef815b4bc045bc7623801920c216f099ac33acd3bee69bd46886de8d73cc71fabae03e4f0c1ecec7afe00f4c4710536af85086919d8b027b896adbb8c1d5433d65d5e625b377dbb695f36287e18e21b85dd84a64d29468e3d8d36da6e40bd18df70c28697a68b1386c8c81d8f68f896eaf78696c4d74e4e1c760d747a6336ff1bd7756d6dfd8dbdd31f0933c6dbee4a6451b232c2c726c04bd8ccefef7be2b4af8da930442a6ea0dd330d19469a51e07894e455e597e68371c8fe71969c8347dbe408af77fe76e38d7ecee86a368c205fbbbb800fe386d510e1edd9783158263cd13b9e3e50b71a39110b4cc97a9895a67efe83054eff705a85a35a4eec2f0a36b61506ff7c3b05f8e5f4b198de2b96e00b64d540c34de6f5a5b469d2d1a380e2e857a1bbf1cba01d003f913b2b24ebe8503fddccc1753174905ec91e8a149b899b13cf656e1031930ea132998106cb3cc06d86982140b24142fc1d6284c825e11ffb4bcae3d266a67c2ae4bea0f83fa308da079df0dc6772f6ba951d5ce50bd3b57904e23679738a6b1c296cd99ae66b3e551b2faa617482a480f102af0fdcbef32876329122838baccb8caa4830a25ee97e5c70cdd9c4bf9d480491322240fe27487433a16fa17f46649661cde1e10126640a72bd5ea5ea29cdbc5fdf0baccb0c59e435757ca61992e42a982a17b4eecf4a79534b0d68eabdc5b8cc0de49830d03f0a17652288a10457867ff45cf853df6aa2c6e79786c6e481bca6ea56f9c7b817c17571560266ca5be1c94d99af695e33ba3189ffa3847719be8d56817eb575dd503fd503e8a97788e036b3f7e9af598b9f28cf5bca372e2b6cdaa7be3e9d97af8bc799cd501b908dab6a3f60471800932c058571a5dca16fa1802916c25177afbd95950594caf04606362ceacef22abc0774864ca924d0332078d9e99b9b42685393308c76593bd4757baceaf132c27a33d659b7c91b7b613225ffb6fd116b125cc4d186800c1924685a621a40f23ac5b19d6596e14c6458bc65c2e01f4c505b4383c799fb8b98e16e8d521218596df3f33b64956d89fb12c10d42c057a6afb4d7beb0c7307303bd45089d26826121e33f55c56f5a4ec74499b6b03cdf0680fb8b31697f50cf07076a6222c690330a3775797d85ec49c757cda4fc20b47a0cc0a8aa1bc707e1519d00fd6815db084cd3f669fd442b0b121eca05f38e006dfa47c8f4fca7fdde1f39299125bb9f807488ab09bc96d20b8f4ed781c1b420ecb790dc628737331554b3a690c053863d997396773840d6b21e21b514bdf9eb65508d5a4880489057d2b415d065bf8567d8981cc1d06a6dc0c41e831355aee9f2e40320b8e972177a426357f401a033ca2dcdd8374f051ca1ffc5960e606ba34757da1b94e556e58aae01cfd5e1910d2054d652254f57deb6707b3777b5331b3642f5cc914bf420e7401ccdcca89dc4827683f28e234266f38fba9fc89739dd2077231751ab835fc7b9151996ebdd54ffd50e80a427a30973857d2d0036b91239da7cedd8e3c4efa347024d7623e11628ac50c2ea819765548a8f9c1b1095980f80632474d8918590bef598acb892c6988b6d8ab7b28f28ce95bcc99897bbe7fc276d1b51ec5517f6ca021fce7ff8362e3a96c2d150ae5bc052a39ebe59d1a6bc85301b89c610082705d7ef7828eb38f2507c43fb66343acbd3df90174abe22aaf58c487a4d503661c7509d29e3ab9ff441fd016eff9962803c7c9ffe0d38f7276cc0fd80b98382bc2ff92b55dee23b42fe47eda2747047b357ba79520e34187fbfc0b4967b7bcc278e39d14f2b573a615f32f95beb33827ced3fe1d75e875f748ef2b0aad1cc64fd386150de67189a1483d821b5b6d2e3a00adff5adcebe3dcaffd03871fa163111740e8f208dc36c666c6cc4a72af36fa069ed6e06cf5bb6817d859fa3c5ee77c61d58ab5c6a3f8e155756bd7348f5e7d545ed529b81b835ebc6d844bc38e6ae237d97b2289e66dc8e1e2469dc2672ecf5446b2d908f77ec89cbf917070b0cd256a08ac76c26e971a8127d7920bc8fb47b0325f5cfde8cb89b06d70f023041d2ce04bb9d4e6158143c3e9442bc9b221d06e322e8de8715e1c5bc111793705cd701ae8e26bac075f5912f21ce203bdb38f9fd00147f1ec5592604366685f66a6e643f30157492cc02ecfd043a1d663f0280195ffd984a6aac54c80a695bcb925cc07008467c5c2932e58141a46353b3a7d3192528abd7ce577d5df6cb41a4fd45b263c129077056b88ec960f75180f9a8b85810d1ce1787ce6cffa4faf45deb709b90119ce00337f99dbdf5494edcda50e2c132a07c70a4423fb2d95588b9cbfb7d0bbe45de011cdd00ab6a702a152b41e966639daf7b2b352d41862a9c013e39271a0abcd98cff1b347b5fc3deaf5e173b59e4ea929fdabbad163c90390c6572bb04ef6428cbff8e9c48c487ebb2c9fa4ae75fbebbf96cb6edfd9893af5b1470407d6b27611f27683164aeb1b5d34a08aec384054c1447a78ba2f585f4e0a51a50ae05d9de2778d498ec7fb2872cfebde8597f44a7263511dc350918d06c49dfdc41746a182f901744ca7fe8f646b64b21396f52ff8337c84b234e678416f4e9b880ea3f9d59e91f22dfbdc4963752e1f962ac41e878e819c5c84c01c58833f61ba6e1918df7ec4c5743b0d012ff43bcd7f00876574d4f837ec0a171dfb74af0b2f867b2665c224aa7d43cefbc9fb03017eb42f48643f2472f9da24c78c750b8f153a010aaf24df7524d2641c8c793ee1ced0ec0cdd8f48caa0e52096e53f304fb56c5c7ccd04f9704c0ca28612686eee7a2d172b822983427e28284e176d13706442d023633a7daed08838a485caedf87dd7685b8926e81577219b1b1382c73c0b6eecc978fa252cbca6057651bb667ea98fcc723ab0df6f8bfcc4f3a155087fc0aa5b54441b9362851b4f2f308ce9d222fd932e107092c65e94a15e234a8e052b651218436a6885ac4f0802af85ae29fc4b0d8d5cf9a7ff74f2d76c9898aca55d51789d8e9cfba910b9e7751b8891b88fa77f6a7bf273b244e2f1acb26f2b8a674215c190f9b6e0809c1f10c0739b519d34294916d34f82b572e6ab80ce1bb4d3d9768d199b0eaa5573a42357a1ca5a4b418e4d7f3199dd7a00340d6315f927266fa711f4f20e25b147a2a6952456d33b753ad673b09ffd9f7a2cff4758524014972fefa51ff7821728ce4c3d9aee5fe7300cb37d77ee20636f2fcc4d65558597784b5b1b7dcffe9df1537f365d04fc96d59dd22e6f632b96a97694025518b64fcdda3ec57d4afb7c5fa3766f8eaaaf2ca92e2c6758740f7f169f6da1948e1457106715c8ce1ea519cc283dcb8c047a4c4b559302e644aea77d5efd6265fe542d63092a8bf5c9bdd5426bdfcb1014052eb703133a4b725262d9d0e1dbdf26f2de7b6627513e3e3d5a16f6992425846007f3a43feba33fbc482edd803718d2527d5c53447983dfa55dd9062bd5d766db1641cd4cde2f3b4368c35fe0ecba4570e59753b6e60f03ff3723d6b1764f9d9163e6c06f7f75af7f553865c2e973c729d080580bad5858c5182bc1909631972a2b1111cce9544ce214dc4ed10ae431d3bdba72da454c5978fb78acceb05079225635a06417dbaf8a46c3227df485cd12975f58d61757f28219f17eb3337be30b2ab3dc26a254af8432e988d8ca20fc2eb8566ceea32bd8c0163c89ef87da2daba616b9ddae56f095a37c85d14130e96594726c86fb7faa4cc003153c12d396718d44c1423a516a0a649892f2802aa1c653d9227cbea9b21626a23f76d0ee79fba9dbe1437345b3bed63e69daa73fb511e6d3642b0aa7e0becef36434ffbf2cb0bb495d93d290f4c36e806f7e80b6d2ff98e3e066b8934b0530748c0c92396e04a75fcd8782e2f624d79389d916b4a7191ca4d78b7ffdde94ae697e76f15d2cbb06c789c58a366307c94db6d65a775bea438510adc5d1b9e876d15120fe61c3c1ac1df8d30bda49f2b253fd91a65d85f3cf57052306b99eeef67f36385a39f73c146b3ae0c1b03c01d54bf8488549711d5e25318eae113f2eb485dfa8736c9bcd43853cddb6b753b3e967a0725de138fa55eb47373e9eb9898df86990e409445cd6f2e9104012d17957ba1ec5a79f9a08b4a06c47075788fefae97d4971edcd7f4bf12b5ee9e3fbab489d31d0cc09daab6bf2ca3a8c1f221a88cead833976a647212e260649b27f600a037ecd0e037f1187068ac91c065f1f1420d25605dc0cead173e1f6495d4ab99c26532abb3065716f0d9fe1e4afa856e6644f8cf0b2985dd21698ec38a14a80a3cb9b170f4a9c332f21deffaf6b1ad64619972a9cea9ce0e6cf6e8ea9ec57f8ea56412a56367411be956432d360e0962432a3b8ec63b6af46f1ab0f965075f9f35eb6432f7de06ae68a159248938402cf1c8c9c0642170a9c5085781629b70c7ac2ea17500fd96d740c8e3c988157783c097ad013d1d0c87e9b9e560b5457aed927997851b79fd4f55d7a86fc5980b202c12b2653e2947f80a31fc7b1df6562dec598f61bc5c2d4364e8b2972e8c0967b817deae24ad247aa7a3b0f3caa6b4a699e71df829b757d79437ecee4631e2a3d98faef9ed5d60c36a3ceb941f75a223dee722fdf5d3f57e728264a99ba8ee5f2b4c29cf7207b9912668c2576ba1266d905f503ed92c6172c989f3997fd292b4ab9f261a5c5a3452aaae27c95efb795e94ba4d83263db5f947e32dcf36d712cb8e7a9611d11b5fcc6278c7c07d6bd15b4455a02d38d2da8f23d48d0cfa157a88834e32ada1da30f4799f77ed858e705e75d24f72002a8877ab66b2f6721c13e81685e2a1a648659b4faeeb8deb0f3681cd59d985e2ad1fb0e05d20afb84896ac2cd88961f9a02beaf262f6e08892622de58491b7bc051a18a268965236657f43a87e5382cc042bf1fc897898b2c98ed626efd02243241e2fc2178ce89f9f45298800c2f912c4ba4d98243b42897ebfc58d3362b66498760aafd5e1e929c5d877419fe1bac37fe1c8b9346a4c158e55797350f0bf469f264d691c3b1c6dd6b3d0f0a64993ca53c3f98f24f2a262316b7045d1be83c2f29056d7f19609fb6eb2c3eb1974fb6657ca4b6b8a06a17937dad019f659b646cec7acb882dd2983fb2b1e4329ea15d0e27e852901a1d56c8cfbf2205ed5662c575957ac4ab01548614a5ecfb1a538e43caf8b2309d829c6a6066e59a55c929c5295c62c0ca202fd4b3da495d26a5f0747865f9214a0eccbe56e90041b14607fc2556585db7eecf5e36b2caf83fa142de2f7513b3fd7b7e3cd4e409724e6b8aed8608f3f00d5828421e69ccd6bf77817887a8bbed520d1346ccb792b17997eace2a9e00c40b0de72758db95b53169941585870e62696117d48e4d336aad34bdf84c80693031c5ba354702e0f485aad1a41716ce6ba572257d69ebcccd4f8762455930799e864f0b6272f1e64f9236934e2c6c47d7321436fd7578026a1d77dfb790129e3196ba2fd1b5f5790abdf13f6021d00e1eeeb1e26fa518d87b6d112e8d85ab9bf49dd078a6637c335a4a59a0a56c8183c8556fac8421ba525563f57e0299d262fbf0ca0c61f2cee86ed30686e3ab9d56d38c31761a8d75dc0b9cadb8b3ca68155f91908de4d41bf5a61c311c51b143dacec00fe418998573799c23b196b5ad931c30c0d5e1d2fd0b3818ec929a653d9edd6245d27d7ea63d9ded0bc8429dab56e9a426309a41695ba772424ba13ff786c845a72cfb1584ca01e0f83c3e519f695a53b5fae54834f74dbc46e0dda57ccfb52202eb74e2905b88f57d35ec2d0c02320cac1b9610390743cc689caef03d51649c188081a3d563f06ab2d5be29f8851c9a6b97761f40cd053114426c68ea4b5aa2e3ccef54266a349855422816ef3cd2c0df6fde793c5069bbfdf2769254327c0c3efd22e607ca0f3f1ebf7844f019c3a3ce3a8fe19fb72c41d4ebdc25a287fa6dfe3a3be6824689e3bcff5054b961bc87ee5c555b4862c12c04911f1a90fa496df7da301d70c1709cc89b753434bb2696d43c27c999a7af2fd422c8ee34adea42cc2730502a04dc7f038e012b97585f02f6bb9d6b8480be295956c0ead3b2f9a9488f95c87a8c01f55ab81d0dbcfffdef2831ec5da6b03827ad71f85f9442ddd16b5e59c01f83e1948a5b3db03cd625caad09b132fee67bc4fdc9466882cb7f4028dc740dd772bd144e5d3352a995ad5bc35c5148db0f3c24ac8b5a34a0442530d7c43198f80edc55d5ab33caa0105120463a104a960ff982c93582e3eecc004d52d4926d74b2066fd58d6ce2a8cefb58364679cabc3a8d4c4f7efd6a5f34d0986113978db49eeb4b7b80d4b371ff80df7996a4b223eece50f10dfcac45587aba7eb34738c07a82434426d8e2ace915fcdc61ce08ba0c0977170377c1c7f8b589227af5b74efacce593f548e954239d0f602fe47ebffc9de5297b338ec7f4096adb979114a0d2a18001776a8ce0de1a351b2647b5940a6fd2dd3dfedace7235ffe57f4853ca60888f0d23276a2e6de50d7715cc1b38fc35bff8ae7ddb0724f6396a6b471f7d70deaec375055739d38158d0f3378ea5c9c10cbda877873e0e0e6209547889fdeba8c122890ab1537b4106114843bee37502db0a6c32d2b0381e6ea2b8a7bcc0ffca2d6bb302d3d64ad8976ebb723e285a1a321d9a9d37cffe872f00cd1018b4b779dadcc405fec927f6eef36ddd3ae32642fcce5a10903b8b28957a5556add16c41f28ec623eefa0d7a3ab643bb149a45aed62f2fd9f97ed353f95b156d9422f46e701e3f9211d0c4a66a7eca94a2b0f5392affdd36c0f7ae68704d46b496c430c7959e6d8c67a424a0c3f88bf628f9c5088a8ec4e69c037f569068564a60f6d1568e40df2561f79013d414444c3c733d768374705a1253efe6d3e425e4c9004806d73044bea916b674e6e960d0d79b36197d2359351f153475d4f55edce63cf31fc13a89112ae72483bad8befde326c08c2dfea1528a43531f0eccaf4e42044f95d3598891f2d422c1c036914774975254f8c82f05b7c194908e527017799f94e3633950820c6079d7a7bdff7801f0cbc6c3913fbc6a6321eb3376b2dc669d637d1fbda775a0c388ed6eba1dfda61453e5543f7a5afc9720a78d5647e6bca41c60990cdd1a2c4a2a4cd481928a449182f0924cb3471a4169b8553b1c57d87cac21d4125d3e0f721762184b41878e952511fbb5166fac040bdf6a61c458c7ce1f54e5f13bfe880353a734421e6e3abe6508e402a45dfc3b518791cf130a67b00f24d26863d9f86d2246c82b47778e4946f14acb971583d13f74098aaa257c5e6437c03a3af2374911f404533c5cfc931d6cc43f62fcc26a97dc67da67c470c336aea18e508be96927ad98cf23fe86bb525628e31c671143022f46d8119808e2ca95f8f9e2a583469d5f321d1eef0908a6aedaaf5dc5370c27882a82285ec51e03a77947827e1d727e1c97779b8df015183c311a3f1c92d9514e5dd7b403c7a285b172419a48cf59ed428d0411b9862a2fc0063a4d1c0a2597fab5d143b94ec51698c59912454b02e32e317ec470d58ff3e4ffcd3e176b0886c85a9a740d417c3b1fb39599a0488835128e63eb790675d5e230264048531e21755420a58e96462a999e2285e1eb1d0df90f264115ce7c275c0bac3e592a4324c6f0633747734f41992d32806897fbb6dae082588430c9836d1a2f38f4fc4ea0650ea7be90471b1bdaf5d87a5158755874eba140170fc9fe38272e3757c51e27139250504759524ca0a27f4383351921f0c1b44e1e03a049781a791f7c2601db33fb43bd610c37fa0f8fecd4a5cedcfdadfeaeb030d8e2921e919fe35c39bca697638bbdc36dc9d19d672655a296249cf8acadefb76576ed3a96c2e72c2a49dd867351059b5171d1e421f7dd54c6da2f5367bd61f0ba77af881bcea978da0f495fe4969786796193601ff38f12479a311dd6bc1fb4ffc606ebf2e7d6aa25626afb11234021eb97026fef0c9271d7b532e86beacd74ef6fac67e7f8894f0c5d877ac2f0b4cb666cf757a898216cd887bc684258a382f67d1c3fb731c8934d3e81e7b76fcfa67b9750f940fb359e399d81f79f134f385844d9524b9cb9c900b607db7144f11679820737c80db3cd74e9f0b55d6c34b09ae1bbe8d6ec19d26b634958afc68b6cc5273d38f413b747f54f546c9267af64a93717d642bc37ad06292df08d11ff02a8dd9399381a4a8a50bc36cc826f7f1ff6731ec9b29bc0d90d0966dfff95a04b47be32929246a6ccd832daaecd9f1e517469437237bcf7e630fdcfa3c08ddb635d939021567094f73268e3cc5ac485fdd6dc2d9ab98a78e1a7911644f5aaa5021c3651030988bfd58022d63b885b48d4ef94fe8561ed149bec93ef59458eb94336593ed3ab07530a48491da956712a6db007f7bc0412ecd2ed9d7ae74d250ec6d9dfff8810276d36e4da4e4c31b89f14195e2b51c383025cbc448b9001d8575330743a859986c1397f12915ed9bb991de2584a4137d9bfc88b714527a303b8d6d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
