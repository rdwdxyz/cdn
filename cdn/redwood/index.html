<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39f6f23168db399f457331f18d2318c016a5200c3c382b19dad8601c143e356b81b5089f1683b0dbb9056027e06416a17c1a2a1fe1d50e26ddd9d330192f768cb647efc30390ed8eca1cbcc89069bb077d6c1918f00a7c8de4b878c77e9ef87e80ed6b5d47fb2eed35d2d2f95a2851f2e9ad8ef87eab96fffe09c09230ed74eae9534faff65d17ffe6a30dcbea81f54309459aa842f116e0a469c364abe30075a4884a191b6e0b3674c2378e44ecf210f2cff6be8a7e3e2b377286a36afc37eccc00e796e61922f1220c149adb51ef80bafe17196b7eea3ba21a6c32d8a54f6393cba067a76065bc129b464abf2a588c087bea42138fb411f015985122f708525af238c707907821d05425325eaab09ddfbeb2edab62d981f6f39c9e9c245d7ac2366863fe1ec7471e48828526c80ac7282e471a9d4dc76ac3000ccd1e204c8799559d6b0a32a5965710dcc4aad8086adb1a29149165ba146d885208b7f898b54cfaef50b6d91f2ed64e08795d84392b9788e6b1049cceae1e68b8d55a9a9f040d81dacafd67447559cf9900efceb403d987f8b65807eefa0fcd843f78a6b646a79ae43092a090b56e3405da60c2d4614f15a29d9cdd420a4063a1e8fdc9ab8cd994ce1d118b90d5ad33f27e3c19c40db1058f357258f83636a54cdfb8a41b8530786911d55ed3755dab1aed5efbdb2d6e7bb74db2fbc4d10202a758c1c817ca6ccdd7218ffcc694140914f7e4e61201940ced27ebe2574732de67599a43338cd32628418211557efa11b2173d613d36cbc51e0e35d745bf6f36d2c205361a8bdb824a8789c5cbdf44c0fce70b13b7aba7cbd09990483380f20ffaeb2caae1d7cbc61c5a1b1eaf49112d964d7f6194e927cce0f20f17dadd279963fa48b03059e881dac5b1e23ff02f7e47533a6f836398bb260f7d301bf2f9b98ce005ff6242dcab2e77a9e6f798dbae6354e9630ea5afbb3715657f662b8fb98d8912ca6ab0fdd1b7133a7cd821ee05d6fc76a734f5b6eb1597b902552277e968c53a25755a61a64ec4fa94da34e9ff6ffac527581842ae532eeefb6ca71d755c4a504f90530fb6b0f23392b01a79e3b0e2f795acfe71a1e60f2c72a29e20f7bda68c51693fe42ead235dc6e547d5da4a367372c35f42c917e0843e1bfec8095ce695912fed1458e5a8bc6e037829a8f5bde4bd9946fb4fdcf94777c29ed9a5e8afc9d332b35f851f9b30a9badf4e798fa5fb5304535fbf0ef88f24ec0b664b683ddd9d667d19d1d898c44369e551c6e3f9910eceee0fe5edf771c88afd28160abc187046dc56ad5c2e97d2698c142a828d4986ef464b6b6935a332a1e222678b306fdcfb5462749e60e3dee3794cdf38611a96a593525359cfe8425f217f94cf38491ba3b127be54e13bc50de822284b77627da49a9cbd8effd3d39c6988a0f772be1c1988553ce971300a65c30d68c244f817e06a0b5cd2c266f7e21cb877e77dc29ca12c42a783420e97e547d4b44be4c8bf4f7aa3f5e5369472da40127902680e7805e70aea1b4c76be76758aae094c664a948b07ac46b76f25daccb5f1a2af132c5393c85fc29bb417180f93294a47ee0d33188506d15d2012f7c9177407f476ce58037ce917ef09c344f9753a9e3acb01b914b26b071503ea19d6009dc31c1d2664785092ef609feecead3d4f9685215766325b69d25e5c293ab52c898337eb84f82085170d1bf3c27de1644916609ebc68b848a940bfa467e430ff0696147fcf7cdfa5d27b1450a325b75d066f998e97735ed99dca05a06d83c5baeadb315fbe5bd4639cef715ebdf278be39d39f156b4a1033bd73830866e9998727546d444eb7b2d5cc4b6db2d0eb7259a90742bd1df49cce354c1ebfb4b61914950fc3c1986bc112e3cc2f582e26de2ae58b982384335c5b0d3fe1347e7cfd5565432960c0d83091d00dca9cc6d5a9b074ff594784eca3f046b6ee412f3a0b22fcd241f4585b4cd7076066e687abd4ce233491e021f376ad2c065abe912010b600d04c165b961f82916db146b83bf09c5be55ad40667151be41cb21f0bb06babc8f86abf2fbfffdb5a38398edbb47e36d4f4901e9bdbeb0ba5ab732ab16b09cbc9ff4e479db31eeed992e69e86c24fc25d45d7efcf3b754a30b4c86fbd3704c7260efa68599a4c7d249800f186b71c3f0e95562512dfe0bc33e13d4167a29383694633d40b04001ea5fd9f1382ebffee92c9e2e67267cb854c643a1eea7151c4551f11d8ce576b4bc5dccdec51de354b5bdf103d7301312ee8e0392cb7f287a2524a5abe6917000585e350e531e99d8238628ee19a499c78d657e73288974e34b0c80b858a8111f1bb6f84bfd991f1bd19acb7875032e5e97485983b348a1cd888a82d2c6f8927d910788b38669298c6033ed045edf7abad541e89e4e8970cef26df6df993a7e6fe6f7c4532021b0ba2e3caa7a26394427afba8be5d9afd1db4f961de6f712ed9d8cdebb92911a1760f798e14e38d436839cc105b169edf6f126fe82286c6227e6bd0ba16f17d1a99cb1ed9c610424eadfc04b509b3030cd8062242988f1e6398e1ecb5a73bd010da8a58472a2feee0f50275f71560d2a1c6e4e6a65ddc61dbaee2f693437192591dba6ac76e7b288cc3fbc322584da78f689f176c40968c0eaee6baac66165de5d3569519ba1c4f66cc603afe35b5cf4aee570d50271c15d9365316f8337e7584e1cf171d7c6b7242544330c923eb465e9b9f1336be580e304880731515117fd0ccd4c68fc21b8b42620cca83a09d178bd2aa3129da77340127882447856632007aa8dd31bbc421a8fa9bb84a200fa24b54efd52aaff51e1fafc3933148b795f4fb60540c4e1e0fcd7b68f03ae4c09eabb3f7962c455591f906203d71f684149ca2f77ca5810d3cd1000d7d1ab26e89ff158d4fa8b201d884137f56236894c8ce3e4aa8cbe330fdc663ae62cfaa37542422b349811681029817576d19cf551539e806380dd16093b8a0ec283084a2d69663bfa2e460a6400c7b7a466c3438a2c5d635e9b357559bf8b2afbddb70b94bcbbed4bc5aaf10e7b6c2f02f207c5f220e7f879438261d088158087f96293bd23e174a3225495e56c32061d0e0bbc7b95ff6fb37935ac050882951a6db22a0e05981e206a456e11f1240831ccec386c11d5be66d0bcc35dcdd2eeeb7118dc1b240f9e425b50c6a89152663460529e81968dcf8fcc20f16c52c0e65054560761ac3e447e9e53c497f8b18a39a6715d0eeccd28697bd5d32a1c8d6f84b73cd0649befacd584f1eb413a4dcfd019f9301f187d7c4599615f02f40e9c3b30d7450a9408a882f7899f901eaa9345622d632724ed3e51d39596ed452a77c2aa0ea259d43de3c00e05741fbc24b99cd70d695299a242f5d104c051eb1d8d8e4fe2f5f234169c259b1658ba5940ff99e2409eecd68745a3c9b62cbf6432b16d2d37702eb87b2941f311f512164f782884b9f5571a086a3fb152cd0df9ba5777eac6010a510b456f3929c211bfc77598657390445917b285377d43fc716db6ec18a19f455a9e90a0acbf6f89bd1d5cfb2abb2967a4f696fff19b182b25b0efb0b3989511d6ac264e61d368cfd046ed72b8f0d1d79bf16e56055345f44bbcd6a103e38822d4590c3721446e9278eb11dfc7b0eeb4a143df694b58a8061c13504129c9f7dc8e93e4fc679ec454180ab4d19ffdecdaa7caf5fdfb96bc05f7a07d159d999948a43d5f3d829e212b77391d64de657631a115111480b3dbd8b6470b0493703e204aa33dc8be6390a52493f4970d5f77c4fded08dec2f00bb583c6af802751d858f5aa69b86c251bbf2bb0d4b16040c06181830420112442efb67a2ed3766de870effeeee0675dde18f9d9c42c705818f3e35013e7ff1d378f7f294c77050d3bbb040e06abbbf68d3fdcd5aebc8113f96ce7fb6e2ffa4097efc7fb415a46b471b5ed327518bd8f3395f8d126a8fcd47b8f17408e31985196f355480c221ae43dc5aa2d6a9848aa35fc0b93637ca24e0bfeaa3e73dc6ef580f0119cf24f4b98eb5b7892b564720a655601bf2ecf059849bfb5fe1cf069301ccee1a8f1cc85f75d480114a5b231ea5efe50ee0e44fed329da5377324945ace443b52bbbd1de00a7bb22f8b46d7f077ba60c923760b24af3bee95587a7942ffc159e2b9eaff552b908e65fe65a4279c58efa21b6f0b0a5b9dd2fb7272bd2396628b23ee7fbabd50472be8af4ccee906b55b8e88d0c27f0db82152651c81ba7caf70247889693e40239fad7acac0b636cab3352509300a791c45ebe5fb2c01d5c0688959ef18bb19f8e72fc8fb9afd84e5ad9676e2014ee7f7237ff588778ff0ad31da35ddd15f0961e38cde7c286bdb9a8c4c1208072b57eb0eb761c59f6d4ba86ebbb71cff053b2fcdc5197a3cfc2ca904340ce69210941ab11703fdb8ada7711dd099e1160f3d3b5e55482056c8fd2c29e1c8fe7dfed13aa9ea1ab3592c4fe3b5a181656853b75132bba0135a288ef2204c70cf3377b01fbd94b53055c8f46b5619cf8381cf7ed031c2dcc6be013166ef1273e9aeb43366071c3f4356aee321dbc68f8e464f281f1bbccdb1f8a070ba3a458796da81fa81465c109f3ff7cd8c1d27a5b3cd28c19e5dab9ea2862ad359e8eac8b7ba0e0a5231d0c1c7e162d8762d2eeb89dbd6e3785f79e66c1663ec6a8c68aeaaead882a235d46ea370f4ce026e277908aa3a6a899f6f98129b94bfb17bf3c627cd8d7d0b22d4922d2b5e3a0117ce14e24f67518b3cc73b1a1fd72cc43c41e68ec709136951eeac9fb994fa9176750205991156b2d07d0f0365ba0bdf7f35e90bd202f71bea19a7fff219cae2e0df183ea1949a820f6407828ad3fd1f087749fd56123eeef2102d7a85ad8736f5e03bb0193550b46fd996895c3e32a24838ec7b5fe60925a4b45158f640f74826b550d5045243539e7ac1f97339a7a9ded117b5497ebe05a05ef738c3d51521d29b9ca6c7e7e2a9485926a9519a91092f5b4102cbe2504e0396d0795e613efaef654fadb20904214e3cd8de1001cb4432d347a5460ac1b57ee00f202a4f6d6383ac022e5442d0724e914bd8c6668f2043f517cba2a6149e206bbafa4670ed202b05080117bcac1412b16be06bd1448606fa0703b80be12047a27c00e2a82366a6a6a0e45e481186373cf148b5b81d74960b6e13e5430338ffbb36dad364400b5093246557fd9682de2d83fd9c71ead3f57b4ba45fcbe8276ccddc3ed3a94cb1c0cced55a4af12f92fa5f5f98ca5bd4cdac25f6004cb72af5cbfa2ef4708f895eb9afed8751d651b8145ab6aeea039708d368782ed7f5ee627f8304bb6c6961e8f10206e8f01f932f3e7a3d5bfbafdd68afe74609693b07e83e99c2e4f1953a50453a53a3a6ec4097eb02cf75aea9f0b536b5d48350f50ff7ab729a227072cb002e619534fe534145093cb204d64f283ae3678828b24e3f66aa599fd483ad6a09bd73a9476ee984de26fdc7644e93fc3b911d6f53c0774930b694021f5dc9527cb7cf33691d7c14235b4324e1e222a969202c4edd7225dcd672e929f90790870177499058cbe43ce1cded52f7f7bc6448e600cc24fbce65715f767fce874dd8cf54834d1a18418cf51a6c0c725eadee74ac058fa70f8899c0357e3e79fb70c1c4c89b85ff02d233dc62a1b9f76f9e57101a4a6deb459667026c5c6fe8531cab05ac454b1a1e3439c2a93452763ead373690249550c24bfb5b91be43465ddaba9062f0b81d6579b7fce59388b4ab6e27826a36017de52141001559980c3bf321024781f3fbcdefb189593dbbd6eb014352cf7dc42587a8147103f671ee370d72d6a792f804f1f6eca420c21db02973b0535113cdb8178da3ff9c2762ca43ea82990c77c4a73621b571347973b14aa7feffe27d2f119d3ac7c1e8cc9ebdabb02d81d7500849e197f2b783ef39eeeb75fb6765a1912aa3a4f6e5653ffa8240d4cbeadf5823d6ed18f271998c3e509c764c3a0e93ec6bfb5c5fdf6a13aa4079f32cae6e956b6684ab494fb48134446448b604fce1f10ab23622f46e4d1a138add9042f8a9c3b3f5cddafb7a95d3d7abe427d1d929da2850a392c4e46093a04224a5516f328496c3c81a345324d4b8bc1256f44e52489bdc2c5276091e8b8b8000b124bf100cb20423c02c2a03fc16e11e1ee9244a2a5814e6d8401a03f3d7fb3b36fedbf59ce589536c5de0d955b7282bab20f05da075b5fc5edef07fe7404a3c0ea0954bcf6d99775e5c16c56b42e4c4da0f439533d96efedbfe872fd34547d3144940431acb52cf87d558b30bafbca8a64099b9424447387403da84af49e016ea64427daf788eb2dea082786426cee71094f7cb88b080a9de5aa1bad0ff1d4c719b1446e078f14c8d0d09cd4e7b80d96b5449d03888858aa08594fc21a2ab5d0697565f27216de87741556e99fbf7bec65f354a7be416596fbfc4df8fb55364aba355a3c50f205c38a3e93ed0bf4f7992a703fb06cecac5f8b81038ba0b0ff0674d74296df86f04811e4b84a10e860cc2d52ed4a9c3043afd2735737da9f5fde5baee3a277bfca465905981bf1f2b495b2bb3ae826eb68cbfcaf8ce17b4b78e2050c195c31c50b54170719b036a4efa6a006b07fc648d71b11cf6bc1cc0b0607d366615d0e40550b50b1c8b417277a697e754c481bc3d50f10b64670a034f71b0c8efb3cc41b29ba3a60946fc41daa8315b15e83f6b54a2e451ab574eb568392775e50668d865b548f1c1808146c2f406f69fffb93808a1a025c71397902ff94417aa5e5dfcb1c2605205d043640e92deab0a52840f35d7e8f6d9034d892ba3b4a605fafad632f4c763acb9a980646d94e0b33853c059c113147d0f63f5a5c1850adc567c08c5d578fbcce997187b8fe477c747af89b95748e17de554d7663396268a45e0c68e362f71a4adf687e76587c8fae9e16758edef3e7ff3f2a599f529f8890225c72839129c0e61476a1e0e17ec2e8d5da38a5208195f88d1504def8288c27ad22990050cfdea0d45e0afd90f0fc6571903e5c0c58bf0cb16d721ce52241e6a606b432f5914c5acb1810180cfdc5d0e1c1243502b3af903c8e06c8812e4cdafc1c978d3c11d028c2abcd6861e2ff4814f51a679dc2f7656fd26aa51653980f038cd42a6840c54827770a3d8dbdc2a4894b106f63ba8579cabb28154cb81a708068872518a0991b657438c3b258360074bf3cc3496c6a7a7202f4377fbe6abd480df425a349c6384c3886247037c923a0a62ff6b628b5655efeda4686fc75ca323b2e2887a8d1f04f4bc4a720f2e6b8e8d353e943e21ac50e1d955881c35987d7643ba421a3e274fc288292b7811360152600d534439be3fbf8e0c49861103977944685b80f70aba8d6c63377904bc6effef9ffa510017717c9b2f97640f21c03e83c3308d1db6635fc101068ca5f0be5ceebc95de04b14437ca310f2bbfcfe92ae1000eb1442b67ca63e9623c4383555a4e8e6911879a30d44ef4b94e58bd76647f48778e60a4804fccbb52df8417b7ef305e56a7095b42ff2715d932f67bd07545c74714d6f36cb108ca57a7b6fbd2691405571390864cb975b317aba9a09c05bbb3bb2c5a1e63b5896721369bdbdf20b6354202e7ff20a3ce60f4581c8585da944ddba9d7231335df49d87284118dedce949812adee9659c6f3c20548da4e81424851fab7d5d2bc497d1a50d46c660c8a32d3741ebf76866345e97db80a12a84992b3ab2a465e343fb65a3f4e1488c6a1085ee1d2f1b61afca2db26301a60053d5bbbc4d6149cf95aed0a5a9e6e9d3de58a5adb83b0bebc701c55d1028eb5c654fcea4a17e280855c6f3b4424642a72d3617627d236e6bfb319739042945e38b6c26e674ef86d01173c9f8d45c5b00cbe170ed11be173fc93d239f5a9c4e6ebcdef5c4997675b74fba6c1b2b945fee451995eff213980ffb8e6c5ddfcd445fa8ec3a0f0c0808f16653ae24f729129d9e91af43be0567147566fc266a5ba4065125b572d1353a00dc637919b451d5b1966cf5d3bbec18aca466274d5535f5bdf7c7900562e53c89de5b04ada3f887d4c936880a6867b39e17fac1c1144e960b2f708863e23a77a84a45c85350229822ab8085541fbefe89b82b562e0a1b85a8c55ca187ba8ecfe91a8e2800844889af1dc63b90338c946d99f884b4d41b641cc6a4466f056e334fbf5441a69d651b49db44238e345cc2bcd4d6b79abd227fa255b8c1ad4454fad4b62995cb73937c5b45fcc56f09a00817fdce0aa22faae167cf3c19e357a442d85eeeacf7a6c24542fb7d8f9199f649f809268ec95ccf6c0e9e2e514cf0c9f8ab9b44cc5b4527a3a70cf422dc5952b2ce96d660498b14756e791009b3208c7c6b530df64abb944e7bc3e5b2f6071cd744b002d1b5e1a02920d46aa4e902137d67a395ae14d37a145c65081a386e4f750c79b5f84602f5de8b90d5cd02c4872dc1f8714ee8f90ed41977aae93f10323a0d60818d2e7adfe3175738a1c0be9dbaceebdf544d46b75bf34592e457a417f62a1eb7565824bc1d1734bd3fb55ee9c11d7b0cefb7852f23e12a7ee868903dd2b93a534e2b9dc057e56dc47b287f1daee47468e04480b5abe60bc863e0b93d53bf09e4aec6de8e0fe51d52e11aa8855a1adb0d544a8297cd37f769922f937dbceac8ddb2e0b37f816e7854b3d4a556ca44b1b1ea7f62e2f1a99f476f085b98f98f98b14181453219878662708c57e1fc428e2a202a7eb33c5979a94d4c0cf8b738d983b34db6f88c15ac04b06e8cebf68e7a533cba091b6ab5fb00ebefbab512049130579e3842a2c02ff3321a601d6f40a8caa27a599ebc51febdf044d2c88b03802688217b3b10f712a4b6cab801bf52df429c609bf0eb4bf7b2c43266278a80b7fc17958ab300ca4fc4b90e7621049be6743066ac08c4f5df9f0efe0fc3741032e4ff16e6e9eac95ebf0d0185b79a91c6b36448d2ae44c0c55e916e61635440cb55c201bd19ad17e42e358750eaa0162bea99fcf86aed592af867da4a85738c784a468de42912786d8c0ecf16947ecf225bd639e57e83a86dc05b8556479a23be06922a23aeef7180143a51e901b287b69cc1844904272a5a041a9cb6e2656af4ecde0d4d25e1085fde0494c17c8f4953184c079220c575ce0ac4af7ce9d48b664e4ddb008c4b96f4ab6dfddd9d16a1151ff022f0640e87b4f3453d03615cb350e5feeb124355e9bfcb753ba9470c84c254130e62504764b7544c15a5c8508b2e100ffb769c7f12cba568b0a92a8a6f4d06ddbbb9101275d7b551dc1c55d60206a782d6f90876ea460cb3b7a486e1de8ef694760d33056d0b1093be1e12332f0ca3dd36057df3f3c8179d349976a2caea6f4bb3ca8ab3ec01d6ac152407f4694e51709fc2893c92fdf22a9bf594f89a8e3f242d6b58b46a4265e68ca4951ba971f6e27a9e444b277b7676a38251000c4807d346eacf8d715a75a56188e477b51c4d008cb0053160430fb1cfb75a4156441b96e794208882a6edb94c3830aae643b3d1354da9810ce101b7341cd8af6389109b93ddc62a46c3825d0669546068e363f88ef5489b71700f12d76bbd3dfbfa44e46b8176f6dc6264d2d4e4d35d112af07a6bb39ed0c71dcf24e3707b3360614725812eeb5d83a8ca50e92f45de44964b91e7ee4fd8699c1d3a605711a91a1e9958f2886a9c146e9a8a5bf94580bcaad0a313413b788114cd0d59c62fed7e1045543f22f75f5e8582cf2f08958568d045564a102e3ed0afcdca55a7b8e4729e98d3bb289a710cbec01a740d97c3232873ffade39592df970417cc219f13db3b843f434eda3604ed6c8964052edbafd9e50f8cecdec3cf52b3a6eb5af90a112d99a41d0c478c7bec7c09a4d5376ee7dcb53dfc1d7c20cd784db8d78d2bbc56d46d2d421c0fce0780d495d3f2db0caab4754d03328d35b90653c69f7eeca85ac189d5feb6872e46aae6e30760231addd044fa1ca323a4b66b49075352c0360723c6cba83e4d216a46a6dfa07c84121ab6d268decddb23a508de21636bf36fd363edcf32949067b2dc22ea840e39715416feba4ab4387de7a153a41eba1e7fc84499ce13dbde7b78dbb4ef0d2fca1f0f03513935f62bf2e5cc942a3d5248d41d3fd3fd6fd962bdadca1da4032c6a0ef16d100498864c79a3b205cd031fcf690cb3f9117c2fc6e1056666c4122388b22b9612f3b4c9e434b85457f9182eb035412fec4baef7497efc2477f9d805fbbd2536b4504cc036d9770ce5eacaf5a06586bc1c9c4b1adac2666348458a571652d73b622bd8b62e3183611af9565f19c44b842b3e5d3772dbefd0be839d8a1418aed22bc8953d9aeb1155bfe13b142c580fad2ccf5d63b386e0d2209ab61a60c37502ab0800694a6cebce3f21d76493c06768d6fe85245558d45e924dd2a8c1a2b33993ae92a16c9cc33b4b63c1b736d6e1be9872a12748cd726d7354ac975e77519ef2f25cedd73b843b16fda6fba40aefcb5d0ada69d19d7e39bebbe4df171e24c0ecf5348240cf0fbf2f0b69615eebaf275172d5c8146ed7ad9dd8c3a387485eddfcbc92d916bc604a2a480c7e23cc6e78acefe102c63a57b535bd429747962ed7d85fff32283d42fcc7004724d456f2813cd1ad600fa9240882b422000b82e3240eb55186cfa86af3eceeaabc3978c8f793dd6e0595ca98c74a281e1c19b1c4a814d1dda83b50c0de0c60dfd669d55df46c3857d4cfdaadbefc54d5f43b6916fc75b43c3a99452a2370f80c9f57f49b9e246b55fa1f9538ba2f7b356c5a4129bfae5b6499b1bdee14d0f991dfb1d2efa9cce8ead65c3438d1f2dd698fab1833d7f6a0dacf5cae7acd2e540cb7875730cb8fac8f48512dc2166ce54e9cb0edf3c9c2c0b957e7451eeb84bdd056f56e1d2031022ac6dd633f0d3b1238c6dad4a39b2d21d42681af632603ce0aa69985b6c46b5e6b625ffaa1a6a45b14ee312843abc8538d43e6ac80262b18327591c03e136aa1f7aca6dcdcc8ee441f8d85c21db1a55f4bd4c5ca7a01814f8e15c32b16658e5b6b3869b84cff51abf3f55a1e7155a148fbd1d659f8cd5529ac31aa3c4327664a163df29d2b4ccb7eb2e2158ed671948843ef2f5242513502aa6bad50ca127ac39b7b98a478731b4f7cb49e056da4f71f283f18024ca06af17db88d169f1ad73261e77577ba58033e9c41b14ef8e72faa5df5d19ebc187f0395bc07336777c72ca92cf26ac7203ae51ee2a9c4bd9b231200cdfe3c5ccfe4bb1fbc1e5f18575d56cc5371f27ad613fa3b9539811e17962d592b11cf5e6dccae39057b4d267d94e0870bfefede4bd41338de56ea7f3d6df7edf3e1dc79f9e34f8dfbb80a601bf132b8a371133088f077ec796365004aa564e5ad222cb7890d9ecb747569a15e26a2bce254ed4535bf2a311c672470fdb94665b3aabeff773db86a926da650089c73693858e3488cb3c3ed93f8f50a6a034fc0dc707485bd234b3e1569f161a327201388380e0e0186c0648ae87690e5bd41ae84f7fed75bbcfe8dfa9a08fec6596e7e90c4459dd5b0cc5605c33496b9a7e19974ec377cc5d1fba80e97f2238ff364bb175a444f19a797a384977fda3b063736f83e4db2391997946f25d0b9a81ca3b18f323b7c0033b896b3f38ba8c6eabc0adfb88889ff47ea215a67205be32447da681eb3985c166e20c1d99fe70e1eb142b06de1daded288dbd8dee407b8dc6334918b167414c1dfd1940c22714da46e75cdacd341accb58c066005b222b3815c904e9b45938ad76f6a133045728408f750baddbfbc36d05d1012dc3a280a5e870fd5d5636b4660b70a0116f67944433860dbbbd40a60ab5a54998e46c005d907c4cf56030ef47867f3de146db94d35d17235c66ec9bf8c21bca2daa69cf6c40669bb1352122fec5c56983b8ee31a1b4969ec6d0f690546b514733c855268e1cfea0cbb9f0320393e7fd512b959a9afd2a162a3eeb0a814747dc9f3cb2cb0e9219a0088d4ba2a86be86a4bafdb0aedff5717eb4c3e015bf57ef52d78ff89e63d6bba69eaecf7161fdb9aa8ba303e88a5dcdecae5a78f8e5e9bb16df6e49eb3e41eeef3016c39ebc07b375b5f2c6b0f0e2f836ef6cc1b3ce02bc67b1d33f270428354087df22ad84972cc080dd2e5c12dba3e0698ab0c3c15692ca867c1aa68d46fea8a08751c14b358ca6b70d7aab77dc5de1f91a9181fa3fd9e5df8d7fc37517219b40efedf06a6349f0dc62e80d0814f119543f2ea42c31c4da419a8a143a309096d442adf44faabaa41e003306486aad12397caae56ea091c7276060e13f407144c44219686e735df2936eac8a7723a9b0f76121e894dae4849d8ca9b9e47d4bc0a6af49c8f929d210cc280a0910c7d39c335afd4b5678095b712a06cb8160a124f4688ecc4ea8bd91f7a4a481f94de1bf4c5363f75d9a9817f9ed63e818e2573d7434f3041fb821c91c4b0597b374d1aae0e8cb8d4c59cb516b42f482c503c2b193e75df47a8a7501e34bfe29a762f5712293269e6d8ce59a9dd36752391c410f4f087a633960e2c2a11db9be5b02a93308629c77c6831d2461d620f7f17c9436ba47b095239f0cc47d9999bca9bfb35bce7e38fce80d9cb511fcaeedd4ec2ee5e705d2767005228b0d375da74b78d1105d6c08015a1e47dabcbcb4c5573590a6a84c008a1ea028f465c32974fd2f7b03cd2382977795f563b8b5e36d3ff96bf2cdab5d3babb62b0d6eb5f55578fe2dd7bc514ac773736d574173abe91720becf97ae2b78e13dfe20ab46a667d29611330aebc31f52b170df18aec43de944e8aea86bc261e37f8af4fbeb5b568246682e0b3e7e7c6cc0e853069e3730a7273d104807c197d02714aded5da5ce0a79cda6ad8ce2b3d65423f3e6ecc328dc4a7f8b61645c29e8c1173e821a0f8f36be1adb1dde4c2206bb4025df5a6df828c0e69678d6a61ab84e3ade808cb40dc3585debd723185193ae27bbf5a158fe245820e900f887f155e0155662f90a7df6eb58e30ab28c8aaa74ca2946eb14a9fe6e5a121a002617b8da2bd3fef101906442c595199e897844eb4cebc11fa09b9e3f04f1f7ccc0f67d677c009f7fffa5e49e9698921e4bbf655fe2cda3a95a66a118d623a67a2146220f9db82a2960a874828b1948d45f88fe30d4e1398dea6d9f0451aa91d3cf0e1ae5ef45e2a34a66971bd50a31f7447058ed92e6b43916aa97557a13b9e818187ffe45dcb08c887f577679091741082f9876f7b1acfe57dfc38cd946c7922cb2f6e9845efda4ce16167d062ef5b532d1a9ef7595a6223d7221f1d04d5674130018937a181c768158c40fa1d4cc322f8e6f9441bc7dd50183893c1f881c3d7bb25ccab17a492b8eb46bb2bcefdc964f7b2b5cbf5dad2984d9d7011e92266ab753cea1b205cbbe4ede9844c40c4628fde87202ae7c1d2ef4bfff25df8061c5aa1c2c6188ead86c1e4fccc8839e5ce0b5a5284577c2eb13d5610905665105f97fbd2913225bd0a5e7bdd724ff848e0e86b63f423046dc13a75b9930e70ea54dcffcd96dfae83187dcb7f2c2b26e7965998fd70257243f1b35262dfd686421956b461b039db2389252fc1e7d83eac47bfa573abd0c03b290b85d31d6003e46f59e52c9130a377450850f1f2cede310fea5c1977b4a6ca6f249192620db0886a74dc135412554006d65e1954193a0e70f6775141cc2eb270c83d38d591c2aae85ddf671856509e9c231755e3705a00e2fff20c65c22103d90c72df0f4b7a543da5b778e83aba84898bfd8dffc1643294da3e155cdf6aa660f7cf3848ce317cc1cfe200d41afddcc3b35449b30d9e4c2532f4de162789cdc8d7d6451df8514412f2d54fdb45b75ae9c1be7811f052e8ebbd7e35fb08ec308d72d172ae3fc8a1a857abe6f00680aeb28e908411fdcfbc43fc160d4aa0711fefd5554fa8840e1fceb7865bd0d84797d76e9e1848dd6500cf9d0b42d8a4d7378f2db231d91656c3502a711841cbdcabf5d2d6793eb59f8442eb184ed1b5376fee7e4feb74872beb838fdeb57870cf0f9c1bb0a7f4ea9a7626fca8173a41efa64ca8bb787add331ed4d9f0c497b2ffde54d334d682eafec9abd0ba75384d77a87841d33313810586de8f5e761cbee81c0aa13367deb25ffb56262ea5dff4ef78b1ba84b8812223a672666c5d6260811e08386463fb74bfb766d5ab29096a5e5c44e973ef57cd5713ef736853e5e93a210284d212a7578b31a3891dfc211943dabf3d1e65f16a954420c75885bf94b6954e06d88a9b8bce81ba34ec35f475bf41e990c8049acf834abe598f2025055bcac0577aae18af9280015cfda84be408e3843b6b74a430c2da1494d2bf1931ed5e1e28f4f0fc14b92d0c911504c707ba1ca4b50d491fd862b222d1957205d061d1433a11b40c0bc8519233e144e87725a142ef6a3cce31aa70202aee19f69c5f3e1151844f8173f5697d433a19d0a719105622330f335745c64fc2dad64dfa0f73d7a369a845d3aceda65f0ab68e163befe211eeb24a8d61c7658b19420023be0319a814ee4787e5ed6258ece87c12873cf70332207c8df6ab0c61481c413b0528d84148f2b9271b02b648c03567c204db3e708c325e99aa0333f7af250f41572a61b84a545f2c399b6f98a6bcb26e5644a7882926d2418d9b1aec919bd72f8e14b94368a4053028049bed6a75ebfac78c3e3c9d90660ad7761bf2ba0548491e9f123339f14cd057ce22bd4c674ddbbc2cdd596e803be3a38a231d39e3675627b362d065741e2229d2b37a3540c7cbe7e6122e49ad2ce22cf86c2f7a1d2ac6bc02363a4967132f21cba5f3064d35b432375643a8013173a7007c644ec285a4d9b2fab2cbd37df738d82089fb255c8136578440f01e8e226e0d0ce0bd41bcd43b06d6303dfe907cc5fbf4f72ea7c86227be502609c4b41192ad2cb97fbf46659662238174d6c4fda29cbfa89116e8e875a0add647513e384c4a44ba7615a96612495fa083cff2076412d11cb30c060738f4f97321c8f4db0ab994313d8c3d09727b28e9e654fb7c2d62c2f316845a67d33077b0f8856fefb6901b2b19fc7107ccf738e0561508e3cc81ca68fe8d9cdacfc14f0728bc3f052a3fd7ecf2a4f164ff251a57317213b50adc8cbe3dde24681540487236813b5b2cd1acc93e985354f4646074cb477cb9c1097ea1d288a15173958673dd19eac51a42d8cf3e50a30b9e9024d253a89b0fcd41351fe14703aa8e05a31d291b46e47cf1a1f9a24d77ccb22ac4cbd1e76dcab5edfb79c7f96b5e0a12d8b48364c008adc91f3d17d26480f11b9132de67b85e409310f51373186b995536a40a0f9573026cbbcc156984cb1e02c3bb9f5dfdad6a15ec1240695c2b020e44204b6bf2d7a21ab6ca715b2cacab16d8a384d0a60af935d534ee46e49fa9c129c3c1955ecfef7192d9b7aa107b964465c2207f9f7d65e7d93bfa4eadbfc7f2f8ccbac3c89ee1d038c7bac1ec761d96970813d67f9578e28aba0c8d2f1e4142b2d7ef5ad0d35ac937c7f8ad3b94bf91c374277480d8987b96c0b73539bb51c25b5315e1e0b0e0aca5e7e7f488bee0dc098f0de9718464860b8ce80a1713fed368129bb45fbadb15452fbb3f2eab58098053f9e1b2e9aab56c6256532c7870187abd8e2c39f5d6135d88393c27cdbf5b389d0761f87391c16a54738ef2e25d4a2850ce5eef2d652bebff564d7f7623b317020431aeb3ced242aa046d962a900ae2968ac3472e2bef9a0af5c8d009a711372ae551992c8a0bf7f129f42a24d0f8e97c7301552ab50dfad5aceaf1e44bf8f4b3deea0a027beac61e394d82d6062e31d5b0ff726d86ba01fa0d098950199521579886e1a62d6e96c4e1a7915307f6b18f542d95f330465678ee3abf845038e5bbce3ce8bd45f0b161aebde679d532f67985cda7e3eac8dfe19fb421ba87df57baf5551a7e7b8bb7708913bd0d336c8c5b6d6782db91f55459eeb31b690507ac9e7ab547d30bbe6591ffe5e664ba35f8416cb9cc83b174e09cfabde1d06011f3aa75e57d2075accd27f0c4b4d3009610b56eef0b2b497cf7d45d24f75514089e91c4a55c8a60da2164338dfdcba1564f79a84164debf28efb3d230507a96d4458f9f8147584dbc87b2e3e08cf47cbd70e4a9d7cf15153010d6c713f5ee8ffd75dfb1f920d1d34ac8a483a7cf25b3e3528217ea82cd75875e1c84ed53ed11b3ae4f9f1747348fbd99734cf2b82ee2480c84950d90d08d60d1d87333423d12e9217ef5797a7d54ce3e326f8eda915d09f4bed6f70fc0596b9943720d78500819f663bcf0fcd56f1a72eec9c2ed720948099273d5a373202acb6def25d6f0adaeaa5a7ea0d9384cd42fbe3d03354cb4e44c92e9c0c25713150ba0dc3e1837989640df9d9c77499c57fb712331f72fc060646308af9bf8e7337f9a3daaef86b57fd136e6dbbe59f22f6514a024f04666a0cdb9333b586896848af447e1d55b3a8ce9cb14816fef2e039e9d8f1446eaf51ab65add83eedee2e10763c33122fcb6c6848bb86f8a3dd80d7ff674acd25ea99bd15b2937a0fcd7262a642fc46d826f0a088042bfaed7c46da0406f54023a7a9f75687715f282442feed13bab8a8f6050d2604948bc1e17a18f14b70627a7b78718762d6a5863507a05852d8c08d49a87d0228eed304583a2b1b2ba5add51aa788a48c63850931e542c1eda36a731f5c2384f5c910b3e781fcb1a31db31c63f13edd62ae7accbd92a3d372a10f921d6013e07297c9d2495d0a36407ea692ec8ea45da5989b78354b4d5b9da45dd76817c563887d87f17d278350ac4d121ae464dc5d7aecfffe4fb16eee08c26595a7515a50a73a8740827e6b5d614ffdab171da6e90fd3513bb17eee875d4a6f4f6bcb0399c95cdde87b12bc7fdbc10c89c3e5fb7e16db6821cd4b137bf2a21cd9cab43fb77d61c0539ae941a050f31822ce2cfc62262a9c4c03182f063fe14a78ddd87d3781a3d2db79ac2da574a5e364bb18bf7b26d1e61419a599deeee5ef894976f83ba786ad75118d83651cad1a23a666422ff55ce224d75d2b6370142d3e52b353777d4b032dccfd7acc40eeb29524a1344c48322b1d6ccb9c3efdbb273537a989c9b924aea5fc0f37e2470f1d85631fa5b90fafe7a0b1769c85e917cb71fbee62667b2d77fb77d7e2d19edc03a8431598cb498de8b42b8b9b3da7f35fb019bda3d6b5a3b7a01d9aeface35e1649ccfe19a46a58737d5d6cdc3832b1549c71bf9ef1cd2fce3a7392388196b3f755084e9d8b3944d6cee05b99fb54ddd7adc45344223e559466c7b053f5e9ca410f5569af7b19a53a097894c1caade21f2928e63d1cc937eccae0e37406d6d605953f8d4dfc557c6a4a736435bfa3dc58a29b319d62fc17cac6e76fe96a603c67d96fb6a7ad5e0e99c0b745cd63227d802e823f106bc9d87f014b2c7d9b74288b800f3ccaaee601395b6083b3d01820ad3a66829d93ff2f3fcf5846781e21f43160bcbb05908e58a5557b9da59af78997077d97703e46533b68da10e7d0da307eea5ae962fb2691aee019fa42e62063bd8de56ede16f3ae08ff64398a34a0067c39c1639212352535a7bad79daa6231c771004f486dee4dd7995b7554a3bf3548dbc31b707222e0b09e8e257c5eba2f62a85290331901532d9a8cc6522feae72288b78eaecf1544f70218b62b83cf53b657640f23b100ad49019b0f1ed593ae16032805db61b1053be2b75e8e8a088d8c4b7ceb44eb48e821b70943500b2fdb5894cd4e9cafc846355061ed2c3b7fe28d442011a294d235533f8b1f0622487a1ebd268aaa1bae724d7e389b4f0aabc5fe052fd31d69e874f755a9a0a92484a55e5977c7973b6c6da26b373b88c9f244f34b4720bf75d2d4cdcdcb0b485ab9840c8b03537091f377227da49e695aa449053e89c8bf1dcd066dd4d8f93809994ddf18ab5828b9b77d3765a736cd70e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
