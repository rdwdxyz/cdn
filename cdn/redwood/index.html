<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16a6bffffc33353994d5e9d550a04ba080bd210b272e579625c2dd850b52d8377acec569199c93666ba38c96620eeab94ce1cdb5cb1999df0e633a893fad47c474a63292bf701aa238bac68b900500fb5f8f167c65a5d40ca96916f92d56807a585ecb70103219eaa5fd11bd37c21e92046f2c04549859c4286b2fd38b3e5151c785a72dab9227c9d7fb29ce48fbe19023d4a69a383d831ab448dfdd2ce942c86bd1d720ba95125c0d9fa3b4aff3ac5024f926abe3aba44458490c2922e7445f8006ca84964cc6175c6277a83efc75dd76ae5a4aff98674ee3ef98f1fbd287a1c04e0e4ec9591d87d5cda64daf519d8f9fd3c45ee4f135f572190759db69b82107751530ca159e01f34b03ed3ea720089689695cf4425d4927715a7c40b09317598e6b6e6413bfe41b1abce1015b43177cf3dbda5e9cf909be67e2f7efb837ee2d57c533300bd0ce70b611763aca50fe0ddf73f7721ee636fe14d3aa62d47bf6de138ee06bc93dd459bf4fb51a949fa8566e07a1d1c92c5277100a83ffd66ec475b1196d5ec77df432d3ae39e8b65b56c39db642e6d8256fee90d9e071de01b71773663963ae012dbd8a1e71a2225edea2d8aa2a92910073722daf02b8bccbc195b17f9e01668fbfd0d4a0cfb4f62f452b5a443c8303e428d57f751b1d6bf5d0696ada05f8a81a5e939b02dfdebbef092d7d0d6efe46e05fab0d3adaef5b6efac2ea63b155b1731afebba46f0d8def71a21eea7c05c2df9c7ec5485d386465083b3be5868ad74ca436ea27b596aa8c36650ed6bccaec7319560f119b312ed5c5a9390f4ca1291db0add8108c9fe9facf625002388d229e975b146fb3a7db06508d15b48f8c5de4e8653fa418188315075bcc8be4d6f1f69cccec3771aff26c0ca50d58c163fc89e0026bba33d529f44d3fefde5df1e4344d2c10ed9e369f1d22c2b0e344aec3f7476e850526431f18b3c59b079b058355c58510b61ea234b90040eb8d50098f120439fa10f099ca8fafee689345a22364d777686bbaf84a8427ce7244010a51a9d86e5b6db9bf4ebaa36221d864ae1331830898b6baec32d1aa9f42e4792daed1faef23b3770d0b9858da7c0330306e6a24c0d7d307ee2304e8a13f24da60affbedea8840754b748c3d54c43bfb3fe871d479121c557f97521eb5dfd8f61a2f4f0026458dde9ac5ad2c064cec1ac9aa4c6e75b70dfc11a5d45ec79ebd21496365e0a966d58e89e3c8bcce6e8e8207591900a8a187bffe693be419cf647b8db059b79771a36029585d1afb049d94bd597e01b30fecfc8a337da5ceb11a8d08657a080f308494ba2bcc79459bb55a23905577f9ded79182ca3feaf355bd5b7ca069b01a0db53d371bb02a747f940a63d2110dbd17cdef47b8cf2524b83bd306f3e0a49e46213be92ec5356089d58a266a766a5cc8cd7a1adfab1cdebce5d987f21761890efc65fd652703cf7152edde58ddc929c42d0642d2affb89561e59e652a8c2d557e0bf48afb1cf53735f94956e656848cc2af5bdf663f1936231cc9ca6a957bd22dae887279ec4d5f68e88c5e7eb08565ecd4e90a9986983bc06eda5af9b1e152107b96de55b3330c374b6fa3acdc1e476d86bbeade80e70d87c33c7f407d41f19ba3a0651bff1b769d18cb54bc8da28192a0b9cc1cd60d2add915b8fa66a7255017eddb28f243ded518d36c3af11ea773a5dbdcb2ec3165ae620b9155830e100d933670b4df9df96d9a54364e968e8eadd91819166000aeff21a355c1834b0fcef1830c90ad7b1e8846f16419ef7c2809a51b3df1ce0a2da79730f88e1dc085bb22ca9156d246e207f1e08c5ea5b70fdc1afe04e6e1a7933d4ecb3dac802b5246dcb334d50a1a072cd4299da9125238d3cc5f39bf813098ef23abd3c197c841d171d59bd503ce7423b94fb60f6ec5967ea91c4beb67828089c3c8abbd56dd701628b9e4c9c99aab8306e43a32c2a7770272ee5ae72d30ea5c0f607b66c487eb3e7d3a32cc0de3eadd1b39407150e2b7f1f4847b62248c07386cbe9da115848cfee95b173426d05a8cb5516465fe0c9d571a5c913333f453fac25724253accf907f71b37076b66ddfa32534740dc8b50d9a22902f126958825abef7eff68929db07c7357dee2a8aedd73a271b8775276b8b40b63d62ce14dbcb227f34a9c2fdb9bd8a13a1ffe12d0eb4f6a1a374d6b9044ba4127f7c2681261b9eac879ba25359fb0563866dcb18d8707bd6d98686b95650aa7fdc1be4b41bbaa8fa1b8d1f8ee853834483298596bac06d1e50d593157dd803d4bc11cf9baaf2e8903291ce79eda9cdebfd48f0c011473006e7e3d1adcdecd8f6d4d1f6f26ccb3dc917d8d7ea4b0b2f11b413410327e32e5a2b9587f332835c468f837ace517c3d4c19d3c8eaec27cef37b8c90b01dbb6e9e2bc03ec197faa6a7978648d572782e8cdfd265aff315a6414bdbdc5d8bbadabe1c3533bd5e4e13ec5eab3fc2b0a739805e563ad6412459a2a30ad1450285570b51ba1c78f6c706976e2600946a154086a48778c5b22fdf12337c87eb2f9507f669d303d141d1fdc032f6d64d60f2d6108204c565c35d6ff8ca42f1a0e8fb2c549aa1dc141a65ba594dca7eb3bdb90417bedcfa91a3f9c05322f848ac783cde4f17de55f4976d6a1bc1c9d79c949d8b871f67f29d83b405817cd2d8966feedf04f2d74113a176326a44b73aa589a242875ade31f8d3bfc53b5b61f92ed667be4be2fd70f3d6611a53c3fea5f9435b92e352aba8e9987fa2b81e444d4bf8fd73dfdb71dcce69ae3bb6d8b02c63deccc8f5c0aed379dfcd6336823287b56aa9ee801fd602567501b0563ea7dd02ae8239418ff6d3fbd77e760a0f098bac69d5e8113e3ddb72ab97cc27dcb19f5f8dc03fdfe059817fb3fcee0564573ac361494b81e8ca36a85a1f04f2a599813dd63abfcad0e4f3e1e22cdd7614636132699a5f4f41cf599c6f7d946d2d8a546022cfae2e949afe87b34e0a07e4c7e883372782790656ca9bd5657bc18d5dde48daee1d83e51b47bfeb93993c014f6e44bd0e2e4f893be3b3207a117d1d76b55afeaad1239fcdbaeece1909f91e622c1fa334d931e8a2ab616fb9fb308d385fa025f10c3d8af7ff99f9b68763bfe25a1e08b1628af33503f608e3410f127bda97b1321376ad130b5ae8ce7d69d0d9da97e78a06650dfdee8903c44e66c90c5af62d969e193ed8ce1b902d2aef6a34f0ad8c5d8bf77ea34b7def9d9ed096b6be23d0e1d6cc24285a436ef694ed8bec3248e99e71f81485f21c18b084bc0bd56d2b112621f606968cdaba65ee7f1e491a087c80c62f5dd3c8e3304a1216e3cd596d5aedbe5dafbdbee6840dbb498150b2646d4cf915cca0555f56ec4e6592212d817f7ee56615f9879fd2bda4a1ecf2f38b90aae8c455b373415a1f47e5028bfccde7271adf1605b4f7d10923f4cf8e34d20f0f3bb32b8704cefdba36e3d733266e5a1a526e3f0e14c8244d47b93ee6320b7b38399d4b07a2bd921cd89f4f559eb35eed65dccfc713687437bdd6df2bcf18946c7a70c9715fb7df323340870295d39cae1e73711e97e453b67379dbbc70eec1b4c5dde531611da0dc7a397d051a122b9d925806e897b8fe60fd4f33d921373fb67516471ef00ad78834f39ef35356e97568e03c7bf12523a338e9d1f37338fe88777dbef9a4f4fb914db413e16f2a105bfeb460907577b495986af77f5cdf1ac5cb528ba7d206f8c4d1202b01528566e0e4ad2af57a56ecfcf3ebc572e4bfc7a46cb8bbca6fa92b895d77c015b08d9ca153b2362bcf6074c40350a8c56d643aa5051dd212616f64814153cc1bdedb434229bacf13a105d8c74dd00d2e0db4c46fbdb5eb5e4d49edfe28fcd10342b19334eb9667d65d5103c9d3a197c158f5e2dd7da2fcf40554838ed4dbc24deb554dbeedd70f09e2e8df61c5c3c78bd897d608643e79ba56a9a6943221264d4cfeaf831796a4d460ed93ee78941cce3defdf9fc6be87fb34ad59ffe17536fd213e540f7aebd4eb47b2ee17e0d96d5c59539a0c55de05f6ebe83371dfff48c3f6d1e896fb0181ca553e2178cc486f83e398b7fea92587af9c9331e36aff321d5a8779e063553300e2ace57dc6c9e629763fe697fa9738350e4a3a0887e5ba55776052fc70056252c7601bf7870442e14bfa19338f71b75391767d5a6959e944d605512fca3322122c3fbd14848107455975ea0d6e44b6f113da5edb8fdb10cba5f1122df468d753e4a78d653c0efcea8b5746b3a65216c41bfd0839171609c88aecfb56bd92efa1f718f0dcf2231c047beaf993bc3503f0ed6ea69ed67771df1268ab5d826eefb8946a2a4d053409059fa22bc8e6c5fb35316efd7af7f763add6eade4731b33c3d4461f005d5bd8b43921b2444a6674fdd867bc9b1a3185049cba883d6dceb46d05d34b5209dfa59e6c125e1436675fa9d6fdb09769d6a98ccc22219870ce53caa3d72f162ef2b7997bf11e0fb4d70b18f4f15192d7c0b8a7ebc5776c3a00ce698ae913d6787402b0662cae10ebc148994dbfe450c55c7b66881f7bd586a4b38d63b91dd550bcb04170af15773e9e092681aa059353724f5586ada5613b730c4aadcca1a9f3b788687a1d80ae276daed80f5f660e37145408d15196d4767093d95468c08f89b9c115c403509972a163f12ff721706262649377df83dea35b76e0a87b9184712c55f12afa008c5a9e7e7cd8d28eeb54720c05385317951d8f3d5601f72570922588049974da8b04581592cbf05458a852b0c64267848478651151daa3e2952e59b505d43fb0773a382eb3f1c27262bd8f4ef552c6fa49d921ddfca8f11c114f3909d5aec596b4aa0e8deb211f72519171e393471fc0eda9c58df05683f6bbb31ef0a0931b303076e88ef36f90be5e73965552c386765d5cc9084343d71c2dd934bee32c8e429b26d04e2600903331775f3eb3d5a09f76f5860e889eb7cc5f9e869fe5e426722192ad7ba7062eda080619a5a5ab1dff9b72fdee2b36d3b00189f81236aa6b4a476951ddd61654dfc190851f7e2d9b6f80b7b74cbaa2dc889a1402925759bdb04ba5b37b3f67fc6fadd221f3eddf1174218f02daca3c99a37a1d3e2097a82730eb70e31f2f663f7e34c64bf83a2287a6e573f1758b3b87638975a74f0009927d585825e44b72a122401d77354a9c3ebc6153ecc7baac24a337e6f6931276aaf6d0f31f34d39174964cad1a0640d82437a56998ad66c4c982f6ce76ca03ae90bbfcd82b7cdc5f0af40d9bdcc4d2d89f7eb0b870ad691deeece960fcbc07490494c5324c85a6169c55f08a3b82401d786390202ec126de731a3c2cdcc3d54342c2824edfc97c40c93e091465b19e869d0e0ee55ae545a4a8e2aac740bb0b6463844a08b452bba1290e7748a9874ae9fa2449698d6a00037551a1683f179e161b3ce01086f6a99f6366928181d9e3dd437b9975f9a098b0be8847620d11470d3d11f59842f5ec9a53120bd60d5bb2ace31a4c0a7bb7d6ddef618792fff9a7b04ee4bf6ae8d0a8afe648a70e1f4bb6d70cd567ce86225ddadbc8600e0d5cf8cbe7d7e20d7f18742e8c983a01e11c50514783ec3423c3cc00150892e1cb60659cb24ea2cd6f76f08430c6d4b2baa84e32e7f16eb8ae358228148be81ee99f83aab53623a274aa4338a45438983bf2d77507c08bf6eaebfc896a50f13b5050bc639934899479040852abac60faf84723f60d769ab95234a24bb4cdcb1ea597cd19f12ce01d72f75eb3d5f255de5076b1a290667e49caac31e84353ae3a06db709432c7153ba968e94ec2567ba1572143caa1498c1ddcf29d7dced7fa0d8424b324350b3af5c11f07b8917cff04d45fb4e313ab05717d81523010a35cc4f8ee79c8227ea8f7d3df68514f8bffb22b47abc278d69172aa6bbfc336d45ae927279c05340a01bf978bb23046907056842ed96dd2b6e57b0c84639f6048bd5e1f01b57f65010c880ab72c643979ba06b4654c0b1610258cd4497e28ed2d02c4ea2f96fee9110d264aca0cf7827d7ef35006cdacb6291c4ec3b6ba38e7eaa91651f2f58c81476e039b93240b7edeb0d4f801940888c64a4fd12c93404c6216089f28b6ef5b098aa3dbdc19ab967d41d01e0e40b558e48d5ec18abda3255a103fd88151b1bbebefaa8ec3f3c128bbf49b09629701a7f16b8861db07a64aaffbff8205d77c5782db3b28528573d1ba0e041ca580964995ba2af314f2d6ee6b1d4015d5d1192830be0ee6e29f6676c6fe5473ed4b20c794c95e2db20b2632764468eddf5c36653e7ea270a359290fd5290a31d7795db00dbbc91cdbb50972e7b6715d3d1169a52b05b4acc4a8f1259e56d400fbe05bb92e041bf86509fa25fbc402db7003c6abb62a481c4136e86348ad36fb6ef05f1592c2368ed72fc6af8f1c1554866e6affc7236d239b671a01767c39b66bad8cf0cf8a774e91bfa3708907c2f2f33b223ff301fd99bf892f9723d0a2b01505d04fc69f14c28fe24e6fcb137c9fb6bc59fbe2248f4eb6050f4f1dc603998a30b0ae486287a7f9ca45408c3ab229d9fbee613d3c3527310a6492569a61c8389048ef2ae30486a8d8f839230534be2ca6385f3f5dcee7e22e43276d4b3cce5a017ec445a2af6711f8f85b8267e5a9f0b75325194cba1c7a4f5a6cddf06c2a8f324a212d0ee2d3c875ff21cb9ef95aa4b7e1a238911078fc94b62442cdc685ef28d7a489667d8b549d30d8221cad0f721f66f8febbd007607f744f3197b115fbe8d906d941be45cda62b9ac48b45d87f52e2c687ec3ab505159ca442e6e586a23ee23ad710e4dbcd2d42b76a8b0c8c1f63ea0134567d4f326c705b5d1b43530b120a24d1d8c04592c78e09e6634fe098c4f9a6001b28ed2895a1684b8412fba0a8ef582c2a7a308730efa84d466890c56d884ac921189395934b019aaa7e2103e2ba9dcdd3a687f847aa3a6ce474198b691251c637419ccf34fdf5429b49af636b4530406608d7518d0e25134192cf213e8f858310c20a79b0c5ecac670bd98eae2a54591fc808eb2ea28f4f99eb139d05d0ad2b0d671d5fbf5c6005347451ed813dfbe564e17339ef19e715dae3400ea1b4fb132215e89cad136e7bade6ef129cf856d336fff32d5a88e40307d4a24614970cbe4c4c63d0a1c715183fb13faa5d20ae21296ed144d5b5426e6f5446d90866f0d2aec5fc7575cb0bd730c59fb74b7957405c1fbe7ccae7e079bbdb5190fbf31659dfe5bd734192cd7dd3847bb15f1936faf02200808a22fe4b5b025c79aa067b83a6ed068a43b7f83ed1a84a7a0dd4170019d1dd092947e478fb6d72de06e829dca089b8c0cd6ff0d32dc92cefd490fe65b7e0c61274f7b15d259020e8febf91cb53f3491dab00d7902c586f33c9266ae90f6c092922895a90e8b58f7bf155973e39a4e1d717c6a0b15addb9fcd03de361dc3c327f1bdd56fd7e424bfe253e089272c0ddd5d9ddde342ccce139d6e3999ff7400f3c9e3fbbc331e43ce09f0057335e09e51574435ff97a2e06be57be95635463a2d799085f0ecf948043798a43a6df100c31ebda36122cdee5cf9b5d860d5b30edde6b79a6044a18369314d9fa99d2e4ffd3b82d7b483614689085070dd146e233f360320d5925eff814a79866b674f08b037c286d75c57a07dcd978580ce245b745eda8696998f018ef0e36465f676d112cad83641a6d6b2d97c334a8eba48101ff366df4694ad1263cbd7a3f1cf2cbe04e02ef4e01af29dbb1a455239fa4c4b7cd70c6b0eb80aa46732b275a8e32dbd5c4c85fcd8d72a518e1b88266539595c701ba99977c34ca4991558e4574b4b2ae0a053985c671828cee72764794f281e3814debda4211655cba3610acc3b634fee33fed99ce44dd954ffc53b9201bcd5055ff65b8fc1608a58e46aa8243e3f04bdd46a432d338d1a52d03452521c9b6514c98c9b2fdafb844cdebee2fa630b0237fb3c527aee00c2aa9ea49363cb0d7578408381d4223cdc1ceaac4ceaf5f056e4e03a40e54ce986afed7b0fdfb4b2165fb531d70da5b4bb364b415b4daf7758c265a2a405a8b69c13c665e862443a9147dfb6a329e328be602b96748853cbe9d55ff8828311b491c2729c2c7421c080c38b246a1d9d4ccb324cd067d02bee410be746abc127b0ba6f2f431874a1fa99900d0c8168c1dd1ce4ed8c15e0cafb1fe2ab26a7d3236a90bc6daf9114b4a7431ea736b173599405d5b16a75a00be995c8f88e89f36faa14d0fe7eca8bd4d48c9827e68bda55982ad9e0a7ebc70e85179a4f0b7916f73a98b101c2a5a36d91eb0792c3b69f5d5d3192478d64f65a1d56d4f81d70f9f3fab99f35513954bb3771fbb829b49680a70b526bab8acc92afda77446616d23f4afd33553b6b8304f97fd1238f7b7590ae7413397e60a0b1764abf515bd8239f6b720f5e3558fdb26c537d411d608f5000f93e9820eb317a509433331429bfe1c58ea3f967931832459fca2d2952bf3f38bd1d5c88701947c1e4fcffc2d2eb8023e0f3b650ff24221b811fe856397fe9152db912ee2df6a5c1414318e8d6d5557e5df2c4163c9e49d597841ba9bcbfe10fc3ee2952521a1a66ce35bf738fd797924cc0f54c6c8363ba4e195c1256187473984f854ebddf1c32b5dc967b6abeb70b89420d5fca0320767d382a337f0850c408bf04c14e73df02c758158b89e2ab4fe38f41c975244873bc2f4e219245492fad50e13d378728e30869487ca3d7535ee69e193af651f396c09bed9476d01c99b920cab4745513a264d5e700c205ed4bf35fabfa58f61515bfc32ef769fab41634a02c0cd1f38fa9351905efbfdcaa858520cd381f1785084d92dabe0504ecb2b4c023c99a54a0e23b201dee38c62c68af30bb7ad492c9d60b04ff15bbfa69403754711ce75e2a07c1164cf8a9f8362fef8d2197062cb37a02c3aed88de300003e41213bdef3da2eaea917b7a69f230e971d3ed290c0f312d515f31d44d0d2e7738ada4aad7122bb8b5c173001500b6a53ef2f8b494083da9e0e324d14568196009f3b5c315d76339f3ac32df85b35bfccda0108116b8888858804f126ff8fc226093be57be38594cf21df4773b71ee34fe87034cd5a344bbbf69b2bee6d79de831b8f58d494cb10bd59c7990bdff36502ef67533af9b63ba4e53693ff98f5f23d2b99949337118750f4e69569e66baf7a7c4c615bc9b675b1f9e0443d2123c2e426578061deb73f14f389339b930df7d3d05fe02040837cc8878a2e849ef8d97954701358003a36d011cd18da6686b7a855310798e39395b56d10fe1f92f9b01a2f43f079605c528e3e315c961700002bb9519789b965bdb08e7d260f6cbd661f97e93ba28e644d7d4b2accfd01230baab936469f2b62b8bc4ce4fbc3f0676c1df254f8c2e7bd76f92eb452dcb0ac8bcd62de52f8cda68f69c8fbf49044f9e72f3a8f587de9fe88bd3bd50b1ec49ff8085b5050ff07fba1b3e9acc6a38211698b876488acc955b59903fb5f987c503b5e29054f9baff9a0dc4b89916350ad37f4667f5ec0128c2baacc89c2fab87e4938b309b8279dc796e35999a3471772127c6b1ec8351fae0b21eb3bc00d1fccabef0b01b268ad303ccce70d792834b59fd8eb34aae84bd410dff14c26de09c254692063cb98593108b229531a67b50786f917f2bc6f4df4e327f80fe3c2de49e3d73e2cc7be0a633f6e91205419446e5712eebadf41293d5978a2a395c35d36e36f5add507107152a6958b229ce1d9f65b98af9faf570fda2039b1b117560d0fd2c598cc536ee7249b1064572380bfc21027ad144acdfd5b3a04f539ac3c1b363d88ce451fb9fe7fdef342b7f297e86610bb1c593577c48ff7653ff076fb14f01056c09d03470eee38bd09f3eb0ce20f6f80b10a04f47e46b0051510880c7a101611998922d0b7b8bae884776b4dae7671cd845a38faec681aedda1ab92025f039530f55034541f76d50cfbaefc77e0055c0b288b9648c63dc56a7f3d3b255145e3c36bb9739bf138c2ec1a54410f830569a38fec6a6b8beea66a23db1e6f32290bd7800485e28fbb55c20e000ea0414b63f69f2fa516acc7d61917d722a8720e0f9577c88fc8e6037c364c966afa168953944cfebc37cdae84ba5c482bbd0208f68c9baefe5d06d60983b8b9578cf6f3bcb203378f5b5c6abba6cb2e49d5c5e7da7b402958ec736c605829637340820b33d59610d7cec2ea3e86aeaa3ac254a2d33e0e1ceca98355447514f320dee74cd8120cc74d326245c9e7c0f32f2588c1b8f9204b75730d7b49307c21ea139dccfd82b510ae2f0b40394c710f4f9b08af6236f8d8c929ef7eb2a37c574ec727945ab5127a579fc5df913adf99f8bae7a1a72ca097987773b5ad8f21f307a141f066b17cde3a8832efffae7de44cf7977446ba9890ffc33d3ce92ef7e354c6cacdd38526769434441767b8148b7f54178e77bb8b33fedcb3bbf4b360361dfc34875b2eedc0ea3b782f21f12a0bb323c8eb4b5714f61b26ada872406bf506c67fa3e51eeb31cadbca6582ae6218de7c73ce0361fdd7c849db0c45b8e872a5dd57c629f14075c5353ca689c825a51fe40b953bfa6df60e8128a112357c6517be195bd7864838bcc48deeaf788358bc6e3c67950bb1280ae93c43392b2fcad30444d3075fe878f1fe9b02325d2aaea8bd5d5d42c868aea474faf3fbaf7f846a0aabf453d02b25d9209297a8447ebbf52e426b23dce380ecf363372273051352a1e818fb8b7511e253cc597e42670f90096a589a2bea0509102bbfc8c9aaf535e2d4b0ce5c628fa8c9dce93bf369ea955faffd9588640ba3b3e6fd59a329a565a3ec705230146d3510e482dd3aa4883a47b3979f30aad12613ae3ff6a15aed2901877e93ca7cee27843b78f996082d9a5c87c4aa0b85b4f8059d8a758cd5d6d567ac2a6814d949382df2ce662009c9653f98dd55aec2ec29626deb4b75506370745864ef0f048ce77cdeccb6a60c256f9858f54260bb87acd125296991aa4b46cb53490173aa5b4df2c481b8be46d7f4c7de474f59fbf274f05bc39254c20de16bb4189fbfe124acd4df7052026e4b779ec8c5481b54f082bf1012921a1f2e14ce6e3dac4d0698b74d3baa34f66add0e19774f535f814888621a38cf5506a5f827d46c6219721e67f5e1e74ddf310496bda2f05688a12b555cc8f1b011baf41b27cd1c8f19142351b7729429085a357a8efcf1b40642045c109ec1531728e2f2a0ccf37f8df9bba03b6a8b5332fb3b3d95bbe33eb0046b7479508f88a8798129440f99577b55415107964c61f657c1ddcf1f5d98e811a61690f7ad4d08b5b10aae1332abbeafbf120f49666ea34c903dd2727325dbd341902658eb575d96a6e5ad41cde3622bb28c75507a881c51943c28e82e9e5ba35ad872ae06e52051288811500d609e21b76ea446c3dd20eb156ba99b618bdcf46214c136219acbda403749cb846ef58f441c51f41fcbbb45d02304d6d53620a7b0d2de3de9a8c461da30d52b69b57f607961c031f21ccac184e7ab6a9bd265cb85b55a1013307d094905a2d4f813099ce2f869a4f03a1cd51cc22a8e2456ca190e6eb0cc4fdf9373e3a28a0f3c8af4dd4825f9b422d281bff204135be7ccb6210e536abd7fad5cfb8059000e4223245e9ede63c39b07d115732773eecaa0bb969e866004db7b61da2e0defec111603625b89b260f8627064e41949dacd6764476e1b5ce1c76f29c35d28ec441c63ee89eeb18c3d648c5e1fa4734baa20a82cdf5129d7d075184455aa52278745a580eddc4eefdb18ba7e92c9d979eb0e916c5373bf9272008b7e4f6d905ed39cababb0f83aba836ad9645e4118d256ee8a327eea348afe1ab131fdb403c95b090a94de6f7fc615b4b9d64c7ef8fd8672ed785bd0bacc2bc95b9670f5a1021b0a99aa4dddaf46c9a3f4586fdf57b515ea7cd066a9b32878712910eb62ae4b7763f7525019f0384b4f5a367567125299f4c197bff15ee3ecb605e7411b69751ead38d2db68b7d2a177b74f276ef2bc5227d86c45a07625ba759e48998d01a248401ff9d6d44291cd1ef103c8703dbbabade5079c51a326899e0b5f9c6a194a198c0705bdd676d82f68a0588ddb1e902c758e7ef3ba937d36d206cda475c1db81d4f9eccd4a4e3f1ecbe4eff05919f6375632b03ec0af592b19260d25bb50ca06804854c21925d0a87f74227db7d4735230847ec16e09122a545f99021464f0b999e49f58aa13fe8b0a1476a1e9e7de28fd15a72d6b1173a36af845dc9587d7e3e655faaffbf18c8d5e7c6cf49f6d2e7a22fc182e3dd55fc1bbf3b669c2d6221b1208b774c9cfc6c8060a8082fd9cc3ab253b20c9f0e0720546374318b95796cf6a8e23a96231130a5c76b2560322c046c376814680de5845a723745cfd6731a95155e28b49ba3c8f18609c393c54c6f01f054a7a5f5fa0d92e72fdb4a8d1173531e850e719bfb29dc8cbcfb040dbb831e9ce150e5e609877332ae286f2d382a1f3188c2a3dc6b46f52855d471371232939493848a0339563566d41282ff47e9efe52ed2465a67d4802ae830fdf7800dfe31e274a135047d525214d89b3cbbc7eb4f61a4dcfc7688224a4f0b6910551b61631f8bb5439720a26f089135813e51bb969611b5e02c36d6e24e300001f7b7cd432ef7d10234675be8013d755c8b6b1dad66113551f6ccfdd1304851d31e690e392e0bb28f9a1331fd8e8988a5fb91b045bd5552bcb4ca8a98d303cec58e9613875d04bbc9d6c894d19aced3a000ac9754d1f1d1bf6e8a458fa79ab8ca56061204f54b6e8bc9d6108d90bb2be8827b00fff5edf3f73a9b2fcda9bfe5360e77197293995ab6a0970fc10fd0eb16adff70ee17e1d5546d731fbf287ccc7fad4a00209cdd79c5ea07ce1f70955b76d32f9e5871cfa5520a8a5d4f8d05c9a23e07b371bc4483092ba16a55ff107d5dccb479d37540c090b2de16b164d848fdf3b269d59deb88c429d8d4c79cde09f777f70353337a4505d53ccaff9d2f503d441e29c6be6a48fc1d9c9e9692c8848f6be487fbd42fc1345fa3d58aca1317f672967b6ccef17e49c779a36b06318c285619ce2aa6fd43577923be33e3ba2b95cdbeaee9c8a03928454efc9754ddfa7079513cb2806653bdddda05e068a0c3ba45ce267955e68b5f5aed99ddd323a3ae59e29771a38c1d8a96d6ee0ace1c698424d6e52cf1720a72561e99e07c9e01ce79d5680f263753c0b431e16d2de1a5f8049d22ad1de7bd5d1418b93ea529e7cdabd94fe80fa69ae2bb814451de2c04de9d22aa70043d0302b920943830cef3485179fb2e729df77d1b0323a667ac89dc8b04eff43b2d6be6b77712a415d3c7274ac7321e14260dc2cb9a397c7765c1b2de00786ad4e4ca9ccbcf24a1ab7f617f21a96a4a58f958d9180310d72046590c91e100913497bfa5f4db76735b25aa4417a0623d4349f25e97493b1cd95a3be7447bc130ba43ea1ae62735939f5460cb5494aced1a70d43cd23ca07806960810cb333013375365c40b5af74de42addbdbb0aa1bcd67a2dbf2f503ddf27ecd0b3acc62119a3ab0cf6f399aa0e76a79591032b5c0ee66744e3844b3d5708b9b492c9e6ed86ed83f49eabab7f8bbbe1581a1ade15a63fd285f29662a0014dc1509cf1cfae79af8cb33e2d53e96d64cd9abc71022c476f981f3dbe36a43dc96b109b20931ec9f11934f7ceafc95fccd2401f7dfa7a9c3a61bf97134f2d95c1869bd2a0b99b45d12c905792cecaaace8a2ab577af40443ade1de7861bfd55fb5b7b8954c3587717e8f5c662a55501f2b61cea16d939e5f963d3eb45a4a232c411a8986e884499fcce11c23e77bf8085662fa94497f5ffbd8061d78f98d326a8687d3cf4087bdcc668fd936e3af390f2106857cfc857b5c5f300b75f8810d47004618ea669bf6cf7be565cc2a1dd49970eb46dc40ae1110d04f0df210ef6c88bc169a6f4220cd09eac9cdb068ff6d9136fb751748604bc1e54bbdd54d053c54d6aec84e3387c23353c1d82791d9aead86a9aa13f5e0d5427fa3ebfceb8a2814ae9ac18b917b5e7e00ba44791ec9c91ef75ca60f55be25d42a2d701341727637668c3806e9245178ea9761be0c7f98332fd6255117cb98c19f226c789b9276af1074c020abbf91b10cb8a6b5e0b1560a7323e49ea801fa159e9a01746d30a72fbb7d9ba965c338b015795eff693fe378144488e0b928d21de59ce34622c9b7c81a3d312468b588d4ad640922234fc2007ca37454df462dd06544d121814f63ca1a5dd6e8ba029d258c6522849030781fbab5756b10a33f3d97473bf7892a1a89f45ab62ab0da0b84298aef5a4e1b9bd7f5bc454a0baa2717df164d14fad247f76d7b3b7eb1a0c8c8670178cea089146ab17c5a67adb572460ae4604755ec5a4e31919f3af41d462e2cee3afc02ed2bddc2e77e525157181ae782fee2abab48922e4e181e89940d95220eae10d954f4af0249a692ef69bd786b8b25425fe8e356025b90b387ec2c8cf2ac0e75e9ee2bded95ec1b829c6eff78068df32d57d1f2ed31034f0373266082f9ab0ff21fbce32506c6dc6bc2827bd0ee3802641413032467ffcd039b28e21f64df419be4e3e03c3947dda24109164559b19614b527ec8d794afec3a999c4fd6f7db9000859cd5d956078156a05087ed3358b2801c0ae7017cf560afd6fa795f334afb53b9a7a29fdb8d0d0b5a7e172657a6abab7510c91ecaf93a8e7ef96d7633a9b08e70137a1b42c96e9b8e59b1a8b8fef4b0836080c970c4d02247436cd85df353da8aa7b0e3d4e841742140de2047900bf3d1276f0a894e3aab63ed28aa3a8aa80d10034a0a35da3ef129905288b419101c25328c72b85a6d8523eff623517cf1fbff3e379379e27069c993d06608241e009184ab8689eaf0910bd7dafb58e0aeb8872aa40fb6c5216e5e09c34817a1e023ff2b3558615762d8c6cb57fcd8d49a18b14fb67c5063fb0514f008413a560ee223bda8c3c5eaab50e0225bd067527b1fdd1aef45bb2d1918a4d3480371817fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
