<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b4cb45c6e78a1a63b09aec280b9261f692f286542c9df90c95809c13b4521d604fb3084a545f281dc5772a22c38721eaad1609b49ebc7ce46c21f40a687a4f90f4ab7bc6183938490a5c0b8e33e4d6cd659770417d85726b8ca15c7710ec0e9d59a1797fb9caea9429fe95de0a4041ab2ba51c601b782b6a3890a02460c88778341679a920eea2c90f8f12e2c8ffb25d23f896fb7ae216fba0d480ee715ecf2c985665eb0a0a65b2efb8d63b85d24a32a67ed58e4fb54f7a0fb4980e637255c8f92f0f562b26b62dd4c988c7a7605e5c17353bb13f3e65cdec75d19a82a89876624d9c975c3a2321c4ed30c906d495867410f472a8409ad53298624e897d337afec3bb62870bdd9406e7bdc15b64bf5645a8630b2e61fa144664e3ca14dc1ac1bbf222c34f776427cd5dbf908981e2f95947394fa9485fc8c84ccae96a2845cf99f0ba2a4e3f157e872576403d8761dc5ec48c6bc09a43a05de84cfd74881cb5b0fe957f8f82c7f6d8e52afd822766dc67f4cdd8e6234cbb9f7c0343f39a913eb08fd3a2f86f938e297a5ce1afded28bd06c16b13cc555365abf1f46e344474c1bebc61635a0febc4748814c1bf223fd7ce6e9c6add6e20e7fe51f884da777bb73c16e3dc51322825ce5d743880cbcabed117e038713852cb8f839b9052ae86e70a4e27939b9dcf251289c7ec33b6e70f5428400b707d0472d5d0773f6d441caae192c8ae9946ef5f90e9843b9247df8c4fea95e5383c64e90c5394165b6aacf6453dd00cbbbf92cf0c40f9e01f1977d8503cb0a3b03d8aaa6941f70908652c2501718bce5e9e19849af3adb901e200b360a9493c62aba7c8fd289f9a7d9aab0aa45bfd526898b78deffbe94e9fb728847628321f50eb6db929a22000b457234d15cc979dac617f3d2b83c671ef0ebb318b81ab8377e2a666f03eb866821bb7356814d0591717a43764b0542d57bc21cde854ea365c3649e59c4370196f72fab1ed78e7c50f352d6f7b2b7f3e991145ef7fbfb8bb8b4d220e9c626a5e615cb6af4d9191b163a5ccce9d65e72be32b16bba586e87aef99eada98e05b5c5f95bf5c3e69164bbb4eb68bb80dd7abfaa0cba792e94e6da606d9c93b6acab22ba623e6562b7d3fe822ca08e88495c65923d669bd192b57791c9f61c64822d74e85baf6ce251259b3c3227b642f1b5b6ab17b6a9f6fdaa8b8f7dd309d0183d34204c2e40567a05a98fed722c9a75b2e0c73feaee8ef3eb0499c5b2eddd611de3c101634113734d8184e1dbc39f6fbfd901e6c92aa047eb82fdfc095acbe995066fbcbcaf9c751e7caa1d9e0928c617e06d0217f5c80b8311953884450ebc825ab1e30576e1ff5e6e0ef2b2b4cc78949188948e266dc0424299b6b4a771b41a646599f9dcd111db10ffeea244c3286939f6072a9be34219a18ab96bb7b9faf0cf9a652f119fb85fd7b9f35c9a8c55be42da276d4be77520ed6926b3cb312665f1338fb5b9d777a9136842dddef614a53bc00085786e0c6e55827e2e08c0265a1f59ecb07008065fcd2acab9f020d719328e612a5f9d9dd51a4883962b300434006326823e5195f1a4b5fefea8b63b2bd9d864eb984155cdf1c638e9af6be4c618f95cc234b1ee887144d1597295e0a6d6e42d4a976490bb70b589f7e012a71920425600a208499ec1b03120548b57e050f8f0ee49c3f0099f41bb58019534d47015fb9071e2bd94bf471751035f6e40d5358b6b3557a0f8fa120a8e0e80db40bae556175fa0e619d51ef6f38cd65689e9ee9f34bfc05b3f20276c442f150d7573595b6ec9c0982fde72949e3cfee354fec4de671ee3fb254e21162cab6d6f28ef0880839763e354a7b9e1cac28576330c700ae7df344303ca933fd4309689354014398bdff248a03926cbbf50c2276e0097192493ce858b49782ac3d5d3b876f81b494e8f3a2c36260b689d1aeff64d24ddba82f5a53c55f66187c490fc5a9237859b106a110900664b53c0678009a62af25ce215a8b8692b64980a5afa8798df31a4864540a04569e70cfae55036ff30dfd2e0ef513c75ad3cdcdded934fed2acf2a207705ba7963267c642a9fb5b917e3a2f1bdc6feb1f0998f386f4349b7fdbc25e8842754b4c8763f8607603ee57ec93d96a9e17421f697f308ea45fc2846b9178754ee8043ca3d64bf52c05bb4f653dbcccb43f078713da4271a8d962644a082a9c77d94a90c0b7b796e1861e5dc9ebacbcb26f440229a83d03652666b5e4a92d2647a979851ec3a22099348c050cf07ca7364428ed627273963548549555b0dd320b2f339bf3c2354d059cb5951a23eccc99cbf1c83786f4f294a9f5169cd41a7933f9ff614f12a38489c1d028c509970c29ef1c90cb73e20ca258d6a299989e00d56ee4077bba3c89d8d832ddb826fae5002655ace43bc761bc4ac4b1295032a8c43150c0be8ead25c697cbde56c521b6633a97e04f1e27de78bb9745ba6a9338d4c0f79c28f0d56a5f509fd8c497fb8dcde43a9938557e81080e8dc702892bfa2d6bf75dacb57ce5bcebbfd854ea03ad645cd58c9eb0ca379c537044c35c7cd06a9a07c1ce8a5cc9a0339b54063c4e100163c9b1960cdf5a7f6d89925b8c70ca31f3d44f7ed3a60ec49f3c3a4c2bf92e20554e65c0aaad4eeb1b3dc3eb89a7379561135726b9d82019977d95a25b01e5d0c93ca6b0d2c4d2996f7d7f23c3d15074ce845dc6aa7f2aa6f72c2ca7b28b8325e13d1d46b35224dc61211efe4763fe8b4fa02234c457f68aca99cff016496530efa84c019fee86ee93e1dbcc9bd69486b29b9ac5ded02326481e26f1cd0b9b909173c097b42dc256587022505c664964f2311764a76031dd8664436d6112ecd27c8beb78e06c2b494b9c75f4f9071b5f166b151654dcfdb43f2ef5c6acaede10b85295fc93103a26779f29e6965b32a8aa1101e4e1d00537987dbfa9fd152a97e5ecdd2ab01e7a17cd356e403f60c53ddacd5a03c079cf191e1b44fd68a94d897e758f6d81ca644b9197204d6ee53d001383da8400470f94497e845a15062aa9f68b815ad392adc136ab087cb953b5096d454b89d0bdbad7c1b1d82b780259e2e2c56d9eb6d4c8b9ddda6d6892224ef8e06bb1ede53ab864f02e6aebdff97b31be1b47d3363e85f31f4cae6ef514098aca3a319f222e1f4329e9ea82b38e3d9e63eebfb0170f01c038ea9bb784bc38a7ea925c220d34f84aa7b2c84e6e241b8abf1d71480245fc7064dd5735a046934f511fafb31368af3a2bc04ed1f2a53efa206750a937e2be96cd2f1a0ca820767cf2a45f17180df48b5d5b6a9cb14fe51677cd3eaa038344ba70f31723f58b6ad0b0712e2ba0b807ef195115665519d1e497c8d4f3a68e665993e186bf611ebdeed56261b66b8b63cd7ca965a5192f5068b8ecb8f26964539e9f52efd14af794695a3980679da913091ac85184a5f2774dea876661e3a9488d5ec6670484e038d69102c6cb3a272042645196448d78a8d54e8a4b466edca1e8c866b86f0b4a9cfecee4d29f8b49f595a6e46553d1700b977942b8fc663dce99ecab3e86f03a4100481b8c4e24df4e604894700f9840fd7161db5c9c00acb5a12be81f5add011ae7ecbc98254143206dad68ff1e1ddc716167c18baf1255327bc55f19bf28111014c1c4f234d30bfdfc3bee87f5160d634d89564075515902e0f6afbdddf5295e387abfce8b5ffc144e97e964c01baa70d0d0b6aaa1a685090b74ab7c5f031a4ca2bb09fd19272a341418d1b1c2e1c93acac44a3d51d02ce90b11d09bfc81073566b3942f8f9f0eca9ae9d2fa8dfcc08b218a3eb2c3d4b81cc914e121e61d6cdc88f27f952c23feb088e1692e71310dc3195cdac8574ed445e795ea8de9ec1ca8db594126ccb90c5c09efa31552fc1d8c336a0a05bb8175afd9f0a978699a1237604bbaf5a1dce6697bdfcfd056e43dc2b702c0be6c99f47e7820810185b41223079b694606c530e99bbd7d43159f73eff292300ba08c1a20d48fa4049904c4e56098716a593a1d209a63d886590449a145c5952fd256ebd6565ac77403e00d389f369eea041eaf523ce93bbbabe0e4073273e58bf4e6fd60a02986c4f5bcbedf35cfab1db5a0b7b93a8f54b4b8ddd010f014093d0c716199e2dcd69950a16000906d488e5177756be7f05aa1b227a2bc93ae1fe1f245a2e7ff5d9a8de15085e58fcb7c676759cb0bd9de3858cc40ed92ec3fe30b129fa070c0fbbe323647f086541815ec76ddc0f01e8b50cb8fe5d9eb1b854a219f38ea66ad0ad27788d8910b1712c327df2bc7b1a064dddafb12e43838f42940f69fbe5b311412eea41d907867906ccbbb605755e5518a348741ebdfbfcdf8e7ea511be2f6d5cd6e083daae54a9425d510297cd55e0a041124ab9633d45afec7cb33a9d7ddf7def8c5f25a338b491e1f138f203cc5e63c5579a1982efa322e47b37cda3f913352d831549209c7b33e094f40d1f1f7d2582d5e6222730e8cc9abfdb5366254f80f3b06ae102df8f2b46231e6abd7f15f5d66fa99de4ebf363b801b2cbabfb6f82071c25e5c96f6c66345041c2e2fb4b688624db658b9d1999af66f776b54a10ed9b4a8edca284b3f7236081fc6859f14e7252cca16bcfda07e58793c5342bd592fe17d4a1a0ac65b3544b432bba907013efa3f469c7a7b6b5863f2901a3b0b8fab1145cbaa8c38fdc402d79a21bd906176e0174816b886772d3de859ad2905037df9962f31931593aebc2e0a873a99916787ac22dc3ab8bca491669a02c422d0ac4cf3d1ede933de5062a7f6e3680d13f759e07d0a39b1673ea0b19ba3121eff201021f65694de689f1e1954dcceb6e84842431c8e64a072e3815d6e345d60788f086d049ef4102a07599b5fe0fb3607b92d4c08d5229990765c938a69cf8a89f5eda1c27485e06c446c25ada049bf4496292e764c4f093cb54f8083db721c831f5e5536317f676fecc805982a934e9e440e1b79b92f859cce46fa07a30d9e9de97b3657634f937a4d3b43311f6866eb43650046a257fdf341c129658edb8ac275fcb8efd59466be9ea03696767918f33bf9fd23cec75eab139bd239a5744765ac0f25229d097de327aa733e52c8f13ea69270bbf2db68856b7377d2aceeac8424e9a2f714dac04ca5d8bf3b2b69d4c4ee699ac5b43d00d87db3051b5c4aa2a36775b293fa9dff1c0cfc269d9d81876b7d2eef4dfd7b5fe501f4ecdc73f95378f9536534467acd973d76d4c2e30abce66bbbea9bbcf824840c797e79eccc716b7f52f435f067bbd79639da6eed84d4452642e003ec7ca9eb51dd45e99fd763afe7dd1d7ef02b3b02237153634d931688ab70c63298aa79eaad69d5029ef9ffdd64f9ac56e669f091d8fc717d1c29feb6a6e119b58dcc7a2bd09b81d0cc129ec83b3b984921e0a263a5f3d3ec0a3b29d3d64825a1ebba447156ab8e7ded4f928b3971ab216cdf2ebdaf11a6ddd044103547c67cc294ae015caf4982660c7ae178687bff148830422adbc35a739e1a5ede435b26e7d07efe39f53de89df417401cfc9f5db2614ce780f8c9343bd94cba18ce219f955961f8237054430c44ff512c270a1f62f2b9d54a8385d44f94e25a3654dc26d4add96d06efc07846ba1dd486477f192abcb1a892f638fdf0033cec216a123b5d9396fbcd0299d5147e6922f069dad814f4256d0196c76a30b2822c98e6c7050a96044f7d1cfffa3b36a00e78de7d64699ac2c7304a796c1316ffc6c98664f409e0ec43bcff2b18788f32af273f64c8995bc0f3b6e86367066ed590b04f9dfeda9b9b12a76e6ce6d03dbc524a33ed88b17341afd9ea0550d1d226d59f3f94bf28ec244d08566f181a14e4bb072d362c8c28b9184524cb6d085c1ac795ffaf3206e661a89c674a43799110b47c64300f89e0fdbb019da43713ee5c4a577b37eb56a7ac9a5df1939284079676f7a8176653f9cc77357190582dc71046e4181fb691fd95f8a59b5aabcd2b90b5699568c1029c0cd68bea464925740e3d07a537c32da4ec3a05ff5d282544b4f997c4a6d63c4b2ca5180f59a629065bc3937d8cdb77b710752017befaaa66fadb40da9a609a555b8fae9abf7aba45b4c7b32b47d973f777090ac16c6f21820f315234eb5e42c3f3b8e62cb788d25df4e5d8c857b82b2a40d08200971e381acab70aa8e7d092c68f45d5c119e14950f71ee33e9f798d38a88d19d340bbd6c9ffe912473d0fdbd7096dea818a32a7c6045916eb9d05a19b0d26a59da1e65fd58a80bb459f68efe7b3d26eec01985f99c770faf8fe91a3b7f37f20cfe62542bd93982c895c0adc6ccaa585216b73972cda93f997f4a5c2a878624ed786979c602080304a2bf9f29e7d9ae5dae47af4888cf9cb345923355f7a3b3243fe27d604e93d397880b6b6c688e9b8addead028ef665eb255bb8a2a5f9dfad769fd73b3095978530215faa9353683edd8112638acf3ade6c0da2346b1f99618f6213bab587fb7b58686483dd182305f35c187221b7c296f22f3bb84a70d142bd5b09ec88ca6ff1e5d60fa7c503678e1c6b2137d8c6bccdefa22c99590cd8c3947478f1c362cb43b3e7234c8d504426e5804a96dfa6171c28d51782117aedf04e05635d93a40b8a229b5f15bd7b94ee17fb2a4360218ad215959615572adbfc37c77704b0c6014363eaa6c731042dcab0e463499f30baa658d4e6192a8e1a346306cc6a811acd0b8f8e2c58e3cdd8a6b5041964fbe5dd4fabc28f21b726bb520f4e56f0e1ea105e1ee37cb5164ad48e53ed4887822919f4c93d2ce8369d9af59e007fdb40e65e7b033950c583ee97cf6217482bc3dc1159bc5b6ebf46d582fe8428a79a31c9e058b7512aeaa8eb38eebdfd82454e2a0872c7721d2052e6c91560decd36b70be1b897ab12ef9d4c9b9cf5ea5ad34da9125d86f61827dd6b9652e4c8b25a4f15cdb14fee3b3c9189a9f1366d79d29716d428b558b0aa2a6e4b356e22b41d95558938999ff664c1becf6615dcb3fb50c7a7c00a976794a3c95ebffecbced3dc37b2ee0e9304d31fc7cc24e0affb25dcfbf367cadb1778e6448aeeec75af51a44bdc011e78e13813d31b8bcf68bf0b0dde361fe868affc5ab83560bb087c6cecf339f939a4e78bdb0138468596d574a716e3ec995d36f736ea45c0f61be5fffc0659c188d186ab0e9193f5eba52392f261d9bbf330d6faab20d32ec420f34ad9ff79bc1d3e0f9d08cfe693a988d643d80da37cf28ccf0a37e5e46733b4ab8963dbb80fec1367c501f62fcd990195afdcc2e8f3b273417c1cc3e1ceb6e7df8a49874fac1e1a760ae6ede320ffa6cdd5aa5d978e5a7dbd88e65e78d7f52fc28423fb67a49de14c6f4a399ef74a55d7bd876adfd190114e1fc27db7b39bcc9836449722890f033035d474ca05aa487c2ede54d77fb8f8c3e2918b03a41a14f1f41af6bc03be403ecb5c2213e7336f2fd72dff60345a1d2f7956f627104ba0dbb24c456b6c5d639c37dd2d60c898d3dce57c22ebf8e7996cf95f6e5382640f39f93597e78daa5e0878d0eaeacb035f992cf754d190cefc52daf180c7c1e0d6e61500acdc9995677f6806d24f772053741aa5777c356edc448b022e9932a89e512ac24f894c486e8251b8c57d68e0040cb937cd8d7df27089edc6ecac17d174b92a6fb8b362f8e1e3a4bfe78d78889db8d68de9926aa6d3d250c532e5ef9e766583efb7947f02f98dab07f0e05c1c30db53d1358141d563e2cd36f0c616668b4689f40e20620fa90241a9b56f67c99d199471ceb97532834239183923e9797a27f32e82c45442f03e22b4226f4359ec6dc3dc703abe7a0fedd7da58be32e59b757d8ca17b4cc22ffeeaccf25fecea6c08a0edf907c42d3aa1951674d02d7a4a64e9606b0f5b963d9ffde8320dcb23a86bbbe3cba8ce5e39f84e860283c7d45f3691f0086f8e1bcb38cb83dc9150a88894d25e6e5ebcf86049dd13e214deedf09123715abe16187af4701c2e0408ef914e8ffa2f05f8da4ff2fa368f98b29ebad350a54a8beb539710c2343af845647d440322c462aa2802163d179e11ab61a18181aef87b37bb882796d1eb13805864b94ef2f009ba9c7fba1a4dd634520ac3ab65562739d97ea9ae2f6d7b7fcc85d7dbe13cb315e55f835cf5f723c41b865ff3147bc57c64a30d8d041e9910fc42e19973ca1e4870d0e7e9291cb0470e9ae539ccd80ab64829eef0b0aba70c2b90f7ebd6a0ac95f1d79caa9ae415be1c0a92d74bdadc0bd6bb9d883fece131afc28d3c765b64665dc6f4401974bcff2953dce4ec40c3a9afdcbf5be31b8db72d5043cca3a231560d106b39ed930e5b322523846dcf35c9c1752afc02caf720576e2723a735c6de3ed6acd88361d3fe187d35fd475ddb60730acde9ca465fb0667979bfa631dec6e0f9fcdd73385d4854e7dd934d2d55833a3ecbacc9e80b391400e6d79221e2e508d15e30bf3861fa438222ef239fd5f88ec5e52c65e9007819a71f4b859dc568f88ce7ab5c7e17c35aadc6f3248d0794db6e8bcb81eb24ab722333deae174cb5ae000e87d86c78069799d1b8f18bb2dff4871e32a24acac53a468571764105e6904e1349c28e99488fae7dd451bb8292e2365b530f90158712144da619a48e4cd1a962963eceb8ce85372307f7d9931ac1cc42f94aa24d0c3c97e914ef8736de95676c7d44493863cd96bc0fa0e94ca8c746d9696860b7164c400e578f3773f8e72e17b7ea312aaf68fec84801339c081aafdab553935e605943fbda2d45674f72d37adcb7c942a7a84098d2069d848093d68e73dec0aaef2b571d878eec2944478c198713de0f94b95079a95f166b0b441ea2db4f9820c18eb4bbb71064ac284285eb477dde752e1a82be95b196a45211688361e3a9e7ddb1146b856f0d82a774cd43a2f00a0344f0e6314c5cf38827f223a43b4a033312c8dadfb75634d95727c888ba0c756580278046e211c691dedf4fc72144ac20389d1386d434e5261c0dc0f3616ead892b902b5c5d7fd4a03d99fb460b2db722ad81ab05a98217d7a6a8121a2d73996ac5ff575a4165ee30eae576cc7961b9323335e3807ce65548304c9747a5d3d1928653a404d43a5b3419c49ff1b7c3a7886681817d62972b0bd7863b2f900ee88c2e666890adc2e9ea918f39c0b1f5a8d3f0abfff3ad27cb5946e86979cb16f256ef21e44be9c63b57755940911ba34e3a63c94b53e97850ef20b5dc360b76cc09ce7ed688ded0d354968205d3d5016f57234d4b3b7205388a597a29b5db427ff3669c28ea9dbe42f76a5066273152767bb8d82fa1c9c1a94c88d2fc5e3b8ee874c6818f953c3ea3f4aec7d98006cda4893a7e3167f06415ea73ec1277270cda09b338be294f8df50a1018be2e1b9b4c245faff0281c143afeca1a0ec71eab5cb7e9d40d831936f5fca0c6549dc5f9689a4cde28e58adf3d8a175fd1ef357cbe03e98637ea2e90217d9a27051bf1661ee7f5ce12d352d03743fefacea3ae4e4b91e1857bb12e942b801fe54fa2eb97025148412b2dd5ad17a9db2e9046ae5c7f5c3cf54b4d75fb68b0e8ecfc735098dd3ea6bc8095d42ebea287b3d2438819389cd3affd53308845acabf06c683ad5efe744a803bc54316158d76fe430b319dd5f89f4eab25b1e3c8f694f6adfaf27490c50d83a038d32f8c4374a19a22d6585b52a7f0a1788eb17b3fd3a633f3215c30526daed04bfa6246544a0da075bf7d70694117421785659520b3fb379495b81c1ba853f62f0ad7d9f935ec524b427f47fd0d39b4839f7cc98dec60cec228051b6af73645a99a3562132845b7d620b0e112682fe0e5c15e9d996d3a8669ba1254993f134448ee4a398a700bedc5a04187d757c1956fc4cc1b13253cd0bbee20e0852f266926b487f3c07f6ecd7110a83f72d55d5ae7b4c60e905937019a5372e1ddc9f4d057f46192c41a36359a43d1c1aff0b954b49728826380d1b2bd465735bd50ad2167c27141f049c0308874d780b32dc744dcbd025020cdb6b22aa750e20a41fb1f10758473863b9a634e33160b8d6abe0d39547a400e30dfe213e78139c54309b5a4140283cb06577db3c0a2499ed9a3dcc7bcf294b89ce4b00695e020c4d5ff515252c359183e7672375d823810bd87e346c2c96464af72385874b12dcedef864e663edb40491b3e46db1985df7af63c38518760434efb04afe414624840adb295f8bba4f096ad95a249cd8febd5e7c72a13af707f40d84f8610eda217687f5ec274aaaadb5e364fe96a3577753881dffc2b590a3b96e0faec5dddeb45b708c16703e22cd6e75775d3234cda997cad3c7af2f5419fbc86e35c9684746d9fe18610372a1b147d98eda92d47540803b97e5bc6ef1b0634cc60f01da58219b597bc1c82fa97365486a982d5db3d6783b99d9f2c89a0e413787a3ff0c35a5b5f476807858cb3ebb37d63e8aa9e38d1288ae0fc608ea4f85a0eda80adef6642ba13d7d90b0dee8fabd2685f823a09eaa44697a73f5852ff81dd7d1801f5bfd64d2f0b62646a768dc013a9b2ec89fbb7d3c6c554f420f0eaca922e8a0785a020f7d880436d2fc4d7b270b238326ee4b7239e8fdaec643a2db5dac3c57cbd99edbf484f9632436fa5caa64c27ebd6da45c2b4eb5dbc60eb294c197171abe273e845284eedc1fda26048baf856cd5f39aba15e770d84038ebc054fe658579d03f3786a94f04e9b15e7c339b3a79fbdf8376ff9d5511f011f9ccec53053b681e463f004d0053633fe4150f68e1f1724d3109b320eba9fa233598379a9e09d47de8f713921f686ed06c5bde1e3f408abaf0f9680027c2b116f92e2041ad2ac545cfaf5c522a76556b054a115247950b3b490e1193bbc13ca9946f0b861d341a8bcef24b2cfedc1a3095b6fc16827b8d8c267c3b027a7f1dcbef82b584d29542fe185cc7ce0ddb8d10c2e97971273026551fb112999f8978e7c42660570d2edb19dfcc83eac568a07edda5ba65cf82dab20678e11133b4c9ac3ce30a412a4803ea0265c43e310e8fe64e0540efc2ef083e2bb80ea43d92b077330952502666e737dcc38812c03e661fd4b909ac78f1565ccd3064a429bce5d353005d675585a6b89a83a447ba7d28d49b65a64482337b5e951fd27b234d2f86546c814c55f33c3d0e44e2079feb758ecae6a8de01eefd50b1e477f2ec6be1da76744662d6384d77c2bed0dae9ac522c66b5983fb1de40cd0efc4602b75007b211a4f6dae464cc4de66a0ae21d367d1450afe70bded564daa3c1ff7f49286523375c0abf34666241a2178595ddbdae90895eebedd743b19f46ef533ec8a704288a2d352c59ad5bcb39298d399b3c16b9aca7c8e1d4175a8df58b690027d2f199111a396a57654598cb820066bddca49c9d82125a130aef083980b36d46ad47d538a7e3ac97b90258e93efa32adb2501fccda06f9820bdea57c14460be34b3e89d772f1f3e80a12122dfab9ab5d11a8ecd73b831e4c71b1c5212143150d9a17b1de7b3c7175742cb848f6cc806a1dfecdb145a633ee3d108e850c56ebcb94a4ca2201f94787bdfb868ee8ea767b7332d864ee864e0cccb158d832c51b0494a97dede10401a8f92298218b348e66563c2bafa0d0c9b027364fed6197b798a362e4e4be9c0d8d18e491463e05a58cd4e45135994e956d06de6fe48b4ef904af4395012a0d86433ec528280e4ad75018ff42d5ddee0b170a003ab5138a7f5bafcc139b8522fc7e43b8b24dc1cce7d6cc6e42b760701c16704048f6c956d13b7807de413df7dbdc94e8f8013b1885618ffd1e7658a14296da097389279b428b81609363ffaebb45e9ca997d02f4b9343ff19cde53f0e08ea3a35b968aa86329b2da123157066e937e978fd63aa5502eeafac91898064eb6dbd15a13099bb34a5ddf064ca02fec6c1c3a2459c0fe516ec45a815101c050fa845307e65a4fe103f3b46e48ec851fc1df9e9a56183e10d88163ecf648ace9ed6b3db1580a68fd8e84c3b9d39dc467b687f7349baaa2a1e5f2589238ee62ed99dbdb3429adac5828837c42559a6d1a4845c550511f10d544a189b36695c3344cff8e7f3df0c33d0f9e5a6a5fabb50f63b87a98714feddbaaec483adc445000d1da4972fefd12423aeae293294121e02c3d387c0b21aded89bf8411882d3dc73931cd267c338f86bbc267fa41c798335a715e55d600dd344c9bb9f1b8a43f98c2ee4ce02bd63e84c2f3f8fa782d2a7c73406db3260143fdb65aec2731493ad7f43e9eee058f0063fc9e4d9ecf6c1509348d4d716fcf75db7b2f630211862c2e2f82a70e637f5eeecaaab759c2643c4436adfa233d108fce2a32c6bfa939f9b367621037887abcc39bfb71b0ea9b2a135e9d1d0bddf099d6d839ff092420b038a690d104c05b71a1c9d47105dc6f38ef252b1295be59aeefa5365470199adc069f21f11e229d27617e49df0e3fa5d123066ba1b390a35f143f3c28472a0e34a98e3744aa7c340cac9b32aee770c269597a3307b826f0105467533bad1a9738c49185ea515fd01c44a21a89330499e803454bcd6c4f91323143b7257ceb2036e56086c93e6f08b8c4eb4af8b7dec8302e0024a64d9decbe527fb350df0bb997419b98f869f45f3c8500b5dcbd85178bd80a53ba546cad42468f57b73686dabae7b350cdc3b04dfc2e7b950122049a22cf2aea75e6f8760d3f4f410eb7eb4c5395a9eb70a4a0dc8c06c6b6d520d49c0393e7bd3a140fdaef82b6ff72d7e18c17ccde04556df6bc6185fc321ee0abd15dd84503f397852d08cbf93787116f4d70956de92c19ed2073f4cbb080b70ead8fa7bb1bad0a19e9554468b215c50742bccaecd030a56cd02ab1a41d83c77267b17f7fdb62e3fd6a9bf9ac403b4a6d758d7aadeb269cc8ed99577dcd200ce40f1be6a82b2eb60570e4b12fc1171f6f58269c7015742a15e9bbd99e2b7b3d3e9e5757d06166ef48862ead97870d1b0414bdbc6aac059eb00e81e4b9886e722acc0a60a9c69001fdc32ddef6f0bf1f400ee729b1a728b40d0b42ec1226f83425a474acccb71d060b65754f240e172ec00cd2083905ebee16fd7bb4ebf5763305a7683f4f06c3a0d2d2ef7a634922538143a92cb830de097632af0c908cd7d0e491a33d81496b908f505387392bcc761528574f29a6f02d1e65ed18192303ee25ff10ddb0552f2491f6304b781442cb6452352cb18766aec168f998dfbf907f6389eb63a91493be71a24f9a63669771dc7c01c787fc4dd0a03d4a6efbdc74ff9e60c20bd32e0e702681e9a08866b46635d306fa37fccb3a6e40381ed246a07f136d8193fb7a09d46c964e1f9113ba42c3cbc46eaa1e6a66b22dec290862216403a7f122c99fd79fefc029cb18de459148b59e71ec44a3964eb93536c34d1ff1cf4c0382b9dd376330f2333c76e0839aa9ac7c3a690f8b78901c23854197b5d8a53b2c92a2c29eac69d2ba9cd1a056526996215e77c1974cea7e99cc226d74a18c7fa22ed2e1ef22a3cdaf62d4eb45ce4836f6cac328bfa8892a435a11c1a595d0a78a06b96c9b09c5f17f46635a63908f55c6161cdca9f0cafa5c327e692213edc8924149c572183c30e781f09a8075cfdf539c85542e157cd8cc32d0adfffd8e131b930eb8df438f9d989b0a31a33c58ccd8765b18b31953691b0da73d83a31d046e58a91527c3651c3bf8abbed6fdb9ac22fc65523fc3b4b636562cc1c3cecb686a42e9e423ce28ba7a9a6ce30af85fec737f26f31128658109a679d370824d7c57b075b697a2bb381f7fc7520b0b5acedd2546587633cc8ee75f036c3849c3cbd76f0fdcbb24b89258304ccb404589c89614e6b4707e20c848139ed90023037d2aea3d7038a849bcf0274c53a69a6e402e443497e80ff056ccabd06f9f533ffb92731296f54b368d6298610f39b3fbd0b61d47b104d6b6536cfafc649e869128b849d4fc825f6cc12eda98813e99cc29fc479ee3ee1500632ce0b48d38a4a573f254533fad5f36f98176e9f5d19355e018aca8839955113575865b42b14d4da0bd9e9555160d2467d5f32b220cea8d0ca40871f1ef7af5bf7edef57c3513f6f18a6147693dc550bddc52a552e04597cdc15a9342fe5368410320db5d8397aef9dc442995019688e36540f5e897ba9eb24d944e717983ba4f9945942a18d1081e06e6dd7c5ecd4a7b74bbf7478cbc6ee2d602ad0cb4379b468315f57143e3ddf597a01b45f97872aa273c4c8014c68b6c154e8f2fa93ad9f24db6922e64f4d824c257e0df109e1f9a83ac1be35d8dcf5788634e86eb28b27573b5c0bd8c3778dc75ad05e64f52042e57e090ca252b6955850dcf35a18f9b3986046450bcb784f753e9b8198a33153349900a3bafbd9858539beab05e408dc97604ac06c79e0f9dba5e495a9a7eeb274e58fb217a66b566d9ef5009ad8aa638ca91406e8f5bb86838026ab895716ebe5627ae830e90366a61fb58e22db2163486889fd65d1a3b2c23c28004ae28b13b6fef2e68afb89a1ae67aed18860de17c65ed581034542a8ab1db61a929784e250ecf4c1a420a282ae3af32a79ed15ecc2992c27b34e0663e805324d10446d500f1c4c7e901dce4ab31ace3415d87fa0439e79585fa86189b48b0fa1a24d42bc86d176e94c66888f48f7cda1d69d19d88118e4f804162488f1b898f522bb904f7001c4d27787f37aa27abdfa50c37a3d2945cb00db7f15086c4d25eb7fe1f285ce3177a843065ae613ce4e6b0a8c94a6aeb5807517cf4e12716602205275a549bfd81d34cfa1bb37166cea272845abc5de050ce8c8e62bbec663727e69643223e9454cc6b472fe958de9be26835b8c7a0a5b1e0366555a7ded8b2fe369dee5bb60f26f83b23a4bd211eaa85d30c24400acc43e92411a0becec4f29731812fb5ce8f081462cbaee3e8c970d57a3f271309f9772bab7488d680893f2d7fa0cd932569669daf763ccf2281576d192e640ece60532b84e9a7394b3a444ff4307ff252077c9b42bf6dee1c294b3c95bfe9d2bbeb61ff6e83c309f56c75d5498de7ba2908e89f4e838c0425db24e17ca25ce66af26fed00b53e196a5c4b68e86b277ba003c6fa62dc15e37c0d7993ce2d88fce2459afd3a8092a543714a39166ca1862682e7190fe134e11710e664aa46a051b35a12f3c0c0bcc8efd53a9b7ed3d7f92b83d2d87fda3cfa7c808eb7db7efbd6e7cce2c0cc0281bfb6cc6cd011e250c9f785dd30b0dd642028e6be79add0f35e231adf90874c588d5f98e5e6bae2fd7e2c227009842cda632b364248657b79a75f08eb2aa746188028be07771dfcccf509037ecd672008c08cec4b632b4a529328e7172f96ed43a6fbc955a83298cf92364f66284d50650dd1bac11d5fd36861e970e72745a59cbae6347b7ff69855f997e126a18914858769b3f38bf917cb916fd7c8d3cc50bd2183fa71940e754022c56618a3638fe37e69801290c7b1d93966dcf328fe5ae2dcb76b158838d337e5ae63c155f0daf7a48ba0ef86e0e6d28f289dd8419838ad4b6c12ac9dbfd1453ca1f2b1d2bd2165961388e1ccb33221542e9e1a06e9149b154c60cbf3f19577968a2aa7ffa038393b55ee78465dafbcdc1440b457cd6bdccbf897acbf8ee03edd8ec4042dd402c12a23ec3c8184c47c906dc8609e7d499233efc180d80ee09c0f230ead117134d4a946b71664a4d1060cfdf078b194e7ac1841481d1eca10fd1be90669281f88371d25c2140d73323a2d06447c90d50a48bcc2fb159b90c3fa0ec4a4e8bda7b5dc1137d98736472b37e8d2f2c2f0aad73dddbb1cea88ee72f146cfa4bd155534568dba3b165afee87207eff2f831648f81bb4e2fa962bfb1d4fcc20a51898d405221ad5e067d1477d2090b1c9b8b40a41286db1addf6d79341decc09aa600fcfb1232f33788a1042444ed35aab75109ebba79a7f6a3fdb5898dbe03e9af60b2f518ed3d907a25c14066af9e851ba4d34345f19afc3ae2205b059dc8b98bff197a84c58f116629d1ad7fd52c1888857f8830fc47121b0a29ab893eb243579c0d3bdd1beac647d7217185de0f719ab4e520f40d59139f303a5928bd9c1f2a553894a53ce3566825009cfc326e2b32e35b25fa2c09c84c5c26065a6f7340854810c65206468c076981e7a9b345337ec345df855d41398694a73b54af6b88d7cae3d50fd55ac02b5d95d8c61b108efaf824c9f5ed8502a158c4122a5cc708dc9933612bd7496a2e091c0cf83515fad979f89738fc16aee92deccdaf7df1ee4abbf0fe39ad387b1408b6d5246d26a728149ccc2f4f45910650f0c0903c2248c57742520d0670425c4895eac9cff99e7d654a16af5ce6f5eb87426b4723eeacf16a03128384fb5f6d1f645e5c4720ddbbbaf3f65ae9c52f629a018b5cfd9f9087adb670a3de6c4f09c53366774c4d419b1cb577c2dbda7366eb8cbb9f08a03e1efe736f9f4cd8976cba10555e7d63b450188b9c1a5b274f12037041fac734c9b281a8c892cc1e27785cd4c3a64bc33209e6785fbb1cec06a3d1036ca165c752077c8a9fda1ee36ec233c6e20b32d172e774a728a0753b8a27f67259ae26f37464dd931a5942869bc3dc58a8cb9af59bdc352f8e63ae4fcc06df5128d19ac95ac1a522829da45cee167727ac82ba95fb0655e8b0c2eb2300bb8d01d0aa372359c872303fcc1cf8764f726dc321b70b8e2947c8b5571f4b5f998fd84cdb4eb819995013cc11e06ca1adf3956a349005b4006738081d614a8bcdd6c1a914b51b2cd7c99217db477eeb455116fc8dae427e38fdb525e9d6225b03d12e4e42007e087be92ccbd4dccb9f6de3230f4f8c86d90a1825b0f1e7a5f91cc69325031ee430944309ae691382807bfb46c5c4778837d1c13976b367351857912e4406fbd137118cee469551e0066265abca75e75462f829f2a5ef3e0ddbe251cdcf1f683720c4ba0f68d2e855cb2558262656c924beaea5748e706e025c9f7c88567913d169c6264099f546fa691e3e386f1ceedb72edc5de8652566dd6c9b89e4b29db256eae2088b15829e1d5e12321e52089ff7e2da2b37c026004af121fea120a873260ada5488aad172434fd8905ca2d3101213bbc753264fb8b5e23f5bffd980ac127782cc3f0b7a423f141ad48051a9e35f244ac0d1bd89d302937c052b51678f30910550a8f9017dcca6acc938889671a5893c00dbf37c24ba1f86fbd3635546905689776e495dbbf1eda96e39c041effc78341deb800025207a8b0cf4cd517c5e61846c84dd8b59441bb4e6d2fd188120886950adb66c5e4308a27e51ef3d7ad9067eea79a54d1fbd16b2e88bc07f75539d726fb602fc1b69dd80da6bd8c88ca571f04f4d4e5e28d40678475836a502b030c6267bc3f0d4f72e5f6ad12c8acd08ed75ac15a56b09f53eab98aa0458a712b00e0faec953b71c83ae81b84808d6964a5b20237a2f47e0a3087637c01d69c96f88a6d24dd1b28aaf4dbe84a1d5f125374c1844fce713ba0dadd2bd355ca4564a0d906809126539ea30dbec99a8695d74367a097ca9a678ceeb1bc3a1f0fd015adae98db3e4f0c6056bbc25018903aabd9e4ecc9fc57d4bd597fb1e4cd5c0a45eb36383f28f099c76daf42037759ade1dca06f3c9f365c9cacffcf8148e6af80da31480bf79a6998b4e55a0cf1b64c3114a6826c75247fc37f9018c3402a6f345795bff6fd4ec3483a802593220f0d0c21bd80fd145c921831c5942375928ce8c58828f85851057c50b9f394a6a078406a81a0c9f7aa6794571100f9a0cad972e61aa2f433ad06a356d915109e97ef60ec0e27c8ff2ca174a09d627a0ffea4501344a1baceba12710e127b62b95675b728e56fd94c93222a7b0a771b6b13676cccc54275276da404c28a4d5f2886c5f724f32de3c89ff9ac892cce2ac197de1730778d1aa18124ac5ea244db362737ff470c1b20a60f200911bb256a743b73e275e7d68aaa0d2e7481594f2468","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
