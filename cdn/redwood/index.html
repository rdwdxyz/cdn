<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcb7d4a54f3915ed47860f02f0524a634d561cb316fe9335d57690f205261e1b23a7fed3ae3ec703dc6a978e0f400f5c173af71e8e363aacfcb4e7ff3b2d6da3e16810458252238340149925bfa8aed0a52e42f8c2459c19598521dbcb0800417ddf82678ffaf73db63d6f339481eec7415dd794acf52ce4f9efe0bd58898a45821c673b1b59ab0189c1c424065a6e365227c3b18dae746c2dd6e7e64e3b6a5a556a0560a9c9e09fcc64c3e56681fe62f77d4b79d73c10a2e424e8d6e7ea86db3fb93aed5c59c69ac0c9b56b7850eae0b432de843881cc2e58de0f4a984242115fb7b67742b0c54d797fa1c6ee314e202fdfab9cce535067ec9247cdf81fdc0c42cc86d8478f8614114c738f39b9908d3f8f0a11d4f0c9b366a2855a0df18d21f0cdda5b5e779a05e1659808b6dc5e91c76ec8e2a7291daa59aab2b72fc492b3864c2caf2a874b57cf6d14cc6da4986c18a93e182027d01ebe14fd7b54ff91f0ea2602fbb3386cf0241d8acf97529afa0c755a25d4f7787b3028b58f1c7ef89163a635aa847b183940d81e83e398c782021a6dc4a49031bcba439c05641bea9cc4ef9032e07a5a89d683bf1b87abe3c6fb1214f52e5d0f9cf1be2fbaf940f0b2a6ce889b9acbf387cfa459d440dbef600203b7b1e8d07897bfd88530a4ad138ce0c6a111b39dcb7212b1814b7898755a3e9360e3bc2fe52f45572bf626ad78cb02d626245ade5cfd6b889a2a04b7ab81177e4f010f1ddad8124fb499aa693f1b7451bd9b61ced75825dfb90ecbbef9ef5f4e5ee3ade426df2a4698123c6c15ed9e96242f00a5cd8e1e36c0d9771b6df88afeb91e3cd3c370d9a3d507bbecc78edbcaa20980a4464aadf994572eeae1a1b71f029a3868e08c3ae18abff267db56fe75b21a0d25d179c1b1979fca0513f2235ffa728344aeb62bf6172f1574c70f08173065991293e436765d802ee9de567c516ca301a7172cf6baf5fdc486cac766458f8f936085a9c1cb2425a7e3b0bb421797549aacf3aeb23857931a689e0538014c39933f8a1d397f2bb21442ee14688e6efe78e8ea619a0a4d86da0971f4061d5fd9579e2e320596cf2b1b7097a7d16e1990687e56c6f0bdde279f74afff5b1b980d0452629a6f56b55b58147855ba3e98b6b34d16ea6610238b50110c16a30702f1eb0706391303870c0a6fc9920ea7fbfc6ee5619d483e4d1f5bf828769f97454d2030fd99935da9038910e48d768587379746aacfafb59e048e8894b0c7ba326f4e3c2521eb19de61acf116e77472732ccc55d2b873d2fe99f95677a6d57827559b4968a3e0a37dec613bb40aea60e6bdbab646245c8d8e145e4525239a1ea6760c0245ed950fced1a866e9cdb41089ea98b37c1fdb66d16e38565c2cba2cd89acfc78670a872a571c4c72aaf68eeef66b3ec8c3dfd1e96e42b7cc13ffc171e44d45b76e7053865acb6958e7f529f5e66fb8e73d5c0621a14f6d89b9156e536bb90a0327b887c50b19a67960994ef5505d596206c43d06257538cfdb7a7759323680b53c77e9100191299d88395f2c0eb8a258563909df357c7fea7f1641f2f0a24408e4c35d731b724fe1f25c73294fbcacf191fbc0118020e00ef533d9d249c0232874b3e61c09b895eb58256fd0a685080ad36e07ed367a84c867d5badaed10d5094b785130a931e2af8a2b30cde90caa799de1748f5343ea2ab0db86ff17af5a56fcf142529d44cf155f2045e581ae81df085bc1ca28760a00a43b4ca9358c0fb09c4ac711717e880098c36aba5d0d4fc5e22c0362d81f92ff3955c861da66f2f87bac144140a6e11ad65e52e183a4f5ed9df8bc8d6cc465c4d22169c772763291bccfa5d6ad862cbe7e37762f9a21e717e46512df5c1437a4cada67d3ea0190581fe334d3523bbe6121d4b781e76bddfd965bbdcd9ab36c93358218b87f5255d3c52d7783cf15baea4f8f0298c7d6e57c64fa1c69db40fcacc7231c399b48538d125226f3f1f9f9fa7b56b63bd4b5419552d28936cb1e71d2a638ba1765ffcc548bf2f8aea01ea522f7806f76ccbd841721ba82c99394458fbfbf43c98285cfcca1db5b8554a016d29aa957a32e50a5e63dd9d0d9e7839beb57386616a97ce313b40d169c5d54cb1fd34d2b2711fd5fec468c474d48da0648b6c43583ff809b7c406ef7687964b768776a8b8673a223fb2d2d1053eb8aa63ecf4095dac7fe20bdc9a79144569393fb50ffafc0ab76471b451eced78c1d35fa37c0d25f90499f71d143b0df99b03c2e99a3cce3a6ca05a8dba3605c17d3a7c54a54e271a4dceced9e3f7f7b0e047646e58b3b7bbab177a9f9ccfea19c838693a19f1693382e410ef94cdeb05e4c33574ac7efac1e3c8d522b94301b0d0f00761b0423f33eb5e41975811d934b2f27187077c95e68d050c3f12e9e7826d4b7c8bba4debe568b9707a52ecb5688ce3624ebf6903c80c2e3d4f6a12842bd4f732ef17257afe85e1d3ee8193cc7b0305c464d7952d6c69a666549cb074c0f4489cc7fe85c23820d5f96da7f7491fd033300075176cca5d3e4fa8bc2a76de80bb0ee85e72b41da523c2a5276e4c56ee3accc1fe16b3924ed44e4572b7bff99f19fcb9bb0b2830c792a96178a19af319e3ea6d25221cfd73b03a1329be3b5161dc1c9a8035f05b72ca543b51c6e40295150265002bf24c829753d694dc9c3aa0a54f3418c0856e7ffd2b9c011206cf3253c46f330086c9a1f51ab57782818e6c857e8642cca2aae07bd0fcadac755a89bfbe5672bec6acade4bcd8ebd65e274cf08b457e3d5d27a8eba195ab97eee1cc0481c132a63b667c039317c5acac3aebbfc59acb6f440d5370c39a24733bb444c188ced6772f599bc2ec5e435fd88fc0a53e1ca08f469ba5a597ba902b474747d486567a609f0dfac1e2b2e2f0bed016cfd2ce9dc604a14fa627215ee0a236c824be479e78310c3b0a6665a26e185d481fb82df567037a3c01e8c4fabf8208729fccbe61e7d0a898c7066e243df75e62f9c0a332c3cd6a7e6de3686cb721e2cb03f9a5b92c7f6b7b8801202bd941cb5fe018a9a25ab50eca4f939107826dd007c1a3465e3e955042226e3a9bead29f3256fa6de4cd08f139cb836ed736cb1b24c5aa2b22009772be4334362e71394b0e5ec25c19a954704815cda1de35bcc2da21b64d95b2c0f3598b8d20788fe7a542cd50a647f2943cbcd966a9fc5af9340a79772337921ff6ffece416763bb715c70e9a4298bcdfddcdb015014ce2314596d743d4809ff1ab9b7e42d7105ea32d9be76260528d84f51f7a4ff33d5465ab9b5d29b6c1b1d881ad55fd6a7e72090ca9b6cba3a2b637dce45b2bf338e0dd9860f8d1952d4fbc90ba8be77148761966e9c2cfc0d23dcaebe2f788fcde65a3d1332b1d692b539a84a3578527450e16f52b5a4bdc5a4342da09062ce1f085b9d24429cae134a26aaadbff16cb1708aafd1d2b6be7e0bbed5e349c0df1fc1fb2226272ab4145018cac38622dd5514e13e65cf54f9318c453982504c2d5b1f6c10b9d14d0b90bf103e35f7afcd9dc9bbb8c4ee7e3ef883f37d7f6a4cee79929fc6ab17f23062776a10d95f0e83118b702556bdb21ac1214d45620bd69a9e92bf6cc73d7af67d427193516a187bd4614130d3ed07603004b0b2520b08f5888a7055d2227e11426abd66e746b9aa6dfe822ec3b9d66f73ceb12d054243209a2f6362c08e76faf2863f337cc8eda9739d4afebc3860f1d5ecd71b0eb09de43ac11d86653e6701262bf2280ea7a8890c4ee3b689e7a867aa8b9371cb905e6ce8388be1825af7e4efc93f92d8a8dfcb7dc506d23fd7211e412c40452b9fb3a8241d65c0a5335973384b273a4c2906bb64b5a43aaeba646f9d571c344cff4d1d08335c1c7eb4322b052efa51df2de95b671434429954a3d49b91f4a25a618646bcd582b0e166847b8ca633229d6107b538084108f869eec878fb0d4c8a957752850d32c68f8cfc598977efd30e8201bb1c117e409206e5ecbc71d3fbc2c89c546ba85da2c25d5f62cc0eaa2de47c8bf79b812bbfcd3a6fc36498d592a119588136e2fb988c93ebfac5809bbac1399d0b095ae9f69681a1fe0b6ca0c567ed8652f808f48eb0074f491da0fb3710792138424795f6ae035494f0bcbe768a2acb15e25bd03a8f30633543f68d0fc25ffad5e40d5437a26bc0c91f42d67caf3ea0b9e72bb8b00b2257991200dbeebcc0fe55ff4a97cba0c32e40ed725253ffe631f00ae9fe76891e254d82f87f30dfc63ca676e17b7f853bd748c7f7bf663025fb1e352fdaee6e4797b143cd3dba5e3519e39d8368445637ee36cee32594d250b1906112c17754318ab29db5911e39b370ec3dc1f7edff368184564dc35c4f6b1c8f1d392ef58f67f3c6e417a6d258d541c2bfd64a7acd76753cd3f908e80bcb3864b45780f8f5461e4f728c7935e5633dc55ff57d77ed0fdaae13090300d403ab9b5d5eb878f4a760f9075a2f402fe5b6af2cdcdbf50cfcc7e7200741ce8eeeeaa8fe7545f722b3a20ce5e3b802d3677d3c5d9981c11a9b5eacfc41b3adee0d00825599b8fca968599d9890693c56b63e281c4cb2959e2d0ee796d700c79c5e1c1c758c1c3a2dcceb5c3cc0e4ebda04ddc2d46655bfbb597f5a1cd6295f0e0360f6809b0d342ece5a9ff2f4d6537fb5601057f635c5d6e374d29c7a8dfb48733d19e55b23b898974d10273e49940eae204458ebf10cd178ff893d6ec4bb4fd83d05d791a41de31d5c6a543f585b35cd084d3d8e2045402dd43054cbf44245b8eade74f796e20242119e7379530fff0a5ea7af51eb97913fc92943d0d7a8a47a5f88263681d4cbd7a9314044f3b8774006fedd537eedfb6aeac4dbf485e712c373a754ca8360fe50c2fdf4a51dd57f2b94a7b131a45f37543aa549833cd66a80e80baac093665ccdf94f2fcf80dd220a3700a3762c3cdef63255853342a40ea05ebc2513b0fac2666eebc48e72f842d9623f4aba14373c4f15d7c7bde347313e54cf83256cdaef197fa9dee577a1760278a9bde57ed0fb19be940b6104812f3eb89a7b85a9d95d86c413f498bb6b7f829f47b7c45605a7073e01d2df64a9378a415e6013c7c622b48a9421f7f1ddf35c04e9af4992f5b5c06d80fcdab25b4c213ab2c01b9ac76309104531dd43fb69f46274af1883e43c519f63f5f7ed635894a2cfca2884b4c0bb46d745d1b610973811103f7480fe44bc01a017241d31615451149bf54dbe3dffb37685b668d312d9bd1b00e454d5c908bb1c72f67c9eed88b7353bcde1b3a26ae09554ccc31a96d0a3f055ceb74ae2b9c229b6792aefc7114c717e89d64edf671587baac74933d1bbfb8cc5bdc483774386b8388563249a9e10ab4adf16c0b11b55aefc5e1e26487284c19bdee6287179b51cdaa641b7c4bd0c7f247df9c3a20f3a724667b8191c68e8156c51bb00d52fecd3238dce2da8207fefe3956b039b3541a20cf5b3c1433a6502528e85d69ca4fb3536f62724f7b449b5bd9fafa48ed4d79f5f9d60f578dd6aa485d8a61c9f800755d8c1acc901fe3905edf0142e9683cc72077d835f3b2e48ea99bbe7edaa16ecc2e1a09c2b608fe059fb518092b494f099fdbf2f48b3740e8c4b6102911c32ac1a48089e3e29c3115e7a8de50a674b9e212a71041844e76cc00775ba0c89bc5ba48c9a85aa3c69627ab8cad9ece1a3481087b7ea72abf1bc95f4873be2789a6fccace133c889f5e3c7bb235c2a4f5e4ca2861ecafca73b7e6a39d13be5219155c741a73439a9ef84c40a09e8ae502c4a1fc781056a351c80fe0aeba4e8923645e0b54ac52a3f56e91c0575fc1b22128c4fee4fb97c9dfe029c43a7b43f2db6b63e9162d2a9830be44157c099f9bc4c4e36307bc6cbe9f1c965d345ca760924bf9eca760b656f296e9ac1ada8c258ffe7eff6d5bd5f299cacbc1f6abe1bba2a8f1a11895913bbbb1f4dc681259569e4d3aef97ce332fc78b2fa4b85d87404d961c9cdc738884fa65b7941e0975cd6e271c8af0accdb1e0c0e83ea7d4afa0664406b496faff4a55ce2163715aca4201efc2f6e64705a78d4cdf40c48d1826fe1abdec8917a932751b90dfa32bd1b48138441c9404434997711751434300a8a9f1a9a8fa98f96c4c3f9526c2896feb8dd84bd0639c5f3586c2fe80b7343da7194c3347dfcb2d1a40f50744d67aad8ff406a54e9805b02bcd481589c3a291456ad751bddf8ba37cd5d2c225309611180f7fdb86592179de73c204c4e578f35e3528e7e4f5acdc4289448d52df8e5fd54739ff75dc6dc1b6a5eaed4067c92900652a97f6eefe35cd164354d8ad93a39000c4194cd7b44ef13623b98573d0c7a8519bb2ec20d104b8343de60ac866031616fc031481c86c070cb620d183cf5ab202aaf6a1782d8de3c3de04427dce8ffef1d0f7f0b32b13425e36d352f72f12cdaca6583490bbb8903054fbd2c7410e99402db2c418a0ddd3099f753272b5cf952b5451d906a254954815ff0be27fd53f875483b00e834ad47d8f49302662f94adba5abc5da1dc9617ff769f530ab6f4823f6633d90208c23b804b6ff8d48307688f646617d0f4c5f53ef2c4bcf81176df326b0c3ff5509edd70a9ed94e6c2439784815e76cf79a0f13bdaf5a4f074e2ac12d95c6b9647c2a1663f4db41f2417bccca7081d1257db945658a839dedc32daa9b736f1bf2bdc230b5384487c2048ec8364af9afc7bb2fb38de26a915e87ec8bf216506775aa4e1ce1c7e044729966dc1fb164ff5d0a9e07a90a4c0a803e05e3490dca689f02b36ede2eac82482e09d06c931c938d0da605394129a95928465cfb298050cdc5844a9476e7c350bbff3898c10ca8d982d2f28175d513d83f67c4bc841325765fe299f909a408aaecbaffa6545de58da9c84dd9c18a6af5676a8b953e753d6099ef2c2ea4e803072e372bcd10e3a987a5e68dabd2af7c155efd00fbe6c2e85bafa044404b65dd84bdbe03e4feedf28b3bb6cccb80e32886e2a64f772fcecb74bb76582279e541b231d85303f23b3b49f6dacf4738be7853e6b5ece4bdbc89a1b70e901f16d6b7be6e7d9cca8f7b55d60c6a928ec4d3a2e00f3d250336f7cdb7891106eed2bea10562ecde8d1a0fdf5de6e7a341b7c46c8d1a22daa30e0a9050bcda38a2b4fc8fb6646ad29f628aa80d95b880edc0e30482acfdb37a07abc4b207e9bc6ee2484eb35ae8c082d703471b79fff21c905a723e056be7697c34b0f69a53f260f90c05c91b221f6de52fa6c1eaeaf8334fccb7b7def62d33c5b75c4f45e3bfa4ba60a2518acba4e076bd1a09220e30951a78865c990c491c6520516f821e7d54f60eca42c57cc4b61fcbc94aeeba9fbf3aee5c14f5510a97393aeab97074230f06ebce1334e130ab815b412724a675b7271e4cdb96ed459f28960421df64fcf28c968a1c20cea8e81c17e500a404ba1f6d2526da84223a644eb168ade0ce4309e0ac004ed6b932c97251db09532665889736bb7791508c659ce3314941bf827720f38406746be45d83c738868ae83d144e223ab10e7ff5044197ec54f982cf7ae91b2e454f2d09d031a92ae038a5f83cd7210f7cbb8673c6ade4de1f4e475f827c8b802ed352400afd41e8d48a6881a95183e73d990594d2f1e49cfe1809fb69edb2390b87abe1acabdf331f718332239d5c40414c618e5dba3cea630d7a6a19eccadf679e68a9f060f7ab76677f1bf5b49d2d10b656f9eea80d6973e8573751f17cc99fda1719acae1abc6919ebec6da350be85fd12784c3e8fd98149604b8c75c67cc22dd401b875f1341136c63da980ca458347dc239c901499d39242d9082af4dcce74a6f4c2f5cd8b6110cae9b91852be3b51d9bfa1000feb1aa08a4517f1bfd2087dbc0b0e9e4e2a4611e754619b99316f8d0eb5735aad0f0f7dfc897e8bd9fa194328c772d435d01a6cd3cd255f829fa6c5b0697f2764386a459d136c2ca66d81016ad0d6a46091c51092124ed254427b68a7952e054a2ec085bf3e6895c08db4bb40ee85733a25217bab29cbb4380355b9df630dd71d6341e9d5209ae55a517a36d99af7a5e6a05513d10bb5e7c6fec206fb9c66a874a42129aecdd48cf2b56ef3332cbdbfd99f438b65738b2ebc1101757c428c64cdfb6e3bca4b1a70f7eb8de041ab8a087ca579e11005ff67a4da30ce6b09cb88a153b1026eeaa1e2910495d76cc676f4cb7f7178b8ca248a5772ead6ac82eb2ee4b2c6be563c2771dff15e4b337afc2f6fdbd663f14e63a362b4c1639fe6c473708b8df919b9f9771322d3d4255db7fe3722642a5a0231c77eb80a84af47d5da42e3387fd3b1afbad9bae261108e1d10a8e2999c02629a4012a17adbaf4901e607a02b65c47a172da39e58002c33c185639b29170b360e2fa21cc9ad159b142b0b54e9a73fb05291ab8d92ed6fa96f86e5c59e7ce357c8cb415acb94baa7f7f1ccb439804c7173e39293ef7cc70cdd63e27bc954f3b50e06341a846168c176b33b27c7a29ef22c301aef2c5d66127e1fe1ee605594f36be5f60bf2a33e618e2e49135856a558f1976b3ab0fea8995575062de4175f3863aad0986889a4e40b5bf201eea531a8a119254a6ed40b522083ada812a685b2cfc0e08cea164c2db107041c0e5cb073a4e8a2e7ba7494a7f31269b98ebe28007f90f42274812c580249b90d3bc09bce8fbaab7efb52b73e98c6264d18de4146ff95a98628ea74b3688be864d247340afd43b708cd7925ebacbcf24bc1c76286069951b14e807af4e43024f07bb7e0ef04c13d735ca263f31ae59bef4598e19e630101d1a9077e6274a4e2c718fd84b21cd99428dce9f3b054a6bad9f6e7df75f7de46bd041642e4e829a3ae5b45279b257776427724fde60dee6cb251fcf2d121be351db404a0398cee11fea974a656acb5ccd76903f592712091b368c57c070a4d18d9936c4ad9b18425b4c29eaef7adc047df1d6f12d07964e3337c546855d5b9f04ce34c53ca23798fe4f81bbc82b932a416be9550949f89a57ae66026fbbedcc7cf1f61095def84bc5071d2dd92a4d9d0ceb54e4b76ec5e78c6f40a51a053a27120199ddabe88af2ca65a202455269d60002f16b26c5fa324882069fa16ed49e6b21d6419abab1d7712a0954b63b2720435ba96faf3bac40422d397bc12815e30fe4418b965e6690c97427e2ead7ad26d6704c01a969a151246faa370cdb977386f8044faf3615301c6c4e5083b3d7afdc341372d9384c81e2e38b62f1bdb224704f5469014e0cb24cfb28c5f0a7036633e1a84eef53b620fe1c607a4b52c735a0758f78edf5d1ad1b65de264261c881cae66bed6746abe475d34a1dc25a8faa2641fa940f7b6dcabd12a402adc510f7898efaaad8f1e83946938523a53d3303ee3f4ffe9a48566cea46c4bd300c630d5b691fe86be22d5055e908adad86375b3ee63403ecb7b9d2f7639282635e0d9e51f7244021260ffe75894d7cf46338ef2d6e800db78f17c49121f64635d598dd4db562c6cc4b6bd225e49258537c39b058e46016dd6a549986044b8c1948e757fa1a6d7d3c3f4725a4cddc1b505f0b0b02fb4fbc1de579dafa7a46c2752ae7a1ae26cf1c3f6126b72e5303c17204a1609c506209288f9566133d0b260f7f851e9f46d94c34b987bf48ada1521651a8e6042ee04579cc4ce5d75cc2dfbe9cfbdc8ae070721ab39f541ebcf12d0e867fcd22b1d7bc496e44ed904c2e2ef56f31b04a8fcd62b201084219d2284ce9b5c67a1fcd41f055a05cae0e2db0c39bae8ddfc50b4551b8699eea1db22e00b8b1c0f56986b7ae433429e92433a71af806d143a07fd7f21100550a73d76cc44d0959a612811f0cfadd8e66c93278ae27bb891fbf46177aebfec23f26d70d54319b6a6379b7507aa59394c656d7d2e096d47e8e402e09b116c0d0e83c9614faf8d78b1cf9e35fab110b29c7e52d6a65d89def34f3f1497abeb172b8acc9e2e246f17cc17195078bd1105c4cec321c4a447f50bb1b75fa7c0a5de4f4fc54ae887942618300e0864240f46f5634646b8d42fa8c1b0e056e4b2948bf7f162877fc5f47628e4808668c3abf5a1746bd30284de041a4db496cef1d040668d365c61160b465de659369d4cf2b342048b40682d3aec58adbf4ce494a42baacaf33d74a5e64f23d1511a53278526e376692b5d58f33d79efc91ec8f7cc26e490c3212847efbe9424a0b660589230750de8337b0d3798b1390452eb3a85595d3de4c03c96cbd5af3088b79d3f62aadd93b524a6d551693769759c9bd0011d986d9d483a27b9610af6579990c0e7678cb98bc31e7a9b38837264fc80a7e8442080f160f5eff3b7d88dea2dec97a2102b5e205497bd9b00b340ba522a5c021b20f09a5748d22d6ced48c18fc0ec2e552a6fc4e388c199e28615fc3d3d54591e8c66d1fb7cd6b1a35b5f3fbe308e65450cbc73a8486d61dbe5abf3a2f96c65d82afd51cdebff053dfe14b850c3c9657ab3b521dcb67195bb0679f623fb3c23d7da302dd55ef0799f5826c007a3247c81d0c5008c2c1608c90a5abf1b01602fbee75574c45f9ee7e3a0ffdfad3256842be5899d75730284d9000a330fb030062f8fc3b78b5ecb9ec07e76acd8de93f94da573c4d2c3da3e9750aa29cc20e3440c75b8673686a63af37f39078e2794018711dd446e854e7a28575650a63d4cc934cca5ffb01bc15cc2e1e87eea9f63338ab7a7c7456d52f80b61acf5caa76678595a6917d2c4498868942f7b4421b620db3c25a3b0c38a015296ca33c02693e260bebd59c32c52298858599f76eeb5386d98829f99203a6425bdd4b0b7c613ffdf6a0b2b1b92e3fc4fc757ce82b1dc5a74d937734db875f010e8924f0217ce99b850c2d4112048dc7ebea3f11e39c9c9e7f75edd741f71941aa98a822ca07401b8b52ab4bcc7f93b7d99529eac42740705e04c1882a50abea8485c81a4a5e33d1213b81c2e07eb52590f0fba40a4d713d707c3dda2e15db30ddfb33c281c30f3c7e6b19b074292340a4da6c6e9be88395ba58a672e08e1b0a8c9e9ef5f7d98fff9da475663094b592f3bbe046f63b05ce0006a62c97a2d1187c2eea911b332328cb28a1edabd9dee1e8eb7597baf5618dacf7b60662c95ded4b3807c1c38d56fa08b77edbd1b77eed17180554bf548128ce7ae915b03ffb32b8419e56fa3141aaad0f8e15727c3d1a63d8c5fa8826b5ce8ad3f6f305b8d9900005bccf9c6b282457d32f9cf6e379abbe648ac9a8e03cccc952b5f84d169afb56dfea1ec3781e8ad438780285d36b6d03ca1b76870cf68dbfa3ff15ce7c0b37c646dff629dd953d51d2617530ac90f278ce8091959792325c0163d3095f3228fbb6dfe16ca3a722620364b018c26bad856747c146586ba73c703b2d92e7dfb48da521780877313f658251bbcff02e095d35e35acec9ac8b59e614449eb758a32772157c0e4a64d5b5c722c55c667b9791be610121c5a02f42c1cad971f5266c416dd19162270e41f8fa4dadc90f2826676748f9e040ad3eb823a7f6ae40aaa8a2fa395718973283bc41cc35571a79f65d19cd16bb097556d8855e76198e4c8506d6721b21e96c2a22a9504b7df2d2f5396d90524ce2bcd99d705c3b66204fe39edca367e1b1ab099d0fdfc0218097395863edef32629ea0d92497518f2f2927791138f8ddf6c9b73203d19fdc52440059225ed8aa9ab0edf2f66a2f55e233ceb209ec3cf66a520333513092a51f518de6409a35c4045a94cd696a6a0f86eb32b0dcc2c13e7ec36925432d9c2855ba0c3cf34d3a466d8da19bd25295cf443ba1a7218423f1d89fbbd905dbaec0cd7b24322ea3c9238750282ec8014ce0efe4501d72d9356ea262fd39304787bd79a8923a42369a379504f41647b53dd8ef00dc3ad136668cfc92af2f3345530ac91afb6e38de4a041a8af221cb62703a0831f75426d5ee2f70b5a9be8001d95102a765f4936152878b77f01e91b15136e294975919221187086cfc22b1a8ea10040cee70828ea4de57c4901f0797a7ce9a7654a2e6c9da7b16be5305dc0d0b5e7eeaa41ecc41112bc2534c236c978fd0dadae4262c045c73dbb437e282299f9cfeebdc0e9c5b4b1d4b6c64c88f007d29e1f68ab807c41ceb03ff28bfc6e2b304b7c592662de5ac439e15bd1836647a85ca66c4fb7fd8269b2f6b35cc84a8fdedac32ff5b27b09c514afbcc6d2ddc585218d32ce3bbf11db18cb605d2c6a5a9e61c14563bc7fd3b0ac26dc4a39acf4c40a241b19bd51c9e8ddbc5d8a4d47bc421562db4608b9c8262dfc12ebf270393f6eab92926d5a6fcacf727750a524eecec38f416bfdca471310c162e924674900258b46f147acd2eabc380eb7f34d6b80ad989f2b88b4c1a9cae26047fbae154ce51457a61fca6ca559f7a864646c47dd75bf2ad75acff83eb6bcfa87832a30f59d3ebf0d62fb96d8036a8103e8d8a4ccd757e3ab6f658684a8f12857035a438069b0f156a4120a4971caf540b2a6e008396b9a50e6e3d4359c3e7605fb8a10982ce1866b5462f1217633f31bc41a279b9e07f529eb3355f24cde4a6f8228e5553375665d84d36d1269a99e57441b04f1c9dfdd794ed3a2d2e1270ab0ab4ad5c5e8be4c6da6076b9e554e3b52266ce7cf33375bb541af8c9f6390c481d3b8f80e1363ca338228ccc20bfc66dfdd15982d10546e35f92f5ed12cc920ae7559e07c13c353b6caa5797af93f1837dd05c70186520e16b6795d020e0530d139f3bd2c08096ebcfd0dd8413fffb2857c2e2788f4ec287ed59034fc8fbff542c52164f86d2e48c7f45759f75e6c219bbc178e456b5cab41dd6c902733ca1fd881786810406aaf92ad56b95689acfaaa225fb16654f1afb1b022543dfc6da51476dea36fe3dc8c2f9449cd8f1ffde925beb219d2d417fd713f6b093a31e2c59dacf184443561a1585fe044a83a7d0d5a2c75b1b84069f35f4d5e1c1b06392ef167bbd6fc77fb3731e5007181bf7f886ee161d8c198c86c2c97efb832aaccb0ad9cd8dc86b69a3e1c9ec2df0ca3c472a0b401881baf438424b9d76fabfc83c28f5ae405cee02c8576cb848eaf8bd9a26621036ff784bd9e9422d739676af28acbd93f610dc90954ee6b5f44070e46c835592fdcc7ff474f90a989fffa99ed13ef75b597f631b3b8924ac67fbe4333ba6a9349e553c3e309dd6a6874b1912cdd99f0deb4cf63df46ad8ac7edeb84e989f0bcda8b2fc76b31d43f64a5e278a143863d9776da20820addd1f9a47247cd4142a11a2b635d7d526a1d00c09842dfe5f7564f0b7567416fa2a39204ca4e41b245eb2389c0087142b6f0218a97746a4a7fad22b2a1d743039496edbf5b884f8243a82d5bed89c5e1845e5f1917af4dd4c380c24e9389211771b8213461af942845c0256651d71a51bf9f57aec4a10faf1b6f6f7e6a677357dd94e3b05392f72e465663e835caa4e2abbfa5be59a4e356d4bc6d6f542a3a8d0954ace8586ba0b9244280adabec5b958102960945022e31ee87f2f103764db69f8e095b74fe4d104f82edfeeeebb920f02bfacdc129b0ae59ef9e450473df51ba3d3312319c95b396819bf16f3c5b030a9c90f48ec8c58626eefd7e749f3598c91c41398159887a9863a889c4c2cfc1630ab238b219969f6318ee3839dc9a70c3672dc45083ca6e26fb65d853553bf78d412d3185cf9e639b7127a0e177df1525f915e1ea527c2103dfa09186ae2de43a349ebe1cfa792c8fb3a126d63580b1240a03b697c7d5d511186474415e50d619693c00178844a694835c72e74bf51a49c87fa3b91e275d38899b0d07484eaa8de3265e3bde6704ec08a92f2e032cd64c8009c360f1d3f5bc9a4f00be44cd0bdcc43d97176f7eca91a95f3505760ba91ce6a5f2bab1d7717b05bf64e9121f4682b183c718a4a965ca7b388f93fc36e5ece011d6e460823cbceb9d5b3151868a2e1d537a343bd31b471540ae4880e63f4eb547a6234782561cf1752aedee248ecc1c4697995a30b4e10069354146cccf2298708dd0c76aafafc37c9669075bf0a4c18ebda432232ea59d1982e680508abb04b5d158458c3a72c2831dc56302fd7f0981b9efb9f29f29e8d78cbc3b66b8d990225d23f5bc96f6224577d7ac241ca175fbbc498b93ce79e0133492597f524e47e964972b5738a3553f5f082a63bc96d9f19b97225dfaf116fc8940ccbaa7213c7c611fb70eb6a74ba2275a015831837066e741e8cd7ca8fe8724bfb4040fc44d053c9d52f557c2fb0566cf8f3ec9a48b163b435cb4fb8196a83a6a42c80933c797186a659baa1e8f01a2f7eb6b386d6f27ac957e7aa56704d6421d013553fbc0daa47c16b1111ad315d75c17a5103dd7dc624d0b5e19a6e46b1f5034714bec06a92ef23602a2301031ef1bbfaa081cd9d022ee2c3b1edc93f614022851666d82cd20a397326fcfd8d481f2fe9fc48818cf8587b7d465c8ce3ed78cef37431866f7e4c6d44e37607f141d9bec1428f87186d6a827bb0b6a30a60de2fffbadbc949fafff46c638ecb2a1fc4283da533d2080595450c2f957775151904f72dc2b932c524f15ed4ed2a46367a1f0868fc3bd6fdfe945b78cf4a4915459af86772af15443492bfd1ef1639f92786185dc68bf6b74be939e7247f80679b1a8c36ae28e4413e13540b925d230712197318502c908752c7e37ab2ba7f9105534c95911f6f604b3b72a8b20536d8227c355d3d5d15339af0ca2e47df566b4e84f96c6197a2c49799e41e6906bfdb407b4e2c6b59d921b1b4c4e06c59228454779ecb2c3bcbacbe1b152e8ca52f7be0dc333956f84474cf0de5f4f219da5f5d9a71e6b8ee35871b3ec3720095c535fe6777c5bc495398b3722eff09cc8371fb604ef13acf0108af3f67d0e41d515727ba7ab4339d71c6bd023abb25140cb8ab8d6e27f98d62552e9cd65560c13febcbe147f1fe24e0432cdcd7bfb54fd2f7fe5b324f6995b5c778f260aec4b1d3c01c2da8afb631f5b8d0cd12d5a110391f862982429cd7b600ad35733069bd073ca54d330ad56d3dacb7ac3d9cb3742384fb305cdeabc0fc0e7ba48a3f175158dd1f57a4b5b3f18e53ff126e146758b058cffd7ba0be30ca42d8c8b254454033c0ffb23625efba4a41de8251ad96b8dc8e5ae04f4860a90bdeb6796913d69d55e19d1e84a2540f44524da9a36ffb75fa6f159fc99f35fb2fe76903d068986e6aed744a8f317bce7e7cab6265cf924b1b7f0ed09cab37034062070a1ac7348149319b11e198a5f5dbd292e442fa5b23407a8fd48aa74f09c75a4a8b34fba6ea973907659a61b8598e57740ef2ad0c801e5e350dd625c2cc715b458027690e94296f8e60e6682e8fc783a3a26b3186b2df4e0a741e16be76017cd4576a9ba6825f8f15e33832688b6c2603ec26e478c3cfc2f882518c690ec42a6a9198885c84e00b41f4c72d7bcbba2d943a320c25ee7e65079d822e94987ad74bbe7b0c3c6b634269aac389f8f08fc12d6cb11c81b9cfd270e0461035bb8da738f0e5b50455dc5db60f8642f785984f1aefc7239e73146b2c5bcc9b7e9306c986b755631757d3554991fb2517409ca51340ece5727127f31fee8ea2804a180d7fcaddae776cff62956e2cfe9053aaa3825f20b0bdfaa0f1a91f39743b350e82b25b464e07805ee54e3cbfe2a25517a6c19eff18f3972e8ad75eee72717be973583c5f1c99bf8bcbeb199db1690fba7a0ac0a25f569e5a653fc61cb5a4a602c07c1af20081efcf4d6157cb0c1adf1b4cd54c4be2e0cecec352c160ab100b8d54f700f8a88c55636bfbece83517a9d33e669f8a4df6bfcf6ebe044a702603fa2f91f5489943f9cb138bc94f0866bd879738172e6e3a1b4a7b177f7d0b569f2cada2f12d6cfba2eb24766860817924145b626088be53eb8310cba8f7a0080e07cec906061d266274586d9686c9210a8e3083e3441a71a402f0ea9e9033790e9751250a5eeeae28049ef82eb42769a687181fe76fa0c96fb06ab4bb9fda40013538cebc04a1ee2dc5c4720e6140eb03eb84fae521123a2f8f8d688d86fa475267875aea909315c659ff3067905bdeacca2f5798c7f29923d14551d9429767df15e31b7e6bcf90ef9854abb34f73006fe04a6c8f80395652644d7f332fdf83e0e77d70462ca6d3bc2597c1c23f2e1e40a92af6c7f19016832b94a57326dd47895317b1584d2848076a855eac38a9d965760cd63b112410b7dd112c352132fe3160dd3b6f62caefad94f565338effb4437f5e3fe0df3e6419d86b79f9b5b181c463b765675665c5acfcbe9499fb8b254f31834248e696bdfab574ca6857a5e463a4c2c34fc2f3c1536672a1f524639d901d5baa0563f863f932717352307d783afb58951ad79f99f160a2a50e72ef7e7a58e03202933e27ae40ae6c4beaace06a9dd41f1c1663e671bffc72b3d2f5ae025e2c58d98e3273195faa65793920e00dfc9b6826771747aa305486c78b723f18da946779fd05f03561562ac5bfe7c0fdf1ddadcf92bd65de6bd1fbb379c55b8f849910b398603b3ecd26b1ddfcb37ed030738946628d4b2072df464d75085e5958621f773bf0c759f4782d4ba11ac9ee8774f7c2a9a66af092c149b55d9511980990613c71d919628b1cee706a28a97a8f88b775ec0745cf870036769d268ca00852afb65bd1c22b27b209ae39c5086528ddcec19ec85bb6048b57998ef4327fa6bce031a3ca4d2c7664f3750a8b90f1dc9a65c72d1432c5ce2c9e420fa8cc2e8bb1e415b4608618708f8c2897c8445cb4d6c27497bd6db01b0c5867578be0f3ea9b86b554cdf7126197f643c7733ba5a9e8bf9987187cb50974588810c282561d263166fa4e18a1f87d7d29bbdb1ea9024017e2918763ac4896eaae9757fe69cdea11ecc2b9b88625a04eaa13d45f068e8124524b37debc0484f6b1f0c0668197c22e0e2642483ea445e0d5155c90950a80d7eda566f0529ceb55114928f3d44cfd159bd61627d43966a4b4e11f36aff0cfe0d5eeaaf6bccd9e016b3431348dc27b2c7ef35faa40a53766ee79604287397614a41086f3c19f86b201f8d3e013ffb1c8c0de8ab2aab9ec02cfb839c03017167aade4d4207d2e0193885bd8f20cd11484b9dcbed7e17fdac62c74661ebcd3ef83407e42579baa87d77d78b1930ea3ce125517936decfc73a65320a7c638c4220b6dbc5ef8d517557a5fd885e1ec2683adfd54afad17ba7518bc2084bf4503767847e29651d47947c8f647b5aa362241fd9ad4befcc0f68261bd7e68c63c508414f3e2adf43f943f025a47278476e6c27a440aef4635af39f847458a7059a602fa4cbd1f407b1f51db03a6fc947e4ed1f05d79c5d59f2f7aabefabbc4e612a76fde4bbd7e72d873d2630668b3df1dbdd69edb66d39aac05899d626fe251b5ee57f3073b4b371b65540416ae607a24fc6ff07fdd462b91524a473700b6110b4762a3249e45afe7beed2b06dbf185d1b5c5dc6ca5a3ed12479a735a60c1990d1b7aba9aba90ad0aff46430777986b101b292d46c00bfc8237d9cfea12eba9a6ce04af28b066d8aa8d8ce88b1d5339c3a67b8d23b20fa7e36771edf8b5d85151b692fe7ec03a8d33c7cc930ce424b90a4788f8877cfb36b4ec91ac92a4d4eb5192ce30c5881958aceede91a6e35b132d4c008fad07d72eb4928131118db3937b59b5866533d92bc51a71a07a59f10c389c2aa3ccd31119db02c7854e9c01f39f2181845e81d9c0f6eaeb36fe3682a1b9a5fd7241a372b423b0c9ba3bb36427633dc87740fce35d74c610375e721e977fe6379e44a663c04b9f3b6ea58db04c53fca5131c2898c6140989bd02ae8eb4c1a9293a8f8ce4aa05fa190a023b197b7b3fdfa26caf98fe6b7b9cdc6f1e02ddb321fb68bd8394e792c2e8a48b91ceb4e7f97dc1500a4f50bd3fa2d8453869cabf8251b0fd667555cb78e033b3b497b1bdb6d8667a10d10159234","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
