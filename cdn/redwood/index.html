<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13112c6955f3ee91ed800abe49a836e4f6e60a8e1b7688293fcc5cc2196c90e0d7796c2d3d7eb575fa0a9e5bff8debe2dd92560ad2e614476d5ca259bfb0490baacc79ddfd19d00639c0885122dc378e36379f98f6cc60ad6ab6caf014fa11de0b36f39da88d4cf24feb23ec72593f0cade730a1e3c40cd3a5cf6352858d068d3b3dd221e5708fd2f1244becedbff445a8c65c0f216534155f615af314b04e9c9bf2bd1a7581040e1bdc553d7f5ca345a05ff3d69ed1208d16185fff5c443d171215ef680c4cf19143d941b6e547c00d42e89b81f0187444bc60ec76d58ac300e8d285b0a184d588b144f329dc593801df4b6dc4603966ac9a9216189a979500cc5c8f750a058212097b3d07cefec7b890f4ad670dbe32d84a3c97cb4be29aa2e959e8bf6e145727f47ccc9b54dba307d09716e9e040e38094387b4f15778c5b503e73c629ee613bd18ae8bdde464278ba5dbc1a837ee1f2f68e3aeee7978493c01e2f0b2da4f5bfa4a1cf38e9d7865d53c56b90b79c4e460b2e6e31fba5a4d31f6535be7a920a7a5122a110af435bd893d109f909187e57e18e953f2c6afa97fa492e084555fda541a32b9a80738bf2500e92ae928bfa552c9b5c062bcb9a7812164d9367b07ef3dab952fc322ecd2a084d6cf82732969a260f21c885554153db8a48aa8bb6af1628e1dda46ba011ec0f8a9492714c608c47fb8f079bd20594772472e9274ed014d652fd0aeb0b2b2282589ee6cf7d9619b55fc3a4edb831d83b5d02a4c0ad50b6ac7c6dd73c64e1e851a20f60888e7bbe6d7781660b36a2c040796211cfe4a1fdbf625e26ed4c87b1665e3a94dc26783482e409b6c9a30754192645060538e07f2f1749d478555bf0d81832ae76c028cb47be2108ea803882de9d539816bedaa8641d1dc2f318c43349abb61496282fbdf677a79d3d1aacfe3ee8eea8f123b38cfda6269fbf7e78927e254851f6aaf70d675a6b282943a0d73aa3ecfe153af06016035ef258faf70ea2906be7d86415cf4f8ad8ef2ac904ce40b609ff8fdf10457c61f8b1d25b89236a42d31ebefdef6e8c36e198eb37b84199c4ebc6cded2ab51eeabaf962ce1e26f543eabd5ae648590cf77c65fd37d5bac21dbbf31cfed2e9ab693214429e0b5b2bc12ab364d83c4630ca688fcd215ac6a82b75feb9323705951b51fd7da434c1a5830779164374b98449e37a1e6cddea849e8d959e1d2ecfcc407969393e78a8b30aef06291b2965636294fedfc01c4a6ddf72022e42d334a59be0e97a25ef10220563cd0381a614d4f4b71343a31c0938f7b1ac2548676de7e7660240ca5016d48e94723ee722024a55ddf3c4faec463f2a572cd4120676c9bef1a59f3a84f63eb3c6e7c5db540e89a0ece43ed3e8363ca616996f4641877f6ed4a6b78c0865a4f558d12b75cd7614eca967ffe71ae6f372359ca2c766c68f0f7704a93f2c3b0f0ca4721c1c097dd825fc5580a2cec226222205f4560a07d5b265a3a832953d71d46a8d8967292bbf1c045a0bf3035f878c2f437c122c0955b64f67e86a5650a54d86eebab421d7fe7644b11b7711941475cdc7f677fe198be2aed79471acf3a67c3ddb2befa74edbfbf351ce3c76e509dea2f74fad876abd61869f76c4d11c73895f5956a48a6348b3b00b5db4ec694711848fdc60c5106b0cfebd6df0faf30cba31e12c7791995fcf04b1e9cbc87bb2630d453e2733bc43fe4e6ab79176f6fa62243fee50854de3f44f4b1f62d50ea12e5f2a64d940e2f521a64ab2c0715f921642bcb9de328252717102f44fb7b67a7d9b4db8b02d204451cf454d9568bbe45ec95a008615114161702dc0466de74780724040ebb6bc907e6ffc336052e202619215ee2539a3490ce6534db3e8d332cdef069fabdccb880ed14917d2f4dbe0fc7a9583caa69459e34a1e25b1c4c61fe5b6acb9f5e400adf27a55d9d48205352c43b684b95ff74416cf8707578ef299607113c06140d2018251db80cdcf912f77c73e9a947ee25d8edbe6c8bd937c5a933ddfcd4f70b337d394e3db9c24b15a3f11453c60a8c5f9a7bb1bd20845196e16efec5bb4e6c06477446fbee42e2831193aeb62a5efcd132f8d4503e63130279ff03983ef125d36c6e5d1da82e39303a563c9502d342597b9a52d2c5f7f3c685c303e03deb5d71940ce33d790c95c5c6a7d450c35c974fd5e312e0f2327188a69a66d70c34c3e95d9b4d1b7cd184fd24a40c2c50ee3929ba5bd6220c1fb6a39866b40aabb59db693b2c130c582d0906957c1c552ec58ab26caac7fca51acf327a7cdd07d3ecd6725abdd04c645b02aa4651e073a0cdd46e5a3dc1db2fdc1b2ec74887ebf61672b515074dd264ef8908bd021e3c10d4adb35ca9e2d28e63e18d5c549ae71dd27de57db259283913d92ed538bbb55e5f5a957c0ade0e71daed3028be5ea1c615bb29e9229f7ca054cb0b3370874759244582a0a83810353131ffbfc3c34db8a2ac6e722834301cb0a5ddc49480a37614674f217714c0c094268c20cb4c9812a8df5dd2e0f05f4295bdb05a14f3456bacf00e19e02176c9b0a9dbce6d301fc6ca9ff66f857c566a9a857f0ff608d10683cb98e2b5adbe20de6fb1240fb3bd97942918f0a55d2a9afcac63e2d274c9328891007fc14fd5037c917cb1267f7cc000804b6ae4df5f93ec017bdf8e3a0017c94136ac5ebaca0591cb169dc57d8a3479a5ebfc495afaada07b858a91d50317b01c0a57eab22a134bffdd13108f95fbad987f258f57980ecce4dd9737a803e8e16f844215e9fca616509090afaf23edcbf938dcbe1bc6ae8445b74bad243a778ca7aa7bd0164627854ea382ece27292ad0b235c9b3b40433f1bb9677bb8b495a34893e19b1b91c76d587e157956de1985b6064bf1611a177e18253496701b69d6ccccb5fec05756c3ee831de6fe14087fa9a6adde0dba76d27bfa69d1e9973ce71f62637ebdc1ad489dcc6abb46ab121cf036de4e7ca2ca52f154e0099f7b01e5b12831477c93ac09d0ac8fa11dc8ae5fa826de6c27ac68b0e2e4487aee5ee7f28dc08172cd209df89831eeea18dfef0c0ec4b1c2047d68013712e11c96f312b72c37de7db8fa5b1d74f1d7a0608462432bbf27de264a3cce955c6b10f3f2584d6bb130a9274f374ed65625fa495cf1922047884700e0bbd2cc60a046320c735aaf9f327fe7e8eb2b8c80552913e35750be61d7e26882f63f2bdc0d3ccf39303ecfea654afeb51cdfe2e8b19f9fea58af626109cd7359fb45e279768c604b95174911051803aced5bec8e88a39dcae88efaefafce11a34c6e78c848841223d0faaba5aac816031bc31bb205c60c7c0e4f937cfa73285ab1757f8d61a8e47ede4b9eaf22d726aeb5b98bdffe6dde6046b82df65c11ca66ade1e9fab2a6964c1ee3b1d32d67b167514568ab98ebce366d5e9d203e0346eab976799ba5fba7ced9f0fa6ac401005f94cfafca294bb3de5400c1bfc3279227feb16f0c028f4675b7d331626bf55fd855087c8be64afb209490bc2e6e552e6edabd2d64bcdbac267a0172130552c2a6371692804a0f42386afd013511d0ea87ad2af2caaa92562a952e78a50dd077031a203e30820429a2cad6519233e4978e123bbae1decc03a45a5de1ccff1a763dc25deb020f92ded2b6779ff8ab1a9d0976e9d5e750ca27f0dd83cbcddde3f803132ebdaf4de6a23d3902402fac068a98ea9f81d24d061923480ed5e7c9eff6dcaac68dff7034d530c89a85cadd54ac75ba1699d96263062556d0fe36ebad60eb14305457b8483c45ec63ed54fcf1fbac5a658e5019b8b863731234b6e6ae949866bbce1be1365e641777b3983f8dfc67aac28390722b3644d4a826df24569614f78d6000d8799ae7b0cdbe7c28fc866e32c4f3b3cdab0124facbc62e1deef4d82a6a3dfc9b0af103fa604c60125ac6fddfd17550835db9d436212febf104141501291261d6656788269ebdfd1ec5e7ffb314d78e41a365351f19f2c84fb3a61e8168ef738b4597da254c6b066f714dc3062ca958dff16e8d48958fccb180be5b9505864c5d22b3b5a3ab40aed929621a982b0e176f3fe1c7c12bbc180f59e4e364c89b4e20bb0b438586168da5edce145c2cdf5a7677edfed6cb8af66a6e8f95e1b13188614f2646ef66d047b0049d92fe54e576412e8c1d2e4c451ae12a525a5dd2f968a37092d1fe4e35b63cd6ef02a627a819a34d26a4876276d58154a9b24b4ee3a85aef3ad8df17c399399f9ad67d31e6eac854de477f18442c69f1ffcb534e2ddba1d918ac14c4f94e046644876969779b238b427176f2ffaf6fd3a1747081463fe041d2cba6419512ffba0a40792da225da6d78a24f6be044129372d8480295191388f367ab134b52fb7e87a4c3f7ac1851b5cd281874136be70a2bf9c663db81fbe61da22c69afab08cc8c45d58fe52c9536a101b0a5178371c7c817c77cd183279f3361953f5229c4be5ab73000ef43d19ec9cf5c4a14f53ed583b4f0211043d289abe900e1955b5bcc0e2b001af73d97e49ef89816d4f957dbf278740dcacb2257fbefb8033ff8acab33a0070f02b6d4046e6f769c64b6b3ff9e7badc6eab1e64aef64401e986736aa2a7ab1ddaac1bdd4e9897fe095c66b6e1a6992fcba60dc610225221c61a5d230b1e5826cfe833934083e632542558ae90d0e838a26668bd9ad31634ac9477cd1468818196d250236e3423f774cab08d7cd30a29d6f666ce8452f1bd04112ea28ca919a98df81bd846e671381f78f501c41ada4982f6d76a7d247cd524b90bc6ec85d65e42842f500d014e58f2c0e18e95384077fccdf531fcacdb959d47064ba82081f76ae88cab8a1a6cdff5edeb17d0842c92d15d40d5d38265405f2b4832c70ded41d45964fec634633bea203bc96ee694b0819c3fdf00a931fc727becfa360573261dff67deaf8e23bac4ea097b00e25450d07ba84a324a26587b54f48b8444442ede279b8cdad03a916513dedf877c62b562dfe57ebb7c33fa85502c751d740a182d9eedcb63eaf8bd20845e53ad392fda45f612a530590cfff70d6b97df7f31ee833efcbc5d157695e1c9446f5f03dd71c6b48aa3bbe6702dd2785334bbfd1aba93c0a97223c338a30aa4bc0d57b97815b48042238b677fe19520fd6493a53a6b4a961d2a2bdaea893f4b35429896e27d45e8bac618c508f9475ef5de9f6908a1b6fedba11abddbd649b0f88cb69ba9bfa5f8b4c702ec78007ecf91c6527c382b48e8c80b41bc2014b5c7287160248ddd87f945ce3c7016b794ff1585162b3a5b34eb51e936c216bfc52938fac7629c5fea90d9e634abab3ec9acb55a6094b1402663151662e563b1b59ee5d79a86bcc2824c633f0d77928dd1c5380754dc93f958cbb1e7fa3d8197f0f51bc9c2ef9117c3d76d12cfc788e6d2d12053effcfce4949e604722fb04b2d12c5d574587f0e7175586ab61396171129c67953f259912b57c990201efbc0251ff669a32c9cd6e1f2f0596e54bdb5f0dbfab772f0fec37f5c13bd91268173cc3b91aff523e34d5ce08be1330004a2dc6e549d4c61456cb70b222d8d6a8b43e52a336892fa8505fce705f6f45bc614ce7735d66ef580fc2b0f9b3fd5128f57e8adbbea4e9ecd7bbb5fab69a7b7bb8f12fb4b35211b132ba8c1c492d381ff9a69a2313498756e5f2d857752cbdeddac593d488c3631a091c3492773f5c2b9dd8637416cfcb7424d7042c4e80a35efe460ce57c10b9a927dc73b6932cabc29b434b0892ae5f304a83194918c77271d27953c818861a0cb88150c51396cb14211dc3d009e06111ce5edccf010acd75303a27c41d83cf8f0a82a15ff73abb0d972b60b6c174655b069f7da7b4d5bf17d55750fe05893f9bd22f2cacf46d0f0af10711bbbea44b4baddda561b80acdaddc22a834d77b864c95003afbb89d7c75b65224a5a4a0890e82ab11fca29609ea41868ba733e0428197648afb660d6c80eca360ce3a40eb4d78fa36dd1b478cc32e875035c1ce0b3b6c78842ffbb98c1b356998bedb9d63b1fa7a1f5e5f5538b3dd4e544def6efa886b7a4cb04455ba3f6540353a3c42dba242de66e8e446b3e5e20df38a71cfac8e19d6f186dde3a10a23242e9a51eb7d42609a0e6a6e1a8802b90777beb5c68c8d855353d4105b4de3fd9bc7d708cb73554d0dbe36be59fc1962200319d569462ff724f75a9e50cda5ae2a16bf0d96f135aa712e629535ca198399382f98640dad50ed173a183f95749cb4644977de0718e345d98d032b74a95a2084ad7b4af014a9ac6e82e4eb6083c900c3585546ee1d1ef7266f40278d6e81c3a504eebfbd1d3b98b0f5a5947d8a03e2e340720f1d2ddc5146a32a031f4bd49aceab9c7e8d86cffdfcfc722f1ecff11dfcec80eb3e92a18c3922c7c4be0f5e4f2d552b50182e1f00c172b4f4c662c97f789f1ee6d10032a5853157412878492b02c1ab8852383d9a4f3faf9720791b3684313072085b58e9b984d3e30d85d56c8f1af046b81543029e692ce8490e283c7f9303134562e2adeb2cd999dd320d3296bad2f92996a13f4879532050b8b6a05cfe515404b492ecd52f03801e7194a461a706e0b7cc18b1e2a79310a02e4bd214b1bedc5ac330d90cf3946c1e58a9ace6984114360f2f22bfc98af4d3a8e5955d0e7d46c13e4ede8c7dfd3339d0a9f40f56cf8b1f2237c20671bba79eaa64f48c267afe06e58604ee1ad7c4f59d0613f15168da0d3180b4bd1b2db3febce704547a80c5b559a49571d487309842af5d8d72da1ff5dc17343b105c3a914cd2b4e8b5ba4103d3e7c252778925e05ad691f4928ec386eba7aa14773f3afc130e72bba9bdc505b06aa158874ad5931aea8646cc132f8330f4bc53bea1d7348208bcfe7633c3ba3e9e2aece0bded2f65ab33c61fa71b0a882dc590c5219cf8e14133db5d5172158ff04df7b6e786a0469e5a0a09e1bc4aba41d889d518500904b5950db6e17384f040f69eb374f335830a0e3d2635dd49c77f098c2d396f988e8b00f8bd4529aaa7ed140c0540650a5ee4cecae51e786026c8ad73acd23b65a6eaf4b52d029edb8c2aca9d4f59d22f981b51b35211cf4998b2ea38ee9fc55dec33b8f42365d93fbd29fd989b0fccdba0cb2e3200b245698375fa6d4dfd1349302fc3494fc3638726a7029635c70c5bd07e5e009c665092fbb83597ba3f6ac9845a7aedd77302f0a08ddc1a07047c7a6fb1be473496522b2a79cc8e76e7aec5559c8a26149ce9f1618e9e1d59877bbf418380344f619684b4df9811f040bca7b66878b8130e5c6488b814e7ad54582dee2d3e5c5a921c01594a96e97765db022ee7ef1667ab44331fe16528348886a4f2576369f7314dda3910b4b91df0e29cf61bb2cdb467fcf7b99f21588c986702fa7d256a82897b93fdb11f1d0905ae9e9e8498f1c8d58cec192623569e9369a4698dd7896ad4003b13dad478b792debe57f87206d8b778dc8f0115af87943839277075fe0da97673494dea2e684933d3ce4f209d2d572f8b3b92ae7186cec7c012f9a0decbd3cc9048c5c37e5cd8319054ea3ac6e06023b643bccbbf039c10d078dedbdf4a0e34d0369c8d1475ce86cb36c0c86cd0172123d951824e6cc7252d59cc2cd09da6613613f8d3354214de1ad3144c53df386d2e06f6d8f25643f2d05f82073b54b31ae0a55fc1dd9e9f338023acbb53a94ef118c7eff578bc6609e53d38aa0885e80d25099acb5eaf8c5cdb175e72fedd01236d15187096d0c81f01bf089670a2a52bb482581f5ae440564f56aa27e8eb11a445f9494014188a12279b00a679d12c6f3f845cdd311d314e5511c85470783381e6be3d52692c2ff6d990bdd5f29901e233f76ae914a884eef49a20c8656a89110494a863d716d7589ea9e6c80f4745b03a6ac99a024721c07208a386f9064630014b3894b2efdc47b95f15c1fad27580e0527548e90075bbc0b69426c6941638dc891b09f243aa27d878436089bcd2994dc12ed16468f758fa1a2e4c04a20a9c68d434a875287506fcc7e76264530a66cacfa8260a1e8907084edc22a0bf367639df9c753fc8f2208833d1385d4f1e89b839d488d88413961c1fd67a138cad7634b565057cfdeee508dd4aa0fb2fdcef0d5df2fd5cee21227c0483f8cd39cd214af1af259d3b2af69d9fb04304a736a20f5a33a17a4996827b5d0d5210ea810a5a8860af093406a92a83276cd9412b03b616f774bbf5386ab1126218e93a7cb12cbd0b96e4fae778c7cae3e1a49236cf515a3b969ae521cc64a007fccb2ce9e2a719bcd93c90532f454beccce3a69b0656bd2b50fca2c62af35d31268d17c2208300c5c569de94c69c1d2955ae01096f747f3389f43cf236fda2a0574ef971b9b2995f95bd7ab90f6c7ae070272cf04f572af98007195f72fa3d005aa67aadc8405f61e2b7e97268df616d8ad5f774ef5353f3eda12865db6ae6ea18c040e120acd6094f2bcf2024a96c238a430c70f32020029804ff78856910f226a1a172c0e98b3c39747d97978f4c9feceb57a89650879d6e6d66cd911194ef0d721c9e67e31703e1006ffed093006c115ee0d300d7fb98ca709579ffd793c113c0d74f0260e0c99fbf9e8ad3cddc2a690b884cb7a06a21805d4d92256db220a50d0667f369ec455be6dd169f9443be517e2c405d775d4cab1b0cf02da2ef050a774223ea272f041c96c5a37bd84111efbc6070c83446d7ef94c4d152aa8c446e1e28ab629f29ac2f2842868cd29f1be4083512737ae073b5ee9df23648b9bf19594e03fdff78737fac9946d28341d8f48c602956e799f32c382e47688ba9e2a32aafe0ed46b9ace49b480cd7d9fbb555f54326a49b6a847baa9cf4262916e744804797d1ac7f0530cd9654137c6ac25c2f007bc9dce69733199d3eb374c407bd754b521c2fcf35e480f009a7814b40eaa88e988a5c7c793194d30382e9cad6e044a5ec095f0792623a250e56ebc2ecd02fe7f0244d28c566a95cc6dcc2b9ac9bcd12e1ad77d0a30a2a8c0490819abfc3e3e3e93f94cdeaa896e5beff563966e05b5eb9c6b92e492769c8820363a497f0d7f9b803b32c114061db02550e330f094d4acc439b8277d200184c99a7bbf4f753b0b13113c0bda19d76a4cb7cd5892f13d529f45cf9fb2cc79b3fbd0d9b9224204ff2b242fb45f1f62545b022b015c4f95bdeaf2351b3df8600e6df27e544781c7bc1d01490d2877ab25aafdc963efeb0ed30be1ddeea3e379429e88146183928d42b386ea70238f13fd7ffeaacdf4f44b54c895095dd8310d1407969d77fe8eaadb9460b4fb6c14b0e4d20c1db3d3993c6c6a45071ed4629ec9b1b5c48cfcf807732f1d22edaf2d8bde5cb3550703e9c8620de5c36bb360942a5faec2b3cfba0247ba7fb1fd3a7add08e738086ee8dedb90210fa54fb3618e0a4021199ebf38323727a2ce08d1dca8b6d3d17566b9085b1094e384899d5c449542f0623872ef8e3243181a77d6c9eb8688dc6e977dfc74d0417abc2f03fc5ee3c31a3d51724e4db36e28652703446bf4032dc9e425859777be367323d6c095bfe88e17ba6ed956c11c3e9058234d0f5b9d27f11e319bc1e8f7516085a1ff6f60001edc678d3332d632e1138c3f68e591689187ab7df285293f291b8d374f5f690ddf4126305b44541d3975125d111a030814a3035b77d5cfc626e6f49a3d23089f6d81f835f2c64433ab7d380d5df085955823118e4e4689c2a20d4d954e4987478e602978d66cc3bbe11eab7b329c757c854f3e0f02ae2be163389687a6e1e87295dd0a3a8d8cf776e5798d25f49bd08e98288e5cbfba13b6e169c0613aefa0ad71c776d482040763a02e8102ad3c6c5f8d31634440f037b9f4339368ab3df918147caf55be69171c2e661d89289924bbcca16fde3cebf897890df82ce054c58f949d3518a158731085f7aa56bb943d5cc0c6187c71ae5366f9dd21abbb42d298ba519c0d4f257e756c51af3fccb02d00a54792ae44ea1730c027408b7f1703a1e480eb3d4090fdc98855bb52e8739ae09bfa0b073eea938accf068750bb04ca2e9cc3b504b12010abe2a4393b84838811ef1a3a2372f834708d270ed992b9db4416828ac0a853a2514581040c77424edb9396675ef881578542c954c1c3f151c69c85917aacff57a3290f93563fecd2fbd6913050dbef24b7d4e49427c71efaa198bb0177360a1dda57ffc5b29309116eca8354bbb07a9a9b8c6d177127b1121486ec4e76a69cf210fdc76abcc90215d55eb57a1af7114fe8fe82717978e02cff9932119d6f72a8097a1f8ff41c690e265d3ebee7da913752c21dc4053cbacdedfd9ccbaebb9b15ab7325b393173f99e9359bdb9ab55722f509b0c2daba12c42474b4ed5afa58ad7f4408234dcafeaf69daebd71b33ec667545e5222225fae9e68f99bc44e25f88503ba22ecd4af2a72155354ca7c63e3e8ffaff261e6d53ed12fbad401efbfe15f3502048d2c3ff93f7bbc4e1e76bc523d1538202f63f6b77b0f7d4214f69b16102e5580290495b50b2f9cc08d10529d2c0b1cf5cfc49786cfc25e7a283ef8522f085522eaf50f8735ea076016ea20e9254bb7e5308bab0ce11fa280689667ee64fe07ef45d48cee08a61bdc47e774e8204a187b573b856e240d946f910830a5275ba7fd168441524cfd349e83c83292a39c38b44378ee58f2fa7d720dd58535a464be08b43f9b276030fe69c3d2d673124e6b48c2727b31396b2f612ba4ff313f6a8d21daf09f92b7c1716a8f94c898a6a3f3f886e042b775c14d7c65a2076a142e45ce5963ce738d784c76df4c42fd1557a6df2a5a4fd5c1eb9359c4326113b2beb6bd9c3dee4042d2d4c8a67d492ecdc8a600bbda179b4303a79940f6021c4bcfccf13de8677021c57d3ff93b56bb0bc77af3db53b97a5494a9438e7142b83528217510c4e180d4040c21424adc00c7c70b860cedabd0ee7bfb0f54e52677f2887752f0402e5d1dab4f47ce3f7d8c1d4838c60e57b3d436b023a2f2b15230ea78ab8f987519c141a9b5c42aa194362d4b299454a25dc5280308f1a78b05fe8f7db15b32eb99a612c2e10a970e7617b77874fa54b9e0c015b983427b7b0ca0a8545550a990f0ebd7c5b10356436f7284d401354c3e9a2f002433b655bd9473cc02b15a598421d88278352adeb42e70f7f28ea12be7e1c76598707072a2cd9c56ddd5088eaca06edac2e085eff0b340f20d569c74b452a553592c34f27fac40aedd217c9f68a3a69ac7da50d1a1ce67e79882ecd5b3e92cea47e2382597bbe4c6cfd1905025c16f43625d8216d0eb2b2376603def70053235967a71b62db3e273315599ca79e20eeb64a3d90ea8c32c6beae7f856934e164453705566aa777e2499339643ee3e517cf13a64656c42c17f83fe37c06d2c6d5e508993d04e39e726ce86b62f4c34100194310b307dd3a8a929b7005cab73c8f651c3c33567db34e4ab31f71b34a5551146f23afc9aa3f03b967bf11994df15478dca209288e7108e6aa55d13d286790e7624c82be5315871c679659c3f157fb6d721968e53653784a8c018cd03bc09851fa269eb016096cc48511ba1f334091988eeeb44a61937941c04008698a8a680cab148fe634820807c4251de377fa43640d0a1a10f1bd0a0f6a7d72cd053e9aa18ced017ca8640b5a6f0e3ed3ccefab639572fef4ac63d3cc5b8a7762b5f1362b05415c0c69e4f4485c220650b035532d78fd9275d6c8b26e6eee34d44299fbbc4c95683233dcab24d9fe530958a0bd7603dc639b3909a45d9ee626225433d4b882b0cc76b966e886e143cbe460f62b5f5442bcfe40016ee86dfcf51d6c797becf21768b9e8cc7bc4cba9571ad38d0c5dc6859a73093437217b4e8c05341d8a0793c1c3321ecd050c7cab9c1f4efbb15440a5afac530ba2a6c9aacd521cd4a94d5fd664478266b74595699f983c6de383e7b76ea23aab86c21b28736c241ae4dd59c15175fc30295d5a14a29004d9b0d0446625064f512daf2e508b076f51a0d70a6e699a788c6eb1da1e6395f55996c26b1618aca1c22ad4c20e9bbde8cbad8491351254be9bca41d2fadccba2efd5c069f393325e0dcaca69733b693935e31271ee99102e41f2461a94764e79961e60d10c31c70f59655d44125415998ed4b04bc434e418a501ac1f6a34420e504f58e471cf95408b88c21956913c64f39e5987e06e4c8487f1fa7413faa68593322bbbb2ce4a21d5ae0b08947a8e49124d3b7e753a5d731959e6d0590ceda80953381e8717138fed4d33cbe0a22ab2e912fd4d3048af9fbb09b1bfa76ff10aa98c01cb05729cefe9d856d5ac158ed87cf1e03511d8cffb8b39122aba3981355bb9bf6892306d38db21b22d589f67f005e4257ca93fbd738d8573f605ccec8ae150d3e00361944494222ecfa706709e3bce1a0b930c8fb50a12f900c726b674506ae69ab544c34312e8036f1aa6385b39fdcf5e492183dd2871a474d4e5fabde5cd1276c239d8c2d13948f1e2c91743388ce88caa06f1f1dca6f034ed37c326227f4197b3ce2baecc002ad8a10bb7574e1b6b718aaaa559045ae46da91b005116f467d0dc2d8053bc9f2b37f20a9bf4b375775dbcb40c1c2f1ccb8e4a2669d1d9d3f571548d201c9e52acd13e183d08f3fe65ac863deb106131fab9a1bbf312cbe5f4c2d9224381899872b347ce037a1b7101866355d60ee3cb6a4f0bfe90aaf9b4bbdae0f30ce8af4b86bef0c23c04c6aaa9069377da1cd0cc5d556c060a2e33b0091f32b0ecb29f5588043389e3e9a8f0d332d4391d31c97b157a70885e1bbc8713ac0f5797775fe551b848274b3ca7c8a991e2223e1178bd0c807e41843f2b722eee050de506b87f05008476e079f962e9d3f98cc9b211122c038843a2986021dda883b339d1a16fe51c96e8ea3be475db82f8536b8f050947674a7e11cf5c6d0bc64db16d43703182b090ab2c5a7be147cbc689397af38ea4653da8264f1a99fa1284cf02aee30774594ba70c59a4067057970d7fa5d965bfd7fb8a12168dbea346f9a18b0a8dfd842f2c7880fb703f433b0381043c0ba2526957319bd105f3c0d31e0883cfab6406bebf167b3bd1e8ee44408f6eb3eb335f8f09791708ffa6db035cd36cadcbd54e180c7ead07c6573c3bbf3169d01ac922ea5bbf380adeac5270860f49e04a4299095860e09fdec3707b2a63086af58ea18e9634ab6337a57d4e7b715efdd588c4da2854193a29763fe93baaedb7f8308bcde4963dfaee08ce200ff818445173eb22e7a3208b2401e68159a012d5b0bdb49547f26ed938bb3efaabbeab291b0aa59297fcc08968555c9bbc241f4e750c4a84931c8ec2be6e27f6e6348b00f097b3ac20872008687fe5c86d79c752e1ea8a9e78e4aee4cc28e8e7b03c7ad726efd9986ae9f04bd038b974a9c652383ffad3ab57dec5833a83c6ce3aaeb6a94db5d2f19b38bdeec9e46ecaf3f8a912ca4f6cb924ad8bd7f2f34e9e65d737a2a875ea036f20df9a482f16b2e82d54fa639cde15a119e2face74246879d954fc684a5f4be7ed12ca8fbb42448c67dec0d9c51f965f9281612ad6986f9d704a96654ea0b9aa8328fc7663ba669abe89e63d371097ce5094357caf1deb2db408d6b707e3909552288df32e300c8f981359a481a211dcda9f422a3ab6d575a6d473f4eae592c73358d7c305684084ad2cefccfcd1a1f6f1bd5fb34d460cd63a7559492b8aaf223acc0b09c9f93ea74b1a2e12b52724fcde06895907f7df48ef21ae18c5968b01dc59c55ee0ad5fefb322e046cbddc20fe7c3d9389ef027f0977bcdfc73a9e9cd03c223d0a98a2f6862f6c9b7c54e2e123b7707d5c0ebc3345515d151b247bc7b8f707c7309b9635e046f8b0c5d85b799e39d1b686c4bcbe56574889f6d46505d66674bf3e7f4f5714330b9eda0013609aabdccdabf3c752c9c13b2a613b6f4155b2c270512e7db8da4acba4f34a5a1d6059149b68324baa94a3a57826dd39261d11d7668710394d7c227b23007aa2578b266d5e22ee334e26c41f09a6b5c0f62fa1da4ae25f7e70c2cb881e04cf76bfa44a77f7719cedcfeda8074672737a06b5217d591e2dc5d31e08a34e76cd932c5139a87b271984da7d7e2fd0e6810b0edc4bc5dd7efb9d64873f3c10b00269e22a9dc5d121769b83e9910a2728381a91c5e63d3aadc6ea35c2bc831dbce93c03ffa42b0c91aa787269cabdc621d96bdc52285d02083cc6987dcabe527d5de1891f63d5fe94fe963f834232f7c4e3351671de0c126181e46ae5d9bf821478dcbfea5498861c76b28ca65a6278c56ce0495c580068106a07ed89abba52513db374ea25d84c1789114a364fa4644e4dd92b7ff999eb1f8651942297293f9624d8f18d569884f2be826c999321b5fc885198ed44e2bb8a726a741afa344d7f8e29cd5b6cf4c421f66dbcfb991263d13b86a959df20f55b4a8fde7984edd3a3703e27106c938a9647947b0dace67aea5b3f44ca0140d7fb99ffad85922e0792c345cbcf3f2807b1b88b6d60363a2d714c52bba96f5a433761fb4a9beecf6d198c31b4fbf3c500fe4361addf10c359f14fe090e62af51e34241a42a1c7cc7f0d21b910b2ddb181c99370ab821ab6a5b07fbe57519942c8644b17a0559dcdf0979dfecfe313c2ddfa8c80949239837bac38c2ef025af439581c54e92beb52caa0f8f4ae1ac3991b276bb97cb1cfdaf42742bb0b500f5131260e64bd3858ae178b3e3a4a12b6a5c04a0121fc450bc765f60e264531fcd425d881fec340ac6bd623e2e0fc9f342ee7c18246340766d12301ff87018e0a0060c19c7ccd2f1c61038547a9b6033f8328a0fff5b013f70deb09385cac2ae188bd257b2e96d9f8f6b0dc549109fcf3828f518b2c28060c6076f1ed3abc37c715b987dae887fe7a4dfe19e3b34ce10ad5a3f795fcfbd901609679f95b958461da0559e7b009b249c49f88ccc4a05ab928c66b832e8cfefba56199e82a103ca3aa1e34f6718c43c5ffb9c6c18efc29c7f2d3e3632d444e49edf83db4d09d4bec8a24b2945e5d484bc12b1181220a9ebb1d8f8647a323d9c7dfa466a710f72e418f116ad20ed94d1f056dc98b4c39dc7b33d01cc655d45cfcc8afb982e40ad1e6a840b34638d002f3c08b8fab884a1b908a0a973683147238ed381641f3a3b52e64ff8f8cd7be52068942688094c4481fd9061f465eaa0675172bda8d54f6ea860cc5b69ef6cbbe3709d2665733d73fee2d39acefd67eefb04a57307e6fcff063046a87ab8398b6b4ab530e35b8776128621ec7a8da4e57e1077ae4997c29727fdfdfa7ef6efb6c4fb405dc4e83da7e6ecf2f22ccc54e4780afd49460378eb8d157eb978be4a6fec56b11a800e527dfe83b80ff149b65cf43f2ca8c137c691f1a94deca916b2907a7c1b687100d85faec82285112a15c0a5cccdd8f244c7488ff8fd7c40c5fb7312588b5f8787ac56faf89d033c1602fa27b2a9531c79fdc0d6bccd3ac72db801bb862109fe498f47ad371b2fd1e0790efc68e38816fa027a08a08e6c382204e0b84b297503b05eac2a6dadd09e6609ca9bc8f02c0dd471d54ae8abeee6046407e93e6b641a5161be185140761aa4b8b1f4803a0c6ed6e1db7987245e0b9a35dd87da36dcf89c8fa662d874ee9e2be633a67c41a16c189cbbcd6d0bb2a5112c68a858ba3d88779d7d5d7b5d6211da0b215ebdd34c93772d07e43d37e1a8ac300764460121f8703dc9aa9bca7f8618f690d4e254db8900c5f3ae852caf28c56327c48d67d144b430b80d1bdba3c687273ee930775f9c0f96d6bf5f77a427fd9bd4dce47a6e12db52445c65983f4226e2810b09aaf8099d03884c6219e3aa14177ed6fc6b2ed5e1ce2902ccd8fb46fdfc7caa26d3b56fb9efe32d56e9cd2a136b24f4be04c74a869f970fcbd0f3f8e065909da9b8d678d0b73244970813116275604820e0fcd4b031b91bc9d1ee1554f688f5aef58eaea0768cf053e7ee8370bc0904a8e1a2aed9df992437d471f982d88330159c98b599f1e2e8da485e45a169d727a35433218d56573b2cc658d4a944d341f42a8cf93e4fe052ce46302d20ce822b7212d3788522cce03930ca8bf6b493fc49c7107afed172965ee825a2cfddf06b6cda6cef4c746ea5d9a8d1086fcf6f0c0826826eba73f5dc50499f5461ad5820cb2c302da38859000276a1fd027aededcacd21ea19e57c80dfb6f9ca4681c57b14bc96f5f64ab59a8202784c2ba2975c1d7ff9fbaabb7c6e37e7d301775dbf6af4bdc0251c3916ae719368c23d63f251c81b055f9d23808c22eb5e212cc80c0f07e2de16d39113bd4948953b4650cacc4fd6626af9fd078ba3031205ddf79ad4007b8c90b033cba9dd02a2ea8a04730ecd1b71ee94f1fbe380bee75e26c704ed598a10b1a0076d9e57fd584819d2d0aa01ccfa9f1558190e56b5261da519bf3e69d7b34ee77b6c58557f30e9a9b6f0b1b20c9a49f6cb49e4ef5326ba06f523a61aac5bfb8970592169c102aaf7f9b661ceaf2a588710fdad263e8f09d86d29cb7dab9a04fc5491f890dfb0ab3bace37cb5cad67d933e898ab9c354d24a4566e0466361174c3aa2b80ec051aff5500b339f3288683e6fba9c9923d6e4c18e34c6276c363fc6c5067fcd95ac84d8ed0cae65ea26b56ee6f73a4f0c61f514fef9c488be9d13224482e1701fe9938b97ea824135d095222b43f854887fd930d3eb3f9b175de7a9f412908e09c57512bf72204b55b771cf0d0f28bed6c1cad6d8ffe3ba66fb0355a1a057b6432e8b558df20d7dd11ab3fbc0b6304a300cdc474a24a673fd4ac6475e8455bf9c0cb09eed26fb80483c33b1c0a71bfd73a60dc8e25f894700d02608d0d9bb0cda12ea3fd3d2bab5e7ded643ed56b18ce906a4021afdb28d8a6ed33ba8ced5c2e9910a1cf9fee6c270acd41bc1a4641af62a3b950646b8997595bdc877840391da49c3993631d43b76b2e57a3fce06b4fff509268d22b90da3f2ef835a2b8bb360272bb4823bf511917cb5bcd210f409eec06c6b37420b64ad12cd6a6de2b517ec77aad17a361496458945bc90f3038aad28169e3db4241334b6c31cf956304efe438f5b85db9b879a979265de96cd5580c5dd4fe865a1cb20be0d8b80e2435aa4021cd17659f228958b2eac0dfe157b80b5a05069806913c16c99af8db15bbc023367ea7eae7ec9597441e33e636b23dc9f7ed80d3a7206ecaa490a963c0ab0e6c087b0a4cf43fa561454d85f9a9af1c28af61d20f24e206394f04e0f0e207a7d884bd65975d1a8abcbdd27628e842b9e43d8d478c9548adf9ae291bd24b31ac7f43a43fef82cfb5d0dc6a21fff4bc38c5ae7817fd6885decaa24b71899c34c8d738878ae0eddb42abad2cf510d7b5676e68e57a4747fb2f3da954ce1459e4b32294661cc57d9f643e94c7a877a5c2495f6287f9b0b551c9d3979d37e0fee006563357ad53f2ed1635081e63476332abf47990829f70f09015b2c4605f1281baa8af083e42d5037026f143d14c9cd11015e959b945a9d6052b7a7bbd2f6fe06012b3b138428856d564b2b217e84a07ecc130037c51a51a6929e7ec488a2017d6b5a9b200bf7d1ab8e70724fd27f4e2582626cdef51821d1822a98265706d127b4a93cddf5de13f46c15cb2dc57ff05c74095bf4cf903228106ac956101aa8fbd31c74abb83a4e5bba96aab12c953be3345142d73161a716cf02552c8d032710345819c0da9b4c54e18fd243f758fe342e0df041081653eabdc548768e6b222bdeaaa804e972e36710b735bcabff4590de6fad27277107d68b2f5bc862f5259b1a7154037aaea59d4f5dc457abcadac89f5aef074433ae2ca58c87421be2a4569efa069161a0f2d6f8dffe97eb17ab59106ecf8a3c3915f07ecb16e7a43289b23ffd28e153a948057dc50a0263d711150260081939c474e3f2c7b0fca555a402053","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
