<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf862b0bc2df47484e49c4862bc7146dde16cb11526f6eb8f783bed55f74968ec8bb3f503c8780418662f323c595882aaa4bef83c4e423c85d0e1ab91607650b4032d1012b06174c8e08920be718860c56ea1b8bf2f9b88482d8f0bde774f7d60f1ad4bdbb9d2593635099791e59689f222f4f38d5591f9f377d3e5b516eb243f416614e7c1a7cdae5eb9524e432cbcbd8b1eea08f916390b4f9018be638b20c7c3bc6e5e34cc992fec1186fa1da810598ced064fee756d008c1dfe4eaeac04b0dc0be9de30e716d0c1e1b8768cff1104433935d2c0f413f3b5a3136f0b3d01e295a9391e214e5a373da319d258f6952a6ba5cde7b9e76d3f7c4155c4fb7bda2017c7d1bc32a02b328eefa9eca2a615c9db77036ff0e82962a8b99fff8ad271c28b249b892011d689e174f296f2e2387abd8a0e2a3d73b95a6684eaab6f7f1a3d6964d37630cca5b2efc0690cef755c51928f15a7d419f4612fd598e43b2de17c1f4e2e193c41d08d56076136c65df38c98995cac0f93700a0660117050958511fe65f9bc2a8c9795be3f38e074ab900659b2a779bbe501bfcac61ee512a5084fb8eb61a80886b5b34bc51848d7fae88ee5aab0d23aaac5ad92dcbdbb89fec629f4c84bb33b23568ce2cfd6594b197e348008d9773ae973d42a93931897b4be034ac70eaf0c1f3822a79af69dc9566d7ca97a7f9892cd36ed8e0392cd8cf168fd38b3be8473cf93573fc4bd028a86a214e720edd8223ebd26da218e10c4eb40e0d907b9b35a2b36309be44899aa17acd8178877b0131029c5f2d5f32dea7effeb17f78d0f6e54ee7ffbdeddfee657fb579741fbc793b8b481224a6e94916355fc136fce17b01d00c96ace3f4ed9f199573513274c9cf444d5d5b90a85abf05c91d2cac25e096dbdd15a971d0cc725c1d01f7c8476fed7fa77cf2565bbe2dd6acbbdc8bc133f42a3e8101f5aa609af5a05f19002c7faf58f5990643865eee5bdd2db53bb13d72af4960059708c2d79f38a7413a4284eae0340cdbde0daab044f2566acc1fde95aed197d4a46caf71bc160ef90457162b45db0762c1a45b878e24d277e34aaab9d65226e0ab1830d4bb935e50c2566bbc274f86e7362dbe3340417e70bc9ea01cc71a6a4e8813943711a1e1407be98c90e14c370a9de75e17ae7b60d3d840358ffc95c76d0e4d8f28c9dea8e200ca7e5502786821c6f0fb293d7f4789c7bbce19d61bf9fd42d540535aa48617ea9e956ebf8687a3358a135879faa0a7ade9c6a07cd352b122f9657727f4c07dafed62cae3416a2224c3056ca4e7c2691da3173748129afe6059c96bbc9acddeed169f7e770eca88273a043afec166212d16f1d5318f82b8d0e79624942642d98200e71ccd539e67c5a6b40de87a7f91ad14c20fb5e0ff41505d7fb96f1b058b7a2b45e8ae27266d1293e1fc384831f3d0218f6a308a2ccb378a278258ee89502d7cbb5d5b67a4aa0990f902f4198074e87a6c7768fc2947a74624c39ce36b86997cac4a30fdea3e0d3ed0941c7fbe9bb3dc823af0237786fd00dae1295e07544cd65676c2bdf0c483eefed5cc078a3049c6167c0a5fcb65caa77e015aa1afeba186d47ccaa25e18a30415af1b881fd16d73cf6f09a3d7d20b7410f299bac16e5bf8054bd0c606edc67cb4e17ac9c6b08e1a166958db6ff3241066296da7176a61dc2654fea6935f9af7bd68b13972536ab908fa28763a62bf04352dbd1e076a1f5e7be1acfad4864aec2b65a13a8a465c6e4876991e230fedb20477b8eb2a66b7b778032cc8511b4db579cba6629036ecd50c4e3fe1b48133882cb4e5abae92a757907904d1bf00ed42b6e938f98352d5835443e75009b1cb6cdaba1767a1928e77a55f0c50046169c7758482019a06c8105110e685ef9de00201ef389c908aeee6a8d28bbda3c7f54cbdc42c6f807a79fe46635909e8e1e5474c13fdc4d8960159009a93449ee007de2411eac80afe4cd20dd26a7c35157ec1dac8f05a9abccde59af63afec5fe975a6d6f2b6cb76ce0f8ee4ec9e5430073d6016a5fc3d9021c9aa5429bcabfa676f1676cbfbd18c153fbe5a203d139c7cec2111ff3970e4a25b9ca97604042a7a230cfd72ce40b5d3a6c5cdaa1a604593015227d8cd3ed11b6cfdc34b2ca545d7066649aae7b7208738f6f14a4160e2fd40ff83316ffff3a5a75c19ffcf9242016626bb35dae59494b8c2ab6dc26c7c12d36c65cd4c8d71623baaf88a56ef1da3fb68ddbf0148dc3023a3ec307dc5f8456faf0483a6c711f275875883ac086e6c972455228716d8c23b5e2c35bfe6e93e4969eaa607533414c95bd33d686655c6843b34ec8a5e5e0c046666f48c56e1cc27ab881fdf0f88af9b90b2d70001f1610506a8d52bbb736da4798160f2b7857d0329b4bfa1be26d82809cdad9a6399899b3ea9e9905414eddc2447de85c30ccd9d514f3a53ace3e2f2577af03fce651e33a4a345b80aca6fb9d5960d838ea43d4ea2dc5fbca328b2b37437cb1b0186c429fed41e1e072be85dc645a741c75c9038492793c0711e920727aeec0c7bdf271c714bbd6f0f335f1e3c44e87bd6f1dcb8db6bfcb800e526fd61cf769b2fba09abee15f225a7a836070baab3760a9ded0342115fd4658a9d99945f8c1537765ab9e097337d72d8016d4e76cd6879723d94327efd8a5bc6242d67090a9aff7bf7f790e3456e887663883e4d6a8eb0b522bb30da010ed877d39ff23fc07ea25728cf65111f35882951799db32e146989f5dc6b0152ad24930d74645d85796dc1134ed433050f2df587d08ecdd6c86661021edb79dcf50864312e74f5c5818e5b6b7329c0a9619a029cb889ad3d63ac851a50a23c035688cbafc288f1f2ecca28c3a032c6222db206315f0c47910c979a2438e441f5b86f9d7e881dff9c66752b18c886a535bde65e0ca331396a70e7af5d130249ec0a23ccbb3f0e01554f8ef3c979fc98d20ddb21c0de8a9e00b7f22f4fa03bf128375dd8199d4240f1a91bbe3331c7e0a2d64b2e83d686793bb3e7b59e0ccf30a7cbeda8f1c4a5e0f9316b11b80f7144eeaf5b3b1cc27a299506ba1401f1cc8ed2d17ca639db1afb075146f312ff599dae64ebb6c7d113f0bc5962351f2a4c0d3dd4b1964263fcedc345f1e34f55284c79e2853f1cf3d47b7be8016349200bf773d1507e5dac20ba0f5f807d4e8586fe5499b22669bbbc25f27f7ec236e45f1135ebe9268dbb01164495ffdc043218573a605bb05ea05ecfa0430e7c38eb04c193b1a536bf4ddd7a1aafb7b8880d505bf0a7086db99276a5d9551aa83fb26bb622c49775f0e33f2bc90ade4cbc17f3d870106272c692b031c696c0c22cb7c41307f48f7dd44792aca99f743c23beee8f055592ae72a414f8d8677b660b3f406061cc849fcd3af0907c67a7b05b24dc7cffd0e8e8bfd9ecf3b8e1011be642656b82ae1aa6048a2ce163df2b76d9fe068f7a49400f450780c97f42feb3bd6b0eba5fb16e1cc838f685e130f917ec4eae06b55146a8b8648a137ebaa439e58cefd37c2e1f04c3d1cf414b5b304351f309e51295ead4be26c4a91ec2ebc74232cbd7aea68889a04cb8dd63b95133ae67baab2762b7e8eef2eddbe43904e925d53d44b47daf1df1dd8c28bfe705164782ceb0361a07e19404b0a948a5469cdb28d1d8f3d557e12298ae1ed4ce47bcdd985faa8fbbba7e3ef0953e8c1ac79568cb3015dcd10c3a1a475dfb410f79fbfdec807c0b1a373859891687107fd36cac8b567c87f1f0504334dbc1a9642e89d9663253c1402970f0d8609427a0cfed2ed4af27d9ead946bf3b89ccd58eda9273e634c0dfc0015c763884688113218f4846030b26e826395e45db2d27ab82427f7d09f86dec23ba67f4d982c68e5c6a98b738d2a0886b6c142824f61f99a8949ae8e8d96a4d0aa4c48b054b6617146d357aac3ee440095bf034792a27abe7ded67fa79fd7c91d47162d725896e5251a70e54ff844314825f302aa686bb46d21b47c8b6062541234260fbb3ed10117e6f04dbbfc15637a627b00bcc995bfa7e9c0dc1766a9bf510b9f6967f31ceefcb363703c00e369ba38e84699607d53a9da99984227d87d24481a870d4341938a0ae1f1542b46ba6595130c00fa09500a961b531b85e9a33ccf5529af2ef8e7865a614a38c171ab026cbde8c6f81ec426f146326f40aee6ff6a1f1cd7a27d5be30c624c3e1dbe7dbfafc04d14e9c177157108a88d72878fd7f3f4504b9523ce0d72d5f16c93656a543fb67dc279cee374e099cf2b0bf26d2f6eed22cb33e088656449122d31324ad4731dd64a861c21dbfb44315b5ae0b4a766ac078f511d5ceede256b6fb200532c99baf0b24db87c32f35874dadae9af5fba549bae1fe20e02217b968e5da2c9a2b0afef08ce53d8ace33581cf70428a5dd5f2720f81ec3b62aab168608958205347407c71d1546b0aef94bbe9c04453ab2e7f60b9a796040aa30e175686bb4d04ce57bf85862f98a0c7b88a639af02c2ca675bf37d75abc21bdd29563cd6b7793fa19e432a4a018c30566a420c38b5ad43bf9928a1c245e17136f565a8a03cc57c893013a4d46d8a4403221e1a50b1fcde33b52cd622050fc7ed174425bb5c013242cd8ddda3dbb2d4cf97a44c81f78b6b745c2467f5d15ff6d8ecbc9229a266c7bd40fe48e91c170a50da77c8504a1ed77710c49e137fb5960d89c4ac773834dbadd95b799945eb8eec28fd836daca811758509667e31fda79453a755a23f14b6a60ec367abfa3e591891578becd54205746e5a330e1a02e46db01d39460477616d4ba0e6c3538a58b41e0653b6b436b56f0a11246a99496e2083e2c7f9af913ae688f13790c4083996332e5edc1e51ae1046fb20702e2407741e8ccc7dd16401ad246c105b0c4c6b40c2397f3b74226a39b69578f81cb9c3d90f7d0365a278f39227a7930cc8177eb953845814569551bf09a4d376061e7c1b2d954b28b5f7feab3831a83fe02c3e04260f6ee63819e9f210f44d3e7af3f352b95be87fd1d722ddaf7ad71a8ac85dbc331351c612b97c5dd3b53de2418435170ea330100c6217e82821ac58710743ca51b7e96025889e31304af5facf76e2c34290c5f6ec5eddf4be277498e3f94d3f62416b981c8230d0a5d3ee805d765610a242722f2c1290d9ce02550722f87c441021c13972604cf66b5a1a0919eba277306df4030d171ef2b08886a2016736907ddd2b8cdb9b35ad02c134eb7b241be0526cd3147f12faedc7d4b7d7cc5fcc703549113b6e7d7dfa9b5fb4ea34574977812849ecfec5bb41946ac4caa64cfb67a43a26a3e80316b556d2adf5c6a54c8da30085639724646cea0214ee695af0be376061531ea74a8a1944595ce0d39c306a01d3a1a9b16591e7cf98272c2c81bc75a05496c0c1377107fef49d805e7aa04cce4ae07ff76655707e194b76abf480be4fda4b899de7c597549506c8d269f275ba0ccbb47a80ac414109f4715f31dd347cc6756d8a9b2433f064a4ad65e04959859565ee2632f7ee38a017910bede2f3eb7e31946fdc7f6c247019003d7053b56ca1d36292714c89120ec51cf7b6993e7b882223336e82ee2940bb12363aecba6c6e531a619ad11009926a8070db218f7f6497d868ea369dc75a03030d6a64ae868743771c3a4f8e48c1e00ff15b6c94168b47fedf13c2779d4b95724dcc4744de6508741b59b940cd000cc2e3934849d51728ad42a7d5ba845348918ff5f9b84ede476febced1c2cc40396b7867bbd9cd3b711e6c508b7164b51c17620000103b4724536ef46748a6c5a539691ba0890ed0091d55a52bd5deb4b3d0f6905201b7e64afe2113afcce4060d0e3ece25edc79da55171f0a4b0777c6b54a1864d7d591210212f80ddb6bb20fc029b520b76d8740492c48dc0771d268f1d214f598752096d40ea48d11560051e45b7cc75e246447b9c53254a0b1c91430ba9ccf63c428ae4ff715c0bd03f266f2c90c94e9066ae3cb7b66e616da2a5147c059b2da971f7c63e20b1c34838affa95f104e0aca69c6797a6ae96e0a10ca5a467f971179b18bc2007438faddaec7f7288e51a2ba33501ab99c55895069b031bdc3ff692265133362527d5a79f4255049ea7338529ec8031fb718e88c5aba7e7318f5099817edc53a0ad8d7fcb4a7a3ebb78d39fe73581508af96e70a38d56f1c410e5f6b13946f5900a772c4777f3743e64e3f5537936b038587ed9b58b01bb60015dfd86f5b0384c535e6c4e345db9960770f6cd20a12e1b762325352a057f824b6801f38bc90feb8ab6dc97500307ec3f134a53f4423825739870c02d47da79cf75320e4a1f13a660da255a0aadd854be07fb1bc74b4a61ddfc0c1968fac962e51fb5e82692136ecac32bd77020e694dd8235bf1488f6dc9a0b4d1b8f72e7962188880db6723d59186a5281caa0a535a425c11b2061bbad2211bf8348394e0f62ef528b06e45360e0d1fc2da7b17d2b29767f234ebd0b5dcfc16d6d617ab801acdcbcaadb79d3835288dbdacf1ab59f0f82e3c6bca75d454e7c6c9fe9438650f805291ec819bfff6d8a3ba29866f04643e6bf5c1fbfc5c72d70e513337323c053481d8e1bc664ac965d8ca1f6b8937442558dcc7741551ebcd2d1e75f52c8e5db14036c5a1ac683468713cbdabe349d203b300e254b28b5875c30aa144de4aa5588faea8f9d980e40b2440f48efdfc51a27f9b9921fcc15362ba705f5cf4b898d5edff44350eb1f721baa07a1fadb37b8f90419ed0c96a337f8b3d65ed40d13a824589e3d360b7d463d28220b28645bae1e210fcf32be2d1dec08674cf9e39e26dfa27701cdea2655138aa86e74c7c8ee9f882a13d698f44b1b81309aa8da49dfb513f28ea3014daf4ab23f47a1a9112529e68cf6eb22ab9ed6c161678681491295786f84fda5a39e20796c37d4e66988e1b408d39dcc6bc0c8935051a9c1182d565e537a11fdda9491ac92a572e39d4e53719f1bb29365e9129ae65c576d311b4ca448605e6128c0ba442725c76a3bc9635f3b20c88a619a29cc97cd07b9058502e36be632b4e1d49b9322ce7eb7772eea78a1f81316404db13c3695b34d10701df7cc1e684362f156af99477323027e454e225b6d059a04b01d0cbe9568b1f54d7c8a8f3aaa2152005ec58dee11087e674819242eab76bd1fa42015bd34424cf870ec62306e4164cb8fa29719ed9ebe9bae20c2e2a0884828dac67a9c2049a4b62cae5c2da1252422e57afcf4a268bd6beb1832527462ad699523df41e59188fbd34bfc60e462eb99c772c0a5aa24d841dc0d45818a137f42dcd7e7c8c3632e3a5f38ce47e416e3ab7f907b1668c34937b238d64791ca7f598d050b01e69207ad9f0bb736b587960d87f0c7399cb31ebe8fe28963c252297f9dd51e8dc1b4572450ebd3937980b5798bdd40872ed804cbea4d894485c349cfce845d809175759be6b66519a4729219edb96e4d4c9c41a1c518692b63cae12fdd737d99b4957e111c3a7079586ba8f6ea08851a79923aabedfe84d521d7f2010abf2f243d621094802cf38d06fc283898e1b4e8dea08ce03b0b5015b9620861abcb30b33059f8e0b1d116e6f43c5c0dc04e5af1c68174a01e17b129cd2a06b089cceefc242d760fb3d890f23f9ca8b3a4db26295ee684b091f0f0c2054fadfcab12f369b967819549b832e1fe3d819c515c68b97349e5271b7a4666f8580df6d8e2011eb8381935b3b07d8e5f280cf9b96923d97da83ac0450cb865fcb0576a299183e4ac8e7aeb2ddae50c9b0b5708ea50d35a8b188fc52c0f0d0f4b72939ce6fb1c08f43b2eec0bb627a653e4f019f14a82f45a1036cbfdff4effaec90f2320d3a008a2e519909a690f6299fb25b46a5bba5b1fd62369ed6a710eaad254cbbe2aa06e387c5ab0eaf88972abeeb56bdbfbbe0e9e7e88458bf7fde0e837f7d069e2da5c21a20b4dce230247fd83220e6c857ca916bffed335d760cfb7dec853e5cb563c93273a6d7402b2bfd6c6bd988296ddd4d21e6bd6e58c94c5814c976e707191a6868ac28393b1522286cb7aa6ec6e033a6166376e65840f0548bc5aea77794c32a6a7b2c7a394ab6ab41b2b51434edbc508d3d92df51f7875e8666c9ba4b06fe1484457b8fb94fa7e328f8f7f6c12c152db6115011a735a6f1ede41432dcb6bf7493b793e3aeef2f1f10cc94a49fed805918478296390604634c129a7c863d2bfdd3695127140085e58a4ecaf77adf8ff14be6dc91926c7bac50946c0ba972cc3e9ecc24fb9ba23e47c4b6182fc311f689a30ff49520089644066e5107f7df4419bbe4972333a4402e10c9305ac8a77e485a9b62eb6e23d00dcf999716c2a10900eabcf62cb78efae68df1f5cd6d0dabb9375958df8c5d2e6a46bbde0a8df2a06df6cc7a7425a4da5262d77cb42b8b9bf3789cbe23e262787fbbf88fea417a57e747c3e9e1392324229c9f001e93c9bddbceec1b816d76a209c71224cb9bab8ab050d91d79aaf04feb34172b55c369d55ff3c1b0ff3165c231c175d43f9d1c2e36713ef6f5bc40e4a750f5a5db7d03667401e501f5e8998d4114f0a4fd2747eb610469134fa41d29744456b9571c40dc67fd6a2c18db34c81e8b4b4f07227818e305453af8a662a825865d904f2886899ff36b0565e1de231e32fb0f0bdf8e90039e28fb00c2a198b0d5ebf2b851ab1603e18c81b211c9cc533867da366f8204c80e06ba55be02ee74de767a23e3914d93b7d6c018bd0aaed677ffee5bd417b6a0c3e78c745848e5b138e23ad8dc314f3ee8c1fca8f5e18399e1e316f8db66b42a3e818580f19b57e5d840e0a9146fbc63433503b013f543cbb50f74d234d59d5fb384e2d3c9c31042fcdeb03748709ecc4e8f0142015382c004366f4d2f382d076c2a9187c816ae0cff262e9657ec251a06def751e11f2bbfde9eaef289ce2424f2d75e88c83b8565c5d3ad47852d03bbcaf7ce9cb60a80f651abb68076dace41b1c6ada5daaa2ad80c99702ceead5257e3fc2e7676e635bb42b068291d4e5c45b8da6e9bd0e651138621fa308f567ace46ef69086ff33427cb4e6bd9311d5c9fd5922d6dc065362cc5ba6b14588c829525167775f3cb45c5b12be6eb797251621e4f607e640b3672ec1d1de16ddc2827324cb396bbd8debbc376b456da0eed020641cfbb697e262d2df9246e231056734a8ba39d66967c39783fb6b9d12715522f749c30d3cc1bcb77b679c401ed6f7cd977844bccb0ecef15e2a96b3347c7e8eb81354080d2ad6bb588eeea3b6faf9d5c2b150790ffc41a647a04ff47602619bd7d31b8d73f0ee76f99e2fb11b3db57589fccd557c2af9e1bf55395f0a1edd1e5341d94e8ad5a9da82f5131aad072c53d9a1c9a7772c3b69afba9e2006dccb4581ed295926d2d6a1f667b809e568cdcc030108d5d00a7dd83ad886aba126a9dcd98c6f63412aa66211c5645b5a2cf39d8beb94b899c83bb974af4f5f190871e10fb5540055f0fde6d55b9aeaa9fe85ed84f0905c9d3ed87363532d7b9132ecc1e5e54309b9fa30bd9b54e38955f0270603163fac29e7ee9a2dea7be31e4a9795f0fcbfd6b1676289431442771d737f1b4ba770b589b177d5f1050f23e8559551ef219d75922116281a02b684f798bd62714b78a2585d686505b677153b1946ea29edbb0653f617f8c35bbfe2fba5d8875f6c55e0dda084d275da1fb7878fd14dfd73aece5e32a7d0c862697e5a9aebd1a5befbee8383f00d5a97b43c94cb24abc0baef410f59bc71c34613bf8109f69eab9d0e8e29851fffe02682ff5df815de6cc973ca58b43c0ae89c3fd360cc0271db438ee1979f0516134c9d75e7fa7551b159c0081992975361f9f82e5d05ac4ae95adb8f34f1827c13a7532d61c78f55825309419d02fe085eef6ece8d5007e9325e6cc291d467b17b0da27f803e0f3dd02e2e5df6e2f3b93107e25c9eaa922cbf8dcc23d4376337577ef2c5f41eb27455bf9800490027d73273f443bbf2a34d9507e01d7398b1f20ead133fe7e01591959ca28765dc70c4ec14ab22c261bfcc63aa622d8cc1b17c35ae65bee3dcc36b73c80603dd75eb828c2ef5afc65c8f860c4b316992b4898b4269e9bbd91f8d957809a4ab5e0f2031039d9f41d59381f7d7aa744dedb6dbfc2de0a3d54cb6c2806be0d095eebd7c1710e5bc29330ee056ca75dbf1efe7519d9a7ad4a4e5091a7d3ebf63c0def3a76f77a0d958a6a6814fb6909ae1d9bdc65e6478d42205dbc9b9149f8b4cf78283e261d5aabfa4680037f9dfc5acc9016082ce2b1181b3507cd1c80b8914f3b34b862e7d40c2ddf43f7935a2bb43d17b9f560de6956398b412cc234f448ddccad1cde8a14035f32f84b1d4452a6aefec1f45a7908e11c30cd95a6f5ca6a7ea183e75668f28081f62b146f0b64856f822ecd15f160c103306ef7ae3866600712952e4647444333618a54eb85686a284837d918e3afadbd4a3d0b40dad37f2355328c34838973ae2005c6f8a0f0410fe397319384fb456e07cfe133e411b07b6ca16c141b58652decb492c84481e9ede9376e1dca27f1205d133409f7404c746d7428e95dbdfcee5ffc02ac14fa9fa7dee173fa173610d286d5516df36867d9797267b19d470b86a0d5d31a175f142b7b4a6d4b66c2ca563e9709afd41cb309a3f76646445df410c2b9221716075478fce23454f35bf9a264d3dae61b3c77868c619b9770785b5225d30208f0b6f8bf28d725a4369c1f4a67129947cf06b989ab58c1f6d1106c5999a5281bd2663007c7e4ddd2715e9933b34abd895de798ebe8022b1763a97672f633d249d270586edd10afa28b8024cd3e5c9881ec519f4ac911e9394972a6b889388d6b6d912e3b1495ba677a8265a4978412a2a44b268a3725559b19b766c923bf0a67931daed95ad93b9a2cf240d7b4c6f856f3e8bb9808fd64d711cd60a92696f0afc3e226ab4253a6f6fa7373f594d939061a62c815c825cd1959185adcf5d086eaef89cbe39cddaf64d3cd8c4becda1fb59fe6093480affaccd653a63d410be062dacab6ad4f5a76dea6e4c39c3b480a73ff0c4b393fb308bb97136fa5c35b897a2b7c081bd9ef14d0e47457ab0602ba4491168c39bcf695355b9799ee63a83c8f967330534cddce37c4977ca87fb7bf4cb64c317c2f454315937f08e54f1288e585fd4d5b003d6df69f9e91e248ab4ddc25239941d9f35c4ec6fbdfc1d736d483c79166d4f3cf4e9388b7e2f6a4532e4643c4dac746fc72507d91a09842cbeeeeab9a77b9a8d3287bf66adc3ecf5fc9b739ffbdd18116dee518a06db6e684fb0e9995a31c88949e2084e4c0e7a50f67d2f68a10026e7849f680eb4d86311432f00e47ad56a1ba0b6b83fda173a493236f61099a560bcae041097cd90eea2db718ffb7a55578bf047a9ff44fd795fb6eb92ed56e8454d16b901bb57dba43e99a0d3c5352046e9e6985a7dda7ca21f0b372309063aa699a6c24f516e6c880d209402df35877784bf2edc4da2105ee2d2a35635bb004de728edeb24e3c818a47a8aa68854300c4406e492662c76e3500fe0f27a3b7e45b58563d86728df32683c53238453786f143c3a6b553b72b947f55f758030bbc4f12ef9706c1bbc7c6b1d7f371cd616da8a839c33838bbf35d517b6362ddd5f3aefeb7882c09e2ea5444f98e696fdd453616dd93a792d0081c579e802a8d8a5edbe9307fb58a599061a26a6181b5b96c76e1531197c5243d1d7d86220feb0ad073fcb3fe8a71141c6f6ce068f715650e167dac357405b03bdddfa16ae31442af114b631292a5355656ec881ed684287d9f3fbaa2fcd5e79cdaff4cdea7e4a529c8a5af05a5adcf168be8096296b9782f9cd8022e319d746595529165a6ecb4799c295298a2a3609aa21d867ef5ee96a64e37a6954d30da683228fbb630f44652e98bb515721c129979f215089df5b110fd56eba88c355c425d8aee61afeaaaa58ea1823a11b9fa1d0d1115495581f24094cf70f1ceee34f3d01044439621a7c215f49de051be354554ce574e65b0331f63be427987bf58ba53e79cff4f10ff460b22aa4fbc8ef89189d0718abb8bd2a76e60d3e7aa892e8b9a08d402cfd94643b7b51688626e6bd3855c4dc480ad2ec5168f9d7059c419edb0807efe3b070d6e07ffb8ae84c4e249e666e6d9275b67c780c61f251cc89f854c3df2622cd9afa5678d0d2fd83286805857ff99ad12aa00e0af7e75b6d932f3d8cb50961e0e68e24ab6509d68523162eb7050159502fbd538d19eb42dc12385ee4f8d5e38dc9f91fea1665d574c6f3df8eef5ed329cc58f84e58081d377d3194ca3e2b7b08e51e5e28b9c8d44cae30965b5ecb33cb2bd115fdf494e8730f57837ced0927bc5e29480aad1100cfe7104bc2ea8adb8669863839c4fc3479dff6d2740f22993291d7d1b5776d06f1900a92abf3e10b1a5811975969fd448171fc1756717d294e12a6c26b3d3b32bbcf87e935297caef6272d3ad752130dda23c3f034e8425fa8d9d7f34a38f3c4f557032f55cf609b1b6380ca71e995212ab48046d6e73dba6704017c28bed4224ecf9b8ef1dfeb331da5b3a4fa295618059cb8a90304200db51a79543c5dfc710885ed29b8ee028bed17d1198812e4ad2d71570dc6d8c5c081639cd21133eda37c15f24beb1d77587df22f21e31b162833833f65956f031c60cf45d0cff04c6c218f0f23fcbcc2563183f24b26e5344b399ff4c7a532c8303bb1a34066ec6a187273422f06698411ae5ba028b435eb20d39daab7620b92ff9852ae8a33d2a70425b7b7b35b47ed9030680d4f66513f7ca1a8272f2dcbaecabb7e60d73ec6ac815bf495417df6db76969fa22dcf1cb3facf6c9c787aa05485e9fc54d962e9731dc655f9c39c652c7df087268cbd1974a3fa5be2e1d5f986b195679f3826b480017cd2bca52cca63f3f7c71e537649eb2b5fc802ff0fb7c9e069f506218ca3e8ad74bd230845f927856ff84af546b151d3cd3baf5af1d7e7835e3285e7b829722a99ddf3a29a09fdcaab93cbc6fffd4f2c190aed9a051128a351e18644b316417e7c7afe43af20abfd8dc7a597de297f34638c0a3b00869548ebee0d98931976273fd9e36a13c2a1082d0a70c6e54fc9f45d7571875c175c4a7a487e3bf7722cf0f2c09a12e992a6fe17620fa7278962de1b99a2783859401bfbe399eec0fd3e13403fe3f4c7a6db071d6050b756a8e4306b239c3219cb094c38963a87d9953009bc5fd7412b5126ec7f88d8fa0b14911fc0e684e5ea0cf7943ecff67b73e5267683fc2f9920a32245e9a6edcea9cedc019a0ffecc0cf344f20f2f9d04616226f86c7aef5e69b7d83d69f6774b4102757c35a1b47d1d0a20efd724949c9e43c37ce472ca6af9c216572b68de1c69e7173f2967bba444d5bb5efa0e50987f7daba8375810153ed0ff7f0029260d678b4654b53041b150052822112f0f0344396ed6b0f257af0a1677f410dbb6ef5ec86f4dd15b0568017488ee7397117bb41b301d1170a914c87f402dbc6b56a125585be9bfccda844b93702aad8ba455d51bc5234018b0d63941cd31c94e0fddfeb60f82c6435b9806b9072e4c484d6c2d03cbf12de12b77f04eeae0b50d37ff63fadcb066125e1704c85dc7e518573989c5dc9f625d88212ef3362a1bc6d854d57fd7722230d51de5d54d5259fdc628b15edd0d82b3df2bfb1c7e2ab98c95bddf6f40e659145cff0dccba23e21bd4a630288d12721abb9948545dc3ec5104678cbf2955b90e4a30a18311816269748915397533649a3f5fc24aaab0755084188fc3206a648cd605181aa32b9750f578c8fb9df711bc8f79900e8ce65efa0b8c46fbd24f8747ac35b7b7981cb34db3118c4d65e3cfb1f332c2069772376cd91eaf1183f198c1760e845134f928de681a7e152f9d7f9826184ae0a3af7205ffd299f1f3dc9fd5273aa5b689cf1f094ebf90fce1763a4d2276f956d5771d317739b456c9c06ca5e5dac6d4a53eb7526434604ae6447add3aa2a53f67e6fe09b9161edcb3e4db9c4f2bfed61e20312514f6140f73b3e1ad5ca357c06e2af9683d9dff82f42fa3118b9435c4a7417b0ef59c6d4c9dd4529c10ff61915099e34b76999b6210186bb3586a206c1789ba53b13c4e43246ed95a85e3ea1bdad03e39b1c2e36bce658af684a91d55f607e06e5e2e2bdc74cb9442b5c85ded48318b8e2a061c60102c6973cd506ef4c5ae20d7a2cefa062338c92a3db3a30435f9eeaca53e04c3dd949583ab2a64808c05c2e10cb3ff91ae53db61baa9c6f25cd06d1b714fb2d3cba86a7f0623b07f24613d339fceded7dc7966b6ed037f643813655dcb315daa00f57e08cccffdff2e95c159ec9892fd47159734b90b6d5d1091b489c32cdd30425e181c8b4e1f4637b6a103b60cf4b363fb38d813a9960dd8d3aa281536d88dae4b068e79cba1c4b8d02d05e3246f55778c536b905b9d0d25e3f45cb2e99b61d578d2f36b93a963a587f6ed2a7094463d17db5997c4526d434619acaff3e045fe9e92b2227cc0c7552aef983800bf7c226c8b2d436b818ccd6e329445a7577d631624d6a9578436f7938013e1be4dbd4afb09c23262cd7e30855c2e78c3c02b71542c9cbb11a31aa366878f8d08c6c623f5f31468ebcd1d21edf71e78fe967d7700fa1d4c1656c27cae60eaa5224fa654f015afe94dd744f791b0db893ffb70a741aa09e66cbe0d3004e21540d80c396c9332f582878157382442f5939a13743379e906127dae365b7bde1abbd4514dfdabf1f0110290faac13cb6b35f486cd952d2900ef4d21a5ae736455f5e5e44ce34d18c9e846d35620a2daa441b85b777d3692a4d089d41af75d6daa0a178f6c2a95af315bab15f6c1686e4460d543cbc810409f62b8cf0b65d30ffe13f81a5f21e7694eaafaaec302a500972c5d26a5d101bd6945b0195323510596453eb4ebf8f83587703fbc5853b9252af5ffcdda5ef260633da9578aa2b40133e676b8f66a4dc71d03f828004213296a10e81cc76785aa8f97129f104781f79ecf5532c9ea70e6de34fd763487d24bb46245e8a95de0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
