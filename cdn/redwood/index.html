<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ccce2628933843f9b831cd7bcba640502e830817d462bcbf092f532fdcbcd2f5f8719edeecb70c87c80d89428670559488bc95dca5764b43d41446668d297d7dcd809f9f20f3083138142b03d941f5b316afd4f85bdbc831a32d36e7eff59fae0023b141ef36da6e2a23494b09392f34b232220d0ce852622accdceaea10f9f33be81d1205fb1924367ae2189dbb73f2377ab4cadd14f1d4cd919489a11c3852101af913084c36ed6d4d0da025cdb587d256237b7b27151612fc29773dfdf2a9c36b618ca52a257e8af722420ab9bbf9919c3aea079641ea91493c4b8708e4e345196ffee3c3f511e566236c5fa89a30618c5280da74abc8a57f40dd25b43a9fa063922707fe7d1356e628c60f5b2ae6df770bff485e36504def07ac1a8c736516d6e8543e6790d27296744c9a47a8d1ca0d4751486f0cc42c9af3ee31cd4785706009bfe66088df372f498c5aef0ef4bd9dfd1967582d17ce69e05009fc3bf89562b22ef304a7dcdbbb6febc19211b138a3ac5ddb950b7f50856f33d3c1dc0d02a611baea2c49da7b5b03dbd798123b633a586cff8f3a93d5c84267c498dd65e9d24d0f4e07c3122097fe5a7c45eb9481488e05dd15decbd950a6b8011181e474bdbf07f6f9e5843613927ef6a91bcf5f25357e6dbc18d6e344d48739f2a9905eaa4b1eda0dd0942107d048553de28e377d244bc81565b953794111017d547afc9987132556c64557b2ca29185a572ed5e4315a562324da25e3bd8a905b82df0b7d957fbf81ad66153a447dab8bdca1c00409eaf5ef99fdd1276a780ecd72dd8284883afca9f0f6a7e27a0b974946a25b6bae9b1d0045613a4da214e3e22a541433503e0b86dfe331ffd05f7cd25a6efc122c1d8f8ba496a19d526f41841fee18e161f9ba48b5822c3831e1b548fe7645e98e6649c53f526cf516187ea6f2273d5b1af72b9d28228c07c7744c941b1188f608f5e5ba31a5a6eda1a2556de203898901b78e04eabdc965cda7995a075feea4d766b6c93281c3d6f8672f285e0805f2475dbf3ea7454946050893ddd24ae5876bc107437c772cde28028f687afafc2d26e385d8ca35f952a5279bd72c1cb4b527f92ee9cd95d10e644f6e0d5a0ab8c799e0a356e7e622d81e5eb2e40ab07555d6afddc90354b6b149e0c2875bbea890a93efcb2a0ebac1480f61ac0ac6612838928714f41a640574605af104b5ebe22a9ce718b36df7fd7fedf8df522c2ec8350160efa7c6c44771b003babb9e1b6a8f0d7a9033ed2c19f8207707ca186497264aec40d396f4a0f5b0e8f521fe4dd09acd5927372ffd381d44284e4267ff8b685f41bcf98bb03ed40e5e6fb8aa588c663b95a6cc64fefef7ec3e0b9890c1c8a63f9549efbe37faa32a25ac1bab5580c02a7067e6b47a721e16867bf116d4ff404c5ddd2141086625072f979c5930a21427ebfee967d774b9479aa11b06d5e1e7062e9fb9edbea7c2389eefa8213aae85e09168f6e718adcbcb7840e1319063e00554a2e0d2f043603e955f29ec46636d6a0bd228ac5af355e769e7630d2c0504738a8e8117321386170662ab2564b65cbb408fd9548d431e0670643743b3fe88db3a2bfe823720104611f1ca452dd79ed47e5a92d323c1099df197c9f073a55d6972a2618da99508de1c3469d4e44b5076476b687fd1aa19d1c7c807bb45ec207a7c2caa8989ed14febfdba939a977385e7440e75d86eb512c8ec1e4d93176e533e787422707c2cf14cd11432a0b8d3d6f5c172210c45af75deea1401b7ebfbfec6d5bf262af5c445dbb767170a976075882b41e7da15f6e605ef7b95a12e1d89c527c0773a8fb846cfdf711f1ff1068fcbc426b60d1fbe93231b281e0422a1437bad14d22793c8aae62d8199cfea80341e0ef5e34796a6164921f4fa2cb99aece31d36d36cf76ebc649665784686bcd759cbfa5c1e801f3ed5f97f8ce0e1eb45680bec473638851443203712c808b1326321355571788811b5367a69959a56ae9c37557daa2b81c547d035165b14265740aaf6745fab5202853e75836c33ecd41c09870a4565e774a3846897e58962f41523942b910579fc30f3c724779d75d5e1e519fdca1cef436fab7e414ebfd2fe79d2db6409ec0e32720c6816ab4f1e585f91ed664d17a9d54367a0cb8dd254e16730bc728422c331ede1b2d3994600808739471f3a7bb722b763128c7b46e3d2875b671d049b0d6796ab7e5d865e0fba3cb6edf09fbd080f3af7523fdf77300b3037fddb3263c73edf88e437271aa2952b2f2bd5d95465576cad990f5763d141f1f2e6825940f4579feef5b0fdc898f1917b4e56dfc74e4ce0c4a615737d8ff6ee410ae2d013d4770d0ebb18c05b4b88aa117bbe16ec5b8d4cdbd2157226243add0ebd3689d462a62b4884c179b8e420f6008433c4a3dc56495c430e92e1ddb96d6b8a18507333c136f852114d228af1f7bbafe402b10d22f442fd56ea12ab13db0ce7c0e8140eaebe51df89bf9c7ca953d7bb9478c777f04dda1967f1a6864d03d8c33c4ecc09a3b54c04a97c480b8c624ca9098938be4943971182e2da0d2b3ddf6cb75d40e00cdae3925ef754a700d64ddb9b534eadb1988d231a1bf06b65ef3df07c6adc46d42a2a1a1482713953da110c937db08129428cc7c216ea195db3581e45ed68dbf5afc0b1ce59ab2b845ddb545ff76cf9fc227c8c8c8c713a2b1924fc737d9acb560ee7c18e32ab15f91ba0472e6e88c9651a3d21a3cf26432d572c122dd8f4a1980eb8023b7cc3a3f62317afc14932ae28d560342e25cc7d2ff7765099cc5f2cddb63e66eb3efd5acb2c8361727e2cb7ad16683983c6aa8c9fd8ad0f81c91cb330b3638900b79414f841695cd4aef3cea84226dd7fea4dc892a45863c703c9548ad75bfed7544e9ba76869d31ee9af9f3ddcb49effb894424fe30fc21e704f150edb7b3a51cb08df3de9db86cfceaacc9563cbcea66a8229b40092cdb8b4f38ac7ff2b8886566cdd02d54516ce893b1f11ac0aee69a3821201d0c7507729c2e862d14503dfc96f95ef1d725a0aa0033797dab103c698654df685f665b0061ff8021a8cb5c78a09e0a2a4c0d49ff1fda2b4c6c97147d1a0a09d3665a4dde0c01168c7729e9079e129989604454a904afe76b8da8e59894553e7246dd1774a3f330824a6b0b935cb19392dafec2acbe392a1d61bffede956b58f573e8f71cca40a65a019540dc0baf65ce7c5807f7e79db5b89a86700820d32eef7c9b837db53c206d15e3efa9abaef95b6a1fe25260d189467272a7fe2a8a7537552101633e63bcf4a39f8d1989443de0d0304985538e82c45c24f3554de9fb7533f5f9a13edf4aa2a77e2fdd1ebbf3cd53dbe7bb710d889a2a152742f9a073f3869c720836c2befdb5170d4cd8b297873975b57872aa29a013208932bed264e3a9afc844aa138ae7595b7951237b82fbdddc2482e83c6f61f608efcf2bb732620306894b5645200021e9bf0cff5485912c37abe0ea88aac3b5182311d0478f1c5c2992c2cb58d9b88ee827a81a5a1e0c2920a8488941597cc8ac8edb457c115918edee01c3ec4010d15fe2592fda80bc74791cad129a5820e02c2e8640a20452731b2bf2c76f14626a4244947d8580f1df57aaa4b1bb0fe916014647e517b936573e20cd800951a907f3452d43d89ce2e548741c48b24d633c243dcc8a1299c1eae01ff0750bfb4dae5eea5897a879b1bef3acbb6313aa00b3fcd53e249c9a0a96b6d757049120b63b46c2604c3f037d9dcdf7ea86a76eada2861dcc3b7f4b4a233a017d1aedabd46f3ea871624843d09c8376bdc9c4353c5dec2ef31e06783364d94780aed2e08d1bc46871fda788fc3364aa399d17e2b68a9a11312d68bfbc94eff7887b78974a7f341b388cd13cfa485eaf52aed6365c5e4000de8ec70d05a79a4361d10c4c08566a0db6bf88a5f69622626c6e1ebc7c9175748d89c1eb9bcc7da39b852e6044b06227e2da09d33be85ffb0ca6e03bc01b91dbf700e3b50ff5083beea9745d541c653864afe94b89e9e018a7bf718e3a5fbf3f55ee92db381949ad806bc2eeb36f9ee140a0dc6a9b21773e5d4bc104d69ce8786fcef255760ed8d9265f85e1d2862033b6f48cdce70c51b876f3351e091673a74c46f3fb20e6df8d152be5fa0d86d62a19ebb25dfc8d436362c4b93128f19b24ec2f05d2c145a7e6fbc264718bfc93350afb67ce4642efedbbf058cb343559620c36278e9a536e4d0a7ea41a185c73b67f8aadfd09965941d07606b769c956d0203afab1bfde7d8861178e2112c0b5fcd5cbf501616947734fd815644e98986df7cf38a104fa390ce0cbb33799ed46edf7e552b6558d1863e631024030f3e9fcc379ee330584252f9fec5d504f5f841fa6ab1447b6f26ffe24b8168a876a42e5de50c4935db0291b5ddabc23319116fb65cb512edd83970a67166fe8def514be16a711a48252edec1422dee63359758da3e7f94b7c821f5cd8a9789e1aa8f1e8eaa5a10b0b1403ccd270f3ec233339bd2a3e800ce6162a4aa766da67c8ccf75ac019fc4bd03c87ce037ad314696312c24bba82d99ebbfb2b427dcae96275210ba0f6929ea7e28d3106a69b185cf62567e73336d485feacb7ee3cf660076612061c71477a88263974a780084a64338d59b24526498e911b93b75641dadde80cd2524e9a87f3e4b42ea9f2b81bbfad0714e0afc4641fc68b27f1615979454709461cda6c8c1f0fcdcbec2ceab752a8ca11f795047a9494719eaaf0ab8d3d931b13da78079d45d8d4fcc0ac22b5021761c89e2560d195cdc557c7943bd6816f435fc653f4c3f9a1e4daf1c736de1f95e1b6e7fe84b6fa82bfc2afe26b6d569a2c711bceeaac294997e525bc9e0662fda2cdd1827011f2cff18216d98f2320dd4dfa352765ff7298ed9ac3a23cae071964318aea82350894810cf9dafa40ceceff0f2497258f27c400a7ae26ba86fe86f2eb821a48950402601e747ed31986dfc085b9b1b720e09ac93723e8be9bf78b1a55536809e4426f6005fb729e127d827d428b30bc61332825d7ecb4409a1d85950bf1e1c4d76df0e6a482029ec0599fcc9a0f79ff39707a21660d4ae3ad6996f2e9daaae14f3b74b03db31e251deb79c5d7fa19314c24889aebf6b2d590f2d6e90286ccc12cb1a161e4060e57d6b3197cfcc81823061d51dbed15a0774b3dbf4281b671afdd6b826b0cf6883ae2b10aa975212bae04b7927bef6acaf5b8d7cdf0cdfa4ffa2989f9b954cd56a7476976f65020addad589303405087eaa105af8894f8d0bb9b03951b88de895487750ee9f8cc1691ca200abe70c5dad4afaa0c207ddbba8d78ad6d010795d65d61d454ab2100321203a041ae2b587ff4ef3ae69eb9deb3c35957e0eb1ad9d62680436b6a0420875b637abc2273a818272daef15a3721d578d35299f7428fc743aacaa14916b06cd96e235ffc340cb3a6f779983f2ca499bfa18c302fe22195a527a8e8887fa603246c317ba68e0db22d96d792a21f30797279a6ac917bfdd7666f7fb2603bc50d37c6e617d7adc8ade14396dc0b5508945773a4fd79535f5fe8b62534e39972eeed299d6f85d7cf6e0cb1bf73849fdcf423b30f11ac8bda5d196566eb9c18225883cbd1b7902b9c150f0782c0a9add7ebd9f7f1121a9c3284830934afc7f9a0e7d1cedcc3fa508fc11cae54481f314d86ba21dc16f6476575e72045e7f8d25a93126a8fdb9308eb177363f394fd38651229f62afe9f4af5e57f1899a8b566ea2cd9d0ded9f5cf1829213f4b6eb2b5bec3e571d71eb46894b53265c1809995a6c1898e23627c0b4e684bfd433bd05cf93960c4a2959dfd730ccc82eec5c79dc589f61ceace7c0c8e77f8793572120868d7f93f465d2223e2d8bb4a2fed62b32f7caaab20f74a6730a92c5f9430f68e9ba499059c7cb260cfd71afc7a250cbb45fc077def11cedd2c17f589c6951be7d41502f779dd01414dde29d687897f90868b68950a0f733c8938a72d78bd37c5794fa99ea42423f2342c35dc8b3c8b1af519ceb3e44bfe8aaefb47c8fe0ff860c845871a4b7dccb167dc22a9b9eccdd8df6f86e4f9a0fe466ddbe104d6a4852be10ac1589e616e693efdee8854d682f8f11ccb9eeef83f4a9b633abb1de6589cc8102371a1e8a258fa21755e3cf3f973544b2664cf9a0d4676ab2d0566797f4afd6e3b4a7745167ae513de6c72e9fe76f30b0a73d630d9eb8446d9e5ef16dd0f2116246b503a2fc646e7ed727f1bf17f5d2e340ae51a874beee71c1e8e744d45e2af3603fb9b56ff52c10b8091b31f741ffad8fbe3686c494efa5cd679f78c2c8608f54e1df5d07e7a6ae0467bbd33f898d579f8bf9eae3d6a8733f3500f28de9d528529e410fe036c1a29d3d02e1bd7c880b9daa125f4e73c094c5ca153bf149bcada0c5974c4c84e2452d25885da8eda0f9d381c2f1b48c0e17b822c7a9e04705d202a84700f12111a2c85b89914b55a08c7011809ead86c0b6e2a7984861ae9937a20ca9a0d4705c58b7ce9e03418ff0aae05cc3196fe5cf8f935a636be1dff9f2c79b9088ee7a38bc90271578b94488de3f51e67441838d5456d6dee63917ce0a649086d6165e2ecb52ace113cdb7ad57c5776e0562ad188eeb1fafa10bc9ecd064fbeccf3a068e7a26bf77c9ec06c444c6bf99ec9b8a0e7ee8598d9342fd7dedab328597b5624a431d94142d8199bb460f152e556eb445129f1f564a1084ee1a06e3dc3ddec996ab9728b2ea5a2e5172d1944eae40f6079c27b81d37c622d32b8d8a6bb63874c2015658df7d7330011f6e3b78a73c1032bbcc64c433ab99dca2113428220f02de257a5c2576b11c2a1cb6586c52c968bba1f99f734b35f8a6a2545584418c794907e3415cbac682c82127739266ea5c36bf7558c029d7f11f63c439bf83098502cbfc29d5c67c9ccdde119a4818f1bac31b211695761caa928a8167c9bef3fe832c116365ce92a93ca75f3ad771502abf12a71af2028fc889ed6fb532ed8d3c496c7419d7a1e1253d0a7bb3a336887cd3f75a133a02d445441dcf3227c891fc71f5fdc1a83f5adddaf019ab5794dd84bc4b8f34444c9437c8cb52cf6d26b0ac4b20df4def31f63313a32ec361e108a69f5f0de10c431e071e5178c9b92487bd394a1043a2071be81caaa7ced9811f9609901e428bcfaeebd6eb20168c3bef9e00139a322f4f6ceba267b242543ce9fce91f523c8c0cbc7856ccfa79686d34c03f2bf602a1b217ae7a477581afa841828ddd28005c4cedba37f4507f074c443ce8caa0856c805860811192ab66e71c39ad49c2f80d3869fb8e6c3c71d3c0338d4a8b9981675269a1350c4e0d2a181b3e145da611f42cdedca3684a2259bdb6fb4658a4f27b54568cce390cff3740a4b942c873683755188fe132f286d1b24692f84ce5057fdd51f06485135451ead9c15beea51172e42013c9d24ec60516328096dda2efd391dce1100b3d1bea5d2fbe5b22b2ddbdfbc6f58d56d0298203af0a6942909cf7d4e1f76edb21d909c040b9047261f7c0143c90d27a35499b64893f98dbd42808a5c8de8e56cf662acad1d93c9f1be14a7a2566b7ef6b5ea21233cdb26e49b0aac0e2107ab5fd69703cd387a95356f22c6b6d39870ecfffb3b00fac684c27998b584f72ef93f625a4fd5efbf4e7e4c3ca569d6db3cae4e51e052a1ea0890b9edc9186bf2621b751d442cdfc717cd81f936c119078697e96b934f0272c6c1e16e9de9106583d1e55f96a39766ddedc22f100c551e9f20b74b424a139b537bc08b96eace562d52983309007fa9a5e3e014bad49b4cc207be5f13cbbc090af7a105511445226a2242c95be9728740e1dce893ca2584e731b294759c88095eddfcc9053350178ecfc7c8b19ffaf40d063f3b7f73f8b3980545839ed237f86356f5f0801fac5bb2afd60e04bb9a5f5a884d1c4bd016edf19c6b37dabdfd4f8532d647536d87348957113c80b89c0b880a2decb7d065be53f405c868b11fecab1591a243b3870b8f9dc5498a45677b4d65d09e86b2abc7839866b35570f4b468b041272a84fb669cf152d0c21fc161abd4882071ef685035874b4a3f720b2a28dafcc43a20aeb4a58f1a4851a20d34844af34666c4b96d51118f12733609b2e7998b4d7c7ded1a15dcf3c1823e908f721da30658da995fe0065e0416465b3985177fcd053d31f996eba84b83cc1064e5b0c885260b26c7f9fb06241170c777677ea8be0498ff440f088b99080b75f25b7003d397d65d854c08ea2ed1bf815529e63a1093ec5816b1f87c20d20ae03859d3b4b7084c12b720fba648500b6240a168a4da374a90896b86b3f1a44edde4f233f71f0d4c56adcbab4ebb41f6ece640b26559dc3a5a9aa8d230cd7c05e0e92f484140ccbb051680b3f3af6e0c5348b26ab9a86dab88afd24dec8dae4c2fc29b120a8ed0067f8160f5df510630be564c3d72dee22b8d4472075993ecb728b23f6dd67102b38941977aa92499f59dfb6f65be57069b26592cc50bf268aa97ee0e3694a2de2ca6a349b3c9ed77ea234f4dbe4c42f6f18d2fb6c9589a3f2b31e894403373ee5cf4c1835378d3a72a720bf0f131a3f85f07145af29aa2c158606d64576ce5e5626aae95c860ece94db05efdea505d4c74a8dcd9e73e6698a1e478e6789e5413723916a349053fd32cd7ce9ca25a965285b68bc96eef7e69014aa3ddbbe242dea07cb983e36ec5ac37fb69037ee688c894488fc2dff3ab67f89fc0bd23c472ba3db9b180b1d9ee7e0ec6a867f1a5aa7145294d46e5c6533fd0f91c3bccb5dc26724f808c01dfa4f06d1ac75e459e390d78bcf83d948b26978d4b20d0bd67b567c4508dae5d3943dd39f60f44e49df916bd0ef2ef77874e3c0dd157f2742032e69f57fd93c0df868afc57d1ec0d9db3cf56dad768058445b8fab1a163d2e775521b981eefa20f95c100c9246f524f377354c18b060e10f8c439dd2ccf73ee62a9555ce765157c7c97c96e9a3245a0bfda9404a35d1aac00aea300c4ead17ef056292047cca7298b8a2be12673b8c99e4022b48f345e4f1ebba05c022bca8aab15c8657a4486ab6773357a8d46c65d061d32b7a9bfaa3e98d5a5566c6b5095f59e7bd79c09656824b02e8d307bee736c21cd5d8362302a7080e8a1620ef79cb65f19123d068c20015014e5ebffb7256fa3712e27cba69a05cb060cb947cd27fcba17b95704770c9ce65e314c2d66f0e57fc3e5a02109f20e03d69ceb2bb7e2b78898115ecd6ad46cde9b5b75ed33f9905d11fc1a7f8908377bf34640f4f2dd80e309e8b7ba95fd0f814dd15703282ea563c359dd21bd0d75195ae04ef267939fbe9b2fdb54961a9c2073a118c511c8ff5e7a5d7664ad425d4059729fcdf62473ab6eb4d42f83bcd8b38ee5fe29e762ffc0d7702cd5ee0a74f1479075266770401345597d35efa16aad4a39456923502a5c0119dff6d0c0d3d7e517e244e727a7e52086713b30099f568975651fa982d0937b34e832d24ed24c60baa538dd7e307d89af7d83b483b052d0633a21037930141128af4206fedf934918646bc1e0d77bcf984a7a8e6a1890ed366fa7cd4245e1911976b622b8b8c24744829d072dc8bbdb10d9d6f984c4b330492f77061defa5f074ec738974c21967ca3324444ad7612ea33a1838342570dd56b2508c251da0b55e0a2c5847a1b8aab4b902d1dca2372fec260cc7e627a353501149a4b540555732a85b21a8b454cf57f6077d7998891fd1cc1f233b98cb382e5969f0c99863d3471055f28c49491b45865ab1b17523f54fd3bc39949299bd3d559223fa2370ff53e6adbc878682f3e2da20d47c5b2f41add11a02670dc00b5e2af4c4ce033f194f8a0fc88105e0e63c74bfe1d97cfb0dee61d3175804e254c1f257e1b8316f1ecbe5c7ee2b655fe4262c2a977767e8b9af57316792d8a770bb4144ae674cddf5b2c7b58e6fdbe06667f8a4dce50842bcf256bd083fce27a76e98f1045dbed4a6c52bf2b46e1ba1cba80ad23bfe9d6f9ab1b1092cb594f873bfa96e3f697ae0762c2c799e0dab36d354b16280f7936a895e9dacb6c95dc5f0822c863816d97074657d153953ee840b498115c442a41569d1d8ec4a881ef59c7ee63fef1a966b4e6b7620b86ff87c5e8ebb234eb3cc433d1f22faba249bc9091555618b6140d32d8444c06656c724bcffc5c4513c53879bb65ec86ac70356b5818764ee30501978ae954af8011dee9e841fbd9edea4a37f9d85799dce486d5909f2998dd7586d4512628d4cd9836bfd2e70665563ad0b0b32cbb68ecc28cc8117c8aea46f01c7cd8655fdab987b620437ee4ba8c8cfd643dca9a4b4f0d5f8b69ed59cb9484e90aa10edbd4c9bc88e4458806aead9fbd52a7b6f295ec607f5bd1d7616d02b698d4cfc4c2d484cc85fd75f11656db0666dd37e8f5bb3a950393b054da7002774f1b9450600ce59ed150b25d75c87fe959d94492f538f75c97b5a1d8183cb5e38acd54c30093a67e2b8d8b5b7714a40f5015bac9e4b84a1ac74a1ad706398893dd8cf7a669cc5f04c105cf5fed54e0a368965c52234f7465d191391bc8cb0c1ee1e3e80765fc615643dc33ce4a98b54803479e5a8ddff4e2094c04cabd0e8f15d6d4c3954fa80aebe83db8afcaafd7f9ae14ae811185554d502e307678294d816505788cc293a8ae16e85789ab06029d77cb6c18a39aadf0c6ba5ad6eb395745888958bd32c102acc405376657381e30aa98e72647d34fddea0db546e7b5c969b9d907a06378ed1d1322f57f3ee6ccf2134515386f431fa43c34a126a66b4f2ab84dde6d82e05696d54b1597b80e9f233c6cb9309b29b1f43b93e4c9cb3617c68489e0621a6aed2d39c3a28b7094b042cb81549af515ced97a84de762fd58e70a01aec83d637f9801312e7c90aebe7a1de8d7ca538956cec139f27d21268caefcb16d74550329ef56a0a2a349e1f65cf3943fced7684fbe35179b38f1a520d705d7fd772fcaee6da251b89d661b17e0bb38aa5ff17472f18046adeb0777d3eb3af0b7da86fa41e5a17c5ce6754670c6616e7c584258bfaa077b38c4fc5c185ab69b539f5e978415057329557982b37167454ee2a3f65ff077856323810cfe642ed443dbd3972f8a5374cc6fca296a5757cabc6be820eb8a8a2af22cf87b46875627d73d4ffbbb4d05c70b6de380d925126f7d9c297b99027ef0238f4ebb29a577e9b9ba586ae2519b985f50810d9838a563ee9c5c6b28c2734184fee520726f51d6675beb2b8260bc0759d3cc51ef8a21e1283e84c3ff7dee36d31eba684de8ccc8b57ca7c35e596fb43696af90d1df9e52b10c3b99d41721cb0416ac69840cf95280c72cfcc9f8f0f9877c264bf0b8f624cf449145d503705bc1e0d6149c9b3e7bc973740fd2ede8fe6d0232fe575a3e1a3ce03efbea7c9b648946274b9039311fe153f05472ead3cd136348576d378a028d976826ecc6de07c93f5ce96d0b263f5cbe651636772b2a00fba3e0976f6372d2c7f6bf6df738053c6a1491aa64a67c5d01707e1c8cdb4fb1149f4915f1be69bd4e8304bbed82b46cfdc3d1aba055a0591341f623c66b9ff9f2656eabfba57135410d330130d4ab91ec7af630d03853424517302f2f23aa4a1d2d930d72cfb5c59bbb4504e94ff112c5e3edf957a50a6d27e9d5f4b28823082689a4974d3bd60d9d3a9e406feb9be5408d93a5b7c6a7e389ff3240a9b5c54e20958bb30a5a6fa53c7a591becf0f478a06d97e2f816a72a71a4603bbbc368e92a5d2d355f8ae678f315b201ba9a8746e3645c2c8d1fe9654e5cb8c690abe681da3891a34fc730898f7e25c555373164fb3dbee8a26ca104d4b8dc4c31b0a8a25f16037ccf278ce0d6431b29bf02a83e112eb3a9d1fd4d1db17bbadab64430e52336b47d78712199f83da41c3b1c9ad3d2c36578aa256f151c113e19a30bea131490331b331ae1ecc15875427fcfa32b71d9cbe9fc664cf6e8e303431c69fe6560450cf6a2b834dd04d5a3bae9aaf3914a52e1882fb70acdb3803ad55f5908275f758b1627bf8cf22952c603dc7e2c1cdd472e84be21ef267ee07945dd029d05136ec539aa157efe5adb9c3f3a3bc86a95a4b6c48e2ebb91f44c0e18a2146a9d8c1fd77589f0e820b7b7ed83661a258fdd1917f476088e480ec6ef5f87a3b8af64e00a1b3ee676c9b0cc7f23f63fefcfb27a3cf6126d9fe62dd65dff5304fba5d4436127ecdae7b849348acee2e3dcbd2e60d50861efa20af8926de1249064361a1865994771fafaaee7e3743e9caab8644a7a0af2d82b23a0160dcbaece4d721d8b8b23601b1e391a45fe885017caa4cd0fbfad43ef606d4f4b40bf5b19f60a398daeeee0cf9a81fe2d3d4531ed774128ae5577f36d9b05b8894263b790d476cd824c987ced4c2e1b3b59f5dbf145fbaaae4024ef5e9be86d8f40f308d6e35d7c018f4cd53bdb497fe7ec2ddb0881fac067bf5299a154d490d8deb2ba1309d1e48db62a290f60b3ed62fc6f3d0fedf245d82bd63d13b07ffaa9c369bf00a7080bc30159a75935198d7d0540047386f6eb60852f171cc72c5cf9b759d2b46b149a721fd68a82fca967ab814a849434debacbdc8d78415c7e0324d2ee205e277026b65707b4aa0b4daba07300ad28a8275e746fe47839c26506861a4abca007b0d1f9fbf62b9ea8dd3e210054e3983ba36c2b9a5333410134531af9ff1a366ec998857bbe11f1c9d5a32d141d409a797c9e4ca47a7ac7fbe1adf399e270655ea3db3e7a8b3646ca95bfcf8013b7b7b59932345639e349dbc33d83fb4ca3448b57f6fa9672106650e80fffd9d4fd48118c4e2ee32d99522ce104a524f57c4a84a5fa3a92547dd839946f119989baea9ed016a02b6cc2b196ec140477ac75fcc0c88bd0a2c4e1d0f62cc5668c0f7b27cf1447862be7bf0bb818ec3ea40ffee6d50595fb6a21762a5e98aec95af0b19dad199a34310a99a72cca27addb6eb623743817f23e65a9af12848476e5e438c9809b87335496a793715b79ee3dc87e86f0daacff1e8c188022ce2e08e14f1a72314bae1e563c526588e05967369a682071f8f2069548eb6eadfaf39f377afd0d64e4bce6e11db923614999fb188ec61f9f7380e1532ee6707289ba535a6bbc0c12fd5788d81b871cc92d06e463f9c731bb933a8739d490351012f5d2e0bb913acb0a5aa075f3c64d40cbf96f082b3a6538eb105d1a69a4dd37b01767b50737a517f161bfc9ee3dc4154c8e667916731e9fd0c185f545b5fa8da5e80050bcbc76aac2d9fe5fda8f62e46723a04401a4561ab2a8cf6531597a1b471b054cb53f49dd6486096297446000c218eb50f73a0e88a6ab6e407b3b7a6acc6240569fd46f09751838d661f7f0d0677fa302a531799e86ea4c141e0e1a259117ea899ec01539b43ac0ccc069f5638d20666612bcf9b8dc7f5235ad567bde5dd40bc8205bcd76df37a8ad65cdd5fc25efce6f0dd82c382e6b945963adc1cab695b2cee26134f0de2bba517a376ac2229f0340ebccc8f03f7e05e0cc09ff132ad8e1649c84f5f11dd49444941743572875f30f40d4f36b6946429f41477d708f6293c9f9e78f86c72addc20c129833dbc6de2a8fb8ffe0bf700bcb9b074119afa83fac3aca603935169e90d300f85960ac6839ff05cb5fdd4f391629223a9d402eb1cb5ead14a037d72f0192662d5813b5cc87e657ef370d3a8d9be689c2957dea4fd2fc766ed389f68c5f3e1c8e362cbba6ffc062378a2a7a38c3ec1399eaf6a92b39c8359c37c54f0e3cbf109e380a6c1ca47a45cbad3a95183b4790dd1b3d73fe9bf8a407647e5913c7d096e2ec2103efb49290ec008adf665a681ae69137bee5c9354bc6f63ee22b55ac98f1ca8dd249c1bf906d8b09786c25feb86b2edb41a1521f21e44547d1b81cc1ae82f5eeca1918469f4595a2f36ee11367026cec2088aabf4493b9a034aded231094b3a174eb61545a21c01aa2faf0e615635b49a968d2fb76f1db31fde5f29d65de17504863c45bb1986bf840bd64dcf53de40ce6ce1765e1fbfd73c68f2945b9a51ea1e4876705a65d8f2183ae98ac108417313e81efdc7227b0f33ab7d9c5963f7686d65fd1d5271cc8ab0052426106ea54025703b4ecb31940e1ac718bdeab0c994396299999ba74208806e2e8d7979f0178db6f2fe2811d07f0a34cb5f87c75b29f82354fd64b6827f34e44741f975bf30245f7ce53dc7117aa2cd17cb4403e487b1c9faf0d9ea3cdd4de504d6f1ee1873d6926d7e340c9434a5cb9d8137f1c51281273481e13aba86cd182b75fb56f6f7fd3b6aafe404de854be5d1d1817d1e693e7370f9af1c1118445d4759752a4f28cb64b18af227b94c42fc3961fa85b1d6fccac498d59064fe3a6025e477c49ddbffd2e7511379329a3eea32b2181ba757ec2847f50fd4d4de5fb1226a2cbcf44feced9da171ab8ea4bd9850284e018b13cb79232fd0c29c0f046bb74017e6ef9342fb9cdd1f8fd89e3afa93ed07695a25f7c762c53a35f955360b24616ec724eeba38229c64f542c7d4fd48aeeadee44cbd4e84f1bf8143c1b3b4264a9666855796167793c2cfbda408093bd4cf6d1a33025f3aae045807bde758774be483211b64c5787ab7f911e747982d0b64cb2dbe52d3677c23ac299606156b1a57370de92c81d7abe3b3deef67a8ea8f76b387e477d8c66a174c602062c088bb816b1cad65f734f8b5c21a7378483a377655a649a8af66aa9d8e8204b67a401d6ba04238f51cac98cd3d58679698c0dc3975ffddbd9ee57388545d87c470b2eaeb15a2271f8c6bfcb4afe2bca09636e55a4cc773338d9540246eeef65cae0120664f761155967ffa9d4134316f2da6b4a63942ef27b9b363440aa59f57dbc4aa39ad0035d05176999badf4d37fa5581321f0502f3abc834639efd88fcdb1c8c64b60ff48347cb0b66e57fc3f127a9e7fd4905a763864a6a1f84f42f9dd4a73f26999e12b72f0519d55a427b0608ab603d0c13232c845895bf325c907f25256ffbcd0c63a28b8200719b44f78a543eebb360a52023b916ce4fb15e1dceee3fe81f006b12a0a86978e3b863e8c34db6be7e6f2c8606691819225bbe1351f60e33eeb9d8c4a279f3b0ffdc7fa737fb46060bba48466cec279898e50fc17f5108bb96d95c870e3ed057db97c709afb2521701ff6eaa6a73d9251d956e530670bcc6e931d4b00289c6bf55115caf1984df4f14b41e9db295397bfff25c8f566c35cba1ed903a8a229d4d08e5a7444e541e6e470763c4db008e9a09d5735e1a811208b8d557c4e10b36d86cff5bd363944757dd96ad05456ef2a35bffba0635c5b84818a3ed7b57dd8a14d64a9fdef0fa4c3282b45666d99bc25f0944a690c420cac26da1197627e551645845bc56c3e3d6184da8cd978a01b6c050334cc1b2374755b416f1e65fc8910c07fc1c7202ac566260ad3c105172f9709664022937fefbf35d2ee072f8c7ce87f98b675b96cc0f93796bcf929d029721db13654421373acf72233721c29cf43539eb605dc8fac74800c8d4ae1e66c4a11c93470973f76c629d15a613eab134089008fe85f71bde3bc31b1581305c885ab5df8892938465ad5cb7acd4f0218957878f59da4a6614d52ea656a77f07a7971e0b04382bfc976e4c70e37b4aeaad28d40e18a9c5562355ab067349ee0bce54a6297709de9b5aa363d2c63b09b9d413bb1719c8e94a542454b05275fbe2bbd75f0e554b1eae4c8f54629dbd904d0585f146c30b65c6171f051f799ffe832a746b3bed45111d87f2418c4e8dec76c6a93052a12807c33c134f83926d0c50dda91bff00163403f6df3bec0677703627b60e2836eb93c4b990aa559981bb6ad62276b276fec022062b41aca0ee38845245ae8535d6799f84e0acc5e283c8a093d8a3e3a53f8fd9ea1f21635abbd6e4bc400df6f4808de83ee59d2956cb9fcaa063238d030b379576c25c22d77c0b8d52c2a2f1cbb59725664353819bb40c0184e5de887a58f4edda513488aafdf1598d741946cef4786f3a7aefe9bb30c4bc2687982e53478536011866fad243352e2f55f20b7aff1fe838cfc1c6fdd0263fc2ee372f223bc58aebf802a5d367ccf45b8d1cd55c3651d74da25193cf9a3cbfbcea420902c9e427ca0b00277a82bd3ea523ac36fea625a67b975829917e29ebaa3eee4b07383a2160eaa564062f2732fdc57a92dad28b585200b38af5fec2e046bfa42ff9a134ba462a2dd140540a70835bb01c054c8b44b566b4021017563f26ec4ce76f5cff23b2525c74fdb366d9c603f6df25fd7f1abe606c447c205bafee1c9fa956e2063f79945a44cd4280c810c5a7f93878e1d3806b26decc97bcc191101203fdb121d57fbf6637d43aadb1d616a227ad08df76de27b3d979354c0f2db96ca5a5677ec8fdbe1b2875819237d7167bd608ddb83a7a2965614a58d529716fe19ada7cf674287c904b213d3647da8d253239ad6fe21433a3b087402fdacd81db90616a22da7774c9aa0a38afc677e654ba62689cc5bb79d6fce77d3de2dff8ebec98ff90ffc9daeca23c1ad35ab2e38fcc3be3c45a139dfce1109c77a247dee3df873ab33d690b517d9dd4368168b72507803c472c4c9d7d83ce82a1cbba2e3cdafcda3405cb1e4938fa332b122a9a9c88fdb3709b7d9123326882a7b513ff1deb29d777dca39a7185ff4d96909044ee48cc43255f948a7a769e6117c457dbcc78c7175b1ee8a5238019d02bdc91db0e406980ec0232d31d2aa42b0d26da2836cbe00fd4cee716fbf4e194e482427b5af98f028e183179a96ed4587507c70e8df573159c0585d1328ec50d5e2deced62de93c7a74410ce92836c3598b2ba395100ae724c589065b9c2ecf1da328fd43bc25781c408dc3ebf2dae831952e332cc4d8fb0a26aaa99668d454658a19cf74259a8455a37f2c285521b9a834c03f032f5cf6a09e35b2a08153463eb7f6dee9186145d84441b3d8aca59c7477b404ea765a582a2c85e93032f4eac344968cc1d3a7799e1723bbf143d82e3323eba0b350bb12994a119452f4740d9031db395f62e5c313b7d3fc9f733116cfc6ea25c486ee5a026b2303b8293b81d83749bb4af60d0521765a78cb844951d66ee0dd4b2c7a1dae26db0aa130b2eeecb20b39a67e8cab5433b392b3fc4dfed86210c069b1eea08daf52256bdd7ae255143ae599810c011e0f72188d9a05f531bdc6682c1629e4b73ad8d2037f2d1afb4ec3b78c6ba8ac75c3f4e4d99d71ab728b36cd2a7ebdf605597e2616cf9ef5c0fda8cbe19122dbddddf7d62aa55251d5d3a0a1b7f7a1da45da77ff208b51167efd20efde950b52d77545ca34bc3fccbdcad64fd26047017fcb833c0055b8cd7c0987d55dee77ab1b84389302aba722defc511d90a0cf3058f019854cb14dd73797f30ae92c49a982b3e4a8076001a4ba6a1986dc325e684e394bf16821e4c216647e43aeb271fb1c05cdc40a56e4d352bc0b0c71315ea6d5f0628d88e81fcec819f7bdc21dd684695d7ca053f02728a6e28b9772f2227832e7d40e40696ccfbd6d449ddd04a6fdb526b8a26657542c9349c4a23d9c4a3d4bc36c28b99dad90158c9ecea225aabc5930c7ac87208899a8962fea63efe90edc05e0fd0bacc718d516be0ac450a18907f7f80d9e7612f62bdebb39331b2137109e88fe3f59375188c348dd62818026ea63783c3c2a8d946ef804a002b24dd6b7291c473789c63908834ac4d62390dfebf7ca403749db93466b3150eb6231edbb8436f7dd63cfbeb9b58cb375de2cb494428c95740c923ac7a70dfc66369d687eaefff9eb065c8a687bdc6aad3bc60be5c5cc1c9acba4a33518f3fb947998414b49bddbf7111bf00b3cb724ecbc6d3ba0194bbdc9cf27d6936dc663f6d97b9229906c4432c3b8c24cc99caf2e89e1e79f5dd57147fdfaf321d43318","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
