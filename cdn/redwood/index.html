<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"368d8bfbc994f7ec98de154ee9fd5961a6d6d47e05c173a14e0bb94bfd424b1d694a884e568f252217f5b0785bd41fe9d282092ed8a16b15db64818b925cc47b21e124befd4eea9058fdcf7a3485154de334baeda3c09f6e7a3d47357e59a0c70d09f26c4b35da8fee41a6dba020da5974df3686b778ccb249ecbed8700796cf5b4b4030c2ec77dea521d8149922fb97f4561f23f097691e88a05ba079de8c5b5dc626dd87d3ece4184ab1779c54de83211f70d47f72ed649c6b1871b54b694b0873af3206d5d79f9ad2b5a9914417a9e0566382586beab4ce039cdfbd5c4dc266fb21c56ec61b4f74f37516e9e92a55ba04d31556380dddcede12c6fe013b32998eb6c4306abeab3896ac8eb1faec5db0fa8f2beaa18d8ebf12aefa349bb5432e2577feb9c09948b7c5c37e11c90ebabc0cd2dca21fcde6f3a02b8968325c043e73de50caaa43f099b1dbb3d845cb4eb4361868204e007bf76cef82e263f1224873cec2014d203e74214784d200d953c9976c0827497fc2a6ee0fcae3699da322e7761a49c9d785337cb6e070b1f12516a20121dda575214ad2d3f24eaf40a3c1d5ab6b96c436246176e51235aee96cea5f984d7890ceca0961885cb6f6ec26e6fc05280037b5a77c5c25d7df0a3e4a83f7739ef3821b1fab3f9e59a1806264c8b3a37ac5b4c7708d81e10acfc57f0b649d72d48d975df846a85da329f2becf99f1fb660fd8b97d9bd9f74b82ac488628c4f1573739aeb6336e2e2e1e73dc816fa2ac8160b5e665801216248cbcad2a558953aae946c43f62ce891522cfdaaf9f64d2c67f684ece54cde08bc38997c2c1c8144655fab60cce5f601d91d98da6309990ae77dc8fc08aeea288340259c2c76a735d1b6128f0152bf734d408508fe7a4a17db8341cad44e33906eb03c9527312ffe3453b80c2cba557eb90e6f3165aed876ee4e96d4d5b4a708b46860ef437e019613425c19e54da008a8dda4cac9ee71a0455788b6969fea5748db900c9eb3fad41ac07bbba6bbf9a34f4ed690ecf869c868c722718128737527429f5a5384290b1298432f7ce6531a3d94826c587b5653354b5db9ad89d1541aee6de44cd2788682942f098b0508858d0de6973ddead8438a34face7e22b833e8b43690ec7ab5a06aa78d6a6a7c73f7aadb438da3310f473b7c4ab55c8b18e86e1e349882f8cc682efffece8175e84f8f2626c53c46d25cc4b6be84c416c551eb58d94b2168d916d453a476dccec1dc303f6ea03b46a61616f1aca342c2194db63e7d442351d0bec9cd18ae15f4bd732833b7741c669f51db2adf9c2ec2bdaea5399de88ac1e1d2f8ef65989b5565d43ecf6ea30d721e52215f8c31eeeac3083f0d96e251ef685611a6ad28a809718a73b7d168cd295b2f9076781e9e5d0f90d79a7a9d53268e47dff36d1268dee8822f134b53a813c633d5c2d65461771b97e2125ff71ae0d7a9e7ed5c94437355008ef2405a15afd672152fc1d5117749f854621e26162fc7890db5c2be87cb9da89085899fb8d76fda7e9ddba5640264fb6b11cf969288f8ec81d7499192074ccc2931325fa954475f482b646d7e2f929a92453f137439117baa7c55cd0a002856c07ce222b901955dd9f83ab937f051c597d47a74afadbc944123d1bff123f0aa6c66b5a0ce1c192e799c1b2de92fb6e1bcdc14578ace59224e40490aec339ba118bccc9fe63b7ad281ff26afadd5baa603cc2d188725215707b3da52e37fa8626c0ce0f51277242027fcc62a41f2abd4c166b825416c14299513677a31a9d40feb7339a2ac5eaf816d229e152f13632de04ece32fb1abce548c93a4a209c967adfc10a68a0ff70323a45f8fb0778b65262d6840f4359cf4a49e5362ad41e097c02b9cb1964950b031640bd146fbb140dd8c01edde82eec6e868ed8d4d335eb783f86af2e5e4d9feeca71a44ba30deee43ce5b4347b999ab3da2908d2f5106826490e1c6d79adf5ee764acf1548b1e5d9f91b756e984a3104187470f0b15700a36cf209a57127b144bcca27ecab16693893f533fffa13159722b54171f17e7e5d11eadc40c996eaabdb9e8f5143f503e063d79ffe330af9bc70da085ec3e30f70f1d7b79309c28452d7b2e52afb6875ba10c9d7377f493934482ee212e42a92796e5295c96e706af7d72b6723f236355773752da8d2b21281401fa6fa9562ff8d57464cdfa162c6843f63b88325be1be5f1ba64140a125d9a2a4df829d67cd1063b2368f5214e7fb7ce13d9b96b189f3cf584bca03521ec8675194c2a4ab839b9c812d4a54bc840e828f54dc6c3f40bbb1ea0be0d182269c295b559a4f3a1c6f4ab50f37d1e79987ab16501f4736fab488b9b09d6d4c0838ed15f11f78a6ce2839506cb87edc96a7e8681eed63477d6727ac6643d2182d73ed7d67f1f70d5f1ffe59087380754e4f0f79a5bc0382b6d5d8fc75862d4b24826983584d54dd5e13bffdbb01265b850a3d07111676f8b648b8cdb60e009d650fffdaf6e0072bebf287e085611427184a63fe1e5444d185184ba44856ed240afe542771db4e0ba64c9c8a4a9e548e696611ead646ebb7cca5946dfc09012081d59c0125c894d040c690941e9accba6004ac870941d0cf99296428ef934cd50d731b68bcc67aaabd2f78fb5d201e1ce6f6f89e77a88661ec9d4fa98633693e68a6e824bfa36678b16611337c7ab9ec411f6d63b97513ed5e2cdf4fe6869fdb8c8ad1dbd155dbec63b64ee7be36adb010b0db5bf9f26f14adae8cda8d5e8251454cdb536363eed3bc37ff4aa2074a566c9663bf4a1edbaa42a3dc53fb7075570ac08b0538614b665764237cbaa9381e0e394f2bcd0591e6cf7fe9c9ea0781af9f7d7cdc30ea884e9de35ef06775aad48c7642bb4e1ca266d13daae192aefa91bda920892e12754b5c2f850a525ea5395f0cb01e26d994ce4b0809920d85ee9195867323a06123dea87509b39fd4683347d317fe7eb8a5b05db3ca5b0356fa0162dfde9a040c67b90ce8c004f4d29fb3c8d3471cbb909013bac6b1d7c436811c93d00a4c5863428f9c522e6e8acb7d1cdd008c086b38ab57d141974dfaabacaeb4ffbd86406f78597f89ae841d07608f081a1db6a9b2dfd118ce5fc25c8aa3d2530e31fb56ccc163daeea45b296e0aff52869a40b70977dc0d18a1850d34c4b3b01dadb52e8267d019ae1f77b905109b271649ca8b5d7a5d9393ca7f0312f8567c23a12ed6e15c69665a4cee3fe1b441979d19c02138e2a4e0a651060470b4c6b11f0a4a7198cd641abbd042d5f50b4fe4a23c4f15e1b6710a2e3f8de229bc67644c69f6de2f83a938d8ceca4ab85d886555bf2188b1d5ac08e11e6f22473c16d076e278a239e398aa0d38e6918deafdc350e5f995195c84cef9415d42d4317b0614f153dd4cd4857461eb27aed41cbcb2a0814d37fef39f6225adcd6d18db9e17327d594092a978a91bc4e75a3d1a5d8bdb8b61a47a634a45039427797e787e2e9a06ba4fcb60df9cd802d47087511b8543c4517a693ba5f8cfb2dd9fbd95bc0a77e9627cee56f1c3b1ec7b45c490649819531d6d8d10a22a1726b31ba47de3c8e1515895ecbf91e2728db4848779dc7b8a3fcc08d6fbad733ba97224f05cb3c597a37b9ba090e01e31e679c709103235f20011c2d276d0a2734d8c93cc66114d5ea17189c78d906529fcee021c8791d2c78349e77ade0afd54cbf96889d1a7e5b1c9cd6d1291dd15d7558c89cec2e65b1bd451367932c2e6c35192b8ff534a7d6687f8e16c6ba9d48709737797ff1e3078d22dbf846189db38f48f4f9475d13c5cdc51e06dec6537a03cb6684ee69d390535013f177cf3592b675d9cf4c8c3d49f54dac09fdb5183024f5579e9cbcd4b1d5bb63b37813c1e0e70356641bc85cc8132f6191916da05ae8e817af3a90857ed9373b1975094547018ff2895c3e45628f6bb85a8c13676a96fb4ee3cc4719be2adfb326f7c2ba8b15e2daa848db826a5d33949c84c265b7323767fdd6184b5c5e919f575a86751256672306c822735d23fb6301fbbf3ab132bf58f790e457df6a9e9825f844334b757873f6b61d76d44e4eb0ad4a02a828b58ff54abb65296648a6b1683e42a778924d9d355494338f08fc9790192de93733a90fc195cdc344b32df75caf0fa41eb6a0f521da29dcae2eb430dc575202386ab1559c6105ff46ae9f0ff5b04fae024689acf25a5b75d07a63d717d7daf0812bbb5eecd7690ce6c06a9d143ee0acc4073b041dec56cd46adfc6ab36f759ce48ce6df20b5a736633205c2c2001369050ba0fb266183a86c2e37d0c7f5c1cad056383d9a708759d039505167526eea8ff24ffe417f899aa332ccc3c03afe30e021112bc743156471afe1bad03d7db1630e460dfc01d2865a463b594f74f178d268633c347d0808545795ea22afde34a1252b76efdd3b3ec956eec6a604f433f26b5d9fb6cdfe70940204d9907658970d7ae7edd85b02fecbf87fbbf98554071035314cc3437904438f6caa2db02c5a0e8c5042fd52db4ed53fd1e51da00eeb13f2bbbdfac5fbf3ab39e8edebf4b12fd7b9bdb6dbbd6baea33db17e6ab35625d37cd65367d36cd69f2e4616b2807260793e377f8a5cd95a528ea641bb7980b451fa392c19eae727e675df20f7b6ea379742f97df44ea75800dc190b14da0c7f57642b388ddb5de4c7f0e1b2e0e7879ae37d235b04bf4666e98b8dc402b42cf5b8fbd7989423897a8bb4530e14ab1ecf34458aa2c0408d5e0ab6b858c91f5f2d5a1653c9edd1c5ce1e6e900f788f76196d053ce0092fd433ba31fbaaf4cb8b9ea0fae6dcd3003f2c0eb73dbbad6e805971b713df160b85f7254fb884425de69a3fb1a2742ce2b23a988ba63c6ef557d8a7dce533143a6ad98ef3cd3ce8b0ecc4557af90c79dd21eccf19b372c2184a467201d75d9ceaf15b112ce79758e73b2e3725e2f2e4840e635e82c25ff5f222fd4c2b23ef48ca5325c62221edaf648a86bd4ae58f14558342a6aa8d69b2f5800d1c8929cd783bfb0f6c025aabeb7a310739f809f7c6bc5df4807b38174e5ac48639772a39ed922227ad7291269e8a3a0d1b77b787b795193e14b681de01e689e17172c6775835a79446e562834edf0047fb8fb932e45c12a64dbe4e662d044aa6b8d7a3fa7303b340086761a08d25834750bf6e1d5a451cd9c26557ddc7e8cfb469b711132884c392822b8e981689487c4f26924551fa16b31e7e5f8020e6249208ef8350bf5ea84e88a4924bda8ae2f3cb9d282aa192ffef1ccd25742dc3cd9e995e37a56253a2f25d9135515c0f1bc54df801582e486e7aac3d1eb7c51638490d29a0e02bb966eb553459cf7db10c1fbada616ff113d0d4dd954d5db0178c4133a4d4d19ce90dbd8aea909c568fc16a9cea629608574ed0a56eac11119120e70f19026f823412ef2f3480be19392c14d009f0cab770ef80baf1cd75cad5410d8cbb9295b3409ccdd5555e662ef13f3da50f0f4f173b34385514369ea455f391d159b0fe60a7e239f346f8f3adc1208bf70e39351e9fb725c9ca92e8fb7a4af12bfa6624efb411b2b28df6c164ec7d8bbdcf5424da1ea0aa078af86b2a136917d05ad93d1488e279053ff4d6555c63c04241e89473303baa7c9cf327117340e54ed2bf425a4011d83766b6aaff4135c2b4757e7ee6bacbd4ab0fc986237b0b7823b8fc88b4f3e88e1de89954e2359a5230d62bc319fa9583408e9eabde142873f5abbe436c27483ad63e48eea258036fa1ddd02409931296dc9bee534ed675efbf542396e92a80dc2c31c6938d61e805893cdf2b5fb5279799346949a8313be9b633728789556c963d1f7c463f06480f79f12a545c76dc073e2924dcb748b9430992daf03f884273493e0375b548372c0416735cf7e1aa4f08269ac1885fb370fc7dcbb09f7e32cc75ae471f18e5bd2f02d00daaad73f2d31679ddce3a0205c26b5f8e2ee6e9da6d3e295111876ae05d4bdc0c48c479098bf9e05615767cb13227ba8ba401c9c0d8c59d15db2619f737866ec94a11cbecb09c195dc12f810d0a0b54a08bf683134d79b4db0b056e3f6065f1b251d6ab0329b16d1ec80e91c00b84459dd563b6f8b90d79bdad267208326c32c5403c4622008f7ea4e76acd29d21b18d9298d4e0b383f7c9d7c440f780b7ffa06c23a92fb5dcb1a9697fe61bfae8a0a676243b1b8b907176cde4e69a0c3b873aa3ffc7cbe84d7e423d73c3f7b22f529ee3051b98754e7d24924ae2dcbc027810ae8dbea46be9a6b1fe6ca4322ef56fe477166e254483f43bd4bb5fb1b5114de942d8a1c02696b3c58b7e1bbc9febfaeb83c960be4ff80e0151f75fd25ac2fbe501c6d7dc95137209a537c10ed5b9f55706069df9f3c4d01170d84a28a834dd64f272ae9653f07a8e26fd4fe9d8e20e31bec3dff18434725275c012c312d03ef68324887b9677e1d9e11bef67e9fdcc8212807a1ec9b20faab8aedd25e88c81c0e215efadfa5c005fc8094ff87ce604d72fa62b513d7771d43df7c1e59fec7d7ca67b851170a6e8f0ef392e9d7c36ffbda207fab34087ff116a70e180ef51ccbe02afb6a8570c7c248956ce4b08b8a7767f873cf8dda73c283b8baf0a1d3225a0ce6678e6ca4d581a65d384197f955ce40a210fc391033688e00d9c0ce97648c8dff6c6ecca3bb12b8139d756ebcb8297f741b591ea5b72f5ac85e48360f949588f475b6a4866aea407d2080097853d596c4dddad81417c8cbddf7b845cbd7ac97a40f83d4a5e6b7c3a4632f31649848650b3e3ced109ab384daf791146af6c867a2b5e6bb67ba08b498c0b2a0f806d5b7876f9d48c198a80f475c1179a225669052fbe7919e63d804aeadd8fc1e77e9342b8dc1e16bec45743650d30f1190d1031e99c5ebce7ad6914d15c3711c213e28f2fa9d2213f36e22466a08bcc295e0452afba9a2264b34e82425356b65f58ed8f1999b89ea02aa49a01f5bec849d30a99e85f38862853de0f854a19432c92cf7e6b9ff2c3c25b4799d46ba6a91af7cbd81b3d2a904c1a72511370bc92aa5fa7e7c150170ef03c4f10318802a5003fae040f4af50ec35bbb69e4addc499e10e45e3adc9eea00e92379f015ff578f34778be7623c1631fabd14b9f080f628785b5cf621c6046f1b79810584a7873b767061bc447c05b00edb0b00816ad2ed68a237213390d1572d07e7d8a13041af154765b4215d2fd63d775abe8664c17e100ff3c0bb378390ece73b9677f748db45f775da5b00c8fb5cc1d6a764f65374a1f74969b11803fa5b6b271b1579beed513c3485c68ea5ebe89d6375035571bb5160aa8fdc48bf7ec2c911f718b1832c0eb60dd67722b8e1beb56150b44041361d74701640e927e6e29669451efc3f6bd34fe8e6cd7bb5fbc1b8ef6d07d3c7643817ed2f594945678411e7b5f57a38ee651ef3e6572de6ef426e174a6822b56a116b9c245f3cc4bfa60d34d02c5642910cf6d1baaa0853d5a99925cbdd6c23a1f1f649dd9b73196776f603561cc4b9e38388acb8b274bbc9f1e33b0668f3eaacd821a743a9cb63ecc4707f023aa8637d2e96396b6a8295a883547edbde3efbd71fa033147cbc246e3bfe31e0bde595f7d520be4ad1461f45b4b566b6f1133b9e8e1d81117b02dd723914810e83e2ba8efa00bf71014ce2e64100f36e6e9c52a326db1ffd0d347cf015ddcc867f00210a1a64f289e73c776c3f36d1c8750d5ae6836355e46fcd903b8267463efaa5d7e8adc66f7b8c8a54f9c1143c9603891d48cc4f7cfad2211620358c221e4d8b7858845d15103a3d4de901efa1f2a6c706f30a80202625a89dcfc3fb789f98520d4f09f8e64d48c9d6f639b3e416de072d5ce6e32f83f8d3f5977f9beffec1f09180d6f6673a9d5a3a6a40c8cd113b4a4853e01706d623c765dbe079a995bf2ed58f2f3eb1eb8ea83b3adf59d7249fb0ad20be7da26d5452c2b86a61ad6eddcd3fe48752ba196d1e349322c6cddf511569f429e3507a8b878b25bcfbd81161df1e2c432e47a6d707441993e8602a00cdeb2229bf5dae4b2e4cc180b18af3a75bb25490aacb46c6c21c3b822b1d796e5125ed6214979ed93a2f598f7d61db9e832120e05bbe34c0a352ad1ae59a543e0087926baf9f7cc58b28dd7c3886d16d240a58287be68442f6e008c681bd7193a289f83a70e70f6b7acc768750589a5f73dea8812dcea4e8ca73111a64c5b7a701c95622407c1333d91935d3584c5343c0a2714165e87625db3191d2739b7824d57c896384d1ac248106f50527c406bb0c5619fff466d65fe705261b923a59f05d7d59937e1c6e959273a42e42009b15190fe8c2cd31391d2b70a91b7e98dcc86af9eb4fd795b26f1d9cc886e97fce34f71845c8d2cb20b0d78d8cb4c8dd95aba80d108c85e18bdf9e94d8a117a4e19c3e6f49d104424abfe747e70f6c7b80f0c090e114104afc953db41a6096f18c023cc4b123da337cea30a05ca561b95a084eaa51a6e79fb38b432ca2e0e6c716500d6703c2cd8433d8396d3ac01aec216d5e698c0c13b4a3990338192d352c98011d57cc3ee34060bbbaab4947c3895d607b4ba24043a185507c7409f4fb1b38fa227bb576153d510f122d926aebf6e8591e5f15edd8238eecd307c8a42b1cdf563eabf8cea54e8e275bb2c0f77704b740a01f4a7a0a9f603554e335b4106e37c403abfbf90f5cc79a834fcb3d78a64ca645691ed3dfacb41000a2556855e3d05977f38d9cb1c5e0684ba3b2927d13d065ef95bc2e87a4175d7725a6d8664a792fc5d94252c1d5e8a948f81b6c155e8b07c1566be7138fe42d1bab98420ffd4f04433f9d511ea2e21c3044c1dac0979bfbfdd88e89d39bd0fadf2d5bccf74c789b250a223d5b1f1163559222e52445f9a3aac9a9f9a3658ff6e6e79338533ffc8234a309e93fc2a9d855b1b19378a1a057b5f172613428a34ba5c8c1790757b6c9f3b40d5a8b1b87e8f74f38313b7c9b0d148e923ffa39f93a8679f1780e499a56107b685467ebe7c6e0e200659dbac7a1f0f5fae6a45fdc0db8af4df35b2a9a2d9079e5aed346fc69b5716f72e191bcb9997af7277636600e44772471d386f3a1ff5de0189693a43dbb5ded1ad06a1678d2063a28794f57b653aec01cbffbd11aa8ae5ba6d99065f3bfe317dd53aa219c659862a1929dbfab1bbceeafa7983748979b18b8a518c72ed949f04b7d0bbe5202ab025515538421c37049c770ecde37ef672948e74c36aa37ebc334641528750c2684fd12e7f38918a5af6af13dac3e17e34a21cb7c4594b3064d5d0cbe88c0c5d97ec0a9cc99b0ad4577fe20fec4a860bc39d65277f216676c47ed0392bb172f53a2af37ddcbd035f9895f4054a290643a79755224579846ad2922d8cd4ef7def0b0428a1fc3641ad33a924e80c4d7e175e1a2f4135ad125fd169335e1771fc7aca19cea5b03e48e3c9a293a5f7d66317d1c7ee95b2236f37b2f41da0f649ff7d4c308e9d27d76bc4d254ccafa03b92d52524b56f69b9dbe610c9e2129a581d0679d05b6504c5d68e7af79b317dbc641420f28d2b46095c80012805e50e71daabe182f7e5c968e7839432e8ba531588091c7856c3b225ba75327afc40b64f15b150bf3ec74b2f233c67977f9111ec9fee9a355236b3f5d16fbfdd614bea3b20dc378c5543df8c916c17bbef962651114b2832c2fb7c95dd79ed5ddb70cb73a9590ddeb99f82bca20200f89b80aaae3a7aeed4d0e3f27b968f7d2b80bd539a9812c91df2d8070eda6de58ad4b424df55f659e05ae957c621e519c03f89d0f0e9e571250dd3006b3e7780caa75ed64a565dbc18354b361c1a2ebbd2fa27c5d01b4aea6552c976f3ac47753a6b7594176db7bee582f6893d4c35b847d37473c31c3224732135f56a8a765f691670931e3bfe9ead970dbd3806941a473f53f1c53f7ddc38b4342e36dc4d189201bd40772dd84bc3a0271e7e3df7ebf43ef51cd1a451c31c0a9b3654769a0bd21d53de1052cb94bb600912f0f969b879d4b542e27fb4e9c13169826ab11dc574e358b91f6306baf230bc1f7eb1ae7933e29636eb98827797700a2999bf2edd635a270a86e77d790069983c6c0d23f435f8d829dc8666494459054b1bca222b8b1c3a38f19bc2c428c5f40a1c0edb85aaea746ed19d1f2127a3054eab38df64a512fda3c94ab28880d0c43f6156c805295519734e991517efc1825f062841abd47899fb000275002d871741b61d527c045820879297a5d7cbfea2fd44598e3ba5e1b197893cb91428aa0ac1b29e64099754a0e7c1853880b4f8e82002af7755d4adf6bb6ff8239959d7a3317d7b868385b59f1a5ac97580585459868b686cbb10f0acf1b4d8fc9e43d4499816c2d14458bb14368ea00b891675f44456ab8f170359148a560208c41ccd29a844a8b2cd4895b6eebefe9ac73b24a1fa64631f2fa6132a418aea60b9e42ddf4be76f840ac3374a842a51b3a768c8bef9fec77b832c622174aa7b9d9984bf7551d1041d8ec1282c111c84c3b7a723af424872989a105f898f64d783374c58f2a513e9fa77a80a66719efa453c87e54beee15c3faac66e44b5f8f52ddc83630ee951171c39cee4a352dc25db56a8a71c7ce6bf4098cd8b38b7a50826e63deddef005956fe04defc685918ba042cfb4a662cebde10cbe7d7dc7370ee4f46b00aaf083de7440e302c096d397a3d7ab6b732a6a62b1d0b4bee881fe4e49fcc8673f9382d772a6cf7e098fd2f5fb54265a9df5b9a7560d6cc9d3cbe846bcbc5233402cc092d3099e185d0b442b0fabd25f3d4bb28bb97254735597d13cfc8b0ffe5fb0bc36e069c1cb3fbec32eba32f27837155e0b301cf1c9af6f2f6f9b4a3694ae07a97a2207fe164ce8ab9cc1cbcb42f73f072b8d10799f84594f587bd2a660f6b0c22693c203e3b8dc49694e9ea7634eec63d2a88e607d08079e6adb30c23b34966f5faf864437c6709737ff32eacf455e66e360980f50b91ed399b186e8d79b90d9f40e8727a902db09211a8df289b7902343069429431b0bbf8d6da3ca1a7613b3752d6d1a81aeeb9055c4394e97fa637f46842465ecd82e664e414ed3bc159c57ae4ace54d0039d97d3697a64a1f5a148b14a4747f56fd10fb4d04b946ac8d1e18f9dc93141571e36d6f95abf77c949242f992fd4329bb2a0b8d6219c93670feaaf14a1e9e23f44bf447bf7efe0220b78c533c0d53ec921d7660197bda1cc38ff3d26fba0bc1a994a531e90f4715d07216505ef5645c98f38702a53247e742874cc8a17ea0225868f31917f9ff49f1e92783a0900f89950885b886b2c69532baf0bd2b23c3a3b7b2865f559b073b68a0f2f6478d45f2c459a6323b9ff3561047cd7377810619be52c77476c8b6dea509e80d364d06838e14290f1d0332322bee219bf378efe84f736f84920b3cf99b1fd29334eb7ff212cb0d13ba249c11fb886743e8c3f75ae6faf3548843592a3e80319d777e63f1c9a302e51a875c32b3ccf6cc15557f37df63a2e589a97a5a9a1dbd1f4a9c4429f05b0a5cce43c23f5ea1440dc5604fc24852af730c1a5f930e47505849db3c15aaffb7c023e1a189224670bea14e9fda02d5fb51c7f23e1f4b4d9cd164a8c3532af4b225574e9578e06ed8377ec85742c477fcf1db8e2c082904f32ecc17ef99b09e0ae5add34717c0bd4897abee3e2b5720897a84983fe1f196adefe2d8054dba8feabc279986c9a7093a1d72bc126df5c7024db47cbdf59a0ac4f01cd7c921e70af074be53c6121070e9891940e2ecc0ab8c30db177454e6ddff74d7f9729215d218555d523b86756c0546cfe52ee9a227eaec047c02db2b08bff681869a82569de668aa878b77959882d16a66fa7c2b5e8243747c2d31df04c73aaafe26ce6fd4458f121f4d1d2eeed58796eda16c396e7dd9ca4a3f2590500851f533eddee22dfd4a1070a2e52212cbd6117cecb37b65080232eb716dfe7a1b80f29498076b9d0f6014e7fa2de865cdb5be388146c078752f447be4fd5a4998dac78d5d4cf7a02fb68a89d23cc1dcca45d9c45740fe9771aa5318dd565ff21fb029abac371cc28f422a826b41fe679def2ee3a64372c5046472cae7552f858a77c2082b626b1ce636f4d139d42dc992ec1f44edcb82df7c99c566ce42a2f350a771d151680d7a4eba43b4db40c07f21d66873c39e05ac762ec9d85f3c16a4d82d17b243a1c1eea58fc9c62c05fac6370dde25edd7ac7ab3c0113934d19f17c8234b4f4903b4334567da2a30fbedd5cd5e3aa7e70185426086473e09e43d65bd0155b92c432efd1fc394cd97a4984aaeae9b09833aee14385e15113695f1451de2a578f2003f51bdaba1cc5ce07c0c8691babad4a932ee0128480b9aee5d01d835921081b6da573745adfc254efd1e5f62529211447340a2d48612245e559e4e7d19568eb9d94150f3e60928ce6e8c4ef6f8826a2d34c8743d0af4ff19cffc30b14ce026d899419b6160bbc18170aabd5351bbdd99af6b90e46996151f376a7d8c805fea27ace8c600a7ca3d2ef614ff03810289ab8650c8b8383b3ad774df03e89542a809e4d8e7c356cce87a9d52f851f756fe128a67cfcdb0b284f831fdeb5c5393df0cf503f64e649e3726ba9bfe63153b88e7b8ad7cc1427089058df0210fbf947aff568673a2fb0347d92e066bcc54c596779270af1b6a0495fb98085a7d57da194b78a62cf4aa4ef96999d9487bf7ba326f7d9f22bcf2a45d1546b66586961b7a0e130967f6138c985467e18534117c7e1c344a483ce649a8a93dfcb587d5b935ff8a82c7b2d23f5bf88b5bcfd8c9bb6c10b52d651eb7dc77e24dcdb601ed2c18b99799ce7a48b0b69468445d7c6c84e76706a87b731916d6476080cac0768b17bb2573c0ed812fd4dc7363f5f3ea9b63c0666742ad7e5401339a30c1bae0457fcbc3104fbeafdaeedff53d9a0667cdf1f98add605ae4f06be49d0121a7f06b92b06f34da7f9afef9e3035d79d5225a706e2b77d0634462c26e2b35909828f3491273f2d5a51ad43d00520edcf60b0aafe1ba2f929f311673b01af4a0b8328e297483e6f04ed269e7dc34f4ceaf8a61e3e0d6a545fb8e745e43c970fadc616970310095103a4f2f5e04d4ef2f55ebb1b651dd7e339e7dabdb6bb61821877d2c30e9c69a92486f3f940197543224bea4b79ad72489da358a748516f18881be596f309717a494b4a983b6e71ccc237b7cf0142d59d43e9e96f8f798b13489e25aa88034e91a69ebf456d33aa36c3b9e0f9b26e1d8cc8751f050c4f4fc44ceeeb526a87dc92f6570501a7c56421078caef9ab25ca274cf468aa8ba82d04b90c9f420b874e73cd59c4913e89d20e5c707b87cfeda2ce53ae4679d2bc5dedd7837f8ad05654cd86bfb948fbc79264e89727efdadf85bbeb8c250081d9c976cc00935d3345cc498de601a82c88bfac2d074bd78ca9c7799d7bab811fddec763d0397f399b83b7fe00f2d41b289276c7dbe999a47f2a7fddb1ff1a079ab10679ed5dee04c2faef1e8c68931947d28edbede3199c244f895f1c99ac989e132850c963fd24c13b2c34e4ee69c9a4edbe8a9716f92a7ace3db755a82219e018f85c80dbe3dee73e31d3f8afda23d80a9531b643ef97fbdf46eb9b0a665dbe8e539858315f892f398cb03776893eadea6bf4df5154cd2b5ed1863372e02cfa164a1f7b6695097459b8c8ed4ff6c15f71961d10818b59958b217e02ce69687621a627eae10087fb1d3082650720814a6cfbd3ff48f75efacda0db9208081be7191a9abe12e164bddf599ff08b08f80c13af2338208c8dc0beeed2dd584ce7ac0d9788c7199dea48c8f8226e058705439e2438957aae39556fb6e9ce76a017c6317679ce1659aedaab384cfc40d031ad73ca91117af29b6f6ca9962d5e4a2fd35ae775acf0325d1d519b895ce555e1fc9d8871a6f51a083a383c345c551f81487aad8578fc85ebe2545fb559af3509fbc881abb78926b96b936dacb7bd2c374150f529b51ebc62acb1fb9c8ce54080c25970170c94079e4b289ce17a072e84d5ec1ceaa3c5815872f1edf213484ff999f0749b5eaadf8ffdcbad73ba93c3d153d08a532f25cc971b72dade4478e9c7719dec6c18763fd5142acf70e248d8cd88be93d18546c985d84d0f576165c8d305eb77707bc00be0d2032e77b0f85c0f709c36e1ece9e6d31b8666d4c8857e7b2d386e62ef12100a42b6b26ed44290fcce97f6135210bb0f1d6adc17d3165f2ef4bfde63e6e8f0fa3ff5f21a626d84b387b2d2ab7a487387f57049a2ebebcf3293675c42cfef0f3fd2d9dfba991c655be67887584e9c01caaefcc30a839eceec8b83aa056a3149995368026224377828a8b5ab03b0335ffc53426e96bdfbe7d98598de2d8d0bb468a47054ef7797a8c8940130ed024e780f093d8c6112d7a9bd1be491d14a291c5025a44f8e769f68dd85a48f89b99ba47c4a9b06f53822b2360110f2d5b11215144f05260411bc8408c97521fa269f0d6bdbe096924bacd8b3b9099307a288d5d24c298229e278045886d615a6ce609a6199ce0e2654f208d3687c79f8b169f399643bcaf42e25b1481da10054ac9ff55ca90829aa430b827836750cee8a65ddb5367b7fc362102064ff1e50ce027b4642e3563fbe58ff499bb94f0376242511bb88432baab19bb547433eba7701105a92bf0804fad17c33b6616461e035d50ff59ac2625ac95fdec93260add8d2fcef5d04dd493e0756d487449eab8e94c4f27eea2b65034e384197c143e622c0e1fb914cb4ea6d16f8aeb71c3c7e589a37c07130c00d611e4bc53264127931581a5d1a71429610c4f3043baa7e15997cd4847e8cf6a49b832bcb24b61ec79a3a02a29c08f8f49dc31e5b39daa939b544960c4155edb493cb2abbc0d8dee07dacbfc0cb6c2270366d233a0846222ff84ce72ef78f15dbc0529689cd7e88aa02ca3cde777a33d7f4519a394656562bd7d5c7325e83ee507cfbf3ea3de703e3792beb4d352d875051fa34e9ddddfd0a39028a61bf5891b88bb92e226e9d0ab610223529ef596f34ae1a8e94b5848aecf02e10ea3a89fda104a54f4ad2057cc6def530807f4e4a45a9c88b39cb6e3541390959e310262395e57f7435253349c043e2fad77e93fa3276a14bd92ff5c318b1c31a78c25114c13488ad52910e4689ab8020f5c5baa369eac4305a755829b103c7f2d74fd7a68292019f033ff7051a8f0fa80617cea9f3b19ca7fcc961c53aeb959ef414eff0215136d0816e1e5a91acab068f465762276cf502efeafbcd1d108eba119148e4747e4f3123394bd5558c068ee0bd6518816a3b891c28594ab64a1244577550d3ea6d848435009ca186915e35181d6cb88d8ca1c568c577157487687f3f41c9e3bdb7d6a0fbe2e7fe4764fe473d63ac71a20c5e150ea6c639eb39967a194811deb7757ecd5baa91d65b24d02cf06b2b32bf0d8bfcab97de74be2be1430b3136e1e2fcc070806f619a43342568511481602aaa320648e82d2de5e448d6c219abed624a462eac6167ca55312408d9bd140abd593882a0ffe1e841a5e8bf7a4533714694936395f0a8c051865a7cc43d7a763e3f77550de43967fd53be17d90a5de2fb9ac74f409f4fe84f0a92cf6f4bcfb03307a130223b0091dae9fc598bfc86f83fd581a7a90f0ea9169f002e74a6baafa28e70a9674b7b7c32471761a9f903cff5c70c08f796f89e333c8b6978fc9ba20566007d31a107e9ca78de7a77930a9c819349169ff425b485cdfb90e9666d1d9e903c4bb325f3d6bee7f1bc2333a58db783938034bfcb708773896d7d719a2091a12bb9d96e7e433f7f39a5f2c01fd93c960ed7b23a33bfca2bf4f46f5a0e6e82a1808af6c8140ee6db8634e8208c4c422a0cdd63e88551281f2ec346d169d02595b1f47c53df49eb8944d856bec5791f38d0eb5e6dda95a8db281bc0b1a60a807857cf06398b6505c13adfc8e05a49d7b1418af162c4f32ff91147149abd3562a6d15cdc11fbda53bb8824f7917581ca853fb3c126375ff6032e54b9b6e2aafa900e45367e6065f08f45e3a6ba42b301c542bab324e44e46632d40f774917a0899ff00b80ea9d9ea64c279a4d4f429b9d998e1cd4607987a6fa794ce746fad9999de18de40cdd5efb5955bfa3c5ada99678c3964ded7f630305979920084e24d53a0174561466209600946b6fddf3db8b6472e3f89e5507123657b8792f947e0c49de13895cc42ac3761bc4b4e852f745c8b650889aec3d2e8a13c53289d623fcef4f199035e6f1f887152b4e6346a2780490c94d98a35a098480b0eb3c576ce4215f7624720816c3084167ad9c0b9aed8e0fa73cad302680bd30c1bb8875e64720376ffc630db18ebe0b509037ffdfd7e8759638d977ae2a0831bfacb55f7209a69ef05388072b2d1ccf163d3ee34edea490967974fb4f1c168bf791fc630af69452db5bf7488295d595cf0198c2764abe9deff4d417297e642b232a8be1e7c398516591a9e74be87bb4b781db047d39c1121c2239f03e22dae497aaf9340d4d31e4ce619cb8cd88695def6b271b53910d9af7d5ffda3dcd8fbf4f30202ed14e492f226448a0bcc2de9f7b2a1765e28bb5fa0d10e767305dd5a0d4efb39d22db1239c83401e04b3c27c75fdfe0fecbf5aed234330331ecdabd3822a1a8034e4cb9c0ac0078a5558f86d94ee9d2aa32cdfaa65632e6d28279eec5bebaf8d001a1ddc6b95460b7dc949a5f2ff95afe6092a63adb6a20f60e2275d06bcc66c4bdb31bcee1bd4451986f43e5d0e5f56234bfc708240f9ca52648d18d3ed5d4f43b16ca06c6576bece6a45263a16a4685845f878acc981bb98699dc75e3dde76faac1e844ba2447fc2fbb29a185106a55f7ff5da447fdd675887ba125c6e476ba0372e369c3dac1769e080344d1f2264f5df5ca88cc67465abafdc6d40cc6a0756d70992628bf215a0dc9faa421e683066c003be6902af295c0bb32e3cfe8297906ccae6f5f4f0554d8f1952d65420ab1a62ee9b5234fb2fdecb3c4ac68c827377beba5b77c6a89579819f270a6ff78bcf55fee906a42c0d83ebcdb6dffd4fbc9a969ac03cf784450eaf665c59c797b0d0d65a51f95b00d2880aee503d5c040c7ccc1321220a2dd9e3af7d5676427395abac9e959223810f793e057190d2048a1d57141f1d51ecc1f8c8d28e929a2276b64381c7cf206bf8254de82c232d0ac9c8a5cf52398359a4886dc1eb1bece69695636cfa15d89f34be4a71e38f71908f40630897c35c1d7de208f6aa9a900c5c2154845c723624e054c6690bb6e08d86e5c2194c54a448b91aa6d8c5cf4d807a4b3b9857ec6819e3392e31d54c19a585aee26402564e864f5a0e858a2429273c17b89c06c701f5e607f57b99042ba798aef942102c54f9dea8ce7b8d490f2bb480843510c350100cf82959dd414d0f8cf1304b1a789392b01174ec9121be0834e35078930c54faf473fd1fbd433d084c176d621a233977a1bd0f43b971809db030b52cc6055bf86d67d22a16632a7f7baed8ea77c7d5c90d41f30035767dec63bd116bf28e9674c14f943f3650648f377248ff9281a067de305926ff3ad7da9a1d864eb10b17d4b526371e072642b1121615d7d4ca110f9cb59c8eee9e5a20e5564d60edf9e03354074532659d177c58d199b6952a746bf34f60b9615c589af69671b6c81bfe57214276e6f02579335a0f6c10b4e85c2f081615b0bb427c0bacb0a1a79db251d23f457aa1cae058d9120529e52893971ffd91c4a3ac5ea24e0fe0341fd8d1416a9bf956bd1e05d020807f6ada0f7f7fcf289d81380bd1aefc65d09d9193b6e16acefd7f2c07a36a2bdf45d029c825d2a651d5cc5fb7379e4029e7cbe109815042eda47e867a609e2ad086ca4c8b7ce5378095a861d5a1f0fe6785c8f13512b2ebf7be99086175a1d6e9af6036cd4f15f7cd4a94130","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
