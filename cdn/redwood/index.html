<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"453ff4a7d92d7fdd420c0f2fd8ec1af939f7d9de4e99b52bad27c2eaa87449931c5156e3ca0842c3dc2708fde9c86fe6a2bd800bb0677a1b61818a5b5011ca537e4f001202ba86421abd607bb1a0b137918fa735dc17aa236b42c645b8183e07bd2e666de48c2799d1f83b1d6cd5be87148eabb7ba28e0cd92716710959f4314bc13579ee6207b26ba96fe476c50805551fd0a5efd8e07993638e59b8de385388502dabb5c71488f51a70fd4c61d3da42162940a38907ef2f814fa309b7565076622b8641c53ab6b1432abe0c7278f8ca2d3c62e0610591b4482840e46023afa7bdd7a63749da77a4f7a20c1ca62493329e07e00b7ff4f6490bc63c9d81681a71a4fe2ef73b2ec6b34edfcee9cd547760e4bcb39fbb13ecbbab7b2853decc643543db83e02c4f4f18b2d5b4386f08b8a3c9ad2720b348283c49d114df8ce90bbc3350c476bb42ddf4472228c32c635beee46e407af878edc9a6c5291e7b78c315cb21e09a5887d5ea953aaca25a6410328ef8f84d3b5c4e9b60de2a98aff60c222575da1986fb5f5ff2aa2f97790c3feb69eeb304a34f9d2354ba07b7e2591b7669f4471ae44b324b59a4fa926b863c64ca989ee7ae504c3863479067ef67db86aa81f8922fbda92ef4859e882ed195084d8455b4fa972d0bad9a5dcb14a5a0506b2802491f89db6d3820463ae206c1f50e43188a21360e1dfcd3ff2fab5b5043d2173b98e562717fdf62f156cdeda0ce53a7c0e3d46edeb1e590fd46c704fe9a1e79a2350a0428aee6548c6a433d7292d6bb217a4cc0839be42c6582d50d35cc9d22f7ae4de24f2231cac31686b96c1ac67262d5b8d57a6cf1cf843122b8efd49e64391028a1e9a881ee2e8a067012b3a90407e8824dcb6059a416d358fa1f460bca8c1b3221f2a8ce30ece4da328cc9ec05d99afe9f38e346ec8fd27aee7247b91884785c1760368127b42035825f2a03f9dd264c69b2eef314bc4b441e5a64405ddb9205d69a18887a5bd191a06f042d847ce90342fdfa74f1bee106d5f44ee8527ffe5c641521497b07ed7bb29d4a40f311283892556d0b49c17364241f57de130cf0b88761638f63a6deb05c9df52ed560fddbd8b9d3d851197f93e16edfc95827a55ad78893aa48ee5158a52532feaa7df8f7688f2b015436d5953e37c0ee65ad8ce3165f9c106c5cdccc7ce43d574d0f3aad426641c7a417cc17213ea97b4e0c9b95b1774f6b6c5123393f606b43d86fa9918c59474a3ff4c9dc4a37ec8bcd62665ec6f96fddfb0100f2198eb40e83df095ff770426bba87bde352096647ff80d86f3c5c306b957449d9b0d992049564d781cd04dd3e8d1fff93502f7294d2eb5fa94dd27a8fa74c030de6568a67fa9c6ba7daba8c0b408cfddc633804055823259f48b4bed4b46a76bcdd9af52db77cac6217a8e48b3864596ac4e42342095f16940bda9b1c3652aeadbf9bbd7cee68c616b7a917417276b7871e40723ca18c42cffb50c0d0985f0268c21a3e89503d94bef073882c3dfe08752f916c0fc750b00e686c387d6271057bb8d4952da0a8e9273dbc8c92184b62f3c1f365194b3898052342261736c1898452d12eaee253c7f149d3ae1e3c5f28cd5152a2c2c60ee33e6a3396635eeef52483998306ad7cd4172e557ec37efa655a79dcb1dc667ede6f1fa2e34b8b27a5d8170c3e3044c4722aa0831999dbe4259d48595ad10f983fd13d7ccd11879c517744dc2174e4f3c2cd4b1ea85a87ecb9791808be648d6bed1caa328633982080a548199272755df3d4317807691d4b20829193f2c53f8c90b0255b2c4885abad06dfecf8b644db02879cb445b453d9e44196b6c957c5beb6fc5c22d8b0e9dc9f515ff9970fedab6aab90e2a06c0ce07a6591f0befbc95f1983facae638dbb3f96389de962991be74e1655f2b9f3b6acdeac26d45493c56dcb5b287a9b2e8173850efb2feb7c799e3933761ec233da1e54e8db46147e003ee869ba5e1dbb628825bdb01f972ebe77f412e2321030270315cad1f7729f6f77a85c8ec9c16d2aad17df7ce98e09051725cc9f2bc2dc7293d6353c1b8de8ff2b6d930f198dc8b839960db8104d82430bde3ac93f865aacace7f4167178ecf09f74941794dce32adbb7c0329e231e336f1971341552ca812cd6288012fbd5b66b21b593283923d15f6f2fec0b440f5c608e56ef0478bed3c90ba1ffa46da495340cc860219bed1ecabff8ed47288c02c3a4f7274a33320d2bdc923a75482f565895dd62b9ac984e686f7c30ad4edf48c377514f9e19ca4d7f49cc89ddd41e9174785b913b2bd8cfceb0c2b3530c0d475caf35253b8f5042c056189b344ee027481f6ac9663eb58573f8cc389af927eaa11fd3bcfeba36450c7dacbe741ec9a034a2435aa554ad7596a928ddda71718b827d5dd3e3e26866b6bad470015dab5f937c4dfac2ad3d7fd21243064e061e424c65ccc53ad86afbd961b5c7e7b790076182016ca8d5b9e113c76150475dbd974cc4806f99fc7570ac6174894b69de09eff3e1a4b09b7bad368ce653d19a6b127bb7320b1ad34644693ab1fb96cb450c40c729031465be47ac8b421bce01bda53894e208f3e96835401af7c8a39e11e0468e1f2b6db40dcf9e70fd4b801eaba19db9a6fa38e321f308d1566be73f9c87fe0d0a7b0012c7f84dd455ba6e641ab93f5351bdd2c3931ff338b013c4e2db2a01b7f0e790e111825ba3375b4f94d2ee7e839757f191b6bd4340690a32393df40a265cc172646eddac71245dea98ec19dced654c7df32bf98c2173b16038f870371fd02868fcecf2418ad4aae786fbeff2583ebafe72a19bfb4d88bafe12adc38439c5fa69de1bdc507ac7983bad1dc4ec2efaaff542f51ea531a4b377303194295340f09afc843c5291f8c113b91dffeb4ccaac23415770d1573855df9276207729d5e4ac9b02e5b383ff7de2f622c97fad255e7d1fede02f9d2c30232ce1504e35fe45ed2c3f8a9a3690dd54741d8cfb13f85a1235d1c30c61bde665966176512a2b2cdfabbf85ebedfba72cea4ee0c41922de53d7b0eeba2495e5a5b6341403d0512ac1071db0d81baaf33025c34e052d92d54fb9c22d4b5e838fea42cf97500224d27482ba4b7b9186404e73cdd83a7aa2ad05669ecfccb28fa2003dedb2e5517b16efe21a1e378ff03a7609b4ea204ad78e17dec6ec82db70d0cbfd17af49d4d22e0c2fe66e5efffd22cf749b77aa579dadbb8eb80c4ad328a17536f4ddcc0baa7b7c7cb5b2ccc8a9e90db88a39ee8a968ec0a8b1ea0c100a9b0d7cb02bf175e70477628611ebbdfc84bdfc13139d115d91bb0818fd971a472179d7fbd23185906bd8017f72f37d855557f1a551af3e8595118ce729ff0dfb3728e6ade7e9d92e7451264ae240ef40af805a91cbe64ce410423fb2da1004157c50446d12337cb0a59d8a5a40384c6e6cf5a0e8e1e6f4a4481c943ad91e685582ee743e8a2c1fd1b558c54ef623ca1621c28f1a3fd42dd088816fbfdde698986654d1c2b9d9d348ed5e402899de78328a82c1d5b3ac9e2cd1d3393a8c173aa5c2074f40e63a8d17d4ec3f34e116e7cf2d64e69987b1df8dd145d51c16158abe6ecf0f18b225a75299bfe2be0dd3448d0adc02a3298195ae81b79fa1a78d69a632fccf524fceb3bcec7b6003f6d4d38011d6d511d72f026db970edc939bd70ce2fa0a3944d43ed1cbbaeb04f273388c5dea7eadb0c60d81abfa0132d2bf72fdd70f6a4c004c639f84af985c83552c181b9ab34cf120052b77a18e76cfe0d759e9bd45a37c0a1203491af7f06503730a5434e446155659ef4686538c984dc9f7dbd332ae8d20c8925dc12e0bb9dc5cf7daf78e83acbbf20a4857597db3e16671b86c589d1282ed895fc6826e3651ab21ac17b14017527fd6fe181114126caccc04ff66979f22b93ac2ac89a183371abeef691b2f01350fbf6ded998e2c46bc6a224b4f56c63d33eb4671027d5c3ab9a1b0a11262515c0eab14dcb60ff370099615d8982bbed3d5aa0ab43f87f8798f20460e9199d10f8de12e26f745760c105a427d32b1c5efdbf838f514e1d251bb1849c3cf00bab3dd44e109dd9d2de4a070f3ad044c5487e1cbffe20b920e8d2a43ace6581769e1bd13cb6590cafeb7cfd8f4caee907951388f6bebe091f2a163a366bbb179aae3049cd4adc6d15e5331c7f2cdeffc8b4a79d1e618394c90a475dc289082d99b5e0a2ae9667aec55648a290fa091cc7a0b393b72cae529d8f6008fb32c4a15d62f1b1f19f524f6e87f173f2484ce0dd5b5614145cabccfad79636210f1b343cea992cbdd439a8fae4a2c719c130c0a8e2aef7dcdb7dfc252c6e1997f37651c5d9079a2e4d79c0646e8b1acc74ec97b1cd3f02051df3d6a341a23a7a1b07a5e3abc5c1e056d9a9d56bf5be8ace6452510c0b5afb519c2ecdef9f280b6a6c1e82d18937f91eed2554d959fbdcf5fdea02529bff654573a99497c6b56464abc68e2a25908ed1848208e35413679f3bf15f5153786b9e72ef2919112919687dc5f434476b084700e8bacd99c0ac20aeb4173b6439a36e0007baf4e486145c7778590e020f3e10cba5e8ced779cfe23564b5cbc6247c062b4978d3823d5a9d89c226cd9162ece1a0b669058b616eabfd374731d9c1f805b58a8b6b6bdf366ef8169a85eacca89fca2f8d92019abb4d802270e2432c046456a52255cf4a81a3c10733a1a1f25b0d7d6a364524695d1709e04f431db9c41741600c44a4ed485776e7d25e67edc98345e405bf88c6da1025f30088709198f83d7ec700fb8397c34e467082660de4924f04dc7d8beaae144bd9b8c62edb2e71dfbe4f22ec2cf9f5d35467c4db7ee7ccb5f737ca4d1a629202d06e6363abf418f3910aa32dd658b9c48104f399b3711f46cfdc63e1ac010fb85a965bf09fe056b24478e55f70da9871f7acf539bda87675b90bc74a751dd4c4a80ea134ffca2451af1db363005f48bcfa4f698e515d0c470fcc870eead931af6d9e08e1bcc8290432014837d3ac57befb28d427d625168e8b9016e1584252b7dff263dde4e5c6382abbe2f24939fc6d667af5e894b8182b1c0add71dc55653b4ffb730f6862092a14b0a435dde51dd95b08793780f18902971967305ff57313a9a528cbea00ab7f17f7048660333bb5d697a08fc8f392b43155d0c63abe37f0f2f4d2739b23994f757ae88ef895f91d5b7aa9a2b3bb40017a105cae3306f93f988a3452662f63e74cd4801f37881b74715b83ff7c8e5a6e244f4cfe19fac994e9d71dea707634b46fef82cb119045654036d0acccd6b71853ec096a5c661c3d61fe46f81ffb4252c947708bcfd43911cf84dea3af4a3abaa8703fe1251c2781236bdf438df4b43e4707fb37f35ebff1524af1b6abc51354f9aa51fc0ca747e5b8067f12a2e15556abf9bb7ffa3402398cb9ecd28981b721eb7123082aab80caed8c29939dfa7ddd58fbff242a61b8a88b9df6a77fac4424d8f117ca351b19e6bc1d1d1f08846b022e14d2d9c8a8b1a726dc23e0088a8fa196cfe1d5529fdda353c2c0089085a63ff7d1aa8b610becd0c3d8689c7c03580cdae79b6ccb02338e71e8f1907cd83ea21cd26b8f7d5fedd9984e3920ebc7531ca8c70addb35dca88db1a4912b3dbf8b872d700bbd28f218f200e8c436a002861b870693f5ed23423e5f15300d8801aab498131d53cd58df492eb9c0578f375ace4f261e059b5a517046ef0b00011b739131459f53c2c4f97276269aeea69a33450b410009addcea738d6c741bf9426b6e12da09aefb805b9a4815a4315fd83fe9edae32ca6aed69c646904941720f45dc65569140e37d804a3824d6bc1258c5c7cfaa4f65bb259d83260fc4b6241479db9437eb6b7405596a074374da519fa488f38646e0f7ec27f4038fc2dcf796aa67a4f458ba0d8e021e112f611231e1233ad2f3ed2ab091c2198fdaedead3c30fc49c26f7a3c468dffcb8ed4b70d26292d9da36e134d94b5b7f5d83f7ec93d83b2a3202f7faa783e3204749caf0910420fdaa99d510d5837412d4dcd6d51dee0afffc7d0128501967a9d958a78585ba5a3cb541705c382d5a23071a586360d7f09a82481abd1347409338ec8306e5d74c429f356c7ec11c002c0c3247b2af673af3bc8eee872b889c6b21262fd2111d4398cd3111e04c61e37247f5eaf7de1981547811d23756fbca4972d83a58599fead2f9abec603a83785f971dbbd7d0ac1bec78f032315c323ef454235a552727a6bb38fba7552c1d98f5cc5769eb98019959da4e4a1dd3bb796fb02f47d98780e344ddac14973fdb0a3000496927fe2d0a5224198bfe0683f4f87c31e4bafdbecb361af852b87b304c0def1831e5831096ea9f9be0a04b5ee3a0c9418507166a50b3fd3e9732220e810c23a81b746e8ed9ae08ce656b75404a59ae1536ef4d175e9ea68026209760d46fb4bc8321a6004e0a5b2aff34b2b3e5ffcc97831e1246da1b8587ab6b961b56c55acf71e009a9290bd41d048eb1022f2e402b2f0db1824f7acb89fabe6f100a9aa01cf83353d0de0270a231ecb64c67794708421041229cb49c2d2f99b5b54570854f7ec54abd79b95871da4b34f9db71469fd2baba1473b943bfe171914a3171f9bd0446561a3a72e92c0fa799cbe875b4905a8c30814e766b447620f2f316859d041f9206f06ec0df089b38077572ed7d593e2694cb6979030a583c00a9b9050bcb05c6bac9fab875b8d20e6cbb53cb17b95f4366fbb04933dc6c5e80e52d2cb232c16bf51bf9eee850513d6901c869f37fc309b3833a37869363a3c6bc9e87fc84258feca7a7bfd6052e008d62b4bcf15de0b2c77750b070809b4427e072bb8493da6d4ec2429f2f0aaa63e98f8daab9df90edd3d7baada03f414b93d8050926821809637edc69bf2fcff8b1e95506e3ff6ed613539aaa84eb953a77959ee32eee471ca99781466bd6b424f7e96b0e13b0744f4a9516ade412221921281ee2a9891dd16884623705612ea23497b09b259f8064eda93d15037fa6457943976aa4fe7dd1417fff27eb9d94e2033a458c072d2aabdb2bb6b260945b5cebd252840f26203bda3e202bf34f73d2b058aac8d535bd1f06687a7095c7b29f4f3d374c268281e07929750bfd6fc5427e1dbe0a4770acb3cc9b308417f60ca165a9c7ced398d39a2b9dfd68f43852b9163a9f5f8ef0506aaf4b605e58b6a74a118abde8e2b1538e84b1272c275bda7d9a0aaf26fd76c0ee471152996b9fe88ccd89ecbeded26fb562515d68212f39cd7ce074cf384c8e5fcc60c0efca2ebb0a1ca3d6614725738c0e6b7153cadd5d65a35d5a139dc70701fe02d20f184eda132723b83f2782a0c9358f4f8bd1edc76c17c072d5218f286b80376f884eea616477a955a794c87c71ae793db4b7418baf85e767190f08bdfd7fd01dbf7d14e377983bb7edea49bb0e7f2a0b5136d5c4138b6b3058f13dc511d07c1277457384b2791778dc93c64c9ae3f99e2c70aaa281a8b99d0fbc74c50afea980461e7a8ee9c69eccc35eb0400c11da5859f39902c415557f5b81d180b67414037a93dcad85767a175cc81b7ff9a0977ed5426f511ba0e7457941ff10951b13f6cda20b304f31a5f1c7ff6bacd9c3bf151884cbed370d8a38613b187ef96bb21b472cb23a4afff1fb5d1c7e20f91d348a615549c472cd8bcf4174b60b24bebfcff0b85576b76ef6f6dc2bca28022b97b6555a57d7d916c1d97dc47135fc6980d86f173dac48e0af9dff1f3260310238800a6a34d0675144e09f63a958667f16512da8c976e354060c87befd4cb746212d699e4cc4e2b4e0dd908fbb6a215ade99d3ebea5a088d8cd84643eeafe2480f07f0347daaba0d5b376fc52c3d8745e7ae229b75b671600168b928f94147254e6079fe914c18472dcd36490ecd6614b1595829a6091cbc8e7f7d4b1e2d8910322df4cf2ad8f3960eb3661a825eafecdf05489904fa19fce8026cd5db809a5e0730f57adf57306a09a18c5d84fa3db759e17c1a4f35b289be8e524bb8378244980f2ccfcaee2300021c78d62fa3dca166deafe9846a0586f4b0efdb227bd39193f95f3b48b6b13bc8725393589757fa367684b9aa9f69f8c560c49bb0df653de5e9389fb40621c8fc0a3fa96fd6d0cdb3607d9f42e55b2f1383ab187e1ef6201f73006ff54cf26e1ee15e390e61408c035b93be40cf8293139ce20f4d5c53aac0cb0985d2d5e839926530d3c6b88926f9c778809cf0a7b884d74972baf342183cc07f835462ec4b6b6ce2569b8bfbabb06feca93557d308187293e036029ec79f675ac1e9b8852a4a0187c81b00f01596f08c54bb1173d2e859a9f60f7f876463b0395405ec9bc62f1dc8fa73a4d44b9de407ae517cad5f93783b4bc54369eb88f06502d073ab0ed034efc0fbb35787771ebfc75d2acaf3d7e424c46f5fadeeb6cb4b31e7b9e4e57465f1614fb8aa83ce5fc94e0358dca95b9111ac2f0c6480c05c2c5588c118fa80282199d21bf368d87dd3a681f77aa7781d2ede8062b0e85f0ac2c90d1569c3998f8725fdcd0acb91e631a4085a7f57a1cbc76b4447420b388aff0786af02d644cbbd1adabee7074947af656809b9619ce4c5b022c410eece61ebdad655da365fc9dec6f43875aa18065bb5b6f2cadb54f95d74150d5059697c02ac17b13aaeeb78fdafd4818355eb16b58f68010fc74b792dd89a2896e8a070e8d0b72f7835c5d577678e04f21557f3913e7b2980cacbd6e5adb2d2977b6bd57a7a5fe5d8845e304c0828a5488f122a30f6694127272c97b305df51400ddd5fb191b956742582b5176b1952e89ac7cc1a259b0bd6981e43fb8c86dad5f6ce0f5edab7fb7868673b039c5879878a0de58bd98f07d11b2d966ab82014f3d1b04ec3315ee60ba44201e8bd607495f6a81c1cc542b8acaadebe411675474c59f34082dc534cb38e50fe0a041feefeeb9b48d3c3af5d4d499467b2cea27aeb0a5633fd39015092bad4af3ca49898cd4054dc23903292f513abcdb816c2ac3b9edcdf336ed2b9c891987635d4a060c48206d83a54b0cebb7ef1e88f4161872f4b96b35bf0179828677833e2caceb381492895e2f68fa05ef684a2eebb66633ba15da68071db00fb1dc8a659c08f3d033b20f5a4dea4776614c0c9e68472572615e126e5e022d216912ba43979f11fc7f978cb1eb2494684acdd4b0aaed413e422a4337492ae3d919de02a076ca2c63f7d39391452cbe3b0f12b0074971c5e63436b466b623372d692e956e5b8332ec2472bbb4be5e66eca5dd15b9bc7298288b7469b85ece58df600b70f6131c782573ccec9a8c69babbd617bac70df59dd981ab2f05f53b5fcb5c1577d22e93e2bfea30c78b563919f28ae32e89b79c40da1ded6a3722363d5bb5dadaa0e8781d88009d61923a3969d9e345c245b2cd29b29ec95e67194112930fa1971e9e0fd41ecdf2dea0934b70f76707b4afab94712d566b95e5e586584be11f15b3051c73d4ac4b66a61aee26023717001defecb1a55a8d05f9931595e049bacab0fb4edf08963614f3454ae11c955d0d70623bf550e9db053daf0d856a8bd76ec437074090a8ed885179c48242e640d823e510bba506ce38c92e8d4db6f75196798d59fe8840831c62b62e90cfd7f9bd97861e978dea6a899cce53c77a9373655bff482038027cb511eb14e768cc772ca9d304d9ee23ab2838ec14e2bddd9d383e8f85513d55b97604f0c3a32a369c434cae3abdc32f5f1555921c294327754a2b7c74eeaf8badadb0cd3180abab657c6a554f003679877920172756f1daf9a7543a6d3e558e7253fb290cf8e2cd8c377f0e0ad83981fd82ab8b968282b4c0d62d08ade931a7f23f6c21622e4a741953f3325d910c0bff463b7be5a7964dc99d2ca918a7777c44bb1e74b90c30b2c69676149d8d2d4dcaf0d76b01c5cc8389aa1f05b7b2480e8aa63a77e6b2dcbb693eb37828baefc2643054ae1b3e375743d22ebedb6c88a08f95a307a376b8bd3d869592b6b960dd4b130d110fe6c7df586ffd73448b0a770d0d4ccf9b7cda37a7e1448127fa7e2db95c7e64b970db001e12c5df47eeb3f256bce06d7d2822ac3f83c6f5c2bf3890d9f8b7540384342be47fa1261f305a003711df980b5fe2fe060f626b131bfd2b3c5c762861605d212946b0f2ff0c101bb08b46be0dabab898d5184ebe6b7f03f67972d030df2ff5d462de144190a0d5b0834384c3c74229fe1975355c394005ec1c0d6de9f88140c98422849bd394d53bc4bfe14023668741bacd71664bb89b79312d024be5275c6e34229b0efd188c3d8321bd4f11b47fff5182add2d43c11268a6e59f8fd053f283d993595d02929a743d18b9716199966d8c3f905600cc409d585405431a9ec01fcb90a15f9bb9ca54361f457fbb90e306d93e93df09e5b1054c982c9b387922c5338ed207c0a26ede6922428a1127df3471acb4fae03426af14801483f5c937c1c897cacc37045a60974a67ac90a5b251fe36bb4f7441d186afa3fd210d2e30eaae1bb06e4752329386ad8aca7ecb05f84048d1ed6a21ea0db8d834eb8813a55574901d4fd1e09af7ef0134852db3174e14fb67d5578c2a9ea4ad6c8c7c52b53c0fc5bf7938ad69a4557fca602d56b64c9091ed8d3563d8c6d87b359e045937770a98b83ea617a13e92468559ef88ae17967b75bf720b3f75e0dae7834bc02e1c8ef83832a32e557d342216fc72f63b447781df9777ac176e2c9ae6e221bdb0fcb2e3bc7bd7eac3dcb051cb1e73df10a992f4a5341add7feaff24223a05d85047591015c94d964300d623fd12f7315364f622ad953027295da5f3d8957900c5362e84adf577aa243f75297217f59615d5cf3b6cabf6a2126dbba977a97cfcddbace5e0e3b89ab4f189c44af77807ece1aa163eadaf7286814c9c4255f0a89f9243c97c0bdf7ccadbe5a99ba0d1d6dc3ec4d3f87e5a6248a540495a8a53c448d8404cf0d284a8adef64240f36380dfdeb1f8cd9a8f911a1c50ab8a6a6e4b96c0f18de24a39ef499388adaf14a69d9d81b032736426f1ecfce0ee707197c870faa4ed600d518ca455968f6477c76deedb9cfedcc256413c4f1a8afa8d7c3376287c1660dc9061ff35b8120ffd4133b517f84861d25b5cfa41cf0d06fb6b69529b0dea29a2357d43bc4046670b19876005d2c323149fe226e0160ee735f70c413752fbb383abf363f054d085936139219e3683d45675ab7fb860e23b6a02c1f7e941a2b315c6846f7123f80018a5e28cb76d2e9e2b090cf2f0ecf59d9ff8b4ff554996dcaede4a94b822a5c4f78c91e3ae9539a81d40ddb6efc41bf27aba5298ef21c8375ecbda258cca69c071ebdd88db0a7d462358780d4857b6ff6c168369e27d0cf1a6cc8e495e1a26a55a5e1a120041093668c79b16baa83f55f4c551407c3f0b88a38e22e2a24a065e6fc98039198571d3d78e3beed08b44b7fa69d9f7d6dc31f381682181ede3f1662e9d829ef7267d5eaf88885313e3de200019fcade1201236b8bc52e1d92acb38291df4cf491827474db3062ff453c68a330bbbb9881ae9680549b89ed0a35c47e5e1f11667d0c6136165d8b61b85c791b14d5db7b6660f006a8f89762fc22f445a9d615f0acdada328b62511f1d664b6c543bc50714ae966c9760e185184e6adfcf6d5195fae298fbd0fcc77326edad68e740b0e46d05c8c9324a982dd5cb982941bb441e52087392601f925198409c162df84120506d85822be92c62e388d00f3317291c696e6bd576ae96d1205d82036c30a35f392fae03378bc170fbd18a2eacfac65d9037080cdf2dc74b8c04ed13e7f94fcf74ab29a78bf2de0574c4071645e8fa8e3dbb854ca3a594fd165796a7fc5ae74ecfc273bb7836f4cc6df14d127c5e00aa6e6eaa0c5d716f59f268b823a94e86a06b11709cf8d64a0c14bbb2d00e6f2a140a9229c68b6164864443aff6a84547e8084b2d0f07f623e9a3ff99effc583f551a2fb261b1291d7c226e984fabe4347bbf4f685285850d452153e61a6f5808ee43916574ec84e849b45c8f99817ed5267650a20e537abc1f9828adcf2babcbea03a9bc064db93194d5e1487c61ba74ec117fcded77990275e29adce5560ef150cfbeb068533c021c6392c02ec5c33b488c1bdd6d8b67b374ff4fdbedaf392271ab2ca2d3aee15da8aa0c6a9755727b44639ca2d06be2a4905942c08cd3058ac7abf2f8f80d1cd690482cfda2bfd8606d28f7ed644918f5299f6a202ed91cbf9051bfef98c9256e0823e776aae4ef292751b4c0479cf9b9b9b450204f339fe2a2946acd828636946f58a18d19c52eb8ab3c5b660562cf47437aeab1ee2d35bcf601cdf85320ab78811d6c820e8a380fcb8332aa06bd2f353a15934d66b7894e55f90a5599d4bc4ce0488d6086dc5d8b10f1bb48575b4dc4ce1a82b4032deb7353b1791fe60bec40832461d20c3d7547ad25c5d2aaac8873441fa18715d0a1130a7ee72c7cfddcd49696289b9b718bc1b4afc733606846170ce5903121b23781b843f52fd01f42f5c437d4230c6e7b851c495c76b9fdc26d57918507235ec92de11f803947d6032f27bda81e6e98b5edbcc0e5b48fe650dd7738c61ee6f32e23a348b366e33b59595ef57088262d34ea9d111e6833ce889a24b0fcf1ad9a82a8abeb1d78825ad991231d664dd3bb4649fae516e629acc8656bfd1f5e013e4d5ddfc62010cb42f94d865c9767a8db299b03af6d8bbf97e1a1c542160923dd06363f7560e356ba1598d604e187eab2190eb8b65d73a365e0c32c7d1611a139ad0eea897e50474784ad33c5f034a6a2077dcd55f29c320e4d9be8ca64c3618ce57000e25baaafebf3703b94436b8830815098dddc703792d5dbc5658b8f87cba555c02e04b60d52152d94c3a1178313acfde821159633f3dbf477f3ffa61003591a42a0758899be69a1b41c273a4cf4bed45f66dc460504bea09eacd58d91297addc126a2a503bbdd44fbd09638378d2ce5fb9c02ca9efd2187a63c1b7a1059fc847ffd5814117d3a4a8c763717563deca0c74569798973b7f08f181ca3f9ac6f47b8649bba4ca25da3bd39b836730a8eb4fa8b1df58e2373fd78916377dd234a1a51b289346237478639d4f6d0ae2768863df4dfe2da8658dddb01feaae85a919e3d57ce1bf535af149d38bc7f159db81c0e8f7d0525f7a3c42a2b65ab526878aff02df265e7368460d5de07d6fc7839a55332491598486bc8665534088bcdbd5b6b1271f16b0731d9dd744cff95b509e72db4f8e649eebc403f3b144feb920ef829f62d883e39184f97a4a95ecd8c965f70856401574204db74262f3c8553f3ee11f9d7ac77cf7f05facc9179b34c99a4f93638ca66187e1ad5d25246872c5570a1643eb941e71a98055af5e2c90440c3e2e2950f1b7d218ae2e46ea2da65840369bce17df08764cd0fc737653fe88f45036c51215fc80e90651a89250b9252304dbc33109f706c69d9b2d904e26bddca06f28c92186aa7319e22925b1d3828a2fddbdb8670f3a51162c9d00b916c4502369aac021c8a56570c4c3b6cc2fde34e291ed88a3e3ac80d2578590a9a5758efa7c4e65d03a5045389e0f29d3d39a52c9d83de625a41617a27a8e6422e83b54f2602e001825a1c6be05f4fee041f75f657872fbf590a05a59b02c6b4629d301a12fa062f620b363d5b75dcbfb7b9fbaccfbec08dae72b871cd2fa07cc1d07fb584f13aa1acdb3706089a9227835b25d5126d55a4ccf8d1e56f0add2640b6b4361725675da3a013259328812e3d2d27fbaeaf6da2d3ed31bade229b9366432aa4934363ea0d504be3f6d963eea10c0f615e5ba233bcb1e1a8e2b4a1aa3ca90fd5a5c7765541a79c8379fd333229f0ca7094c7215aeca4e81db759be2838f8411141a2c3933841785e95d26653553cc0946751804d066c3611526b49bf45a28ed84f935c842fdf87c7403c84db4fc958f4723c1f5d31c0689ea5b07e2f070e9afd7887b9e27c2dc0443f427a232a8e01d8f307c165c3d13d4de14890ca335b00a521ff240f104a289e5e58dc81012c71a2cef0ce11cf6beb0985ab4da6294624a6ccd72936b1582f7a64e6e2a2b751cedbe1854c9dd81b982b25cd044104dbaa68cdd435e6b92722fa0dd7f0d2c3cf519960aabaad5a26453b1885d3473eaea0fa4ca6e87560c1a0405237c603e508c09d991a6e1b6e9df93d3b8409fbbf8223531f3266f2cf2788edba2e80344eece4042b592bf83cdff607dfdb60496e371df9c339f2de16cbdb1992c7bb4c50f34a787a927b06f21a83499127c94c0c27e8ce932ba6a989ecf3c29d6fcbc0fcfa582d9104f4cb906650d65356335857a5bbe08e6fab672cf21060a519d14b46b0ba85bf3eb08e99749ae809d14541e6ccaef23df74e76fd3514e692a81ef5ac297ca1e68699af174c3b6ed895c3a18795913b9599a1e0d824a9c66e0b953d4a08bbdfdc8c1aaf213d263446d5e147a10b6f7c8773cb06926f195faa20d738de9c19d527d08c8cc4837528471772ed8c30ab34cb46d6dd7f4233a9762e3108930b9c619bcc3bc5a7357293dca7088bf8377c8d3f4ee78936b75a8595ef826a45ad7799b61d4a7fa639420ec4d471d7fd6eb05b27e89a8cbf77030bf4871961725cc0328f4f3e65f58f93e1e1ecc2874e25c0ef69083fbc820d98523b7f31dd3ddd990e00d722ac15c22a1168c4af36873f35f512429112054f78cee8f657d85d6d4d1b5b43c3c4629d8ce91269d88cb3953805d7b9cbd6b01905f8ff026117c47d8ae4f3ff2b4927f586b6f6a5e76b47f5ee799aa8f9274db6379b778242dad368f1eb2911d15769a676a4d7407aeea2dde5967c4b3730798cfbb8e50f986757c66bcb08ac52bbd93bb3d992eb3ac1ae727ca9c74911a74b660b252a30b453a380a39b333f089db8fbcce4f6cd2fe70842a8c3981bebbea6c430bd07f594a8578284290054642290e8167c87083400377e39c5526577b4011b71309f081acb8cc2b779940a188b4fa3a300d78c8669f47a2845db89c8c7883d7935c1824c4f412a945cfead6e10f48dee0ae365dd96f2af6817b0ce44c70f1e8832f2924cf1aa38bf1329051eef30340bf70cd955ca3c024e864635b05068bdbf24671e63eabd79e77e111e580c0b6419e9d676e538fa6e86cdc4305cf13f5bf7004d9dc65e0dc9361bd56d6e1971c9ca402a471c62c77eb68c1615864dba6b50924a6ccc33f98466e1f74b95b4a0ba244e4e49b06bb36eac6a583a43af8cd25d178b52c99c5d80ffabf7babe4c850c5be552ee55f4f00587940974ea3ff80ca52e04d5823c9c9bba81f45d2e6be212b511884c4d37c007709a11322c3ef161fc2f77a15b1cec16d1469efbdd1bcfa435e7cfddbd154dc23976fc30aea432a6a8bfd973adc4725e431f155e19b0aca8a6ffc2015bd2d6978d29f27a3f874e898349f6ae9f004636477fd32c24e8fdd556a530a8514b822392afc6e1da562def798a999b01f71edde5c2a0c21e670612877aa38270e3499dcbc41a65637928ae3dd97899a23dc2dc5e4e54a8f428665e3265e896fef7dee66bde3902dfb3d9bb4095174acb3e219c21b0ce56f879b18ad6de371e348729b578a5b29c920eddd5f5700087d54d40c7aa5a676743cd68ca0497cf0fc375fb427538be3542398d9489fd00a85f1e5a6fcee008343b029544b5cb5f580899aa251eb8483b5f55f5aa393635912ebc8279b4f70908825afcb27e4a37039e1ac0b2c71950ce1098a788c7b2eb12a641c0df58132c14412ffd1eb4c64387a5f13c8410071f4f10828b072482b0221de55f18f86ec76deb58430778b93728b223e094a312c1e176835fa4788bc944c3c10366fc52d51ff7c738624a8e253dae37185a026f33d9bcd91870f657d859c31cc96e221d271edc9b3c612ace1c627895dc70828bc678e31cd59b21d2c7e06845b9030d1e828e37c2fb8d9a5cc61174df5b85250065bfa1196ba2d2f46c1dd53693f19eafd46036dcccd1749cc30034bebc5a3c8ba747d3422a49c99d9f59bd001e1737fa8b1b9a231da412e216bc29162fe2544a2928c5849c6f80e0ab433a323182b4b3446bc7aef8bcc8ec09178691daa7864163e1bb53b1b1c5a2367879c44b35fce7228f8999c09b06c6501812bf6851ebec08f30bd4d6ad85d7b1f741b5cf553f6dab248c47af2e8226aa371f35e6d44208c1873c6b061017899349e7459d27d8d2cf891db42ad7f8bc38c8605fcc0c008b8289cd3d89c70c1fdb0d7380b38dcc78ec9612449ced5d77f5ba5ea4127ca279f8dc3fd6c89cb5d76b91e8a414f4465b4fd1391d5b9ab6fbfca3a59113dcc853175d5a5cc35965f650cd2448a8b1170dbb1cbefdc8f2e706d56f51b99b000b72febd3df6c3e48d645b876ab6cd826f2117b3ac00ec867e52cd512d97138376f47cacd0b61a01e718c3d560647073c0c738b64414d6bb4c657fc478861e3fcb88025fb55893ca171c69be4a4fbdf35224cc5ede86e1a5f93c99af50efd24adef766f20ed9224297391b82cf20d0b480bc2b2c08f59171047990726a80cb05419b2f78e357d78bd62ab042b63458cfbc95a46cd48774251959231ed8b8040b001d216c0a4bd2b02ef24fefaa7c0c5f58576577fea14d3f79fd96ccd6629ca8b18900c748414079f68b4394a976cec1c7def661ef003f152a525b1f357d143cd1b6c307a58a6ce1d61c5f395dead6a0bc61e38cdab9b636d930faf7511ced2c8c2db6f4707b3aec0db3da279e7e36d27b714a21d11d2f06119b676527d623825a39872547d936b1d10fbf86c750a7e86f904ce20e29653c89ae0570b58e8825e0826459ec87e9b7a11326feb314d98a9e127bd883df91feb7334e95edb7368d3768e1f128e04ea0678cbd02de3f27460ecfea179c1611c38ee95aaeaa3e68c4f0dda99af443627e50bb855e4eaa0631068f425e96387b0d2aba312dcb12388757b3f49087b712c234f5024159aee5503219ad93800b0551ad8eabe64e3035284f8c1be7899e5716c57c3019cc013b8c8fdb678344eca3eef1df6ab4fff418013f4605611c871793c7c51e65b6f44181a5c41abdf2583486d328c1e63532a7edab2f90289f91b90a30f6daf121fd9499f7567aa97e6061202b574a0bda766895bedd14b56e0e26a2d41590bc0cfd421f753b945c5a3e619f50fb155775dacc5b9c2329873254e469a9f0417f69ccac56828b3cefc3d56f88464df43e4e2d666d63c58566d64b429b82cac7b6731f9048d033f48331d5903f5de34d6221bedbff42b0b04951e89e105e1f55fae4ab18c628afb11c4fa6a469cc7bb761fcbba52364d3cffa1d318f8c8d9c6c83e06bf627a5285f4cf6e24cbc8fb20721eb7332b20f48ed20d167e3b0e5c9407faf1c9821ba1d89bcebf0d54d0160aaf1a68b14855adbde20afe4341c7154a157f8aaa4a0e094b60c988bba2753d82d6ad62bed486e3bc01c44de9967bc749f6f68a576a7a451aafb125a2c7f81fdcfac8fb2e3759cc5ed0a0218f1652cda2457e38f7b3d38126340f686b6de493ab5c96afec87de2e4b33e1b1f2bec43702d129be97f557eac96d4d10137972db7ae33a367a1ad3b22053fde2097898007c7559a0078e4aa8bc97540a64b7c2206493f5507b2c86a73d1f8147e001502bba3039022c171e8b9993a14fafc3907b25bc58e2771b00a92239751b86c557722e0fff07c707a74a9f1daf944b6d147afaaa3e3536699892552b4633ec3caea403f246366836de96583504eb1396df3cc7205671680e2bfba6d367d6b5e5ef2b9916654eea452880b6c37e27367aaea731b407c12f928c5dc968b603abc4c48204144aa14b5441e3c99b829e67a042420fe73def1a5db5ba8c572be9ff8c57595e6deb0cc4b6094ca6ef21e1bc54b1b19c0f1fdc44e52f2d79fc90bb17c3fd5364fb1f7511e404a010f9e36e01","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
