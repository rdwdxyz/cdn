<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0fbc6899a84321b68edc069b0969300e6312c5691925cb7cf40e49a16d56fd5c6484b023f830bbbaca9668b69788af208f6f075ffdbefecbb0b37bb3c08c19e663cd31d9732fafa64d05decbee9bf78fb902d8ecf1dc80a5ecc379f0660592b5890f8750dfd33afa07044bbab74cdd409b36bde214762e826440621cdfec12adf55ec3afb9488689e8590df61d1e48988ddcc799f496e236179488f78b2ba1fb4c2ea802aca7a1fe409ba42e916031dc6afece51bf783dd56c47db914092040f5fc4f6459cddcad12da2304bf324fa3be40a9bd06fa89f0f9a0b5797eb6f8c7ff1f826e77daa18574be82be3c05973f7d4c4aa224bd864b5542f94987657bd7555942aaf327e28e43c7d2e3c04b89f0482cdacfad3210e1ddcc5b910d866ddb19d474e676f438baeef52bd241c529c08dfb58aa485d3e4f8807070f7bf628c447774662b77def5c367418f86fc4a5e2943283ba57b30e7a5a3ec37a158bc850a300ec35376c12f2744ba4d1daf2273883c514afed8a78bdb3084eb767b39471403276b2d2a72064164a07fa302784fee03569aba3e3cbb50522a27233edcb382078602353fb792814c90a4c73790b4b4063daa029aa2f44d00e4db0f8fcb1ee63204a361e7937bd1681cc7dfb70faf013638b0830c1d68fb495404cac87fec97d8f96722013dc9aa09e23b29a05dcbc72ab25c737fe53d57c00f6f5298bbd7981d269d54dd6e84716d36a25b4373b1c490662b3ce8b9cfd0831ada3fca9be4b888dd0e6efd46773aff279d71a0515d9e3bf270fc20bb742f9c2c1225ce9890945c38e66e1ce3a9fb5025922194eae1e0c4d7d75af36a708386d0724eac5f4d2cb3417d44b7e492b32024ce9d6d2e36cb1defe5ddb4a9933a8dc0bae87c31f8e910361575f348bc996098b753fa0d7bca09563c32c7dfbc394067afdc34b7e5cfffd855718a65aa8569ab4e12048dbb6aa4e840bc3d8977c994bbb1cd7fb2b3e9f1acee565a57457670672a7a2001c2bbff1de0efdda7641ca519ddc740eedc97ff81471062d831ab753af30e2c6dc1852ae28d9b583f9434e34a922fb116c835f95548fe0d12e3cec2bd158ec591da139e631f5e4dc68bccaaefb40963379fd651eb195e562f38f04bedf4e4460083bd4b4f200d1120d75989dcc8292cfa83cb5a6b7c2c2e74862e7859e8021bdccd9db19127ca37b2b6589bda31385783701cba9b53f969b57b4c89f2c9a9517d1179bd9e714e1ce37f9ccc47eb38bfe97d675340f928d7b7b8602a57b9abb7487c7bbb9be899d049de95031bc0aeb75a46906b32dab1b8ec5b12d720daede88a879c4a6f5e57959f21d2d9c0a2061958089a5402683bfcd7fbece80e92b74ebae127ab700296626a9d41af83efdeb0e71261ae803ecac5f0ea000dd75cf1f53cd21bfd7d15b57027c119b1a914790908d16bd465d094d2e229ec02f67d3d81175cd8921d4ae1ec5610b5a6d978963ab10c84b8f0a817c5dce6f2aa2dfcc698113d9125db0fbc3a75560e7969e9879501b8371607d86715bf8fce626a5db1cb421c1686d7b5dac14db8f3913ea9d7c0fa2e867d4e7e8a2fa46b49ac62860f35b900a16ecc87925e4f3309852832cb6615a4149ae548d5000a4632a0e043c42842c54a0d07639f33246c680affcac1e48a1738ea38e90efb5531cc9e22cdf88cbf63ec6dbafcd974a9578ad8d7f42e37850a67a33b54b4f0c54740a9d8329529c608d7577c097e5eb36f5b2c25954e2e4046367caa2533ff6bb25b3494f15c86c2b96b278901bfbc70584127c5617949ba145cbc15c640b0879889f1e654e2e2eb08dd07d4e8ae62293cc3c5fe601a7ea21d47b75222b262876e441423fa7e96cf552cddaf0d262b35a0bf972e9a5605e19815ff54b999638116463717ec6773fb5d4921b7f926217860e259a791c35d03fa32c9224928c84ace9fceaf8bb229273cb86eb6bbb043ffcfe6f43fb09fb51e1200982dcb2fbcaf31083fb6a95a0d88ad3f0932f5f77faaa1bfd11a6fe3e150eb4d5c0553cf2af9293061f49065dc570f1aaddf336eb10e80ca136688c63de013bc7120273cb3ea8499f246779231140f54549a35b88b4313293c18f738f83fc76bcc5f224d6012065c9b7f7f51c2553d4728a3cf8283db4ce7a89dc05b3d660e75412401615740f224b3f8daf296d8976ae4e76bb825733f032fbf14d9252c7eb8127fc729d2172e2d7e6d564d3148af566c9bc7ca5e2971e58de663345564c8ae28595108468f3bf1a120eba2b08f531573e13555f46c1551fa3befc9ba757d1c463414ebcb5902f850ee1039f1fd39bb57b65a77d49c484f74758a26d66bfb7a8d183aa55e58752d908ec15a20cbbac92bdfbaecd909c72b7933caa14afb35416f4c874af98b592433e8ad699156389c2a02920df2b4b486ae22b1552f9d6481904d01bfc53148fef65d916b0b16d318a2955fdd4039ac21424b9acc3d6bf7b2fa24f719de7eacc0036fa148a36254066e5b7789c8d41353c27e69168307c4b15d4023079c021f18925df7237c0300e16f95a4ddbe53cbfd3cfec80455050208d5da915593a1573a4489b50b3c3dfaa6e894fc5e8b3fb5562b17b633176c5950006e4188c6960a05d21ef073011d6865d886bc432db833a0020ce21c7151ab8b6581706b14d4dd5f9aff6804986412f964808524b3fa88e3714dced8cb4596527753de86a616f790ecd86a54058afb4781ad32637c560bfdca6e8a9e9e64df567a20d2d72b067b881518243c79d696af7ea96167970ca7fd59987d38d8bd91da132986be202b765cdb77b66601dda62ccdbf40d5a594f18d8ea26117b884251d90281ff1d8bb38916497d5cb81659e4934ba2a29b40b8d61b76d9b6fda94189429934c84ac4c8b53e54d7a56afeb037dbe29cfdc9db29af82c145c6efde203f306e6a8e7cdc9aa3c6110cbac5a3b084055b2ff95bc2da3fe583c86c5013cd520f22574ddab00ae0c60d2cb2f69e6658e240f48e94cd7b14437f61e1d5a5451d0041f1956743e64b8d53f8b1ce7c32e4dfa565030c1ce0e30980b271b96fc9e829c9588e7f1e3b08884ae6afb11018ee48912d7e51ee2b02dd95cf67cd2a37cebf767fed96343a6fe834b6ce0df8e6390acfa2126e877ba5b861725d51b740c606b702a90f49a64bac77fac58e80ff09545f8fec14470ff0b7ebc4f9481f26995e0d5f11d08317e23f98bd7a032962270563f140a8b7469a6a8de294d8964d57de9e8557ec92e714907d3df52f5ccde04027732d21bc330f5b14830f8eee197da912c840f054c1f309ecd43466d2d85ba6d17a1dd5baaf3ba5f9cb091458fc1ea47ac4d3b76be8a77fe1fa5a9f0ad87e8a0941595534dab46e0d5dd8bc08b3b7ca121bac1d46cf77411457f060a6a13f2453e3555187e20adf7173377ddb3a3f447e4cccd579a64a87595d432031470afd15174af3ba427fb71e842b55091f44ad31fca59dae4685ccb8f11f48011478eee91d4945a7b99323374408a00025aea86b5f24360f011f5ff201c1dad75ec2bbd762d0cc39d80addb833095ae8d28b29323640c5ac0b6f86af531e57d65f203e6d0f9838e4145c1257439323273fc82ce9f3f9ed6ebfab4c990fdd6bf9bf01fb12f51714b7457e552bfd3ef9ca14d7bc15c9eb6f965e678e19ca7be22004bc70caa53d108b7a8de4802bcec0ae7bf847dca6a49ac4fee22c247a970b21ca9646bb1012c2c6f648429cc26e98bcb5ab48bb309db36b4e56a6b834d1e427f72aeef88e8f4b01febfc466e60b511d0c909e37a600c3071c9e9ce975c44424ab06df21be6836fed9de95bcdb9f474f1999ae49d854a9b5219e59887aa2a5fb44ec9c176d7d3e6b7df5f2c4561b58e0360ab40d76367d60ad3b23bb89dad8b9888ba8b9f7af59d2b3823b789fb46a9e5e0d8769571a8d0ef1d0dfc6abfae3c7feb6e3127af7ad5d01dac6a48162c15e4b8913b9af745e55f6a13f69423bcf292e76390e62dd392b0b62c22a27334f91be4d3c38d324ad34b3a15c2df2210c3ea65063534954fc38550913c47f6abc121bbd05cc9fb0d5e2460f2b67f2ca5f6de0f2ea307185ea603f54cca11f78bcfa7eeb7d0e4ec608d4b7621e1c7971b708cd1f9cda2b56aec9ed643a4aadf45df5b8f0348393363c1771a6dd80edb4235936cbf82fc0179dcba43ca12621df2efe97893da0fefa317fd03d21455da9caf963178268ec76383a3fb9a7c482cbd2126105d4245b89a55bb53f93a013de6d1f752759c77c8c46f4bda19834132562638b91caae67f5e30c69cb7329312b87d601cf3813302b3fdac3cc962e0665598fcaeac6c05254ee57152f9aee752e6e0555975eb1a90c2599c96ef4b620285a896d09931c5ec3d06bdc2c0080cbc06105ed4388b1c9c597a33d15c047437da536894f859e9280781560511785e120a21ada148f64abfcdf9ea4e7e2e67d850cf0ea0cd9a7d275e443aec292f0faa748007887ea5d4f57fdb7fcf42bd9aeb4bfc2141b6469cd7e46590b3208f09f8d75d452596459191c790d7ab13b2122768b57886077313c7c97a922626215db3607c9a7413176bc4bb7fc0e750863aa289db4a67d47dcccb81eab00129ee38af3558bb02dd5188175c4ad3b9d09e527ff6a53d1ce8c87de9fd5e02a38044e01e3c5641ff00f0b7a2755906d5d6dbb2ae4b23b823183fbb5bebd4d989f85ea491641ec5bc0a1df8d16ff6e9c729f75bbd7d43e042c917189b5cbe4ff30516692475d23d7cd9a8fd584abfe56951e83282e96b09b90d4e06f21d9006f3acdfe25435a7fb216de8cf79341d2bc83759da930c44e4f8c3de5a995dd8a77818cdd14e122655d9d4e2e67d42b3a69c1db09d0e83057b3ed308f8a1bbbb4d3843edf122f891c84a4e3056549428a1bb9e3b335392e50af8e816c3d5afcc7ae6b8ebe1a2cb1a8b87a5210a069a83681c66698e7b33d123c3a43c0ba17ea0651f10a5126fd8eb8d87a1fface9fd1646949f22cb49af4416870541d2e42c9b4ec63708cf58d8aabf3e529e17719618b1157876c27a03eaabc5a4bc5dedd67532c8b0cadfeb9807532b3e595895b8362e1c731a64d31fc4167c5f6bd6783bbac6eb2017844830ff5805a3153ba1682d52e6f9cfff9b4ee46bf07adf9a2254c2d58b0ef63e8fad1ce6090fe53bf5850c1cd464c683e83ba94fe4353bb687d38abce7f5fd14df7d10900414b1d9a165f19e57c8ebf36433b20aa77b930131d8cc5cdb82f1e2d429622e11e79d0082ecb2afb3c74fa62e6d2a5607952632f5ead9b335e5393175680bd292cb34eb49dd95c7d7fdcb9c8f078bfd80d43bcd059cfe1eded85c1ab457a07607001bd4725c7053ff9eaf9d54c3bdb82ad469b5e97aa94cb7cd598af7179e5365b0e6caac2a6746490624129d161025bbcbb59eecf8234bad038c557a12fc834355be255f14de458e606752388602806e43aef54ac432e49e0be6b7f901aaacd418d8361d40c89e4a68a4c30305665e9130c50ff6bf2b0a112ad2b5e04416985bdee44cdbc6432f30264b9de492c50867f6d6708f8eaca8ecfc3674722e3555a92b1c37430f5456df486a1867e8fcfa7b9a3a914d65e196802bf7a1d196a788643dfa1b62327ca5a421662fdd11a5b8cefa1aca4d3d20264c16e51d43a72468ea60d9f9149595027b971aba833bbd47b9beed91d466928c85e15fc0644552be9ec392250e0986c5ea1c46b2674bfeb9bbdaa01841e2dd7e89247a25fd9b804dd9b81f6b6291f2ac8c98895ad618514fb140af5bd3203f57092e7fafe6d3b34461cc4812465a631a046030aa04ee95da066620d4d89715e8a1640a3e685e04ea451f4176e8bad100abed1c3ee6f8377eeead38648cfd6a7f4aadae294db41d6c654682a8db99026b461acdfcfa2c5a68a285a457dbf6e3636c6259f9493ab0590edd372aec8d0398961044e8db6df316c1022871289f8d03f2e7281268aaf1a618d8a0ec3c043b7f1aeb20b819c84d6510df0918b51269d15453dae0fc760cbb619411a7a66b67ca4a4fa18a22d54c297a9f65267a36b451e02b694408c40e508268d8b86996aa7c5ee444785d00dd859de7b42e7d8858a4e249cd899153423a8d15ac46168c1a93424376521d649a442f394e9195c5d6e7db7c38d8c35c751d21088e89d52fea8593f8849a7332486d6d6e02c3edfdbb3bd5b850b07bc83e08ed137074114a369fb61bf447be970a15e786dad2e9032b2accd9618f360fc593348e1ef4ca259bbeda1491edee70ed8c621370e1d6b75f3694d13cf882f0254ca0f3974950e4c2b40f1ff38896fbdff4ba29b2a333b8a00dcb891f4c47f2196af14db6f4e87db39a5b09d5e89aade7eb27b0ee5616019f00a8656ca1598a913c6877475ecda484fb93377c6748390a5c3ff7c05f195fcad61dded1bb8ad6ae11b12776e036cabb47ee7bf2cab3aa564df54fd5bf5bcbf3396b3534182494bdbdcb5e783ad6fed1f345d6a8fddb4ebb1c6d4c6c3c4055591426047c4760cf7580a9841c5e8f28eb94e942ba8a0ff55e9de6f07912bb100a13178201562e388710a50048481c6f62568e288173b60c6c0f7e04bdb031540660ed4b6b7bca4f1e4ec596f315a77184a62833282ef3f270da31470ecd02da6288df1863d675f4f82e0de41759d66b55f210c7698942b5032c86a17fdd62549824888fb2b274a7c588bbbb645d6c065577396f0160eeb3a5a5bc0deb525677eb4317ce29ef663773f7ec1568dfbfeaa3fd4d50c2ee85a1eeedcb07ebc329f60f063e1645e623a4df9d7a86ccdbe369260d4c5dbb197d152a2fe74ad8a9785b340079df989effa20ed5ce092d05fe28064115a14d031a5fbceb9fa43ab1a5fcb1e0e75d54aa8682fbdf685a15f20ada6ad3a8cd2036e7391af5fe287949244cb73af3db701b686d7c9ec7a5ca4fd06ba4744d2036323dc58b81bfe0d43e65989bbeba544d234011efebe45984c23c9ca46c6949cbb9b0afec7a57df7d8ad1544d352e63dc6d1db391a3a29febb4eff4647b4c5346c8317b74270e3ac5b09dc45696bbce044b5eb006a9f1142aa48783540da69e75b54ed8df9054c76cccc8273dc33c450ec5270faf74ec21aa975758b014624aadb79e75fc027c41315d63f94149420d5058bd49a3b0bead84b2ef13752d8e6a10925483c06a86dd09702da82709f451b227fb1b27b8077483bfc9150fdf2562864333ec1b052bf87bf629f00ac1f4f6228f87d9df45c3de675903ec7a01b30fb7a81b7f1417998a5835f292d6cb3b7cfe28bd1f819f6a403056bd94aab77e5e6983a94ce9e001ab4542a3ea14c49288692da80e85313b71abdf026750a9e0fa16f5bf2f1431d7baca8093aed213a3ed18c0fe29ac890a6dd9a0b3d37990d6a5e474cf1d4016f0904a6e8af40c0610a6054184d148fe482fed09b3709210df323f42a59ac329392b24df96d42ee0bae2c5dbf1087f6f7751b58c7ad82ce845c0517d1fecce64532d9a4c32032c43460dc9da948836c54d1ae986d4729d0699dc352ddcf1b2c98bcf0eca3ccc7878357f3d10b191d378ae59f05c7087507f2b0b4cfae8ba6f7af5ee8e6ca5dba1dbcfb857f4e1d8c8f39d5223770deb4e102be137d590af812824f278ec7143b9a5d9625bfd4dc60629824b978b45e1ec97e7a275357b42739c5d8ccfba8455e8f03c3dc8e15f035056fae723ac9144d57b88fa72d65bab5a7563e1a140445ca04a0a34cf44ccc1182f5d58af9f057a39e301ac4d19e418915823761b6de8ffbcbeb25d483e01c8bf6b76e7b3c9243a1e46b9eb0b23e5460d3821febfdfe6a0d47a6b2691ddc729173b0ea04b01ee7d6170f888053f42827dd0830a70debfe1930e010c4e7683992b8323b2f2e86e01ff90430c22eae571311c389d16f431ac888fe7658b1782a3ff4c8b5ecb59089cf3f9f4aeb7b5d203caf30e8663bd8a31d852af0a07e8bf66f9852778f05b178090e4c555f793cf1d17ba089a76ce25dcdfd657ba08c57e0a107f3640d2bb4afc05414c8e18f26f7b6763a2caa355a949815f3cfad6a592fdcb1f805d51b586f32733c6d1715b1d92c35273b7a103c7f471a7f3dbf225db1410834b3d8638a5a865f64f8177a325cdd2580318c9fabb98cf7f62304752a8ebc43c2150514b9636db6ebd43cd699f828684b5b5266e82fda8dd5bf7441072449fc3d304c69380026fa7e014f534a44a0a6c8bdd279db113f8855fbad98092b022d8b7eb9dc94278b85b26c59a1a4745ea7737bfb590eadbdcf5fc644deb9911d24e79f9bb957d87ad02ed6f8ed3c826314a9ae4f1c5539d029dd28f523300ab9eeabe1d39a323964ed774145f620d201b9f5ab3ed26b36c3e15f5dc2bb8f168765e8e3a45d6980b257ba454ffd4dd92fadc6eb71867ff04d94f665e81b916afcb4f417562ea4e4ad94415252198007e2167bb5f6e945633db799a0e4da56357984e9f00ebfcb30c36ae645891dc0f40c6585f45aff473ef3bc1dd0990a96afe6baa8813c614d17b0de7502b8eb3e6004b9fc17680aeb67f00af133b925e40c6e3c4550c1ff490a2bd34db5b917edd520879b036739dca70d64c39238d73492f9429f61574ce416b714a0aaee767666b45f8523989b020fcdc31e6bdd2cd5eb3dcf01b512b06322453cef07132557ad52f0b4c2198f4ee87bb05b51288955af9cd6be66a63a996fa69843386074ce21370383d790ad274ae6271d6bd85cccc2545f90387a290a6f29a104fb0bd5799b93ac128e1f106bb5cb6d135b50f11e3c52c648cc0ed64e1bb07c9e392a3466826be0fc7481307d174f130c3a7bcd218eb00a08cbb0ba7a2b78ad3d974b87f95879634889139823e9ff83c145e636e2c3903f8094e1db8b890979a7d9c2a91a73120fb3fe738ef551b3f81f86faca97e795ce6827c22fe25404dcd83a4adad04b2994b87f7f7a50103e265dfd2ff3f919d406c783c43e1b192e5f0c4fc7db9d23fb89750ca871928ce0e3077afa21752ae54ee77185df1be3f29ac72797b2e982f7837882300c6596b1a1235044abbd117c726bed380feb75b8cc3a4d8433c0ad00266684778a7eacc1d673b967a7722658c6343fde1b2ebe94b183bb7f4e7bfed4bfed2a3da31a03b2fc3efa389077c6842bc42c564659f234d99fbdba6ccd46c6e790b4043a46c84d89f9911932a669a28e15ba2db47ca6250bb9b6ddb8fd2483d89efe4894b01c2ebf594deb30f5b4a394e1ca896a43d6569002f8a67bbedfe89015c0333dc72408768883014e130bf6ed25fe1b7501dc508e3cf1b4dd418bda72614c3a518b89904e83a431654d1adcc8150eb3f2ae444ced837505f3c5a0c62278195b2cc85ce765ddeb6c8d0adfc144e9124c411dadd0cc20cc863572e3b41bd5e5617582b85be7d54b290b90bef7796265967c6b2f178cd3cc5a9938fd46bf7dcb7abf3bff1cf73473913d58629f59115126adf898e5da508a68d8709def2e0fd4ff531e9d779caee6fbdbaa18a1d3e284ca7fdb8a16283c407e9922937492fa328db530539292e965a6eccb999cee1c7a2daa3d6aa66ede76283abf99872a10561e29fa93e32cb7d49051ea243487702d0a9f909803598b351a14fa7a794bfd150131bb35859e924b6f4231037b2a0431c44d547b45481a6d10dd2fad8550a3cfc8e5a831896a59c18aeac84589f8b2af8b18e93a07f05f66226bde0b8c9468177b59ecbc8a0754aae8dad3a85967e87bc76a72b264acf8673324d3f949aa4e3ab9e75b1811f73655200b82fcbd573b16db2c172aec79d24bce19afe66465244b1db42edf59c134b639800f8425add532aa1b41045429dfd211d9b4602b7dd4ec9aaac5532be8166bb8f4a9058c73f8a037587d8d767b67a1f1aef9119c8c3ad524eeac8c5b0e8d72b6759c97dde704b5dee68d06274839aaaac773e9809489a2f70b1ff15faa3bc2534f4262fb65af4302aed2230c565d7057c64f4c509cf90ee37124477ad1dd54a1a5ba54c068e3da863f419f960aca1c3b943c3d468b77d1eeed555d302fa2da7d72a5f527808d112b327f6e4fb170b0fdb5ecdf6a1fc385fb063c8be7bf4461cb7a0e271e8181c9b0bd40ed5f10f2d486f5e947d9d78d72c30ddbe9ac40a15e829db3471c948acb8523e84c14f989c0b89a5a779f5d97b73364b98f3ba9e2c563536122f9ad981989f7cf560b0da28dac5ede22ed99ef129eb32ebadc36f2ca9804972b635a361b97a4eef04919c6ba2abc30132256a5816930911bf1a39f725662274734c2c132984f02ae25143d0b509fe0186c162657a79e222a8db8f3ba598f60a84f1781b688881f6a59fbab115309b831ff577ac793b98b2a601952768428dbfe913976648d7c9a66f5a837207d273691237838ebc89739da25309526ccbb5f49dda36095cf1661890660265abf3f1f30c13822ff3c6f8aff47c79ffa0fd165f4fdfdb34a4c79ed7a3b3af1a11b6a4d43442d5431143ad7711c4458c360cd66f5cd567c463b2fdd9ca186c13523b568c800d38050683404cee7d94f7a9212a7a68e07537200fb52f711d2660f0c6bea9a59ae2f22a201f97a482ed1589896f6d31eb9a58dfb1f87c61823149b3d89f11c47170eb238980dcf4402953542a31853a88250c962f9b7daaf5760dbdc4471e9d6278303362220f71add057e0bcf988c31d9f98c0f4b1f5eab5a547afe041c370c32246beaaf7f425f2682debbb8b235bed9485cfc7e0d0259ede2b7825d572500df33c304d98140314afe09a848c377c921a7640b7bdfa628857fcf81fcbe62941bf86ca30423c6de47167e4cdfbe85550e273cc9dcb9a9bcacebde8e294b112472d50ca49d7fde8849dcd9f8a7bfe91da71a9843baf618ac3792549d60140bd1ef2958768425346159a757a7c0e2184508a4fbd80b302267c7853328f9229fc433400168014e59fa6cb50fc4e6b07cdf04c611e4809ae27007a7f7bf7c4f9741c717eb277890316af68fafa1fdb7747da70ddcc6c72d69406845a3df238c89f4670244ed335c8bc04a1b905c8d015221737249387cd0b1264a1af65e28674706229ac4239cc235c30f0c8a4d38a6c1fe8e356ba8c2743bc1229a3efa596878fc1b99fa6d174a6f6364e1a8186f2f8d85a50f10d8795533042048b396442be4468bfa6c8c407581645a783fc9aac9ca1f424f88b8e9c13302798ff743dae209ba0d174eb631355a0913e137e4d613888053fff1891bc028b12a1224c4f57ca79d42546437ec77f5f67d234f9b068dd73e4dcf0d3aa1cf8ca9b9d4fd1f00a1f1ca900e992646a422195dff02d99b2ae34ae7d807a6a5ba80bd9e47894d05322a82cd9ea508a58ff5c36eacf6fd310e28988d276a40708e83c2d86e035c5c225dba45092e0a418294cb74e7ab5818e6797fd43194a8ce48b2a59f2d11e040523684dfacb6236c2a968c9fb7491230a42b68fe9b6ea639fa150127d2f238651c01891b05f6f9528c239c730886eeeeaf3848acd653060aac82c93298f0a6ac140e8c8ac563859598e5596a0dc69227ca70d23c80cc1b1f2e3b1536311ee793ffb606cea95c7c360786ddbaa5490fcd3b8817f1349a03e270c403f3e067292687e06a1beb09396df19d3f89b1e0ced13ac99e0ce299349fc44e5b8ddbb595247a96733d589d047de40b1c7a6397a19012b00c7953de30546814c1268bce517b4a0f5f12c7803c26cac0198bb2602f4f400f3bbc64eb29bbeb2ca3a8d4435b4049d4b38caae6f4bc0f6d19df5b1ce4a82b84d363e827fa9640e5de135600140c485d52305bf8e05f9efe467a65b394b9364d970380f72b984259d7a30a14a52f524e65d72e6e49233e595d19630c5abcdc0983dd1e2011b71bf88486100aa69b65688e5e255689dd3b7d76d6198810369a4f8fd4e40b75fe6c50bf9789ca4f5613cdf831946f3632cfa523b5f7f35e91f9a91371ec3df031fa5718a9bc1bad01fbe6f9f8f8e6cee51c08514ebd7bacfc09e985668050763bf040f414eb4537e7087ed84ebdb496abff737e6bda007ec5ab5072bec7f8f892a6721f49e20c073a48698877c20df0717ab0dc264e0bb2b3644160b4d79ba7ed57e683601f59c81d6e7dbff3159bffd1d093df4bfc27be251ad31581104407e787392bc6000614bf3eea92ac9079ca61e2e28b0a108cad0dbec94ed81a55a5dfc8b1511d2b113cab0114c21682d558f8f1bdd4ab76b533d2f87cb1c084424b4ddadca0bfcb700c94fd242e2013721f6471cd2d4e2b327163598adb3e59fc927ca9f402a7625ba080e979bd8fcd5e03286a921d906af1209d9c7aac926d772adfbb005b464584c5377906bdc8ce98d02f7b3642e0cf50d3624801929f355016e2c0c779bb3c8f6f6c91fbed83e8ccc74bdb8724fb8c5420735a61ff02972366ae2b44ffa1ca6f2b5011aba6853e5dc29695ca908df47d17409782b2b3ee0dcadb1e989fa9ac28e88cd7a26333bc895ef807442e252434b4113024d2d5e03402d20606b97fed1db9233d5bc145e24ab7b47ab53fce5f6911330e96ad21dd579b619e4e6be083f6791408b1019bfb9ad2f56ad59cead53787bfc3df28048ad3d8f58e17ff36cf933e6ddabca7b59039e5e5d2018845423d7a28149bcb7d0a038f9f65e4cbf7b2f24ef56f7139976d37a334b7bc54109717aa89d8f502fbc40a375a443301efe794f45b85b485e09934c44ba042399a27f39e17ab60968a54aa01cb59c946ee3aa0a3c888c1f33fc8437db0f37e3bfb9a6a72931b25cc13139fe8f78aab2a539eb436f172cfd6878166f6bc5b7985d468fd61b7ad5f331cf8f9940796a91e360c2e9250e3cd603612e933b1e90ba7ceb67eef8e6701ad304c7d6a7252997c44c53bd1bcf8f63f93cf55b987e790078d70a265a38501c71f492a492628279f55edc37ae414fcac57a594ee21fdcd1d2d78ea6c27982a4d3b98e663dfe10f4e8dff20fac0231fb91be6809cde4acce2b8681131232f494b752aad4fc78a2732345509cf582955da573cb8099773ca93c7e8b535f75d495b655bcc086865aaad79a39194fba1d6b08c1aecc2ae0da4ebcde4a82ebe2e6f0b3fcf8182be61afcd160efb2916f8ba03eeede072f00578f0d09bb9516e2c680a715ede2b25c945e8c2816208b9a57684b02abd9ca7383b7d09aef3eae5a5535da47075d906e70965196a5cd7acf4d52c50ad56172d025fa6bd6ac59ffc4d749acc9483c2be8328b2ef88e00ea67c9774d5d3911193f95153330f3451a8cd7811cfd0534f971198f5202511562d22cff73032be9fca10d3e8dbfc88ff7d450f4a08d0ab38ee95b7de4b1b3a65653cb716be584aecbc922511c450037644036fd3a46092e5aadccf8383c990abc14d59bd081a8c24f53b44ac19c45c6336d57dbfeccd3a34212d81b23aeb13875b9aee4de68473cfdb7c0a8ac9c277accb01458c85e0c03d80ee9457efd24b78576f27da2d7cbc21fb0a7ce358e0db4d848f6de602eef75b8bc79a4e1344fb9fdb408e9d839919b53846b5ec77bdae67ac83bb758984a97f6ea9cfbba69bda16dd430dcc7d55a2e87c6bf2770107d5de23a3ff4ea8982dd64b4c4d5eccbb34f06941bd4b91bfae34ae123225b3f2d65a35abc419f1f36234d5c7ac78d20d1b4328270a5488dfb95319e22a9cffb7690b253752c5454d558f8ff46ee842406a1d1dc470ea11c928b64ea686b6fc5281deaf409742446760d0548bdac68532d9d29fd6b9aed7bd33f8505d02348dacf8ccadb5dd7689b17699afbaea59e3a1e8a812df9e87a56d7861de427c850265903b8ccb6b0575039379d03f650ea2a9ac641362608dda2045507868747477c01f9510c5448f81013fd933f1ef47f1ece3cda3a912a06a94550f316392e8adccb6882569d6bb89ab1edbbdc6359fe3ca5334f5ed4656b4dbb1afa57337e87f9d53981e83f06d8f6007a687c51b9869993a1c64e05a0437072dacda8774209088d20093b3446b1761cbb59f13102799b5e335c41faac957e683d9633cb8ee3fa9b9059ecd34363b1e4a9c98896e2dd86655faf2f122752589469e1eed57d38692c05a12460429557febe2fdd41d1b7451614a40e9913c879cdac8e2eedba33cfb4a972495bc43560f8d26411b9fdaa26ba1202fbe482d5eed5c12bc6d5e63be9399eca2b43261abcacc47131ed491a221015ba87593d60edb17d19fed5e02917aa41d76836f1a8f9e7f8b274ce71e95df0ed77686dd5b90db6ea4bf59e7511b327e0d0f26aa88fd514d843d48584f1304ded91cf2ce535785c4d45d31130fc7df51e9a8bab6208096aada32c47d603a3fc9ce7a25351321ac3823a8f4873eb86ce2d871c4b5b5c18b4dba2d88723040fbab1606a46dc65824d744f8508eaa1f46a3657fdf83d03de3bc7348a8d3a80362c06da724b8dd7f96e1209af0dda94ab0c1cc8863a8fd48475992be699d3ca1668dccf45b90e67c4e0d9b646319c8bd8543eb6cf3fd31d01b00b4aed0ef3cbde49b92883c067652a3ac379b453dfc828ce9f0af962419ef474d25ff9e181091f7726de24409bb9ac86c58c10d2c63a7aa65d74f50070e9fed4b84e0d1fee6dabaf0d526de06d5f28884f8b0edba7548eaa04f47a348540ca744f16613945c15cf8d89847053fccb36a93a58223a9bb70322680534afbfca15cd4a9a356dad0c82615ceeae8adb0d98e7e8f4c7e6490e6a13344cdd6a2e1cf5adeb1e03bd80556c00988c8f3f1a2c7728e1a496e5c7b4068c87337e6e375d52774674350eb13d0356b75496e462dd689a658759c48bbc8d135828561791d1cd764b3c1a4c9d5a9d8895a994ae0d02a33c9a409579d0a575c54a699c33ea0b8d45432f756ab1ee5f47c23da3ad1d46a2518fb4b65e33dbddae461934bc5ad446afe9888a6935fa2746ea2bdeaa36f15ecb0a9b077ba2dda6e19a817791612afcce6c4ad86d449ee7fc2b93589915fa13dd3d908fb53418fdf619ddf37530eff8d77363f8554aced39c11f48626701f607eee3c4bb05ba40a2e16e5888bb925020dc25b008ce85e1c9e93d14000daabd31d044fa69b31e5b3a683feb5f7a04351acb09dc7f378b230a6470563ec20b88c50721d1668920efcbf7cb40e7f5675ab9728fdaf022b70eadd3064e8725839ce016ac307e9a47019f2ebb982811203fc2bc1a41a5c9ed33b5487af4197f1dba564b3b4389c584fd79cc154b327aaa8bcfa026f9730476f626dccae59ba6aa3c01ca8aa8ca73b9ca05c74a7760cd47137cd320bc13b6aa4e73a29fc5b6cb4ac3510ae2a4d3d992a3d5e78c5dd8a52afb87d33204cfed40cbba5bafe529cd620e9bb3cf9580a25419f0cfd65e050fd87d771fbc285b05a50d2c8f857df7aee49d5bb80db36904ee778a2d5fa585c0f54b8e7d5c992420c7382362aed99c7fb99c0e71924fad0553bc87297f1fb45a8a79d28a38661505ebed0bc9f2f925f6e46b622ae94624d322d29380183f0e3e31ca0017b4a3095b08c75e048501fa3cc1467422405a60742c02ed9ad9b0658eb40fbe2caab57021ec770c16c9b686b4d460ba3724055d69cb228ebf96f3bc160f360d457a762beb423be44170f20a29ee02f2fdadcb38da2536794a45cd0105df24be59fd713327034b092e64dbbc410f2fde66d7a199e2b633bb747396bfce17d16ae14aff07cbdf032691a57cb95befc0b413eca39e5ae5d251601f6a9920f010df4bcb443c6504419e4478223e1295c593fda802409cc023b094314b42ca75a77cb678d69265d288d72dfb0e8049c18e8994d2580b8096cde64ab2b9fe3ed1d9142702b8546e6fc86a0d9e014fb062535826513f574f27819a53fd80edb1fb391c24b5834aec795f8a2df03e2b648d4c0b6e7e23dd893ca8d625b2a8d463a21ac01add52438178ec00e364e86e1c6741622f00241d1908aa4b583e65cbed323f053fbaa38aee4fc952988b2194ad5bd5a8e7002d1c4209dff186b73345f76a16ea5302e22ff6beb75cc5c20611e80d5314b07320bf2134894c120f38ad168035a639e7efb35cc81e5780b2c7b18d2f7f9732969b4a87fd53d462c5eaba106ef6974038c9950211af2e170876e1fba57c07ab5f14314b6ad1f45ee4703ca1e0b8a7dda5282d13c2d89a8d334e2fd3a5a9354bb780dc21bd0b8f03476080aae2c7538171138e29a5b4564056741dd0c9b7dfc4f4bd5c8229b7e6ad50e54dab027f040e3668f704a61738eb937df7c9918fd0b36ba29f020d638f93b4a1fda290491354cac1ace00b7ae9a056eef0efa5edfd5c2a8b92a45f7268ae318bf32ae020def7214b87ca6110a5b4312a0bea4329c1751ea026b35bb8f9afb82f4d1ffce7a84cc144903196bef9c6a2332f64d5045d02ae22cff3b0d01b5cf170c2ae4b622b3ae1a095c81b4876b74b984a34be8a63bcafccb9f13d53b8c1632acc85d4f5ec07864db78c122a6fd12c63d6b289e0d2ef3b9836efe8933b0e9f7aa09ea90428834eabf7824b495d9dc8ad6cc35ff515c470f6294e9136af7ccc6facbb1a830652eb18154589701750b5ae1bd56ca66730dcb67cd3cc7450fb8d407fb7a08551774c89f35d88e13cd03a2d983f74f133e4331d9e697bb8e496c75912c7f7d477ab844e5ee865f1a65259b2008116f1c9c63266ba3be25353fb945f2b34bf7ebcc93d6cb429efbe27b80f31ef369b77da40d73d7a0876aaea1901ea59054caf04af3f2d8043a00a24895cffd0d8197c0fcdf2bc46ab189a5500d939110b8a9183b1b4afb8a05afed07b7604a57b91b14e84e4d59234bab6c7c98e1abaa69feb2928a57ddabedbd11f9b506188e79e6cb48f42dd6dfb7a3a5b28a5a5cd09c1f428f316debfcea94d395e855ac3846acbdb840170ebf31644b1a8ba550b3d0281c784889a170e3850a89b9954f8153cb600f0b880c74d1580a23f2621dde918991026c1d131c0368a149b506e75a058d7963f49ad130faa7807bb09d28b45e386f41ac994f65ed0412e2c1b9e821396e59d264519e2ce336061f664a0bb144d00727aab146fe28d2fc5956f6247d2f7b30595d555c45021af0fdccd3b69a9d354ba8c8fbb284cf0c195bfd3de34e801c03f6297297734db68485cdc95c9672c80573eea950995dd1109adc2c8678716d34ae6c60c9ac859176deeac1476f0a49d14491c67fa5f8aff611dabfb51fe50f96e94f7038d2acb1b62af18babe446a7f47346d55af12a2646e00ae7aea65f0acb7d9c171711c90919192431ac1abce43e9602dc9c2063b834370007a5fffff9592a40d5612c53d9c44ca070c9cbd23ba3678d56201c3ee906c6c8b887faa97a370b43f4180e1da18a33af3e5e9dc00e8f82c66bcd1c2e2380aa720b2bcd2476bc60bd6e30bd436d20a82b6069ccf75b44a9cb5f86e6aaf4821eff65457d1767b2db1dffa6a00ae3641aca1d03ea05429795e2327e34a98ff88e72a89041e3ac96c619a4ced88f7c913caf8a7eabcef415ec0f093d84d5e22d2cc5c1fe62a74bcfd2d0f92d6d25623a408f0f10bc4c731e6d242e2e30380213fa54a3cc706138d52e9236835a01e72fb03c162b52d7ef34492ece3e632dbc803fcbe7b5537b527535ce73b9733b1bcf0e42a9150c127d14ff1ced64bd04589e365bb8e9980a761aa8a03b8470a6f9d30b3880bca52bbde78fc5c7bcfffef701a3867a4f19f0bfdd9d9311b7722587929c3def8aa4c47ff8871d20a8a0d0f4fc19ef3c08c10e3a63b7960390a2c29f982f3822adef65d66feef29fa6747a1813c79dd12dc270bf703aa8cd4a1fe3911b2a9619f7836fc5c452c1e2fbc548f991ce80e65b7957c2c20b53d659d82f204954ef6767ae43b5239fc87f28618e865d0fc52319ba80b53269a7be2b653b194ede816c2772d73b4b9c24d2d83b1e0012b84452b12ec6112a6e336a8071de6ed391ba3c7bbb4710050f39c01cbc32c08cb2c759eb41840917e2c74a42a54a8db4c1c39b5dc7418ab7b14b9c95e01c4516ff4480c27b5511f162d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
