<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8804901b84465134df63b8e673c3ce55ebafab273cc5337bf7cd76eccae194098ecf7406109430812fea56c6645f1ce7dd1f858c5d80f64e6cc734bb9a499a3328bdf13ffd6f637c21ff92fa0e53ded42860b26958723bc7fc4744e58d2686922c00ed5aece8f2d324c0e49c1f2c0c1c26090f952ad98d91f5210835259af8ef937d0081dd7bc9b91d53381a0e35a53484b8738b8a722f725b5c694c995f22dfc9dd5f2fbaa70c79c2e8de320e93f5cf16d0f24a5d23d54ec8da3dc9108479eca9eed6d374da94fb7d7a075f825b85fc864db8b28482eee7e665d14710cb7dc43a25571fae5dace748e0997a0c2e0afe72f2e637517d664f1abd63f9a9e13f6c800c29db752f93493d18847e04295cd48f6e26ae49408d5904814dc0594d50418598d5034cccbdc5687d67f7096c64b11a3f116b8868068d7abc5c1508c016978f4e159e58f8fb71c5cf37d475abacb2e24c63ff8b732c8b14e96a3decabfa1800cb0683b34e7a79197d87bd8bb3cd349d68980866ddec354392959455213de2e63a48298d2c8d3bcf6cd0d26724769b2b5fcfac0f8e29fc982d031b682de0071a8426291d9d60fdc38f66bdec46a60f3fd2530377d0af06d09218e9ff6350c9c7805b9ef143c2e374c6133b49de753456204c9eb720d687f44b420e7ec9f827c2bd54b78811ba191d7de7eb950cb0fa7287bb6b4dbc6cdb46ca26806c75c0512486fe9dac32d79c258325cb0bf4790b7d89f13a42c9354d6e5cd39976d8808006046ee53ec295b108db581eaa5c30fa75ae78bf843ff7460ba919aa491a3abafd028d1966d69801707643bc5499542b68e6ab0f7ed4723c5a846dec08e0013dc4c38e54acfd69c725fbb80b4c6184839804a51513c521e4bc9677eba1a1c3accdf6fbc48acd2bb47c52e047e85f9f0a2e89f15822aafbf1897ac14131aa46a6a13b491a9575dbe9b01ddb063a555e8c607b8a7d7279ed3d099a37e1db105580e666d0ea815c6085d0c512b4d13c6edc67cfdb833a31954f00ebac6da5c7c26496241fe48f33d2e4fd2dfe13f8f4d7ce4ebe2281e376f9138bec9860c5f84cccd1593071c14cca93a8f7503ad75026d608e1ae1039f30b912a6290e97f22d42d6d24892b543bf143b8ed7f8d2bab93624f3283dc3c087682e629df9a3609ffda345b8a974c5be73b5c872b94b0ff4d58115ee516f050909d3f1ee75556b4c071eb79ce152cb9dcf9440f4ec3a97c1b92995754041f2720be8239b1e031c30e63d408cc60d332e16c4d6063dbbe874cf1fbae177233e00b3383954c8c8a54fc72ec68a242e3f058155f40465cf22f384789baf307708c80c463dc8d46fc0ad60b4fa0c07d1f59c535dea9faac9950be88d79658429dd7938bc60284960bb48a8ea74285314bd1abeae55ecb36904d6d23111637c0691e9b669b068cf5a8ae28ca71da3a10fd224ac8ca56d87246d3283e4e4ab74cb23bc7892b53ce8f9efaa7cddf6d8cb29a32c8376948a2382ddfe6802702b9ad6d66cc82316afe49dc519292d61b50763a158fabdfcd7eb8236d8446715e7c0766b81c2372ffef292059ca28dda57216e05e14d74b617ebbbfe77c0ac571766fff174143b01e6f46137fc42525f3602c07ae47a8b55d7b11a07681d55561ac06f23acbdc268fd80086d6a03675898f526d2020addfbd45ef634e384260005334782d96a8d042a246490ecc0248d7bacf67ec89daeee0d076c20861a690bfe83890f60f8f3c80691eb613514c371db47d3dfa6f70ae4535beccc748e49231fa2f00eeaebdebe0989a50eb590b77aa086fb5492a1f175fcce3bd0b9a0c35a79a8156a86383d8c9abbb824a5157f919fa371b210aa05da49701436b14a9d3e8aa200ded613ea9bc1b8248ce775fcd5eca26dff3952c75cf6a389dc1e4205251d92476f848eabf573715053bee105a35a54c1529139f458d7012326d206f6f91873c51f4bade4cc8e410a2915a7dbc652fcb1ca7af78676137b28f1ad567c9b8f57a43883bfc229318af1b52d508dd8075b21732c75a59f8f2cb9951380edbd3070ed4520498839a1b0758b341fd0d45c368cbba8db7d43bb3e0eef5b479a943a1b2954cc2a2a21f91feb4a31d690698f2870425aee556d449f85e913f5b7ac9eb86f9d622e6dcc6ac411deb52072596596805f94dbea9b50bd88757b5e08d3fd1b9737959d76ef7b0c66f23cbea95a46582dc4625edc4e37c0d177d1455cec2e34338d7fbd1e3ce35fc730c174a64d7ec2d27fa6dfac0bb15d6c5e8fe9dca7ffc9ff8d9e626bbe0666889e6eeca15cf15008c3af5347e5acb60f157688050e87bba9aea9a1dc0038b42ab4a9d077573df917b3f2aeeda32c8512bf1f364f4a742648f4532b7caa82d3ad39d394836c5c55029e426a3ef34c2411ee3e3fc1a307973ab6c29a824121911e59065dd2fb319155cd1757bae4986d462d87d8912b90ae68acdd7c7060a112168f65f4563a50d9c6bcad954c1438312ae81b2050e14b7527a714222d8ed0b7a2d5d7aa840132a5db10eee1b2a4ecaa5125770eab457506a94411583161f5ef46f0b0962bddda9e8cdd6dbeb3dcea9b5a2c8463c6af079ce1624da4abab14a0da4d2751a8dc691ebaa30154b39f08793815b3a2233f22ae252057f97df68c5352c3983b91f4b8029adf8590b804a8d783777a111c388d02e04f220abfe38322f4a1bca931b90fe42f85ff0229abba819321d699cb42dc390c639d900f4af8a316ad34edb582a2a0442c8caafa1e789d5bcb8c043b8cec7e24207fa6e4c661aeef5536ef02f19f4bd147ffc905a8e5f5a9c6564a620dbff679d429accf817cbf60a177b94ecea79b557459196c955e8cf401584f1b9a823fa2e9bdfc3986e1846cf8c7b3a71d2e66d679df53763ab5d3a2c552b4456cab0f806e2b78ab8ceb1b6b0c22260ec950a85f795e3a3931638eb6c1afd820dfc4b592eee891c55a96d70673d2cef4756523d157889f295e17a09656de3247f89197cd20b09f6aaeb7f6415a06a2ce5229f654f2577bbb2b62ca4bd7f4d86c9499034fc8cda7083364e6aa0bd85b4bd593eaf7604c2e2091184444daf1066d70db5413d59d3a82fd5ac7ad15990a40b5d92d4a405607faf6c024b1794595ce1fa232c89a6e949d24cfccf4d47393ebfaf8c4fbb8ec156ad5399284172cbd7e802a95c208d42af5e08d47d897f0972edb0f9e1714cc747ca6f30f651a468ec69d21cb72d1d4d1860b609631334431bfa07437af2084d0b16a6dd4fdfcaa8f041051bc0d2462f4e3e3cca81bd7ffba7bdf1621afab2c2d74b2492510a01db052d0bc26c6dabbaf7ca17bfe1a56f8c8a60dd6991cf63d2f874ae26d8bd3b85657f3d9eaabfe1111d1c8064c5ca78aab8867855e2c1ba526e5d2589839453cccab46f67098aa7edf24a32192582d27f9b50585c0525a61fd85743983c38f667469aacac52f1e37e386865b71e0aab18ca8b1e16b900a4016ccdf88c4b9ae9e528c09515661b5a3f0f7c15703ec16f4c220d1ba8bb6e61178836aa40f40044ca51fd83070cbf25c752aa15ebd1522c3b0f2cb189f744da70c69042299941347a8271adfc6058183b50ce2ce20aaaee6a3d14977c60c64b723d93e6a1462521bec654184700da1297a42ed8f9e7cf91f89c3729cd40c1dd09087c08d42108f74192cfa673e7fe22abd77fa141a91a7a5b5ad70b4ae9063c527e3fd9e8d3691c2956c54eb5aca4db2bb0ea0f39b9c9ac55ab03acabfe92ffcdf3175256de776a09009bcb6803c9a591fa4bb32efefc358f9dbb7319a5e70e6ad7b9cc14d5abfc80a72c33e09eecbdcee1a2649d0a03f9ea0ddf36d1d586ce79c2bafcaccb5af9537b7859a7ebb9af6de1302c618431fd0d8926b59717f92d7f38863ed4b435a6869f7194893c9c0db5608df8bba7934ea1c38468722e606391526f3e703870144aeb374a7a2be52158345eea7003973cfdf363eb08375e531625ac6cff4c17d76c187257a934898ecb53f0b00895c694aa5930599d172d996827ebe1c049490eae1ea075e3e57f197c4347d219171e8eea7f529fce9549128d9435c2568c674a821bf0915b1ab1167bc0528ea0b418e11591d0053170e4f7f18f57793ca264554e4330a2a7c4ee5f89c37a4fb90ed0e4f604b6d6e88e3df0f117ba7d7b80e6911d119693d6e453b3b16dc9d692bd7552d959738afd6f364f2e375c4aca1909fdd8181674a31e200eea4af21d5f77e6b59eddf59c803f28ed2417fc6e13fbfbdedf545a4e064dc3ee24ef1580901235f0d732bbf061bc9841949385d11f9513c3b283a21dbb416072551be72cef3e8e6467b1439a7499d23deeb98311ff5cb64e126c3077c1cd5db579327b3d93492df06d77eb0f95f47212f1e8f11b9b6b9696a3044c321437a3d277c74050f5ae36ec901f6a0bc670e4aa8a9d40f5f08a5f97e89359daecfbe3c44fee533269e8ea2142465afeae388a8876112ac1a31b7aa26e3a125d8171952d185bbb234fcc7356aa686e7dd6ec43d5a087c59125866b9d867e2116883741e5c9556974e4e7bd6d455a1b33a18cd3b315bbe32fe15af77c9ae62b688c24521560c5d135ebe9ae141ed8b54fa6321adde081a35f080bab325a8203b55fde64730d3a064dbf58bfe38fba2a738ae3c5b4782c9b1ea59a350edb8b4cd13b720f12ccb21e24f31edd6f1b7682619c031884a60709b5acea6d134df1265fd037f95025321e660ceb2186d471dd1b7059467e1e1161058fa5d0fba290f175556a61cf45ae8c626b85b752867e9c330338e9ef17443b7a683ff6b745f718e60b16350f45631002b17a0586c86010d6ccac74c0b9c5d7cbfa7f65e1f89cd8bf18176e5a60cf51d2606a36580a4678cc3f98f8da16cdd05f935e77922297a950d7d92b909efbb9325ca8d1da612fd6c4b0261b35687de37819d0ea193ba8c08eb56dbad65fa247804134d38f8588f847132b70ca283cbb1d7632d5f8e853e6dbed1effacb6ad07cdc531ff09b03243de840989618ae6583cc6637fc85a78a567bbe532653966ccdfa6eaec8e99900edd985ed62a1ecb489c37d472003631b2bc97325f6f04ebd698f9c5da74890c16748bb2ec67c0fc62b3cdde4482e9e1530327120cab7e98c4b5694f8008d4e8794134ed7069891c21185b781eb42933b71f01deb359fc454371716d2219e212beb879ea2af7f0b6e5543b5e47b58aa310c536fc86b92af8e3b0a1b526e6004e78a5fb2870e608427cf704b76ab06728003f1fab2e9627a926a59505600e555858a6c22ce93d95c7f45fce5640f6da791744fb46f46cfa36b56d81e7230b30e3192866b4a121dcfddc2f166ebf1b3d4b10cdbd870a563b196433687f755cc7d42db3cca0bcb6314e00dc73d5796f5f3ecec71dfb3324bb1d81187a706c8706f93642adc56cc37f252c0069b535ee463325e28ea9ab8d4ed1c9e1587b81f1118c1c16f657e3fb6cb9e0b95f0c2e5c844902868d7d6b8865b10f80050dca6424eefbfbe69ead18f3fcd685de3336487adcdabab556be5b02f63b3ee8afb7ff8e0ad077d29d87f411fbee7a1438254323679652bcfd0ed30b81164379b5e5537e3314de22625798f130948f6de78cad51b63bf71543bdef93abd913b7cee6028998eca74b3ea0d9d19aae1b63f610d93ceb12011d569056884630597256ab0e7d1ab8ccd9ecc68aeb471f373829f55a696e5f35289b61deecb23b76feb0422f6b513856c9c25b9b1e102c3b05fe8e58e56c67132f7bc8e829edb14602cd3567cc7127065498d9f8326138595696f4a828fb4f1eefe8bb036bdc45fa530a72b1f26b5902c8b604ac0287433847cdea6f48aa69e1255b158b44654d704e2ce2f60d8c408f6ade1429d67b2593ed17aecc03292eb9255680810ead6da9e08745bd36746dd1be14d008954e7bd281d28df0605ecc7c2f79500bae07f05e6680315aaf2e82d29d88364cdd124edb8e5f41db5aae01cfbb313a51b1bb91c23f3aec91be2373f12d735a79618a00898cce7b29405130a6b67b3906580c81a771dc4c1b463b9cb0f9bbb64d6090effd4ba9b827c4663ba51b57cacfb763fca87d75e195006e126974d90b1e36f83d635645f09d97f0059dd00bece2672d7fd32dbf2481128ede9de40a784c5e32e3301d29978e13cebe6c99f0e3629613f167ecdfea2e1d9bc1eb2c188b09bd53e466631a94a2a3b5a467e70b2e13fd16ba98601d64d0f91378da4271d4052ca3c441fc5705cd732510135e810457b37f216d2abc2b1b2b8538c18ca31ffa9ba5fc918b3acdd58dad52d5c8862524619f82b24578b9dc7d5e88694679f7a606336b1dc5e95b77a419a52a10e48c021c2f5f16cdc9ea219d141a9a4d4e52f7f46cbf59aad8af304a89f671146c3b529731cecfe0a0e5b91765c7c3b6c5772dab5bf8ca65adaab166fda5865ae88f5d657be3e6498e4196e7cc3e45751a313e1eadeb3148e773d70a04df4d74378f4ef066e4d5e4a4e3644a5f670fac3a2dbfb921ff229a344b413027439154a902f0b932d4549610c9510d37b2697db98224faafd7e2d517ca134e30a0fc31b0ee78245e7036f279ec3013b16ceb71268358a94d99602862872be5f1e0d602054728a939062b5756f5ac15a3f918af9b32fb994fa5ae90e06a8c15cbe0e9ebfe6aea16ebe051542dc709016ccc6e93079f2c8779b1ab82e706b50e6f9166ec0be7d47e352e2e81628bb25ad0178008e25e8ef36bc00984a33a4723abeb7aba5bb4ec3ca96b4d9717be78745a0acf5497510747aa2743d94d6710f60b8e4cad9cfbe59d40874d99d57d3c3cf7408803e3be5956478e2ea12bbe6fdff9b2296d273267dbe95b7c118ae7b2bdd694ff2b6b61437637fcf2793de185a65b4dbf27f7c285485df618e4e3b7dbe5b21b33070b7b15481cabe48d343153e5894b13210e6e0ccee884219ebcfb83c5b1971ff721f3659c32d6ae522c07911c6a4f717345fb2cf46d57212a9d11e9a3ff14299048fecf0822e7a2de0aa71d49e04240a6e826e6a9b0b813440be052be2a07500cd61b06c4f01b86926af3a3f449a6f8598efef53f83dbb1e27a5df03562c3d6e622afdead567d02a8db2ea31d0922551795b5e026d21ca0ee1516d6baa0578e8fb7736aa6dbbc382767ca0de4b3d0e9d677c909aa0edd1e7fc3108b44d2eeb61713d2be1eaae495b688aec9b25f1514643b01a34d56aeb2db5fe3a21045e945067350e18b692a3c5235d11fee7d11467e71657e64366f19406f396b4f54281a08d097c21855eaca03e6fb77f02a50f236a7aa1deb423a09d27439fa2b114e30d38b906429a764133b4050540024f008e91955a1eba4cca3c64004874458d8088ec6e1b108be82da99846c9936142f304eb6dc6b439074b49f934cf3cd01bbc342b793a8ed8938682a9e30732118923e88efd6637b12427fafb87bf4d8bdbb18a1a1f966b9c14780f92f325abb9be92d1aa18381605e24b73da2e747707b34c8a5cffd6baebe5dc1f8ef927be398df13dd4100746c06e03332a653ca7a2d40aff608e18185fdb94fc6c8491cd21ba25f6372bece7b01b4434911b18ba6cb5d0cabfa18f64a1f16ba4f006b6dec01d2f4a7a345dcb6f2487e6c21643fac47fe7f7adf4f79072f893b65a9d5977c3b7220eb0a77be4fc92179d55da333a007c33b68567d6aad6acc24b40b91b96c7ba1eae38d9aa08adef63a7cec7c115a3386ce7af4041940422355e5b0252fff947088c3648ee8d1a3e5a1db6a5fedf50975f29053756e6004f1e4e8b906805ed5cab47fd52753e433acf8155454fc72d9dc07595c2423a2985562fbd8f53e7b1822850304134030d11ca6f12de17a1edfba146cbb4943cfc605400c0c5a7d6582a34db7fd631007571e88c82934267da0b6e42b0e405a30555092ebccdf9e53373c1912f02481bdf5a2ddd0fc503cb14763b6d5c4e59fffee033308857377c7d0de2a823169b7e4e60ab74a2a99fe872becc32d5a08ad81409cb09bdcc3c51bf33a58c29500c8176dbe9ae99aade2459af7579becd7d632e438a8647dc282ba1de2373b5a7ac0e613b91b042bdb09bba56246dcddeb6a9facba68614a5fb3d6ac4cc60286831f117eec04e9f7250ab031f439c6fdf7e144981b388c1b64246a5ffae915d9d8b21a196a72189e7abe2c63e3d07314ec0bbda8d62edefa4b0aafd92689d1ee22c9e91e7af35c7d7af1005151a26ba28da314f6de50af7a097551b480db898051f76d2c475b5f0b1613041ece18f4fdb850ddefeaa178addd59ce8e2253ef4795fefd25b95033c3ca4b02d26cc435f6b1fff85bb3bd70abad1942d29d45f074b75c010b9982846b0fb676b71d7b96e3223ddf8f591b1ca8fa7f9c753dd876980bc67056942d663a3098fb64ba0ff88376e03fc64949917b4c7ac17c9d9420b9da79d2f165d0cf20e0a6420cc1f695932e1340c3d8131c62659bd929a6775efa8a4f2e8297baeb038214fb47d03b77b7f9f11f46d39ff6df44309efed75da475b769e46fd8c1c6c0a978636dce4889f54f84e66fec88e612e977de689556b9c3983c197ddb8d8dbd448a263f2ea6aa240d0b8050b8b5dd07ceaca88f5cd7167f82929f4572b1428b87eefa2f4cf0e7a1223b4ae707ea6d442b7d6220d44a9be4eeb7ee43fb07dd0725b12a9aa43ba6cacb95e2b3e9df16e040a780e5643c627de83b11ae4d2fa056f2e9e08784503aa2ae3b89fcced6cf3b68499980a15550aaf151dc135badcce52d5876e5860402f58dc155f02a24f09948d1e378f75fef978cd02fe687ec464eac754f1cd2dee60486b0cc901e16a2f16a2a3a5f2cf710fd01e55d73dcc7d1061d2c4fb84c9f53b3749d6884c010a4660001b4cbb0a8a5719e1096a75b82ec6dfe1d3a9aa805c0123d8ae5de570b6c6ae4b1c6f1a316f43f8306b20948ff8f5e21c9acac37bae4b833a7b479572307f64c778dfdab73e068f578be812df16db6dac78ce2960b6aed52cf9ed5e3534822709fb027338f7f6e577ce6a0a1fb52b0dd01846adff1e96d2e5457086815a0f56c7b8bc04b608213571c7db63462a340de83763df284a13fa90037e9c6e075d527089595ad2562769612ec8cd02f3d84f2cc28fbee519d1e638a3870586374b7ab4358b44e72cf94dcdb544c90eff1bc1f4920ada233b4950cfb177349f138948fe486bc099a8671ffe4d937ca82bfc5981b1ad8f5e86b8895b916ca4deb074924923149752f195da6f0472b8c8f5bcd20cc212b1a9a6bfb20391dc69c06255fe5d0cabaa66f56d77dbcbba7d09ec4f88c6c74a4987516286f3dd7f695bff0cfadec61d367c21f36178550c5f3bff8a4698f1c16ac0c80e557f68f607072e3563c3f0d4d456f5f513cef7935b3231a238277b0fa65c72d22b91fb16a5d3b70e20b2c0aa57c29999a505d5053d6c24dc5515169052f9415c32846d9ebee7eaf162ba33fe1438d29c56c5a958eba878a181895c59d6d3fece8525ee26f2a10500487202986da8ae3a455825953f0e77da6b138a4b9c29c1e2d26e079ef9a7763ee9c7d21d60d6a60520a83b3b124d5299fc6bf3e0b8f49e03d4cf802bec9ee5b36b1dbfb122b7b89cb5ffd9370dc26cf0eebdb62111ed18c65b2a199051ac85239939d0f5710850084b0fd1a2bbd9bfde407c7d7926b8ad6cd12cc3a9cf475976f35eb728e5ee656e0347c3290fd11d9ccd61a50ef7c013cae259335f3d05a19d1d4d91131aaa7fb3bdf33a9d9dee0f238264d7f59e6b73d5a7474457e04156f8dfde0f7bc133e2db48035e4504b130645e494c08f35e934616fff8bac4de71d47612c9df8ac8fc4cf62bdf191d248240d7244e97579e6114838f4de58359ea80d2ecbc6f321ac5cf005f8057d7ab7b07609968fcf1110d3752001ccae4b993a7fc1300033b33df0d89c7e66470c358843797537c55f66c3410e6c61e6484f199eb21d94568d93e6a908e97c3df13def3495f5c0a66c0e00b3785b4885843319a7402f943d50a52664d70af2e5161c654d5ee23896940f50e7f0009c547bda7d076bf9407271e9d1caeb0485b30e20ead2ebd0a0803847cf0c9192cd8ab233b64b902f5bbd07e9cd57aaa27b0f7008523cffd3647327648f048179b654ac5e70109f9fa083ed98e2cad99f761bc6486af3d86b62c86957ae519d923ffe78889993ebe79993b0bb45834569b9c58343210cf9eb04e697078c8f379a9e5ccdce8e6b2e851da0b087f575b8c35980b155463dbc2e7270930391babfa9e4ac4eac9793fbb2107380f88181f2fe54b42c57eb778688f774d8401856fad682fefb92df49b0f483551341fa176e454e8a487b375d768ac90d1e4d90e3f74bc5267035982577caf75290189a7495981771b0139a1d8fb5beb8ea5bfea833c650f178c48a5dfd4f2da65397562c8add4debd06699c9ee8564b007bcd905fdbe8cfa2674abcb906882d728b65a984cb83721171528ba21f9a11166af18b61bdf2bc49912fdbb8912879d4f1f071cf85ae4aa8859e9195f1a99016e4761a883e444c54f130088c7c8b0b3bfde9f2e4afeeecc9af85572282c0e377d8c789dd58803e9b2d2bf792924bae833242de87148db21ae7444f75be6c99d3eb9ec90cd67db4ff6f3bcbb274ef97225383701db268f762f5b916e4fd144dfec2d2d5f7cdb68d7719dbe400186281ea1d8d8050fb69d1bbcbb6aad87b267299a7037bb3f6188016dc7689759adb45ea802a94043a78817f184fcd10bb4fc60b0e4f98a390b909ee0ec19be951e391e9e89befd53ae2137a48294032264da8bf48876cbcbb63edb0caa6c96e111f8bf28c39e5e9da069a3b46bf9b96ad68ace6b6815a6772d4b0b43dd0872c6945b0d0258d321140c567c17f08bee2239cab9ee2aceb5d5a3899141c26495a98a9967bd867aa335d4b1223f4676debd9f6d55ed9e61be83985339212773a0f24e5b87a6896f77368081c9e73632b17244d9adbc7308e59866390180b35398257e9560e5b1c2acb4fe6a630a7b158c7bb61d6a12d8aa6b8d97ff205be91a72d0e40cb5102ae6eafb0a364d9edc05216960dfe18fefaa473c68214e0e36d87b20150afb7f274fcd7b208cb43631ba8526927046b04f2ef90e5c047cdb3ee69ff320742b1dde4d123f26b1f5fc61d6d51fd326ccfaab049fba61355ba06a3194b060594943c02025ec70dcad9a84341fd950cc87cb398815667bf1877f4d04ca0870df2bc995ae6743cc4d3fd22829c146dd8cfc91aaf8d8ff91b14f00d097d9392d11dd63cfc7e36fa86bb79a0c63caec22261939d2d5b1860d7c8149b3952c006858041bd5e6a77b4062c926161173c8befa55ef0762c07fb2c325c0f830baee6ab4fb36094d460ef08e08d795ce1b388d9ff2891efaa7df4994b171323d3171603971e1c70e95bb92d177364e78f335f7d21708a94971bd2d43e239bc9d0c6de4f6f12812471790ba2887edaffa4b0ab105f12e4c3fb61efacd9c03585957bf37898179a77368b272f3deb250693eb2201a5da1dbe384cf001743c4337a90949e84a9015917468ab9e11058cc31d800887228d2247c5fc300e33afbe0f6865617a984b1b9b2d5aea1d2e88675f7e8446e35abe28998cc5231c50268ed775a0b370b7bc5cc987d9fa043f290054fba4077294eaaed832249a65e4f5e3374ee43639f566a9e0fb46329a89820d22b9580adc417a031168b4c2e64b2972cf565b3f9688e2579581833920dcf155b8c80e1e954ebd0e267569ca1c0b9733457dfc83f8b365fc3a696419ea7a82411d0a0e9981f55e4db110c8ab9bdae3f5f7da4439ab4607ca230cb0b8c411e6ae0b39725d32211af835c05731f8f1aaea69db7529d4a6697d4392a5e5dce71cc3864237c32b2bfa9a34028712471c60d5ec864755b2c9b1e97c5bafc74b309f9fd4529a5f3a97698deba234b7709a205bdad5f137e541d6137e55e6f7b8f4b0fc78d9d3e6b439ecba2a30b8aaf56024f22666a50515fecb20e3393be2ae65ea286dfcce361119c847eb0abae8edf9ec61e970f9d31111cee24c1f2e456bd3968bc25763595476be7afa72064b996b048d1c7dfa8425a7f45c0392d6bda76c02253690947f3b7dfeaf4294ac11b03130712feca94f5ddf3ad909ac15b684eb250194b9754e2d4c57b8cda62524e4de9faf09d9bd8ccb9415790992ccca83528bf0877f8e55141cc49911d0cd116b575d066b4e3650cb88a2ab3e3de69b08b91b51a373bc81389cbca2d4d131d340ea51dda87afe8c4eece5023bf0bf563fb09914402f0d3704d077fb6da826b46ae63fc3851078837412f720d61d5befdc91db6862a23969b2021f81b5f317454f96da8c55be20f158f82549c32c44be6c8fbb5931d705330075013c9bd465e8df8f8d6f872c16767d15e2c609443172016709b4657c01f4aff2daf6a46a9c9c5a6027d2e8cfef606be112e1470fe66040e9e6459641e2da57f64b4ce27b770ce738ade2156403733bc24003fbeca2835d62b16575bdec2966494b3c105253091864cd173c7e775c1536eb87eb31c0b2ce54c669c94d89286f746253a3000085acb7b8ad06ccf4d14104e7cbca8fd6835e798f4f72fb05544e294e356d1256b4a8bfaa29514554ac92980c198dab838d3bb74da6bda5d2d19c063b4979582aa2c3662b084344af78eb1809ac28ed20d86018f304d7349f72a14451f02db6623f74e1f1024db848e3f78b68e694d9da38ab540a7b2e863e64b8e276cabc714433c74a3dcacfb58907b8cfc855b7af2a9b55e25a3fcd3460c9e4a0f737e38572655dd89595808a49967ca64c4850b111d13a80955d57d5ff49b5202dfe80a27b56cdbc475db62192d98c44afd06f1a9f159ea094dbb6995b1f50ebc728b1139e9e9a50e2074faeb191a926f80bf6b945b1fc08475ca26095d5033b815e12aee02fface67481190afc7eb70af8cfe2978706d290df77c656b7a8339bc25904399bc9fe203bc3f67bc2edc61a64f63cba3a0c2a0553b184dadbfff23ca361da241dc586534be4ee7cd1f3c3bc2f7b13b1153fd51b549b7ebc832215c3b1f22c02a176f1a24adf9eab0416b45472bc09cce4ba44dbdaef8d74598864081b1a93e362124731365b45e8df0a445a01ecf8eea19b62acfacfbf74b7525a658cbec2638b26ee94f5eca377a8c184088d4c8853304f4ce9ff08abff74a01dc5db66517cf80fab862ac0d5aaf8ebf164d4dc169909dcc96e5e9fe8c1aa9691ba73292a582954ebb6ffca6ae82c24477a0153f4ca34303a1f39a39bd8ced305a66eb2b7f4f13d9710cb68ddb339cccb13cae3b0a76228e731c639c53eae484309ed84f9cc964731ca3bbe7d9bd1d67035f30e2d23e921710d961d66b0468fa4d3b010846a5417c82e7645af5c53dce1b14585a34451f80ffd42bf69dbf6058bf2b6e02e59bc4cd581a5f3dd0034ef87d777acfa42db94554cf1cb716a3cf5d42602c7e720575cc3e5fa1e7a9fdbd410aa358f8fc790a24b2afc811eb3a18260f9c949073f8cf5a3b870efe6d6116705773e8716325af47319ef978354a56a7fb329c63f8f2bd176c67329164f9a11012bfbd86fb2cb47600ea918b94960e667a11a5a563590f189444805dc36293fd8f1c7ce79170cbad883a8bfa811f611eb2ec03772bcf6e7c43ec7a36a3c8d7df21c851994bcc2cf7541010e8ce09a9eea2da9d54e40d06a768ecf99fa5c2c4426d5f86a4279114fb2472b6b132cb52f037f8865777a22a60f411a1fe79def0885aa5d16f301ca8f5ee4b7f0ceafb0b94a4b7387eeb44f737ead9d3dc37530d34fdfc8379c73df855a429a52a373ed23d12ca9655b0cc3a222c4a7a4cf32da521c038f314ee56330247acaaad2ae561dc92320fbff83160a1fb47d54a09f3b697530c4a9cdad29dfe6c00d328b1e5e0b5605733890d5f8e185f4c04d94a238d642585141c9e3323f019161cd3514ab228eaf1e4d3b51df406126d4a5d4d4ef68899b9cba4c17cee8d0fad8d5f247dfbd376f0651d8c8883d2be7fae102777bd1732e9d654bffb8fd88eb402b9ee4f1403806cf058e7bef19145b79720dfa5c2c4f74902b8e434ff43e428eb0ee04a945dd377d611ac3f6f0ac3561cc3b332dccfde4294ed1eb095b77ce45e31aab1f61c7d04b52a8715e31c71196b5a0a59f3463e53dccb8ea80adad4facc69dcdb98d3866baaa8343cc3041a66b02438c17a8d50d3280c6da7b9610b00acd7085e5400527017de5ab787f8c5525879afa5e0305cb51a00e638c702c9871d3809f79b249288f3419f201cc6b570edadf087398f16ba9b85a19e1f5964ec1af158fbe4aae3e0c7c2419fb0329caa6bde66c5616918e29faf088fc047a98fb47c80d3d75596000f90b191ae9d1b5732262775f5ad7542ffa6cc64419ce56a606fcfdd837c7932dda14af9b74c5faf36d7ed3d11904fc049bcaa5e7cd21afa641ff9ae0da90be7e5f286070a73166f7a952c77fb6e56ec91daf4a44a61a01e4bd55544aef2d2cea89ddeb9752d37311c6967658811d7eddcf9a835e700fbe9dd10afdd14096f8e5146c6bfafabe8a99b5e5ccf40a08e87968e9b6cd112e91c0a3b99d608bf08ea37be14f8eb8280e6b082189fc35212d2a7bd4809324a72c6d99de10c1a5689e827278f577e29ba4dd77c0fd130e66863247d58bcdd34522cde878b335a0bcc051ee46d44ee6ea1f76d15f6a0912c244052dc07c9d55d836eff30ce2968733f9bac100763bf82ff420973f3c69b96116ed7a45247cced0678c407f0654f50746237912b24b91ec2976b684de9c6cbddf8ce597d16ce0e295921dd29154e6a5e7abd88d6134061945d1c3e078aa79f6028cf9241980da7fa9056655d5806fcc98c8bed05b0331a83a86f585aa5290729608da68cad95551e6d591ffbbdf4ab9322db8df79d0d24d792fe78681b07f4eaec0014937e5c97699c8115e45dae0f43c2241bfa34b4cc82cc2ebad7a63e4fb5d9ee99497d442ff2fd6196e01594605c6109120724febd222b5ffc3374ae4f1c296d0a14d01b177e34217a13f686bed6131968971cc5af131d333e7d3fcb277cf8a42034db5c979839c797e680001d378ad9b631dcea4ec9400e6a9f78044717944ac9b7522eff412a135e21b01b28790625ac762cee96ec8b791f12619e5b312f82d29327868675e099a8c359eb519b29bfa56ed926307697175b96fa7fc63b44d226132f683a3985f3613d94c42c3f2ea1500f12eae8651e14ba59b97ff9a712f1450743513d8b128f8e844d67895754c1bbd0b84ff5b238957dd969b4acd9139b68b898d35cdf652fb5526c2d5d539b9a9ec74fea0ef318ca4a2c1e6a1a9583918667d38b71bd99ea006535539331c4cb308bcd2ab599dae28749d319f2407c00462d59b10fe15a794e9564f809a0fe087a9aba9fc10bc975b0a1186054096a63a400b99f8b6ffe752cbbde384d3e2e3263c17c0185982fc3b193a00c7124e7211499827b4bbd5d25469b921d4c6a8a6aab4c8d0e1eeca1206203c48b9f34c5d886a6e0408c7d1571e79ae2b3f2f97651e8348b8559894fa4d25a73650c7657dbdaa18717e415f6d4903ebb839dfa1cd389204a4b4859684787101f936820cfdbd75047d9deac666637af57b50db118b41cb8ff107638817bdfa127e8c10e136d55cc06b102f8c0c094fa04fd9385fc14e9131c8b14f8331be33536fa72200345897779ea121061fbf9d81447be88ccc16114457feb323f99991295f1732999e9edd7525e1abf567a6e7e61ff9601f8783b628036d26c3bb3b9bc7f13e14ef003c48e2585e68ed8bc3338fbdb540fc2c65d3ba68a6f7fa6e6c337f3632afff267f0f4f98c6ef4a44b056ba7d0434f573a3930ec16d4c3998ab6bc2548acb5f70181e809ab2aea5e01a9c95539b76123934a279a05211db87885a2f1acb45cb1080fd0371fd8fb86e2a2c757894ac4e1c4df7658175da7f042f5c1dd4fe6dd3b5fd4ca614873ce6f6921831ffdbee148b2f80e12cbd1f12450b22f3fd77b307a266d2b9044bad732de7883bc80cc0c21e9d37a44976b627d65ed72666d59536254980ac85ea88ff62ffcebd6a2a9bed34b2b5f246e6c0b116bd00dd31dd1022c4e96575e04c5a930778263fdbd8940cff3e724864f662738837ee3acb0f3b9f90c5fdf107c6a51c16aa31b41994f57730cee877ec8ad515ea35bb0b5af7d5bd053ff50a5325581101001f461331432d9154e85d610c8209bd29402514a8f515446df1c0dc6f4e98b533261a7082b33767b6e9514ee3ef33b60f8cb49f56d2bae3b8b22d6d49be880908485aa96bb258f59f6676729d5677099c4b0481944b8478f5571cc406ce587add8ac481e5e217e5bc2a5760e46c5ac5de449d3d535b01334494b33e2c0e5bd12a4ae2a2f4fbec8090926230628a03ea6ed184d70c0a4f801aee5c647f387b1298a9cad1b5f02f267f9ad0e566886dcbb44fd4ca0a897d680d2fa21dc4dbc9040beb5fc38899ced700164d751714832526414d425802098cd9f182028ef077bf3e754edf6adf68ecdfbcb4f491cc9748197ad6b5e1b3c4e6ba914839d5a2cbd3705bfa710341dbe2b9a9c80c23029e459659d69c7db3735f0f60437f5526933e50e3e8c7ff52aa752a9b586b09cd33c1dec279b2bc2fcf62bddb9d8111452df7a42ded5c5c7cefea490f1fc9220985a3774ba7f072d913a990e429ed90fc5d1f3fbdb290507c9e380089156873bb98cbefa950a959bc696e7df249ee5d9e9249c3f96e2dd585ad3b185c100c565c98469714495da250e9adee7ea7c5515dd84caa2fc51ed7ef57e70b54c5de594cee5d3189827933f3f44eb933b58d7a2ecd2fb0e15c6c4a3e1690f1429ef09ceae34e5a454cfe1aa3fadab1197f46ed25f03d1bcb8a24ea5dd82f2ffc4081ff24e6681f40a0550848eb6a1c9a464f64c6e85e1607a10c0d5508165dbde85159d55d4004823ad9f7059812f0e1f8d78f7f6b92c34127daeabf6533ed6c55ccacccf18b14cb20f01ff225ee0fbc0821d55a2adf50a7f210fd8eea77a152ee2b5a681cc0414393edc1c0b3fff9542b6b370393a995c8ee5ab03ce507f574c03adb4c75dce362ac0ab4b41e37d76410171bb129ba0d6718ea9516a6ff79e223a2ae54158a62e2b2318b6cc399c66ad290ee587442f79deaace7ef4bd72706c59c50410ad97ba04b99eaa3db80856de59231c1d056009e1af9e5f3aef97b2d3541b6322089770eafc9af5d3b3a7b116e7936fac19246e82478f95484d7256f0d25b85c993f7c112ed148968c581eac8a22b0a2997ff8446c71cc946865c45261fdcb0f73b2d2a283c2f14d0b94b916321f066784ea25b22f8ed430c68ee7b54e86ef38983eac679ef4fbdbdc3c969f541b1acfd0be3db030c67f8439d7e3cab2401577805a781d5db223e82371fa1d4064e14f8c2ca661af3fad257ab11aac14e929284315807fc48d56b27459c23856a211761fcb192edaa6affd6cea6b3dfedf92bd084605235ed36a51c4da93abe383ae1e319352b6eac64d8f8fde6af9d4923c263034d6655a5e927059abb2f57b8bcfec1cdbe3a196c576f26cdd07fcdc83cd281b26fc0b313b5e75e13b62b079866aaea925f57640a6477c15e83b13d2046aa457c09ae73b6f15324ed4b6fdf6fbd321d3af8841981c61000116921f1b026f37e34beb1edbd650717437dbc5eb11dc3a88fc3b192181756e49c8c0e7a5d759a3c82f64c713856f6227fadd812ba3de45556d5dd04a38b1aa1d4a41241c9d871ee60f35faea7450db98fec52586a3b5d67fd48bbc9c0e1a0912fb62111baa1bc7167b2cf67d44ed85eaa961af4a63b7a7e6a9e9c0faa3b0f3a55acfe4f3c973918a73959eb7aeebfd608abbae384bce3dfd6782b82caf9c8a6ac543caa825bf43ef2e410d2159ed31c6a10f65b0cf8cfb61775afab8c786e3ab7a1ba1df97b4131b01aa8d74e346a4de7ef3833fa525d2023e24275f3afb166","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
