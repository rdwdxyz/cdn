<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d865c4259f9baa7819274ebf5c7acbe50667e8121ef4e0de52d855afd5ecd65c2b0c392a4899eacef1cf790e56a191694359249257fbfd77dd23e0ab4459e33184a6c5b238c00f55c61643c26baff7701e366b60e6579fb359db27abf70dd43ac3a0a8b1118aeb342118236eb86016ee92238e0a5d252b5fb5a538b91666c70bc0490b017e1f2399b19d4feab397341216560c4934ca8464ed8af03218b1063c144abd4e0d50292cd8358b96d4de9f6599b3fd4a363b9b30c6f14aae8ee935e99047d2b0fc8414802cf759e1562cc3f7c6153c931f8d5290acd70a5a92f3e8b7272f177862c0d842587904176d71ddcf5364e32429f2ccfe84b7023c79e5cf8f83f4e1e360ddf4ff754a180c021acada93288101cf69e75a47a129510ad9393f00b367b5b6b018d010d7e18e069586a36a14f543304421a17ea983294487c3a36ecd7a71d9feea360c7b99361dcc2fdf0c97a5d792a24ac611539caa7656e9c6b2c8e06615daf932669180003fda06986c30d31529e3a9d798ee0ca0ee46e524300015b2e06f3be3182f347dd723ce470bcafedcee04bf6c598e9e6bad63b04ea7ecfd5027d5a903621a03994d4745f738db3bb88b7e2b03fc22c273113ad186fdaa7922516a6375c9c11523bc1fce0c7bd3992bbe30591ac6fcb9dec7bca66a2fe05121f16be592a74740bd4449a9fb56f38de214f23949254415350ab1d8d98c0ef1ef41310aa007ef0c1f499c41ce42c4ac0a0b50a0c1828a04b0d5d1248d9a5c4ecac51ff2555157110eaae304968bc83509affeaa6761f33c4eef98a4bf47e756a198b416409119bf18dc5d94514588a15787b74450cc3162aceb488ee929f370b495123cd681b7b13d77f3ff34b7f41025edfbc378cef33c9367879632713e9e1130ee1e30b89836256edb634e0fbbe3239fca4c3370a49614e9720fba2c70b7a1cf38e4a94785c5bd8499019a0d5ae9f1f22409d4327f794d155e621e910e7406bd2ce2ecf7846277f6705af7501b57dfda9a92588be187d89685c13e6fa545b338196865cf4512b7b14e80d740d145567746e6b6b9274f6c82ea4b255376f7e18c243bf026b2be76c9e46e81cdc9a62c8bf456132484a7746a7574f217a0df48e4fc451023dfca7c49dcedfe8fa7450ea139b79219270a78a51c2d1b7c0958077c7a1a5f98f3d54850b487d9aefadafe4346ef4e0ddf602b021740d47b3c11532574bfa07c7d4f04f29c742e3d8bafe42969a8ad433bb7b40eb273e64e3b4ca386f61c9971893839962ee4e0b026de01a06b1e0bf853965a6b66f319f3c5bd18abe022b14c360437fa7cba905f52422270f731c3af02f6689dbf19d9e80bf8ba4b8f52ec57eb5879b85bd629926ac30279cb0a28a0756244991f009c8348524905cc274f19066196d2926687e57aea96b92744d0d1b4c2ba126eb30d7f0167d50b52bd902aa749e1e567404b6a46ee787207296426e4e6a16ba8339818a6786bd03074ee5aae8531b18942369cb3211f743343264e78c403af308ee9e5434e17a717c94bb791de79125f11a4a5f4e7acf767e687a45141b7e41de2fb6c200ceb5d99e9bd443f1b21a1c04c0332582712f00010590e41721c1f067a6bb5dd7e3d54ec4147882729476369cb5300d02982acb7fd784ce90dfbb96ce45f86a11df181482f09859d90fe27ae672da9e00f0fbba80a02b1416ead182e6a9939a8ddb0a80b4a5f56ead1b6a871012ed31a4f38e3f52892e44fcce2fb59d0fd150000bd29d18739c0e73fcf1fa3ddadb7f80b9962866bb621cd60c0f9f30fa1e066ed039ae2e56ab018a0752c90b95464690a28e08e584e629f71695a242d4a4f8f65fc612a18485f8ce2c9557f5f384de89261fd1dbc203129c579609c93395fbcf63c614ca73505f2370e85f04a7babd7d5340642fc4ee5447ab95c7f2cb3a870c969cba9152c5fa2b75e2c89dbd66362453b8ca2d64c9b0c2894f8190d1ae8dd9db02fa3068da2d7d7fad040b5418a25138464d43125acc093c888819af9afda99eb8fea45065aa4fcfe46a81a242c264a635362b7a0c7fd7652302cc466b5ec3c2e7ca3023cf55cb960e3e5af5df2a91e81a1925cec020eb2be626539b559ea81f7998b340b00989051159de33fc527397ff8175acec908f1551784537e67e7e53a57f27df0dc5dd008eb4a3ec308ddc524d326fbd7749129ece84f6a1000dc8ee3c2d89685f12a175bb05fa12e4651f84bef88b0136a64fb01873803fc09d76cbc0ef8cad38bf6016e10a65a0954b31eb8c3b675aff75dd8e6203507073112aa1459949fc2f2dda6b550e0cf08066c25e01af70207b6b3261f0e4e41ca1b0cfd30731a6ce3fffe583d35bf8fba690399a69c74f48cc8965fefeedfbe1c1fc12e00e2994dab84eeaa72ab738a46c29019f2dd7a02c70710fbe196e633fa1807927fc214048510cb7dd51d317019a9f6ecb8ecff178f70e0a6698ca3afce1fc608d88d009de6cbedd15330e97f587cc5d8b56f3fe744e9bc0bc3c0876bea5f82f02d14066863055f1bd17deeafddaa968ca5eb1eba4e70361deff2d3387d46fd2b56e76499f13a600f02caa59c15e311162f06333c2f0c7badfd5c0632caac48099519757adbf7b595c027e99b7ff8a20b33b599164f6eba54b3b9e8f088b2b2f7a62f4b9c7a7a3ea354f916524ca94e8845a293223d4396421dca09c7bf380847acbd3561fbfb476ccb29a7389b46c48842c4dca5d4a600b669f1eef8c1f3ebee99a877441cae68ff8f1f75445aea55990442fa056d4b0a14f5237d7703e7e0cfd72f4f684e8ab3144219fdae6fe62b10c0c075c30ae60fec08124f7002a4e68fe879d68588a0eaf67c8ab86396348c710973410f6ff9ccb46179e72ab51742f1ac28bf7925defe0dafa43c5f5b4b7b2cdab0ef716043656b3dd8f9dc067f5b06c547f4dff39de6ca4134fb306f0f3ce8a0bf9b0d8af043d52fd1678b9b42f1216bf6a8ec59758063fdc6d90dde0133c5b78590ca77b1fe3333f301037757463bf52bc3e2ae932c701a04be97ee2cb0f3c991a63bacb7be82a99609375564a3ec3f2624b1438b9a21a6487699962d794ebfb5ccc5fcf712da3f70d1fa81b4fa0b6d44d9d37b361809d054496fcb7348fbce8df2a8270963eec9d75af322bf3bab7dece6fcf2b363596dd422b23f856b57261615b1cab8e6bf3a445b0c40a36c1a367a5c769325071f1d9c36be4fd05feda906787ec99a29e9c0e055edfe6d79954f107a31bfcd59ca610a384df7c173c59d741a1dcfd01410ea65e083b8d794b77a8147d0de993452986040585c192bb5e20119b07d042fe8d1ef9cd99fd29bcf1d83a2258aef8b0de594d154abd077354446d149de1c85356253ba67b6f00a1a1812384e44ac892d559237de5110195f491248476f2fc05ef02e5f44cb4c651339dcdd20ddbabc4db99786bbe2f1cea749a44ebb71de3c70a9a07980aa5850d491bb5f2f59df80cba0a7aea9b30e7711c1f49fc84009df38d6b42692f404cc56aed2fb40e15da73dd6f8193f2bf6bae5cc214e514a507a7b662e6da131964210eaa75c832326136c6b435b911638a6052ce32994a36c8af46bb221de64d8b82e87e4f0e1dc83972fa637d4406744be93dab41812a4f01ed3b15104ad852a8f8ba555d9db12cff3b4372922867f27a059a3afcbe9483b083f8ab44b9f9f4f227250b55f15500ab6a38676279bfe71bf15f8b46277e00fcd1b83537eb40089785fcdcd10aec22dde4d33e441faa69bad9707e5d8f75f6b95526a201e342e2f8b5de4b8ee613cbb33f8e3dd0ad7309e898b44a64ef6433f3568bda64d1f045fd3129714b1888d1f59c3852ff739fddffded5a58de9017c4fcea9b9fc1bc87fb68dc73f3a10ac0f6717cdb9e60de562fc15e8af0590969cdf5440a4a3d4da0c662d137b830c66517a8aa1029a98e98404ac8c4e2060fefceda508faaee8dcfe8b88eb18dfe61a4536d75575e4099ea6ad3b1d97a26ee632027c60ffcc45defc8beffaf80c2db218bbe71a44b28d380b7df9779c62d7c4084e02465965f111c009d1be6dd1996d028d32f34142570077ff0a21c36106aa2d904799c6f68ba83943a62ea2f331c4f54eca53f9127d6609bd66290411ef1eae20554da24cee5eecda45df2618070b219f5c59fc1261d590c6f478dd02dd896b577b53d55a75e8d16a787ff2acd5d771f10f5749254385d70f891132aa899f9084922ca9b807cd7eeb58d23982812b8f4029e3a45faf886d68979cb65d6ff793eed58f0adf4b1d10dc89294a079a96cd4def3a41a838b05be2b56cb1992c152e06302c1d3603146bca3427c3deacd2bccfe77db74c1afc631056817019c61a6f05708094d7f7d787c3037d81c799a333fdbdd0ac56a09097b60e767e2b0a21ecdb62ea22eb760d0fe28eb0335b9fa646d4bba4ac4caae4baf62021db1a5e67e79dbbb8360483142fe52ea892b691bd7fc3a77544e94eeb485ea75c6b61369a49f4f30c7587286c0414d2494c45127e133e1b5a2e2d1a1e7e7aca9e83499979ff2004097e2e2f4503de88ced8f1019059a1b4aa53d995fb4e7c9906f27cc764ffae1acbb65b7bd847549e607f4052db08383ed52b6ca4f731bbf8bb6e727d3b129b62b67ec10e93d0e2083392cb14701401f6a533cbde3eee45568fd4e7d6a93094fa2f065eafac357d64b25cc3e08e5bcc367a351e7fa47a164886bbdab054ac022896a191353494e4fda4f259bbc013c08a4baa666111d9849ef72e87b25084632ee4c953b5aad4fe964825eafb09db5a0830f3bac00b4a9e8c1a569a8f71ac13a66248cc6342a78217d4074a275701cf7a9a39e1a8e69c5102075af933c4b944fd4c1abaa1c2640b6ad2b6c4a22fdaf2cdfa54a487c17c72ac56ea763f4ced9cd590a27efec4b5a93e2c13a2c18274abedd192ab0ae66758fc59e46b445cb63e1cfab5f1fc9e6f4e8455a2806f070f86884ba0d492e4d787420243f7d0f22b4e08cebe4170c7a91c85eb246d67f5c094836d1274095c184468206cd8b05aeab0ccf1657777a721dc1c1953900b2760d722b598ba1f6377d6a686e9d489be3b96da41b549732943e3d019ddffe39fb42781f8521173575aef54eb3caef5e09557cc59eda3bdf0fc803c3f8278eabd9ba6ea4b95e25c68c689dc4a1298a0312fd920fabf9d0c4ea76f14dcf4cc10ab3c0bdbaa109f1a9fe4f919347e115cd7e47638677ba79658c4128a854fda7e76186e1326ffaa5908783fff84f3057a307edcd306102c4eb81eca74bff4037ed027839dea04833dae28f7e6564c82acda1a23316d67c8a0ecaf6feffbb5a387209c1ca2b25d5407123723f2a743ec0ed406ed5eabbcec5279dfb2e3e40d7f40dcd44b4a3601a1ec2e2b4790c1244bd440ad89cda44aeda8d08ff868a7992b4815dced669de0b1341ec31bf0f8983fbfd812a1dbe0df347d83c8df1de1117a4082aab1d8121aabf9b7316237aa3d29cfc6a6a7854c2d51d5cf93f49448c5475cc96f3f78869bf2fbcb27961fce6dcac581dfbbb4a3d6791089a35b16b501c3754902bd1241b4f3bf7b7159bc8d0fbeb6d2ef4ddafb5736fed4cfec9a705860fe2dd324d667787fd8e80a72c579e9e974fd730457f854ddc6a930df6f1e6a6f1aa70a2989106eb6c1a5cf04f52422a3fea7ef1cbc430368ec945c90590858c7a2b73b6982d967abc5aad256a4c185a9dca2e151daabd1525c7362dff69aae784802f016807b1e7f449f34783336a656ca21a9c284a22fa10301f081abcd02a1323d116e6d8b60f690ac5e08c83da56cf7a13f8fbba3309e3055188eb36ec6145cac10872aed0dc3825838592df4791c1fa666c9a8dd2b9e82d3bac88ebac3df5901983ee6cd6608010db7a92079b32912883538028058ffe27bcd378f6e4e523bcebe51a12d309ef7e7381cae0a020e002745453ed05f8421b7b7aeb02fa08040e644bc43bc35c6a90a06c55bd2dc77a72986066b2309cc3d2279be6c0e8613820010f33cb466a85642169fdc725c7240dc40db3a949effdcc18a05eccca29d6a3225d4d5d71af3ed9ff0a1bc16f1756c7882010c0a22f449f3eb642a202514adc2729e78f52a3e546ed950ab5ded078b078f6010b6e3c267a207e29b3c7ac2e3dcbf7da5cc0b88affe3438ba70071ce571d5746a81a99e7e1d61dc0e6a518559943404ec26568eb5ba787f5035bfc013df335ee4627d8ab14d2b9d79fd573a8e51db9564793ff63ba6fbe3f1bf7e1719b0f8b57e3f156031168d3651de3c41b97c0042e4b8838b9bdcfc5a604bdc924f7fda06adca7a3c1ed274b32a4a2974b8cfd565a201cfbdb2a366111d3356f98416b1b5dc005e7695a25d9be70ef172f115b3a3e1d90798a593257d3840ff3e76a91bfa3711f4f866fe76969ef9e8a2b94377f75472a06da8cfd218ee82b4b597041b073a014736043214be1a13dfc5c8dcb300d8e1f0edada0571e386ce7342d7f16d3893144fdb8d5b17f1375003367657501912001b8d07d1e8d2f9f4d523813457d5a330442c22affc5625b3e1a8ac4a170aad8528eaebd255ae42d374d8f67aeb701cc0aba885e92b76a73fcc9721411bc922cf7b67903854dba834bf0e3c61b995294d1bea3bd130bfdc3c621cc66f249908173d68f42bda3b079d3e9320e97e14cbea214efbd51e30a3c8707d17d80e0da61832bc009e0e8f74069aabf9c02d2c3687efe2daf54e45ed49464c1aae2d5f0ad9ba6644c0293a3a98b196be0255c68d31c1410274ff4b7f2e0c82bdecdc494030d563bff84d19beb18fb0458d709997a82585998380fb1ec5e3ca94eed99e301ccb7da12d4bc11e9c4d60374b11eb440afa3ab091f67283fc47e17143f39345d85e5e98719e589d1d54ca67d4978cbf0d25f0b5ba1f6e2434e2b24904c67444debd1a98630650258fe4c7d649971c5f51169a9c464b8895ce0aeac66ab23159b202bc70183170abdd96ceb33ebcde66fef64c0173d9285fd2d7deb3c90b196fdc43df6913438d9ee368fefbc8966a07e761a0edaf3da788af48fd097e109e928c542f6cbacc3a0641a113e695950c31dc51a1fce205d437f94cc947efb2c33a28eef56665c7c56323059a536fae0de9028cfa0de4b90ee8418dbd42fa0770c03272fd1e221a0bb04168fdeb7b303fb72a504a60b6c72dc472db09c09bd09039a07551141e7b64910e616494b68b681ddc766b92526067f2c0b021121e80cedeed4ca9e15ad8f101cef45361d52fd80bc153f2d921184661533231f58597138e11fac48eb6ce1a3243e6f7cbd96287bcf291bda716d0dc3f26a3dae043628289d8d6243165bf647d013eb63ba5ce932df1c5136310eb25d1465b1af59858dc71045e8cea8183e0ba8e531f898184c188abc2f18e586a415bfffa4598c974c5d3eebee1c67349847fded5c4bf6786b21c7e44a94e691e41143a144f7101838a7aa878abc74b5b7fa4ea253c5454d17cd62f1cd1f7e714478325dff0de554383924ebe46ccda1be05e44a4293a0e32b705f36b934217aaa4a23e7ec90e5a43c258726d9ed8e918a9337abe8300f570d249e7f2bd8b940ea9ce88c47bbb634b82fd3dc7171dec6a2e906bcd75eed1e6de4f2516e46e083faab1cc38bdf640549d2ca831613008a94cfe199dd984339013ceb7d1bc601c8e60f9a963530976677f53ede99a0e1158a54ae83d8a54c0ce07149c6ac5e4fe45e06ab771bc8f06d56318274372673576ed285f13c3e9ccf1a5cb4e5c50cf2ccd5ff44c7f449e8dc5dad05117db99a738a2c503f868b77c6861d4c9372536772ba6a7f3ca77bec3c9299829f875826de1e3c2ddf0cc7505b768a152f59247af63c7963e898423a01823800067cf5a9402847e611ed77946a0d7eff72cb5d07026d2bd4c09cbfa98132c8041242eacc537cc9b639b0592455c4f6994123ad0fa13553f0d843e83f22587c28ae489bb9825bb4351cc865926254dae045432cb4eb13979f7f93117ffd6fcbc1742a7840c32a9cec52fa8fdb844dc1f3585d544df0300024c9122d772ad1441b7ad12cf81d87377a871a50ee725798c4034a3dcf81733184e1ee64451bbd3f516d7590b8952a168861271c37c7d6373c5bcec8ed0008982a753e86f15dfc852473a3be5a22e07d14900d6c2ea07e015c72e57080377c717d2c77fc5cb4ae328f2ec8d2da95e01e26fb41ae38b707d64389e71d05b16e312efd5db1d9357e58d5cffc3341ff8e7b6c7840222caa04e09696b818c024877ca038e13e2855eb7e481f3f904dccb9671042ee41ab1d954899961b284e3b595a088b2e42ffaae2281f5f9684cf9601af0a23ebcecac917e6af8e4437178b1114302838faf14aca0329754774b78d0db9658ce339e800bb08fd43d15a9896425b626f06139e3a77c9e0905b1575177894ab264e545c3aa70e730b27ea9b77d16ba00cdc69d17c944b87388829adae24b23e19ca51f611bc2d25f9ee0d41e28cadf5a0bce88dd494c4d7275669d8456b0c18d4cbc44016a056792e982941bac7c57db35d36b97f36876bbf8894c0ce1e75b541bfcc2b3fbe78b6c61062df123fc0874bb6630ef573b6430459c1084d08fc315fcf7592f12c151934770657e66ff73e4bd0680107354193ad887ee20c23a52542372cebfd4d02f03a8d42fdca4d01d41463eda371b23c927ba87e22aefdd2e2a2124b2f4d37a3eb3349610dd925fe2f06a37928725bb3af190d30a5b1751342acfe33b717065be4e07607640a8f9ee254e81d6aaba6413070815c09d0111729d30b15ec3331168f11fe93b9e986b02069ff8996dd6b5dfdba177910787c777a266c266323b3c43fdbec68f3e5cc2f37423c81944338e4085ec5c1875b8103e46fc226924e6407d208691a330fc65c15059125225b96568178f0708b670734d2e3cd609620a3a70d4a08c667e971e469f8948a15021d20e0ca7476929821a68d93b2fac89368e4e6f2ec47b06b247a369bfa2780227f4f569c0b9ce4d038be835c07eec11f6e4a496094c54cd18916f978913345c913d1a0f846f5e959cd79129b4bba15ca946cdb32199ef51be1dbf5c88e0697469feee6bc4bf1ca2cfd0d3e794555759661f5201b839a46bf0c2991ab4442482967fc240dab457ade0bb78f5461c5d442b2c188e668a779a377152b598bd44de9ff00d7d037247809dcbb497a26551afd6b98b33c8d9a5ec4949670e65cbd3ee63476810679999d8c2e63729affcb1302c683e5e2eb5d42824553f2f024e17788c37c3e3a9d482dae9250a997ba095d1c8d5d9885419f577f79e4b9e322b537810ecb044dc5324d9bbc5ac4880fa5d8e4a13ba92c27b9715c3dad6c88d6f86a6c3e66b01ba03dd59fe4367cf2d9a1e880da8d23f7ea60c2cab758922242cb8af608340e99fab41116288ab64b9061ca3fac10bbd29052891e1a6cd29ad1d135f50356dde57e85a0e413e3cd1bb1afdebd5899b4cd8ad98bec31c6a51c06913f24bcd89f9ec22eb8b4f0f35a64b5fe9959272dd8d8d34175ce802cfb48c83353c737c0393279c60e79a64a05edfba486f33eeb5110ebe7e39b194017e0a209217120312feec5792561502a450ff2bd434ff9f246821f1d298ca159367026a23f95a6533eb4b7aa01f6e3675d62ab850f5fbb1fda8a600e9081f1259086515cdf9728361913c49327d36d5184d106f82ddc3fb5696dead7cf77289750742985e677f9588a687f876a914856dcebcbf896055d0d95a572397c2fdaad8a8129220ad1b221db37a8ece926a3171c4659d645c1a8e4ca16a78b01b2fe851f7f1874e78fd67059fac72cc442166152c4e7738e652a76c6ba35dc6f8a8d6eb22214363c14a4c1025aecc797ad2119dbd002fd827312d30f49a3883f1d813c8517a38a4a724b599652575fec7b1ab1abd86b958e07eef7494417b3244c23d507d04b5690a57f34849eb288727cdc09d152172b4148da5c35b94826d5a84db1a85b1437f07af861e7e4f7c228d127dd925af6f91af11569fe167c162cd192a0c680ca2d1ed66ad142cee8ab634d6e5369d8f2d67008fe1cff08d2b8767624bb17f33f37ed57d5c3baebf7f92810d3c26d58d9a7547590bbb0bcc98fb3fd84bd771d1db074bc7386418761ec39c726ad81cd955e874751d7e16eeba9dfd5a9754d2bf2e142f9449eca23664e32623dec6a5e7380692a5299f966c3bd3aadfe30696da4e92aa190128666b3b2b405edae765964372a1315f60bc1bdc8909ae87aea39302a6d08c38158b78b3942819d312796123d0bf32c3f9220ffdf9bcd68eda9e0bd1e8e3d27d0f3ac2d1fa2b9dee5b273a33adb01717f42188619e7cf760cd834e04eb8771af47d4ddb71ce56c3edfa17b590569916ee20f5421b8ae53060d8186f38ae9dda0701e6e0089921ec1ef8e1095eeacc2273807e2f2ee9f78538fe4735827ee499483a7a8cb20d2e22be9e70f0e3db4d10da70d2871b959c2d93365d1aa3853a5d8af5901da38ca35524dcd647715e7478871aa86d20967c93d4fdf91ad72276139bdc41749f04dc36817d23137553ee30d37b3d7486963388f81dd27b24bad7c652b76be43ec541a70eb9f9c2f25d9cb84f0b1b14cf7777467053ee43b08232c6fec2210afc09cc2b71b0e52c998a330df3b5b4ea7c623bad26e969a0c8958ecdd61017b0bae2e81c917bae613d284db225b506dd5af18993214bd025cddf9827d20af62e38329d952439b8f376747e878d4a81003097c199ec027df24637b7e7fd1fd9f3d1ca5642067ca8ef0a09fc6db806a9081d7e3108f46067dae7047b00c0a0c038cf6e5bc6aa8b3c18f2958728532966a27b79413e65f109cdf5de4771a728a6d6a6de65ad458dec06a29733b6ee525d851f883b57675669baf30aba01b59ad2470631f04381779ac73817462f5929d5f5610cfc0d3706983aa24d587d0f67c8ca15f9c7be20d2612977b2aaf431ad317bf8583449f8c15d320bcc141b0a491235f561f1e0a98b10d7a1ee53355d30b9558339f7a35b520045a6190aa0e0df70024d61c60e6189f53d7966104b5bf0792183f6a4f360af6af4ff2584440f5ba6f59fe3bdbb37b95e1605407cdd0fcf3082c922615da30232252afc8f79b02a43e12886884674d06c884b5d22d226d833764ea2917d2c9f29ec9f71b1348aaf433195c95724794a79aec79b8c334ac17e9da8cc18e14b4adb158caa35e9edb796aa3a5c7d0df2a67a2ef6fceb53b25bc3b41bb8ac90731fab910b495ea6170db7da25602fb7b589254240d8739d44ea0562978156742ee0e53734f10f331fe38919fa409ac10259d1db7d983958e2b064b4e68e9faab0da738a5502bb3f8f606b7fae6535c9af4adb2e5e1146890713a971f6e6f46ae3801088d322951fea3f2269a1fac60bea755e75af9277c9078e74a49944f1040aff26cbe29ef29dfffd5d369dcf40c4d2379255ef3f0173085c8e3c5cc70ced76be287b8f5c366f9f2aef9bbe17435704d404c3de8852213e4771aabbf3c16d9cc75a24a9a9fdb4f1e89033b760a2a2c2920a5cb40f9859ef8df19ce001a65d759241e8adbce3391e9c706f63a2b29cdab1cb7fbb72ceb2f1dec50196e36bf236de698a2b048ce24b155a9b708e51f9deff22c4220cc5aa1cf10973f8efcaff07f18df37d98726691bf28c8748700f1de744ac40ce3dee9a91937a9153884618a077cf541cf2c33300635b57e3f34df9a2cf746fcdbc992fa8e32d9a463055637d9f8c4034a409176012b4a59eca02a21321926e47fc430215c3e22c36ad160e3e41f78df4fccc4d15ae4d2a800754d096476daf908b9a7fdb8726b803fb0b82a6d657c8c65fcffd4802b8242ba1dd015bd1bfd4dd2aabfc4b48ca2474b6c5ff93458ad1d646cbd7dee8ccae654f6cd64987e252307aae0bff55a251eeef7be209c6066b5696e1f0a6ccfc6a184b78081e0e71bbe466cd082125d55c74247b958c2684378227655ad16ca7f1cb2c746f8e6c3d827af1369dff0509f453aeb836d6d22d056c4c331a3977dff93d48c18bd1bf41b488791bdcafa3213537549668e363da1b2ad689bc078d485e0c13111a5a26897ae33b4700f25f69269c2651f497ecaf6675689377e7ee9b9493919d87ca30325f60eb4a8db3088a56d1b75e5d9511a15fce4e380adb91ca24df0f9c4410fe488f6d1af10e524e6d4eb9ec50bfc0581dac069bc43d0730126bf3fa94c875d8e4adc13fee1a3dee38df1c4b5a6dec404558f73dee4d21a1b73c18707f9370a0f11fe68dd9e5bce43da462322a135efb3a2dcef06005ad62d6c33bf5725700e32a7cb20c579d7237672ffae24d75372f610edc3e83589b2c269a2a3154263bc648db9d1d6778685f182a262d41c05f8db744ad55603a432e743d91ef8aa0e6cb4f41771676bdba90093b59d18c2fc9bed3c373f7fabede1cd2fea3b7e1a93ed7618add37233b22857ddfddb50c7ad386b1024dacaa3b0013f2eccc08f8523f660c814a20c971ca5c924eabdf140abe70c3d91e40c09cfe85d44466d993ee7660a83e498db6b3054c1885db702d2b710a0a726d584211625583c00f2fdbf10d81ea575cf9f55aa9749d82e5a40afd320e01f2640db7ed9159a6eee9cf1a29a27749e98a893d0c3fdabfdbe78e55c9de90acde0939164e46006728edda8c4a905574c1b124981c22a43652b130348f56181773865691e35cdfb6438825ef116e8bd19c934d0ad59be253eb940d621cdff9ce1758dfcfd760774afb279045c0ef7f3a7e807226539240c51b45af5bef4e8f51b73f8f8aab49a51d218777671cef2f38b1111b0e738cf7cf25294d2d92eb506be3ccb18acdca840a6a69ecad374884962efd39991544bedfafa900a61cd18a80be0dd348b25d14f8c7f2ef9053a2dbef6d18c64ffc62777c2d38f5ece48504ed98950ab34dbc46ae90397836bd83eb9572ad444a3f8ac7960ed641b18c3c899480343df4494b31806185bf0be17a350a42da6f4756ba45f7593983d044f180232ec60082a8649c0b8ca4624847cfeb1ef0153443eb3c3ba30787d6df65863ab5c08279d76638b183517fffa4e5c679e489fbbb20bdbc809fb0f0d5d86cbc0014a39e26ca44081e8c8064dbea675102b7f631e037a035814b1537fdb9557bc76901c13b8035a7ab0f3d1334c00ebe5f6c89d92a1f383d68748b6c2c7d299279cc64e72cbf98eacd9cf75d4f732ccdafae0b1df324bb06faf50497d807a1e471c84e7b47b85e1c0b504fd4117f242d8e8f2979b5e1b2c4b7bdae09eb9eb4dfe1bc97468d2d40834d3459fa788e80014db8f91bae4de57a7a931beb65fbb70d76d269202cf360894c8e827fe9307345bec7e5f961c04b4645807e348cc21c674a792874502aa056bc82c881a5dfaf9b79e2892e665c1a3ba775ec5c99617c79bd701ee7a80717670e02994ec55ace2431e69b142aec8bd5115d58d0c78ae5ad75bffb27ac56652e8f28ef297fed3c473fa87b267bdda1edcd3e32c3625819ac81a79cc3db0554a20ebd1cb3b5736167bf46bb462d7768ae0997ccf37b6c495bb032f538af5a79dbd9e4d162534ea69258e655b9bcc0f0cd16a085b2a5c6c9d42f20343fa62752b38f6e679a16bc5e4add419f7a3f8e57f3e2f56ddfb87ed3c508709b24d289fd574378145f6ee786f0af2ea3c5b604a4264d3fdfd0f6dde87747d716e41e51e11f0758e6ec86d177fbb7bf23cad66a3f8a0ffc14f3cffcd573dd76df5913671a329faaed415fc06986eb456628e24dd23792dcb80aa9f56710f2a2e49cf5cb2aeea6f12749043cf2159ff1b01fc82f956fe73c0c36fcc6df8cb81b4c8d332d5625d1929ca2e641d6817bb28e9c5d9d07414d94eec199c02eebc20793879a2770599892d8ac823e3ddc76076c5d46555a37dd305b2d4d43649554358639e0aa1fbace102904c2000216a690e19fa08096fb46ee417aef4b948ea727d56763dadf13a2d5f368913d4ee2d21d9d0840c569e98040d99e6e37346c33aabbbdd0c3405001f6c5de10fa811e706f1d4b1eb73086d9755277cbf51633731c60b6aa247c6d5e8921deb3832a7c38cada14bf8d64b4295aead2faf7483f49288aa3bcf4d68e2ec17e444b698f9ae410fe396ba3486063b47b70d76e739c73465ea457e2fc1376821744771ffd1129103045c47671843539a4e63465e189caf7699990e09a294cdab63c2e51159ee62085edd61c2ff458e5fecc031e8a27af9b1e5a79aaa206728c2750688cffc7530193917e31a97b9c389fb458249a61b8ed3b6ed0ff2cf63be8516c6a4863734b51ac0e76a049c448ec902b227312c952ef8a75d081e96a9954253f157b2bb93efd8cb3f4e79b908082c7349f811b3eb868aae2ba79ac4aa572d1b7a3f8b96301255f5027c6f9c46eb48b6bd4a27308687395c5d3f948507ad546eafeef127ad02f6990de2825dacf1e3b9820e0c619c7e91ba929940c08e009c03c878c44a9953703da8ad1c846266f65a6e12bea06bfb27617e5f9ae8a2efb300fefe8e196f129b934177b236bba0b555104fc8041220575d09cdffae7f433951d73f88dd65765706166d24b5734c3622222dec7cae052e3dc24f0d75e21b4fbf804dd57f40613a71f66533d2d23753049b6e92cad5a95c1dc4e2ee1a176a4ada647e2009ca533ab3af23f7ea0b522dd38d3fae9782818472b3217043280bc73447cbc671e22d1555bd0561ea64027f8f580c02b64416c2cdc8325cd64b9b631caf226fa8ec057730c083cabf3b2b32a615cc0409aac9bb08c88643946dbe0673d16fcd77ea319f14a48b0dc9a75db7ecdac21e5245a50bad6a76f895a1eb9f6aa5dd66e3d49d1b9f3bb46eb29498049c9986908dc725b11ccfa652ec2a1eec7820a8b40585fcdbb2acb81aeb59d8dd7c22ecf9e04768496af0eb9a64581328af118610e4d7fb9650e32f5e75f70d71e6fda4786a0fd43c4b9af194fce58e39004c6a8c023a1a3e70af1ab8222c850c67221e72b9adb5d9450e3d502bd02ccb5c2ea8ae576e937a7b4d522d26479e70acb1ecd72982ac96446215c7f5dda135680aa27913bda74300500108e1fd31dcf1fcecd38ea65de85b54a0fffc1c50e6144859b67c8122d19d1edae57f50628a8edba3b57feddd378fbc9ff474c2fa0ca9b765c6ee60288add8165006d1cb07f4650a0e123550522a2bfb9d57993f3fb3049028533ef6d0c669584423a86a78f41101d75e6dd831ccb7f8a407ba7dae1ee0690d8aca39289bb1e111de4f5ae8816cd9a853e6f0ee4b820d12c8850f583e7180804428aa185aa1e0a14eb3d7430df3d56d8e3e1f58654e3f0e5d967d6a800ba5a7092396d6be62a16fe7eb734ea748d350944225c9ed403979ea3cbd76630aee08d5aa75285310c206a0bc506fe7c7fbe82d5b3c346406af13aeacb2286d950f31dbdee0410c1c50ba18639522583227b69b396ccf7e700713ab03c8329de9223a61890420774f99b59efa538179fc242f6945edc38fc75a1f2351418074d3cb582f7f45f52eec89015fcd5ed8ed307c708b6e990090420b4e5becbca18d507f10597f44c6bb432621815d3cb9fbf3c810001340b91d808c5536365b876557919cb3b7d4c4101e2fca6443da5407d171be5e9233fe8bf760b7a351d7955d6b3706951bfc4adfa51072f27809d6b9d8f6d819cdb04ce9d6b5cd4c8d6d291a3dcdb4946fbd9e8e8ba89d21b7520a8c4e0f53b20f294d67d06379ddb2707988a23b07ffb09f342612de35a29031b4df9e8e8bd73b785e58e885b9ce6f17c63085712f87652d927305ac9eb4d2497e55282ce8d20611b2f736fd3b88f5911ca80a06c88c232674ca3652f5ec23c06301eba955dc5c7ada38d49f87ab9e3a7bc98accd31bf7219093d1f3aa5f3d37c0ef84ec609ce990da622bd195258ddae99d5d1975df6096994f881ed3be915af14de100366533f3e0f8dc63038bb553529030d89e30e3f0ceed875a2850e608709a8ba30202b688fba0f3e6880cf8db956a5e03fcaeaf648f5d2ded7cb56d68c1ca47cf0eaede4a4f94f7ec838604ea35054a60f43248004e02dc77195b1cd4e64d8c7583f9f17478ec28d657b67aadbfeaedd278582cb4131d80d7c303e8e7b3cc4d7b9aa23498e615f32890150a05f407e98e7b8dfebd9d776b8f3d9c6c50711c49b204eb65288e46545a6302fd45ee89ae6a4ebf395a35826cb2c0dcc56db3e44dbad9d74901f61021e5fb9457920d39855d8adf8d3b656c77a45d83652c5889c12ca5627b88a361c28dfbe01b6ec5e94a4ce9d5699c8adc102a3cf83942f86de316a05c3db003ad1481d13b39eb20be33c45adf8d4fab8a7eb324d3feb80be41eae3cbecc352cae86a0695c5523128759439c76332376784b165bdc34fe9eaa6749b3bdd4cbc68f5c676762b1590e2e9806fbc1884729c7dc6eb5b000fed3af52f6b54a74721258fccedf3cd1172e4837ce15c933f3434597f6f216982731ce47a57b91f3315698756e9ab4edf50504395500c26a0b607079f62d15ab2d1b513ded58ed98165cfed8aab18123a6d801447e273de324b5ecd0698e6fefb374cee9d1275f144e7dbc4dd0e5f88ffafd8ed1361c5a922d2a02d7de207899371f71d6023755cae0df66b08625676d4f4d67212a1fa53224aec7215e381ab98bf175f3ee6cc3cf76fa5d16d545111a0a9d1c3762384e6d43d31581c59b852653901793ba10a6f6b51e6a73cb12df086732dd9a8d1d6154ef0dcdc6adadf9c1135570a40765dd1ecb9b2f22408d78352890b0ed493c352ebf8c927b162d327d9c735c4277f20f4714db8b7463e7836db515edfd6d814cd5e1744a9bc957bc1b99e0e57c0a0a9bd5531416692fe7112679eeac439935fe789043a30b315765e3e9c5ffb43101b49e53340444d9856ab223a58ffd433b4b7a20e4c5ddfb37fe84b9d4fd9a7258f8784a583447ab3e4aafee4fbe7b6799a6d9ad5d07c1d1b15f3f2ba9ab626f26f8b9f0f4a86e454db1aadbde7f6b7da491af407c2d6a4511cfbf657ee6993ac08d9cf4c2992f2afd4e3da7733b9315f8cb790905d1282486a9845fb444106ebbd02fa9e2715d230f2b0d4f862281e4a7ec4c87d662ad79c3d0f83c4f1a57d5f0bb904fb4d9e809bf371a3efd179564615f43e657d0d61c1eb40ede85d74780b07c072bb8600fb7aa4638516f4a6c4a833a35fd8c3bf1761344d9e25c35d7fd112d041b0a203e819f0354b9a8bdd1b1b0038e9a5b8dbcd5dc5c236fd0c3b8346046735341d9422fdbf9778ef33198846b63e9c5a6f82bb3b043ec8b4329b220b2bbbe06f28b7c47a7827c5c15f5afc0ca708cc469bdf0615b031b6550e1d9eef4c64c8918e7b5b885f14d8c0c4a0ae6a9b5b9e9567c5326c1b44a8da51c3883e23151012973aa4372beabb1989b40944589828ee33f3d9fc38b6ae59925dc9c249a16dddb505c6c718891c62a0a8e4ad5c4c2e530b016324b7c4ea6c34bc158a60f09295698a5e0ddd9a26b48a815c9db2eef22a8ca363cdc8efd0565bc0a179642c3b8ffdf51247c8a07ec5eb1083699b7dc40ad78aa5a3b0f9ed48ae49c941a629a08dcba352e045d218325556bf546e3176e4f5acd93b8468f8760417b5735218b42499cd88e46c48957fa32718d83dbece5308a64f0b522ddd93a8177efa2e6dabbe5bd95e6213f74faeee2bf29f0c878b575236e8fd34d3990d607df230f2cec1b4fb369bef35e484071708006a228c0d85d524c269e3d034e8b0d8d70b8d3b104772bf6c8a9b03987abedee26d4dbe7d680e75ccb0347e36f358826d8ca203d1eb64450e19bb4ab541f11092a0703cc6e438dc0261a370d7d9cb5439dc16e3c9c1210c852ce4e8cd27cbb35e643861bf8b58f7af7efb4a3bddb4b14eef5d9b5b6a3453e1c213c14930d0c086e699dd26b57a511d6395a528e867549f0b1a20fa3101eae14401027062cac7cab34e2eb8be87cefc0a5f060083017bad8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
