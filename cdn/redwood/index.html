<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e8f0dc536d6a97fb97662a1fcf7d72e500a359cfef6f7f985a8864bfd6a4275164e40ac65e3c8387f446efa1f6ce8015a00eb2e4315b592d295c8d04799f6889134544f5616006be3d6f565a5efe79b7c5b2da3051ffff4f7febf2559643344e51950dc34cd20e962f9492929f9c0ec2abf268092e34bbb6b7f6616b53a4b6aec43dcafc27e0bc62c53d2f0e1378b944171c1a37cc7730de1d0a6fb274164a0d7f031ef70541d664bcaca6d51b5c0178bea891890ac23085402a357cb8e2b4b035023b2388ed99e8d6db1514c423b28eb1fe15e31ddfbed81bf3ea9667ad894c9c1ee3fbc519bfbbffddb2fbbaf3f602e917e9d6424430b6a318e0257e0b4722227d5a500930a63ca8e6f15c46613138b55c5ce8288f6400145234e33151b461c6b688ed4f16d5acc4fac678a835a2e379a1c2c3ed15b1583a65fe9f453a0ea9787c8c08e8081af15b71c078a0b2633313d1a549318d96b4fb4efda6d3638d79c7c0dd45841431f4f1d465ff6adafec4ea75ba2bf507aac69d5e4d288eaef628885f443f92c14ff307917d398bf78801e993fea12e0e2bd3aca8fdff4926b7dde9709ba6cf02e3472bdbec7cea8c3d49cfd029dc15467b5a01c8593ffbb1b2ebbd08599725c37891d2f3d0de10eaca4cfe3a0bdb340c9af531b66dade58d0f884c2882e66c9d540a663a22b02481f4d8e7fe2f27cc8c1af2df1efdc1b059511d5871e1917fa396ca6da79454b38a3ba5b9533a9a3eaf751dd6154c7f0cbc779589c41f26730656bc4ec045e7774dbdd2c83b0b88051bb081e0a59f952a64c47f5e04685e60b5c3a820f015eea79f3f3b04c9b1c038d22cf2ae2e3db228c577b704951853cfafbe735c74e026dc288bd54dce34c15605d84929facd260de5e2a49e9d82b2efdcf04415927d3c6a5fb9641cf5c58b8b5535795210e0d2bb8c0614f13c6427d09e3744193473257db4170417d35fd34f3ae1b94bfbfb9eb32a242641cfe73019dd70390fc5d9e3b88698a597ea46daf546ee51676185dec695d3f669f7437e55e08a770055e797a3b2a8985d5bf0d88f4d59c60ace35b839d3b6074f205647a3064fe8d6d0098dcdb055baba463e72aae367eb64aec63f2db21a8998ba5d82c2a99a00a22f7ff2dc67d3c13d78e69b188a8ffba975a27958c56b303c0cd90fb0bd1a7ce55d45970f45919537b8185179164055641be9d87c960e0e1614d3cd9c063631766fbe5f30eef612e5d0e5f19fb6061858d0303f55ea44b21622e79c2892111fc7439e2d256ee01e5f0faa723370e23e38eea95ff6d7c49f977b38414d8de9c13562232c0f0b22bb7bdaa7c385e43e8c3ca534f9a1f3757f945e6cbc3f3674a699b854f87b4e86d2d9d1bd9d71a6225067ba495a5d197fffd26aa78904a0877ec875cc8357223e8e7812941ec987a4f05a00e051f94a7779d60a05963a23c011054a35d4e322dda61b90f5cac57c257cca8e098bcbabbeecd486b89f7c6292cace2e08b5709ad84d8fd88b866811d72f16582a1911fcffc78ef7343799d12f183d90a55b1c2c6940d71af6ef7a93b6ab3fbecc768953018a94e529725d3f9972957bf2109fee2383e888969e2ee09cece22a6d4c7bbaeec309901f424f0dc05198880bd8e5c5895689d61e8be142361793d598421de895e25c4fa1d2d626865ea476641453694bb49b8770984397b4e5f4d9d0b28d9ea5599946348cd4fda440fa3d3f8807114f1ee6bbf251a2446bb1ecd51a117479c60fc8319c972b1ca0c73a8821931d6791237cb83c2270c70b77a4d2e0dac9855ae10364ccf1c79d0cfb6b6f06539bc4141fbd1369fe6405d55e4c826b6aa1dcf9b3e94df736cfee535ba6d62995cd964f110dc2dfc843ff81f1c4650ceeb8f3eb84968b03b0a9de9b0e85c001b52179642481978032c8eb6f4a6b8d7128356e19c172fc0eaf1c3e72c275c5d66a792d13ae776787755022b1161c7eca9cc48ef4491fb871258d8a0e9322b2ff5f5a2c55f94af9361a798988e7da579ce5745d4044d675fffee85f624026484bfb20a9583497e6215f911edfc769917e7b3a9d6eef437a6ac1de17e7585f25c48e7873bbfc870173928c9f1bc7a9a077fc6de3ea7d5c15ce70a1c59c76aec2a5ef4862cec93bf2b3884890f8ba3239c9a5ec8050ebeb5e61549adcfc8b0aef6e7b89856210e5a47682dda0a71c80945c54418ae0bee76c5199d68d4378fcff43e6fb0e1ecd0eab05f61660d455cc527687e074a9b4e9d40a88f9d25581ec45c8ff12de7a5a9c04a0864960399f96c19d7e00dd3a94f827acd6ce8ef3b20b50adb928c9c12ba17e3961ff3e8f0b78904a42780a03061dfe1024700c2700dd27de534983e39d37f7390d55fd23499a727a03fffe944355d3805bd5307d77204aa528bd9d88e5b94d17e8cca8ad987152991e7360cd94cfc3f20df764afdad1ad5d8be5f4f415d908d610031f264a3c23198d4399e0f5d8b83e6409ea5b39f6321ce1fec89cc1ff27ece9541b81bb6301b609bc8cc20f3061037294db3c7cb8d3542b03f9639d0d944de778c26e1a802fe1ca958ce67d44b135d0039a84dd1bbc1a20f21b86cb1b139dd5483606a3d9dfd4b114dd62b894a46baa63090435192ebc2bf24c70930ecd059573226d7805b9f874c8365367c30a45ccd5eb2dbbcbf494810631dd0534cdac75fdffc2585a780d46eb079dfba71b767398a0bf7ca6a16b69f2fb6eb000503d1d2009a28ac9e14ed5147a2df6ebdefa9d33baf47d9aac050cce7ac4310e19737bb2996720560cdec94a5e00987871feb30d3c3b1eb6f525374fd80d948d6bc0e1029667806206f1adc3724a74dd5cc744b19d6097e061cdb8a91d009b891a06abf4fd19da8a2ac39fc17e39d8f3706334904d6eedf62e3b42e90e931f67094bc2ec3fc2ef0cdd8c0f977b9c097014fba9fd347426a5c9eaa1cd0737aec358fb2fe731fc3343d76bdb5fad21708fd0a45b4543a1a8e3ad31525e6b23e8adc22d661dcc9e4da979deb01d400e46b9e42a39be9db26858e587e1d8cb8f22d75131627baa63e6523c3d9ddeee7db64f1a12da0ca79c93773790a9010bc245948add1c87d4dfd3e1956e12e7b168e8a7f2dafb46f922e2978b845b032765c0127d65c564522d328b2372c9afff0ba446bdf744fb98597401c518c06d03bc4f635435dcabac47616f5f5da672d5a9118355bab7996bd226b7e071d2a06354ea65c7bf9a6dbf5523f3734702b5925d19852839ab34553b5c1f6bce070914fcc941921833c0c7b4e1adbcce9bba8b17a86397f6d7b4a4a14d2d9a9e0e1e0254e4c437450552734bda9c9b769d4a04756471f903349b54cfda65ceb045c08705241e6766c13b0a1f0fbf0cee81f0eb6705516a178443979f239cd18f3c5a297482d529642d68f63a5b612b57246a08645d645f8e7e9f682fe6e4c4da6a1c00bb78357c5f5796a44feb68ad7b5e711ded2521ddc8824ac815594e71842730df584ee2f3a5d4e5f74147a8405de23faab0248f5afa7a6f6176aecc8c6bb8ea44a8956fc1a4843dd48c1c14cd72c18ae68783a6b57daae8c06d97f7e3e4662d3f6f95e51b64b75e78315856629a52aba12c937915cb27f087c84b53666923da8cc0c5dcf4d0e706bc9fafe147695f53367f1dc354ab40160ca9f0226599645ba0b09a3b965076cc42b1db52682a77daba0bc1216b2cfe6338b8c04f702600dc1d2f42143553abc55a4f835eec77404536b7cef08c7b7a80fbd974c2dac89a0cf9bbf823056c8bbfa79c458dd7d1c44189e12bf413f382c44cdd8cabdc33a176e305940979768cdf9031ccac47d03bedec82859f6fbe2dcc33da3e4dc9f51a35d7c5dce0cf552f55de4f1c46356b80f5bb85dd80237c7beb86c203f48d13ac13a1458f112b08c30066634934ff227fabeb122b0066c952ce27a3ab8c7d3c0f8d3e72f1f5867fc64eb39a80425e378a0b2fd0d0d5406a2ec66b54b637a97f89d9b2107aaec764bde71b0f2aa93883981fe735c4055898b99b94a2c15b937fbd8e28802ea9df58c8b00fbc523f3f3636725c0dff9b31b3fb549a12e014db3b389eb3a36317b57f5e705f4075a321a1b4361e6d8900fc2970bfcef553cfda99bb9799758ad23067a0dcbef1f8828d8d8b40b5583fa11d1e0bd28b22fecc39566a086de1fa0b503fce2282a45f5e242c8cf9983482f10f4d25715a3f5b77272c16ba1a4e8c787fac6a22b4bfe3c4a75bbf2d59f8e1b2decfc0979297fcdc54105feb1184f80995a83ac75ad022592a8f591b5ac9bdb021f3f171dbb3a8810af1f60a13e44a284af09c4c815f2be83cb218e38ee6397ec90e751ac07133a80626971fc5370c83bc4fe204e72303dd57654a436e14b69b7f1b510916111f48be3c679dc5208891ec8f1930f1bcf1511f777b678ac916a7c1cbb3ca2f998433ffa32637b4a74f443fee3f592badb761ffbb0cc08fe8e970affec5d2bcf1486ebe4287a1f800a4f54440fea13afe7646ce1de217c8fc024c0f840076f29018af974978434e943b07b74357fe738eba8da4f03827c00f97ba92674104cfe886601181f7c20cb9ff6d420572bcc151f72406a90dfe65bc86bce0c08674eff5f1fc95e7cef7341331baf53f01111814b607f8c228c09b9d4bd018aa91c153119a40f061163f71aeefc171a23f62f4b50a4e19b7e20eed94b1a432b34a63a8d9cef9582a898d507bb900d43d47419f5137d73e5a7e7e051255571c72e22b35c30f7d077772de8c07706c2fd36b7a9550687757e7c5e7a119a23a59e22b0ecd6a4790377d3d4b7ddcf042e2c3ce4a585a4cb40a59d7366314d681f664d7dabae0ec743a7224b278674707b6a37952ae17d33e092049c698387cf7a57727e4ad2a24fb8700f9ae501f60258ad0a57b0a4c24522ef68f4b569909d50dce72a26d1f650c019de72dcddea170d2d1e18cd4cdd961f36ce7629d4375e740a7878c5c631ba6cfde8cdeda39d94ecbe66a9cc246f67ad676343780c7c6978575d37c82a233be22f21f97a275bdfe5d88da774428398c96c6709ebe7728a1b844aa08a55d118fcc36ab6098642be4f2f4307088138461421f2875d052dce964b3ab2344911b8d84e3de6ae9162ec5c93a875bf69aacf66a98943dd01a8b1dda8b8b5ae23b162e22bfcfd6b210330c28331a84cdb00fb9c0719302908ea79cc67e58bebae16fe61a4e7dcdc78405e05c57cea72a7cf8930b7f9713c5021b7ca5322b93597089c6d0ac3fb59503e68ec7afbf5361c755d1f16856d85375518aaa55c6ca753c868fac4618f060055ebd9be311ae2d52aaf7e68ad448c6ff86813416ddd5466a5bf9a332799ee41a1826f6c400d9511b8a61c00bb7ddf54f25c686330affbc8a0df10b0ad65055287dfd8a8d9c9c94b5c17c8baf19c590023c4a43683450edeca9a98044486a7b84fe149352c3c890642b3f76d1fb24b6468e65543591cefee4fff0d894ece93387529dbb62b630a6c24234a7d10ffc2aa9b42af4d6095bc5c9f17ab3546d539dd2dfc9b49c39cd29e030dcf5d1bce1021bf2b9872bca39b2673ae5cba2399629025020ff744fce33ca4239daf29ec58b8574ddb416febf4c09a897ef41955642d8d10921d6038a518c0e0698fd7423a6a79a37bde5ad29e7259c27a2646bde91a194949b7303116aababe5c5d5b6052404ec81b33c760ccf2d2f20f8ea28f7900a21c1d27caf31078e84fd626ce5df6f04158e91ca5662285e2a74b343ada5d4bc55e5f8d5ade7e460e55e40ebcc4b22665ce40752271b5d260931497e27cdf97c701eb0221e273fc46df3c1ab8e0a9d1dadff79f981af4bf8af80f5964855ef39923e0be73a51f45f4494adffac63c28cb937311d4d060f7399bb720bf9c14bcae96427a414b86850fecfbfc5b83086818844d5c3aa7079b458aa712771d5d720e7ba7e926a7763db36583e5b157607e90fd90d93626eddbf53b6089d0251ca4c72ea49429ef53cd7f35e69e6d31210967271afb85298113f94a6c0c55e0c99daa02817c118197cafe51b2e9e2b2c7a54135d9ca30c2c93978b1443d5d6a606c9e75adf1f800bc008efe0ffe077b73ac5450f74fea5be1b43b0cacfa5828ee86e652000ac3b413ae6ea9893e7cddb33e25b548f127999ee356857fdf27a184f59ec1c72219098f9b11542ae8de77e0b1c92c085e617079fe0e8a041c8061b3f37899d80f6af11b7ec7bc601a0d6e59b954fab6e25e1cd3e1e0eec45d946cbff928b3f69084f0c27ece00d88ae03d672cd44a7766f93072bb4d634ed1638e382f46d57240f2ebd8c94382f0e735c3efb3cd88dc8df34c6b115b78b0140cebd0814e9598527f38e081b1fd3afdb6da74e0688e1b32a9789117734ef7eef215b64b8968effda47ec7342c6baa095c0c82d14310fc152c71243aabe708f76c53674755110385f739ede7477e1ea30e7450e90f4d6c276e7e5a21135c91cbd164e10d425c9618b270aadbb11cddcfb59945bf8cac90ab5f18d7eb1e54c66fe8ada60be5c28ce0111af39b8ff97e7079262a3efe595ae22eb3e8be12aff7d8ce5ead20c39d637f4d295214f195e73e9d90c36ce9a53f1f33766389cfea6e8622aada6ccc897ea2fb117d91b7d7d9f953bb626abbc6d05415536bf42b9e79f96e8eab13e74a40f36a9f3106e4c335227f9ebee92e308948280d45c369a4d73ccb9bfa17e3bbd4815c37fa2055cef7877c7ab746b2bd47ec5e7be68ed0578c6999304fb7a7949539cd4abc7bdc2edaaac26ba79224b45cd5158feba6dc448e38c061f1bb0e6d209835c61eb4e23560c8db55983de124ceba04424e4eec2c8b49a05889f777f05c0fa4bc8cc47499e88ef06aa0f387e3076d384ffb7834b3610ca0b04d304bd6eb84b4f9b0f6e03dfc7e4722d5ec008311ec74ee7c97e39cf6d7b5e1b5204e7d79edf4423107f4c9b9abb0e51e8982a662c3c8c7fb32c2233416227980fe8ef0768a3801388c5ea77df324dc97fc2ba9e5d65489dad8da50ea41b789b84c8d0560e4f8ad6fb67825b996f178d47aff88c3558ee1265e4430a81cd2091f40d1afca11bcf2d776635c08084d267d7195bc63666cf093c41d0e29079d45300ff461c1173e3e0b28f30683dbabec20f149244ef3f634cc75a2944b6bd2ed26e323bf58355d2c680515a7c44058557237242564a0c811f52c8aa905ff50e81158962fdfaa6f78316ba463329ac83978ab1a7f2a02eed8728fc9eed07e527cc991df33b1482b49ce74ce29da5d11dd363c5ec2dcc99ab15ee7722ebd3b487b21d9b6df38876de07e5d5d54d6556a3f03074c5eb5fb1f3415c7126a2b502327b3ffb354cc4f5ec5d550b6bac3d161b96dc7ba8b4292d5a70e87d29e0b4b51ea660455f369adc426c375ec3f6807c49c16a11d4b7b968496f3bdb98252fcb6bbe2fb89ad0f17fce74ef12b505a323696817bfdee4b2ba712e2abff99ed531b0ade0613c84afc95750aa653b1df407f2947c3d6d7a6dfdc5735bd98e33df77d5c32b39eecacdd3c5a271f14eb7aacab841e3ffc7c0fc9cca9c8563cef8a7ecbca39da895a07d227d56b4f742e2c17325421eca7af17978429f5fed694d411c59c4ceb3322360dda43c4b1ff3069d94d48cb7baafb4c48338a82f190bffa2da6b82d02ac4b171aa615909ae9394254406b1c36f9fc9d0df6b5a9b54eec7a086e372fad29c6fcc88d194cc18626239ca4d4a227bc6fccef23ffb1cbab4a4279c5f9f2c35f00f76e760b3e8c5a50ddf23771202c4c47e777a4a27b264e321344b1f8eacf8d98a781a56b1c4a3f5afe9e43e922137b07a35615e96a30acee393cc2d5800de1f7f76fdb2e6df2a97f482eeb07ee8496fb4cc4384ad1b2325e95c16352149f483a91a72fb4f6db73f387932f3346e92d332f38d6b749f7563be1d1bb310be2087c375f2397e8243bf59372809d982752016d4ee1ccdd7c8b745600ed5eb959861e461fd2315f81ef4df4099844e8fd0b79f573e094ee2dc995d12b60128d4eace806b4922382282bac8a16443af4cd3db15d1df5ca8c50e26f68df2fc0af3a311f74cc643905b6df6962c708c6984e5bdf2f75b058e0e2d3e68aa122326b624e82ccb16c23685ac39d8997db9b89a0cac2662605f1d0ff510eb41c3c413be3331e5bf1673f33f7b81cf877c43ed5f21ab059499b4ba70073157efa411b4ada20851010ae3294df84c9e65536bb4416bbebd685db4ac27ec5441eabb0785c4a012a7c796d5cc216e65d3582a07d890525200a7d0330be53fa69e0ad0a898d313b9b96fa1b2f1e8a319daab297d430146e718ea3154f379f7ccbfc06b983eccc601a7d7eb86034e7423ae33b2fe7e51f3ae54c75ea03b7d312f7090ee4d26b9f568fe501baf788207fd77409089e674799edca2a94098bdb3dd515ed9ef8074655da8e7eb9e8f0c9c6f41f22f722e5e2c4ca0ecc01fc4ebe711ac52703600e967ba7cbbefca1b4d94f30f992f196eb5dcc0dd4419390b08c749520bf6b153c908c155e77e5245af71dedcfdcea9f12cdb363aefcc4894e19ba0008f28bca029c0cb20084234a8817049f738eef016cf1ccf8e77459a1c15c748d674e1512987a16da81258a139f79550760100c1aab3531ebe94e8b1096cffaf400955866dff04986ed172c7b01699872df354e101b5ea4ccaf2279de10b3a19a66735122bd39eb30ee3351e79778e39332fbf59a5ab0f181d0ba6ea28409dfff9f1412d7be9c7efc10fef295f1b270076ff8553ce7daf17230d58071daabe42df4a2c3535b79848658aa81a98ab1812152a5711a923b6cabba205a8028e8c0869fb83d260b84deb295be2ef2e201fd7f5c37dda7c16769877abb1a5480be4a53ad5cec9b5b3f856e13515b5b992a90a15c6ae85f05655b3df9b3268982556601c3f5c8544740bb56cd399f0bdf72060dcd7ab3b1ae0050ad69a57c259de58d36150cb1f3bf8cdd26677115221043079fbf3bffbe70678946e3574286de506b72d2627dda4ac7740ac8ca87dcc9b42e8bde756015e30e592748829d0eaee036fbd6ff37599ac0bff79f2657617b45ec10114967ab90c0fe0da47acb14f3fc195b1ddae8c4724a6bd4daaf860472eb119151bb23d0f291cde33f241745a355de4188730c45389cfa9fb7d18aff606f80ef92bf52ce5131cb4bd70dcdc17af3c9fb10870f219750f7f296bfd772211312fdba8ff75f8d7f127664eac4ad83bb6993524cb9cad589b9cdd2d33f5ecb447acb5a56fa00243407f199bff97189bd16283fe77f88313b6eabaa42602bf9a0cbd9d839521b4c35789afef71c93b0acbd17489f9b08f9a2d271e44e09acdec6b55e3ad89f35287e35c33c8a81f2cc151ff59572a7a1199ac8ea2071f8488fb32b6e145c8629e70318000b26969352bce0914a330e538386942da0d8970bca1a0fb5583b725370ab3ac5693f17a9ecd9d4c16120378e311f56589504ae21b76774607b31b3c34012476d608eeb0db5d8f397496b7d5bb5173307ae9bc342e9acdaabb3c6d084ac2fb9f8e3d62b10fe74ce7f8b25d6bca3b38f84a1971c02be846cf430aaf190a3934f21ecd5978eba0fb476d1887f116e31e1fa8be63ed4051a2f7371b150ecbe8672daefa6016e0c12908f8b56446d78e508506f96691448e9e57ceb6707dfb9d59e1012135a05c90e4145ad836f5150eebc130bb43a1c53bec7dc1b8d2921335e60c08a5956802b98dd23c2966c338c9b0650808c2df8ab1625b27a990de9074327463892e5823de824ffea682bdb3139c6645418dc03afaaa6f870344f0dd43485a95d37d878f2cc57e5dffa0e51a68910df9161dce07befe3279a59c5eb68eff483f9ce51a3d2fb7b952cf0bed40bdf18200fe316078798f23b10eaa447db1082d01799e7486409681bad9bb12b1d5146b0556ce79c64e64b305dae56a8788cd13fd85e61d416ab25e0fa5401804647763cad86f9d6c0f8eba5432c99f2d95a5c4d2325a873a283b4bb39f4a18398ce702418ad69d8b2fcb0342581b0d97e2f282abfee0204320366a6c9fdff7eebdcfc3670960b8c3c955eacf73b807ae07bbfbe2a67af7f4faadfec645c8a0fa1b86117ce73b45f43191e3afbb7d893a4ac0ae2cdff2fb5581272b2d791f0d3e63b87d959fedd074b883cf0d824e6c09113d40942f74fe3c3771cb8cbbe38480d63fdda6fa41067fb96c2366cafba502fb7f6868d49a4e0076e5fff0091bdb095c6db3e8afc06d472670ca5686fcd715fe922097ba98055083a819433fa6330ec1ce77e3efc6168ca9eec9d758ff5dcc144e508146fa866776266411f2f8d41542f1d3bdafcb90fa0882dc219ae2d6140cfb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
