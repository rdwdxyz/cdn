<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da9bbf680236e2cc804b7146b34a1bbca2ca85119dff0c31ad946a91d86ca1e187ea975ea5723c573087a3b94a9fbd4b472da9bf6ea0323e294462e2d12ac965eb894b5ed7b12e86e71406a0aa13b4fd34389a5397d74eb4323b48ca5a3bdc6cf7d5c1c3e9ac055e9c09c7538c4ec323f89714c93827f351ff0d9cef068ba05e0b4a0cada472e6dca2065e5093422114f7f7bd8362312740ad990c2a9fbd20aebf29f709b6eef612c7fa70bd9abe68ac1545648ad1dd6eda1e469afef40125465a8ba5b41fe7b0ff04ae58b686fb1fbc2016b526513a7de3df0441a1de4e9b748b9bd76ab47a512637a80aa4d4f54196c96364f5439c6780b84b8af8eb6917a84da0c85f3a173f5c3915eb56834fb99f38444783c1199b616c094b54a6e88fbef1e7bf9ee10909c2e47f408f14b5002d2fba55fa8b0ec7176470e94333ebc33ffbff0f237370cec753a2fd292e573dfb94b0a21ae89e7392de883ed8be890e37d726c58caff2c4919d46c9f6a4b2f71fad9d83ea21247e164e076772bef8e2580875336c1f36ddfd181df28276675903ce4ac48fe944658343bf74136b8e327f58ec5f38782ec535ac336ccf58c52bde4d9f74de5932af8b4a8124ca59b824a1d7d20b066f1f74edfbd91f888c7356b96f0d267f2a3b50b973d7cd72f517f1c2da0199925a592b21197dcf3580b2c1937197276721a7ab4a7834bd70281bde2cf4864f7a7ad7040af671ee1179482aea7f00b64616ece4ebd849559028ab1062211a5c8e2608de3f9815e5fabd656f0d531ea98feee6cafd79af7aa398ab6ea267891f6e8402f9d002941f787fd41db956500c373d83ad7466e8ce56fdac45bb6817f734d298cb3b6c5890ba2c7a8b2211ac0d5098bba4a7edb8de4eb9f5b1e7aa50c7799226477e3cd7a9136a55190c2b972983b5ddfce601d7656fe3a62e63ee30a7fb291dfdd557cf26076003493b3544421eac97af10d8dea1d6c68f08bea7df1f47ac0a743973306f97efffe62e4d95967f9aa3b745aa514157bd739cf25605edaea585be9da45d62581a63f5a04ce90e5c26a599ca6d4c56eebd5689969d8e4cb15f40e3a021b0d1f46dfae0b49018e2320286182994ac6a929f29db7223070d36c67a5b6e6e65777d798f9589085efa3d5f990389263c3a954f05686a49f5bbcf678c11da06bd712a81e000fbf4d8328fa947aef47d39eb495f24ec18171fa627729dc8f49c8b308e893c5bbb314200d32cf5dc857006b6b04a7f71f11b699bda9dff9f1c8272828f257ab889878ad152dcb91f8c9be00adbe8ded2113d3c66cd63ec85609d4b7f78ca8db47c2071f572f88ee8c591cb569f4003975945bb39aa4b55cdccbc2bc3d02f59ed181049ba7e66bb595d9001f6071fcc93b8b8a68e9e4590e44293ce9e9914e8f537bf4cb8174d01199336ca523ef64cc2260805616e2f463be00c05e22d479f209046e2a3f250edfcc22d7938f98b0a059e1a0b7733ddc86334feeb5500d6755fa3dcf4b67746fbdfea18533ec4ed60622f4f4f6f07d2675f0bc9c063cc2f860b598d7a18b1acde0a6122a4cf286dbd71db186f40af7f2169e435d7c6f91b4985fffc50ac20f1741ac75053bad6b5dc8a9fd36ad1665c919b4f825807e1c6bad7adf7f320d9ef69773964d4bab99a7c55a9862695fe6fffb8d20c7fa446546332908c503eec5f24a409d93db011b4bf74aa33b49a824333ecae6b9ac35bc575e7b1c4ec1c992f9030a14d29c00beca3126c4075355433c9d0d92c8340efa8828b363c47d0dd73c5bd032844b38a0e70f897a918312e16fead6073ae40a8d00b31052d5c2475fb4752d5c76ca5b736d02d660d3fb0a353234e926c548d9825b99f16df4e498d97742f0994fc047ab93416caf310604b4d3738862206c2843c31c3531697c8d1f9d532054d057ab2eca59614c2fda69758ceacf25039382bfe4ede121b89d674264c904701bdebca9c2625325ce7929a05da8f02d8a6cf22e6108ac15f115230d4619b726f3f5e0cb6aa4271a5de86097035832fa9c424bef42d19d411365043353053ba73200b9449efc30aee2ecc054d503fa1f7ef883528711c948a6fbad98942ac4e951d9e65aca32a890ac9e64f6355f904d6d0d9ed9a85b10a3f868475ce63f1826f6fdc88b0178d6fc7e5f7f75309a2076e61bbd1bfed155e4e7d3d0446d3df485cc1b66812e418feaae6d51d8fb1f4e6c48e4d7e6b28faa5b8e990b2512dee121c5a93c8055e0a9ddef02475307b0565fc21c9d3da14b3bac3ce316f5224bc1d10f9191ac360e3dd5c922550e70772f0ba12d6a84bd978561a9f659744f7e34de74726bec51814eb608205557cddb29f39e1bdafb415689463099914f1f70028c7df80809573c00d643a67bf79cc15ccc5a775b4bbaef73ce8b8daa03e2dc589ef2e3c76a3e37d24f017f3a515a949f727638c0a0d06e766e4440eec7dab77b6453b11b5f396a03772a450296d703c019006aa61f443b48547b2e47edf3cce58fb76b8869514d564ba00bfc8e21169abdff6eea5c9fe5d08c60b99bad98f3d5dea4fdaf5288ecbbf0995abde48fc943f7ec35a29802fb6d81a9d42ee19c6bb645bafce12069d86d7357b33e37c41a66d9c0df9fb6683e060f55e334a636976e039990d59a646955a9669e46fac3d1101e4b86033998ec1aebef0b980b6585d3a5512f3d1c010c13ad520a72b5b2f826e42e1723bf422e39d410b5237cf1654fb15d4786855359865a69b892bf78e3fd5ca0a05e79f24a567b1a104124e124161731e982215dd24ac4e2182d1401a0caafbf8fb2af4dabc0f9689e3b3d00a67bb8618dd06174b984601a147b736dc4384760296f326c23742997eacef8805af16ff73b2603e3ff27d4bcfd70b0ba022297e8f86e1672ea94d06a3fca25bc05ad323b7485e67d44baa11dfabf10f97fb9515a560630255ef4dae472adf523211e52536535179e3d0752bd63baa509398f7a41c47f894c3d11312f5ee1d7c73ef8502488a60c1ce19ecea97263d90f528a94965ecbfbcbe5d5598b9611807d01587e37e5fe30a11da2bf6e7c63cf43a266e257e4586f461ca3882a85988a64bdbd0c1298760b6c1abb2e90eddeaa92f65c4055ceb24d3602aba6055d3e5860a9c012a02834dcbbc4fc2b8fc147222ec77f5db8657b703b387a145c015f815f22f8ff839b5bd5c42bc9e511e669706e1314b53c9d4b20e3be0864b789dc573898095ae99c6421badf13bcb2b32dd4e2572a30207f0c0ab6818b3e4bd4ccc90e006166f66577f921319593beab64e5d2c2abd5893938ebef5c30203fa5af476a220d45f39af8cbce89b764110b6fc9e6c35d690a49b2c70a86467c261b88f2f32af0f0bfeb1d5df68460f8211e9791be61d09ce0478ba5dc07a5ef6a3c52ec844c7a1649dd19f232c68790993e8daf6d9f8a1b87d07b46fbdd7f5f6c240d871e5a66d31ca7ad2753d8623e11eb179dd37b80adc632247bb7a41bc48f930cebd74acb9f76a4200776989095d078709125e08e5c33d2c63ff767bc629308215872788d5b65fb5c73c2ddbb7affd11b4c4a72f3223390276faabd62c01e4dc3fd9c289afdb94b39bdb1bc559fa4131a2b3f7e851a72b10d74128157a98751a187687841dbd0192ca2dfd8d1a55a08b3c0c09fe0d9c48e50a4f8216b48457d512898ef69d8ff1a0d27e9c3c5c5d3869e8a873f3f6faf3f84fe06160f59867f8e8bbddf1e81d3ff1eaa6ce453ec4d703ef4f5514596976621ae1032191943f6ab48195d9807d207004a26cffbcf56c2bd746d1d5157e14aad8660cda3b02f2539bd1617cb5bce5ebc32259a12744acc9627152aaddc4991bef9e81acda0cedaec022a9219be90c3bcf5b3cb53914e8c3e2527b781e9187b7fceb377529298cd2de2b5f5df88c8f97b84aca9fe45159b34dbbbe9fbf8e3d9da0af99a2361536324debd181f096aa846f32fe667effb37949b1f9b3dd3394c2ca93b35f41f757de15d471c4a683f51c27ea11185244cf094f4fc748fa0c6247c381309aab40ee94b90dbafc367a8d6e336ea763eb5f4c5284ebf83638bfa349a68782add551839d5ccf5ec25e9da0d91a7fe3e32f7f4e2cb4bfac0c2d4c95100ebf2305096c1358cfa66da63f7118bd29e548360049942b228b494c2684e4ebc9dd39fb6116fd4df76fa043bfe83d1c173f6aae373dce4f787edfcfb0ef681d5331576442f32e758f4983a695923e79ef0daf5ec24d70827c81e5a0890b585b056b198de2afa64aa698cd4bd9a61aa1b96e8c7865296a2618adb1ccc8609d309035264bb32aee4b42d4f8afb2f1a378bf02774550cf452415a797d19293ca6f3ded816ef0aca9f9ea9619cafea10778514af2868d76a171ab780da94504fdf2adfa6568b1a454e451b317192b0ad0b2ae6202ba1c6d43e50d6642285c9eb0d1665c5df177d9e435b81512ca25f740ebd5b5ad4a9d4d8edf3bdeeb134abb6ea2f90351bbcda8fc7d9af1c3783d6ad2ed3f837469eacd85e8ed235d01b185cbad374fb7aea0b14c560ba0096f35274d9ef1e143dac2b78bdb38154feac5c5cf589b77d083689761d5e148815ce11e192f2a64efc788919fec49704aae4ebc5a61899ec32a09089f3bcb8352ab4499754d2226e43d6d1035fdf7edb92447006f9a9811224361cef930d681cb3838bed9c4604f226bbe301a044ce846902be1663851e1a879e6a1b93e5bd28b91fb64e2bb2f840ebfbd18f32efbe2bf84629ee035d1b298a140c9c87f4b0a86efb7a859b7596bc72c978bc743c704baf5a1da257fe537c247c40f788e8a717944e136dc0397a01d36b066240d12dc329dbed44339f6dba2035c64c632482be587090eb73ef7bd794a5a41b445597045f72b7d1d39c1497ee09c6150a1b5d27e5f689560424b3dac1ab7531215289eb7087d0281c9f785b0254f565940a9c6c957059dcd40e7dca3dca0d748388e096db0cffc308f9ace1e3dc7749c02fb74980662d9cd4bd08615106ddf54495e976653457fe531aff4ae71b836c28431acbf91234c5648fafaf2c6e6debb0f73d8b5942a2443c120e106b40813178ea3034f7e6503aff3dfeaf2090bbef128587e4e0b4f02a27ebac2f5c6305c36f3757dfcdb91963da23653a3f078995bfd86d126f391bd3e0d80ac1e2d8b148f41a9b9708751e3e80bed23ce8a32728eaead1760c0f60dcfdec85e2b2a9ca83c92cb06ff96f20a1946689db1b13a7654916a2cebe1b373257192eea0cf5572d428ddcc728e23de6d23044c75f4d799dfcd0a97e803fae301703a9d99c32c5425c8dac05e4052c119b51d851e5a4596b3379bd4d9ff88cdd65da936349f1a9dd69d91c7bddc97eb649def821a72335202416910ec48c4f55b388e4f3d5862640ec021cb6333dbfe61fefde16c3715d7538fbd88dbe494b3e23aeb1ed1bd9fb1d877cee92426ddae8b22813aee33795c6d67b4abb6c5bc395d6653e7f0ee6f84abad67b945f7b02250115afb128808522d3054b38e84b87513b7a804f540bddb387c0f3866cda8dd9c661b00968c7de96dc57e01d1d10ee2a92263c1b69df6bf8eaf26119df90a867ca531db0f28d76814a77131fb023bc7f41dacf0917d7842a095dcb15c0cbd7883e40f1529b67558db90daf930d4b77e9e7e796de6ffe90619d911257bb39c95906a279d9565c08ee6dab9a8023e579a7ad80b8c02521903a890038cae134314a22d67e2fccd85687f61ef3bbc1b8b1ac7bf9d8da67f16ee12002cb5c1ffae9451ea8ee1bb6973c8225385ea4ce8538fa0010ee3c569965f6b542b2a4e2dadf7224efc1b2b1ee01eede89579f51b415b3b45bb15640142cb4764e8c8ec5163dadf56de7ed97a1482075a81fecf6cd18b6683c210871cbd2b1f2d962712791b51355e936c2076df6fbc7fb52ba956aac1e836d6678d14e671569467979b168366b18bed412a3c00e649de9f5d22bbf331701f6fcf3106b43b5bd2441bfa51d435a6069f3e41515fe309ac7a9545e5901623e2ad9f2d3aafeb960f2e9137ddc939eaf3168652c17ad37f9787bb1c4ec32e7297a93c72f3b9dafd075b90445c103e5f2f774c156555aa0641e7d3c2c2819e87746d4744afdca242bd0165df7fad04bf4065820ba6bd775cb10ac73a148bc20f44b74ba6c863775ca465b31ee66b38902ed2a59b81654998f944edd74e1fba1fb272d717091092e33589e8f618991578b15e33c42090ec44414df89d2c32828733f8f7bb1fa36cc43aa543b722898b03b089dae97ee6902b39975f4771dce9333c73772216a2d33a8eb0c5df739035cb741130e0020a961b21a26e8407be596658217bba9437ec41cf309e5073b53cfa44c75bde8d86d96e4a875adc1cec3e0715e89706ae382da91e9a060984802b5cbaed816ff46e2662bd58414a1cf9ec126d845758ae68ea9cc98c136f94602f1f12f4b3cf66f85e01d2f75fb13f452e02309bdfc2bfca6552a3c93a27a05b9b020237343db1b4fd38d9e261bdc7cb9f9281ccc261214cd3342cc8e1833565bbacb743ff3be3491d61d24007496c1e56a1364e9fb570ad76f510786939b715f5eb69fe500f5d6799b74a674030efef2849bfe0dd88a9fe8763ad77147eb63ca64af7aed850b450b599123610d369fd9b754e060ef9ab7846e57c79795acd41339fc62f7d54ff26c465ba00a67e8cafd5e043cbe3a2bb9e9c30fa0a4b189a4705031f8c5c1bf4db8064739d4273e5db47167730e3e8af70dfab728750e2647b0fb9978a1098b3a9b2f0f12fa56749badfcb640121b1e65c9dea57b73a8bc467f24be08a748396b619c25878fd750fda5816d40b9fe472ef170b12a23aa8f228011eda2c8596a58fc885dd6bdf396480558ad84de6ac66cb33d419c18df8c5b53e5b037ad99765a8fab8bc135d35fa177080797c6ec5451f69d502635c34716ab0596dd1e53cc3211f75b311551f1639ecb5c5c8384281c3de296c8c3d3a10e4c95ebe5d087670cdbae6e0c7d7d1e83177bc8a5a806b71d7ce7fd8e8909651a932120189d231a46d4a675210431a2e6121866e5b8c96feed16956277363108be57d0355f647a5cfa84ae0a2b432343831d59428661a17c0bbd0c13d7f6161c38fab3e3be2289e3631d5d11f33b05eb39269051d2c6feb3714ec6578fe1d6e8197ce1a075fb16e0e3c848cc6a547a78aa501b0cad6a0f4559b8f7f97a35223cab741d156464c20be4d241ce24a7dd6583ffed89cfff57cc7e48ec4c9361df9af4d9729c36c1f053f96d34b428cb1134c896144c18c304f4d3e42f0d0413eba75c6b552528c90590aa2a263073e7542ce651e34590f2af2e0029c112b1330ef2fae3024ec1202ebb7d02492fdc2f8f9ce84b7f9ae142663abada3acd06775649cc3749d441c5ed29d8ba0a9bc74f40382ca755881f0d7a6a06dca3330f18b0c9788132995007719e78992e4fdead45a46e727e5e19543d16d6049927155fb56856d2f38bacd997ac99301c2772e82c712d8ccdc500cb3071835c229884eb74b60652bfba9efc9d33c9d525320197f4fdb88a2513a72c967f750490ae698efce3b245274424ffd7725a0007684e8cb2bf260e5d0f54c2bfbc8f9fcf3d19aa6c0bd38e9340b94a331f1aff4cb6449b75c5283eae5068a7d58fcc427307f2363dfc2f94e220460a77c7b6b7395d9eec4a4f9a93c4482de755fea38999c702ae9cc499ec760639d0c5a8e0f9a9db3c4ccaaf9794d789ad921e146ac4e309a13579813b4fa72b08f8187b0c6827ac0a442e94d75aa342689edf404cb41b6e77af540d0ad45a41ae09c057454c9126f48757e241a03521a5b21e4eb3d22c22eed4dd8a3c926e3694f55c5c663f2ae6be5702f4572d5548c28067a8decfebbdffb947c052ce12198e1a4f5576e759ee103035597d41d16a7b3bc87175f3fcb3c5976b81629ad855dfb909c20be56ab28a37d26e4c4bf2dfa77d774034b467f8498fa643320d9162e0f3de9639e473fc6c5e741626129033e834f626485f35897c93877d8f2748d020306901d9079de1282e884dc87311be7d46bb8519d507762cedc12a5f6d3480da00a5b269c99d904ee7433cc9512c5071e9980d43385374cbceebd0c8433791823cae8f4566f1f7c21ac7f58b68bf5cf7dd18f1191735c69873a44a919642ad3fe8a23b5cce2b1039a339e96d51e3c92e8f57396eba369b238ba98eba0a48a8c9a4c05cb7a9a23e30bcdc0fcd289f720291b273171b05dd782bb95d4066c03dd18e2e9365f31cf97972ce74f569a1dfc5272f20e4779fc332bcacfb345386036c84a5cf144c0e99f4b7a14797e1c8d4ba65c67f8b1f38e65ef57a91f262115f9c97463a05ec9368fc2e20e0f574dc438c83b57a43414543b12c526c69b9f62ea1b423defb6e45009cd3290446c445fcdfef2463b9e1ac434a081a4e1e81406ff5f49a4740e2e20b37a952ca7c707b72e1b75ded8d18cdfdd60ec98285925ab27f7c99f3b970d117713e5ab36b5aff1a4a1cfe4ea476f1f509247a44d43efbc1281724e09e3114d7753bb540c76ea54f83a2e3c72a6594b5115f3161d84c9879a014cc5500b48edd21315abd180caed38405cd828ba20285ad2bee604847b3fa0af7594e0b49c14446994047cd6db1c946ced8ad4569fb1dd8aec0318fe861e8f67361912fddb110f270b232fd67deae8ffb104ef280693b99d09c9ee57230cbd5bbb17d211cea8a08f17a2b337a347efaea3bc3c94f069081906f401509469cd1d6d38746290ba3143d552208582af732669d99defc582ecbfc5b4b7894820d3efd6d731cdc54091662aa868dee1eaaa8ab43fcf0e919be27a8079e4846dec41da04b1da43a3938ec33b8db163a2c5410a6afe03405f07f982d6b1b604f74591f5225f083ad0afffba52d9ad24cd5aede948c6b7c6eee2f6f60ab2dce496ddb71caaa08a51f01b0bacc3546819c767a3d457a9a0628d97f8e90cd1a38c5480a2283bc2d885fd44667a9b8dd8de25ff0acfa4c59be021565af6dc2d793f3f209ae4f7f40088afb25929cd98ed407d92702ca07365011ad23ce5e22d0ef5e97cb34a9b951403b7172c3d295ee09679f080464f48faf52622034ec44a27bcfbe7337adc690f37d4a56daa84a0e5479f72dfa9e75bf8d6f7a4bae8d70ffcaacbd892911f1e17a611928416563b7233c4b5f70252ccc96da2f70e67e9a2a394c2cd3acbd55cd2573bb61d561c2a9aafba4a918ec8e9a894af4efddc2c4e0253b0edd8be48da7457c7b7371bccc55c8245f14b4f41c209dc3f7b142114ffa9dd905b9a3eccc8ca93debf79aabbd93529c87a2d4d9c162c23ce30e7616f892b599e3267e87aa6e5b270afcbbd2e66a82677218126f61a1abbce4cb83afeb349e2e95c2bc8a85a927c4fee767ee479507bbd5ec961ab85ee36cb98462c5d8fbb2773b49ff326784bbb1bc558e3c4d800fa23351db73f6237985fedc2bec01f483a1704ff9a611b3e941ac248b054a917dbff497c62217d88f2b57a77100a960cf922127336df5f6f7caf5569d17d2f88b4efdae3a97b66a2466902745b9571e80f28e9ffd2f25a2bc0b8ed1c5843aef21ce3c23b002671c711a0501c178024bb54969a3759108c98108cae959f0762bed7882a549b2229e12f08f4b2719e29f5cba9c28f639775f3a0001db6bc0f58c8b09c174ed35288d32e39866bca67f7568eeae862f62e652cb157b20e02f0cb93c63cb31d0f4deaf566c43c902e4a7709be01b4d01e55c9cfba3b913c180390ece562361e2434a1a868c2fd51d28ca54be663549c0707af46b26af3749aaaab0d3de42b73c2e25688c78cd6c716abebb657d284e8d2baf430ae378aa3a44341f502145466ba6659c29fa03e85dd624c6f6a8d249b6fecfe2dab585b8915c32fc39d8460ca660a423743a607462ef2b2649e6c1f5b3d3e3651168552ccb0c07fd64a43f8762f0f5dd793cdb42ebeb5472e54a7b8f7a610d6fa0af472cc137729bacb0a730bfed6e30d40e63c1476150407b0ea03d93dd7f5b1e2f2f9a5eb2955ca6ad047b7a11a31faeff1324b603c6435d39e4918650bbb02fee777cdebe1ecf8c5514c1cc86db1ad204a729b358e7107684805866cb374ae6afe8aa73546172ed7339e190110f74c1dd9af5042e2eb3873adc96e9e56aff92f8d3638fbb9cf734bba078179509380efba6b20d0fef4985dbfd0a2fed5817ed0d5f35b78cadc2cb20b3ee77ec46d3cf5bd693b84a9ee4667a17f7762e021706cce1b3421f77b9268c8c00c33f7d058ea2bc66998fbe1bed77d0eb3bedf71c31a672c152096e8e1db957931f048a3c09def444fea267a143e02a9d17f2c6d22d25d5e53204990757c77e269945cecaf7834f18f0163013280a9e4b2f42523c5831e9be636b9127458843b10d175b6ce22a9bda71fef213c8cbd58c9753fdee3fe6667382fc3120a407bde9cbd7ce8d4b5ff09e658bc8e82a18af987d130aa76a54c92b572309d6531ddff906e27ec0137ae22ff8d5d5f2c9e61611a8b54d406f5da1e5ee45c82fb3c2839c88d7791ce48767282009c997edc1e966a343048c0e00007c9ad304b49681d5822cee0891284d768eb0e419caef53eb23257b8f14b9084c3c5e4ad766149a6b027bc720e7738dd7a9a25a9d21deffddb21ac13ce8e0cb5c84b0aff8fb81dcbf7e8177f11bb7f5bf959112753643efcb37ce1c65ecaa6e215367d31812f73d227af71f2b6a853e8d5517025161304f0007f0fc090324354d729f4eb01b3f2c2445ed22625b9a168d6be04824ba3ecadf2e215d42dfd201211239fe007db4d468bdfc03edfc2c475d950eeabd0c9b0f40a64c891702ffa58db154742c5f0d35db221907c5f594a79c60bf631a51d935d56ebf49f1cca4c61aa01f71abaf3823616b63d2b1383b081afd27755b3254807153be288f1f0d8fd4a18aa4907b367e1966783b3eab474768a60e79af8afba6d620a6cc1464a3859a13b6d038a3f7a0fc02e4e364ca97c5d64d5afeaf90b0005c5d762d00b09a7b2945231428d5368049de73da277ad473a1316398a7e7a2c2c2b907228e84b71bd0988e800a6360db4e5a10eff28f687f07717140a0073ce8ba237b82f8c4ffbd8107d957f228b99b10a4f40781f381cc2a5797dc221dd6ed8cf5a2ccc779006606e4262bd73a479b6e415b7b8cff3c852ea448f1d833f0c01d516392d1b88eb54696f06df453a7b690617d9f464927e0ac0d27588925da4966e291d00ed5345838c224ef009032379bab44407cd79d371b56efdb9753fa3a5b48a93d2a6dc2a93c67483692dcbb8c362475dd9c8454fdca285b0fecd7bcf4c76db4da5688d6c79acd982dd5af5eef03156fe8fbafcf887419233c7d73bb572ec9b5d758912aea0eba3e42d6243ff137e00925529812fe2c1e5a4c29db3aff60031e8cc62253074e77e5924cb18e53411d3fdd9d7c3dceaf961e4053b6cda79abb18691763958c9085366446d205986964508bd309ec4fa5f7ae3ea00e2e0da2bcdfc037d1b65524785906df4285437d516c49f3429d78731247e72ab1f1a226f1c7fba73a0abb14217b5fa2373a46c1500611fb5bf761cfff9b875ce0688bfbb91789421b73aaa90bc72f6fc63f1ca1d53676b568b563ecea73ea872850bb6faef9681d46b2cc0f71b1741d2dcebbb11306d2c48bc34e0ae20b31a26c4057068bb7a5a1584f456c6935df1f90226098cf21c0b8cdc45f83d6ae8aeb074129e90ac082573a9911fcf0e0b1a0a3a99ee0cb58c10df56e3f22b076c24c53ee2bdfd26c7b37d72536fa95df287c5e79e095f0c0da471f63ac12c804979900cb8384d35eb3cbf5e46dc8316e90e56bbf363df122f9170d3c8e37ba2191ee70196c7887d1dadf137b9019874681644ad45fe592e3b40694417d545a283479c295bf2fbb1e67f27d17b7fcd78191b012c0d4b5aa123b89b877a6af7c765e357aacf266487e607b81e3e7f5dab2ae172eda4469f044b7e4392f014d68562bef90de333eae77579434abd112169210b1e225e20bbb856d8f1555b99bf004625ffc3a5cab80117eceb537272ee336fbed47558331f4eee8262a0f9b2bbc0204b59c92b981d9c8780645b6f564b649c97ea94aa9b314a4082ee98f5f507d74099dac619e8f8ea38808cc6e62bebf293ce41635b73591c67c9ecf4bd2d483b13893d560bdf67dc40499d3fffd0dd63e555b42cbcbdf4442eb23cd531dfbc12662c552ebe167b03e21924012c6dc8a37e71681da1dc925af0bbbed3ea00e07bebb7081d6ae4b5d1a2b483283d4c1950b8477b3e2ae2e3dd0d8d468ccba0166a6ed5fc47d7bcfa64ce76f2641d5e9e19d1929f9f740b96d6b5ba70d32841b665567d8a0e28952847a66fc265696068a8b01e4b45b02cf62fee994d1f4f1d4ef824fcea0b843cc51e04a7768d0052f3328b853cfd4abb787cde3a1e1f9016be01d25326f86736471fdd9d7f497f04f16475e6e83db290f4bd8e2839585518f92e95573dd2838bc1288aa663ddc1bfec067ef11b1bb5a37cd1804669996bf2e1366dd71c34698a793a7e1bbd44f0dbb855d4039aa3b75575f1be7e97cf3aa87b9055833cfcf626478323561f803ce6b61919e7af7ca1f4932dfe0655502a33b5d13934c86fc80c16bf41c2a4b3eec72ebb5b767f15bf3113a0c7f0dd19cbb886beb45ea00ef7f94187732144477c7cafcb85439a4a1a7973a62299278d327622470d930f7191735620cb4df282809c7ef52ce08a6d3ab18630068b1d666db69924a0adee135a5ef1ca92810b64c6d09ad581ce27fb8850676b3f839f69e7db33885ea1aabd75572c5f41ffe45cad767970a98e15be46311672dd06b1b3f12e19a2d0db2c168c1857a74b70d9b502a73cfba15b4aa0e3384b0672831924a4290f4281b2b469f25d6fc264e311904a8228dbcc6599f5bcfeb5f6d4d0b6ac0c7ec053b677825420b6af8ebb715aefd022a6326b69c1170e0e474e33b522dfd1e40744adf4f2c7d7733a4a25500c72334e609877076cc7f8afc25ed6a483e68e9850f09684ac730dcc0b24fc83c464665c02411393e478b5ebc792523aa8834a6d19cb5c33d3d02d937e3b0e65e5ec96497a31b49d0f8e7a49e254e74e544cb02ec314627d358ac8153cccecc90cc037a933fb726c28a273f96dd1c871cd553de84840e0f9eee0af61eb5cf509c5b6fff4fb983e97bc82a8af33186a0c217ffa9468fa2d8c3b8148f1fd6e7a22673efa75129d24aef05bd5ad0e992f6e095b99ac4b31dc08255f65b77602cd150bdbd9eb4ab7fb28e48bcfd911db0b1e344046c50a2122e6c7bedcb2f4c3f5f69d31038810b4597e995c178125e3fc4c8643af5d75fbc00789c4132f50cd27e9878bb67b893a52590fc27b120343f6a9190f325ed8acfc84e09141847d69f75246e48fda1b45061c5204326f1af067897078f1352f292b444906568a63bb8e34d9ec0eff2b19c6514c1ef10a589a6431dfd45a8db6df932dab12982874036ed58bda73adf06d59523a842ebed58d8c72c5f8f6c2ae54c2fe747de3a0e5f6fd521842dfd8363b3a874c77f2d2f09ade013524d26623e5a3f81a4acc9a4e86d465a25d937675ccb9ed0cdda5c055e2093242e2ffa21268969f37330e2d8c771cf11172aa10bcb1d65061c59718fc568e622d6155d469f3ca24ad4ceebd0309bde2ccee6e5cfe3023d3ed1b12af944291bd7c1483b133344365e47d0a18df0de190093c9ddc90b5a4b6c6a7e332a9f49217a4a3810816cbab7af353cfcba0de44263fb04aea0cc22d17e8fc54e4caef92f8a04179eef6302aab4044d31d468a04a63399cd0f6c8f718d7c80f3ae8597a1fd8793be0192b8042ea96b424fb388b58a0c3697b1333bd51e40dafb0960d67a510727ba721f08983cdbcfa85d0bd4fcddfd41c9a209b51956347bbe1a7dd9c3f57676f3f8295ab2af230db8f6b63af468924ff8d76a9fcbd868da45369c05795407ab6c9d4ed9197a6a356e03cd915792ed1568867a422b74e6dc2ee2f078b3c3cc991cbb49d6762d3349cd6342d4374f15aa5db14e311e613422c46ee1416f56a21ccf4d7a329b405e04f44e61cdf596e198405f4142b254fed0c1b3d4893ea4e1985601fe434fdcf5acb79be5a70ef6b751a64ba3ae23829d844ae4a1d39892898aefbfc5b43e9eddcef74e1cf106bbfeca6c5e2c6d9c5ab207dcb51df9eb74050c4d6c863a7bb62016eefdb310c77e4d1ad42a8952e24684ddc5f9fa0642099bd7c7f4ab90b1a049698eb20376f43a6950e0b6549433a10f3799894a583c8a8c919f1f971be5eb3449663e1ed4d178116cb4ea4c12937426b59e67e2e8c161da4f49dd1fb7f5a2cbc7e8a31d20fa943b720d2107ab7b9e9cbfaf1d01f199f738cbe66dd4b9b5475a9621e5dbf0e1958bd2553bd35e8fb30f7fe80e955828b7ebcda431119528ea44acfabb9e13359cf97704585556f036f4df92a58a975053749969b02465e63686f8cc9ab8fa0c466881bdea38e99ad65865a3197baf89207cc5b87262472a8b05f21799b867f9ee49aafd7b798acfa4f7b8be4274eb6b3a041f0189c1588d2b219a9fe112227a00df92c193f4ba2ba7f922703cf320baf6ae8a9cbdde5aa11bb8dace4bf10be80608049e66cd90b44f6de3f780cf126ce2f0bec759831971948f8c8a042fa4f4079891219fdafec62b4a1c95d18dc335c80292b18ea6569b8095ee48cc1fa49218b8cc0485036063a877a0b30643a675c91b9bf06b37c3f666beed4b41d1215d8fe1b698f4a98885bf46d16ed17bb566b4901630dff3a08ff9a0daef3a2f1374ae894260a4d2fb6155739229971ed1ba814eda1c4115b364c99c42ae7f41cabfc4cf6672b66977bd3e9fa41a4d3e4783fb3d3132ad69744b0ed8ce2f27d99c50f0bb277f994f358b8985d5e9acac39926e465c55d22ae9a26f7eaec3b9256b70cbd61bcd39ce956ae247a3f0c0fecce2b7502a93e3ce05fccf0c989921825184e5f287467d70513b501990dd9f93f2e12f39aafe1087b190e03d4c84707d55036a355ac2e7748e2af0e4d0b7e7e4557feb7863bcb8e1c775f1c204093bb9e25451c7e9e965c80d516f71f3de5d08809b75d8dabe2851f1b60751b358937944e550e470ddd710a28264a61ce7ed9b943a3f570cea6222a06b737b887759a2121b7494b007652b854af99afae096266c98731821a6840ba3070737c3e00d5db56138e4c461000f305bb9cca20dd6786fadfdc21cf361736cc52ca03f41f13cdd54ba8a4ec7fcd79987a1f7a279a0233860243c36b0a97381129984fab85f4f07aa9e83bdbd806e17f6bd7bf76a0ce1c9ffd42aa80dd7f2d77e3b22f405b759a057972a174742272a4e2d90752fbf52795f6f2fbb3b3734466c51b171c0d1c4b58d40ec03664abb116f815f38a0f43d0f94e3cc9ca30bfeac3b332f517a2d71b446b89c137c89c2162a09af034ab3c78ad648f246e49465276ce278b253c835bf822b83ee63fac89401885a3edc4f0aa15ff5bcd9b9025407256e3bd84b91c88bf764092fcf90e42ba0feefdd89add520fcbb0f4c5c392a287f7b6832a166de25dbb5b4d180536b769218c7f25de93bb68c58920ba52b61e461d90f3c7938af10381164dc8d50a2438e5fd866aed3d731c5a04faaf4dd28045e8683cb2b49abb398fe7d20bb40697d46dad551a452b166ebc44085e76716d390800de1ab1b7d0ff09322d01845a26926e2dfe00ce233734b8221c1cfe7012e9cc351659d0bd41fccb72cc571008a4bef0c8e2dd8b75836321c08aae7af5715e558469b3606cba6e7cf9fba937b944def2363e1207f051ae4258204099e2ada9657a6a53e2107927583d43a44cf999e557fb8b0b87fecd0eef78f1f983f3c0163a006faed9a9a9910b779c28455d8931967a77574e0babdb5f0389039b771131afeb69dc969fa48a88b633c8541b76cd58f84ab6946d31c9053c37f155d93b96827398b60ab54a9aa260c96e078450414b671c290ccafe7460ff57e739ad60eb3ad91664ca224584bb654bc2edc12e7018d7a595a325c2c61e4921214cbb2c62020fc89e4cd2d35ac37e6bfabbfabd7520cb239579c8ed42f739e4aa8ab3fd36c7d72a869fc801bc3038c07a8fed30921af2ed1ca9dbca2295b409d6baaee61a7f8516d406f60d0a1e9fb7a523d2adb953050771c64d95c1628ca75631f554906729184295e08cfcefe70990ffa407d90bbcfd6a52f95ab58582b1188ba29b754d4ed38d030daab8b74f26996c9db989b25c962e67a9b2ed9412c79128584863a71db97e6a904870578e8f3dcb66997b16618f48cb8fcc974542f53bd1ad9226a96bb305d44f1b37729d3f1657ddf4bb9b05f31ab4b5d36f66bad8de0c8bc27df53a563585cb11518f48857ba82f91999208e7fef2fda800a16c01b41c48ac31829cd34ae598db5c81c017c45b3db27cecff2704b8f60965ea19c11844bf66470619faca1034044960f6c7998ee3a6a683734a33747520a823afc63d4b6cffbdefabd357b295250408e904a565d0e960f1e2df817860410f27a11b3636edd808f0bf88cbef85f49550f5f67838f469a7cc2274370f223dfc6dc1f52d70fbb6033d55c84429d10309b79839a984c419755a487ff85aba783db01caaa061f1b1317a1a567178ea5dd957221f2545e063782649909b7acabd1665c99ee458dbc546acdfa57089aa90faa02cc19220d21c0f72a81acb7b8637358595888086971e3b141b99d6821da8652df31fb0b88fd7fd9300ff737735b6df90f69c0b98a13de491f0de2344e327be388f55e6b7f4b4e0ae84c6c4aee480890467d249d6f1f11af1f358de4b685cabed4de3469b9139070007444f74c5e0438fa45698442267c5e444d4abe8536fe7bc39e8627311518e0a486825b9cc77cf961589e183a50fdc2d9f38506769d3e6496e3420e0c150df9e9e6b7d389113671ee23b6f9b5df4d915b8710de1b4eb48c1dd374a816b412525a2d1f458990709f7987d917c3fc9e27fcfc3f30b37110883a4399ba378dd0dc655937577c55ea431362bc5ae4ffdab4ad86e72f357e3be7fd2939b7abbc6751ba8c8c42683d6a1e68e8d3bb24c919321ce8267cadf677e76e8369b398289dd0222f33e01fdd3c8e69d20083d76cb833077b636cb88c17df23ff39efe988c44f8cdc89bcbec80d5b9b03b29efe4a021e2e6ba02d5e638b7e949179e367426a7dcd8a603b7067a7536c2990ebf809226b42ba0b05565ee0ac155dbb7165c42e13947854dc328788f88d25c83689442421a1ac4304216ac37566c9975051584d400cf7e839c6a11ba11b6126e46148455cde5ccdeb9a7c4865d6b0110d67a9d3b515be7fc64c6a985fe4d646c27fff8acb874c121a1da11a7f994e89d9c557db89b9d76d259c58fa69ab7eb29f6246686a4347d44aa891021235dfe487716f5d7dad73584ed412d07f7ff6c2412bfee1ed9bfdd762f20f6764f2bf9df82d3b1cf4a855e5e5ad6736f0a9f6fe45c8f73f7e6a6f7ae90242ac59d805b0eb683b59c77e915b698c85f711f819d19c0d7b52477e0b4a3e8bc24ef9e229c081961c39adf609cb04801652752d90448f9f1febaf0e95b6b09215f5257b7b1a990807519b9f441093487ffbf7587dbdad023a3fb70a791f5f479e216ac65e3c4f57e47a4c53feaf73e9e05161953c6c051fde7d42747091678ca0052853a5367fd29e986d9f3e22f6a3b700e95445c07127b347daa7891ca8d85689b89755eeb7894c4974255d3e5178d1a2728ac5410f3d4bcb0646e8b863936a78ecc7384b1ff49991ab74d4a45d588f5c80ae97c30f9b059a9933f2d2c50af63e586dbba174a4398399ca0ef41e4ccb391c913498bf1d5930b72b658897542f8a7147251fba8acdf7f1e07b1bd1a3bd078f0142a84ad0f7c1519ddb28248bb8bb44088e22b82426de8d19ed58e1eba9b55ef8ce363b3ef3d4d85d62917b39714d0bd37f4b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
