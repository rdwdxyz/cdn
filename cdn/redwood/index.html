<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da76a5fccd61f8fbc86c9ed4c7f10588ef1277f2bd660b190e315f3ef5ae4b0968cd2880eb651421ee5b600d3572610b730a3c4b741a576bd157645991c6b337c155248b7102bd114e04dae5e273a42291a4efa541b2d607c69f4b28a4673851a79f0656e71846df1a4a658764fdd7fb75a8c7104444943adb63c1a017cf1ea4cdfa773dac1beba33d94ab1a8ad8be2e8c6e78d211af855b9bc7ea9c720c7cce41d97d346549a8b01b894fe99d8800082b598bd32ce607c429804fba2110fadba8e1c1f79cc1b953a3affe6dd2e8c16cbaa00c10ec7f067fb7a6adb622c1974c87834d0f1a4812e2961e3ea99e8770e73fb55d96f71bf25cc32a568fd4da6482089d5eccdc87cb75c3a170f1a91dca14b99825d466839e8949a10d707dc6489a74f675dd4c9942f82de9fc62aac937869be2ab93985b5846fe91cedcc5605e592f6837ad00fb56e50c6bca5ba1d1400ccdc5d063ca7bcf7ea568f1e2d133341250e1e5a7ed0390d8a2903ff2595e4c76b4db8014b595f633c40cad429bb70442c8d9d64949e4a63993fd4b5a731309fdd5171c3958b11c1d0f1c0c304f6a242f077b5f4a30e4f5743e76e01767874ef6721576dbc54dd23da33577ec817120f5afd5f1b4c8e0673121130e96e0b3c9e8b4cffce1ec35af705da3823626f626beb40e530b27fc6324cfdc570f5d26fa53fd84d485a6863b31181f8c2a7aa6bf19e290b30f073a5bbf8eac9847e2d8d18607847593a0c60b40a3723e4b587c8a5b7b30c203a661cf5b00dba5b3cf070c5759cbe30388d451979892f3f5fdc16c812cece42ce684723068f5207f09c2a2045184f546a93f5dd903c94f84ac1e284a08df0eaa83212e9744165b2c0ebf176473e0292f378a32c085096d2b7c050485792403ebf2c021390bf7f4d6667b0ec3bf43a5d1976a302e903f205fd5384ad6e7b2931c3e5a7f043c2c3748176bbe01b7d95435090e2acf8d287c9b04b498f6e0ebd7ba183d59871691076e0a1815796dd92c6535efa048f5de548a97b7334d48557db13b7bc298f7c5c200bebb0b2afea6f77d898f1dd081579b63bd6bdd7c1daa3b2a4cfae7dd83a33a69de20aa2174b827c519443cd9eb3bbe436123e6ec4558187e1b0aedddfeb672c7bc86c7861c5682bd004de909e6eaea80bc796cbc94062a3ed6395de32317257a24217067b00bad55c35c86d607d2cbc54d5d778ffb2fdfaa7631f809b9178d7de4e799db1fa31ac860147c8ff0caa318e3e4b3bc16c691623d41b0a4ac14479902adb0283f4f7d4bf8cc4335641d1326b6b785fa5f1e7038a3bf5202add17b6e5e99123919eda57f38e81d6658028dbf04a03d42d65ac2483a7b509548e27c0d51f353ac6993fbc4b4d8f6482a9132602b3b4a387054b4d7b5ccfb94b4db6dd2a9d944f00b6aa25181a51df1c7eb5088e7a885498a5a8b68e1f9412be05d85cdf2e58e0f99ac9a75eaa44d95a9a29040495f3050914ea202085835ab160388f0fedc9820d03ae86df75a2ebc8e2708affa1ae0bf4d4062f8a4029abdac7c66e12422d1ccb47bac869d5b60bf1744f165ae11ecd3a2b6d2bcf747aef003d8bd94d56b0ab7eb6c5ffcecd0eee30cb19478d10d7360f69642d922cf43a75f93c49a31fe8b2d2e28ffae7492cd2308342f525c5380d0fc0e4cb95fd32b44a7ea7020fdbca172d125d63fab7d12473e50c3a07177c8b67de3d738401326db1264f2abbad767c51b67565b09a70b5c29294648cbdb5938f48fbdf178b8fcdd68df88de4863c186d7ed12ce7d773e79a822631b6d8cb3872d916807799fa01b9e2be957c9bda8626d92600dd8fc280924ea444c4fe701b5db21e9d3855bfd39bbeb8494db283e5dc7a11c56254a373ac16569864b7a4d3f0892327945b6dbb1bcadb175f73c846d48e1688e4f74ae2c0f0987c06454a51b3e3e1c716e20b8a48a523c50447cf8545126ed841311e015a206de082089fc8d0947cd01c0252c72f399e16b2cae3b83ef06d7ca678d5fda3ea2a23ddcf9cb92e6d97ecbac856643f5c017d53cae900317f34fac4966e49b967e029b9f0694e5e0b2bf503029cda5235dbbd76ffe14366ba08c851c09733a601c72a0e821946b5d2c2864dda1acf262a238746e80f9c787da6156881fea711817cd80145404c7808446b5f822f0f4da2a993b141cc96fb0e4e8793195867471e20af927fb0e7d7dc6078bebae5795fe84ef65d3ad0e57de062f77434b2e91c956d9dfd7c767990543b97659b51c19fa378a2e70b2b8a79fed82a427bca67440c4044a27e6cce2bd78eb82c298d965360a0e54886a977235a88a0d90d22287e6dec5cb606e943aee3c5565a2ff38bcb23249867c50111243511b5c08942c7f221db4471717a3186e706305a9eda41e18fabf14c40a157a273a519b9570844f4e32c1296e6931b5985ad05108cd25ba0455da0b601419e52da7db904942bc91b9581b29a3f8fa075ccd7aa73ab2782ceabd98580f98b210c2cb1e47e3b7c0a435b65c60489d03b8edc0345f62233da682ea4c426c91c49c52008b102928146004d0c704f6f0e8f2a7eae665865dfa7f7eca40f3c0ab007b35b534b066ad078e3c9ba290044c43f46434f5ee4567ba096a946c99325722a2e4f1156dd878fb19315f559d51884dbbc499d4ed55866b9e07619ab24ef25348ff681c227c5a36c0254811fa25bfac93006f2015fc7167e5003fa4c6a77eb6c6a8771c15db23444f057bfdeaa02c033348dfbae85873aed429be1e89d83e8f83ce9c39b1845373054fa8c47c5dfdf92e4f54c231985c7804cf0d754e6eb197b942ccb8ca430c603d03b6024b2891aa1cd69eb0e0783c3dbf08c6c055c53bdc5571894ad76ec6cf303e393ee0bcaad594f3212e95b0731d2e06209bfcee07a96824cbc59f9293c0abcc8fd7c33f32d313bddf78cb9ef75be3e9a4c2fc1cdf77e5b4b04055da71a5e4c7ea381d837aba8adc7ba5da8f7c8aafda8a1c874259969718cc7ebf1fbd3ca7528166b3b5f336c975d74cce191f595d048b65528d9041cd176069c9225af9f54dd0e89d50ad3dbfbcf81dc522d071f46f4a0f90386fe0fadd2e54bbf1c8f3dc7245e48af4e977f39e960f969c5ea8a76b7090771211a5509f9e5d4abe250dad0b72b25675bbfb99f394966febdf94bb7a28486407e3216eaf2abfd607f28a140c82ab6c534d24ffefa3b3b9808acd732a76b49100ad2c69f3551417b768c0b81535e22ead80f87f8bfb727004dd150632e2fdf24eec5d21e38059e7e427f85aafc0b5b4a14bf7fe55a8afe25abbea1ff89ea7e4f5c3c9803e4889808e359ecd59825e768d269fe362a5c880bac0413330001e07cb6554b185bb93c32a3c559226bcf6da10529ec14ea48e21ad6dc37ba37469a1459245911c960eeda0f879ea96a0f035d8fd744c66742c1d34de890a0c86872b838460b192736cff8a42bc5d820ef34c0fd011cf7e64bdf10d2697afb4c69f781c1df9cccc06f63c5d569df84976e4002b1f1ca2fda6faf469d0344a291e5f6b488b333b10676bd0af0c0a89d762037f7c6657cd0773c4275990dff8b56a49498032eeeebbe721208d5e23da471f8b79e7790ceeefe1fa5371177d09b8a3d798e1bffa1565e986f0e388cc4d84038b78327763ee8934f92fc5c0142b014274e11f6d21f3527a33c86ee497224309d3a7e1205e524adbad651d636f585eba86bd592acbf8d5e85d93c1ca8d24f11ddfb55eb5479a32fa0ac3bb5692d24dbe97cbf6ebe89cdf235221187bec95ee490c68f0e85d6502b57707f96730d4c1ee9e49d0c524bcccbc0f81cd58108de9eefb38cb57a0cce9b2fd96acfd14b16452e09391d1305f2978cc3b98ba54fca25af9782c80c52896f64ec89e5b5e5837ec91bd9d927740013abe3e1b4ec8c104c4aa24f42c599044eeaea1d191449a731c01c0ba5359b86973536c4999e75565824a2c5e70a743d779d5559cd67bcde50b487be1ba74a7bda266b08b647cf87206831c7d5c792cc5967465b1bf53996f588466d583d5f481c626735b19a76a1aad033cb4051be48cd7a92e7fe93d5ea0a82586114ab28c8bcd4035e7a36e2c984817b3790d23de7c22544e3f6a05e48a4dff5ea2b9f633cd6ff230585c9b7218188927c0efd48fba418ddc216f11b8d793714a60dafa89fa92c54bacdf740e4188aafbbdefc41e7d9d88dc83e54039cc5721e85c509b10dc67acde40eec0f46936b735ba3b7418748726fc120f6e4b26f63ec8e6e42ea7857fc2ab74ff092c57b5f71becebb6532ee7c9c4dc9fe9acbc357a7c2279902d484ffdb05288039ba58497e247f7734397f87e39c63062cd1e615daee6d673c7eeae591f205bbd24e00b5267fbf4a6f65f772ae1622da9744471ce223453cb32815e9aa115a17b8b72a8e143ecfdb90ad414ebed894fdf425c1ecc69e68f2d51e758a3d86b7780432f6ca5cf2469e11953bdcd78546b8f1c26f4ed5bcd620d5d61a2590dea4e094a0ec29d285d9c69f072bf4eabef3fcfc903d4510c78a1b417086e670b1d78985034785025b6ac18eae3018326a274c1056c2b253a4befbb15ca3e981e9855ac1368ae2ca868ad37e6343bcf10724132f32a73826f039d6675c0b442f530a4b9d18173c1ecf7fc8b99f7dcc691913445e8b4434ef69dc8b8b1f15b29b6d5243723ce4c2fb21f86e77f1b22ed78d99796b86fe65debe30f1e821814237b71d3d8ff4b0afebe04ebb3187f79569e63094b37391419057a9ddb4e703fe5dd759fc0e82735a1744857ddbe55dfa90d2de6e431bcba82f91bea27d2b0a3d7b74d664b10d1f426e195b8ee7d4bd737d77f24963acddcf404639561c65bd5ad47e9ce237a91c839d77c08c60e4efc26d5ec1befc6f9c28891e3caea790e9e1f082b00411b5a9d75e038016b1f186d0e21cb60614c33ff69f417f83298c18479efb1ad87a69798c5e5e200c60ea59103dba5140116b9b9998367ce353837060690e45051ce4f9355c990bc16b75bfc6a9f6955a8462cb697fec8447962a397dfaedea20cdce8d45c350906fa384dcf0d25cbc17a60b6500521e2d09c020f821578fabc56d81e1aee046c09559e17c693f09549cd92fa6555e261fb2a1f299c2df9a5a7c04535c08958abb7ca4705e9956c4d5394ea22d6e70de2400aa421570c593567c20468f543d8b7cbace77161f55dba02032032b1de8b982d6e2c5d306558457c88eecdf00c4ea216a3db44bbd2e56ca69809327d085bba90325efe9c48a9c525c0184edf680fa815097f31640dfa70bb6ee61cd6fc48216f26be757aac7fb92abde8c65b7e3b1adcdf10f03ec7371e16db748bf0e663f1916db4a2feeffae69dd1df59271fc65b37ce19cd400a745a2f9c460f978abf82dbee24ef8ad58b12ba0ffd7ae3e0e04bc6d374ae8ef8c8a349ae469e964ddf7c25c50d2fe629b2c31a617e7d77d4373f5a2b8ddcc66bc83cc54d8479dae153ab6d6f7f22c430b1798dee40438a64da236f180c12102d24e89135fbbaa7964db0c218dc7f30ed9e470ac0d25dc0968812bf79e51cbcd9dfb76a1c0f09f66c7fb9534e1354821aa7be6b6620002d20cbc420a0212e1da296c19df6d3c6acfeb90d8b3088e240771b63a84ad3191e7e45f8bd5cfc0841f05edb174b3186378595b013c34fd3de67eaf6e43f237154d30ea67d89a01c2ee759b33b7aa590f1c9622e71e08bcbf8884adb5d613f2812ed06d0ae00d88ddba3ab433eb3f8a59a471ef93c05bdfa6713b60eb4a82bc59b0da41120b5b3d597a0aaab71d39c2ee8455407bf25c4a468f67ce0af71c809692b4e7fc82442b11db0d7d04f3dffaf93014737dec2bd2149d1da3eaca422734dc32c18447b49412c5b07dcab1ad93df24a4333a447f7101be4533596557032a174b140672adfc42c5e25c668da87f4c77a0476b4f88595fa3fb750489f7ea3e136fec26cc87584fa60f61a6f11b4891541b9e6481aed999e2cb77cacc4d78d64e950f190bc3c6fb9b3eb22068232546ad0ae2e694181ae35264a54a43a358105a142b7345e7281842c1045360b0ef924eefc8ae0dc10f0e6a45be232efd3fa93fb6fe50cbc809db337b9f3a8afed30ab3767af38a5faf608a49890c2d6e8258ed6e86f47d8420bef1228f0cff65f18f143cf68c2541a973b6838c9cd883aac22855ca373ee651ece071e9997ffb5665aeb0f2a4b927b5e2dfcb8242b769cfb05ea277ac00896c071780a03457570ddf069722051d25389ee15dffc9fd8d12fa2768c477beb8f2a4db5a3ffaf1ea4d690f597c12c683ded8346a3366f557363b71e9eaaba2be6c82ebc27baffaacfd55e9151c4593ccda245566a74310da2de2c325d542ebb751db0e48b345f21ef95c5e5fb4d30341fdac41db2dc4e709d8541750a33160cce6ed39c43d0a512971c11369ccbf0807e3c1fb6952c2a116a88fd8545fac160d109cab5b5ac9692be36dfa9e830280196e302cad27936676850c0076d6c17f064e626d5ea17f82f786836a605c5e380a5e18fe786d2b1ce2578ef33fa254fbed361094e31a5e307a03461e9cecdac35fdd40fd0af8a8562d13f3ff299ccd0be60589e60c6b9e1857ed543ec3f9277b9488dd79a37aaea2fa0977280fe9b476925e855ee936ebd42d079f7c498e4c1100508e766988445b6c2c32b72e06dc1ce273a0c0e9fd410ccd61155589b9a030e60ca62365563c394766e990c7f6d01ba3b947a9935dec22b45dfec485c43cb87b01924cef806fa06dffa3fa829c87dfbfe58c2ff8ddb2248f3c635befc9b63f4ac3f3a2fcf5b9c962539edfc269f1e4f916f1d9e7fc8ba2d5655300b9e1771924b29908a5928a9acee034900accd1fe08020f8405339137a45424ac0f8354308ff301c4e2a0868ac609ac638a7f98b720b6b8a4293cfc87591be3f821a962139f0538cb505893620c2fa88f32718e4b2995eaa7a68dbd1eab07c394d0e22efe8586d623d642104259e732abfcddf1822b3d902cb111cfa55968163fa63fc9fed13760a68311a2e4ba2f8bd7e99a4c7ab3566c229c4c5c65e7771a4337f59329bfd0417903b62391981259b64cfce9ce198c976f049e2a6c88d622a3747a02d4bfd0f37baf4b451d6b250f2e7f6d3ebeb7b16e651411912a86ccbfccbf37dfd1eeab3337cf74e6d059f44bb5ce3088c43a96e2f0b1c8d00b5c5c4012634a24b75ce76fd1830133c44fd4b9ea16d97df9e4f4edac19eb138e9a34e89ae2706ecf24b3d91fab815d6588e2896b6d1d3368cc5344706adf7a29bd630ea9d773aa87c8b7ffcd3b2770ffd936fbe032ef8857f8d0fcf0d6525b4712e0dc2ff5f1362207bdab411a5c50c17ddc895aaf1592316d13ce2a3af2292f0ff816aef021f286611f090dd7d998381050fa41b91d106e495710430ecb7f6a5f45d088198e5820614750ebd855e546872f060fef6bfca59ae7ef06be6ee8f36f44c42146d32ec5876d9d5f5f9b0cc0fbd267e97c25437852f02306430d0cd22891468cc4f400c63854194857ffd62b964e63241a05bc14d8f568c043927ab19317b27f3d8a896d96d5c05a9c7d94c42476699dab1bd1d97b55ee18b76a2d2e7df3e0db3b86eeff5b385a3470d23ff7ab8bfc0bb6530e7a3ce2ac4b1f9f97b492758071a64001876e2e6131864c323f09706072019110bd955187218a284b8aa8de2f7f5db8cfdb2c3ac1f4639cfe469acf9e5cb8480b87b11a16867beeec067293090050f5e51d7f15ec44244dd992449538e6ee20e1cbc84802cb69337a384fef6abfeb6fe7d97e399b834fa72f8ca8781227838056de55b7b76fb116d3fc59dd1966052f47f81e3f3de89d3760acecce4cd6aa695e92dbb9363acd89ca1a54524c316a53aed24a2171cc87f6d11d42a9ef216a0a05d75a9e91edd00e15b41da61c46e735093fcac9cb081247a8510dfc2aa0c146abb2800f621f5ba795e8bde4ba88a635434139a6483df002ae5016bee57c53e4438bc5332a1dc7b95679c329be8edd93d274ffaf827755c161dd120b00c054598b5a091158e131675a81632f6f8934bd15c5c88aa2c7caecb15b94efa91bc0b0ea9ffe430696a92217583a34a9f109c6caa843408fe0d63f191f7dd5733e1b03c43428afe7ecc330347394e8104785ea23b3c38ecf470e0cbbda408c5cd5d02ebee3430096db6e2b18ecf09aeb3369caa4d93f8996d179c2374872e984117a1fb4d59c4a6ea966daebea44ba9bf71cab5faea09dda8d4057be5bec3b87c823933124d26cc1460d5f0b7624cd2a29fee5525b5c68cc1425a3b3f2bd07d1a52a24b89024a68d839c0ddbb3df9a699e86a8c86e4338da04d488e09d2d1230bf9e3589d2abc9460f1729d8047fe4afd0dcbdf8d549625a6e2fd4ade475b5e3ab49d4f7aee6ea031934e017304f81569f79c6c37d682f4a9d08afaaddbe208d06555ef97ebf6cc15d8a5f4198f561b13b1b0cc4eea4a1e372dc49ad672559827b2e24c2f671cb38f88a18437833cf943bde4cc560cb4a96088ce5ad35357e895a532df9ddceb91f3d4b4e21700278495d43ef0bcd036da9b126d27b802abb52fe55199517771505bc1736663ba8dad230d46a7f13226df813927215b280c3c970095050130553698ccb1c6b200ad1636875c79757f4edf0f2b667f9f60b4c8dbbe02d13bb829acdd0d5d577239142f4800a161102870d0636cf4d157b0ae4041947aac7a2532b13346f9e08b06194d244f8f19465c24784e7861d515bf45edd7b1ebb8031ea0adc60d6e5261c53a9265330ffff51331faa14f2788764b2b439e1087900e6e0b95a926cb49e43de4c26c528a7dec459428d663a8a9c62f6bae3da345354b9c2639e3672fa1ef5da9e45b42fbe37131dddde3e059ea9cdf4b816b86fae7e309d807fdd19b064b6681accf0dc90406e8e9ae7301be4a3e9df19ea405549c7611c6f4bc2b48d8d3e6194eddda78433cce2ef30da62f741ab1138580958cb95d727c90deaf68486029190638295852338448bd0061613604b7be0de1d3a4aba508ead5e42dffe84e876e5c5c43e7b389c2f794e2a4371646d9ce2ae9870d047ff0c7c187ed2ebb7cd74b5e7c5b95450a90144e4df2a296616984ebbeff52d5c4634adaaa5bb8f540811d3dba8ec9d4ec93c14764d04cb24ddfa38aaf907fbe42adacd889bb880b39390ee645cee3449ff3ee69c48ffb86a224bbbebcbfec483c0d8e6f327759141035a2305b733f259832d432bf92d4092337d856f6f795749397358312948d37bdcd27208a47b88cc66896f9ae623f65d7b5ea31ae4fe05614111c2d84675f9ae3c57be592fe675bd0af8bca00b8b2ff05241917c54990eb6ed1c9576f50dc697cd7f5cd0b9d70a535a4352269748aad910015104cf708a5ac403ccaf0b7f465aeedd15f395965e8404a695733c090c3f2267171b3f4c4a277431fa275ec4d3eb1bfb2b27871474ed165f601074441846a099314ea3c7890fc649276314ba5b1e6081ce04be7b35f6bca652ff16ffd1fa44f3f24a0454c6f6834807502df4530cd7cf898766fc8db466e85982ab49cf13fde497c479c6c2f6da88143780f19569d68e4c90d4e123b176c66b54ecbd430dc29f5a33b1033c983a99db9b41cd8c864c5d70e2c279a2c9258440ce5e79d7072bfa5afce8a39e2808fb9f1d3d186d4c14117ee36c9fcaf017642fd759d12f4fe931bbacb9973538144f76b8c62143de0bc332c1c724c196308cb4cb5bd2bdb4ffa67b7382b23034ff951aa06634d91f7a62ef08cf635e310cdf6a065ec9baa74d14a18bd96df9e5aab10f61cef544df4eff6c0e429b179938d641a76129036186691437731c05a39f451b33173f5f37ff1d21775b8767f1c98b2ca3ccc3331352657cf5482e6de280ccce8151546d0ec14d09c160d18a5ad3bb1230d061b610af527fcb8d5a807fad598a5f6225b1b32c9813022cbfcca2a15067d9517ee3a597730af9574a51cc291d2d6c4de15f351d48a00e7f2f6e7f5d9c2816556ccd48a6d1359007ebbfd04cabf0484485203f63c1008a7fc77a6e0f88121be7ffc97452d3f47e10a2070ac86924e7c66250dc734546d20dc82d8696b93cb35d18151dcf290a16f255f624194c32d2f205c3e6aa548bc43c356235a886d71890a0a92498d05aa7ae2ea0e62fd98f94cf87f24d97ec5cfd63b343f3e39c081d765993eab33ebf8d9442536e0c684e44f68910089c8aea7e1b0f203ef2a54c9a22ee62ede2d37af16aecd15ad50058726b98767b2f25fc31ee8be29db1af99786800027ef394c974742e43b560c837cc69e86875e1b9fd8b92d307ab45927362c8648a8d497d46987e8aaff0976d0f890915fa59902562f67d70d9cbfe6935e9c06ac5d712d035819c557bee434b6b2fe3f84e0a234bbfdb101cf35720f271e73676dbc0620e93b4324454f6fdb0664f609ae44c915ab16df9a1c363ea4d758be1055fafe45171db7f172a70a8775ca4d34af8dee31d3f9a090b92b488a69b95afc493b9ba9b60c39db1554854493c7953d3888feb80ec84f2932a961fb157286d0544535bb8b8754641966bb72f300cd5ff521ccd86ecc9e77fecc079dd0ad5ab311a186e995d47aa11aa346b2064203f2d9bc997cde29abe30b090a5c13106a65d8ce5be3fdc3f310155e6d2a5d1a9c81b92753c1847bdeae869795624df4e54b56fccc1295f7ab852e5a67f5b0398cf224325c8234956d14db139f479c404dbdae68c5fde9051c41940d9c6e3ae30ff54846d9cd1503679d94abd3bd34ad936a9d86b869c50f59eb1cf343944390c3b77c867de7613b82d6920b88a739bd238255b3542c8e8daf8d9befeb3552286084c9b3b1ddb044e77212823830c4d3514d95452cd393f31570edfd2ee6c2ec55206c8bdc56bade6afc743f0bf26f46969b0aacf0b670368edc95afaf8a2ca5db25d94bf9f97f4149f09c26b04caaf30ce2ae5e30269bc7ea5d34ffdef8ca9d61d862b386e65f82c1c5991bc7b8dbbfc75e362b4ca7df1fa3da5ff77b6168f524a52cf090da14558f63e6da204eedf8b9a5f54cdd6eb332b63af6af2b0e88d6c7be06eabb626d8a757c3d98e67c0b416079925dc9e1826f093c931a05a837a38f6515dd0ce6859012fa1e9c27b803fb91e6c380fd8eef4d371ada3f45a9fd3260bd336ebefb4d72611b8e2d8efe17b6fe0438e84798804fe05f336d8275bb66e31b4276e0cffebe26ee34ebc8cd2ba6c86ea4cd59141b3c7e3c6d6420554c6dcc318950e42e92671660f1f9dc45b4b3acfadeed19272913ce3ba3a6197d3cb8290c4449fc646bdea41d46d12e357e387a56cffa69ec00e65212bcbf0fe948bef0298b5ff28e5f683382f8a9b62e87ad71182879fd0add0a36d7e2653a07c4bbccdf485db10c465363e3dde67248db2c2def45c616689b9be4223f837f83d2a6973ba16c328e223422c3f5f0d87b5fe045af63f1d19b071a0e6952c5b256bbb3b82148f8422459eb0d07de963b15fc730f76fa99e600ddad820fcc9a06f62dd3148a442e8ce803ab334bac4e85f386a452f4e047aa1d62cd1fab22bb265820b6fb5393f49eee87415b454e63964fa029c79c3ef90bbd29a0d87e434ae0276bf2932d1190cfead55bde5c859ceddf6988a66fa1c0a54f87f1139d618d351cb3eec08f4bfe4a5d296230e5da2d46c03acb649f0511cb1c53004702543110968120b1192429e9a342aff578a77e6f74937ee78a6159acf0d7bf6730f27fb509d2bdf5e4d7d6dbe6badef65fc3161aea383f82270a0f61a091e883ab0fedbe5ad11300c2a8d5a532e320b42e215506653ed81e7b12e8c7b6d564550fb5d57245e43da715894a1b4686cec5ac6f8b48f1bebe2acc16b14e7be529095146f74324d02216072f1b9354c68f31c9dc028a00ffa98f7431c254a78f403feda51f9e61668a6ff5800b3f2072e3946765d2f7e42fac539049aae70af81b63ce0164e928107d92d0d237472e242b193b3b7de8341fb67c4823c1a1c1a25dc4180c14737141a7ff677af3cb3076b132a823ac6e154f70feff21edfd32fa739857365473bdc7e44cd79ba6d04d89efb3c645cc70fdec9c012a0405c9b7574d8b385d14abb41102bf72a06e2399d7f13b89fc1043ba5b0e846b19668742d2a328bc3941d915959cee160e34b8ad77e45ae173dc34f2caa3ef9dfeaaabf0032c17501fe9ffe0cebb2669b00a690af9cdaab642427c52e8901789a305c87877c83e37dd5924fda7de8dfb90ebf589b71545d079e6456168fc9616a4dd370271ca7c2599091dcf79b9437c08b68334c01042e82bbdc2da82dcd50d414219fca7ab7b1625ba6d46bad682e2abb5aa6189b0a29c17f04865d954ef218886ce1836b1191bb1193b9e0a4cef67cd3058664f787c448fba214b2be5500e9af2c585bdefd210ded80cdb1c7247172e1e74bfe81dd4a7c58941ee9b82b895e66c11681cb999977e41b9d5e21b9bc9722d0aa37ddc7be4a5f12bb42061672789dad278706c68dbb83c09df41a130d083ac613e595c1e995b479df0a0201a4221a37b524e2053c6e0c4b6426d2c498e031f5958f343bcc245e7dedee3dcbed1a1f4c693adc26a69d1403128f5e947a434dbf34be2148940a9987d2bbaa003833604b099f4e43fe010a6c9be7559916ffa011839f5b588ca1542f8793673257750627ee6348ae030ced13182a768d994f084fb6fdb5c0fad1311d5b1620132ce8df5a6e7d905916486589d1bb87a44aa9058a80712d25592c082b6c5f0acdbc095cdb2829fb8b1295d089c24018cadd45028030b6630bc8c2f5dcf0169f9d6ead4bace4178116ef5da21f5918f31c6f67be974034cdab5aa446450a361afdfd8cb884b74a3c91aa9189603f0955d735b9af5275d9a66a575b9d93c7eab86076e9fad85b70bbaf61f96bbfc5d1bf1f7697ced5ddbb4d0a37e5eac1f7c635b6f59f3416dd064a641c6e5a1f881a8e0b9988538fc488ce2cc0b1019fdd13b73accee6e561c0e5176f6147cf0c936792f193134d662023a2bbc15cab72a148f92b8c50ac3cf4721cba9a11c216b6eca8a6b106e293db871e5b1860a0ec25a16ad93a27e50b8fd5bbb34c9c54c3bb7091abe34c06f68ceaed5ed973715f45c78f7159ec0b0dde4b0539c79deaa9cdb7fc01769de8fb6a9b48c204466adfb19438dd4b573443573f3786985e8f3b4960fb3d38ecfe3d79a345fb974ea8806d925ef1df66c048afa302d82e9b91559b5083579774495aa0ea588c879024d0123c2277f098b875b651fe2bee711d13c45b4d963b8c5f547d7224ab6a9728a4bb9ee2021f325f5cc460ff6ea4b4a3db0d1bbecb63c79a37a2f2ffd332a9907897ae0f7ee4a58e1c664e7934b179e8db8e08a3f57fda9835da5b5570ac9d1a448347b8dd86b599c7c48ac9130324f98494eb9dcc29135f4a550cd67182d28e58bd222054178185ac2f9440e202b1f862fd4bed2b21d28685b41aaf302d1aaa572b68cbe8cbe59231b6713b3c586c71991d3d1423921f245f627bae7659906205aea444a6d5c7339a72de63c74be0e15d32dfb18cdf1a0517a56508802f549b2f7f0132c0da2c221991dc4856d3bf573ce9e34ed74ea003db0119772dc32f55867ba719492e9da11a37bef41bdb84b50a8e7607dc252a9012781c39ded36a758e5a652a799545ed6f7f5332e175bd6d3356012d90abd31554eac414864b20574d37ab1100492cfa99a78437f0a128706c8e36761ad82ac749e5ea69cd23211cb23dc0cac0645f69d488082c380027f7478db48e1b84f5ca198da9dfb5c5119884743138af48b418fa622f7de6451881e25440291340d1b504dd68964fbef5d0819c798c67f046a929c96a614fcc3cd2611552e4d018236d0322b029921f4945a81691d543a6d0d1d67866135dafe6c838b43f34633e5653b82ea968e48b0a949ad15b7a16028fc60893fe015b69fed8d3f11ff481f0f29ba4c0f30c70fb0f6d2a6771e23fc69150753e8f9a7ecd6a9e2205fef435ac4072643337341d475a18911c05476b23879297300d22684635ae02a740850d30c2b8a304f47bdf4fad7b29274105c505f256b59e1b2ceaa1f31d54b0ff6f3e1ad190ead9b7c502ee021fb9107a22dd53f5ce9411d059ac7b67cc96a243c409de529e6bba23199ce72a2abff6cfc9e31aa00bd2b6026037ae8d6d6875d6a603e8514a911b0d6213fef4b8df42146ebe4b81cbfb5eec163286f64b533d46b95b8726acbc9569558a0540a636462fb30d70d064caa8110da02d3942aa5ae58e82a36cafb6a6541f7b2f04b05174c816a69db68fb35cc2b0523ea6875e7923b873b4bf5b8fb8d82f7e4d4536afcc59e24e804cb36dcbe4b4c6d204a846980316055672c30084d67ed7b5a81adc1309d94f72d502f9f8007c3564070c89126d75c45a75b81f2bbd1db50b050b0a1f42ac42cd359bd95de7b8153436743ad421566a5c9470e5af5023b62576c0350e5eafb0cc4a1c1dc5ce4324ce341f56063a4d2a6480bb019a913667d9b94254df6b80d9dc78d0f5a22f34943eadcb7d0646c5233fcd5bd5b1ec456ce4c87585ae97328aaadb58a5980442a9549560c0fa68b0027da7e53ea357a8f4b74a16013f4b3b31c5fdd2140f49c65030a9185a2cc0065d0b4caa0acc2f9061ea6e5e93e5902f4cd4f87c796e1f94df6f2d266c5482688c35c35596b1b59bd0b16d4a283498e507bcef55c71414be8daaa13bee951db957fb0971ba06e00bdf9dae52c2152f1c637856aedb3a588566f6534844cc27e28a4e7983890310d45a0db77ce843cf6cdea4e4308affb5ea0df025402ff5a680b6fdb63bf5c6ae792da780c880d8cd9d118a980f2a82d98089ac8de00c5e5ac1de99a0afa85e78a73a9afd45b0b44875e086b1edf84f6be0e47078358337aef765921aeac6870525e49628cbf683ea41de20fc43be90a73d7d07ee7228c26e44ec43ebdbd241110adbe780e1dd583994b37799cf8d2116f56552f31aaa3eb5574a0c6fc315dca0851273869d1e4a2a8adc5d7494daafdc3409f2dc57a0e7537ff1c38e1cdb9743390c08db39d68ea5d450af3314d21cec689ecff62c6d9905","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
