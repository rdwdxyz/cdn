<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4f094cdb828ec39ff369ae6276394e1c80cf95689158e984085f45d70f3a83bb4ec51f254c8da473a0d1ebb1cd2e17910bf42fd50f199fed65f6e8c709a08d36f48868f9177dbb74e6112b5bbdfb936ee9d8ca079905b48be080530cc1d42f3ee71fda710e722667412b0af5fba978e2c8ff12b152274b5bc0a31dbfe253172000e9be4cf7a9060ad8bac41a47abc47d479d5d1cae8076583f8c61b64677ff7c06fe59d603075d40e929fa573fe6bdd8bec924a4bf92cc65a6b6f954c9389cdba825ac00dbd7535819eb6ba3c87f786bc94b32182987a0e691477d217417dbc31f4e99425051e81d9d22c50d23cac6432c1aebd21b7333f215d0933356c5cd7e9dbef49f22348fba2807089affa880e06516853a26d0bc5b9bfc3d23990ebf4d67201eb22cb977323fa6e3467968504f10b9f24252a2aed35e1e37e4467992dd680740099c68df72cd9711c35fa726ae93519ca3afae82abc788415d507d30c7d4650e5f57f67094ff1e64406a1417a438a19021500eb19d94258b21ea910e4723513982f6191736d8c2a4b8abd65aefccd9f3dd14d46c3b98dfd9e8a713af1f3514e565769f359c2f6f3e1835b186204a7483876aac0c7506fd289605d416fd5225a4eb7291660974c35112f88125c7cfb14506e3c1ca23ceb1c943af64b17def065f0153b437c1907895bab16ae1e0672f6b6b83dd80a6d4f97e0e59d8aa41a3269289c75a2694cb522062d6f7103027645e47660c8234227302cd8fdc807c003b29b58e6defd0b4ffe7807bf1c31d66d6bb2d3763650b4548e89f53e7346c0ca31280d7ce91bdbe641abcd9218c98c64bab8dbb4167afb40cb9fce7d4c3010b1ccdf342abfc477b1ca6b0e84ca4ca47b002460e54934e460bb2bf8137e654dd2b0952435eed1aa0f0da8a8eabd1f2b643a60fe4c6414abb8fba92906019ed720134f39479a3647640cffdcb889c4901a032ae1c4e19eac5378754df3689facc2b2bb7c2463d86de54b6b915e87bcc4b5ce777a3c8cba4c8765e7154498f2400ad4c6f3150070d052ea1640b220281d1e4dffc857a56333526d2abdaa8bf6d4e761816ee310f6be8742c6a602ac80910e300ca06e2972982bc1df8f9cce28bb78b2c99c697a75468ec758109ba3440e2c887c9d32b6d24ae866c42ec8d09d3f6c250595abe3809e8b755e8d932ad983831df7d26507d4123986b6ba0413306b75705c10ba0dc1991d273af4cffbd2cfe68096d69afa03aef118cce2a43effbfd8f4368ce20defa33e2f623b0edcbe9262a251d92df8f85a10c65d7eed41e47c296d4009dfe074247ee320aea08e1ce6fbd12820331b7b2293331597a1c209e67a88cb7687f8602a4c89a603dc498cdf4d15ba117ed525bcfa4c57b805345e0a3052ff459a5ff5087c53e4598c3d62938770716aaeaea1b76bb380632faaf6e150375457f8f4b179255265d0fb1271d9b5515b8f5fe759747a848059a26891ed4b28bc8403cdbdb6b7dcac83882557dc358aa5c7e309fbe12cd3fc2b5f00666c33c72d4d380082248f153f8a7aee3ff740067311deb67ac0d0f488d2c6c59b4192d0eca88da537c9d1a9dca50135038f6cc14751cee8fc4e1d7376fcce3d162e73e4a772303c4bb0d5b5db750864a0ba50adf56d6936212fc397dd90c959b622bfa9742790ac9bcf5225c2e12dc8f8894ad9f88ae251cb9ff7b3f020ae2e370c46ea69264e30137874d314cdf7b1c812de458aad7c3e03fbce0491c5c9031d95ff37e704b467b99f600a1b7b26f39b0777719ace1459b8c88a9ad652048842deed7ed3d6eb0551566ac1e092b386456d27566519d2bb47b36fa0aeb188bdac6cac33f5d8eddb1fe25c4959c5db92e763800ee1deb1e73c8239feebdcbdace870fd5e63aabdd78c5051686604b82f72b93d2bfe03d9c222886228a270139645e0561af2efe3b8a84e66c04bdcc3c997fef13499aa3d71ac48627e09d1341fdc9c7d7e74800f1c9417a26a770435aa9dec30f5a308cc72d91e7dce9b7ab882147ec6d1a9c582411dfea602ea98d9283d619b3aef9fe6764f8fbcd62763df37f4b0701a20020f62018fe755150a8216e8048f68fe325f714059539f18ccf58979e2c4b1afbd74afdbb60e4539231f654ef250a5d6034b5185b75b122a7110ac5e55d5486951bdddd4c49417c0d34936e13d0c8886783a3f2930cf2d6343d9356c21dfe4e88ef899650d8fbe0d3f6d3b12ca34a5708fbd8e8ee07952d6d71cb52e4ddbe7b84bde9a241cef42fd7d03f4f6a44ed14a6b8eb7d51e4d6c73fe50671d1903b0b7c50a7197b57b06b0d5060ca082765c3dd42e4a74ce15b5b7aa05053de66a2c8c1e14e850cb78259be30ba20b27c3ab2ae4d3ff03e25bb38e54deec2f2b197528658ad450ee3be27204de76d50a2ff3ec55fa205e27eb19103891516b6736b38e68a21a9a16a912f64ef0fe114f4f71b584755dd33360ebcd5f7f1df339121b10f11b63fb166ca1b18ed4c55bb9ad8a69a6544a304bce0ec1ef22e0191e8e77f6bd0e9dd407a0fc5dd7ea8a25bdd6676d9272ebb994869f144ec1c0cfcf310d3260d4636d48b6f550e71b50c9c8062dec7b34846f38eb1059a9570fbe67300fb0f835b0a9495a65e13b5d5ecb4593a0c205cca583a7734740be5eaad31d7358f679cbd75ac2116c12f5c108ee4d41b92d6c69c65b72f003af98dd4a7c3ab2c2a446c80fa3cfd8aadbd159b0f7e094ccb6f4f628cf3f86164c369545367679bb7a56c78c73042100c6f6fcc3fdf2e26db6248e2381714463b59547a044058a72b24da6adb0638de7aa67a898604406d928ce3b83056221bfc90e978faeab1bdc7c86f940bfc5d3a7344f626cd099b3f30fecda2dc9de0d393827ecc1d74d0e6cb9087ba38c6850430b342e84955db99013cf44e78505ab2b9fe258ef5a20cfe0026a743741d43653afec78031a82fd43da7d71cbbcc1741516fdd42e4bd2393f58812192445de0132f34d6243324682a5a5babf2f0af8df02e1127cd42b6f36cd013919b6e5ba7f1c9f5628930d22edb221ef5a993c28f1f94ff02bf6138d35785c69208acea81429ae4336bf602df8faafef84eaef015dd3920d0142a297e1fe9203ddf523295f6c56639e25fe2a4822ac846241351f90ed781d6f971e7e047db14c027740108e8b38e17143391b5a54b9c60ee23d12b05c24547226a424511fbac3d2d8430a68232669fb27d2bc8058f1b4cb4170138551635bea2b99be7d2efc89c38cd0ed5a67ca85c26d5b239f1633f55803b548b8d6fe7dbb1814134101793c4720cbc5d3698a3a08c6895c0b0492796f931c6282bf19125982cedf9fac167f258416b8158d2265274445541884b399154b69eba763643f7e03142fce83e8ca79427282e6449ee2d3db70f56b87a8a6d15711e5006d0b98e18a82b55b48190070abb6e9d7b2b4209b1f6b192a89da1b7d790878cf4c4e458c5a5a2a825d902c6323685a8cfe9f22c56575ec48482001832e4d2aa03256a8eb3101d3aac85b343c36e24030d6cdf8c9abb0126e2d3771e76319a9a0903ebaa7be3782abb89ada49e0ddc9ada9c2a81f21d55f9933ae7257bd52b7f7e521cb87a95c4ab37ff51c4bceb61e1366f2218c79095eb605c87a0c88fd3e58b1cfd18d99609ece6007799615fd8e108e8035272694055a1635698479b51a9a64a79e03400d618326f08b6877c0dfa6329322bace7d5bb76c2f31626ee92654ddf363d27fa8a94bac1827a712d5823575413239c1acc2f1c48166587783d6777f99d2c16f23adb1131c8f6973d9ccd4ca4f566833238f56e0969cbf392b677c28173febe9949218318203d9570e9234c20057dccbfdb7ccb4940895d67553d1393c1befcfd99296a3c268dd3c0970f7eb6eaa77b06b257e26d420a057f24d8df91d51a3e412302071544ac3cb9c9c133f6c234d349b8255d48b8ae6fdbb89c6f7298c49468e098accdcc96a55139ee9db5e8dde914f6d24ce126912f74e88940893a25039bfce8551b0fcd2301407dd60afc587156263c638538bf113501e384e7b4b9d27a1fc51ae34d01efa820cc79226a64e5b3b3918520fa9a344c0fde42da78c41067df62e0c4a9c89c24330990b3ca6674c3736d021e2c77b2485864f266f3c9a81bfee42a720200aa94a163a69da9695aa757334db30ccd67666448dcf4f05f21a380017280bf1e0170f6f6ccba1472b06062fe6ffa907b5f06b00d37bb11a6221c0022d3af8eb84fd05f22a71f7bfd46948a89f6c9dbbd2f5d7be9d38e8c817a87b36e46e6f333bc391edb99352c1362035485295a7beacf809796c1ddc14326ac0268a4f2847180424361b31e312e908101408a1a4e9979ebc06974fae117b01c04c0660688478c438cd76d2804054a449a19188a90344cf1ec67e1585d1cf094d28745e8ef9f9d6524ce4ca4960a6c583b61f3d7c2b0726f90169cc410f5dd38f09d6f0402e82ca565d5f9aea817ec5c5378f61ba2c056d516e73e8262ab3e2650cbdf8c75ef3c33dba260fdc8f3157281f1cdc2849a82b4f8bcc7d010bd1beb8d9c94d9cb261e5fa6131a3c72ef4b78fab4ce3b54e7ba58eefe26210341c269ef4fafb6ec19bbf59f5214b2dc0b844d3ba8d51754defeca9d2ad3a97320ac07ecfc2059617b9ff052a20962cd712bba96f36373995174fe15db313a433135c3f5702776ea7896af3bfbb27b59a1675628490d4f9313701172843e47089a7a9790effed35d066962c2a57908f516a847a035d669870c48ca17b654e9a9fff47bab7d302bacf7591dfee62dce109ede3631cc2099b552be682349ad793c66f75425d7d0f79d955c91ab579dfebc979b45e8d20baced6eb31efa578e9a555a6161803608ff83189d65c9098130e190c13f4dd000d52d386606efcb487ba1db6ff3df05bf5c338c152a74e280a292792eb1834d213d2204cbde36cbba6097e497d2d4197291205002983c3bb62a5db6cda818699be3c9e4a9ceeb7886b58b19355fe98de390cd59049c4b8a03ef65b62bc186fc044f9aa3fc7cc961e676b0da1afa8412802851d9a41c4ca97835a2b5d03edd1b48983b4c34a6bf851c6190f42ba40098a8bdab1524480b86a8cb9ccdb8b13d31c646b5b1cd61442419808fdef2957b58171087a4d24941b22bd5ad316347f87565c4b303603615df9f8d4803c54a0c17f182f8d56dc84c57281cdfdc3cbb2404cdb1bf9fdb3290201617c84cae8f6d934b241eb11b9f3674db26be3d4583e70c88fa3aa1c0a44ebfbc349c95ede4183d6fc58d2b89dc26ee14d00c064025deaefa2307f483afeb09373067568f10000770a13ebc9b184f72424cf9e8495839fbd2dcf4f3762da96cafb166e4c6f07c9940cdf17b7312f4f34cb835ea38a5913eb990067502940a447139794098b4dfa6546c8489ae2ab9bd456e67f33687e0b806a99a77875066460e7e64e3857cc9c96f077f90ffe19bd9b35ac764e7688de163b6d7df3390cd6babef25aac2ecc24b2a02521c49a3f502c1284fcf8c575c7a21f3eac20113aba03849291650f18b94444a48892a8a8409f6b41b6f3bc361eddfd74646e5033e4c50e33bdb4dfaa6033fa1e222ad6f2d1478be7c13da875be568e0f8ee1368ae6c0add9551784af8a64e91e507c72a9894b163084aa2f900a2bf28e1573388a28b656c56971c0b84bfa0be4085518e80aee91284f14635dc491fd3730b3b64293cca78cc88d0504eac180f66dba2755d941390f569ee13f3c0efcb9bf53dfe7b75c6209169d5831d2d8efd219c8fdb16e8e43fc5c67f340ab5458536dec7bd581bfdaa3cf67ee5a662d5e3eba02a35007b6b0992a0efc4b4bfc7452d71c7f247dde9aaa9866f43062001b5fccdce423fcc1853675dbf8d82a4a7e85fb9ba2d696422a9edf88c7e1ec01c8ef69bb87ca0151bde9e9d689f7bb2ae24d5f0e7d9c562687a0371fa0002455a8261e408099087c049bc331b415b848482d69f55f1d54ee3be10081327fca4efa91f84e82c40d7ffbfe221257d5eacd3ec623d048783dcf2aaf7bdf8963b309a2820ef89250183a06ce231f7da00f61e6161a22fcd370f489d659fa021db01f704cdc67441af6a488670521b094f5df98384ca00c29e5d8853a5b979d673f5640543e40450f9fbd85180f6975c4682e73d2b2cdef8fcef518980075dc064d02df9ac4122c86d5130b491b78b837560fbc5c8c9c50ba03f733dd2733042bbdd3adc777aa71b48fdc6c985e1dc956ee2ac9efbb60098fbf96ae4889813c9ebfb2999f2af29116c06f4328d57d4cf959c54a203fc6378f66f55a581baf0095d8d9d5b8d838421804b70c0570a5219a41f704f2a3ab5fc01df86059587ba6282507e74d0356f4edf6f2f539112cb47337279d4921b41b80da343c950229ce6828d534ccdb70df4bab8bbd2c3f16e4c3d58c4d2bca3981fae372710ac7947504354c6b627f0d272900e527baaf3e11af5a02a6c875bf041ca08f1765b9e1b1b671fb91c0a084f0b7f0dc91f91e1d8d390d0865a915b27205b901d58aa687432a02fb10bebddc1c8f2dde9b7f3eec0f200ac951e5d91c22707bade60cec8a40875749134b2ef646f5effc8c5f8e5b869888b1765bffe56e0e8e4e041a5ba06a4301512b0d205e796d1391718fa8942c10aeddfecfe2b247282eff48d0600608309b173e3c901117dfeb2b75f91e3fca2bc9f0fa17f5e6ae60555b91871573de05e29e90a1fd4266b9c0ff06fadb81b88c78d6df819cabfb6dfaa2e75cd7f97d65f05a4da9f2f95e80b8d3a5ef48ccaa6b420b48ad5ad68558f83b11b47993f0c9a8aa46df1d37908c895a1863b7388cf9955845f11d5dfe5c32420544ebafbab92b1bf6c822b5bb45c7711bee3fe85aff2bcea1671d2148524dbd487c74ed8f7d6fc33e96460ea144eea631e780d92a39fa8104efbf80658331acafd64886b45bf378addbd5d12888e7d83ef3f625ee384d6505168d40bf87db0ac791bb32cffd12f044624d0ad973315cb5b4dda4548509af34521985f298a29c936a87d0a6778118309e345843bc6d28afd3003971e6cfe490c65d7cdb494dfb8dcafa0988eef67f584dcce184cef8503b58c6a2c04a62038e7de0240e3c937f381a66f36ecc89046945a8828e535226bf914941a7926ea6a904680637b1aa0ef5025eb152a5a7b238e9a801f2fe1f361b03a1042bfa15767c660814bb44b2c6bbad6a4afbcc2c6748f61bbad298e9320da1f0869268ba8d308522e6813a60aab1ed0a4f1ab98614fc15457f9c36194fc1fd723d2d70e4e5a06fc7bbc352aab87115da71c12088b895576132507919b56d81112ed8d1736592ad315530305747ca748a805cec59c0135d411d4e9859bc2610d00f6ad35bd189a464639a14de391593461eca3ebc8e3e077bee4dc60c8cd2f635fa2bbc309943ca96430ac107295af34b3e7cc466d0ca59ece9472326dbcbb911b960bb61db6de908720532fe28c030f8d062b6b1975363351a67946edd6274980825c23dc93deb0cd63ccc917a71dcb82c8261482f0cb9a4c4da4030ebf50e556359cad74cd3189b36b2bbe0b9c9ec524199fa831e59c11b70a75aee555bc954847ed85eddc0ba7cc62e0a4ed58c79fadeab4df30e662a9b0bdd370c9ba89ffb47d7d158cba8e0cd83ea19357edaab64e1291a5d1f3954cd4c5f90755a678d633738e054adab531fd504d152c50e23de9def09cae65018076a30718c717a4fe903a319fe992c71f99fced6ff6172653a373e13c243aaf30bee03cf875ae62ed229e6c6bf8e9d93c452a7ffbec609b66f659368603ac7f77b741abf89d129c9d199f0edd0ace439607fdb1e190109a2d81474ffd4f96f80b29eab9840098c5fc97fe5b67e7a7cb88bc57879dda6a1629b23ad49134aaa7e8d4808d0a5ea83a88e5b7d73ca8193d60b0ae10a3f1bf57d9186cf7172cf595015cf3583e2c4167572242d637aac223a0265d9dfeb2d0f600e56957e0262d47ba6634f3ce3541f0d2f1134093a01425c969df34500f4dbd2ebc8398e14c3fdd071bcbb6f50fb02bc0e4e92eafe13ad367faca4cf64cf8b5dabab8a5a5188e652795cce09995495820a454d350c4c5c6ed23e1cba7c7b5f5b6f8013f420fcae88b1a73a9fd7d46bda2ce84ededd02696a4bf71902abdbf1a97d0abcf524fe328128535be7c6ed666984910d7e1b35cd4e7ce575d979f4d37bdf1ef17154ab3369a25f3560fdca1f02d43525f371122119144490a3e121efbc6bebd29446d96c86a50fdc6103ae70bfbb5b3345f85d1009d17dbf82284dcf417b1cf5de9967d68b37d88781c5512784eec094954f37d46b725afc58a29e12a08885d995a2ccfb36c4a715234ead0d255de6ff217d492e9ebaf2033fd5229883614bfb4f8fe778a26632be62221b7a59bb5fdf9d40220640ca2ad52e6a4d45d6d4606eb6db2218f220cfe051df876b86ea9cda2e897d45d022c5a77f488164b480679e8e8d55d98d2113e37159a78c65b12042e21a4b4cb20b97ef31f88971ed97974bcf5cc373cf3b8b98546187e048185c779baedbfe19de5db4692581e64f663ffbfd374620e7dc00e6877e4eaa4f0e49458109911fe7a12c41f4a2be73f76cf063378109327eb371b56740c5fdcf9d2d200645bb5e1bc324eacc6f3bf80bec4881cf2aad72c772ff263a7c9d16f3ee04cb137866d8a2a6cf36548eaceccdb247ca545d14990dc7bf6b9a26548738969d50d778943a5a6b9e353cac31ea6944db2f24a8702cdee3206e76896cfabda064220cb6a91acdaac3ed66482b4445b7db1a7c7ee6cac3f006ee23bb8261e7a34c6198da939a5b5ede285bc838c5214d04d9087b335fe9f072b15421a2041570a802339603dfef7feabcd19c812baf570abbdb6b0686aa83005b9b4e986071dd0191a19d252caa161dffe9cfa71ceea042b48e66b96581ba43b63605fae03ac318587012950bd27e0de032a912bf86dbe91ec2556e6d6acae2b866b35af422e05608ef92771fa83e192bb158aea7968330a6293eada4c0ab4ba7c4a9403dfc9fe1e540004299762a72b9082354c12726eaf6881782a8f5e8416524128d6f6adaf8bf10e9d7452f3d07651c76ffaead0bdeb32bb5651ff4b558468ca9f63506c4742b0d8a50b73faba443f91f6c3d55cd5514d8c966d89788ff3bba8dc079e78e09005f3dc821bbfab8832a1a3f9ee91bc9a8483f8dff244eb527a453f36d440b194d8eb3d54bdf8e60fb458cc949fe55ec01d850649cfa7c82f334de46433a399cf1eaba4f28521d6237e2570db85b3b50b8bd8f89df2c448f935ab9217597f930b5730de3a59e38deaf80999b61f21c0493077cb391bf08d93bdd8ea47e72a0a03695fedf76503f2498e9a4cfa64ffa4cd01bf1fe32616d5faa323f9aeacf8e8bcfe249ebe6bd07ad32452a958e74e88644646ac9f56c96babe380bda9ecc853e69c628f6b557bbe2a602831e98f2e254b08315fe302a0cdaf6511cb064e9f984ce8b78597f76bd24f998d9b4c701c2354dff0f95602b9d53fc9042504f20c3035a5e1ff562ca9ad79052c3d4bc8e0602c9b0980b90e4f178b4795eb4c73ba91ab2490870616fae5d1d01975ccec74034bbd7d02a3504522dea6273ed5ee5bcf9602da83290a9ee31d6dcefc3a48607a8138af7185d800bfc52dac83dc53b10f10dab3ce8c383f5a9ed19569a83e6c355750387253a11038dcb72cd8ceb6a3c37deb7d6225100bf85b03decfee88744263b96ea1929c0e212817e7c92b0b90433771fcf0804752c7f58ca335369b436b57a35946355cd32533abddd5178c4062fa9a47486cd93dece40d4224d0b590da689889ef2144c52626116a28fdd2f99cc9eb2fb1da42aca7cd3ee651879b560991ef7bf71aada2b5c460de4ec33f83c600f042785899feb66c4fadedd587ee882fd6c5cddb6786b74a972a3ca773efae10b25bc8d65870dc65601a4a8556015efbe95eefe03e280c9ef00d307ab8dad6e1c91b0dbd730be35ba639260ec775f5473916f39f4e2168273d08984eccec1ea87a228505f814517d0be3831364bec2ca83a0983696ba1b7e9401f2d6b5d6969f7578ba7958b15cb89a9fcba2a3c7a5362c067f0139c163a151d8c8f4f528c3c6595a5b535f1bdaf782859bb96c5af731aca557fe955656657aa72196f540d5255098531b8cf9b03e538a1a1b1f45d72e346cca55c61bc7ec6f02df9159d6bea8693f000b64a3ea8c0b5303c2f9087513098a31fc9f2fe3c755e61cb965efd0afe79110cfa51406d5e7e9b6387c9cc32d5306f229c7fd16a5a6bf8d24f2df4c6921868f20e5a40e2602dfb4b74c6dc2cd657c6551fcb58be9bfa42201261d2d52404956e34a0ba3b3a38bb6dfe457aa5622c3ff1b5b64daa366a4e8605e5e6066d9ea535e2f1c0763689e6e2cdba7587d4465e9a601c5b37fa3007cc72dd5cca75e0c341b193fa595f2a1e97fa238cb8e86965f6eb535b80973bbc3b97ea22742744337f47097e00c688c1b6031f817dcd783ccddfd4536e33957dd36161873405ba980893cde5dcd5c2ed6d907a482950aa15f86e0e932abf7efc143e2c00492c5dbe50d0ac31c37eacfb08480592a0097726f248a1c2a4b245f005aece898a2c234f0cd1462e71d2471c7a76833761ccb2852a3c43512b794ff31f9ea5a336415af4ed9330939a189a16da1b71a452e185656f353d455d9a69f320585984223b35af52311edb72f245ada905f642af3a6e4ff2237b13fbec49a820a34f3fd49528effb16f13fa4a9c68009c8b0de9f79b1a51dcd4e6a1ff3fc9f629a7ef227a0283667003b343fe266ad12f5dab166b1758b4cd25f785408232d9a16122c958f6eeb4e150a962b029dc14d6be19a7975fd3fc38abd9e5567fc9ebac14e858c25fc83fefa62406e6c3b2d610f7e04d417ba203918963ede2fd4e90744bca46fc13078fa57839bf1bf6e5417d5f2f68110b681d4972dc032806a11c91cbf8890db0c5b4c9f43e15aa9c711cf0a5bdcf285b8f62718d7b56ad9767428d80fb5c5edf32127d8cf9d058be0ff7eca7664bd9dfe8d9ae3dd98bc72e2b8003f0dceea4459ff741c59640566b587bece582d32cff5cb71f006e98c5fae1a973f555f78f65ead0d5d873b0938e35b66561fc1429cc2beb73b6c10ea75cde82be5cd66f645ca70dec05cd1ee4151bc8d07d8aff8d2b4529eae1e29411f9802b00926d0f758741b40cc75ca4fa7d42a101b5aa46d4fc90b7f634055b6f986e5485fb45a131e3c03a4b8275d7134efad1b34a8b574601a0d3e61b528de0833da6d0d2bc4f9e1cdbc23a2d7ee9a08e85efc73553a77403c002694695026b5a4be38402154ed899aad5d536026139aa5eea18a484795f6087e3902487d4e546db7ab644f99110d760d3e5013bbc6b6d8d44d9f35668de445ac0fc4e0baf6a7a13827ff279fa65ed7b74c944bc42ab73d128d689473981062f31a5f658546fe08842ccf173c2fbaeb2267d3f1262919c03a807b9877f3ba4db076497c11fbd5b81d51fc9c6926996482bcf46d41fcf64105afd0c3aee404a4c543c112dde937c5e5ee0230026eeec9b21cbc09c0e6a8e41a8b8d94f7181db40d78b8d021881467800bd8e0cc9003f6675e6f334d967b395372b1666214e77dd88677f73a20d44150581bd5a605e916bdd4208dd06a6a2ed1d3211fbebf2d0a16db9d328e460220e21c6258ec4fe7e9e4276e0709b1eb32de100e239c61d007e0d28e5042468f496622ac926fa5db75df6db44467618d346f72b994a2357a939eceb927220eacf46a94b2a7bac48366a9818c67222821c633c743e90a8a664a75a7c994aae86b9d27b9de453062916bb4816e4792cfaa06c234d538e9f9216bd9d87e48b49370fdd8556982f0eac37315493bfecf2dabe62ea912d18aa8b4287b96c3cd331ccf1b4ed9255e869c0bb1bc63753c8938ac6d1dbc4cd94cb24b4e9651b6e5118c462518ecd168a03512e23920717555985639f6f9c97ada8887a88f7cce94bbb483fe1287d3805871391d141bd79c6d23b3ff5b1a22da95379db92c7d840ed779ee6f8c8033e0f6e3a6abc2289389772592c04f91ea3e4e9613232643f2d4f675a5184de14e14f89a33806785994231b85cd4069b3f6d63266ef0f2b932d08747ed710619736b33cf364b76faf4a07b06838d1c7e333bc96573becffd16c230eb2f5311ee74d0b2bf570c46113aaee124305faefeb2b511d402f1eb8a235c94e29075ae2c7343bcfde86272db450d49595bbb29072ba408adf29e3a088c2f2d72ae4c91986ea1aa3ce8e23e1cdd83d09d5d6209d46c111233bad21d03da6b7f9421c798b2e4ba32a8a1e8ba67281fc3f790bd321a2680c13c3d43210cb6eb26e3ae9d1078f8af693ce37216aa774b484b1cfcc295bad0398e2a857d168eef052d110a939487949e891abcdd45f2313bde0b262f610c3141332ca45d6e0e9a50d7f5c3ee78fce7ca36e36f446970e7f76faa7754198b9f2592c688453fa9720aa4b0dd8de767b5a4f7e996512219aefc4301d6a852a36bcb8bcb6aea6f3182acd2678de2453025805bdf473c6dda2dcc2f3f7ce1dbb87bfb4c5b60881821d6f1996c67947e350210175a4674d409eb7b9f4985b3c38c4af0afcc219d7c8f8b38bfd1a14edc013878083f12c9e33b51f93a0eb9eaed51b1092b380cde019e51b0b7e9092a566958534b2c6a869acc6872b601384e5d1ada3b7a04264f887938ac07423c5bd7eac2256c9d029b09fb7e43114a5b1297c113e7ec9c0a40bedb651f4727312e1e3e0c8dd5ff6a587e75be093aac9d8d45c507ce9c50742bd9217622f963a82a07f4d9e8eeaa803703c44700afe627326049a0675d784773cef0a03213cc12f2cf3c312ea465c4d1d98907ed381693bdd5e3e8c59873fe1ba39b83090ef99df22f8f8f4e0cef43ea9d03d10de2b599565259d3a7e8348b04725e7cbf82763288a64cc6d9a6cdf2ffd3e9c8f3aca87036ca30b2c66da669aa89e21b9c6e1949401abe2a62f80f678d8a16c792cfb5efb4afb200a2059c622147e2a6923133b393fec88bf38ecdaf443a3729a78f0c47ba655a0bb6a852ec67e9af559a1a8b10978a46eb50ddf0213e7bef808202da12a7249a327706ac4de8d58640ed0c95f29f61490fff35fe4021200dc2f79ba7ff1016d934de23e4989612ada2909c177d38ec2f334770696557700400ababdf34c8afd32b6e5363b4e32a907457dd282e377b13a72674f63fd680b4de7176215deecc9607f2f6a4659484f8283fea63e3b931d28917eee4345ce212591cbbb04664aae3c2716274f75882de653b9d7ebd812db1b09886f8651c54b0f5033128d242ebdb53537ba717bb6247c0aa7dbe97de8194028a8f58f5c69f70e2b1dca8714a3b606ff286443f7fc5592a3017c203d1b71d4f1d2da982a8fab0b01429198fdde12e204d98afe6be059985fcbeaf2181aa7bddcf27ec7c03eb8c36607ea9faf6488f6c4040b30ce5911789844de672789e4a7631c14cd2a6560aaa3bc28add20a15bd63bd1ea6f35bf344e101ce3a85387786d10415846ba94c328804a105ce6110b14479f08ed0583e265820961f26129cb266c339eb8204ad28c62f581685c06fc980c644005d1872930880373aee4b9d4a7237c2c2dfed67151a3ff985aad5906edd886b04b8855d0317a0dca651f9aabd229c2bb0770fd0d962f7a08ac90b8af574cbc7251240494bd64067703d4f6817be8df61c637f92c97b731b9b399939308a8cf85cf76ca1f442f3b51410e21f1849d930547d685e83d3a1b6e260290a461b52277319c9c12925b4fe9c06d3bd0e7ea42beff1ed5f9a6248b2352db7c798fb8a2e28b61673922a40a954755bb471a66780812426210a21b0ae6ef5db5f75466af8ce05760cdd2e916586157a3bcf311478658ff1779a9b2360376e33192c5477b7010f6fc75eea1c155ddb01578d53d429db98a663490897d1065c55bbad060cc332bd0e357c2e174dfd8df87b8b663063d973d2e2a4dcd38fd512a0ec4a5b92fe07784c2197da47ca43dc5276d9baf25c22ee8b54291a2a35add6fcf8f6b7390582760645a2ea5cad0f0c5fccbd8d9b959cda8e25d421e4eff0bc4d1b10bf4b73f10627c3f0b78b24fbe6fbfc6e2047f8a3684398a1ff9f1a42f7674aa0e62097a91d0d27e7dcecf9f63e4f777972715dd473a8384a7df0ff805caa93cccf3d824226e15855078200116e68e5be0de7b2777a6496b331e782bf7d42260c2f3200c677ca225b0b1354fcd4161c618025bcdb5064fc8a37c6892c9abc5d4616fa6904a297621c81ac947bf45927b0b0701538a3aa05d831be071abd2d726021c73b18e5e430d97fdf8e0961950c51903d4bbda15894ae433a45d2c95e6e0e0c9b075ee4f27323060a4adc69bade49dadb883e8d486c4e10871bb24464360de9f980587742795273139f65917db8d47cf1df0bd395c8f4766d27c2d8f9982045eea68700f48994d41744edd08500cc452e2b815f9945ea75b07393708e85461c9dfaf53891f89ab233b308b39b1e0583a088c87e7b9c67d79173d1786cdf841b80f41943772b06e23727c60995bafaf4b07b9840709975e2cab3bc0acce9730062a457b6f4d42538bd5054697a5f3f5556fd1921b928e70e04ca158805c3fbd9a433de04e7db1f926bb0232f00a5696f33a585f40245ddfad22a568d01674ceba74175bd50da2b9a20bb21462caecafb035bc740d159d52e82df6bc0502b844c1049b9bc1a92b6ba74d48ad4eb1927b22e0be53643a936f44b1593926c7abc63c936f4b0a51f42ea67c9e334d257ec2f5103f556f1e937039f45a5765bc2761f054009e38017abd226adb9610c8a0c9d692068f68a1e9e7cb85992392e1225c061df135236b6bc27742ee2ca2f2e7ad26b50c19e16573e4df4e628a8b3d41c7065680520aece7653d162dbe54c846295b1e903b1ffdde3b7fb6d1bd53caded66d49beafbba1507e728281887c5f5e36342172bbff776bce1705663bd341fba4c9840ecedbeaf389d6140a3a7d400047e5a563f769c0bba94076f9a00cc84ab0ef6a1310025be67e716fecbbf2a9c294e9dfc9d00f5dac0a077ee531e0ce92505336195c8ab7ebe7c021a04b2f1b23495d847e26cff51dcb4188f0aa9b8509c8176ffc1a219ff9c7ea63dfdc2d49f5a407638d54d58c6122c168d62a486e4168c31e6965a498d380ac855036fb69fff2af0d10ddfc47b4af4cf2efa63ceb65b7328f07ff7366bca4ab101e33a2696c75e7a41cdef0add36ca06af36f74388ebb2e33e7097478cf67aed195ba6db77b3f882886a6dc3b6690f101efc3b4163b9bb675902d338bdd873f57a4169733ff80a4ca0ba97373e0bfb3d45e12b54332a98ecfa15761168fdbda0e563a1df904416b86f267b092648f8f7507324ceab3ad655664f58a31f32b53d35b11965cbce15a97a0fddd252662e07ab964b43d22b96ece3d985c4178cdaca80464ccdfa8e0aa306bc6222c34a007ea121fb041b5bb3af8bd2f6b567eb0160c3cdb329a05afb71fa519756c4b8e2f8fe47904565c4ad4c79f132012fa1b78b3b4873854ee45e259f956f2572f2f4c5ded81bf54210fc4d9dda6065f79d0347a48875a4e3dcbcab5fbde72b1fef5dd6cad52771e4ead6fbb32841ae86a11ae69c416964383b65b9510f767f2cb8613dc145a3494aac472ffe13ceeedf8a78a33025cad596e6dda4d2e98e2d08284a56365b8ae1f798b08f4feaa22eb9483e49e78471154ecaf7dc92e97f23fe0f87bd8989c8ba002bd8d0c39e51e33c81912a3c414862999f031e938c405aa862457c4f52df97bd2d2ffe63636aff248a0610a578bfe7bc2e9d3a7c9c77d0d982ceee33ade9bc9f928d121f71ffb62c78c6976912e2a2249ae02bc2dc7cb60c57880bef7efeceb00a3333d0c0932038c1d14fe45d1e305caa779e8d58d06ef7e847dd77a2fce4344167ef9e8fcd8b6af79a12bda2815767f8ee3a8ea9ebe650bad41e321270ff7da6afb82dcbe7f24f687803f77fef912a23dc11031e100962418876994fa1078841dc8420fcb1a43f9b882822ea538e7a50a205e1dbd65ed12c20a8924d093e67a6aef96cbbd01c6d4dc133ff065c367776542d79703f60e72ea1ca51eb5cdb1abd93d98179a683ae40da177df8d2e7f6930fb9d1e8ad119a184f0c08f5f61b71b5e705858949a68773c5b72240d716d93eac94992ba1fa366b8507528d98031a11e345b5e4aa1bd945427bce2b0bc287841e89b6f0e8d761459891fcd3b5db784b7bf6b988d9f514be35f36a154192296d0e2923afe6a18dd83f91f8c9a797f635b30283672b9de2f102ea9f361c86926006a818e60d8dcb8d0e96641c80554fb7ad7913edd088ad17aa25b377ac9fdcce86810c52cdcb41253bf7e5d6989b495ad86149251ac4e76d9a2081e7f8ce4d69b0c6b972aae9344e76e3d17d2f29b9905e8905466bd93f9ea3a4ddedad0a6926a8a6fc5f6ea3e394dc0b7eb248398fb97c3b65cd36f005656a1595dbfeb4470d0bba0759a693a3a8e0fdc1ddac4166a8cffcbe5bba11822932e150e0204448a952c2857e0472127bb0afbe15c1279c4a74a96233ed19fc522e81776e589fc525523fc9834df4587bd634caa18c47396521d5fa9996efba0fa82bdd43eae8dfc11f6d83d84daadc05855d1218609eafe6e5b6baf928a3b240ca5db2f4bfa29d4c3a7cd823fb8343fc822474f1dc23395dbbde7096ab5b0d621e85537ca80cde0bc9d5b225e720742e699c320b12021d322e817c073e94117ef89e623b3f2c1f16da61d63ddb3077a91e770544cb6fd787917e91eb31e1ac52ae2b798d1e1597e48c7056a472e3062a437559504a88155bb50b004b02f77c56eee9ccd44f7d13443978a724d9268198d22ef57c2dd642501042f09b004963c572284cffc25e6852fb0dc5163740bbf38ce3eafd85870d023cea275aeb52e9c9216148791c122f7591793c8b4d4ce3d3d28fd0b9a621a89912259a6e8c7a835601822e087baf65cd3945130546356852be6930bbaeed50bde90fd56afa954da8c0642d4c52163b56e3ca017f6e0297dc7c417f85b60db0a289502e69c8e260fca3be7532de23d6421987da012c33820c5747d31a7865aa0fbbc724afd76b1d8013b79d1cc6dd9d826699512e221361a7b72c3bcb0a6bdc61f055b91c3fabdcbf130db9e8d9a7182227714a3eb00bde296c64fdd51120bdd0347ea9eee195029fb28faadc9119c4ba7c559deafb2b2bc11be9cf913074eaa5bfe30bab4f7d8b205eaac383d43cc35538ffd574c3590d33980df1ed1f65bbfd81ea74413ffe1ad2c8bd0bbf4284b7affeddc55525cea177d2a7ab6b822ead2b0753f928e8df92fa2948624b972e30ee9f7abd6bde86e383b10264d50e6113e7b570792f8e1f49e18167564304cabba9252cba8c4798d5685dc87c1c5e92d46985e48cb8cbdeeeac145cc607e03a5936a677d465d4a8140d0bf5a8212ee2ec2dc36712de4c7f7aca0232db86fec5b1fea58045d7c69a7bfff6a06db4114053fec67c9c40709b61e2f84ee69ca392ae06b573a0fa5f0be0defa3f2bc23f57eab430168b3392c943e08919f44e5c8507648bf503d5f25bb250ceb6d1272983003adc8d920935a5cb644c1012996461d069d2cc63abba2f0cd43eda9ec784ff9696248cc2a15c964d0b7a49a5dd3f664761695fea40fb5d0dd3740b86fe47b7c3c3e92f85d35f33162c9baf452768d18f4ee407abcd242624d730bb4f080d32cb33c77abafe5ba1fc259476d7fb753b32a5fe31764aade772880880e3a39e7df77495c10f9085a4474266f0574be362a4e50234a96683d9dc504007b6731af622697bd5b7a703f39a38596915e2bb51bb113cb903f64f02e9d53b416601910ce64d2762fe0f0b13c4283995bd18b95578c94c1dd73d01d164a004648657908df5ebae49b859","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
