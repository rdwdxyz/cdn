<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77696715131b2ff0457d9a21c6904815eca756269c89fd9424b336563d6438a13819d74fcd8fbfb6d6941602fcac78553c860630fe6816fd7c518e16cbef1d9705c9d8a7c5d46729fca880fb1c82704aee63200785d52f23d8b401b69bd9a75d3b69f4afa4313ffcad0c0dab71bb59869d9055d3b44333aadf40e26085fb1f4d72dcd20c309e28c4ecc10776d55072d18750d5a59b4fe31e5c07157c0a0cf66f6c1f65dd0833867e58b83547ed4be4bffe45963a16b02eb097f1ed62bd2abde86b70c68e169ddbd41506701e85dcc3378e70e41a3d319f3d62775a7236f51b50355068fed4fbab5d225dfeaf6036bc988fb1734b634ebfd5b2cf0d47078c8fab826c7a4109deaa809108d99d22e8a85f01430add42bb7ad7029b3c0df7d4e8d5153e7122e7a8f7980556816e040c597653284c3ee42645edb9d8349a844219eff2022a5650557cb6346f167a471d71f991a378228e93ea07082669ff3c60f56e030bfa38df975c615b7aa54c1ea3dd5d9cbff7a65b523826c643069d52fe15f282dae39f1a4c46c3918ea2051aeb11ad4f88b950e9ff1856259bf39c37118085a8af7b39f88105611fc37f5711adbdd53d378ec0d80bef2f75e8ed680cad507f2262458d26d492967704abc86ee4023540d894ef778c02ce8d3dcac132bf644fa062e1d98f311b817c5865f3b8e65c722c9112e0533acce01c4f0192e3d642fac7a6af47ec0559025d0ae2dc4cb46e94e82c140a822f9bccfd83f39859fc83fd618bf1fca59d03c80d448d1a7b8dbe18edd530b567c8553f5af2060ef7c785ee15d86131d510215dc254eef095d390273780ec3a82c51d538a999d300a19f7cd13abcf073efdbf10aabecae62a9ce8d58233d0e85434a510be6a0791beadb7058932da793d5d059942a8d5261457f27924c0b704a78b5ebf9d0210638b3f7861a2b69a5a54049daaac13a2f62e2afb5e7cf717941cf0a957de856418b5a462547f72450fd0a2055cdee2aff37c231dbee18270d92ce08bd4cf911742e4b51e4877465ca7d344abfeb8545a20a3d7b41c486558671d65236443ae1e09642214ab378efae34e2319f0678527538ff41ce21eec158bfe9f6bb60bb866f87367f35f83d219abd5e414346b738754b749e124e329a8120a1dbb138524f1dfc826525b565f64692456894a15eb2fff75814ccbd9ba6ae0fb78ec9030dedc2ad43438d54035814ffc785a9937f7e90af4305ec75deb086abd35a14f760285299b86e717314aaf060ddadab6e95fd4bbdb75a85bed0f6ad1cfea2b82e9ac656af7f27fac28a5b6c61baf09dea8e66df8238f92b34e830c66cf82255dd010c842fe948d419fc00e4d0f4c9b5f6ee0f43a4a838fe96c1f6f8c06a2ce0ef1ae04b93f87886457eceeaf392d90052e2f18a2015a9104ff2f347403a100a10882c8ce761b2d457a398cb8d39d6502af0926d6f6d571c55365bab3c77ce7e7f51f9022527cce7219797d921f8fe0b0ad230a338fa3e2251808935ca0be3ab7d9d01a26058e77a84dd60f6f7c92aaf7864413a5ddca462e75921340c1e18be4413e36f0c428591c37aee71b9fdd1810b1105c3dc7a7ccc4140b4a108360874833568fd74addcc52153b011854b6fcc666aa735804bddb59a6edf19b8b700756aeb0730e9ee3c8455a09f9e0549638dd685a039ed6aed502c39d22d1e9e4469c26f543dcec14b957f9fa63585958c37a38a9d510f9dd2ed7a74414e45e46f827697b57394d416d03fe82b61573203084a8ba953404e5388fe87f53cb6ec621c5863cbd81925f49d1f6cb31af7a762de50e1e9a8e3a442dda218ed50d2ab0fd9eceb939fe23b6f48cf90ee1391d8d24e52ec3170b195e671625acf379f88e4da53fc0a44932fe82dd02d92b44860cd93545582e2bbf299f6279fa50b86743c6ee182f3d814e75a7370ea3a8e36df5e6d635a5d32a3b97cb36643e71a481c0b0eaeebd612a54675d60974c178a2c76f1c495ef0b8560ac422773ef7b53c249b8eefd2460faa7bfdc160f61fcd90882391addb9c8fa28844039b9557e046c10b4ec31c791c348d07b63adc3b0a42f03b418f9681875ce87f25dbfdf7fca12858a597835f76000f44ea03835c94f46a4b2df9ed1abcddfc02156fa5bf20ad83d2307b349461003136ef964fe591f60402e42b4a2565c94013b7bdcbc60ddf29f3ae8261ad257594e7d2b3f2de25fee8eb13a451cb9964517dd054fa0a91487f73650af5368857b72f9e3ce1c4250bffd8e86631cefba15ce1e9de1bf28e08fdb9ba9e5e655180af44174f7bf3ed18c2e12975350a47057ad6edc0de133c267430a67dea926145329ba10b6c70f4a8e719f40de7114584cc5fdebd71c26dc468ff2ac6885ade95ce658fde60bab04dc4deab9cf19fddc71e3fe52d599f2fd5f7a07cf624069d90aa2f56d9c123b9c83d82cf2f9eda916e2a7d262eb0d199db547ec9a663f1a69e47915119ef697d4097f67a3fe991397ba1011b37ea60a2f1f57d1de68e8b1d3b0d5f8fd4b26c64839cbf76016344d183a3d1b2210a5ee0be51ef7a022f36c3a458d9d26e22de2dda28a28fb8dd1473c4cf8e3f1f13905f5c3d10971b4ec651d234c280aa0f0ffd954b49585505e8828433d5715737b43c200d4250caa698069ed909dad203173c7ff176e86c6e616dfb166021b6d91695fbbaa291a7ec211cdf4e55be4599934f603612a5c44752f59eee26930c2cc47026980bceb18ecb1c99dd8f3a43deda50b02271d07d6369bd9b5f7f81a465c27f4614ec0536c153a5330200c7aca0a30b8f906e2c6c30b3182ddfd014977c8dc0844f8153dad9f3028b00cb7b740c45391f891404631a0082d9982c1cbccf93275ee11d3c8bccd666308df931883a199401a68244f206148d29afbc43fe8c29d27e88e00e74bd6ee31b8bfc86aecb5479feaf985e895280aa61caf86e27bfe6f0244b0084bf9619b921b9297e64ac3e2706b2683ef0d187db3b3e97efa7853b2d98c4d541e2f432e206db3d30def7a56c47e752e11277b98627ab403ad3fcc2d9a78227f4b93f2910901ed682030c76062b66d9800174821bbf4f71dd7d296cd5470501154321f7f2ec616627d996d507159694e0f7c0434353117688ff0a895613115ec5740f1fbd3f211fb00a679de0c2d9aa9f658642a1717a114fd82a84a46543aef622c7381ecea0919d96c7000d2f5e6bce79a53a3fb91d56f4f02651481f57ff290c3efb6db2fbed3781431d150761341d468f8ff44011000b832ec48acc02400c2db7a8943aede5c6ed468e1b616c2afb4d2128c5d1659693c4da768764c70d157b508911e41c038e85ce03202b3dc65553cd446c122a60f6342db1bfff043dceebcc1f43b7a0c7ecc740f5150e5d48d8ce4cd098ff08df7f7d3a1ba865313631cfd2b820da52476f54ae2f38bc3aa2926cacfa09cf943983b1cba6d4d642fd78cff17e94e772fab0894751d0c626369407adb84640cf1ab5aaee613867ba39602228551c92619d5692d21a79b8d2e015ddfcd4efe2ad9700125d0418977b4adf710506ade310de5be50b3d9831f9559a58146ecee5c8df5be0c895f3b0ae2604693e587a376d92721aece47a14be3ef2e8ec398f82596903bbea50d69b7613e855421ab92400ee929880830daf92923e2188b5faa84632f6957f973fbb27e3b7994c78e1eee4a9d126105e9bf94570d2e796e7564dd39f94b337a7b7220a3d3c47256e383b70937f9645c55c4d67e7d3b7467ecd9efe6946f8f73491b314b2ee6b116c1e4953ad7f367ac9d54f50f8329642b9be57826dcdacb6468ceb13c71a44f88deb91598cecf27bf91fd4f54dfe6fd766a4d35f6275d6be20e8b2ca2b23a29cad69d986209599854df1dd5f8587985cf67754888a5ea4574c22156f8a090b9e9bc2a677e2d2a3fde81784f91f623773f2053755bf0030222f5f379f0b31062f1ca7634a0fb3acefda3f1ef964b9c85f6ae8c36efeb1c137f91a63cdb020517c25a7781549c3796f500f840b4b1bb2f3779a4b84585ae6a9900f960f9401be8d9e68fc3c7ce2d93455f460f1fcffe1a0930fea4738b1d56ec030f4b610d1f48b4e3bd92fea251f31b471c32a32cf2df354da0ee26ea22c99e35415dffbc715207332ec4bcb4f1ccbe92f83a48fa4c4e6e82460723249d7524535fb849b9e426785e3c1c1c535703a52ac1f2e59eb54a61258c826ebfde2eb283821b29c723700b9d83a8b62188a5ef0a890504bcf69dd2de6e43b177d8177c4ca646b4ddb019ec594e0846c6036ebfe3cb069016698bee8f651a033093f606a1a0358d25c70e7477c58d685ea3d019901b750d5876d2490086c0fe67cdb1d14c8c3113a9971d30e40d2fa64e79f3f5bd8703a276b6d481b7b774291960b32a3b81492e7b397e9b736cd264b40ec95e5e9db4c08b172ef7a0e489b5d406a64c4d7244509d3d99f7ffe514a1a72703fa5694b5f6c87f5bbed1d878ac19015de2265540580759147e6bcb3e27e6e35488a6e3f6e100bc9efbb42264e4e86dc0f8f12a095ded8ef9a9f4028d96652583e60ea7a75e241a778ab2aef3d86567eca1a8d8e8767933793f43540d5d3af379e54d15dbeeed25998e0e2f79620a0df0d4df45d5eff7a7af92e1bf40fc2757c2a94cf92df1ef816697863a9c0363e4c49b58887227774e43f64e00de5823cd1273e3dcef2d1099f919d9bf0fc1d235f0e546ab5fd13e3c3c11e31aa2cb0880eb5e28dcd476ea72ce285a1b5d110ec829d69264f4e3a6961a9db7464f1ebb51b4c887872f1a4924cf8171000b5e29b061ac2a5e3a451a6a191d211a9afbbf471950f8482756de68bdde6bd317b548e283eaea59a327b155f4fa8843e2c56b5bbca5d7fd1f2698c6e1e3a27c7a7e5a03799e2463c594c95ec95ff1c9aeac0023a29060ec201b85e0f940ba9caedd45dcf8d53703f232e2d83ee0b9e47ee53cc67dbe3d5f1e3e9d9ae2e4c6a2b1ac41959a1c464c8a9576434e28062785bc4d79b1b21854bb993d301a592e5733683066108fcb70fab170747dd3d3dfd90ab4770a0a1fad37698a7bb9f774acec1bd64615ac81bd71baa555ba22e5e2cac105713f6e4c6a5d608eafc4040d9a929da12fb8b93c8add54f64d03993746051aaac4f5f16286c06a23508fd09d90d9cf63d23be2e324a2735e71999383e0904ee4943618b5929573a8ff939faacdf3b8d491c032d37f8ad1ba0f3af3ad1a868f9fa22bf4995bf9b8ed4d5128c6439aab28d8d3e787ca3acb706082e17a4fbbbb3ce59f695397f000e549abe970a4d144f0b5ef023cbb51126f783cbff2f6271591354b4398e4220c8d447211a01956d8aa0c183d4e3027ed18d461ecdf9395eba2f7056ed7c2027f2e9194c5c56597dc2deb6fd447eb6e82da68bf1a79ed0acfbdff5e6b4f772d1a8c38c4821c1bc0381189cb5369c919912f49fdc789aaf62c5be79337373f541c8972eeb01c43cbfd0316a0d2e5146487aaac326fcaf64d680ca5fbdad75ed69ca6e3dc3fdc759e7b89260261906e7c36fea89c4b426d1dde64c64e4a6401c647402d5e935c1456ec8346a40222c244de76276966b5e4613f7fd5b61aa7a54f11ecb141a99cab591e716cb5b006aa1e31074a82498145472d06d51df048ea7dde62c98e2d4c0131fb71e6e946350cf3f672fa7c2cbb121f7a677e11be0fdefaa976d641972324c79f50b493da44b6737abe64a33f923ea96b9600f3552050fe979fa3828a4fe2bf9d52c4daed43e71ec8b1d38393d854eb7a5bd5fa39be85cc358fa77dd9ce93fd76aab9f847c993ddced1b7b5f2872a8d00137f2a0633b83a634bd6e5e0522219ebb34679a2e15f94e428180bcff9d27e6371e5a136de51be2ec5dbf7bb0d07fc2b71cfc85a1f003ed7ffa9c182e8753621767a60cb98a9ec23140aad36e1f3fa1513228d4559b80edb24a15115411a9162a495d41b76e847b8dcd2709a343e9c4145d4dcc14dcfb57eb048921fda7b0a00327f41f49441370a705cd84164d70a67432e35a9d979c887134d9838341b948f97456612581100936ec166b48ea13243dc76d6d761f2cda6fb1dd021ce965ac2bac7187afa98c333aaae63a5c27a760aa9939ec8d78c7f6e4235995dad7a4f6b092c61abaaa325bfa11573ef861574d02a2590e573656d9f7316c571dee97d81f12a017737c875851d4ce441b3af0a4d9e57da053edf71490c10798e45c5fc1c1980de354ebcb5fb63c65681ecdf79440043513013d961be7346dbf1188aa1200eb9702d064c9fe553f5cc4c6990f782aa5405cc788dbecc3875663759bf7062833149a3941c5b9a951972105f0d8836ef456ce98e4ffe565bd28ecaeab8ba8fed0f03716ccf0b97ed520fa21b8f9cae3abb9ba2e6e87bb73bf26569446edfb5a2fcf9cbddc369777fcbbfdaa2d732d49cfd1ef9847a18da8e198a18f3dc31dad6dbbcb02aec1e9635f9b606b3751fc3aac57c9ab012e50c72f975ee6dfb265e1f751be1dc963c1150960d4b6d48508560778f202547016f7c8a2f427eac9252a8abdcbe955d9309df043a1919506501ba0435a9324435de91612c556aace4e3850e3c9e01f146ca0bf98ea2744541207212e6b59a0870602bd477dffb7ac2194ae10b8c00e1a94b3a67e0ede3196cf3fdb199bf004290b656b2b579df6271da335537e12484cfaa60d08acf903ef613902e47f1f0ccabe6905ad4cae1015907988c1be6a41ef98baad2d7d24e21b523cabdc7faea97d1b1a8b6dc6eb72891d7b11019b2a3e4eb1efba622e44bdde126c6cfd0a80bdcbe2ad305334fd3fe11601ad07dd90fba681b7cf09b3f11afe40625c40d12e0d894e55bc910cfb02faec421f342dc7a80fdec54b3d9bfa2da1400b44eaf53475d09f32b6a9e16edbbe17e91406913e053b33dcbd6ea431064277750405c17f66a774afa21bcefcc98786ae80a309616738413d1efe7df1d001b7d2aed9c519a1eb790d0b95b2366da57635b6be810a10e2f3d8d7d208acf4eb791b29f9ac1a38749176cd5c4ea022e6dcf20d399d155bbf3997987f31232681e1a3bb5c92bb8dc59035dcedb37f086d71f2731026ead6f9206699731702bbab9bb777019dbb8180bb46c5215e2c702da2f11b12ceacd2e2213caaad0265e79e3437a98c818f75e8f7b1226e13a552f38fe868d3a1ad28ba1d806688bf836e89cf06888bfad519d9a07fb2066b6a2e70639359cc8c974904ce69c434b6b4c37826b2566bba39808463e29ce1ff22496ce186772b739d6c9d043c6e59485133b990e008d764f5442b4ab8ee1b899a220dac0cc5eb24e655693983a3930bc0f8f4f845ef9ae0485ba14cef7c2ad52e5fa4f7cae31eaf1a3d7de7949c9fe5dfeaf2169c52ab9e4fbc617234c1c27a89063132f5651514a5f0c0a851322624be598eea213c86e3ffb8d4666cda1309466e0dfe087e41e984fd9fadca8b698c5d0aef4f71c9a68260b417b3646a2b061f1276dd4d690d4063131ab866130a398228c6a0a745fb3cf04e001548529973532bd56aa52e22dc8c4abdddb3076dc5f134b2170795537b198d56d60ee7c88d421d0e717526cad3baedc4922d2209df6762e64f0d675ea804df00af83f123f537a187374793fb08eff068e9071eda25429ef8ed3bd22600e0476d74c95ad85fa3ad876551058c2309d6bd05adc68dc7f957ea85005f0563d35f4755ca13ae2c671ed95775af93c6d81b11e1192556b8ca74db04174659c63b8e28bdff6b7f406b1ca1d7bc5df2ef886bc5e215265f7a09c06069f140808bc1969aed8793771366542f707925108cc63e323419344b2072df36630e53020f86f8a03fcf2a7e0aae06274628a1fa5125caf7ec969ab03a6e618a8218aab4eced2ebe25d9370fdd76b8400605e4e7bd242cfbeb4285c3f0785bbedd348cff0eb477921f3032cffdb71626b80988d8df7ee32faf0be7949ce52eb9b0ed204b26d0bc0b2ed6b9e23f76cbf01cfb1ecf18f0c020845d4a3cff21fc2135d07986e0fb63b7061a0f98e90f25ee32dd53dbe81df7233ffc992421437c3499261ebc47747121fcc5a557f75b6b918a0b15daf48af0ca7610b9913b8cf66c5b67dcde7c0b1b43cc2ec35ebbbaab5c3ed49452421f4bdd5b1ec86833d848f2292612f4cf8d20d04c236e09e8db51bd7a1d3b06681142de812cede0e111ee7a12fa74c5f40b484c8c917274c4286f54c15a57578161f7e580fd061b839a7558fb2cd3984bbab5dd15a0ac1a1f93c5db74c54fab6853dd2a9adf08c7a878b4a798c39c9eead2fe0df029b48794005f990061d5fed63959538b0fd6235dbb726d35104066e36bc9ba941b503e9bce18da94e22ac69f807b1ea4296dca7f6fcd341a5d05fe407588e5282c2b448b4c1fc98cf6c88ce0c0e74b03052681796adb5834ad4dbd35e9c542ac41f5c3ebb821ded1f6b13ecdc0671323fc8b4cc956d443c56c5d0a18a685c3d54730f1c380aa62eab60bea9a3fe6d8a804b5771ffca80a1e1cea310bff063732f04d32e216970152cece368c935f9c50f1ef60059e9a0dcb5f780b04f9b831297c915d7213f8e61f8a246428c2db66616163b3c28009ed29ebd250b8b8cdaffaa8cc2fcd89e23c741c5dd3ca43e990dd197af44051e7ed84dafb2aae7736a60851a0c36c392d98e70ec1aed33193844a861f1f7f280ff29d720e109f1ab2a80590bde3751528bcf58299bac50b8d9f39cd67f40f74b8a0d8fd63cde1a5c9a8353ab68c34c552bf8aba14fa69b3d7d89808ca9fcc9843696c415aeb6216d3bb1a30cfec55493adc288ee8341f68a63b3d48d9534e117f337f370312412b78c860954fb5f0c4001a33b7c2fc5bf407a3f50e1cbc2c520fc2b58b8fe29284f94506fa3e25c8438e39d1bae9979fe84d4f9a2fdc48c138c3ddbaa847da5fb998bba37639b4cd25e6fe254924640d4a45a68be402ec820ca26201fd42599be3dc5ee2522188b9244e1aaccba5f85107edd3a2900f5dd19f56bb3433e002758c8554e8fd161eaf05d42cd98ec260e5e31f9e10261a8b3ba3c6d07f76e3b26602ba06f331ee99d01b63001208cb1ddef6514b68da5cc5d56fcf65427f21b0fdf9028a503be590bbf1a8ced730fcdbedefcd9b7a64310d8ba5224810aa4c12a807d1cda1704ba6e20bcb89806bf4a9b0705b44574cf59d48c5a1c77cc2337bdf1ba1703479b0404821c02a67e154dc6136909cd05a0e601190c1041cb7b1380d02ddcaa5a5ef3b5904cb28bb93202f9b64b934e587602c156d40e648750611c372c2ec4f77a9333f69f331316dbc1c0373edd6803d52efdca50448ac00a0edddb2462ed833eb0caa34ca5e2e9f99a3df916824c25f16d536cb8b3dce0b3c06ffa1ffed17f5cefc31abb72672da2202165569c6794200fd6a075f5ab3b606628caaf4c286674173e629415401d48e6366afb3a8f5314665c707b628bab1fd64cb350bf20046bf04a22c1a7f56b19744d73131b2bfb0a1d8e07e3c5df34bf45c5b79a2db99dab0605ae427ed10456de587feb0a00fb5d2a3f7dee821e88060e3e3dbab865ab76204b0f2830c4d966176be143d02f59eec657750783b75c1bbf1c938d7e9a6fedef048a49eaddae1e10d2d9b1d6f04e7da54262d0151e1371c4e610b9dad2055c8d52f8a230e5b54455152dabf1d19b1940f2c17830d3b650806859f7ca1cdd35afd1159f80ffc6ea60168a09d7c69df01c65ce4bb527ba86252fec7c4a93ada483ce2ac31d9490aaecf6db8cff6138f717210c329db1147c066adbe744e816ab0811ee85ae192c3ae4328575df10a65d9ebc94be881ef6e9bdad8cc485f6611d6353ec155a77b68ba20974d09da1aeb57b468d230427c30867852f12690aaeb26d8ce660b94b486069b2b0675030dea11863b600447a9c6a14d52a3b375c7f8f748670ff6e1cbe96de0006181dc0af999caafcdef2d5d4de168e755e0547ae5409ca312416d8cd8f93aa6a906da6c6720dd331cff7323ef5571460081dd7e6a0de483e1b49fd8fdd90ff82bb2df1f20044d16b336cb880dbaf25c0304d23e7293492b75ffb6ea36bcbf9fdc25fa0e954d694874ae7f474c1982f9a0fe8dc5d40a1cf58237fe9d3176d8e6021488f70d8891a343aec27799bb4836a39a941f0aaf336e9c8fa63eefcafd75e3ded3e5551321a4ebd23891f6241bea0d09f1d554277009a9f13698af34ae91da5a607a9152887e7ac2220eebe7f124a7695128e2a87f86633cf919bf8f1c40aa68f9ecad16faa6172121b2569f0c193412e520326452085e9b1314f0d12b578711f9f8e175ffff2a749b94b51fb3eefd9514aa34f57f5e6fe921e88f89bdf6921e1aa7d42284623933d87a98250f4f090b9f856b58f6ba0f7cdae3365c7376fcb13c86e326214257537bc9e2e4c74390ee33ad39288779b16a578a931a3338398ca3657b6754556ed72f1067d08b14455e31df9a59ed755503ababf36803da957d9f9c9675f864e0111b1fd5191098aa0c543bdb46748eb8dcf35a958a767f11ab7f97209622c6e7993678b93d1df5139f3b7f80d01c07dd39a9f3dd8918ffcebc4d6f851ce1e0f55eb295f39134a586c8f0d64a0aefb35802d07a4c8510ff07238bb0da88427a58e0ac97b10eb2f6a9f453d464bda9aaee52916041c5d7fa5cd2f4130100a313695d56069f88c90dcc4c0629e728842aabf7a2f8192a87344c0516208a29608b9ca62b69d2ca466a5feb6c969f8947fef949a1bc8772a90f0b942c4edccfbb491bc48958cf64988c4b8b9cb67db834a1b97a6b355c0e6b003eb62ac46caef975ac86d664a5754f692b9bd9659371dbf9a98f77cd8d3a821dd502a065a22a9f062aedac0ae875274952fb81cef96c09e97d71e585bd213e5572b350576aea47479ef2ab64b19a95f2c7b564da6825e14020585528ba8b18d24893aa4b19984695ef491afc14d75f5673e08cee82931a989f065e799bacd791cbf27f42a999d0232d1230e7ac9f6d90c5647cac8075fc7d7ad738c7c024ec436f9c8b87b6dddaebbe20ed09766203711774514ac67bfd361be1243f77b38def120b95c06596cdb9d8345d26d83b9ae0ec0c60ef4967579144b5cc4b788a0bd063d78c01ab73c10414f073e49257e74bec2322a955c37a8713e4dc2057550609f87c29a12556d9f265c17a37ab1e51879025222d37ff3d715ca9ba30a2db9a3193e43d1c52b10334c3d6f27560c92cb2013d008d53c6c79d7b21b15aef7e7ed34cc4cccf40b56a493913e229ed22a8f9f0a031d0e7eff0f78bfbcdc899629b2027247256a6ddc56fc7ba0196c4a9d3aeb1407d126e781488b52296283dc9d4ab6588d834f6630b0f2cdd98829b3de3dc8d344e239048494a66ecec1eecc2985d63f96f9062990cb352302c86d23c25843cebc11a6a593f464bf437bf284320d4ea400e2138ebddcf2c02322f8ed7af4fceab1d4ecb305323bbab7dfefdb5818f5b1119ea19a2a500d88f9f6b3472c3c374dbd80abbdf463c1817e3112ea2d5c7a7c870c1d6e4faefbd63b8f1e6b99910ef170017026ad7dc786d646192b4442ca1e6ced4cba3d4321ab3a0bad14704919b8c2885e37da5bf3cb0ad83170a8bc8d3fcf9e62e84bac9a7cfdb3d0a800409fcc1409659416243cc4844036b527ee354c9c4092e633aefdd6868dc91eb6a5a8efba9ce1146bc26c972027d1fe70e3bf29067e4e565680cb6e54caece135bed43051bdca80be5cb77f0c562d7baf966dce6fa08d52c804a679ccf79b4954c6e7475ec30f9b29e022b885c493c6d34ed489f3398715825ff20fa00d123ac60853a2a31da48c9a8db32c567ed4566d10b557466d7cc4dd65df844841974c224e78c06de51b86fda16db249f0b2ee9bde1b1f754a5c2f1b8b34051bb5e7ed096bedf8a18ae2b0b5122f5efa431742d06181832c3d5bb16e0ffeadf8e0966ed7a6dbf396c1ecf9dcb4c7a82a48a3f32a284c131655c856e3bf1d9b1d959b6837136a52a212eedd702e1e8b1d28ff21a7206723c4cd78477c94dfc519b9034c6cb09a37ffb12e24376c49b1ba8ad95a9cf6611af020a0f7afce399889f723d887755313d982740f47909fa96885f4042b3cad8d0a3770fbb64e1903a8dfd68e0eb94a2ce13ec09da9ca90bb3e45f1ab98bd0894e943ad0a42cd917cf51bdf302a818c18f822f87ca1d15c9552c2e5301313ea3225e8b613bd26d4d6fd5cb1674241c7386f6ba767de307678e4aedece0472d67bef433f24c76c464173db3dbd2803d6e3443d02f7971c3271aa60739ca797748679650d95e55636749600cb450abc4afcfe1d96361af219aea2c8cb5d86a6306ccc58c3bfdc6ad25908a27944dcd5e2fdd9769c92da99557c29adf3b96bc7ac819aaf956af873138e97f09a6a09f58a59620970e8a5cce9805805bf83335b791d68baee99d2e2602a69650d683ae3e084dbedbb79879ba6b64209a0bd67bcf5c31484230862fc6f0f163bf2eda818daff0e27df8dbaa3e89532918fd73ff4d97c0cea19478d914a73150475ab2eb224e4b2a06a3b777559fdfe675b9412dcb4fac7f67d5c9bd9d3d0a19f393bb153624f9a9ed5f29b05771bab1a053e4a5f9c4c4752978ee5f7e407a671d79616c64d2422efdc354bc83a69ed708f33239a67ed5a781f5a6e545f11a738ba16c9a0459b9ed117845c30bf7bc35671b2ca4963c54e54baf8f3dbb988854bea9d27f0a64d650ed56e78ef770e296f121013ecf0eba976fbe24dde35bde8b7445a7ee77b6a68811a21d84e7f395956d32acf51b32a22778fb86ece75d90c74aafcefc82f7a836712139bf2dfc8dff2a7daced9bc6e68886928a98edbce15ca5ce5d34fff7d0d21a30f733387ca7080a1eb2f0353daae43811da77635a9f0b22012f44bb5ddcbc12c0f8a98b8aa2ec9e3c9f2b2859e2cebdeba0dcea0f72a2822566b4f255dfdf0bb1b0fd338590394d99cff3903952c7cbb8e7c3e12de6de79a0759a40aaa37689ecde7fa1c3161a8ec17d607b73cb0a69c4a3ff3dc0c5a647d1b9e9355b2e72544bf5c5232e508fbc1b914994beed7b7f5a4ead15bde03364956513ff2d408dab2852f90301e7c3c56beb398be4ce0e057d5a713a5ab285fe0aca9efa91e52111da6353112d4a9a9f2c954868665ea38bf3c7766adbcda740c64aad852f3bb48faba02365de519893e2e6d81e8dd971dc21ad1668495c912e1152bac12063aa9a0e0eaa8a8241a337fa2d07a78e9184f40573378d7713a37e811249596ba1af40fa802949d49a2a05f34d9eb4f5fed768a4f85cd181f1d7291bbffb8a5d89219b3d0db5fb4b217f986ebb395738e8484244abf20beefded34ababcb91e8a9042e3e1639a7e3b1b68cbeac2e09bfeca88dea890784bbdf30e0e524222ac2bca6803a862d6034c0ff30a80d3992f01affddfe5fbc94e908f7a1bbb260007c5e268ddda74b3072d6d80ff3f613329f40bc7988c2dc3948e06f79092938f8559e3610242e46f2e5f6e283800d59bbf0f02a2ea60c89d71666547ac7b85a9c7cfd57d3b1edd3541311069a2be2f78fcff71102de99d033d07a6241c88990643a2e9304d8e2f00171973de49f45df2f6ba0dcf22ab949f2e34c0d7c2eadf9c7e66b16983c2fbe85373508aa44807fd057e0f10391cda80904e7165916a0d19e3f9c5e8c6e7225fa7251c7979603f4136b4d3c4f67924f3031f2f599ea5ac485dff11563a505f44e61921632336a2ab4732c0d2156d775f4cb1091113571fe904f16bdfa9002bdb4b85727b724f48854c733845829a65faa451b43a8d83ed9dc5643fa26ba0b8f471a372392c7d32f96f4bb338a016300984914f11f87d44d9dacceb7f291a030d4156c0f636910c97a3336747dc8f5cadfff1ba0b5c23b760e100e4376181fb992184529365ab547849c8090ed66d4aee93657d710dbef930690c2a096235f5aa4337fcf7f93dc2558484f267b02501d3e6d4cae467b3bb0f989f77c5a4f640b5b3e29137bdc1d4b2ebce05196c7f120627cadc95d7d7b3058e67043d83afd5e0ccf17bfd8c9d8dd1a8cdfe52e6539f72e4fd5df0334ed36d5f1dbfc21470bfdbaeffc3666fc3dcdf075c12805e6bca79e2af81d4b402cc25d35c308b1d1e83f34b64a4791dd5e9194b9e8cc3f711e9220bc60428e1aff58d5f02a0995b544fcc34d495edad178ce0bdc41ce1bc722e5cc4ae8ed6d2ef57aabcdde9160d79666273eec97c38ffa27a78c04a6b87e533bfc2a3b6a1544888ebd69765bbde27c59a736590084d7aebebade809a7c88123e4df441b94e722407db0fc61317f52e57bffbec1c3686fb1c592897f7b679de1acaa06d7a0d4ea0e0a0f46530ede9fff7b1c2309256989820ce01b752cfb4822d2ac2addd44b7ec71e2cfb648697b74699b9b264ce3b14baf86931334fa15f56e36ce564599ea7016ae3d36564bd8925615cfb48a56863380a09434d6f0b180e79115940aac95b3afcdfac4ca93490235bee80951dbb1696dc3c2646a138747dbcc6975ef999bd6e50f699c67b0d16216bcc990714c19b76007da95206ccb22056a2efb336f33504cc6762bcb5d08f7a1453b9f3f4f661e81c99878ac40419869c4b0843a48a77fc28b3a4badcc3c738522c93959f41cba3761a79cbd42b936e74e724761332a6b389e42061a7c538c733abb3adaccc14d1172b52189603aa9770339e10c825bddb4387baa4bc0c28166105bf9afe1e504085232fc5668612066345097a97c3831130c1c8d8baf4706d905a1238d4e9c006399116e5e6e0a6ed8c7bbe7bc91f908475712ad4f83c21f87e941368b644f158cae5b9456915012993716cb1c1697ff63dfae1188f0dbd09b8446b118a673c4ade58672736fcd98bb701dedb052d983269d727c3307f724372ab8da0f4b68acad3615dc0f8f6969a29537a5be8cdba4d5bc18d4508c5c6f783b88ea3c9b376f918888a8ef420085964dd2570e0187fb830daf07b33d26e04a88686170ba4e9028df2fad0ab78cd272422e117a92a4dba15f4577663d7e9cfd57bbc408f0f6fcc06813c0a246704e3d6ea6f701cd1b6d7570c986fabd7407988a1e9818ea13bb4bf39430c787f391b3e82f4560b05f2fa881ab61724417b62e0c0b6449e1b5e913dba65062c2526bae1a84b64c3dc7ddc142845c4dfddcf3707127883add73df8fd235df7a6b893a4fdb6fc71cecce557868696c8fe45973f6eeaa260bba02d5fc35da393fddb65efb2155c9246e29ea24bc3c8cf4ef79088555235754e202742a0c9306e665408090835be2c08d1253d0ed2cce49a57597da87ecf9826fe1fe96992118dff2947b4a0b1efe91898340b8da901d9972a9940a6b5a69f144d752ff1f8892193db636ce41b239ccb2b9cd20758bd5f92b98acb340c5ff298f5b247bf8c16c4dcc42c523b754b6b25aff4b39f0853b5d02433f3252afb59ab12242ff82048b21266dae1106fab9f8513b9ce2fd504edcecae744faef75ba5e17daa54f7900bc305660559dfd43140c2959e214add3f7d6b6d87bc66a68a904a028228f508a2f69a013d59ad5eb7296ec08e61a10c5d0a9a7aa2a8fa5022aef0c68a9dcb4fed558e0b44a048ceb1c2741c2d3293d50835836e4dcf6a09a263c89004baf167c587552980f8b3cdff614d4db74fcc6b16303e7034f8a59cc9a4b866875271fe865d07eb956b405d27d1d3e64ae27a4c6b1b6722c55d81496011d93f85278b90a8c3a03906f3021cec9eb1f2d241217c18deff81a9f2c2f5dce38931e711211921dae68711bdd8e39cc38b3379d38af095de6ea16321d10caa5dcb70a81a28b999d0407f935c4e2525dc1a3f15b4b911073037da87cb4caf0380a32f151f3df6002ec77883a2ffec25b5d03b3418aebc17eac52630449d822aa65fbbd7c41ecdad1dc0243c389658aed9bdbb16a10a390e914d692aafe8487b8e0a23422627b7f90102ffe11a826e362476bdd96bc5ae96109d63bfe4ab41db0fcaa93547f513d767dcac3c47fb14c2f0414bfd16f39ef2c3f7f58da91d80c7b9923b75ab56d048a88582309eb5591f235b9b92eac668e24a55481e03f321ce75f672ca0d4ccf505b762fe62c4a4c37c4d59969f6ff6fe51059dd58f6d1accf68d84ef28e71f0b1723a4ad1cfb1ee785b12356b3f80c12e683dd19ce7bdce6289872c411872b4d312624295c29303775fe0e97f1049e1669637fe7b3f5e64072e8a1e7a46585665399296d45a02799dd10858214f7c45dcbad6f37ab14f16b399835443fb9ee2021d43c1bae88638503dc1513152b94082681ea0ac81df42f09897ec9f8317a621929f58d9b69016b801eb9297337c2617a0832b37584b573a059a8317d650535b1b9bd748bbdca917c86af1339410a7e482285bc5a1bad38b3df7a8d6cd7498324c9207c73ad5d1e2bfc3f0006247d2cd711eb871e3bd34ce32c3c10592279efb903b54de90713d1bc1dd51d92e59572b8b042e7832b2cf394eb3faef52f5e561b76c769429a7f7b7ffc7e2e1fb4676f96b646f5070ddb9288138c7304cb6e58c530bbc6d30702a9ce66c9803de40b1016333040371aa57fb6f43f50202f94b4abfc3f9e5a5b3a7b0a7f02dc6b432fad1a5924e4726817c7a1086087b711afefd8ced5fc48024fd007c2c1d4490340de4ca982ad0439234aa8dc58949c8d580eb058bf36a31f16dacef0f4ebdb2e3a76d09f491994a29e5f426d38339ff80aeb9aa86294b548ec9ba510bbab4f606f7f5b1625af8246bcfd527d5e07b11d9b79a64f412096c588a7f8e071a7eadf8ab8a24ecfbdd7fbe2914db60f98ab1971953a430094d6c3c30d2b41cd80f4ed436f5d71f12a98da9850ed2711c234f592100dbce93e61527238f4adb183e2e12155ae1f33129f13558a68b0840cade10fba7c8690cf0c93bcd541481fe02d8c752ebdc84fc5ebbf87b5be929eb9467bbefb7246ed67b3f2b31ea09e94001ece51a707085bc07424d11d3accf87cacc5fccc90f08179bdd8ef7f9146c84379f4eb25e5947902349162bf062b9b928c8074e60496bcf589fb8a678e9fad81925b87933a38068144f98cc5ba1a0d25d6fc3e9ac93dd3b06924c298ec6adc49c07554c730a8ca6420b8868fd0b60d1a57869d711922540fd0083947b5f30bc4ed568b2057865a5e7a54dbea33b0db39d7059f3b09551921127a989db45c5c928b026535d16a127749e6dcd897069e47625590e9cd334ceea1221280182fa58ddc2cd5bc0b2b5feaedc8838646bce6cc1d82a7671f5dc8c467566fdeeae423e32c293f010bfa8a7b3f04f245fa5da64aad732d04d5a199ac260448ec4d8795ded7aa2ae76c9f8b2e1a1a42cc12d5c508407567251e78799b4aa3a8fa5450dca0795adbc999c3dd483822106c1dd78d1509d8d8c8df6307d09dc5362cafe38d55304d4cc39fb57d304ef09112e93c6b0991d2284666ac2c527d1fd0a635fcb4576f6decc455ef8eafdc9231d50fd9ea555f48e2cebd74046fa02aa7095f7a43e668752ef0a6f5a8b1994eecb2a80df90a161625d81c6ec0baedb726b91a5ccc3f3f94027ea054db5e9a210cd80c4226c36f2b3f1456814bd0cdbe81660ab8f0607d576b9e1b5764d6623dc739f9ecd8c62ecd6f56eb8819f765f33a628627aa40bfe53262afe7eb5ddf2bc599f3e8ff11f3266c16d1a9fe67e810e327c2edcf05ce5d91ad1ed50474539b266d17ece524b44bc76fe066fbfe1b3b34f4510b0e0268637d44280eb8f4b4823f8ae0eeac422a3ed908d191519bba9969596bf61626812c50a0e6d1a5bef4070554757ea900a9b63ba02695c20c57da707af5a5f602b2d6b2712afcdc365b60f095ddb2b201535190634c36f24ab5373d52100efa8e7e05be7d3533adb6d539725e90401c74b2e97012d62bd22d5b40626767613a634888fc4203e7033d8f18c812ddcfaf659f3947720de82f5d72a897030c019362ca1889e0f94f5380a48d57e2390f36d306","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
