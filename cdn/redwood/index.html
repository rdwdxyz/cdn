<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbd697666dcf86c5f83a86d6949acd520ea315b1dd859a9fe268104b2b9eb359c9377ca8d44f9d41120d2d8f6f9fc0f9988633dc94b8842652cc911797b34d0f799f2217d3efe5242b9f479c22a401c48761323be0ef3bb1aa0b3e18e6a5ff81d5ba8b175ad23e7a6d5f1081c3336581bb40d273ba250cd52fabfc43d789d791c77ff642744b4cd0ae09f90b82896c4e0bf72f1d4eca0e7d6038a30a41e1e92dd10f926848419b10684b9f2b952c328f2252804b90906210c557e9d44337400d8e2aeed57d11b23dfd6909080e65631ea8bdbc69ae9c004ad43403506fec9a631ece10583e4bcf59920ab8b6b48aee10ccc982e1817bf0076e1df2b7b1e400b83edd6ad7387837de4bd2ac1188eb7f3371dca2375ef4fadd8b34ce0ba7f63b043f06c6874a5f5036276dc0df41f76498da145146ee687d7da1db0f96b85060c737ff2c306bab04bf5eaedf4ce6fc90bf106e02882ca0e00c8c696b1ac153b04354a77d0297d2186e756d4aeb1f59c21e80d1ee93e611d567e97047caa64ef715ad3adc576a764cdf12419c7b76e3d6f9bb6edd361649a44027337bf0a6612ffe694b57ba26a82821c20ee876ac076ec2af99ac6a74ff4ca888ffb695772cc1f5eb258aba296f0c6c706e9facb3d41aeb193b48fce4b36995649c2c8e0cdbc5d2c27c7b703628a156a21b1f91d676708d6e51b12bad9b90927aee1fa0b9e5312738e0fac13fbaa87e7eef0de35ccc7d68d13809228004eaf654ac6c7ce75251420756dd7e55c53c6a58e04cc1f2ce02d1ec23cee365dce2b79299b87f37f09b29e0e9e7c6316d7cafc5064d71bd21e859fb31b403d7f7cdbef6ac663a82a2b75314bd222e75ee7718f11fd09a7474d93f4e072e9862560b2601ca077ada3f354d53ae2fd9cb5a310cdfe426b8a55b109b98f82c59926f0e2a95e28c2d4f99ef353ac96b0fb28b868911183334e9b59684729cd46775787476fed8955f222c44fc6f555f801e9a6ea4eccada3eecfa3f3fe4cc701ebba2fe1a68d38a7f32d86b111ea7b9d56993bf24c7daac73f7d94bf166db06f5e8939f98fdaf298cac10ff9c9f9bda11e1cf97abfd081348651692ce7fc6ab8c02f84b15f0bb7471d82f758b5eb99db89ddd3d062a276c17b60ea65981338f0798ef5a6817b21f283c667e8667f347ffc0b5a31c29654f85469ab07954331062c33c24b2c8432c39f3dc4552c4d20a1f41c3ec6cd7dfaae45f5ffda0457470cfccd6e89e9bf4f97cc6d67eede925d07502575fb8c5e1dce18a277dc7a8eb50ad17ece93254aa60352524e99588a44c466efbbb73b2cdafba4f02be1c0ef2a9852c5bfbae9c3b3d1c12cd66ed355a3f0857c138f33eece0328783fe7c64ac6fd24cabdcf0d392c78dafbf8813eb5a6adad71d0545b684db1b8ea2458fb8584229df6cda0eeedc7adf90931daead78ee95aaf00b246038e5ba634add03574860c0e4a798acae607df5f6c69919fa0a1fa044378d4ef73de0913584b76d436b153ae7040535ae487966f6da42683039764bb9470236f24b5f7ffd3d24253269786eb65fe61450a50f26644bce551dfca24bec536562caeef4189d77165e1aab1dbd423e599d0cc7b429fd1a2f5895d80d8c5497eb4a0328d50b29280eeb9bf041e1cea2cb7c01241a237fdf1003bbceda834eb2a542ef1d800868b21e680e8df2d78c508022b2cb0cb538f46714621719f2dc1ece4a67b1fc7ee9954605b4727a182b8149924be926bea2e23fbd0c49cea8e6c8641802246ade244b1e9d3be796bca43cdc5dc9643bb8db2619dc07856cd8ebf94770aa8421f10273871e1d93b71eb7846b549a0ec1a9a993194d94a5a6b4bbad9c93468fd6a31f145779ac7f7a2dca67786c7d885f91f469c0157e458a82238be715e3a030615674377d311b8eb2aa0a169c816fe3e86088c5f7af5491efbb159a191509ab93e1e950ce71a7589ee217f080c4d2fa68a1a42bc94957e7a2df2ccf4475c7e09a842650b6da4f3ec1d4288d7db1e594a145ea38443c1bed8fd48f68dfa84affedcaa6f64cfd2c203b6c561867837d256e8c3ec7045f0d0f32e5346aa12755a58e77cd23c0f2ec275603d44f6c20200a1fd824edbd8e319d5a0429cd9d80dfc60de10b16cbd6aa4536d33e6e9b4eb1d6aa5542a6f81299e037b1f7abf30979461f25aa0d5fc33135361a26955e54912fc07f9da702974ade47c8b9e6f874bb344a4154660bf8200c3ffd9c4ab4cdbc6665780dc3c3716cd632a78c1f436ae6208088e75350d2c902c91239913a9ca5514f57a8008d0416f51b64f81637ac7f6a1e951b31237eef5dee5d565f136b047143355957a82dde44d3755b4bc440ae81d8b6ddafcc1711ca866ec6f82a96254ec24bd6f727de4b708df74e658170f916fe12aea75f095cddf0c92aa42312cb6eb563853f6be8331239fd9ce43c1e9c6e125b9b8b763202f166366eaa7c2ef77b47c940ce3da509bd6ea6bf2e21c09ed8b708b24d868a672a40beaddd068ab61cba849acf4fb4ea5dba2ecc7d80d03c9e71212bcf6984dd3206b2fbe31b5bc987a86eefa3da0f3b86311e9b6b96a4f1bf205a43bd9ef89b24d0c91804e57050b7cfdef9a804ee741383dd121783d4e144089af9008142dbdc017fa20c301be2c08260fd4c0ad5d6ee0c2c9f3778ae2df75e6ae1ef7f5bd7629cae8f0b5272d37bd2e9005bafa3ffe7ac4ae9ff9abcff737a74b89f58b2a36dc561dd7545a0e7e2a30bdaec219c29a4676e595b80260a74e357ba078f9061f47ce051f93eea18656508bdecbb956f85e0ab25636c947378518d464dc8afa5dd50b384bbaadb83d76ad281c185ce1e1259e84159d2869a8230a036b8055202a50c1de50c16c0bdf058c28e01933c78984bf463bbe18a8d85064aa480156bb1eb7f4752feb606ef4f393bd4371d009b513dd97c0bb294cf4cfc0a3f9179892da055cb237186b207f64299c8cb91a3a7d356efc6709d3cc5566d1762aaff4a60a692bdf282b1e40a9bdb8cca1d6c2e0156f874ba7022320ab1d46995cdce9c21c9a2c98032d3117bf8d77d4e14bdb7af9a25c189c4c91cc23685bc5c1f4d8b1609850506fdceb4d5cff38b57e2e6351c1617b1e81214b123ff8643e141eb8c5c3b10d05ef79a69552ff2963958c7781ed65bd62f761fb9bdfb6a5d053d6e8c3d28ac05408558398e4af608592bababb21ec18bbc6e467372f63be497ff12622e278213aa6bd1e37e34896eb8e5c60bfe342c3650ea43dcd9bad40116b732830d1ca822f90a28f59dd0c80e2bdf9bcf460117387f3c6e9442b8956347c216355fc742491fc70b322627eda3caeb65583116a2c89406111cac1b4aff2873a3a04326d974f93c96e723c55a692117a6fdda7f8ca70c3b3e928ebecba3be728e86776373331db85555654a21f33477205739a37ac7a849fda99d7011486a8d53a812291dddaab678db08d0e9b6802822076250bb760e9b9e75b62e228de341d1cf873ed86f09a70aa1414685d54acba1af0afc41a8b1d2b59d0597c3781f6687ae538024235550d3453b609beea1c78806c0bef5ec1b2c5ba7c4af16bb0b35d957692081fab0384086c49f21feb718e3031c311b657268976d412cda574908a920a81ec8fbf3a6a82c76f6e929249a2994971aa75a8f41bb61e5c06ef486aca4ec9f0695a9abf28bc382f098e8440e52d24f62cf81577146221e42897cc0ec006d3bdafe11d889cc2772f6d09fc0849cbd4dacc612d19d2855125fbfdaea6e0301dfcec6feab16217893fa143adf77b5f2de3e3ec3112e25b9bd01527ec87e1ad7ce315c0fd69ea1b9b6ed35c2317f9194520351907d315905cf5e8740b020f1d4c1c6640e506430a8ea5d7238aee0db7b494db067307cdb3e65d0d522a27e9be7b24bf5f577413a2fdaef7a703785092b323d4231a94583f6e2b9c32c9591503fc37011802e308db2c90665fa4afcd74b2dbea2ac523ce2e8ae31d1009ce6ed513afe5cd9dc3e5f442e85304faff0b060d6cd7c38710c08f79a2fd94c6a6c9294a7f1b682477193b49ffd1465df4bc4f096582eea9b437e51424ab3c74052fd1d51993c77cc7795c76150137a3f0aa6235112bc103aa8b38e6fa8621a8497f44b1d9cb34c0476bf31529f0c10e2b9ff30d409403ed56dbb8a4d53ae6c6815e8bb37f49e6cda0ee83c0bf08ecfeae2562415fb164102bfe6f66f37c4e5fcea634f8c3d8912bd74c2f63162890bc1af041cf2c90baacf2d369797dde0e5b8879f26be9374b572c39fb190caa1a0ff3e850ed845e537d8a2cc2b0cd9b8fd24e8cdc396ab18302486a29786d8372db2c035a717f2c5a117346a482177a9f007c825eb774de80566ab5f9b300ae7b770bb786d4e8ebead745be913fd28e7c8c93ce81a028338a8d7c444d61179143aadcaa56e256adc0b7ed5bc296726060ce18d5960fe31b86d22d1bf992a1868d32f70a259b4b8632b443dbef5d71ed3d48974d3fc27af2d89ef14cd35dd6785f90045129ae9251e7946b74cc3d198568a24ac3c87868c8b351994e7e8d0d5ab8a27a59a07a1dea444d32554ae59149122e4277eb1212cd09aa2ff743b8077db492ae6c696c20908487822422b23c479cd191c12133cf0de2849fc295b9d6bd347822911e99a6342790b16eb92e37cab7a406a4e2d0331e1090d305d0e10494c773726322481f9f6173ccbccb30ad5202103e9ad3daa9bcf164800f5982132f91b057adf9cd43d199ad7a3238854ac9ca188ba64c5c0420452e36e6dc1c9b1f0fd7667bfc5ad3278ee35f2b7ff9173a29c0471384a96dd5d3a23ef945e00f776aee01805b78f33a9cf51d76246c5bb98c99f19bad86cc5666be86ec063b2e4f42c3cbfd8db0e46713f0a3db93694ed9c46671c4d1bfcba400914d47d77b2551f60fedeb4d090d6e536fb7b31569763546a566484f2a648121bbe65073571a9e059f0fc3f9e15379c1449cb7a86a0e09a43ae8299716208716b2b86f7aee0061e27e138b71397896e4465c179be83a49895bf5e1769771ff54db668dcbf401b4df405a10929c2149e42f7ab629b8e987644a2737f8ccebe9d5f6aa749b5ac9f9c9fe3d32f7c1745b06c04c221beb5da27f4ed18c6427de0bf2c739ef6ab147d21ce2cb67b5d55d5d8dfa601ddec247b89e9a9264e0e421092b1315ef1de2b4dea8f686ec0e37ec1e14774ee9fbdc8dc96194d2740abb9c9576d7b6fdb48cfce89775e4efa2159ba6f62b5f7f1f2b548c23f9ef95ca97c26501ff3158170a858384947bdf6e0a2635b9c76e048b6058675fdb1820c5ae42eacc0d2b985db90b65252b01454190f673d53cbcf8fc5b163da5d0c6100874a765f61c2785ac22dae6277d4cbcc5e1cba7376be2fe93de4add157748b6428f36bdbb21b339e079448b302a3042e41ffc1a2a67e8d1719a52a8f5f1deb411f1cdd57e5e68d815bc9823e25d1d2fd55421586fc0a0e0428a34d5642a784ebe52b6009da3fd5e64c3f4b6ac8fb5e8e518b3c78775144e73825c63dfbd31074108c5081358b69f20334f8fdeb6c42c8f14fc470143d6435a632e79c23a7b1b579534e79b80bb0acfc96299deac9719f424c95d134fd34207ffaf4c7784096fdbc6f449eda3b0e53df2ba43cc53198bce1bb78511a38151b4b0f0a9391096fd2d88e74a576b37eda5894845b5202e3034e71203a4f1974645768edea81e548497a48001a04758b204919e2eeb69bb453e5174f1f04127ecc898245af29067376a6702c4d82953e878d288aaf92bc190aef44e671274b7326cbb09b89d694173fd1666a45abc20e24cfb7004ca32356ed9a05340c1f8a94afb434fffb9f33bbff7773a44a199e4dc5f44b21c1413677126ae558d72408f8c7dc47b3a92fb3aa9d63ec3511b2f6644653fb69c0a28961f2bd081e82dd0759cfd311b871c9153925e2967f1c13c65161b4f56868e247aa8d0573225fe554b7d1471cca055125618c5e56ab3b9ad36eef8ab657dd2ad1ad4f300ce15e4bcf55f36ba12b0a297111e99b0d0d24ac4d9648d523e02583923603304376917b37cf20e291bcaeed2a8581b7f3d2297435f8ecbe8488303431f4eba57b5dadaeee7d43c9245ea9333a3472551e7a2db22b0ab2c5af5e2f321ebde998b47f66a48ecfc115b65ae1c5ec24aa1109d1f1e1beee90213bcd769d4701b426bed3827c1edabaf630bc8b93eff91bc2d6961658fc0b489bf12ca060ff7c6d75aff5eada76a0aa96cfa3c2a43eb5d31fee25a714c9570cce2e40b00380b87d42a685d68ccd2c2aea9f2ec2704ba5bf7676c3fe3cdb23e42cba6f85d7d1ea3ab634361314b97dbd0a734e38962f288d18c2ad632c6d8993ccebc58ff38781d9df96a5e4df76ab9dc0d694e4304215fedb5cfe09c45d6dd85c1e422ed6c99df6415cf180ce8363e4d8ea5d9e343e8c354c6655f5cbfdc83c30a91617ac611fbb23be407a937c50979eae6751b79a85accff30ba0c6f5fb184389280ef0a2d6a78986f8a5e14ae43e5ba97b127a9aa232b85841557af91c6ccbf110af86de6f11ceef72f0026ff3d0b262d0e971c5d5e10d14ae98c7056ac1618d447e2cb1dd843e9f4d02f35dd0db79645bcab3038efc9df51d5e8287ad4d3342474caac406692d227fcb5a9a66885c7aa0a7ea014092919afc5d2ced4f13c66e343342367e29fb2739a936a03754859feed60708e826ebfa1d463606fcdb5d2eddeba0014f3a4a13de28f40e808e099dbe16ed6b65e1d249776de288d4f72f0a4696aefec186f50062b98e5696ed793d2b79fc65d74c03321942f65498a74fbfe43232dda10101b6b92cc1dd9aacd89a5cb96d80419454bbd570f5aea45f0658e33dd39f4a5d86e3a62ac4fbc21f50eec07c51c6e6e6a5903f7fec34fb46c5333a5c280562d64fbc23772340a90be20068a965fae866097e05ec3bd34fd565faeafb57025df0b6dac3a71979509d083e983782adf2ed31f7a642bcff00b3309865b7f8188296ba8b983369b40a28ccfb3f194932d56316e6825d39f1a8700e42909e2c3da37d02cb0d80c21c1c2af6c0f4d7605033b14f0bb5e910dc699efed0596a8e7afa595adca63bac90af6641ddd0bb4684dbab6a29bb96a79a430808420ed58aabd6e5e0a681e91b7cbe102f82fd83b055885c7d569c060d60718f4f7034e540b5d507070c59b613c0790297f963258863a33732e20e997a186d3cf155c921985f056075e27c10be98a9ba10282a545d1c5a13c16512893260a6ccc40f8555ab60cb943f37a631ac0984f6db3ed7af26a9d97eb659b4d63f3b5c25d2cff88abbcb5ebd36167fed82bdde8fb4657a02ea992dc0f472d36125b1acf1eb7a2b8fdacb136268da560d3ca5d78d3bc45014c0d61f58113d41818103fb997ecc6f26086d342ecade999db0f1e233ba7fd598ce9d8a89a8298c7095832d016ceb4fafcf8f655c4913255ccb5c84ccb8a6c249b6baa99e89bc19d1ba790ff43c746eef8daa753c431d84f654ea06a142714be72cfad6703e9d4d021b801a109964198478eb2e99c2a4cae0c267787412d5f69cad0de32e11d7d340d1fe01a6183870e954593c5185e6094353704905c4fa10f01aeca32a50846d0595eb68922b430dd31c18a5c2645307fb69100cac774512fd88f8d92ae9a81098cb5f5ad33aa2eb10c291cfa7b904e484da233f792cdf78f1e9721945c2561d1cb7075eb8af214d1aaea1d4ab416a28d37583a5d1f8b022f62752ad3d9df53ba8c18e59103589615b5c81a9fbb99c4ee6b41cd88b9fd75ce25c0c1a4f99b6efd49d5ca75ebcc98679ab80f2f431c70c98e2f74c44ad281155b0406eda839b7daa8259ce60584fa7c2bb13cd6c52ea0c47c61b178a4d73637c48e6ecaa0be9f05b09be67fa221c27825b97aefdaa71b11e08cd91577eddd79131b31efa29433017af0b72316a307bc7ea0ef29335d8cc697759b79668ecfb0a5dfc4a47c0a12519a779c9b9c61ae2b5bf1fbe211bccafd8320c6b006d31751677a4fd0dc8a3f3a952c31236d489e2a988784365bd737c8243fe470cd154dd01a4028f7d54ba99aac6d850f841a07a238e7a5f4cff4af2002f3ccc5872a6b906424ae8fe7fd8b415af404d24858d09153c2e5c3fb235f0dce9c61e5d88f8906d3e36a715f7ace6df11c8f9f5a993b6252272aed85a876cdc8245f26f276daa1d05168ccbafbaff6c5806d4fa68865f9574d2897213a9582f08fbb671068ac39220429dbcc217bf5fca25d10c42398e67e59805225e278b65c6cf40c7ea7035fe6ff46d80c4d1d6b8f75d31a08e70ee36ee7a88b41baaaa0375fb5fc13f0a2d264c51064afdeff2dcd143ccb66972d69130f93740e3387b173044c5f6b21884fcb3bfd07303a1c81749518e7ac63c3ac61defb518c7037ba04aff6a5a44fb059a94e4813cf6405bf4bdd4d8f4f51361a679055408cc3e310e59be107498d3aa335ee86181eade7a67cdab013820ae292576ca2c8ac91bedabf2c799249f7ba286c844b792aa9dc10592d07d2028a593fd3bd55b0fdf6a799517e8dbef806e59a0ac4cbec5b3d8f0d787acbfd320a14359585bd3a986f3a593adfe74ee2b8a1049c659ed839164ecea9ff2cb6c5408d7d3fa13995c7a5353d21ed3eeec56921d55b839e9b96ad9268a5847c852ff9bdf6ac404f915d42b8623fcf804e62ad03fbadbdbf60846a81883e91ce383bf1fe0d1de2ad81c9db38f0bdabacab34b0e73af85865fc2279149efffe5b6dc2fea3a8e13309362b1ea994c2c361362a1574e7b39a86e6a981e83738cb09269abde7cd829d4b7498a08e3a398e297d6e95973d86e4377314f1e8fc98d56eac2fe10f02691996cc3b6079e1c182d77585ba8dab91db44ceb6af7b6e51d53b6363ebb029a85dcf6af224d2e37033484c2c3675f14dff64b220e6540cbe8622d78ee7a92ee74d37a77e9e31a7ed9e48bc8f29a1d22298a0d0ad1cc1e3d106154efdac6776ed18d5fa077ae9de853b57e56ace0b1e8ea7e9fc040e9f1b292bf504008c33dfebc9b17afc52eb8d3c14edcebf3d04cc3933db207190f16c7a728a0167a78952b5594d0e931207d16180d4942b502d3c8827113a49ef1d225bb26ceb2c0f5a7a311c3e279eda75d8061790125a8be694f908920349f22bcb3ce1dc88890c3b18c329e744b637659e925acfe40546e2d50cd722ab0dd83f48dd46b8951a9a09cac440d3d49f98ffbb0ebf3a144196368eadfb509173e9a28ad622341573fcb7af259e3332b30cde9ae023694df66f20f516f421d713d40850e2b025e48ff3908fddb260731381d1e7f1cca685257bf7382759dc722badae80ef0c147879d946eb5877fac3e349d6b3aa165a65b3eb38d50a9e7bcd7e0e3ab3b5b2ba94da44d3544283bcc81826807ae955ed95404e0dea262af80bab2fdda1504b15ac4e79f6fb685504ffe8e6a11a7e5054dc0c639129afaf9b314d88bdc3dad8154d7a85fcc9f5af56d2ea35f6713b4880177821dd64a425fe4883f25f3c1817ca030dab453b5498e1882f071401ca12c60eae57f1b99417a9f7781b8098a4269369780e798a7d0c19149371863f1fed73bbee8214423f70d1085b26082748b1c93d4f868838d5f5fd34b09d32b49255a7f6dbe015aa3bbefc0fe93269c5ead2e58b79d71b14c6a556da4ea150ef9641e96f07c0e403fdae1816067a4e71c8fd3c42ed98ad73bdb6be7656ad7044a992a4d69d92d4f56d50c8ad40e17e3bcdc55f1ee731b94b139fb966728db3ce177c7b41d8c066b87e561d2d5005dea7668110e2983086cfd97c839ba906dda0cbc0ec3fe5d58fc57a5414e26ddfcd7a5e7e7fe860db27db58f69b47a710194c7a6f32fb5ce6917ffb8008437d2f1cbf5d0e8979e52811e6329b3f98b8d3464492d70b6dfc699400ac9c1f73739d5e1385563d482e463871ad98b83dcbd62b929cde235bf49c52721f33d0c1da38fc7f9c19a9559f123f7e246eec6bfee94ed15cb8bc7b4801574006fe1e474bda480db5d2c255de384c025f9fbdc8805ad441d54a12c6206b88685bea578d283abf5cfb3aeee5d72035971974fd95e1494507b724b062a8be82490457985a92c029f91d6f1f5f3504a55c427a87e7e1066364a25edaf2bd451f77fb226cb003f772c813bbdb4bfc22284471dc9ba51d536813f55c8ae98710d8342a610898be88d50353410f584aee00717532e8e536c3a55579e415f605647297700ff20047cf0e2601aa4205f197d3c2c938a5fbe91d45993502c5255378e30fef44dc727490d1811ce799e9164bbd0a2ad9cacbdafc696a26076a22ca555e3702110f73e15cd53519d6031227174699aa3a035c10024bb8bb6f06f6b3315a25a2ee1401aba50b2913379add91cad4c1be3eacde7b6f0679cb278bbfd258ed33db079e0af634e9e3012a85e19f6a0267afd43ad097bda06cbd50e130fc0831afb9c4e0e24b31755d4184b922faa0c68f67ac346d68c68dacb3ff6f26e733ea2cc70718b4fb2459f8aaa20aed658bcc1dc0bf15e342a2182b000bfdfef219e634bec0caab29b7613b8b536806d3bf277611910188c2ac7179fac590b3e129f6f37ed31ccd657ba295ab26c10e7e110776081f24e2e7dbb5a20a597065aba376b59ce6539aae4b9d6fd2b7a6c9cc8fc853e051de89815ed7454d337f904e953258b3c89884ad7d52c517a42fac1dcb6e87febae39c3c4f9d10ed168aec635bc2ceff584dc3b7435972693cf55e3ca064efa1f4f38a6397c3f44e508fff44edc5483309ef0ea29cd3321475b9f0e9f81f62fb4974a2e2af4a1924bc872b913946182dbdf8326790625e66286224aada9efba0f2e28649b4432c48e5acf50650bd219afc232787b84df3d01972c4d197b818d5b62357fc5bb37144efcaf3260b8a46ce5623ebf29d474a053ef6da5c8926298b224288d1725ba1d2a4cb04dc311b261b40918b5eeb0afa0e7495b9c081bc30161e36bbfa588d958142ba48cf1741665bc4a2e7fbb96d63aca212f7b286d89d0ce335b62ca1bb7c9ae8726be8bf48e739c8532043d372bae3e2718f26a195f759261a2af9f84f1742dd1328aa09e935709c952880a9cbf374b93945cb60ffa6cb6f1ba5b9772df13f976e498a5ba4a2ea064c86a29fe7d0470fa2c11e421a22a0c76ce6c0c3d06c0c9d76a17241d4a65fca9a1818c6ed023df6c1c4b311e667b76f2b32785cfaf9ee1a457a5678c39ada6d2ddc44ebb1bd9357e207e631ce489c2a20b09fcbe945fcf785526f1757cc688fd32f4fe16918513539fb557870e3c5923af2aab10d1dc67e4bdc5ea0884378161bcf6d88dd83d302f960c87637eb6151afa9aa6c52835c157afd757c500357f28b08a8fde251aad7e4d84e07c798131728b0319f7aaedc3cd53ac84ae0a80e74225f6511ccd6c1d4315578c85184b059b5c5e4bd4223e276312960c716c0ab6a524bf2344092afff03dd6d8372a4576ee4bc35bc7ec1c3cf55e6befe66d882efe6d0dc41b9e6dcef14340c95d6371d3dc46deaa61b1a944ab4380b41f1480c10ad41feebb2a6acd1d7b1f4ce5d21c6714c46954223ae4177e623c2e2477e10c72f94efdb2c87068571c1a635f62f6a49757af443ed937767503c158079c82f37aa31cae8d5be8c88e7d4b260b9675f512a24805c07d73b2610614cf413d944e8f2efc886247870d1d89d3834405e4626da143dae51e699cb702c703673471b01eb7364988ce2d24f2ce9a19c5b4f91dc71098f090d49e679c0d5f251c947851f74c12186374f1e348e0d3646052c0ae06d97045843f11e177ce8f7f7bbd2810fa08b8ae297fa952e84ee11cca5d10ea059b3ed6cd75a72ea855b8779461ca1c04d662760c875095ff6b61bd314423a0c90f43a44cb91b3c349bba9c08f9627e0c61e0a444ced54569f801c808b15c73611dcff3c755a951217a45f1933a77f0838edb68b73cb12955d7021913b479d1bed677655ab3c7030c0c823f912723ddd414486e25a6ef3864ba83cbcfd5a9ccb6f26816c1ac0b657e56d7ec63780450aa4eb4f780032695bb1b2b3b01a45086812e93b625ed75cd0c56636aada82e36b57bfd6ad95e3bb3c871f4490ff0d7c9c0b89f5b34217b2424d9b923520587e3d49ec8a27f12af91f3a548f98cbba66b080d82754f2bee7461d31e0ae65bdd90223cc3c12fe292285cb2b171ab4fa9cbdc971aea221af58f14db03a6dccbc53a2cf1a8b931b4d9e64666c417b955a0d2ca3b910cc10ea5780e420e96f0fb9ff112c264ff0bb6b1b2d4d991ce9419387666b52711d960371c1abce55e73f80cbf05aebf09c3c67c11ee2c8cc8d8f9acf700e56fda703b0aa1b7c7bb56b11348d70646b302e8be986d90edb29860b1675f5427c2034ebe4e08358695142d1195b33f1750349ebfb8d25f60e6b2dc4b50e58d4b7bf59a106fd0461087f87fa71ef697a5850986aa3fd79a4c42dd0be8ae13fcddffa3b5c4869f4852c8301a2ea92b7cbf07d6ecd2309277640356bb30435babbdfc4b86e90469f43e7e3edfa250a635edec66e9fe7c9542738d4e9db545bd2e185960fafaeeed5ceb2101da4c7357b84132fc3a64ab6a20f54d2923c5d9301b0b10d448d86144656da5f7a90ccf516e4f2096a5508821f9a4ebd40f64b621da9325004ab7b76ed6b93d5a4f6007f3a13fafa6bd4b05494723311b4682a36215821ee5a3bda9eaace5cff6558db2846e4a4a5b0a9bf4a7cf55f598116e028d2202a02e264432ea88012cb482ebb240bf8e1a64d53d20e1646a9a021c7d1bc5b8475a6d4d2628749b2e7a3e269124007ab7e6c800fff412be9aaa5fc8cfdb354473c179913c66fcbc069c9e638e621d33d65867445c0b78e179bb5a1e61887f6d8d8856b73849ae988d965cb263b974f1de40409510ccdd81c878d1f7159306aeaea0de104da0bd798c8cfc2e08b4328272f9181b9e493ca06227be2fc2f96133ae342cc826fe6eff52a90bb28ca5742ed510ac9ec2a6a24c2cfd54929bf7784e3932b2b44e8960bcba9437fc25b77b98bba7d28ba576d8742ee1450813359e56058ae4db8c20c999b9490b7082549abba5ca9183f68e5aebe05eb616fd33f0c092a4a0ce3dc1088743f0c1205d696928a704451180b660646b87bf470a9bf51358dfd1ea85e105913cbca369604902acfe7405200815d8fb75c807031e36f652b91792a79a636ffe86de2b8c9caa4678d66d772dda7153c8bd7ebdd20837b6906ab7e598d17aeb13bdd5bfbad93af33877bf25373d2de8fc403677b8ddfb1feb4f80806359babad802024258a988636a28f429308c6bc5ac20fa4f4e68bf81fc62b7e471f4eeb40bd73eaa346ff6833b251281a6ba5516371eb9efe0107828671e7e1537479cbf3716ef235f80acc2e7b6d04524f8a16f667d572fd3e1fb181158663bd6dc548665c1a6b059f5565f92bc5541ef4d4e337264c816dccffbed26baf2cef681711527008955b10d5a210f4665b7d11671104635870fbdda6c0df27461ac00cbc84730361fa55484776c34e88b239848bffc5b03148a090975646803f80adfa8cb842abe9aa981e5c86ea19c421020c48961c7dc10ec9fc671a7417b5a0ec1aea3f262c3391224cd44ee1611719164fe1c39ff7c521fc18cc1f2a0176f481500ba8fdb4724700622582fd69d0ad96ab46d6b7db92e8947784d1bfe706ed281f29d1e276a4a39d8ab9582f5b665523cd84026368de3ed6869e1ed13a3359e0cf9b8aa2f55f33f6fe5e6d8b8831b787510bc34ff36faa6d400bc630045d548c5d98a586c3e5b94903000e18fc39e3e634250bd08c7fbfea7742999f20c7ca0fb86dc95ff6a47489c4ab462595625793b900d0e42d54f763e9426c29e7bc07da27dbaffc3a3065ada67e8ce38085c1729d367c815ea15455cf21106d6c82bd790cca579ce699031c86f95a57071f1248330e1d4262d88e072b6dd0faed4eaea237a90db35bd890ea6dc1b616d28f179eee162b1992e4b43edfd318573e8295513de8804f7e20009044e50211ecdec2726edd78cb9b53ccc731424d2dfb9f349c04f86e9ecc9ff2e87c30557ce78acc61d51f520eb5849ec59e953f7e36c4e4352be52eae26da12bf2123c01cd0cfd76289dabbcf20a16f6c34fb6a2f940c42c88f4068b6cd70ffdb9f74b7f2649a57e184c7edfd43f2ad5d4b101fac22e2a5820ed1c133748d9601da274fa8c08131e77258759790d28e623f2e0f822f7379fff960a7f67384cea9a289e8d55a41887c4eb64653e90485796785eea85b0d9ca18dd0765983211c481208aa9563ef66c8be4267afc4eb1bbccb9b2df23107bacc27847419d368443a3d94258278033e45f7e10217088721b14b2e4da221b48903ab546841598f201d9ebd7e8c8a8359951e0db1f0acee20b00786e45f36b0746b2781877126eb7c4c7cf6ce83a04d5e162200bf7b46dcf2f65d3763e17659ab5e50667acf68eb40b1ece6e0aa8c484815010b99bf4c1ba0e1597f1cc0c691c85caf827688992f8a964ae8b84d9a3b1f5dbed16d3358c1479ab82d5830f7cd0b6b0ab9930be81bbaa113ab69d0000059dbde503a767dec73c80b7eae79b5904256acc4ef46b64a60d796c1e5e478af5622b990bfe94842ef260462af4c5b63eaa22ce2f61e9b6d8f7295156b0e0d3eca878920e3b22f3119a73ecfff622dd2303d98ccb2fafa9b15c7f4fbb81da00984c0048acc0800f9877271349e2cf9b84f831c1e92dbd2be0da13f5e798e67000423f903e3cbafacd01be97ed88c7c811b3119f59b614cdcd2ee8a80d6c3a57bc8e7728011538aeb67923c8a3353eb400809bfc8bea72826a00220f18a58927402da9b00a290966d111f8d0063a054f4e231ed505fd066440e251159ecd07644e55794710b1bd6de96e9650af31eb3b74864547618e11d3e34849b002051746834533bc1c23f4e7580a410c9ba23db20323069d4454c5531f1858b188fae445702a0fedb389fde1061429561a50e96eeb94f864810aea08cdfb3276f809ff066973e93becc6faa9dff8a6a7426a6b04cba74695334e3adcc16c725713c17c166d70c8a7aae40c2e76b64997e11bce01e4aaa5a532fb339aea0aa9800468fed3bab542ac09e1ddde9d318203b17ef4f48d4097caaaa13df19f6482becaf70d8321130db02814b340d9db676743c8476b071764012b4fedc88c1d474b24240bdb5c53074914bfdc653a95474612aed764994f441ea579edad0170c42f9ee4f6c3599d5c629df54ee6098455bd1184414a74baa2c131ac1aeffd306a78f03c716e1840961013a53fdcc191b1bbea26f81238870a86c51aa1732922a4dccc9983f286d19f08d3ba1c344721984cc1cfd6f18275fbbc8d6e21169360c2b076341f93b43982530c8e51eb1a5654fd8e6f6f62227cab347992ec55a4b19cd707195231dc9766539cdf3e35b6c80b04ea52c9e15a0d393be78d9d6b0cc158f512474ef54014a0c5614c41959cab47bf56fbe465bdd1024240c15668cd3d15ccf265b82ae3956b40929f2d282f45bf3c63f7c1a8f7b18d15a80655635432356b840c3b5c9231223d103368403594bb6cf5128748df9df330bf48fbe35aec7236f5ff07c407c2e69a5ddde6097ab6b0aa01e0a7408b91d3d5ceaadc5958512eb7a7af7b910c30c5711b6cbe9a8fcc175e59049cc30d0afaef13d308d4bd7de2994db96792c8b647925cb8ccc3b7c8c5bc8029b8f33a9e8ce1313f98f5705b6837a1b6f55e055376bbc797fb67f5bee2d2e441c75912960ba0e6fbc4404374a3847282a41c6db0bb6f2ef9c2334f5c3d1c3915ff3e196368e9869fe086d73452ff17779f2da695aeaa29e4f1cc9dce2a57ee90d98ae61a712254796370365b8237b84001890bb10d9acb5c641d83dbedb87e932cd6c93a4b98a5448f7cb8ae8a92efd0309a8a636a1ccf84ecb5cfcb664d83341d88d7e27c5940147f7ac55522ada4ba3f5aa8a1c6ac913f35f65fb91aec187f1b57cf6c1ca5f615f008ca5708e87a301d032d56850471f415f7755c746fd548e07f69e38de8aab7250908980270ad5c249fe8733d8c59a1bd994ba502e9746efd29c62a59bafab172ca41f4c4b8c427bc135942043024945cedce5ea911ed9d8f036a434fb85dd73238055b4809d55d3dfe11e8fd01d409fa5ddb284af2e1e8044de3185eae04ddf8f5125857a33bb9295bfce5d9ed5db95873b88e0c96daa4d552169c06546cf85d3a961e3348102eb6cd325128ed887e024df873ac1a8406efbce842443cc6419b14d628ea589cd93030b13cb33cbaba22d1543430b0c9b1aa1df7745c9ab4598e4b085f0fc656e5973fb01b281980a4232cfc256b87efd9b2e8d6f939972575c3f8b36062c3305fcaae3a899a51bf21bec840cb1f1384e19a2ad757128c027ea42ff731da2610b0f2dc5a3bfa057a862fb448668b322f920b330a9af95222b681898e121135654a7cb4630223f1a578a3e2ae12415867b3cc3b58ac7cf11ede1936ff4141f5ebcc25100d0bc799d0594e5c931ba00493f2218f212ddcffac32328dac60cfe536ec7ae20e0fbde1cfcbb10d7cfcb9c04e1d10791829633ef79e3cd2ade680061db0b73e0e4e0acc31bfac1679faa9727d539e1654d7a72fb37affea78dbfa1ea2943575a674da34f5d7567f3d451de47f0f9626ba8ea147178387e9954e509ae8a5e64fb6d57313f11d0154c9003b46338987bad4104cf82503a1e8d8d9f2a5cb51ec591a87d94a948781f1f92ce7697e289a8b370f90274950a7a7f4913870e3b9bc88d74a003401926fa31c0111aed210b3e6d26a54e713fbf069ebd05d931225eab520150f3b57dfcdece4b8641896843664a774d92cea05f0912c2eff54b832ff060acd76c4d42c422c6d0a69ca997e0ec0b35417ead633f7cdfa8b7af674b292a1026fc34ad7967e06e55ade5ad4ff90d29503c4bd2130175046ee9da29ba1d5d5937f5c3c5572febb5f7e28bff066b9ed97282f0028a0844e6d0de326d22461031361ba0226e19ddb8b6a248f41ea4f4c1567057a51dab07aee053fef01eb69bad82d9835cc1a04219b101ea787c0a137df2da665ecdd3a2ff934a4381ae3ef8118b57fc28db3366a994a72f33429a198e017737ba53062caa54d927c7194cf81bcabd328351728ff3940bee0496518040771cd8aa27aeaef86d6da3de76b36752927aa6be2e752fa53e5c2978d1037fa06d92f0c34ff91725109e509e12fb7412f552055fcd5887c16bc6a04b79feefd05facae95a3436128c215e1d2437176a0df0bbfc3f20819a8413f331d7a32292c1777f3b3033281b2d0758f029ae4efaac4c38433d91b0538868dcd16c3b9a1e1ba74d723d09c28c8b24bdcd6dd66c520b335d643290d34ce46be334f3064be43f73e8bd961e7c4d828665aadf5218c0cb793173afc98445278055be89079c0f892c6c1ec8d230a0c8c1dbde59ea44e4073428ad240c0953bf20f5fc0a5809cb87eee1be53764f2c6f7e94133c33a3fe5974e27a9670871dd7a842b5eda2821b0a8ae8adf8a0d6e58c9b596cee119c02cd9ed770d879eeb84e644a861b1b426eab375ab5d7aaaee3b6ddc0f4e85cc8d169dd8a8176ced84ef668634af9e7b5a9357a9ff01c9898b2008e27c45ee5cf8e3ba1316089abe6f08d0232a110ecb73dcd8461610bc9ee25729f68216a91ed4129d4490ebcebef797d5c89d35a0a9fc158645a6415ff5e19033dcd888bc0238d3a8d844f31a11a28cb654f448730f2714879e7e1578d9c72fc4e33620b8535c04da205be4648cf2e3209aca670863f109415c6b580b4c97ca834bbc6727af3e0fc93fe19a29243de1ef1cf2b3551d910145186dc811443a099f74216382d032235f6fa55e1770e720d8fa28ec534f4ea4314555910e9ab1a6ebb9901d1abba209857bd9eea3eb7dbfb5ce6721a7e613f8f8ae1f119029595c5d968151c965c1d2c31dce7ec6b5017a8707f271ef64213de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
