<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2267a7be9bf13890fa7e8c3001906cd7a290b0d04bf11a7f3f16673093063b031cdbf40a87d347807a3de21eb969e7ad58b4d339e45767061efaed9b70ac77633eccf5c0d1d779b903b07c3485e3c6ca71c8ccbfff9e00bdc7a69ee209b356c00352b94ee5fd75a038b8967a5d988dc412ebbd858f0ef84ada7bd3c4722407c8ea076428542236d93309858b7b1f72d935cf5107ad0a38412f61c426910c7defede01fabc3c1e18ff299f891ceeaa3963ee27f5e0acb2b7a14396e78ed41541017a3b68ef773be46d2bf1ecb5c399b5857bf147f5348dee644d8442842ee9df5b635de82c2afbbe236a0648351d56e104f9e207f55855f2615a891825bb0345adad4f361174bcd5671196b85886119d8adec26dfb3286c301ef5572c01420404723623c36e8a2c2c670a02cedb0e8424467461bc3b3070e43e510e0b5c65bbafa9726a0990b90a5f639fc063bc15956539d2566b63bcba2b5cbae32f9cef2b51a26f54191f275e4f9595022882c70b00a687fc9c8ca83c4ba1982b104d6d40d3134b7118478e28b9c1ceabe595856b311e177c293e3ece79f9bb110a56725dfebacdfc97e0ca2e5be5184a84e885b3265294020f0ca965bcd4eeb6b9a1ce074a71ef93f8e3bc65abf633ba438560289685a7b0d92b2e85bfd5a096e258f81e0f476b7aeb1938771e39155d50ae71acd57b66e8758845965cb34dcaf9d4fa1791396617c09aa8e9a5f4876729f27e437a8c204b8d6dc14c5f694178bd458443916d73f731da1511c3011a50125004f54bb4b4838e2f9dfa78e52e0817d5b2b5ce26c6434131436450eb260b2f257f4f28e2383472a45afe8b40ebfb8944de39fe717a36a34502cc7293b37bc4e69b3eaea966a77c365081953ad3636814ecc5ef617af97fb69785bae262e82dc57b202c8e76d6bbdc1bf00dc4ff674af4e1b645fdc4ca6e1fe42782dffe8860edf5994049d1d8113ad28b6c8570da3c2eed4ba11527239664243ca72f5bdb59914ac6db1d31f232894158610753775c664495c2a53a1d492ca6d091c2c0cf6f67f12e5be9d625ce1b803c4c6e712486b7b2cc2dc90e2c82037322a13b3c23f242c7b8793c30709d0cc7758d28d8b3b096cd5cb53402859e8fa49c7d93e19e2dab8412da709900c57cd03824a6b7ba47b60747e9ab6b2cc466a59fe12f90ab332a80aea21ccb2179ef7b9f48e062033f446346c760c691e54c1c262eb8cceefedc7422efa1d89a91b22a4f94dcb9c948e6538031530e42ffb074d8e70bb6ab57649b99a8db7f8b15a524603f8bb4d3a7c9c30191f5d377f9b140b2e7e32628778ea99d8975b8434b712ca369a4631ffc31f27897ee228c9c17dc459915ec9efe113cce622866e3ecb4659a49a0fc58977e3fe7c17614bf0bb305ca5a8e002c334c7191d7ec429773b2a872e4944a34583365d67e32c02e7c4deb7fc19d5e9bff3426449639fca810922a60bb9d1287d353d7309da06044514d363ddd74f102975ca1339e586cc44a6d19043c0203fb7a6a26441b54ceb024db5ea7c1b910cf927752f16d8983eec464b041f31b2a4d665b48342fbe1d591d117eeb266d5e952274d2777e8ea36c81fad4ec37eb98f8ff205ecb2599a14af1d3018339fdebfb11c1805e3b45090f74003389c46b6718fd8d0c295138214c0593377c22653d6a8ab7ef654e43067d0277139e33643f0d019adcbb82e3d2ad0477a6b22bb29ad467615202afd43748a9041f6e46b64796fa0dd18290a079a92b3ef54ee0e08a2c91b5dcccc70c9e424f61ac4a771ae68481a916af7f90e5bf9b6c299af035e12e6756fc7f4f7d7ea55cdcd0524a7e256386c165171a57afa9b66b74d359a10e12d7e87f6fcd25acf1967c46ef27c099b3f5201d7b1ccf900a00347e2a3db9853abe13348e4b9dd04ecf56790a5c0b84a80d499025732de5ff24db4583f20caad9012a8831a35da03fda2fc796c7b02eeec1bfa063360d6ff375fa90635b60d654f32a9049428944e4f3c3c36be725511cc314a660e0cfa32c243f3af6e90ac5e7e6ef6a1240d4584cf908e4b8120846d411f3fc5afd9902a8987639a45c4c0be71f145b26210df99458618b97eb39b00a60b90a238c04dc001e4d336840de07d420e81324fef24f7df6c354710f3aa7a5b85e3fb14efd9aa272be894afefac20f0a2db464ca32380b647ad2239737f4855609f8e0ec7223b2d8e70993f75e003dac9461fa2ec5f94298907808c75b2738eda9096f1606218d55d835a5fb69cff14ca9167e17caed26b687eccc6a8a291ea5f30bf5a3dfeb0ed4d920c93a94a9a880a69d262ba847d09bdba3f4b24f6b8ec131a0c480c4f88d3f4f5a969875b7b78100d7d2e4a9cfe10adc140e3b9cc0733a7f4ad51af09b54ed5f141027e85bfa4f9fc384be0ebede190c1196a1c5e7751fefbaf5d9182511dcba77d84e07f46c024e6892fff6e4763f268f91fc5579461ec3660815ef26980c0c4125077b906e9cafeb9fcf0052093a6574a759ba07402e6992598d079ff2ce2993a746f749873813a8d39c29561ee12da353aa2981c5a979e472fa05376c31b4e7f2d6a9ead3588cebbba0a0a3e35535c2c7b40765851f87ea820c29633fe66c34d14a9b406a1077d4ce01b74c49f2369d4151dbe7665638269c34145f75f80b251e3e70ded7684d31bdbd0327526228d8f6752a14de349369f2c78dca0481bc0de6bb7b800077e998c47798612d9e534988443381ea2d4882f35c234d6e85ff4711d873994aafd42c93c9f821506151d1252eb1b44a45a352c6e820d2aceaab384a034d2d8fdbeb1d07784a2bb1aef78db1757c5316f2f5e22a946dfa06e905c9bba5981e3207b2c13f302a2dbacd88f715b27609bfb496acd79597636e4e7d2d82c619419b1345d5989e0af20f0a07fa2cc322ed06dcd9d627e920eeb8a655091d3e7ba54c2b16452b4af0d9bd0f7cc27c4dc51190ac374f9168377b237fe84be97b6804b9ef44e728ed49ea85062907430a88c4eca8b42f3a128654924b88bae969ed1852579f4f76b21f78f655795c233b0978460f8baf865f72d8d137c4e4777ea38a79ac6a6d2ddafbcda68f95efcaea2afa510a8b73f86e8847d83f7d38b53bd88b6ed6263943963d31488b787023c51e80e77d508e8ff5edda193ba69446a103949b67ac0567dbefa716fb0f208cf9a08ab396ac9902b11bee5dbd6f660992595738808c83c6c32082d649de48b3dde2b6989c55bf2e5f12a38a72fd1a64f10a23f31e440dbd9aa9299301bea7ed0eb00ca1f1efe06d0b180c43455cfee274bd1a08933da5c14306c8ee70a03ecb55df0a3c867819753e3285bd619b2eabf9a0faeea1f16160469c609bc5aa093a377d4488bfae75febd6f993237917c6bd22a7c6accdcd94e4567457f19b8471d717f79187e1e188cda062680ac5c6008489cfb8ecd87beb6a8d8d006b757baca43ec3085afd6278bc91dcc9ddde165284992c2e915a235b72368fb60bcf160ae99ee8722f91a6edbab6a3a70941385fdcbf1e0a1f1c66f4142a4da0687924e425eb7eadfe9937c00c4bdf3da894604d081b762f2d3ad33ada92c6d84299a3ad6346d0741dabfa5994f2e1f8417e3aa2b5de1e8584e5203c91939f6c8b538db9531daa549de31da1d5eb833c353a08849f0404e111f70d89a0a85d332e1becd0c18e0fd22b241887001483d64385e4f37880a9cfd727fefa5a1803e8728f886af20b512378e353e3f2dce644e5fa1d099c377826308cfbc1911c07e9f273d942d5d5214c0b0ac8e9e223bf2e27f34f09c0b7a112a59e4934f5ff521773dc8bbc6bdbc786c0e7816c7820c651cc4c11af1bb3cbd91e93455125fa5eae9fbed0672de32e8df8c78605035a5a5b5dbd863a57c89684607b801df700b790dc3f484c8122a960fa54b18ea5904dedd3f63bb849dd89c21170214589ee4611a2b0461e628aea9445bb62a478394d101428bb0f79e990c57697862ce1cf02119d71b537c410b9d70d0527d4e550e36a5669e9c986a9406f1f594757b83a140c25ce522473401d04864fc0208479cbef24f524a07c14d31ecb5c32b5ff8c8c722ff82e4058ecd7db4baccdbc732af6fec5bd55878c5d73530c306f2aa35805ce399ea534c83f2ce6fdcaec88e120672878b0eeee57f6e57f39ec641c21efb2539da1e8e49d0dd10c73e78eb62b2fdfb40d812fd97945fc3bc44e384b64f612cc409b6e4920ed14c05b80cc76397e49eb0c64d4c2062e77c95798814f9d7a790455a4c98f78d96d021a25ee0621770900d3c8bd9cde46d5a2d476e2e113b574a0440f1d57de3dc513f1e704fbb6b364ac871fefe26c9d494591cb5e992f4c9feb062952eb243950ee5d7112f284dce7c81c2ff1f0bec5e0356082444e0dca661879dd3f213b8a87316698a15a950e14a4e237c116be1e3114a15ad44301b655322024a20ed1e8304060e25ef42c1b54122a79d5daf5ce96638864b899b39fc66df8c13ff72b5646cb4784827579f00b814dcc035658fbd653033a9ca787080fb71617981cba027d44014e41253cdb65b846155cda82bc3125c9503d04f85728acf4cd23cf03a61f4de1580459f786b8165afa6cfc873790055d60bfa6454b563b0966b8e3a5754c8acb395553a633ebe649ea59a1af623e0076b2736a37b988f7052dcfdc0838d291da6e8173806a85fbca9501d902146c1ce8f35906ab9f4b4f675df389e7b9ffbee607b27ef9d3bf0afa88b92aa1881726019d092054a4da7e721d804c1633b3f52f6288a079c0503a4168f66d1509823c53c6a0f6146644a556547934fff385539b192d09d2c8271f14cf0032f7a8db017da6af26bfd0b1ad49aabc7720d9100eaaca978189555d6327836896116832926fbbb945c63ca6e456feab4c6508dfa0bd69fbf4abac86a03455cfc7b5231158b32dfad43b7e79987bc620881fa7b13a93173cc10460e0c859c9783f488481df2da67a4d1347ad73c7bcb3233b60aee6beb83255acccbf419c5b2acf0eaa7447d5e1f38f990c913e3459ea761aaeeb4fd9e540494eaa85a5f4484b79d12265d428836a50b88d0ec151e1ed61434a42e694e555729285d4e766d3ce7dd116ef9ad01d8907bf0b1448075da465c70f2d824fc969c5e007938919ae56166292ebb0eb6c0fbd6006bfcd0a9d00f882f3e2bd482f667e1085ed61c6dd78e91407dacf0ae4f4a58e3a06664f3807f04ea3b6b05c845b1f76b56d34f9e81d251b6fb112c536df901cdb37e45b706edc86d0f6fd6f4eb42ce7d7a20184a9672013a4661633446eaa7dd93d0a98166da346340ae5cc2aa9acbd65a368954f3e6e4f1f558a44f3c41f59ed9bbbcc8fc8d2ec5a3403be66ae4859b9b2603efe3511bb92395c67d741cf93074021a3afe5b44e5befc67905751a7de032a1d263598ca67dbc88ae2c9dc5e170662d80744ff0d82d3799c57c2d4265081a8d06acc42b72a21c639fd7103509562e1cfb25f0aae69b765c441b4d1b2f3d86a468bc667a2e3ef1c065d119fc004370212c684b4473af103637b5051d366e902bb672a6d41f91446d98e2f273bbea7c1a9ace3aa4b9d8f1cf2460791f84a61e24d6e2d39863b14d4683e69a8bad35f32e03b8dcd0b06bea1cda85b0e87aed9f4588778d14aa99f11ff1344cf7611deadcc6ad1a418080575a82a81071fdf63268519a55fc2367ab286158f1eb1a7fd6be8ce8e4d6764514fdaded35841101df527e7bb932a7f5f0187f3f30960385b9a5cd0fbb64e6b4ffcc5435c6958529dacf9f4b7f81fd66a329faa45ccad7477e5ccfe6d07001d229ddcda95bc01b71215bed09ada91a1403243c98e7b5d1945b7fdf8fc6e6a1f1bc6888051624c31ca0fbee65a002528a80c6b08ee980411a1511cdc143c0760f1238cd8a05453e0a556a4be7c2b1407549decac5d13db71240727efc888dd4cf9450c42e5abd92c47eb0bdb9c1a4c1e31159e40c4f4bfd628c48177488d349179a393f108e64c2095e15c78bfbea54f4ddc0f34b02d88942e42fbe7f1acef13c8c5a64b1e6e2ca5de4c5fdc58e9c19fe03b36619edf992e3046cb53966359f85c726fb7dcde62d5b62a3346d13e304cce7cc5e57cc762b989619433668b775bd7b04428421c65399640b7645fc66518acaab67b8c99562705ac28c9c101b8455a5a4412701762918d30574dd0c370229c77dd0e2aed979a1114b7678388370e097d43add34b8eae8afaebe433ee8ba2db90405b39de33e6d8146fa1591ec6dc6ae7af1a4f100c5a7af3e1d74f06388626bfd27c34b73a8e067de64784153e60e05546ceb12f2a1c1e269eb2378f16ee0a100128c4c80214c2eeec0716ba9297ede8b11b4cdbcea10164a2009478a9a99177b7cf0341975b058e6dbc23087fe292528c31aaba76012b5cd21ea6551bc0fb87dc3fe5edd361c56b2dee879e5c8b0d72e7dbc1ab79fd76d7671b14eca1e894c3665af6d3f35455b77881be8816ce2a6b39167c03a8d9bd25639ebf6ed3860e4ba39e18795b1e87ff2846de56635113db40722d23fcec9b9d9a54235c96d9a15eb98a06f3e9491d9910a75e73f85bc51b09f3e48982ff9813a2927ede576ec79e43d7da5cb6f25c7d02cc51b983cc052b493c6821ca3864cb2d06fbfea26a35c3c3d28b8f5d0ed25350337c43aeba0bae62ad976806ee74c42c0f0449bdbb8fa71a38b1084a812e54586eb0eb09ebe4b3b5571ebe59e3f6988f29b9343a51206eb768e5b72629603b36539ed69db1f6cd5001c64ae0c005d6bb14d4e1a40fcbe05249cc1922a353d4ff74d29f5c85ebd6ce5948f52baca5cdbd057676e8175ed34dfae4cbb0fc4b10f20da5ca7caab67e941dedf23bcaf2905472438f13c0cc5d17dbe25f0888d4998240a9e00c5f842f7000533c18b69070584c85566141a3ffe42ce1e04f918125d0f38f203880f37f22bf7e05016fdf2a2062e8e4f7114601f60b1a47cc016918288761202e700d9b701f575230775bfaa8c861b30cb536340c678bd3a676c21dd1550959a58e4ec51a818e3680feaec81fdbf693b5c46b5bb06854dcb3eb015d018fea699f737a25dcf26a2aca740d69ca4f8b8727c91b290cd2329ce6d09c50e981cffca4db9d9c139ca2e2011233f9ec20d6f51e91a437b977072c4e1759ef57088ae4763fe2504696a03d6f14a6d0753f9882ac57221ea2cf67057e155a1aa19831cf3770897979b8e170ba3bd1d8656df66cc96ff3655f74b5a0671e570c2f6b6f5a613a571d3d020a9c8adcd71aae18dcf65273c8b76efa4e2801d1f4edc08ae794682df09775f6aae98ad52fd205178e5bc8812df2e845c5e5f1b7e9343b9115639d198458483f2af364ba86f8ef2ab6903d9a1e26f4254c7d4c09cf81b95832dcff7645ba445cf19f2f63a129109de5640f18db16985308446e1185f07f92272f86c8caa7c752bbe0fde00ecc68998e61840f19b8f2088ca4a9ba1b611e464295da48b7e99ed87dcdd55ba5697bf205d6d0f030887ff00330b8f2c62d5ca85b79a09c120cd0d22ad635453f7b9276f32b8771f74bf1471cc8196f57e8068741dc66374dab3f2c1cdd1e0939437bd5fa0998bf3013d923a4565cdc0a658ff1efb026784451338c1b080e0cb687967a7a8094e9224133f8d1f9e70145b31ee06485c3201ffd4683499a01ea414047ca6e4b4b5cdc19ccd1cb7486f73c22ca42fcb346aaddf0a920fa7a8ca6a15f4169cf3f81b167b11601cb405b73f099f6a222d6b2d775ed65a8dbf4d732bd126ba1a281c8ee21e0dcea84acacd5097de456a9e95e28875379217f210e6053b4d8c451837e80b33511510dac7409de49d4e00ec5667248fc2f4a926d46d36d52365b6898b8bf5518af256df07deaa073f3c30cfe885917a39b44e355cef4db15421dccdaa8157ba4fa343486b589579b55e9d732c3e3314c0d1a73bafa76afd83a250e5310dcc12791d703e0b493bbeef590b62c3056e601af33f420496e578bc69b5d3cf4ae17ed6f1da7efcd7c6f63e463473e0f7c5458a9f0498d511cc56b163728e01405315e688be9b6ca23b2be6bd2f5d17f2a6deb34ab1a317e8a95223ac727de3dbc1357b2fdcd4c7d5bceb19008e2a8d32a4541d1437104a5f7d511f898ae3ab9caab4e98dc79c3e49db3ccb0802d89389df44fa974f5fcb3c523f3bb09b9b66cf5f8346f167cf40a4d45577592bf160ff9b38b5549dfdbad5f1517db9e44944f675fa960ca19c0e9ca0acbb90ce1c62d96de013429fb57972fef5b277797b35a36d943cb65494d7e713945fa05230f78af33f50b27e8e06a200fa8e353c42cad2885db93c0f7527db52e0905359cc87812669cc1670d3063eaa8bcb37c078ba66c18f6a57f4428c9c661d63f393a4961e3be6591075878e409df1713124f6ef413f2094c5749f45547b1107b776dd933e89732d8af559c2731d6112c18e30921d9f172f603177a01005c9a9015cb90c434b4b731caac7df88dda2a73841be41c09f04397cfc42837817d827c022ff8b1ef00a264857a4952a848ed76c1a88b63c8720490efe854a03bf6a660e3c48724b72cfa29b8c82b8815b2789cff9b639cf24411e4c96e8793b1dc29d11b2ab3fb785aba32a534284b167dca6707ae3e79e00a415235168ae7ae9cefbd17731732e0e94120a11fade045026601ad9808fbfa3aa5aee85648f485a147b2fde955d50f62ed48a585fe19953eee509f7fb3befb1ffe69be779b08d090fdc538725012bcc4cb76231286a1a96b177ac867999b088428f10e17629aff2f452d9b7fd911de842b020efeecf07f9d04d9423612d24e20f23bc7142d7312a67ec3f712e494d0a7b1b67d13cfb2630e06421d7942d5a81247ac6c0c9064e87e383fb7016e1dbf959b031ff937a69f9f4f3bbd6fc29cf4d3336b5699f3282b3d786cdc0fcdd008169fe2acfd759b958268c5d769accba8a24f7b286126d3d2e0e403120ca98ca8481c3a5500295691dabeca6f87de76b86f2cf74e34f69d0c8e62d291e4d53eed0420ec111b66fd34dbe649de6a8463efe7491380fbad4cbda80b6406e47c193a60992db5e68f9354dc91bdeac6aeb0db0ad7d9e8d7f5cf379e89d9cbed5dafbc18d4bf80e4323dc6ee810bc31f375a5c267643799541acfa5e0d22e20b44c4b48b658523c472ea3bdd0050d4a50ecfd717e7ec31dc252293295c1b7879ab97450098a918beb719383b3526404422d5b7fa74532516095273fee5e13ba1e1284365457c49d24d2ef2141522876a83e5394ca90758ed27d8862ef35c773d05b6c86f294ce26883a4416a24f64e0050e2884c8399744a68f90c6fc1b493b2d77972415ecdffdf5270c7374c5f63946cffda58a16ae3c56281fb2adc15b8e6f0c6ee86c10c8bf3085549e85a3ba080b9f3b721e28b6741955499b2c58cc39b5f5bf8e022bdc29ea7536752e0d4beaf2b5b42f99a59aa5a9befe627c3283384f971c01ab2ff7c36c0d388975289e3d7a4eca2679e26c7b1251c69f37f66eea3743fdc212b9c83f111483f113f2c7346c744d27ac111059b8b7de09e009c93786fe2404d512d1204e93919e804abfb438bb45728b55806e8a82cbbb8ca0a8c53afa475a768ebef69d76ca62f2f90e2252aed381b04ca7095abc866128b913215953e60bb4436749cf6aa5a6820778cdfb5b435037afa62520f6b5dcb958f4cda00097a7c820c929fbe1111e2aea698b928ffe139cc3ca6e11fe230b6721ee5dc1e2f890d0fa18b9f27fda09aeeb003f158d3b6a092b1c4b3df0f1f50055576d3691b1a6e2eadab2353325f6225a3332d0e6c1513467135c5b843bbddc5d6b502b1a2fbce827bd2fc1e067cee3120cbaef16098c659251c5edbe1f8ef454a85f1a5f90f8489b7077d114c7aaf080ccdd02833b7708dc227ddf2b5fb74256152efc2e920824fc3f4b9b6b258344b741d5f7e12e40e3003404ba255ed69154740b9e718b5e6a88f7bb4f3e0695e3d5e35c5f6e3a8174d4becdeb505c8ada79809cccc871876a65db7882909ec3ef0d862caf496bfbf7512880147b3d61392eea263cf3013b1b266b762e94413bf37e0f44d1c18fff365719daaad99bfbf98b5bc83499fe7c04dd5c61af088cd621f7a8114f8bff2641f8669ed3fe481254fb2b1cac1040ac9529b7d9e8823a7d9bb0d9ecd7ae88d4a16d1be38ef3ccee492a5a417d7b3ff28d07e23461a94a8f06534d0646255230a4a7ad630014a243834fd53b5399f41324b72e00983381935097fa7b44c857f1802e3bc29797ff180a38d0d1e3a5b7c1f13d9599e1d71a16f822e7da6b29afb183b9925112dc8e4aba3f3a8fe01aeb967118c070225f3e2c7054c8cba3de58ce623673fa21042e4703b23c220e7cf154d6e85f12963ba6bcef266805dbc91dda567d19e7c15ce810052e396d7ca96a11f6328c88b0d352ce4aa910a5b76772820ad5f0cc7da7c757bda44a61bf04c534a37c393e519fd510df75ee8d81c9b4e59a66c3a28fcc7aadb39fb86c40a2d301aba639f6584075750a24f5d254ec6099c088839b9cac91a3c04547507e6fb26046cee1cd38dc13a1b239995450607407e41df523ff909c36378b59335ffce80f810f71431977e114dc74f2d333cf245707639b2e018a2c19cc87ead5a1167bd4335a00bcacc84ff758e1705c2ab81ae318e424fe30136241604231eff04a8aaad3147721d2664a917b3c42c77dc0ccab40de3cc1e6d4e26135486395ad9aec0c431ba39d660d864d102b089383806b57239f8ccfc223392fdcf0e699b65934a1b7f26179ab44c1d1e97fffab0f5d3ff96be517adf5407b412c87557109c8bfdeac2d1dbe0d0761f34be694f3c46231cab199274b9a9fb556157fddeec093a95011b03c2501c970a676f7d80de00bc249e5ad7a473fd5599cf9540732eeca134e461bf6992fd6463b67fb62380cce8ef27d1a0ce383d692d3aedb26e703634458040bf2a620bb8aab97467f195c2fbbf9aaae536c6e634e89e8056cc3900ad94d926cc61fbd49d903f7957f02397dcd2033b43c966eb41bb7ab2cf55ef59762e03502dc8eabe3d270fa928712c36347afd489d137774e149ecf43e2cd800d55bc47b88b3e512ec6eaa8810cdc01845fbf6b6232ff088ea3912c7d364be97da5c3416c5cd2c90d898d177338d0881adccc736307e85897f104f6d1c20d5e89704666c452a9f64e199fc1dfa67c5cbc4c80280e0a0c9255bdffeba9ec80eeff2b9aa08ecdf8306b2a78f303c150bc0cbd3a7dc7aaf8d7cb030b6ba3ffaad588f5a6edcbf253efb19b4d167e34cbde63bb4b37bc1781578ccff914acdcdc0ce971da059abaf30aca357a25f1d5eb005a9b466f68018881118ee5970250b0d5737e0f11c15d1e03381c9048fdaf0137e11535a61e0ec00a5bf244e10118d6e62235d74c9462062a2cd561c9028c22ff8f50351d55e619d1745e29209f04f07dc09fa8c5eb2b8444b216a54df3487f279eeca07add5028dab26d4981e1ffcd716116f2ea2c6d89b7631682631684479e4add49528d208931759dee9845238f27972dc48e3d6a8e08aeb41338d101783ed0bf236496fdf6144ad674f52da2c9f51dc7a4884507dbb355b3db330624bd24be550e51094fdda74fbec6e31d2b82551eaae15a88beffc7cb7c3cd5891ee01417cbe85e027aaec2518a64aa1d99cb33f98adcad9390066efa15e7db947d8e6c880b275284271aea5a2a420d1cf8c619b55fb3d5881eb01048783467e63a432f606ba7ecdffa2e09c03d51d4ee5f7249ee3765b9198b2d77385f353475ccd2642d5d27cc4df20652874c36fb08275cf8d62e5ba89a17315018ef2d879fa1c5d4fc9583b557486b542cfa33b9434eb0b27573d9fc28997b132c7c2fee14af62ef7ee5f9cfead5055a624617f3e6edff1e859c251ca72216cae2161480add5c2cbd845278c1bbb57b9e15663b47893869ab771792532149aa03af8b44cdc7f18ab2bd6197aeecea653dc72366ad108faf8549ff9e6a885a6c83342f8c6eebb93f0d6dca819ee0f33959bd82a01f2f9988c0a945c1bfd2d5ee75999979b42c5d985d3df9f43c014f016bdb007c876dd1d5a4b59e2d017850c56d0cc593d4e032376da89471fdb4eae03319d044bcc04d78cc5f180b7e2d3d70e6214310f060cc44acbacaa3fb18d0aa30ae7cd7ce6fc30fc7551b028dc9766a53fa935cf1761f37e06a2b5e322d6763039c6ccf30de21071fecd19c3d7b3f9e0fc4c64bb7372c6114cd51340822c5e3ae26fefdd50fc05751744b7d497bcaa49194639bddf4c741ca1f5813ab739791a94dc3ef473d3d6beda65c2ff1b78b55ea8f56f75fb85518142205606fd1af2171738d63dbd2b61af7fd3e26fe587a3d1dcceaffdf824dbcc44c6b4dc464a11d20d35c48ca399c6f7f5d947f437ab956ecd861f83c9bef80ba46358030e6f4f8cf6ed70a4d90d7f962a80f7301d38d8824b5252da266cbc105a91e8303a9977aef5527a99911cc9ad14d75b45529b0476d22495fee31064365a4d5d0a4a7d410cf8be9d7c656c7f4d14ba2feb341d1646b990bb5bcad40c63b0383020a90951dea1d734ed6c942e73d351396d6fc2caf02de6e013b3bf8e8349cfe8f5a38f1891c20c9d872afdddf6e8c78bf9d56c629d334a91d7102c2bd830f0f21e90f31342fdd5c619e3b27a0b20e9aadb9952b80850705224324f0282c48a28307817f363efc04abbfc142ecce77b4d5fc092b526b4899edb13a3c38072c945a38f14de626f21b9dd558e435be89362ccd8caf4b742bdba8c54131934034d7a313dbfa9783196ef942a1f369ef22d5a8e17d6ea84a4d7419b2e7bdfe2206a39b812cabebfcf934e50da7f75a815e4cbd12422b641c67407cde7ab5a3108fe499c14f922f0d31dcbe5960d1945030ec4383bdd73e2d12d514e775a1b00f1f8940a60d1f49356598c62cf73cdd9204cf1fa70090a7cd04b885a3ed44a927e0fb07166994314801d81b7abd8ef950e806f166cbe504d21dc90485cc9e9f805f1842e19aa76fa6c60e1511fd9800a55a318a943e0dd212435a35828118bc277ab4203991849777b0072ecc88863f1ec7e41d17ec55d935ec80eb58b2527f60172945f3a9c26d1cf6be7c816c2fa457d0f68311ec5d2c4a272bbf5d432ded2c48af8ecf85b02673da2662dc5ce948e92d6d1e11402f84acda297bde7c4b7431623934e3697f3088458045937e04ed4853647d2ff1410172a74e62fa8736c7882bf835cf13f5f272528a6befb483126230630267b1021e1fd3d7dadca1ccaf20a35431aae69441e97d86930ef8663d5886fda1af1ffc5959dea08bd26ea55128c0595b8c7c6ff7bc89c2f915f6e51578fefd6219d9a37109ee508570db09a1a0f2d72776a62472cdb2325c5ee9c4a06d565e806027dfa0f0502e502590bdd48aa181c5270c955fdaec39e6697cc0bdf0f202fc59f37f55340f95add560073850d03a714d676acb9bb08215af869db28b943061b584e6166b3e092289a837f01404066220c2f5051a4faec5b5cfeb6319ecb467c1e6023bc3f5fb1d7c8729908e38a63293c8e158d5bcd8b048b987d210aed1be44a6f423cffffed5458737b79448de5d208710f821f53a5c9f4c173db859201e9cc9389997046d47828f5f082895d8a6d31e0104f57e6f939e76dd1b11195cbb14c9d86273ed74d4e172a4b5893189f96506bc3884e59f6a42db382eec6aff90c413516ded71ddf1b62303581940a2a959f48c80016ae4cc0428a8ef523ff2ec3dc20b36039a3c9ca0958876c9963e91a1734a0b52954c1a03505ce4d164cdb2676569c8baa847d641629964be058050fb74b795dc42e329f965682de06142008d6745569a935518ce0b5f1b86ec636929d5a2b64491d95b9797e513dbe25e60d033f050b95df607143d69c6b27c9c60b3b5732dab376c4c2e0f836debbc2e200858824aabb81d3a8df6ba5fe1846373ae2a1316cd6d25027fc32c9ab49253303907f8513562ea348b861e24e0496ca3cbb24a06fb3594980c7713fecfc1e4bd3d8bd6c7c52c9b921f37e1061953de7b34095b33d4d5f06cfb79390ba7037db5735a6dd1bba5f115555489ea8a3e29de16f087b03fde4dfbd2bb994035f3edf3e956430e549f6e1c1d48cebf1c3f9b1ebc7ecea03f5e94f18ad82b03930ee07242347089dfdcb4ebd553841ed67277c0a22df8adaaac0d66fed0f18c3439e0ef61986d694409ad8971ecfbda1db3a57279b6f57a1f2e29a4ed791419a5f72c4da0dd6b0d8a678cd24b4ae54b1df80be6779745cb61fa75f12323c0b70d090d09eb3fb7f8fa490fd2bb8949e5fe072169cf5922ae10f2e92e8a07b234bf4e79d87c7c5f9b36abfe96c899ac802f5452cc2713ab812bf8fd647caf2a0012f6f0a59ccd6bf1bae310a207211d483f4c99e05b6d3053279fb88c5bcfed746f3e258438db3207c42c2ccb03d91b1f5ed87656f4deff80640b9c025e53c3b7373af31f0b76023bce8b32a3560e7f80e8c5fe0e52c6ac35e4317aba65f329a87b721498c57e9bed8470f5ae0cfcf1cf5975b6277a4ff67e167b746b4288db02e7fbc29373964c268f8e5cae82f8c27e5e81a740355b1418560708ed5e14c0e3e6e93ede59c5f3c6df5a7df1ffaf7a0c62e6da97bb4fecc1f82295ff310c3d2f28440ab212d2bfed80afbf52e0fd5a1d4313200f7ca8ba67f31fe2f0373e3879f6adad1a380fa2e6e9ed4932ed98b0091086de76d42bb1b42a3dcc7aa941f0714d17f6d256d3b2389a48d9920a561ffea3b79c83eb0ef9787c41f7bf339b5a4f48509935036acd04865b23ec29202782731a804e56d3098b47ae260204a7f10d1602c8ab412a3fce8ac495b184ace315cb4a3255f7dde3958e3c1059ec72929226eb10253c2fc64b60942b98a9748d4aadb8255c1dc3d8a1eb80c27eccaab0166d3755e502eb43aa6e3eef3364cff29c4c93a83468d47a7cb4dcd7a74d8fe8b0e6862c5135208f010514aa42578f8c912cabd64d1670d639ea307fcd8907867620a44966f517cf81a1e732e2ebf1d943d2d43c8a26b08d0e005b272095d4264468671f1eb8c6e4f577d8d6bdc1d08de39b1e61877b1b01199a1f688da68384416021e2c0cbcac49db3c18ddb4593acc33e891613b3de1aacadc9cd631b95c74b1b34a25ca576078db0cf7c2c9b1e77dd44e6db05322f40691c33d357c3fa7e4a482b9f776b855bef5b38e7616f481623454da5b4c67fe9278ee874fd548e495c02b57aa43be5e3eebc276dffb0a76614c74730854cebcac7e75691f9cb25fec209453b4217ee3a7b10e2d52e1f1197e498a9923c394be972de3866f1d098b2e5a2ad25e702c5fd9ca9dc4819bf517d429b88d0749a83b18d96e6ef9dac3efaf572e921a027be4ae19d752edf6b224176cadcbdb348cb7a00394965ad02ddea28607117838ba1c207b57a2723d0cee0bf3f2e8c82058dbf7e0b64ea59ceb24027d9e4546fbc91fb2c80d05adcd6102952f2cd7c49cd8cce7cebe1205877edd96233b5a9713a971e235042c2f3a17ee96d32be224e33d798d505b613c1ad188ccb773f9a8fd05e1336391d71f0718b3b25c02d52fe6007923a19051450c5e2d9ee24da847e239a1994be2faa875889e7cf02e390e4ba384b36034d1b28665fb1cbd216b5ea7d3b92dd60c0e6a1cd0b147d01d07a3c031b68d609af14f9c9a97156a71e3f87fd990fc7037119b824af4bd06f981608966898109c0277392ee1a5de41eae11d5a2408d439604769c960704b23d645711cbc1e9adaf562248c2902217c5823f831dbdf9d6b0d4f3b8fbd2ba614d6c88dab760251607d6c6d8eae780d15d283d04432e8f076c9d51744d954b4d3526e50b47081a17ed9b8ca684dc75ae55a1286d930d2e22c0a14c9c82b47d08ca0a65f1bf03dc4130329d866522f6d1f2ae8f91d3c7571cfe796a0377f588d5c073b235892dcd7bc94fede1843d4d3656fca9de5fa1adcf1ce25c900313c5466e24da2780d136c4961e14ca6fc17af7aa30772a985380944f435afdf5bac35248964bf8cd86acdeca80c75f0c709290d3498e1b621b1034cb8c5efda2b50ac9c04c82652b9c6d58a6559f6d0a1874d1bc4a42f91a1eb5e34e3cc349eea1c95905ad19ecbb5740c7653d9cfc81ff06ace7686c8132ba80731cdafaf236afd816f076b988a36181ba4b5f295e8a7cff3877bb059dbadcb7fe8a9d892cf25a8c126e4b106d6234d185fe88c1c23eabc14469b305fc4dff272dceddea12fc40714e5a312112628b426182b35bd476b383fcd529069f6fb20490be6addd5d01a94589dd91a086ddf44894143537faf81274227085880552536a3bee49f7fed8e827edcc5e6b78916d75e31e333442769324da449c46c83ceb09478a21c262ef622fab96089ac69be223aa59ad99d6a36a016fef6761a124eaf419db2f5109d0c389fa95d1425368ca40f0ed13fd99438501d46ea04733d79999c3edaac50a6764d6d88abd62e864df99a7db84736d2feabb5c35c7c355437ffdc36054f6286e3a799eb348bc5bfb78a2c0bbbd526d73b0163d6f2f86d6b72920c936a4ae82005bf0a1420d68c10e6afacd70969856ff609fa9d49e266e51e116b35560476da698baebac8ca9a7816f24216ef7b1c8c0e44043cfecbb47e7fb868c76c0f9ef051af8c86f9afdea120caeb7f5fe1639eebb23a142734ea296c8654d98448323c0eed88df1f29441def72d30fd25f6cc927d8ce83e65d041f3e58c3952743e62f0b14dac4ce46ad98f458ae18cb3cd224ea1da4409090a21f9cc4d83eec3bcbfa2309b66fbd7f97848ba66ff9cba3b2ead4eb2addb0bf4d04e76e1608c7892d7d54e666a4998a4ed9b3e658017e10462448e1773b007600f779fe545c84bc5111a1b86fcb7323cff25c1d1dcdceaa4e807add63822937bc607a4aace73b5b799824deb35a1e70e9c2fcc1a9ee953c4cd179942b8d018c6aaeab3b78a0fa995f7821c56f81a5f2a44d51c4ddb1e1d6b7e000eb90d7ac8d741ef7e77e4fa60546d161f270c933f912b8b254d8e10dfc0cafa17c0614bb08ae7e4d44152c773883e780140106426efe57a6b34b73cfe41f0266b462729de048f09adfbf95b70a9086b4d77200c4435f5b788eec2c3735825659baa6e4854a6cd29893488ce9fe7344d0bae0ef20e3b13c2b7db839648ce566c6c83b977fc94e5cc5c74572adc3623eba5232af2f0956285f480e8f157817e31b3413bdcf8f5070928cad64cca5ac34639bf2c8699245dc25460c72537b860cf6b5431abb9569bd7cda8ce204b445b26ff6b02d290244fad3b0d8d06e3a1e2b1c63537ebcf786314d21b7a6343d402f33efd53219953147b1a2dd204ec3272bb0a05104d15bcf9c58adf852a0ef445dfd7b1213f18aac5598d4c3ac0045e756d2130e46af16c7ddbce9da99227281c5dfb3f586c127ecf3c2852c8829cbd59eb4fa20362ea7d141869a31ef05cb4016243bd02ecea1f78f4cfb5eaae2dccf22d66af6c0218315009d5fa5acbee4ef88bbe060de02e75174a3362b1cf4c7ff3f5e7fb5735b57dc9561a073c444e0daabfc80023ea43b08bb91e0bce7c8a41b2c3c9647c7f72ab1b77c7d4bb85681305c14dd68e5e34d0977121c29fe2d42ea29af31c4bd85bf9d9e35fa6db2a94ed704787440cd090ce63c9c3a79e8940a3ea56f90c1ce253f8fd7a09c19aae81aad9c6948368305859baf523a1b071e1fca4ef31a6dd16fd8e9da9fccf630282df2ce34bbb04c874454c4468937a5b61425c7d6f6867a9c301275bd158ae33fa8028c087f3182982ad7bad159e92009b6ce9cd3ddbdb02131fc6eb913457853384272e9b52c1e0f204e209610b3e6cf7682fca053f95592c56a1c64a32496cdbd282704c9a38c4c337220db221d050816d688fd76f2d2001bba617977460d817b62cd50e63c3a3ba8e9095c5bc4a628e9f75cec30348f9780cde9bd10d06e864","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
