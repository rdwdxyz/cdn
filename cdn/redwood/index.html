<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"968aa30b2b8303b474f919adf768cc3457caa7f18ca763cd9a14715edd8af2f78bafa6edc62befeb091348c59097ab8d3b8e19a1d7bfca7b4a8892d07ec79690e4ed9dff97b1512d62c8924417bafc8549cabdcc5f8bb8f58904c81bb47e3780d4b908d38e97e2356d0227f83f64edfd20585923a93b8cb4af60557e1c074ec0e238dfba8c0b73f89ef2a54f1a6365d3b61d427a223ae3524e29b9cd8587ba2c6b8ce5b8827b99ecc9f752191f7febbab97d048aba9d71d0b0f344e3a3c56013ee6355b0298db19236d8ccd0d42c89d4aabee141d4011c9b7b517bc89e448c2a724cbff26638d8ad0a7d40c18db6271112c1b8a2db5a303955424f440ff217ba2d24027604e3f845af1a55d990c6117c69aab1f0665aeb1cf0c789486d71de41bb15b35b49669392e81783b38ac50b7172bacbe668886ccd013a8bb22b5abc5f16c823657a7de1498d2c7ab5fdb899805f0a6c5501aa6ab25ddb60f8e435d38b9bdcbab06f8aee53af5d7bf0c02d06fa6c86e4e5ba457063dc2e94ae24e19d6cc38da47aa8885c0930d06b18082ee2cc71054ba9186a72dbf64acbe7adf0160ed836de1007cd2540d50c0dc9f6c59eb7e2d15b66e193628462ec01374417058587041e6e4a99c7b76d7ea3112e71f4b19400f2d6b86fbc40d3f09d46786b3a6c9239aac2cf9c6cb88fe5c596cdfec0968d58a521a49b6f2d27915d7c0bf4899366f09aa1161ec3656ba2285682ff8230d1090bc580e3c1713aa62c0bf43bf6c41fda03755b298a0251c6406ce6ae2dd12b2436d2a38a73df0c4ca931466fd40ed8a06eeff9d40eace85c77bf02cc2b411f533f9f62e24afc68a3f9e653a0855aa08e7db6f5b5348fc9dc6e07cc8f2a2388c4f5db4a8f1ce664558fbbe0342ada67e94d22c9176d709c363fbd7c21125562a2fb744a435c61e3bea1f0a1134d928dce690394b02dd7aa8468b48b31d80c57bac5a017f8ce62b32c6a298056ff2676c57653ccd49ef0c6678ec081812e2185ba5c492a6373cf82bdc8f8297322f8ad63da2b0dbd0aeca06e6f7d4ef19df1dabe4371bcfcbf7d5812bb029ee2164f24aadd8cd3d253689f9e51fa1f230af1db4e8fa9f922f661f9feb4d8a8241cc986401099c03cd86d4df01435ffde00e31021e878064997697bcb06cdda8aaf575bb3646ca2abda1d8014b9864f86de9fa5b9ff66e964b0653d0d705d8fdae49852a90581df98cd6c32690d90acd1026a546265b4959d7a9774fac5c53788fa90a296c80edae85b48840c2ba07f4dd0e1ed4fa995d7f2a1c3a690616901861e3e39cc10a586d6a0e2ae5e1b8959a45fa7f1f4cdcfe019ab767ec6f5bb0dfa950491b40ec9155bace04f713a6a4cc1a4741863b5487e039f0f3fc4fa3b6d533d5412b2b3e54f9f4a870893b7e42e5de96289b394c891a961ceb36206d999be498606a93eaaf7f4385a4528718817629d565676054f368d89b628d5dcaf1000d8816315e668764be7fa9b1b9613eebb25208b4cd3cfb34348c9fc799d400965f334728b902c92734238371c53cc7a1bcc90faaeef5ecf1b9edb67f2afa3cb8e5004ec78a5dd04893b4a18d414611e58699e7c03703c3a57f97ddb57213d6253f7e414000f9c4a976e762cdf9bf121401292ca64d5b9d3c0324eef928ecc09bd7e941e933452ef27c0a2a9c3b4b66ca1b76509add665a3c56e4dbe776b3b2793972b64c59a24fb8e4e52925d36692d41685019b5492c4c2529fa4b774f58c242a80a2097b4e9f972c376d9a98fea13918c402c7919691992b1a1a47abfc72202b3d07e31ba6616c84c3f9cd9366675d44f6df6f276f542f14933ac047b8e095b1cdbc807fa423e65ba27691fd06cfda0e0e841be2e520d59cb93c2d3de148ea43f7d605182162546ada9b36ccc0ffeec1222ce68f4d05e2bb64cff05bcb551d0c806516360d0506bb2afff5d8531baaca5ec389b8645b1a207c25be4f98ecee85489fd0134df44cbcbce9973f56eeeefa43b87eb2de43c0ab809076a5e134a866f16f3eacd27a4a28e455b02a736a750e811944f68f2adf2f25bf61ed24076fc04255e68b59c523def63029a8ed5ce109a4134febb0a6553c80463ba45c254eb60474a0bf00fbdb11fac83850f9540e425e31ebbe864dadb79f20ef5acb4ffe7c29694fd042112867bb77d83d24301c3903d51be5f82409164de5c08b9f0d3aac46f350d942b7b50bbe4348716c0bddf2e6b1805a786bf8cc0700221472794f2f2f8d0d38eaa212a2a9e77a33e27c86b44e13d120cdf4a4c72ffb0a89ee406d1acfcdc198b3a779adc2f4025654912c992c178d703c92999ffd767c91b47411224b74b4b658aa09b97972db1f9c707dac7679773194f784dc2492cd695f1a8abd8346035de5df0e201179f884f8fcec9eb9197e5d66f67fd29dac5bc694094e2006caa3d690a11365c3685cae84dc78f914f8d2002082afdfe3fea3bb3562525d133d8cf6f81cad4fc87d7068a46359e8727096d25b97516d4881c98da71934bfeeff3d8553dcdac79b5814bcfd57c9452bab2e2b2dd0edeaf7c25258eae674cec3a230776e32fd70ca26f7e7380ae1b9c0d11e7b4d51331a59ace3588ad6fe91088d9edae03e148558cb749bd57e45a0de220e6e49c5d29418360ca4e74dcdd552e1d684d37ca202bdf39e77b2dc41b3d6e5990027799e7aa222d3370b9692a7a2a6343f3405a94733e6e3f226249fcba0adb690b5e86f6b3d291432b792d4c0bb32aa0e4483ce6830f114a45e470e07a01a1a81c3d24a9b68d5c8af5be71798273a3fec191c61407a10562fad5edcd9853f73830243af16f16d5f19f96112b97886a7d00aedd7c1adfa8fe0c8f518aa5f8b5fd57a3840e94a45c812d13103cf85510c7c3170bb500b7c6c19411f504aa5181ebaf7b7d5e950fe3489bee03010239a33e358b562e878d156824712fadd490a57551d3808504f8875fcba8e6a7c74d8de842a664105a36320a06b0f8ae033ae6ef9331a98138afb310ae531dd217a00776324a02541d261c2eed366707f8a12d947bb672847a5d60435badc85b9d23c931b559838f700cae79fb66863d61937b5379c139bdcc40107d7db1566f0c26e38387ebb6ba0611a6f52582e377fdb6f110854025d5d39d8887cfb33be6c29641a058e2dd26dbab6793a27eefb6cc30025a6c227e480bf9614c81cbb9f0a2b4f725b47749451bab11fcd98eae837babb31c85db4c0930d4997060b4680f5af6251fac64706b72d508b6313b0109769ef24916425430b14ac546c6a4b9e725ced963123e68b788e17d9eb8b0a5e22e529c13d0b1f851c9a629ec9b975b9ff4e386305e65503b024f1ed95a624c50dc3fe558fcdaf2b4622154e091e18d423e3d1d59d3f405df96ce430e350849230c597fc0578403f271c45ab4ce058b83e6bf70edfba0ccb30727059550cc1b2cb3f3fa5c061529fc2d3e10f171a479e91638b9bfc6b9fcd32baf8da9c362266b17e8e09fbfe008fa33686e7edb6d757fdf7f7deb0b58b60517e559b41abf02331570a10f460b4a65bef5ef893582489d2714d3659d8b6892f959ce62fd70857ffb1a392050e321832c61cfa1e37b74d06ee2568ee2802cb677ac63b86bb035a78494ac89134422cf8a111da29767994c897d39f8b507ea0f3f0d2386494ccc54eb6bcbcec7e501097c56f3c9f8a7733505b23fd8374b47589e94248668056b58ee951cd6e3d920f0c589bc2be82d845e74d341d3c099547262f5236ae0f0e456a734bd938e1ccdb90ec9bb325056c4f41785ac6e791b4a5ba956986804ce241ff9e244c978cab9e84db6d5a81504b3252df565be7e5ddbf8202d489c070aba2d72722b65d9ccad26373b4b603173b5ea18f2c8d45cc0ae41e26775cb9b83ce7f45397b591b5ab29aa0a442a76477d155da2ff03f8fd013082613eb41eb0806ada18919faa1e6edb87a1a7ce307fa697a2cbd6976d0f6f89d5c341b1238c2d80093358208e4c90a348da91506a5d284099c2b890ca0c779e2d0f7db9d513f37e6678993efebad234cc6da0e29c714fb2a32e3ec74b5ff032264f1aa51a35abdd8eb6fdfce51cdd11b8be224b2b2185babe8a499ec99db9fae3442522a6f1f59787083d1a365f98ba5087f36fbbfb2b205ed61ceea56207c0f59f5c937ad67d8d061e0b2b6e4d9444d42c06ae4e2b51d75610638f12a3000485e068f9aa9b0ff7b5f9f14f2fc54ad8e4d6d3fecc6d2b3a4efc9a0b9db7180674f0ec044a537b1d8399c716b0d7ddf9eb9f29a86412c0543406b05407bdef26e4451e6109a1ee1f5d0ea9f6e11c7addc06e0c48d4c3a94248505ef4bac554f23067e83216ccb9cee271907fa91797e748332ce9ae81dad635fd1be8b08d1237870bc5662c14fb75288bee16a7dd63cb0a939fb75a9063571601658c2cd505146750b205926f23424015bc2255c16e03d3987229af783282b47c395bc77585c5eca9313294b659d1746174dc5fd18e54eba5c8052f8bc8be516ba0195c2f805fc39e81522744016f52170662103c434ea74cc5e5ad4c7cc4149349e4aa1a2f8df6328bc731c0672e71f13573befa9ac7d7d8f83ffb24ae4532efdb7cfb953980e3301d87e7cffd7aafb7218e47db1dab4f986ba5a13af48370e52426908d58b886470f9c135bd373d016197456fab85d453de64980022fb3f3973163a0132970f00be675d80a2a084d3eea7417f50d6f215f9dcd8921102e2438f5fbc076445bdf0bb191693261ec06f249075f9ce1c14254238e5fe648f7aa1331868b3576f3a948dc6229c5fffef82fe216b6ae2adcb93df446cdf9f16487869b6a9a2848cdcad28a2ec283d6acba0867d29743f10151a2377023878aa08a0e3d16f0a92a9a348f3825eba034282dbcc980ae56d112e46b9107acefaf6d23bdb759c8a89d033c1731908ba4d1d4f8e1821caf67992fcefec07698bf5ff720d757f7c0e317785c4b829315d5dca4915bf8a05e546a0099f5f701cdf3cadd4cd15c03e8a594756e44b896b668d097e4b677bbdcc210a29d616d7a11995b6aead5808872110e26d755dbbce5bcc3e9ff3c597630b66e5fd727199f5e5921c7a7f40702f53162ad476808032843a0b36bdb45108ba37ddcab19d252b6c1362a907f2337781a579403cfda363ea78f23b7f12b3f539441f3f1bb88022ce8ce3b07c021a882d14d1266dabde1e5ee3fdc834a67d7e022b38c98a04f2b8607dac74821020b09b3e2a5b1794378825a8d6ea5553c715831bc0c83ce18cab6526de936c87878473f3881a5034cb81864820ae9d63b520dc4dd50deb8115412272dcb3460a2d980a258181ba26e695cb2c3caa8fb8aaf6718781187ae276996410a4d2914b48a664bd5e52dc3e680cb566e1f0da9ebfaa79438322d17c2cfb2dc619e61890b19f953376c633e02659a6c6a22266993d2f839c02ce7c5e44184470c65a8ac505566f01eefcb8b38428c45e129df7bc22ed19d733adc4fdb250bb3e1d91f9d89aa6b3c833dc3c9a7812de4d957eb00c85b521591bf11f5ec99c57b27ddfe95eda79c31b6def6891a8226730f3709a65f36d8182a567882d9214728c387d45eb1990e7d602c3624cbdfa172b7ee4e5cfa5017ad71e403e1784cb41084ca2990a7a7a0ac465968a50fcb9a2a906f34fea37d12bad774ca3d397884492b953368f963cde39d08194ad59c65b8c8e4cf72d3c3bdb6688f13cc548b21d7ba3be6f3013c42a513e8e9f11711e7d863b6a72875529103487eed15db4aefb674661f7bebf8520999aebcb9021bf4e372acf68a19907e6410b03faf3f53d194dcecdadd7a514bf8169245ad3bdecac3ac17fbd3b228758f3c1b5cefa9252a6068b96b459f7e09cc50a93d2d13bd3f75df73917d67a11dfd3bf188b1961e6ad8df2a475365a85e9e5ed03965bbbd1a2c83310ec8e90c601d69243cadec2d84097bc1f6de0f3464359daadd7b01c2ec0bf0a6e1e978789bfbe10c48fef46653347a43cafc53974651690a9d52cdafa46444eaad9725fda70834eecf1a695b3ab45359fbd8124d81ed1d024d37916de5a89f25b48fc64ec298db81bad80e553b2bb241d0c432fbc1a32285d77abfa1135ffaa0571dc914c5f0ab46f3dd9212247115546913eab7551bddf844b3ac583c7a4e995197761200c5ed13638ddf16c1dd3a92a7246a9f6103c8845f6b3b3dfde79fa0f4a39d5422bec62ccc4449b7ade8a651fa318f742d25e7d758c89ff748cb45fddaab2ddf44be3f08b5fea68fd57dac10d28be9e0b75c409f500c39fee0e3294d564db4d472376c432e27ecf69c09f339af6eaac5c3fd444f8bd34aa3b6b3cc7250a4cc5267ce3e55a16dfce3b4f0b35bdaeba72f4e2ae2e4a48a139942946f506a5603ff60acbfff8cc5555e0c39bdd18fb2e14c8c611e45060f1c70acd4951ec4f7a80b0dfa91e30c8da06c740fc65ca592e10f639d2c5fb15016fa338db24853d76191258a16b599014f194aee53922da34822a79d7227dcaa37997fb343ab7d9fd0d6debf0ba7931f9a82868134e3ba960b50784a16164fb33ea251cf42581328966e00b6b635afedcf81862679bf01ae15115acc97234c3af893289390a4882962ae1717452a95160a3f8b08a2758e6ce62709c030bc7f360647af2ca68fe8b07f28976ea0fbc2d4f41651049b63bbac38bcaf57bc3464dbbe409374013f3e8af22de5652f092bced8629b748d514634f9fb98209606cc1869cb626d26564fc13fff571f1bfc9739d548e28ef7b8338fd854712cd4d015711c722949b65ac4806cb8c334653cf94eefd16274b1dc357e00a905f5e100a742e38c6495ca71c685fae800aebcac943bed0b60a9e2a91346cb6a6da6579677d37631c92d7b83d4cc342c88a689372cd5a688a0f043cd615c4ecf6cb610dc4e639079ac812105e953f54455ae8fe390312f985e3cd3c15b7315d9ac61d7a22f7d717b0a0935fcb32368c758a7ad654e36286604b8e4a2b2b1bee13149b9740ebd6e91bda5295d3a1aad3a19fa2a789503260d601ba7d2108a89ce47e0095ec99b5cd511df026515c86a807b5d3d211e8508c8507240c9af1722df8cda6113d38bba63678afe95c7cf55921c2d8d89b193bd29bfaa697aa8fded1581f12b647be689e13ac919ab4ca89f48088eb2e5cd19ecb3645c543d5a83d64749b45a0051cb984eb9d8bf6f901219689dbdb1cc20f715f89ae2505caa52b549dd9937a6961be91152b1792e7ca17ef585cfdefdd082b375ef8aec35e3dd216c9ff7d7f7a56e1fc62d7afa591da9d7a48c06bfe837a309f45d51b621eac8402785402170f180a611a56fe84244eebed60a46d7c839a802ab78e8d48ce0528d44597d7988c02cf459f4a8586abc4fd8f6cb77702deac182407d4c3341499d4b645fb9b340a1bf89869c49f7e72e472364c1d11d1552f26968029b630a8f58f5656514c7881a431899c847a07f0266e9b26a65b5138a58cde5ced3824d5f432bc6706b9f08e2c53e3f1e4f33d5c46d6e70d4ac2223e8c6283435c253f120f618a9e8005a9523f12e12e392b780b5b9708cedfdea7b560904667442d6dc746dc79219f1688a7418e525b302ec0736d09c551a00154a542386091ce5f109747ac229bc160487091fd1e374a2acd00dfc1f893f55b02f35418dd1322f2d98d1d47b4b6e5f7200ae1b5aa6eca38c15ff9138d4016ac601ae89b6425faeb51567beda852629cab373db9bfd74fbfbe6aec5dde4788075e5dad46983046e09694bc7fb3b7f4c707a46aba379b35e3d7be16348eb975fd0e45aeb383f749dda4cf2ea95e314ce742926a16916336277b2e3ba139db2d92d5295eea09051ad22b9dc01d3a6dfa2d78bd8c1eb2952f9e86d866f2977cf083ef45a83a24f5a3981220a79d135558f27e77a5bd9e6a80be62b26ce9d6387a70b94b40099f68a0df73a7a47829bf6b5da5d9e65e5ad4530189a2f9f461ec324d3a38c0a9b5fefc5d37a1443272516ca4b1057b587e44ee15741dadab3f541190b49e0b11b912867116a4fc7526a6fb7258dd0fad6dcf0fce0d89bc35e6066186ec11e24d1b182893a27ca1d1ba2448f732bb931a2b1dcb8b4bbdbb085aa11cdc75ae41fede2cefddc6056d4b605d5b2f6158f28324135bb5fd92e533018c2183abf3c073756e4dcaab7be41d7e76f0118c255351c7cfcdc74e676d3900db79b947c513229c21e32b9a1767d16471ca04c92504941f47fac30512a02d4622637b52a2573c49aa51b8ce0a196b277cfe1bc58a51b50acee5415f0a96b6806800dc136a794dde48c2584ac41fec2d30e51bbf62f5c298c18fc638e81983929684a7508ee0975b4d38fc2c11e6719fe5d665134fa717bfdbfe29e2a4a5dbee55c1693b202b46e6131fdf8140fcfa57f0d71568532e2aba13d7de1ae4a86f227f354dec1903580b4383a9cafe69e0de0967b1605898578c8a48730dbf1da28ffb068c632b7c4359d2e7d71d36792bb9c09b2404592c18aee97b078c991b48ad7770bcc2cdb297912d0d26018842b471d4adb436a934bf4b611cd541fb209d59899dd55cef50dc53429b547bcd7353420a0d3f29d58a0555d44e8c69544dad46c36f34126c1c22daadbae5a5a934840d2578ffd73c8330e30e109329f771d6330e0ddbe0a259e85fe5b10c0ff03ea45ac31aedcc419d88f3a441df7e27999390f6092d26e85bf07cbe4f46f08ad0d53e7a06baf0b3840a9738eac7b38c232f4243e24526eb392dd0e77ac9419ca38e6d0b63d04e53aaf7feaa6bb64ee3e573ba280b7e4907212de80eb65907421b79c9a40658f760771dbb83cf99ecd352d8a5b4ab23407ff51854f91caf295c5f624416eba83158373cc27ec9678c6538c7d182514dd72d51ee18895a89c2f89f119f3b24006b357cf5466cb3db869d286311a43297959ba7f0dffb3a38b37389475e0582ffde27cd1af71a8d0fdb9f287568b8f7438f8abf1435ac7b2c2a57ceb522ee5aa087a2b84fa1b396a696266fec2f70c6a31b5396005786efc993f9ea596640f73e4ed4c67ccf775e47643c7b9c04a71e7790a0c7812278c3e75fb49848745a86f19729367a1ca8254652ab3a0b414cb571c163fa9bc03a851d7472df3e1ac42d0d306846d763f8d9859c41cccea441aa683d4f9fbe51561e4f9454f3ae4e11bb8c09fd339da770205c5db233b306f1cd910adc43b28f69a0db9756d813826a903a44b5f6beb350049b2e161b89533a8d4a22ba2336a2f42c47ac9e6d82e240d412b334812579d7b65f2d0b9f8b862efbe4ee0ef0505260721de5df700c458ae2b5ba0c7246bf99bdb81041434f41e0ed96467406bb425cf16f12ea2a47d9822526b520e8d4ad5d47a201f5a72dacd91bf5dcc3441a4db5e7a468496758488a3e46d901b8c41d110a00718f502e6a57e56623d6b66bebd76f6fd3f437a1d32de014e6c1b3aee8d84c3126ee69234f7bf673173ac9e2b16e3c785a1fd82d91d054077771fdb101386a8438be2653f6e1b45c3758f09487d78b6d916a5b8f4a1ea4c0702ae72394866d2c5d19b76a66f257cdde37a93c0b5cb44c71a3c904b42f48f2d256d7bc83a4e43d68bb4a3c06a87e0dd41a245aaf9aa97e342d8dfad9c4be2e3eacd4bfd48c367f3b76c4be3b948a7d49b5920de3a13d18caec55448131434a30b3c1509172496690dc89eb49368020c7742fe9af388fc77d83905428d5a7dfb595a7842be596d620bb1c28a914bb2d86db7d74f0d35e097b2f7e9cb09c768d4faecf5b84dcd8e2ac183ad87c6996201d002b204297242c34a954c06af3cd002cc97af2c9e1c24a54d2111425b093b1ebfa669455b07a685fdfa46358756c037ea8de97e84160714ec21240e809509ed69b7aedae3a9f055fb4c7186f4e1ad219c805efb02ca6e08c1693f4e37d9d11f865e89b3232aeb9f68d99e3acbea3a8eea7609b7ce94d37ae6df786c4f41fa9eeadb557acd310f287bb928bc6ea4a1b325db5353b0290985fddc0b2ba8839417a9a7cc8c5cd905413c5d3c9ae652633af28903e6b44553150a5506e440e9e5f403744a1d9b104f90b7af83853bc74a584e715cdd828cbdae5b715ddbb6e5a7784332dac485aa4172d206cd05d007446ab17b5c1427b5bb0b898c17e1aecb7cf6ce58c16687b6deb5b4fa7b6a8355b9c7d0f6a9d872038ee0a730ef3e251eb257fdba8aee75eb0acba63fbacba782680f22735578f603e4dfbdf1ce4bc1c81d0cefd67fd18cdd7e6f7045457ebc6e71960627e543993179ccb576a11fc734cfaef4d5c038d6b101c90d82032d2bf84c4b830c5ccc0a34c37959b3117b9e2b3b19a9ab0243fa321571a0f89b22c22d974c500d1d92ab6213733f643c0715238b97cbab87b680bb3590b5db70506d60dbb6438c0ec5f7f543bf0c503f77c4e38ba851c4ead2793002d9a66fead340cd925fa72c5d065d67dd6e326281988e1aeba1730a5a895f177b50493e39cc33caf890cc226ff340e572009ff0104bd9a9c8df96583d5a6e813d87763b758b0435388f70a1097861631e8fb9b49fdd12162e6c32960d83b60fa206e2e6f70966efdd66f7dd584361ca0637fed7b9bbea64e54ebc35fda49ca6828dcfa206236dbeaeacb0a3a4223d003215ae83a265cf3ecbd7d1fadb7daec9446b4cf83c7b84b683788119b732d2128fd9f6d2d8c1034c7581df174822147dceee218486ab3a05e493c96e33e66693acedcdbf369300d4f71d887fd18a12116ab1302e2313be300353f9b619130bd8e65ad4a6da7f6775a897e966e51cd2b51916aa9606a368b6a7faeadfbd89a77fdcdf65bc576f1b8f89d0a612bfdddd70f80606e6ed5e33cedf9cb66367f4970eb7bb4980159a64cc31aecbd8438200d646904bbf07f7e54bd8460fea3764131a59dec0fb70d3209637adf3c5efce287e42da49851ff8bd657818d1da18a26c7dd05ca53e8687176f1055f8d64630eb510decae56e5ca1d544a0d92b0c2cb5c98f1645f60dc4330f28a46f7cd879f8778f2b78e924597d6a07b5cd78c3279933476a5dc6da210ed3bace432761e13bc0f165481d52e41c18fb05210b2a26afcd5136a700259ed91c36b894fb14431a0b7fa2629044013677e8f71ffebd0e175b8e6c312cebbf0b6a83bee689697f8f2699dd8bc7e9aa21a59b02f4f5a66fff91f64180c1eaa5e075bac72032b890da74d5789cd091259947b46a1477b5503e44b6072ab813374e2743358410b77ebb05a7410bb42753075fa98e86acd68deba6b08132c44dda52903b0f51b9bc4515945de229297445cea84098583726142c13daac7fecfcd30afb830c198df27b81a1970dece3754c08c0be890c7c8611073c3ab715776e76212606167ad79dfdf6a012d105f188e617c4dafd343ae2a0c1d01b1ac1797b9485ab98305ea482d4af28c576b68f873ae11cbb503fe554450098967313760e81a0c1c9cb1596e88cd550dd5d3d75499c2c8861e509438c2816f32adf7e787c4098fe65e06755856a5ab75fd9dddabe8d79f84e22b783fcc85bd033b59321a480f9e25b7b0f69a88fd9d5d97f963978dccc3caf04f7a121c861d54ee2861c9b7cd9a9f98623836cbded9ebbacf82d1d534d84801e973b7c2f8d63c645c3633c0523b1b2c440c6e7059552d02d822466be29247c413b5ccd61b518e6f1946451121932003def4f0bc8ffc413c9b499a3deabb16d61b2f10f53e76a624e94c34b120b5bd24ca97dec55b99aa9780a05f5371e14c120c263099ddfda10d8ff2506200e1fa7db1a58c5f31a68c09347ca43ad0f2597060b415027794607a69774b4bbcf681b3101b2793dd89e15d73e52d6bc6394cfd9a1981dccc7d5107afae24d32c882b043947774e687f8997c6b04a3bc8b80923b8ed85bb3710696db952ace1dcdf6eb96912d2a66c2025478e77d04256a50391aa8ef47fa8f9b586d69fdc80cfb9328eaa46dfbc5a14a4a15742928b19c7bdbeb882f67d4966c06842e9f4eec3870ebe817fff7e7d4e42ca38454a7224edcc123a7c48de7ac43117c874c8ffc5c96a527c94bcebd71a9e501ba0bca0a1394e8861c556c7de8234132b32fbfe03ae5c8620f4f2da0a1a3206aeada4203938e1b1abda8bc32773040ee89d5e5062c2eb02ce7e78a557bfc7159813d9fdde76c094af3f1536e6338ec9948fb0e2f587b5e11e0242bd608fd73d5ff5fcb95b1cb771e9d4d428e476ca10b1358367a1b3a8258898315c87da71e45075b28e3dea0860caaafd1f7a60b55b52557025cfaaacf7d3347be7c82e7afdef67d8467e8c6fe04b107b6e6f8792a322a1b0fb2a00f143d1388b001c42721753b5ac52dcb17c318d6cdec1d7640aa26de0e9d7a658f613f8a929694d88d50007e7ba7001d2433f0b6593ce540d1117c89b44de430b58d649b519b7f4fbfb674da5e933e5dcebc9ea82e449ee333e187afaaeb3d6686899db798a04501366481d651647b4403d2ce21e8c61ae771a3ef3bfc41002ce55e0fd13f6e2b74c44f26357b505c42731664b653c8112677730f12e194bcc8efd75119ef7a1da35c483573a620c9b5a3a615d260c2c8e1b53a741faf873b13ec27682da00f6206fe85a61ffdb41c15ede1dad5bc9207c5cf77af74a390f724a1ea0fc282c147ec32c8abc887202d66d217ba9fb92d6d0e96db8ac4366935e37923ea6894465ff8e6f46a181f513fad3c4a8ee891ed457c309ae92538e7885ad4e227bfbedc043ef13f1e802542202a6084f3438c6a50cafe822bab8db6509da1d375b8d53d800efc985310303cafb24efd484d693b6c7dc994ff651b60753ab0969ca0500a0261ece933a650e274677e320c76de963a6177e46e713510eadc446a6c7a9c9196c874cafc13430abd5b7af20d8e3bd9c0719cf885df556834fbd69045f66bfea53c88ab9f292ce494aa40ef3d9289d941af9c369b652a6d02b45ba875394455acfd0706f8db53dc9cd64d2116599907c4c8e7318bee2c2a2563ac4d968ffc4f6c1753456ee2f692d750207a1bf74a6f1cc171eedb46d2d53782270ec78861f3f72985b8de2a8ef0b17efefe9134915dd47f60b842389c6d6d3f156643b0d327580bae087b1867156178732ed7ddc82567e08b3d218194ed0056c1e93945d914a4d0874bbb18f79f53770e3c7515f72a91027e0f3ae6dabb006a3e03141ff25fd74b919052d5d50370f19bf8cac1f799266d99012e4256ca4b66a8ced1affda98e00dc249ec2ab51fc8646f12c32b497e9b1d2c44da3905084dfd58e11c372d930da0e4df93cd6ba8866c2f3ea324c3e6ed144aae8f518ba14ac85050c4f08b2bdf7af6eebdc5bd3e15aa615889a2ae1080def393beb130dfbb02692ffe69ca8502509676718bbf1cd2f79ce7cee411148c55bc126b0f25b356318e9d75615f8a19a3e9699c0e1b7cdeee0520e689ff6f758b55d2274430e7b5f5a523a18ca519ad6a58cbdb43e96d5d5813c5248bf1447561565016ae123c35ae902b8778dd09c80bf5bef2eedce6dbdd98f36662ed2b6a7297e0dd0f506986b99e9670ab41f9cc270d5aa7c8d4411ff8d14d9ad23268ce0916a2509d85285e7a71e0ded7862b751725179db4bc1c7dfba6cf813f6d7808719254327f1c435291a2607f044cb430f29cddb13ce35718a90a119d6f62c1162b012a7933e848d120c2cd0692fbd26085e607afa8d34b62fc85c94b4e121c5a983bc41793a92e426073e77393de701e0b75949a839bad428cf2c8072a02236d189e8c28124fa1636787375ab52ecac00833bb310e0dd4d14dbb8cb726e2d92b186b6e4d4f97294c00bb08d3aa0fe515fcaccf786709cc67da5649dfc6c7c9c8efe554d12cafc1424e8f2c4d570fea4c98ac4898c0c2d6997f08d33d4a150c62f01bd80fc2daad127770c021ce5c415c8b7a81efe09786e700d0c76528c44ab6845a3d0d8d7af981fb8992f6ebc1ed5b0f29e78e7a257bc9c7ba81baeb170d08023dd6c2db966b519477e9021470f1f406ea2e79bc61e22fe3e7cfe1b85c880d7787959ce3a6015eb5d395323de263a93d34de62c351162158396420dffbd9017a08a1841f185a5700b045c131202e60c8fc7641e7d11cfd3f1af2441e9a667d7e6c030921df296fead4e885752f1b311ffe4da092480f8f38cbab9a415a27a40641a3ef4864e99d92b15b0ea92fab78f13825895a4c0c78a3fe81f7cf3810adf5689a9f090a53468d8b14acf902db13fd08d4dc82991d319508a7690f74feea7d44ea4dd1ba6e4e7a7bb2d0ccf8b76755cdd11165a37b3427be4ca269d5f98023a445783dc7aced619d4060c1bb467ca6d8ec78cd14ce4d3ed2cde894115e5b542fd87f0430dfc06eb3029f45b9e97b5e3490569e2d197fb45fb3be3ff1277d320234ee7038d53ed6857ebe2b808e0fcc9d090dfacd97f465157cc93ca9617d99bb93558a8985d1ec4b8ff6e47ccdc70547adc79b6812349f96483f6b1eff66f1d794503a572c25dc582fc7f796e1df798973a65e4556ccb7b655dab079458710cd4eece42926fbed3e1961fdf207de652f609e55765cb24150a82b23e33d32cb790f4c1616adc6d604d640ce0cb1d288f911b29afc7970c53caf04c9099b836dcac5bb0e355792ae11cd703af447c41c495ee12c7267c2b23305410dd5d964f3a6c177c021c8fc9123d61120a91a96acd97834e700c06ec6ded066852d470cf931eb6c072d5c268f488ee93928071cdc0c5de30880769e2f5135c65e237db5fd6b19c8a389d36b5a241bd9dc6bcba6b711f0fdeafbcff08ab128d954ba119a9dea556e982c336854ea5d3a6daefdc1abc4803473dc1c258134561427cb4d6b775ec4286580ac93bd18d190a6b5ac3a82e9cb799e7328a1c07aa51fd767ce90feb71e5c5acd638dacbac15fc04dec983c65cfbcf8327b7d06c4a9249f2c4936d05535598be9c850a3ae29d763f07ef67bd3dc8855b6b64a86a5e0e5552b62236c7dc1cc06250bbb3bc9e41393511c409f5863ea3e14f658111a451b0a6f4b712f65ed133199078f777eb5b1da4afc858113b6ad6cae51e8d941999c4df4238f86c1cff3b55b14f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
