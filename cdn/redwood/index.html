<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71d3ebfcd8d20496d89b113ffc87c8bcbc62e579a962ef1e1ad9250c94657be6e2a5490cdbaf5bc2c21199d351801a219eb036ffb160ee89ad8261745377bfe8f53858de6f9cd23bb2cf06bfb76a5e350badb6baa8b6a5820d55882a544d7c7c1ada61b53b869737541e1fed4b8613f6eb0f8bed2bce7c68bba667b137da6e71159c2f0669aaeb57aab73806d9a0b5912e3880783e25adb09c1dfbd103aa23bbd7cd58d34c2798d0606f68d2166d80f1a7b7db6ef89bde2dc42457b46a63ac02ad6191303f0c3ba12fb7ee515e2cd1b312d2b637e54ac1db81fdf80438255744f6e6489e034606d07c14823257b4e1c3550b45ae92c2961487d9767f9b853920fb99299a3acfabd126a6aeafdf538253854aa85af5e9b5d6c05be3f6e022ef1697cb2f764d31872825f5925e9279ecde9ff0a75aa52ae446f3ae390a89c82324d6a74999d74b1f9f5ff9e25eba36d6993581761a16a08a82d8f089e6c84396fae8834870b38d2ed577a9c92f11abb0c7389902a6f448bf98f649060c6c45131821b34586f410bb1fd232ebfc6520dd89454a76952c86fa0d9cb856285f40131476f34cbd39573cb00402ed2f4abd8596a9d7cc7a560e5f05c6f31def2aec678a36d2674166b19f94538f1bd919139ac4c26de6355d6a6d7437f3fcdfc27e9e7c85e60da677975caa345bfebe73789c213d1f1ccdd3dbcd79e97d93099773cd93aab9f5a953f9ed09a6f203574065e4010f33dbbc4561d4aac7a21d093be07adb8fd66a4e2086bbfa539fd3f0e57cb662972e30c3a000aec70cbc3b8938d8de69b1fd3976e267460304933d1735e0179f7b76ec0304a9d41e0f96b8baf4b97f1137823d8e58cba216ab44979fcce92e53a403b889a6c34f9a505d5cdda74c811c2e6a6555f7293fb3d3a20a73d1d1f0f06621e6098e052756e7480e4f6457ddfe62a54b6d1dbb8e4255bb745967130c509295da15eeb5182e6a68309598734c5f272c2498b67732103c29661b1849ceffb66494b47dc6fe9229e3ba02ed007308147b91f64775e6274f46809d88b2400c7bcadb803819d6c52ff8b4528efd54e35ab5650c4d757b43a7bd7d90132c948ab83014445e5caefeb40d2f31c9b4f8972750b7602646504d2616d194d55bbe6039c36c8730fb9045ae090e74cdbd617d979a8d008cfeb7dcc137ccb194ade3bf3ace674b835209e25c1658e8b29bd307fabe639760a9db7a0bcd819dcedeb78a5d611612ec71a3cd9eb6b5069db822ceb791a8c8a3ad8e86ffa80cbf45d5181796691e6e53691221512a189edc42b12863604158c15cfdda84a9df81bb035125fa40d39d53e5afb309faaa1d5d94a36d7383ac0da0852b1e750aeaebc30ffe3c824d655097fa7b39031875446991a71d18e38aa57c93d1c26275d455fde5eb3c2a5671540838e7395457c12d7bb656d5bc3515a60121915558b73b9a4fea7ae60a186f47885e3f048caba3b18aec6630b01acace5611e995703d4c95f9c336b68c9e1b4adcc4e84133d45fc579b2aeafe60227569dd75fdfa4ae90a58e4bcfa3d8835f8a1010c92e2d200d94f01289658b0da4d9f737e31a2023d03ed3cbd185c5d60c2d38d9d219bf23579b9279694c6adfff7839197a50bd1bc72cf368fe7537d7d4bb777898b08d8a32a75e7df4581235f1047c7d687ef4395b51dbd571346c505f9ab11927c612de443b593166f2ee1e27f2fe4ba06f6c79a12412c1ae642f5417a2b3380ebedb55b0c1444ccd9565bc9335a0a23f29e55ec387305d4bbda7f0943a7de199132447ce864ebe5d6850f9e3a5cb029f8f18fb5b76818e58727967acfe68b0773b560fe79426fca96178e926d75a2d96f68f42d7fddeaa478252d77c224fcd42795be1cd0488ce993dcca966a41f06dd7b3c8a08ea5f7fd6bdb309bd4e3da8278b6412924169d3f21ddfb65c076c2e26ce9460051a0969c52d7fd54d603147d6411a27927ddbd91b50f8b0670aff70c4cccfdc70e48e05c46b5a72fbec5fe578fd0bb2d89f1a76d599a2bd7fc658bc76c276091026b2f0f209690b29b79e2cf12e970be17d7bf8d336ed2edc29d79dd9549108d6e5df10699dcd1ba328d085e12f6ee5d0f50ad57d8bedd8c24a0ac15e2e98ee80a951135e7a7ec8bc9d5dbb072a646fdd27cbf8dc2387d76bdf2b87bbf3d09c209ca9e9123ce946d9c6efbdec336d90f8a5de87b035cbd6b722a2cd1cff1065f055822ee20395d2c8d67177f656bf9718791043c51b25143bd87c6cad1afabd466adb35f792a4c49ec03d4483e5b1370b377bf91a1ea3453d15d388b51892db3ea075ae2374bedfa80e19b81dc4407ea50316b3c922f5e737d576895ac63bb5de46989e271574add1cdf6ed3266ae199acebb871e3e82fc5f146e6b3719bd6d4850d72543940a478f717b50a60d374e97edcac2f31eaf304be4a711fea8ad8f621ad364552a5467e067d99a2ca2b4f0f12a7e83258b8a5f934f17a8e13fe6e84ce03a4082a3d2e44757561da9348ff73306c0826b0d78550ba583c466a5d62449a5746015b1e6cf72a665b6f52b3d150381c959645422a7e110f5b9a09b8bebf2882b646920499820ba9814bfa33f1e8b1970f3ca6cbaf9102cfd358e84eeec92e76fe6b5c131445c4d68eb681c68f192978196b6b39f59464f746715f0e719e60c0d4955217894da7197fd90bc2486a8a137d56b8c6715ef28e0fbddc3dd923fc2f0a69e05f61822ae9eacccde1c0d2d7523764c95423449e05eb77f778cfe031f112b36cfeb4ee36a8a2fe964d9e498c4d38b6f2fb04b92c0ba58fd1a21e001f66f061a145a594af8901af1458dad143277c7594f78bfd0a53831b44567e3e85d9d394d5c9bad4049f709a25e93bfdaf31c10a4a3082411a4ba1283557122c99aeefa7b9acef9bcb79877add88f203eb9e45033f4273d26d30b413f7500ea6fb20c00341230461254f246d2481957529e1d82803a41ccc9b1106a69bd039b7ee81b604202f4797c8e69a6f62ad210ba06086add11acd01d6749484b583d6e4efb744557cb6959d2cd684a37a78c9dfca7de27f9a3fd5e5ee4a841fa5ab46248d0492b3e557cdb051bdaaae44be11c4f214bdf13d5d0f6dd9864714806e05f6d0f10ee9389fa70d3b70c224ce06d5186c2961dc504c1e415bb4d8bed3c4dac24dada08cb300abf0375964ef3bf190ead540e39730cd113705601206cecdfb8eeca9064edb0704ab7ebe16700d61793f28f0bcdbf5404399d47340f247297641f3ad76418909907b19af38727369614975e989d19ae405653358c0e74023511ba5c9701bad922e0cf959e8e0b335ad56b7421ca7a24aad1785b157940c20b3c01ea2a7c5b7380e55c602692a3c2e443e51130cce283ff6756a136d74f16429d6d5d765528eb1584b3bd6a5b51d989f2a4f9454b91ad8fc0529229989415ff67c8f74f61db3f73bf0bdbc1902be548901f16a78bdca285c9f836a787e416be5569f01768bd77a7639c751f22ac6f3cfb6567ab5ac1b7996017dc4b36ac375775d94d4ff85be1e2df4337f2ebf2353884225c7b772f22ae116aabb74f04ed8d218bb1e4be8bf3a57d183a9e2c1d8f83c7073538177ae19a80fe3fe04327c3d11a73bdeb7a7793244afca2e8340d7b6aebc416590d806b609111dc01c1231aa2f908747967e79bb77664f272b9a21bdf721c7b9ddb5c5029d571decfd9bac69214036e77ac04a7ed0ac4b4cfcfb162a0755788f535ac55a5885d89e70572d6379db68dcecf675f940bae34b894995aaecb799d33c8c95b0a944bd0a88450141f7c3548fef0744715bf0e319bda4b91fc2b5d9732188ea69f69ea7c53f40b5a6a8ba73dd3b58107f69c998312f3913c817bbae3430dc50f9468b0c0047b177ab47bd72687989cad818480e2d84c1938f71e1a5d491e1ff56f577b6a6e2f49a22d4f7dd26d4c50b6c73805dd9d7f5d3c5b202d468fabbbb563cb1c9a2f81ea17af62f5cbac7edf502f69b48920c727124d2b7b94ebe5767d70c164bd8d5e97368c2138014ad7b0e646821d8a33af4126c41b5d37b4da23a4e5b3b2eecd4cc0d37cbea90a1d7802c4466fcb1e6bef65f38a97ea0eab0ea33844efdd7c8337294c0258f9c88de6dba393602a46b7da59a1172a9c2912546877289f2dcbef7296dd15a73add16c0b62253b153398aee408b7fde563c8b8601c95a5ae80603708519d512941798a0648a43e855b6fbc034afa028be29bb806b2f8e5dad7cdd3c3c0733c758db91d2ef88f853cfbebca463d9be4549c64421107f9d2aded0b38fd7e4b944d497834d728abed504ec73108bbf9d0f8f19994e5604008dff2657c89d06abf995267cf219aab1549a17bfffd1778182b7fadf4882ede3bfe7d17d0888b0a0a5f69084c8adb6c8afa05a99e79b6f47ecbe6116944e1891e946243ab0b7638be8b17d39a2091ede6ce2d11d237ac169bcdb63edefee6dd5b8a0025c9cf9edfed02879d0db697dbb77aa914628752c12ed0a8df5012584a5b8872f68e534f1496c09fe09cca900007dcbb8f2d6048691bc5c229e75d4925a711f744c1084a6e8e960d2d6fcde64c27ac93ea9c931b66abf74f0963cc63b885f44593f092c19188cd1dfb4bdb154291dba792d4ffa0f8b7257c8ccb2b0209e8ff10bfe0e481494d38674a8817cbb27d70314d1af4eac9a45f4e74d03bb33498a8e834cf38210df8d8660ecba97e21a14ff314813a8552138d62a4c00ba27e8f413f93b7f2f00a1ffc223c7dcc9eb0708b8b6d6767fa86805fd770bb699d60e119e9a95b602b19f2c5eaa73d65b970827c7603aaca6d945d0250fe5afa541a30e2b946288859326c3be57a5f947b8d5bebad34a6699d435bdf6d67c4dd70ed6d0c260180c2dca7a47a937bb91634a102924a2b0679216e3092d7cd68c492bffe6339c3379cf8e6a5ac5a77c8869718eaae4206ac9e39e06efc8083c030e2ff4c6216f2f17e2c44a772a448afbb0c06366a3ff6b941c55c77c0812b252b30ba2a35aadfd221e488b8bf3109e8771a634a416418bdf9d92c39ace6499060b3d6e0062ecf248350d8e17f738b79a7e3422146147eff5729cadd1c00a0aaed04302602a49b9dc88cd42b5e5e36da17cf7f4d020aa09e5f1b6c6daab8d7ca2759f22b70620413f29405f00f9501e30b7582adaed000106f30c6aee61bb5d9c401afc4253ef182cf19735ef1890115834025d1c20b0556adb029933c8383891fde36f51db58301b43e0811d5f69935c4978618baa975084e0a3f0d2a849537602465c68c2d9f97c93671aaab0a77d28ac40275ebbf0d2bb1a52fb11f648d12fe65339a92893f0c0cb5e38421f2b86cdab3d9b7e49b2ea9446d3e0c436b89c90cf9f952ce7c6de32826d64c11ee4aab8efba498bff35187a8aef2df6de28e1d47a1818a37441179e18117340fc6993e7665180c50cbb20a0d5723dce4b00a75ed011ea10deb73e02013cd41f8084cceac7630dc2668a66966bf2f0945e1c07b17770fb01225370ac7db254f8ee979a39ce640af7b192dc62ad58190a4c21ac9696810d12c6c3cb84a486b32d09360042f637ba611a4fcb4a20d5713343467250125f48c2d9ac0b5f8e535cdd8f7f4c769b9350878963753ca424f7370a7c627b32e46b1b98d36cb8133320f669f6e01e118d25f4ca8bbceb55ccf1bb5561f00700d8db80495855e6733d309d9c20fabfdc108775de28c23df23a9a30f435ab167eff99e0043395eeebd37c82ad85bfad6de2cc0a56d1f15ca7a5b3d1fe85a6ed4047e3df2b8fddb8635e211c216fb9f2bdfc362f514325852cbdc3562ab867a95ef57d51c4caee834bdc1f203e171fe997326e9869cde7591c1d187ab081bb8fda54a65014da567e557c4139af7dcde001031069257c8076d7c168eac665cf0f95169858336ffb0d7a612526967ec88eda4085c07da726239b9d9695a4ee54a3db01c264796e460b7d90225434f54c28b211a528651186fc1ff611da46fea78a0b39e8597f60905f722be49a64c6be975166de51eac8f18c52dfae51ade226099f18be7d297f64bd64b01e180c7a18dc885413a0d1b3f1d5b6acfdece74534ab3f54e75c8d6da7b12bc41a9bb18bb443f0ba45b5eb4771514b0a2793d33616d3b11c92555e1b6e3f48e06cff423ad80b2592f1c3c45640700e7f26a9918af85e70ac895f79f2b39a8eebbb4b12184a415ef8193fd1fd0a313453121e3de80fae06d032160079074f03c7ca65e1b6127ac3c2335fc0406f3e1f18ce73e0fbf5d05d156baad7d90f91e561b73144b0b91c046973c8bfdef760a85d213623b2703cb563cf05b519da27a3cb89f0ed8b45d6215f15363362f05c254b31ddf631d2f0f8d7b09dd4ef8cf118a393cbc888f04082809416670275d2a5317b287e5a895e84ea83b50016eee7d21536093ebb074d619bd7338bc13b51156e48a425bcf7014d849098bf530ded57b57ae0b651ac0dd78de2e764ab77d30becb53ace13ed8833cbbdaf63c9736462595b890f5ac7b8d45608bbc5847c566619cddf337ea82e38575f021b14fa0bbcaeeea5f7807e88514f2b4d65723bc6f2d24aab7866eb90bd5eb7e90eaba18ec4a40fbecd568d90503a20d3f9daec8cfb4ddb88cdbf9ccfeb48fae4ffeba4c3345e74c9ecdc0c3e65c53d6e0934d4321e34d26f68bc7210778e4b7c4db3367ea3f6b9151777cf909cf4721d7a7aaad3b332cfbbb5c82e44ce6b1e10105afa749536feb3ef9ad8c4e9bafd794fa995babae9b69f0ebf287f92fa47a62f11d9cf83f3b7fce1988cbdcba67e875baf2ed12e2c82ee6fe964633c12cf8ce0e8f4147e4cae780b9338bc08501c55e67d43b1fb39a5ddd1c53113ab5b5a8c4403e3a353e5ef71d7d866e982f8a6164b5b5d5e081eab5a8aac771124954032a0e7b6f0a9f72bc226aede24a7df50de1890343d0d501ae1900362555ea02db1ecf43d871bd94e020e33301b75cfe64d62e08f46cf9ab4984e42255d60bc96e24aa3925982d869ca1eb6dfe03ca2bd2aef521f206c12b3ff0cfbb79f5754a5498773c20090d156c9835340b0f6504fd2360e121d5bc866c55e1c08fadafd84853b61fc05c721d0896721efe51a05399c92a53c60310c2837abbc87fba9d8e5d50cadecc55b9a140159cc0e219881c781155a79f81fe98746d7bdae8a8cc7198227d7adc3b24104ff645e9407043de9c3179ff420544ccd5bf9111411514a1035707eab1bfd177b7980c74889ed682eac3a2c2a534b3f7a5713c9f1b5fc1bd5a3abf90c9c8447be8241e681644a4f5b8e3cdc44b33aea149adb9b532d0a0490e78703f4871bf789fb9b915705360ffe7778c35c750175bcb9fde92cf619a991eb5be673d58d1f7ed1282d79bda82e6d038b15c917267cb9a4f02b66239109c87bf01641c8115c6ef7c4aa5265c8cd972c1b0fad016cfb0d19ce73f7b5bb17716f02e94a7a8f814faab210e1dd750d646e5e4b0124cf4e5f57f3843eaace553ce969e80a74b2dad357534b733a8d6d9caaa3f838f2da6126869d80723a55f56cd92648f281ff086e3874ea291934b572f2f90cf3336efce923ac4c13dc74616dcaf661675c28d416826da20f757de44ca65658a9799f7f2e8c6a13ba1a46bb46dc06ca666cbf409c847f57b449fc636f57bed12fd0ca98c48a55c359bb4d84a634765e1caf741342771e67cb8bf3363f38443bb8e6e0f114b30e4e96c00620b548ed7fef3835b599d7e318a1d2f0d6aee1b889f0b4e915308011d7751262d611c748a554c7a353ebf83dfe26be3d8c1059002241d2a0d0a5e8fc9aea0cbdc689c60a3d2526ced8d5a465368c528ee39a949ed6f41010200be9f84fac813e2b003e7df94d768df78f650cfb321e086e3c0b4e03f7020350e5736166d76f461cbd43c9eac3a0312137baaed68e34e119c4f18f8757760863f0c12ea0a7899bb70b81062f7a254f69053ec54ffeb72ea4e3119347e417b6c6759d269c0a25704f2319da7207886b3b80fdbcec28201a00bd6ff7c84c37dfca93837cef0be4d819d3f7face2819e9741ce509cc9edd91cae4dcdd4ad0be8420173200ea854489bde3cb35eccc4fc5e1ed0a796f2e547eff7d6d535c873aeea307b913310c647aca09ea19d51cb45589a78762fd54e6fe87c1e0b2320ce9081ff05d00eb58c2ac11e2a8adcf0aac2c9b432cd29dba79ba33bdda53ef3e4e11e089ac97546fac0f9c89b62727ae07f2676935d25ebcf4679eb6f9e9d8cc9896529cdae48a6d580a492360682a73027369433f4741af0a7b6f1519ac87e2bf663648f37e3199e58117c93fbe26e401ba278b3a843799de3c8b49508a03e179ce3aa3087fb753a0bd815a99f682b40477a150ad3b0caf88b4ab599a76cbc6ba55ac0ae4680f3a2cdba7f6d6ad1dfc150d4664af1bbb4ef60b7ac05b225fa3fd240993e59eb967974f7c46a7b0749ccaa2da565dc6f1bf5f5e85cff56f31ef13c4bb1968b419143de631dc3f369fb4dc65834aa94e04fff7f700cff68bf6ffdd607fcaca21c2318b2da127b98cbcb69aa770a461bb52bc17b9eea311be22bb8ff0757c6fd18ec02904ef607bd945e40b6fbf6947492f1c31f2e8c0e8425c300243e592f8ba6c01110d4bcab3cffbd141998a67fca78d7d9d6f435ecdc8afd50a628cb06c0e647b8a8695d2572013fb62c56ba5f804662d0bc86534ac7606667a2d67ddb9d50cf1ade9c5aad506978cbe185b2c3904052a57fc1e0f0052606cd2c19de8014430870032902cdb42ed20fb9da027ff2d548305c10ba4cba97165889836426bfe08e362a780b6c042da6cae897743a4437e803d018bafce327e270e09aaf900b1e67a4bfbf315deccfb677f329c01058daa779a67164cb405ec792da0e3913d1189310880c74f108a442c9b30fa94f2cef846af35da72e10525806adf26274d3a3c710a44f19cdc976c456aa37115a896fa7a5e473df62a2236639ffd2a22f7423521a9c93f2621755eeeb05240ea1410dcf120b76d024b598eece278b9bfb4d9584aa1114a362a1d7cc9e5d628e2a6584788d529f7673b0ed7669bb55eafc8ceddb7141322ead50aa5c46838c4abe6883c142e0ba6d2aeda47e0f8becf59a86cf9b0c8115d320f5c30112f53ef5a0fbc5d71125d6fa657ff89266035e34ac58667ea1bc927428b2227d64316fc81ae5d22fbde70f923ef407bc04c69ab330d4df0b84af445a611490db9e93c1d6782f6f6bf1cb3e1cd5acf2b50ca1ad400d99212697ab44d7e4e7136f55a67f6dddfb4e1fddf128a17dcadf10680fc580b99acf9650f09c56192e97e4c235f9056b3e2cf6e9e1ac9292ce59876307b58038f19aea948f9a66a67ee234c2b5ddbf0f54b648951ca78c40fb6cb2e606e075477f2d504f569d10925e66c303a6a2b0c36972cd83ccee78c3e01ac991386bee0bec947577d32e9994e30570dcefd35b2b0fd13e3031dea8515226d9adcceffb66ca83329587b01b3d91796d683f948fef91c989eb8c1af9c2dcdd83738e2502fc80bd6e2203567984e2115c63b0d31a429f8f340bcf8b8d341a79fb9eaee70dbfc62f7239826d575e4f6d27ec806801457d3f6aac16473ae67f2475dacb1504ab801dbfc323eca990098add475c8538dab78fc45803ebbbdd3a25024637b1e8a4c38e796ff3b9c63ef435cf462785f61da723aa1dc3e6214d3ba976c0d97b139c1c3da819ab46ebaa15f9bb30784490f6cbadc9d5d7a22a4da639755f10294d22ca6bb8450d42728ef149783e0c9e9087c889e73aed843eea5f1304fa18b0b538c16cdf3f0fe4b4539b99188a5e1e2ac0633edfd56141acacc9f5c026d8a2d17068f7294fb655514d20a93804909b350ff9e043d8e2085b78dd5f14df4da5dd40a2c69463e7a075d48a2c2a626d5455ad03c1b1f07bb6b66e00c52ad664d03c5739c6a8a409866d8b0fc1e35ade772310ac8e1f73c111ce2e2386f9c87799152edeb296c826e971d2e3e8a8617ba54a534e2de4056506ff8f3565f82a0eb55f609f3126038b990bfe222a80f6af1a9c173fce470953cb1f495b9cfb4e80da328b18046aa8959db97e6c0cb04d3ad6dcb50fb77c8c533cb9dd993b3f3bffee5ba47aa21bd6bec37f0a203a5b2483d6c460b5c5fcaf8f4fe4f0269fb6150ced473913e3760ff78c037d3d5cd8c5b3dfdbe9f11d3d8775c51d14229d64da0300b98c468c225bf930df61edbd93ee9a1299af24b4a473c2474f89d9f3669fe59ce2af6c11a068706549a3136797579b62b4b50584d114b9a7642bd39a251e976a5b873c68458b8de41379442d9396dd9fdbc3d04c078e16e6ceb74a56b9d59230ffcbcf572044bcc37","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
