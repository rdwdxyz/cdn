<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"429dfad221a527f709be877ad9fcfb50cc4bbc6c3596828816bd82f19b366263242ac4e3c65fbcddd912016332c42345b28330416acb81ccf3d5151a88e876f3d81e0959d279429709534a2c898e51559ae58e080b6beffc0da10d33008c53dc0b780107d7b5cc4a444f4ca00ed6b67dcddf32b0efa2079e510f8e57af8be47d02b2122544d8330fdeb4bebb80504fe11568a95e918a685fca4708bc2397c36cbe9266429c9c55bf8798b795ce8e7a1cd2934f5ae1e8ea45205504dfea2a466c8f9f8e31c0142db7381859dbc0605c14e47e7a0fb7b9f4fd2883a256da81f932d2cfd9e48bda0153fec8ff6c466e283bfec61435ccbf3b57665b55a1882b7ebd66e27d30bb250f56fd37b6d68dbae9292d43d68b0a2335b08e88cd14476fc6d3e27f8e3a16fb1eb830dd8248f0ac3d47afb422c6fb9aa2fec2d3011d274c5852e2ee1aab28a4df2d0783a3d0d0a3cf2735c894260cd766f995def5bdda5d3b76590bd1f4f1559936eb076ddf3e2e9a1b1bc4aad6565d0c2e56c9c920999c46e4e3fbe88e546780f75e699ef236066f0070103e6e71afee80c64b15368ee2428b923d6ab29f1cc9a74faa8dfb312e96da93ade99e55c57771d32f1afb3b2996bfc8a4eed755061b91e8799add6d71b45d3bb4c4655bff6f7dc7dd5a7ed1f7e8864912b9e08dfdc8533446b83bc06be70d2fc7953ac0c09d2c73b6787082209bc6a94a6736b6e53429f307d2a89637eb11c358003887f5ce4560a61b9e589bf67dd382f275684975096bf65c5e1c127050b5a0520dcb659f68c187f1dcafc778ef526f0b1de57b14c020cb8822f59a9fc806eef995fe0e6dc76c68c8de12ffcf39ee04f142f276eeaf3896c86777062f074a19e3b3e89ea84683b130fe95f5e15ac814153efce96215495c46966e0d3da952f28c2abe5838e899167364eb73d4687087720cba83180faeae475bf666aa73ba6e72f3f9378a45063b00c792e0080809f6e2d1de02b6e006a0aee17846ffc30cbf1a69e882039c545e5dfa5e29237ff132bf6056ed5b15c18dd30a8cf047ea17ecd789c5f53d52e24d314a6b87532b4f34fbd9b456b6b81b4530294b0327abb2e7a1ae6dad4e9254000e1298942c544e8285c6ebf21ec6af60d7b19f2fae5915de82982496429cd6893f80edbe784c6add5cfbfb33347abca8d3e0caee3bc657137a7e6eebba2114e3417a5a92c42f3c3ef340b879d01527b639941e82a88e8bce02d14a716631ded1f898762493e13e58a24d0ccce0a84aa5d729210ab6206d578f150e37e5258d0ecd666054956d8253bae13cddba61019c6740326445719ac3ebf532e2459e1ede525facfa28e60081d7869197c0c40b1a3323a2d38741bb4cd2be1fdfea1ed11be2003202363a6889bfeadc9551dbe3366eb5c2884ee15552da210592a6accaae83035642668a5c8b0f92a664dc989f140cba47e7ba6951876ae98d6e1866a55d325dbe71e67547122bc5b7aa2db2593ef11ac0ae5ed159793f44fe550384bce04b831208734c7f00002a0cff8251961033fc70c8e0e1219a1aa5f251bb6352fc8e9b3909169554e57a5b6e19eeb82ab30399a1a710d6a9d928b93b689631ccfa141227ffa92693ec76228a8cda92710ac46cc12072ae4e21253ce2a7e5e4bfe81ca5095234c47fca8ec617d107a60d293d51ec0621cfc04a929805b58ee8867bdaaa1f0ebcc5d09853fe7f0016fd9e98975ac9a0709f802153e4a6a4894c4adce6941233f7b693274571ea092360c7ab0c97fbe9d060a22abd347f35a09fdd9cabc190e98acfc4a34051fc86edf77964eebcb01425d0ff5221de24c85087551c5d3ac2722fbc7482760063ce98c644318cccaa821098e04b91c42a08a2da0532885c14abe5029d4b3a12aa93080b1c8eda934106fe482588b4153f295edd69301d5512ff22eccd70feb21a7816dd938b43bcbcb2d5fd49f3349be2084b0a4c14e0dbf2dd2d08e486999326b89356b83680e69cc23c813fd3e95dbf8ba4ad7b657c097af22654e15b4a99289fe572ada6c84bf816a99e67a8f31c064c3bb357d92fa5c5de00ca459808a6f4e02024eaabba8db2e0ff0807f7058f477ccc3ec50810c4243e77b0d516728f4fa1c533903c5dbd42eb65220bc96adef04ec738f5a9c22d1c68cfd566a59026ff9d1b29a8d6f233803dbc6663102b36b87543580fa7cfaec19f62c1761aa37c6407afc9ff47f981401f14126193887517b60ad0f32704a66a8d47557575f8ba136452fa3b69c1ee30b88e9a568db0cc880e1e06bee003ca489673a9429112e1330ee4aaa9a02ba4d2925f84dc6e3e6e269cb717861167fe60e055c142846a957d89e9bbbef700416b3826374fbbea87cc0849aae5f2e88c96d88dcef33b01c3edc0462f54ce8d2c796cc442840b16b929c9402f83744619105fe1efe65b03140de5c1b5014f1b85c08adeb92cb6a24d04e04a5d48b263f14abafa2a0c47054f004f7c3e6e7d05266adb7d9f08b371dc43f310a35082f9c631a828c969b9c07705fdbe36350974d3522e21facb0be07fd1f6c5df7a8dfbcee2186bf9a01db7852279655e9771ae2af1409f36b24a5aa67605af3dca5b81974e6a97eb161cc3944143ccab44e8325c869c6054378490843984670d7dca49825fdbe71ec831b2478124bfce90f2bfa8dfe0424b1bb4ccb3fb668ade7f3af29da5f23a42d57a6a6801c443992e9f74a9a9e7d14486590622910dfe3e0f3b4a37a9f513f4a055f4d7ceb1075379e00d69490131212ba15c259ea12f133d511f4e14ff9028fd87e59d7460a2ec2a5757a15bf8dd3f713f228ed01ea327c52a9c7ebc151a6b78714f6559b6a73329a28f71f879203577b0eb7f00102b572437b81fbafcfd80aefa022ba99b863da2c4f3aa7144b645e0f05449d570ba362985f47ba947e76773f1ae3cd1b6a73fded24859f105980da0fc311a7645b41103318175d6a3bb853c0e2b84c82c68f8143238e8c80d057b8ee0cfc3731480037ceba986ec473c63de85c6bc76fc0f91ba95a343cb43fb511d160e491dc0e45436b12c8ce2552d2ff6f3734b3a9374ee44ccda93d2184707b15db1f80a84cfeaab2ca010528b13ed2e3777459cc1e2183b7b5f9a995b30ec9928da89bdb48eca36dcd68e050a8a75dade08cb7891e20a646d43048f1b19c69aba33121352c84ad3ae4caaf370870d7c6615272264d981ceaf13382c4afb14ef52a059f106598f5c1da2bcb755d40b3d3ee9ddf21b21cb47b02ba75bb00cb890b6bc9bb306d2ccd0f0315fa450065cf3ac5e1ac967cbdfb515d2da11959d86c1e145d49741daaa671a0d51a6c0aa8ee2430e45bd5f92f84c3aed1312ef8ade556f6149d9a8c0b62ee853f5f48634ee40e9cd08da111fa4840da9d0c9244f53e0822ea8eedb31f2eebb3138a09496f696e51c4797afc2da08fae9bd981b03d1af7da5fb315d608ca66b7924d06dc63569bc5612a7d164b72f22bfd1cc335b86a96faa941f035c424a9df9190ad9a8cffa9aadae9cc29606e39743cb5bb948085d4fb3b19d0fd271a3c45a3edb61496890b2dda79eec6976f0a8b56f72eb9406756653874a5c81f45b1a90618fe122ee638e8d6d76d22a64801dbb773a689001e79288943d4d06d52fa0e0f0f3ec3b48d13963c463fe498ca1094b0d510ecccf3c42a178c440d6184ac75958d6032ab25f2eba9089a2912071b5a94d1f5ae36e029f0e231e2fd27ffe22d02e20606a231cac593a32905f045d338f8c16856a29ec5a1da72bff52e59ee5b18c9f1a95e405e068cd68e717fb64f3d3808acc35d10828330a208031e0c905c6f1e53d2ae30e95c6d0cc1bd91d84d584815286c68a735e200acf2e78ae01533fc6dd25019e45feb17864543171f8e2031d214276a0fc5fe45f67164dc2a11998aeba11609b978b9a1d053c9748a0cbe4383068fda77a26c96bf2b5e66ce7e0f02ab11ebb7586bd5020803c56044d8b0ca2426bc77d3a92067dec8ef888d41032e01c978cfd884977a8b2bfac3bfbd0669de475a49cfbde4d13bde28d39bc53f0f3343a5a501b4746b69b26a07e7781c2949d1e261227c9aa515ed9ec57df32a0e8751a32ee8a3c3fa36947224d5faf6e50ba043f7bdd6738c3e526b055746468fc4477af8eed170b8deb6fb133395c030df18b445dc8191f0d4be17de2f2d23367ddad2d1c528b28863bf441ebe8d507f6d12138e3d327aef18217bd2d07aff0d179831b1ec66bb070a5d23122c934b7567f5b41da58702cc7d9eaaefad77ec59ea104d0e93d9623d21e5e40e344c4df799fc11019cc45ed06f04e11d8b0657daa28b84d4de45b5a73b42eb9da696b667172d8c0eb44fe895f8260a39d93873bdfd8f7f0bfe7df0479b26469e1d61fda59c8f4384d254b35771578ac5936eb5a1c842b915cd0af3db5c6dbb134d39efc0d530df3660a718c9177b0c085343bfe4c4689c97bae6f992f9e932aead2b7d5ee0aebdf00b3ebd377246f3e65c8e09aba9c366f07a39edfb28850273f64755a128ae42d1b7176c1cacb31e3994afe6f9404d6b0fa7b353796e44f15fab852c18cba3d03c3432fdc15e467eca887fa815ed2ec1aa2b1238d2714e8e34b9fabb8f38f6c732848ff30367401e20fe0b5de7551f3cbb71ec592a9d1546ba323d0408af5c1ec7e8f01b449cf6373eeedff9181f5ef132fe8a45db7369ac4ec03d1a8ab1da6ffaf0538ea8494815778b89c81a7dfd056b0a631d097b9633de1af8da5c592fa41ba9daf1248f98368ac4a87527a3071b7f344ab215d47a22921d398c00780ff42016b9b16a99c8b27af6658e2761f82cf86cbf323719a893e254270114d1c8b89527ab377e394c9c8570a998a16defba0552515465dcccd11bf225dd1a6e9c2d0c498246042a7f18c8ddd551e35b7fff0232d472e51386b032bb1fb2ce8c57c019071b8af4bbd30e5f005f2220340605d69d29fa2b7bb32383e08be8f1455c1d7925bee717ace4047e67964365e17982953b6ffb7d1d20f18d697b09607fe6914462e51ee8d0bde9e7a9e9a3559778fcb74a838a014fa32488abba61a44e62f8588fd2eac6600c5e56b1b033b9e43b2243ac8ae38195adc3eb2456691c0b53ff0e57dac16dcb9e1e320d3e34fe9330b345dc55034658a830c93bfd4b10b94d2a83d3bb41bd86ebc76e0ac2b936a60d490769d47c65228ec9feec49ec5aa160071d3fb0e9b3178359fb05f6f1f7f206a331fbb20ff976435a2d9e3984104c5497ef450661bf5d4e1964bdfb2ec103fd9231a108480a92d7e6ce8c1dea3e43d55baa65bebb135758c2e0cfd1afc1c5d063611cfb07ab4e52bc695f02f1362651eb93adfae035887b8d58eafed68e4d6c20c6b381e1a6de1bdec4ac1602b3f56420aedcc00ea11a4b3363dbcfa8cab591acff5aa847bf8743f92453c31901d1aa8cc921c19ca37470c3d53949fb76bd0850f78df22215993c75bc5758b0d8e76998e105b8fbf78fa8f1ba9b13229fb243ca91a7c7f1c2a7c47534cda480d123b6a7253702de027b726fb309878d223f95b5d9a72113e74c00b498a20b9d9884ea1c542b5268c048caf36fb54064ff9c78a907ba3bf2254f22daf58b8117e3ba77f71ac5a26a313fd315e5f19cac0e446cde5f3c9826003c0613383b4d28d6e8149f2832dd81974321590da469ea496cb006906f9cf10a9411d217f3079e3094c9f0c64f306ad4517b156e22f5be364999d72aafab32f472f667cedc32110103c97c622668332fc896a53a7ac45aea0f2890c13ea450911b0273ee1f39a9d7b25f35991034583736f78793947e580f35f7a8b11fc17b22681a57abd347ef53dc75364f74298de543f9f76b75fc916a2958b8237ac050b38f7f3e77b0f8caa8d35aa13a77b2594aa7139f1711e0c3d065bb03dae5ed8ffb3b55aa7b9a9d39cfbc382379a7af4cc3dc654513fed9b40810c940be1f8f1f074f5ef1785ce7b346f454e135d3613a2a85edbd0f948795463a643f4b6300fa36e75b9977237465d5392fdaa2308e1d8e1ce3270080712b7c0020e7d9420c3b494735d0828ec06b3884cffa4fd2a67982154e6cfe174ee22950c0a09f1a12637630d6d87f6511e906bffcf34c0bce415c159ad764764a70e0a1d94e7d89ee6caa0eb220d47fa44c4450f3d1b8046d429926a4720f03143b9b86a9cf109a09f226fec2c3404865f3a9151ee1aff656e80684e8c6b6065af68594e1f85a2a6f94045693c13c661565c117261ae4300d25389dd32834f8b8b613393887fb2385c17ede28c78fe4409e77893082adbcea16307e2bf0d4c212ecd60f2c7eb3cfcd555d36198fe517bd7b5dac41eb4e812a08933025f553bd36d85c61eade42dc4fec3484d7b1c30891efe597a21dfb132060bd450b1cb98499638179f1d6e85b1705f60f2f813ebcc5f120344249aa257a08d557444a6c9c9827d463a5c2f477ccf9c4c9e05b3ad310eb7e87872e347e9f0fbe0368300b8fab47fb3c339e1bf6acebfae103bb1db61796bcc7e280cb98be77ed062a1ab0b6a14eccee02730d9e6c5901ba9bbffb9e021078ce6620563e5d0a1724942f83aad1f77905399990289bc9327ca653b0f6060616e7d8914793bca2c6fd7d8f86e443c6ad2b96849f025e67ccf3b615123002c7e41cb4d11cfb80bd2abd83b6d88db1d98ec79085d3016b85979fadfcc371e3a88098d4746c8e9b83d1bd82044410e4684dbfa3eaa8386e8b9d514e4f6d94758f841de4157661508b6bf87c92e8c696c027801405858d1d7554ea2c75b451a9be67280fe10857375367474234eb0376fb73da2c282da170699b1a62d08f871c7ea7e05c453569856d802a8c00104f2e10cbf0cb5b8fe6c38eebf9ad082c5eadbc522ca9533e7bb9ef27fe4e9b4e8667c4cbbc67aaa65522e15d13045c660baa3a1cf9615cd14295965055125fa8dcfbc1303dd1e83553fbde5bc0d22d308d6493654c6fdb5af27212230758cb28f1a062094b0bcccd85eeb6d45e18efd51090cc3f48a39d8b23b08ac92a7a540b6661a2a9ac129d940ca359c567cbee9a366e301f95f640926c9dc49e06d14e0f3335fdb355b56106b6801afba843c048aff1ce296a41523879011c06e504d524ac08277688a55238ef2997479802be1da905a326e9f1e54647e8609350d800f11391e6ea5ec25bc8c8f3c14c28a98c95524eedcc645311e6dad6742b4bea007fdc08b65994c75f15967e2ad40459ae0b39a0e2293b5797e5e0b34bf4fd0b18e3e02b776229e090e933404ccdd9ec05ffca1af48374f1479786cc7be68f8ca4e1a2f780cf72dffba91958a7e67ff520f5728bfea0fd6597b7a04b4cc892d4d7c8c143dd3dee1c5ebd705ced383e66645ce33c82c6084b63beeaf7ebfd148e8bc8c9c8c8e4e058637d5bf60b135a34ea4135fdc63c41840132af4491039cdc1628753a6abcb14b25a717d85ba34e2f3bec708934f9d6407a219a539d65519ffbf88c34d849a10ca0299328c8b6102da3424b3d3f5fdda2a63a697378c2eb284d34856ce99126a33ca994a42998f595f4a72f84965e8e77c8d667d8e4a9ee77e72b8f5ce6a00461d70f4bd662c92879dfe689ee5a9e379938c30f806f7db9bdc659553a9b5e77e1f4cb18794f037ffc6568aed7673b7a5c9f317acbdc6ab7060f62bef737476af39b4e3af3d4f405f54887d1270a0c20dd18e88487e41ce9f294ab0ba59d3565574b8e0410839d773feb3d99fa75d7c98f61bbf7dfb3c1601855ac1fd51994579e682a882d2d9e038f6b487ad00cd4cdffc7b401b1c0ca7e2986646d17589cd0979fce04b191934ca24671dc9908fbb54b7f42d65a62cbb6e89168ea0315ac9a1785e5bb39594f4c589db7574eb1a3f8c1b5f1e2adf0520289981cf8bb039dc567f4c6948f9ea8d26449fd82115d0f238639d19f01f837ce605780a3745d66450cbc43a9ee7d3a0732f724abf4c09b4336da4cebce4858804d46f39285f8b9f1725ab791f1e5ac2ca55c75377f65e63638bf145c32caf6f1c12187765a85689da7f35ef96160896eb1a5ccb298237e657958fb2c24cd2cba2a8bf110c9f2eb873e85e324c0600932d9f0aabafc92689f06fadf1e050866e88aacd2a16252169a2bc3e1af1cb23b088625cfe94cc0c8dd2b83004b92f690fef54ef5a5e09bcaa90624a00c33412f2a5bad9dfce7585980764e10a5a25ae39eeb96ad01b7de656ed3c0d12a5750041f38e12952ebefec90e4720587588e7da08c183f88caae0c49b20c9e392cc0db51c1da4bc2209133763c248088846e74b44da4c039c79b1de92d0fa0c68f634f4078b3f18a0645fd5fc77a5580d7b3188e4f1626dabe659027e986f2fb3c2a238d8bdd3f1f4149c14d2a91be4d8929f5e00602b40d2f8e9d0294c26dd1dcf01ee85c246761ea431dd77f11ce2da904e80d3a8ecd93708e5805a2bea2ef48dc8d24f4c455d01f42a8f9d2f2125c359f9aa4156e478f327d173a050cc14f3ca893a3f6fc4a36933108b796c0a722a02f4dacc2c83aea0d08f54a5d4a189e5454c7d62d5fb218a388604b1aa73cdb37434312bf84224bc5699bbab821fc2d482b3c2009bd4a6cde1ebe4dc9b1dac91713252eaf265cc5c62f1d5232e0381f075b5dd4012bff7b4b6a5fcee3e67e8253d4dbd6d3e5ed488c46a08aac5f047d5aaab463eb3bd91b6f76e4f70484c9263f8a5bc78063e7fc72ebc2b6c7d3f0ab9eb93dfe531a5f531ed1fcba19c1fd3bcefb46cea8108d20de5fa4f799db1a92638ac58c118b1496b3c3891cbdcd584d201ec7bf1c13ef9466c95d1439900054c6e82c3fb9b13a36e46b99830a53208a7f7efceb5d00ac29d08b64e8e1a5d0d391aa991af0baa7a4379161ca28e537d884983e2ac0abd7a6659a5b554d2c6110ad779777281da6c5ff44a3a516effc9c6569187093a0d0c127518b4a41d093cf05866f93db22a946798e10d4bae26cfb075810023806d6e84689285d799dfe9a591961e075353f8fd2a4fd933f5e53401f3526efbe3a74a7d4a164fb50a8e0f4cf0e89ddee31753ae0cc70be6c15a531f57c3dafe93e8018efd671504d6a29d05e6bbb67caec6c827ca4d544928d2ce958cefbba40f2710050b1643dd27d51cad366195ec02b33f74e2496a36c0fa29a5aeac5678f7138aec333f987768eefbaffa955e213fb41e1a45db4d283440169eecbf0db38498175bf6aea7cd15390d796096c0db8e560a05b973010d3f4a064b0e77d210af5f191e64bbeca404ff9dfe093ce00d73632402b58dc2d5ec5ef4e25df150926a5ba67423ba83119d70fd3bd05bb770407a5cf24c2815abdbb934511a224b279a71f903da3a96c571ffab6d9f2c2740fd40994b442e0bd0cb1827ca6cad9cefc75f3e229813e0fb5238a3583db76e5f5888d0d89aea684827da15e02b63498b01f21dc62de53dbfe7dbd44fdb4f829b2175a6d35a72559818b7c0b9766d0f46eb1e71c2f4f1c3278248a640b82fbfbf311d45f532501d4a80a1095d9375c6d390cc9d7354cede6b635bf448088f27c7e03c3a6733d04d67778c8fa7ebb02139a7d03354c9b77db9aff7bac6f08fd926bd16796b799ebd5a849e9b32cdcb2f3c1357120ed1e38742ce3a584d9de4116f818f7d0e31921945777b6bda10437033d6fe85adbf765e61bf45d6886c84d926051ad9fb7a2aa2d3bdffb8c738009d4beb79bc7edf3453552fc60c6f835ffade663a93e06dde2b6e9b7ec48b80a469b27e9705e1ce3f59025ce8ec49787170bd4b0ef453e7638d550c3b23c4aec2ffcf0d2e360c8fa8aceebe525c67ce9898c6a94f28d9e10d32a942f377d8f92d2bafbd8f327c631d3a82d3e36a02ed8e0a3e612aef0324ac591d8d1e382f6b1bb90d89805166cd688d606785dd20f51ae5ecaf80d1bb6a7b42aca2caac0687905c08f22bec195e7b496cf747349a58e09fa1f29da1d99c5ec7efd6ea73fb2a84069fd60b057d8e030f27d955e9ed19b0d6ba06302f884f9e864326bd1d16aaad57d24d40a13622d8da8ea92b6fc13f5a3ca60e47df65ea36435d2b259815f653ee3612bf253c1f7779a8680911d32e03fa013c12043909bf6285bfb28913b5a402b1a6c975765f194620cc19a6fcc9375fa8302482d8ae43d41cba14a0cb28421ccf9374e0efc51b33efab0e7bd01bc354a8b621150b60abbf008b4491f734095f310f4d35ebb7245ec42a507bfa39b173d268f07870905004f726e686077f3eb3283439a20814549044347922a36a81f9f9fd250f12e4e9e89b747a9bb40f1e40b9ffbc5a8281d7b792b6d02524f731634ff4187540aa21f2eea423a8b8c586ab24a576bd851a86174e1d68a40774c3700204ab3d3eee969a968481ede5967aef3aae63255974ca55de96cee007a6d8ba076ceebf63e6dd8e3fe3db87621eba5a77d5c9f84eef4eda4c35fe8a62d9e8c75d7b1870728c7e3ff869a2454f7c2029d5484f2e403cb42213ef15d11b38a918ebbc75cf82899cdb871cc6b30b8e836a147851844e3933959d7e246ab5852f3fe3bad4bbdf97b7b5dd84a5ad376f56288d1ae47d6704559a28a017a37471e348dd1d346b6dfcea0014fa5179cfd434e09c8256caa8b0496cf9bfa1653eb39391b85eb35296020e1482b4a6a6f338ac6eadc96c106af1b9d3abf0290461e0b296f8578a2fc88935e7ae39d5082fc075d0a1fc1655ae4673e882cd4f27b395f44cb9848811c31f61d3a70a3ee803e0ee20de9927bc36a5611d90e939eb0f25b3442831650a0f9013ae3d00e3e47c5ec625c46920a4db1c1b9bf6a01e513caab38cb162ef612568c67811fd73528dbace6a40e1a56e08bd70da8a60bdffb8e712ae2f2d2f19dbefd3be551ccec2a3d2876d28befdda30a8b897518f8f7a581e8b56ded66c5772095f66152191511594849692b8295481399547f66e85891ea12ef5236912a22ff6b9d8fa7cc784b7aa970d99968edda6f0edc06631532b5d03390bca077be594a59a83ed493e4d9c9d1e26ed173c56cbfe911b3812274790612e63d3a83a4acac7e025794fc903902d0f2d9c66ab91b057cfc84e43f4257ea481f86383df2751d99573787be3c75574f3b8197a3d9adfa0a4f3ad384f1eb4567d26bf0fd51f1e0e156fb4d8f2cc7a87dae31ac2ba555524d280c2b00b42126f78dbb7a52095dc6485f9b13d1b45e35ed42c83cd7d48346426664a6d918f1284b8177f7b944b99ac1b701bc27723aa00949804ce778cd2988f013d8a190075d02c12489dacc061266a6634ddde29197f28d5e03347844a8faee501958f5620de966618a833120654a6f5e2b84d9b1420b28f7fa9372a02b27d2700d2a6a65fe9375b5fef1519400d548b5171faf1517d79c130fbe11002c31d271f80ee27640093d3543a2b1be4a971bf458a78fc0347581a65ebf8a8ba002ebba37fa9e80e4bdbb3055481f494668ca3bd4c8d819cdcbd32aaf09535ddc0e62b815e9ceea7d40aa957e5983220b832a1a77b3eb8425f204c3c78372ac256380446765c9d2c4a9f3c1bf142eeb6824b21bbaec6c71b4e1fa70d9f8cd0a74891ef8aa44665d242be01bb76472f4bd6b5b0947e50ac633775a986aed233fce1004d80abe6866b9c40813ffd20da430fe59db9708ee6ec7eaa3a06b914aa580597effb4de5dbcd7bc009781b64d4ecb9ad04f7d4bdcdf6e3a534699d3e99a4a8bcbc4f216badcaff0a0657d2ba457b127052bb4f187338573831b2fd6e6fba760f77d1adb7283fd42b8ce1fdf8feb996700a45e45ce42f1641646d9c1ed1ea55d8b3a442ac47948462882d536b57183fc2b73b25d00900db96d1be9a25f3fe120cbe47fc66a03bf929f37b4f01648e79d4fc5ec9ec289af5dc9193488ac3fda848d0457ea50a90e83587e38bb28782a9d53543b2e0ad371aaba79319d9b79ab88da13f4347683214432d7987d29460d6cacf315a861d9ae691c5370a320e6db8b5be7bf563e585d681093f39d73656382a4bee25c1ce4ea18e58868c73ade92b48206e3ae0c14cd19c74a9571ae41f6b6f544f27df1dec7ebcdcd623263e24567858d3ba2dbd1490142cd506618097760f16ed12f1ed022bb308a60afaef267e4273b6527ffc0ab38229e5bd6b5b91e024160e3e511f8e8f1c6cec6f9c97e63a8e227b0489c85600355c04f2535e09a347b2f97e6e407c991d76229bd81f3ebba7b0aff29182e3e089a7b3b44a49c7a8def3c52af42753e7b59a022a70df90fb949d2d67e897db7193925a0311a6c3f5c11d79bcc0a3299a545864ffa8b91b79e63be182007a071ea7c5a4516dbdbf736d7f39d2a8dc80ea2714898eae10ccf7ca8c618dfbc69539d98b4ae687bb9714dbc1c18da6adc00eb31e7ea68ec7f1abea9747ca6c04250bbb3b3898fb0db776da43e2abe8e835422745f21bfe67c457a19fa47c4d33e8fddb465b3ca8bb195c2768fd15f6b7b81609c4cc769b9cef2c941abbe37a91ecbb3f04f38fb4823454cc236a443921e661681366d28d461ae4a268775b77dcc9e5baa72021dbf420d136cd23b4eaec203f8a9c41f937a70d3bb313d281465c4ad5b30e5f71f099444d0d7b98acd5c8205e6430812a52d113e43f08245134c4a6c91eac06e94b7ae34e98bd6da8bd61e69c109f9da211084e651f964890fe56199d0dd7c4c4b70301cd57e1bfb573c4639a9fb10b99f4016f5ff993279ab921f189d8da998fb8dffc1f129a0c6a27e214b4318120b9c6d5fe55a6e8bd5ea4a1cbcc2368e72e2d7232b0f3bc791861d05b1f5850279e64a3ddbf0454b9846f4919292431263cb67b0b9fe6808166c2250d10574cb9e4131ca61d17540190bb924186839cc4a12661cc338b1a7c27de7199867d1baa9e33fd99b91023985652b14ed6e5917b6fb0fd6854a3bf1671d2199f2bf6ffe13ced0256f5de93625a83dfffcb6cc60f8bea60878feddbaa5296c2aa0bf42c85cfae7cbf526c05bca71157ff6f60b467e48072276c16a7fd3598efb69ce2597606daab603d63c1d6b44c6c99701b6832c7239984a2e61042af64f64d82ebebc01e6bca16d6ffecf575dca533e9594fd8f14e97002159770f0ca7d7061f3383ea9b6c66668a065cc4304f07777ac69192a33fff6b7f24add8bdc472e57f905e51eed3b0f25d90987f1fbc9f11d143e82eafd60fe5c9000c922b34ec9c8cf751e5fe75ec07058d35b6143cf62e547b0eec4d2045a3f2470c7fc2922bb5cf6d79a048983648953e6d39f1dc7941bd9318837308442dc463a87afc4a75130eb29182de7f768b3bc6be1aa8cd43d4a91ec00f8b7cd2e6d03de16a2cab66a3304d8ea6ce5f9576e460fb7db95b35f249a774c3bd31981b39513c0dc6656f6cf127fa7b042d98376b786be9ff6e240d8b8dfb98199dbb78a815576535dc54681b52532b4d476c24dce6ef84164ce3d9477d541c79605aabec7ac7aa65ba656f12eb547dc2897ac3ae07a94610933cca5421a593162bd7a0d6acf9c6e69ab2316e2ed58304810dcbb5d06d072d0798a6640460069638a32555e85101f36ec2679de25df3b593262610330f89a01b28523147629ce4e10e20801b67e9c42135d64f1f5e54597bdd7197d51895346203a493368f2db2ea3afc8e0224eccc0b7cff35634f116e0dc688fb66132bf6d032f080a16a56765252c383b8b3b6b6c8e87252c406eb5a05ad587fb2e2a7319b2e0bcb3b0d7fe6b4eacf56ce705150e31b3bf2780bbd3ece774d8187e0202a4ad99727f699622eaeb01112d52c477caf47ed051cce13f75662fae04ab7464f672a1b734bf1496e9b7a1e620f38ee8b55cf2e968823a8b24b7397b894829f3ceca370b4181a320b75c6474768c30f0ff31663c904481719743c0bad05e0720a07f53d201c924fba8908aab955ca7dce0684aae22d93a7b27b45711609d88ce7b8827362462d909ebc5ec5e673e0390841d7027376b6a848a3f26b5884941fdb7e993d95e17ffd04981edb8fabc9d5816fc4593f5f058ca715101180e73109e082ba7b21ed5aab0882d8eae104b6e8587c2de5a25893fd81415984e29c1953d18d5a66582cb85d8fe2acb4e2174fd1d2dc4cfa1d2eeedfa112a5ecd95e0021f76d93de2d1d9d43744913ddeef89316028b0711ed806a9d2c1b0a1a5754ee647d137edaa0559d64a5e8753d134106b2ae0264fbb9a8db72443f5177b75f8955b93c3de9d4d2dc113433d1a9eb0799b9579bdf64873795bd48e404f53883abbd9a1a997859a4ea38038539a11d3bf3f2be5336b4a61adc36575b70bbd7ed6451e4a566e817ce8e0e984ed5803aa6fe1aafd506a75464fdd9354b11b49e060c4b0efadddc8cc4307a0fb0b762b24567ee6ad1e5f932e62c658ae9bf1f49520ada39fc91b7579fb1bb8372f88ecd306c4579de38ef119b8bef6d051ef16c67cda3314f4ab23c72b99980ca77e090e955e81569930ad577ec543708440cfabc00e6dcb0d9fd3423fa40c381026ec47ae0be125f103c062d9b34f971ace101ec8c4255ba21de446b092ea007bdcb690a974f2d6836833a4a03949a81a1c6f0bb38eaaac006f4850454be44f8fa2e2f7e36026d513b88576646fcfe1892f5a92620ab226025a4feae70c111701a2445113c0d2a683323a5faa7cc0ac34a79f1adedc748d2bd5a1fcf079a866e81b04089c9b2b5d5c6f0309d035a19f8e20ecc7ed31ffe6fd74f56d420912341bb2cd523ccf0fa63714c84d121f9a91a8764b35c869c332bd0a1b936abc37168eacaed41a25c9a54a69c500928183f7882f02b04dd355c9c8637b5e74d8448d6db030b2168d9cc3c9cc43620c486db1cd0b1907b7b17e61ab0a9c6792845bde8b4db052edcd887f934938be55ce60734e380a519098184bec423ab27c07bed271bd022601475e2c2f9fd5c4c41117bf12200ef2aeef683a170102146d2a2343ccb0d7a5fc293ec2dbd479fc9230345caa144ae2a40a8decf9a9339bdf45ade6f856730318ff9e476440d61526186ebbc5c530a5d1d4ebbf58bc12c2a42aaf73a5f239997a8dbb443daff90b3ea72d781cd4daecc7ec20d44441fc2209ae1ad951b11d595a07eb19297782dc937209b0281387ebb4fb0857d9ddde004f45d34d55a4e63f0384bdc6ec403606322610a0f8df326f2e2d60317a7e509b02846603c5c2865222cb785210ee5f89e7e596ff2373d13c4c2483917b438d6894233d0d5a47c60bea6047e2b64972758d8b22a8529cf690fc18362508db72629633704f2bcebd8e4eefbea35a1f4c1f26ec89190655d0c6394f8dd3b7229d16f81241229cf73c82f8ef069466db62001cf0d596ae33d5d55e84cd5cd5f3eb658f68c3030861576438fb0a7104e58526066d845060493d474b6faf1e336c037ef7243e9cc8cf579470e1b757d867b03006d5648d58c50a15d7655ed7e942cc522b0406dfcc9ab8982e81366c8704b858aa8cd35f7bab66a46d42082737b52ef8a272b3e704263d7d10d6b691561dfd8dec6301ae429213bd92745c5e97486e04250c13bd85e2e95e967831099192421a8d31300c53da1659156bf7a58d2d543c267e5fbddf46495db12f97ae40b60d5ce8b11705729b843c2b346745f07e9373332f395336a7df569e12475f5d02bb0836fcb3a608251a0376a3f1767bc8ea579716bd4bf5af3890a34a7b043dcad7ad4e0a6596a4e934d179a85f7429bb47fa43fa2e999404c9d2f157184d902277a80d1c99a82d4bc204f15d1fff94367229dda890a6f9d83a18548a782de3244b8f64f8813ca508082b6bf6ed262d87f854e62ad64e9b5078a799574b612256798d0b7dbc8c73e551690107b9fac5178f78f712d1371460e1b10f916e4d81b68d466ce6f95ad51820650cb61dbd50cc7c8fae4770a77a38bdf263889d0d6205a504d082749a00837938361356fcc89da5f14db57620850c0061b7d01b8209e28c24e30fd16e4fe06a0ec804a97b4ab07f4143576802403f514b9045ff96662f9dc80ac0b0ae687da03916fe881ee78ce1af672fc5d49d345a2206ae0d8c10e18bc165791ed3c0a9f83367d2986dd56e80bed17ae497c22d757c4710f9052d1a6c3c179278b2f873431aaf6880918bd66782fc6e01895463cb32f900cce5201d3c88b6ecec2ef35a7a4ae523d61c0c77e09072f68dd85abad6da6afedb9a09c89924135e395ac2e48791b17068a1fb4b75f7a1ecad21d82d725611f04133aa1b668834c5d85d0c537f00334624becf9f4b4c58f95877ad704c9a9a038e4c41906b13f4385356513e4e2baa95771ec00ac544ae17fa807e36f1b4435e0d742a254873840bcac6e14b1466e1384b042c332c9e24413ceabb00b63df203fb3ed6791a634313e95fce655a180507286c277f60cab7c16fe32c3995be97800246699808c9d292fb96240f92b96570244ccf2356d31910c6f4f2cad771e74d6c8913eecc381c01ad26ff14e0b2469f71e1c7f2733f2e9fae5255bf5f709dc86cfb65a5ebb4b5d2ca96ee40115fbc2412cc9dce7861595d8d1af2622ece89e9f41206d86ba114ed31878f25f8e4d2930f642dd95f77fa52dee0c5e34382ae8c3e0e0d37c1a9b7830802cf13faf6b1dd8ad64646ff1bd0078108e2189ff52ab233e554494ba5ecc6fd66faaa54ad904d60ad4180843a9e4864526215049ef318fa3f48b52c06a76e6ca5846ec7559932fcc1cc64ff79a5180e47039f954fd86c37c18813ca8d7593cda1b5f410424c049a39e3081aae74ada153322c73886b1b4aedbd31317050acb512ec823301c96382d91b674ace6edce83b9869a39aa1e9f20a2c5306fb0839689ff903587311bcab3bcf95f1bc3f4f9a961e3b46fb372f3efffdedd4377962e0de0932ddc7f4839479583ed2b14698c810d8fe5c002e74b71950a7ae586c66c622d525f2fd4d90f346fca4f382388e119e7d3366608860125473de7499d4f6a9c4455623a477d52416cdca24aa4a44b72bfd7ceac84d6b5e3c1c71dd1a530b172b065cb7b111cfbee55350bba673ce1d1c24fb1dcb758526146bf6cd585a7f1b364e51cdf3d4b1c3ead1c0fdaf2333be9e23052d9c37d0ae9b26f13335652b2164bc25cd9e0a8819cfaa88c3ca8b3580d89cba7fd0a713419f72eef31031566800aaa6c836bb6d0bf7b002f96fc1f0264cd86f3a819a40c66223350ba62307b673d0799e934ae8d8cb8af2b025754843ad2debc5f6c9342d8f00af9f33280ea56e72fd37c0c83267db8a21ffd7ef2371821d89a3b77af2a4014fd4add5e7a79728f66d56cabedb92a215de8edb52cf4115f6e5a338893f143c4cb94cb60946e51b23c21c51e984c7ce32ed6617966b465373a4d2c114a4b9bc0de7dc1d4fae5a78e2485434b0626ca0e9d3f9748c7cb9b6df433cf56f6398466cd88b221271869184e656ec68fee9347ac9f65bb1bada2645664b5041d308a49919b8ac9ad0d3db80bc8bdad3142e07aeba04456a760ebc1f8d22ca873b9d386b702f825a1378589709a1883b95c84e9df72b82dba94995335acaee4dccf53e8915613431dbc8f3ef998cedb9d3510f00aed807253ad6cc1aa1e9c4b56cd1c79b47a7c9be599231b9a9f006471a89713295812612342e2310ae46b97adf72e0018d172bed8e8fc43db1fde0c942f56b27558b2e8f836ed79976521741c0a71300f54f5cc259563018ef4b78439d2286acc2536f3bd7bdc52bdf97106179e25a323257e99cc09defaac509ee6eea5295255cae0f8585ecbfaf7258b35625853b1ece7528b50a050d379a32bc55d8b6b6729a1052a9937262bffb894649027365572961eca3ceccd0c1fed7acde18fb940aed610bd7400dbec660395c86fdf1c752aa7b2c447d3d0a0710dee00981381bd8d8c56c76f95abdb0b1e1c7cdc45a53ea454c82cadf57f97884a3fefa42e4e0762c563877eb81ef8d319096e6bbcc9a991797be4b8640a3ee17b5aa6c05ba6318d315691811e030ee77c445889b9c448de083dbdff099b06632fae7dcc832e0e94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
