<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e2c59d414c5541f4f687b9cdaebfd5cebebf4636c77128933ea985ff14174187e09082567cfad8b99ff6faac95b8dc709528a083e63ed3aebb3357a6daecd001538490a2b08213dc8ba0911a57ae8f32b523479ac3eb0e382a05aa7cd6e95edca050e0a6de05c4f846b65b4a1b7f5633353f31b917cf8e562d3201b18021cae2062367d6ed32081335dd1abeba5dbf87220d7cf3895576bbffc455590300e5947f67c55d6802ffdbabce103eb3eb4a3a607b251d5a4430b43acab50ef1814f896e73efa7fdfd7f788e0db1a385daa653e2bc5144645039d02485f5a78c64801d9cdce531bfe4d08ca38f5dcef011e54bae42b0ec445a13d04c36d837951beef0323d787f6b9c15f60e4f106e5ee49425b5be9c2ad9530e35109056a040967f77e72fb2a86435b11464b33bcb9f392daeec24962c9944e158c62f43f3d77614997b07fd4f2f3c9f046babf490281390980c0efba381b79c6bca9df41c83caa5a0fb32ddbdd5027551077318c8497f2976095e0a963cdf402965961b6ad5446557f1d18159ac4fe0d8ec89c81865baea3dd2bab01078133237cd78d419ab5a204c8c6c50a0d3b29990e8272c628aec19d19afea64793d40c9f29bad28539c20b004f434a3fa4254e5ef2ab6807df3d327f017a51869ddf93584c2caa7154fc1477e9f70c85fb828e742a41246236dec48c1899e970694c051872eeb446fd052daef6ae78e48def9e1f38da6880c9ab34a31ab2132770b5badb2b1855860264f2ed7db5d3a33b75c67b30fa19018eace3c7be88b50de14c9ac8f9faee2cf1e85e75c06d9d4348f61e8ab695727ef62aa02aa473883097f79523c5136fbb8265058f1f4aff4dc5a68bd22233bd3290573847bde6037a6549c3844d11fde536f7bd41011ef712dbca8ec3da6fe3e466e596b158b30dc8c2400e8fa04e9e7c3324e4c093e718542b63b4291f9f339a54ab6728b0b43fb50738d0680818439dbc2a7af87fd4c1bf79002179141396aee02eeb60d15d8a6805a66a86f9bb1262b55fad953b1da10fdd3c0e5ccb2a299d50e120cdf4d2d249936a36f2cbb3a24ec9ba049311e920185a340684139eb72f04b2e61ede2feecb16ea5a65f36d74a4e11ee9758d3d44dd8bb571934a96891c7c6d713587d928a3c4a9dfede5186f686cf7b52b97d8ee8e247f8029b194cedb9e3191c17dd44b1251bb5d701014bc24a1f0c8c38c0ccc2497f937c4abf192c22b02190494d70c1259db32946fecf02b6cb8b0295c7e5eb83ced258be37218c7b308b0c0703350fc8974b1d76fb8b7cfac8c10acb661278e92939307963937d73508a301b580393a333b46d6424873cb12fa8d309eda958545e4ba41dc7401a258eafde0d79790809467fc2978933425a1661c5b964d7828e8d19dd1b99d6a9f74a3afde8d162261b888f3589dee9a9fd945146c5582d16ec3d6f5e7a3a21af960cea1a67bc3e5e28a43aa7b34c08ebd011115e16296b8e0afd55f5fdf90130cc1fd5bf737e2e00b63f343c4289310d6afd3bd331b31f0743da10823b64606f4d726face3baa57fef7de11d9227513fef3cfdc75215d4bb4b8460be4e1fd1a2947a3fd9f54b46ec1cb2b9c317ae1806bcf12b0ad5af5a23574418259271b92bb22bc04af723736b9edaf327a2790dc0ba96c3ed9b81de8084d24acc66af5e4b846fb6eed6f8fcd421fbd84e157d7434989bfcd4604fa5973558bb44b17d5bbdc691ed4de747bc9c03b190ec1f05340b08368d33f3c643bbf7c4db3cc8c32390076b4929397a67be89664de9b9f74d763687f553e7a00531cb611599c9568ef3ca72da3306e5fe0fdd7b5f33c5e2ea7a5f04a44d62ef71e48cf4e9604cd1b128422127330c48055834357b1f95c2acb5973352b782b90eb928380a35a0e565ee564cfe94086d034ea95c75938ea8ca016157bdb899685aaf471d64b2861df7092763ae0d6a9de02a5e542f389dce7363e8d8cb463178e6d530d66a8753645f233550292eec6eb013c19fc720e24c069629bf591dd1c8f9cfd3f6b6a63d2572ab71310eb633e5438d1c30f59a866685f3890c90d70bcb3e041fe69ce8ab3a298846a0ed453ce164d05ca4956b478a1b283a8471c53360ad9a3c4e81626ac2944239d755f18511fa278b605e8e35148b23e5529b6074db5950702986ca86c899166507834dc46af0060cf0ec1dc6b004b8f968b400163d14f7e9628a0813b6a0dd47698760674822a3629dc558748bc1f3a6b5d67ac185651e659a285348e1fe58528c75e4d5141ca906e10d436f10111809b1a8f543022fb7db447c12f6a9f01696ccf90ef811290916554d5b5da005a7c6380cac54222af06cfcecb4c20e27b2c5b4d8c57ba8e192b8bdb1cc6043107c7f344d75b9b242577c62ea7bdc0dac0a264370c31ee85656323fb7e81bcb7622147e95913e47f652278468b193cfce2f7a6f2ce28bd6eb20a01f85b7337693275a93b4e60fc48ed0321dbda9a71c92a4fa90f6c2a8f270dff2cfaec7f3cc89671e6ae126adc1024c4b4a93d3292a4344893b0c308116daf6967f90c5e80605f90eee3c978943da0160a519737c8bfcad9dc43736e75c5898ad0b5982c19d865d2aba542277f845d60b9596d62228188da9b9cbd00c38ea1d9919cdfa99bc3b1909e34b8ce14696b20c1c98ba5e70761247a1f4686ad3d6ac2b92a1a66bd8d215c65c3459475bb8c2005dc22aadfcacf7be03fe0fbe4a71c386cd3c1234871513eab4b6c2097158c6f7fa6851934cbb4d8a14c9ca239b4baef258e8470521f3989ea07f7dbc14f54c236c70285a1ab6c24fbfff033aa41a384fe780ad0ea542eb58cf443b0e6968b5013d159f433cd093c0c080e3e21321f57be833ea13301383b5443e5407bab955d34cd5e2d9486b52fa26d1fee186d50b32409896a324643b2319918f15f35bae99cae1ef31a5c26c3171632305c224a9d9a63deca5aadce4d917812c17c8f62ce2f322e26e9ce959ec051ed2e0f2f39948e0d1f9bf6b4203ab599d48a6b6e48da62b1c7be6e1551670a7db4bffc933940293ea1656c560e2b3af81d27ac8c0153f9d10c0ca7fda9572026804603963ab76012d285b6f2bc444136718c5408de4e476ed483cbee9836f5020230cee8bf584a38f77166cfd64c06a00e8bef03fe3577cf5e466ec66c2f40559b199a1c3eacaf2c3e282c3adf20cc8d15e5d6aab01a152f6d5ff576da79e59a5c25c3062d452e66857b2533a4b4552680da0c8cde834cf12d287144de5c4907c1f13d6cfd97153ea7d118c03002d03868732c81ac62e1d92c1f27b96bebccbdbf366fe63c80411eecef5a03133b31c04b26fbf114d12211f6e65c05008e84738ab40adf47d009cbc2e36b551d3ac42f35375beff329f9c6d99d324d9129909831359d7c6017b0e323cda33d00e76df667ab0a32f078d433ef9344209297a17c2313de9510dcf12f4b6530471a457be8aebb06d1cfce7ede7b34f0f8742103cfcbaf9e75c50ed5a917639f7a3995c3d2bde0f5b6bea0a60473178a14b01eacd29241a3bbdc3cf3322fe2685aabd3d0043e6e51e711b25d469ed7ba3214fa0aeabd1318a610e6a246bf5a352883b2c76c5a344d8731d616271d451d25a9e8d10a80ef79ffd8e29412c427a57a9a07c2c39b339d010a0a4f272c676c374aba985039e769d4e3486496a51b82412668177c5b11ca91ea4a5abc328d23a25301483d346ecee9f8d3425477d3095b0c4dc35a9612210f11da5b22ad7c12b2c1812204cdf5beb7696594c4e1f63f00e04c2e3d2a836177c915251666dcb82ab4e3566c44f41283098b1df0a08c3c0ecc9077d04bb956d86a659a80287bd81fec36ca2d515b9fe1800fa37d5c0ca3fca33843e8bc64038106f63604fe9712534ddcddb69ba849091dbec88eb6bc55a8849dcd0c51c34a71726fc51ed3c02bcc8d3ea4b49752d8e1b1dc8ecf816b43a12014f4df2529de2e114b723624a85637774f26824ccf48d28d5ecc5d963fa81f1370ca7d2e5b2ce6bf05da457c42a93d9d64286745e5bc0007a551d242e6436c4dff4526367df01e2ab17dba2df3da14fb1cd617c73a38b911fac2ce5ff98748c31e5a8aaa17d008c6a92e8c6cf3ba0194c8315d8a2cdc78ba500f7b7ccd69143da4d12f2aae0689e232b0a5c2a51e29d56093ff10b7f34560d60f519dd2625e976e2b39b149ae013ba4e6e5b8a94742af49d1c9ee5cf85b3fd1795bc96b84189b0351145df70cf017e034e707ceb5e9b85be7f12c4bb3dc7df7bda8fe125974fd70126fcdc7aeaf3171b21ffedf2a9d2c7f8d3584d0e8eb25c4024852e1b1186c66ca7d6ea7ffe4228a7834721fbdc2b20868dbaa6292779b7d5c0b0803a721a401b162dec3a9d0f559477ac8f76e422b1d92e46f227fc86e30084ffdc79026ac5d7c69468600ccc21493124ba439e1aa779534276da0a12bd5872379016115d42affdc7b2ce75e3a39e56f3d731df4c8c2d9b89e305eb27b510ec6edf24d5bd51fea11eab4ce3dba7f24dd6be2ebb81b30290fa1e1ffd5d73eb184da5eb7f1e7355d8f3fcc78ae3453519d74c43591b59ed04e31f3d4fd6a5f556cf36048a16ed987f149b964c32ec2559367e9ed4e254cabe8c34b0d512ca6966c0b0dce4efc259222096a44d92635e9469a809379489ff0a137160f4f995a1ab0f2890d8ba83356d6f05e3071396aae32896821839ee4193683053024c3968e3ede5540803bc4d0fa6f5abfd71b74ae2f964e4213b54cff7880c9478dbe7885a7076b75e04e0bc71c8923850a4b9036275b61c37a5a84280084aeaf00a7f43fe16682c3b5a02fbf86f9594a4a24595fe01efae11c8c1507a7eee75d4bee07dc77f39f30976a4e629eaf3ec93497d8d88a2ce6253bc612c228f59866d006b00f2dd95845a418dd20bf738015c4fb64c45fa0e99565cf335e3ecf42024dd4e03e2e8af2a59a231c506468c2b49ece75b34805b88649d2b83bb02fa436e2b0349f41efda0011966ef28b0160db0aa75aab8b04924016a095360f59da09e6df6167b1dcd2502c605e250911b26ae91fa6ae5672581b7f54e3e35e26fd9f5b7652d65724266fe9d53116c7ec895db9d3cc8d3763fa99f3d09c2a6e757aa53db06a5e120cfd00c676639a866096b79a6a3ddfdc839d4956ba847f789225abb894b9af87234772aed04af956d8662f93183bcf321f79d799e54fa00a840b316d80bcdb96b4f1f3b0b07e88efee34628520f7322074e1ea2117a1daf342670087490fc99d710c68b5ce4276dda91145097f80d5cf73a42409d650fc80798d479bd004e78904c411fb3e211f97b4f1801ad1e0c9c474a2995c32392684c60e46a82ca96cd6d4b46093b61989916aa250cfc54f6dd28ccc9d79951f4a1d854de1c993a49f0c2a9bb14e9cdcb14f0dcbd78019c0dcdac13cc1877801b7cc019d2a9a4167a57ca11b227ed41dafcff87f12171fb6249ec5e2712a0bdfd64f78ac3c69eef1de9124f8d355a3a901c894579ca67442e872fbbdda4e8114385d2b45fc29760e8a67aad362737ce3d914f69bd4d9e45587ee1b1c1155a2175841aeac834f5726a86768f951a1d27673a7cb17d3d5a5209db304dbd381432225397d6227a52d59167f05875e1baab0ee6495cf233ef96f20d065833f86bcec6fd0bf01676b07291168975887db710d6860d64e6c11211fa02a79e1e179ae9f5aaadcc307ed700b4a60f2157fec7e8e368671bb44663ff1dc3a8280f07eff40c107e3eb31419977d7818227c8be819cd12cdee90c517c12b5ec1245d4bf066936a9e870899bab4df3ec02f3f77d53ac0d96bcaf8b2ec688da26941dfe9e9e603825aa47cb4ec98f78227e990deebaa164bd23759507c49341994a644c3fd7794b21e0ae28e3194152a7c2530e2dc589c0c07c2953d85a0c551cd80bc7dfe911b5067074815ba558eacb6b5d3082a1a05861f16dcbc33d078d07ed05173950b882b9c9550351d6c058a14dd814729f3e12d45cc62663058a4d80b8d43b82e51bc065f69253d8b5ad46ae83c249d042a7ce67c4a1853838402f324694469b1896b27e759b443350f7b9ec2357b8f1954d64868e451d9496d7da5f779440fd3de9c460eba4a9ff1cb713364dc4a68182e3d1ea849e401e2a57b2b90f0ebabca6de8edc3b1c4a96b256ebf83d4644ec0a8530b74e518dcf546b92029ee67e2d441e2ee770d78ee418476aa1b888b10bc383f86a58c4f1cbf59d3848c9e7305ff208ea8ceb8744b2f45771a5092dfdba9ae0f83119e2dab343abd7e65f96ebfc5ae33a77929ef1b6adf0e1f2a1d02c06a4db8f1f1db2fe15f7cc56e7c3ed2d9c0b57bf45f97710d8eb6366ce5330fc87b9f17fe569b605a39b0c48ee1560108363dcc4c05fb08e7904325b3e7ca2855fab99affdbd2e8fa4e99c509c2354145edeb05094dc3810f1c8b5b7da0960d31912f40f5bca86eb085937de1a400a3fc7d845a3a0886e5bf386fde8e9819bc460a5db230a401dac3241acad1036a16363ea30c4e4104167d9b2b7c8615eb92cee1ab6c8105f67a663738c4dc827302f1dcfaf4f0e29dcbe8e84d43e014caa6f1680a755d6c3e13dbe40fcd8833466780e9762c761ebc1352e86f63469b51f28e90907daf6a871f8d7ce6d1405d52f04d1e62c5c3612b948a3df185deed9efd9145bfe4dcbd4e8cbfe77b39f2a83f2d7296887dbd35f478fb3f1454f9d7588791c0da2c3df4264b76c4b0618cbe9730ab39afcca6262206074486ced1f0882a1455159c09985118df5fd3f6880d11121566922e176ca43fd79c34364d98a030854ed93083c22059ad9014efe086238aeed7debaa673a5c49383fce6f2d1cbaaf35d91e1757c3f1e9f2c030f949a91411cec71c617786a2dfe1ab18febddadeda2d74c597add412a8267692966936e7d4b9c2ae303b22607f394338773d056b464e6ce861c4fa2293160100f25d5c3bf97efe3f5dd762580832b61c5a3bbc0482595cc6eaac7d606bf336b98264ff0b27fba170636902b0a021ea08776d6505fae83dc905481c820fc2edddc244e5179803483895828338ea6695b14b0bba328920590009a875c86cde98504a5a33aadddc9bdfd40efc948904a114ee9c90e342424b49fb46ebf32b70a4df26b6b8fc0b5eeb614335579a080259f93e2861b3021fe1db2fe80bb78004abd07ff2080190138ddcfd36eda3ebcdc11515a618e53806c2c68621a770620ae63ff9644ce201349673f52858035019d3fff05d9a4bbbd8abd3f62383b6de6d893f7808a76cd85ff48fb9997661ec905a49190a94223cd636b535c6ec811c53cb5ef64cf968164a354347730e146555588cf028f904978262289f5356934bda1b5eb2c5ef7dda48cd6245a32b664284db5dca9534c2ac9b8fd1dd1e5d635e541b4d1903682cc97a1666d725e0ca2dbf6d04e03c371d3a966c92512bbe0102396336403802502dabfb5bb58d8e89bfc082919579e7ff0d73141047d5eefcb1b0d3fc04d201550a95172e2fcc958ee3ed1ea402633e4896731f6e6f5c7bebf749dc2e72799fb35ee115d20faf145bb6b6576f1fa4e707b7cd8bf4d87a52afb0a7055df294149b697c83ac907d7498366cf912cab1ed41736e3fa77a3c71c88e6c1f78ed5ebb0318037bc046da0e02de5d1d5cea315338622892c0493177faf15fd9e8c2100f9d7e203814b3e07ce219cc5a38d6fe085d6784f79bea3b455c56ad726129b903a52d604d32db053a684623f4b528a327e594623d57650dbb12229da1adb66696cdbf886caad5d5afdb2a78382ea2ef6ce3d4434c03fa430893ab36dbb268f918b9676185fe2bd9b97022b59d219a17723c83efbf0e8aadeb6ae01e20cd9e58eaef9f225104fac3c49a40c6ebfd10bbeb7287cba83a961059b46b1d285002ba92152732be1c44f227083f552df4cfe34bf745f1de9b280c9e8ed04cdfc7a7ddf7f50ba19bd5d5bc53eb6aadcd602944535481af3ce48b1d91dc5da16dac1c6c7c50f4fd9713e854c63afe6d23e2bed7a20b3a2f21f3db6e98de2658e0c1b003142cad202230996e21991bfc45783f339353726c1027cba77bfd69152f659c88fd43c9f48f5133da066576ccb9000f996ce8ea454fc8f24bf6ed0a83b8b24187209ca994c1780e731252f4120109996f5a9fb759ba0eb3975293eaa9c4f0ad82ee4b7aa37ae19c1fa607513b8f8b6fdbebb562250c0cb92f613c29dc0b1ccbfff07aecf35cda051e9902a1d01e364233b20b3b2d6477902be612aefa113b4a74ff87384b62020738ccc2d19c06f01ea15894ed0abf024d743087c2fbe013300e68a70708089417b94e9164cd02914d124e372930afff6d10ff75eea0e75ea7c61c047e6c9f6c402c0448821a0600b79bb09ca5b83a59e664eea45120230913c04c5461de1d0a498b830aedd334b34211e12de6cc7d0e41211a6c48bd0804c02c6c0ffabf7dbdf38eeed735568262c2f6cea699243356b51d0f1812684967199ddbad02d239db3a312795b1dd4a87c3ad4177582acf75c753097cb5d02bcb1498de8bddb050b8911c90441c7c86e9c2a4d29fb2a2dbeabd149967fcc062913e067e5d3c605266b4d1af9dadc441e25b761d02fd21390f42453c08f07f06c530ae7674695eb513704960f57126f22a0dba884d0abbf0469eaac0ff153a34c9b3d2374f96a594b0f9d5b1be8104b86f74aa87d9415f61909f05d5add7335211290aa8227d0fd19d28b910bcff72564cf7bba2f68b9811b956ef54538a7e724e2f23649ce2f59bb414f4916d06ccf2408f5d5ca98e1e9038d13b751005c2fbab3712b7fac9be6dac3fbe8c5f1bf2e13575f9daaf27f687f12ebc7876135906bd691f6e6047db9976e0bcbb05ff309c453aa80c878e101ce96774eeb72d9149674566519a7b7f02e86b96cbc0b0c1b59e778883adb1f57d8af80d02a03b2deabcf7c3eefd618e967bcb979ff5e57162e22b21b715cdeec6ee341525499c86357ddba0178a10f03a17c5a09228e43481ce2c017da9f288a080a9201d89e29bedc65bd9dc708ea0003929e83c1bde92d4ab9a975e48e4948c68e7844215ed30f4cd30e24ff7dd2df155238de6f9ba06f6d1201cccaf6775085dde815c0733cd014ba75de9acb65337bad9f1e641b026eae9181d4b8852b6f1a8f47413064b93c9a3bf6d20e674706363af8f85fb03fb665c5656e713914b7a8fb58fd2f4a98351aecf6c31e0025101962b61ec2b5a86eb0aa43b3485c6b1607823f1a639d95a7affb8f04a15d97c1f37cf9a0097b0bf8e1b9b49b0731780b0e94e8fb448fbc0adad201b9565378c8b1513323207b0cf869b4f81118874d7efac016fed16edccf2767186923013b54ca5b7252dca2a1d32d06b5dd343a604c8bbfaac54421a11259b6ef50879f6b21bb80bf9792b1eb87dbf0b939b615e6da1408f8fa4597db0150cd6a945f18ace284542853768045226b1501f174c11af6f7aca619680e1465b721aea79921b14646b6db73d357627f99fb23888ce4a98aa86424033d30f8e22b325f08fe342bf56d9b8704f91ea70238372995edb40b1b43a4973d5058148009d501a546cd8b4683cb8d5b9d30e7469af2a63ddaf38bb252225fc6c9e0d2970b6a7d9f60edb5fa4e154226fb949ff4ddad2f526fb406fcf2aa1dd8a24aff77e08d67394bcd48638ddc10b02dcf5e75294cef8b231730efe0621cf597a21b54c321c12a9e572549b2f0ea1de7b615912054119c8040aab1e9b1baa26b7946a75f8e71a8b4035d11b8de92dc21744923ea4cec8adb87d4f439668b683b62758635c730d6e3c8847805f0c7a2a3d8369618f78416b388cb02e8d8bc3f7befcfb220993a0dd97def1069f95ecefd2f321605a1944387b4ad5b96fe0d86ba33066241bd9cdcdef23c548210f033bdb1a8799959a4032d7937f040c8f3487574cd2eab80eef4a976fc37ee1e2257fb8dd0803850d5f5e3baf20fd9fd3d93b1fca65aeef5cde40c004a5e3d46a2fcf1addb7a5b77493c2a062ab178976f5e680963833b9b02a050991392ebb405dbc2c86c82f1cf06728ca6047afdb1d37f6f0a966c4bb7a8879e557611c5d56c8b1f394469b81d0a3ba803e4eb56ff433d942f0c909d278b3ca5af9a8582b6a71751ad9b0fee3c4db70776765f4def0aa200218b27840fa04d8b59b3bfbbc61f3a96c630a9c8928f59b53305f15294776afa4965fe6f0dfbc85d8a5d403366a3ff4cf746ab2f7e6d96a4bb485423cbdc81401e39a09f7720e0870c80528eba58eae8cb24a2afba15a6daa8934de36aba5fe7aaada9437161ea18e1fc3cceb13624b258743f7f0a31e9e24f69aa37d3845bf3d2ff4cd71f54106800bcf8c89a476f280fa063c8d990ffe98a0cb9a0eae6aac0c864aedaeff6475be52af46859f33d657d049bb3a2140747a0046eb6b0b1a7c877b08cb06d1971072486e0ed6ef74bbbc0106b3ce31e7a114ed4febafc0ee47a5143351314152e15bb1a8097b24e392fd91dbed9f7fa2ce35e01987291a99ab26dbf4c62e267624e7753c27b53c55ff36c9e7806500a41d60ab2f8a97c2c187f8ca67e3831d6ff15448918e1339b16e7ae8aecd01d41893de4d0aa91c5b2325f217b9f6da956b5e1137e0cb735d57ac9cde551fce9f9bfe9947ad6d17d368cef49cce88c4007d2a1b073defe2d6b5fcfb45089e85562786ffcfb7bef34c24d6b8c39b1642285fd641e3354b6612146c18cea959f1c58012530376eb7993626b9f963ab15b214f28d3d4ca5670eccc71b835d9ec476871a31ecf192162436da871a06fe2b2859fca09c6e6e35779d2e1a1429d9b3f8b503eba782b04fae6a291ed483a5aaa86b3a848dc799dc3466569807c76fe2c10b9d5b573e3377e135185577694230bb49975225e4d20ddd04f17fc5cf9557b84d2ccd2805508db5c849f13a866d462f7341099dac78e68f81ed1f4d1051a8e78d1e7b3b1f5324e2bde4f1bcebdb45d09f8e67e63de384e515e49b6172186055e0b76ffd56c41e17db3822ba481921ff57eaeba4fdc76a484fddb6f9dc5538c92fa7fcfef17ca7a4fdf65b39a09c563163b30f7d3d06b743722dcfe45e9bc4f63d0fc594e85d23778a1e47444dd2a57bce07c3fc33fa613d81ba8af2423edc308d9e4dd0a08e1155254d71e14c07a31745e053ec2c9417a40036048ad13381451630d023869af057638de28f3401dc8b0dc2a3a0bfb60c4c29485d75918ea892688740db3917159336e46a04b7e0bfe72092f1b3113638eb39ce985d486b46ba47e9305d266523634b700c2699b80633a7c525c47b568966bce72d258d369a0c403896c92fb9cc4347f9a990f6476c16e4e952cf666b74a305ac64f23faa8724d3caa61cc34c1e8be2caa5d1e01e582f3d54ea90ddfa95393951124ab85983c03dba48a2191e406c9eec263026cfd8aef711ed48d467d4e2c12ab832252551e3719b6a46e271311e4f39b49f0b316e1614a81df509bcb99e5c6180a83559285682e26be4da9b60f8504c43a70b69faf1435b47a49e89d23a3122047eacdc4f03da7d19453c1301bf9054e436aa073bdcf1eb85e7dd0c15c4bfec0d806d5467657265ae7fa53c4f9c9ba89c9d07a66c24bc58ec1b662fb68b978eb406253923794559758e2c5348baeb2064b6092026021e7b3016020420acb91aef8e60712c1c2cf03c8c80254770559879c212fd9b66224d1fd72021ef4c17207f9140d6159bed07ee1e9b2dfb3d69ffcce1308e4d039d632cb91aa1b17b749810b4255c564a1fe4f48b90ac6d29c39cdb150986492b114525e7679886ad1a74a9feb1b12f4c5207ebfd2ef83743ed74bc9ae08777c2b49c836649233ba4bc59c0c5b912f28e7fa44d3b84506b920af2451ef2912eac6d40adaa03c5e87fe2ac3344fdfd92cfff5ce1fb368fb482ab0ce0c052f2caa8b2d79402beb3f1feccd8a44919da2d08ae33b4649a1a94bcee248ffb200fa65125217d720b6924713d61323cfdd311e023ebfdf0666b621e52154f5b6e7e4f0ca2a6cc88a4f98d00ee53ed501bb55f7fb043cf869db4802f8e3dd88f8a388d7fa289ea5e265524f42ea9b82b7ecc6f66997f700f8c86c1a36ec068e7ff7ac98afb8ec7e3cad7049683fbfd64ff393ef7f64ea176a9be82a40207736bbdd7a61f6d3cf5a5289619dfdd651544c15ab6b6ddd29608e0f451a7328fbb57fcb9e9373deb40f7cb87ec5e34666f0241123c60faa11cbb4388d17758d9497a75435ce553a5e7ddeaa24f66a42ba446cf869e3fae2342d95abb4512e0367b62bbbc7489ef28fac6277476199a06f72d45390cdee9a5e3799010b8546700bdc649c6b523d875a323650e34a993a0aa3ebe0ee3462a8db33131938d438c84db9ea5dbac569a36ce960c062d00313973b7d344e20b28405a83b6c7ed9b5a484c529804679ddbe09d940306b977c7eb3ffb6b778c44a6fa01fbd21e8e97cb6fb14cfb3cd8478102faa1d94507277d7e97ea90dee7fb108a9e5a05feead1a97b98fcc6998330d1470c74a77f13a0a26866ca01505f1c7c6d11a7fcf6897c62ef38cf321edcaa406480b7207356baf1969a67a3c3a656643a68ab1add1f3a67bc00b86a940f92f06074a7f4ce7e8f5848e9620afe40c578eea4d7fd1fb6765d62841fc342d619e3af9a622573a2f24354552f482c1f19d7fa20515b81900e8d868931285a5bf58ead23da810ef589d03f42a7a08eae4a79340f41f287634ef88103e4db8646bfc44cc244d74b311ae4be80e4081c123c196cb5c5e2c145bbf32609a3917e4bae703d5cf3b3bdf290858e178989c43f0bce98e17b8bed0b5bf5a567e06017176eac53cb73cb1b22f908832b22b31f44cdad8061577c006613c71715aa0f9322a231d9313b2069796e79a7dec4620aba3fafa4ec8794c2a508e467a3b2464790663401f16836698abeb89e5d8789f99ffdf3c45a8bf00339a3703b0592147fb9464c5d833d49f34e953e144c25901734c74d2fa2185dd6bf26d4275d32324e87936f4028b0c2afa9ca295ce4375cf54480eff448d8d0d2b2392fc91fe29c83f3d318963648896045fa7f8c6ea5aefa022546f5b8a277570f2cae0031a7985646c0c8e2cd798541720e4724422b514aefbb8fb63acded0a56ebf4473e48f0182124e46387cb03cda13519c84e0731a2cd434dbe10c428ca3d41cc1c91c0eed31d778f9a7b7c4237f2d85ec23c5e50829fbafd7775ab7a6ac8b78bcc76e4bbe901462c9f2f855850122ee965229eac2b26316bceb048db69cc9a15da442d133168e5dc5938a769e7bc19c0b05da4801b29c0107c893cf52f7a33d670516524fcb62d0ba90d703dcd5b23228ab8979e8f1b78b6e281928bb71061c00236dd50b0dba06d0ad8b9e44201bfcf9108c75cb6cee46c1a437c2d9942c55069fc98c979a25c4eab60d9de37706152160bd85fa90618ef2c3100601e5a687adc5ac02dbbe3593ab1bde05e6a8260ed8c618a642cc3aef11391d01b5b3d4011216021538a9ae52b1003aded5adfaedb52c3a99f63f221ad0110aac47278f0548644fa16c3e8dc5c2aa72e9b7e34745d0e994cc8c15eab0f348d5f0b0da8b143604eef4b9af7c65ad268e026c47915682ed72b28720dc0bc7012c991d378a15bf9d732630a0afa867f895674cb81fa5c0ac711f23e9e69e9fceaad513d0f7b88a1958c6cd4f05a40cd3905dc305c08cc0240d91bd97f327112e54f0913df8e12476eac9dce5ebcebb2de50665e55cc13552a9a29a01c12e9fdf7ecedeab85f358dc49f128fe41742e01edf10b2e1840ccd08b47524d05fedfaf454804736c951a654837d3c5bc7f354e758ecfe08c8b9dc6fde8c0a2842408747aa26da16415f8a97f7f7b262645f978143867f5e064ed39616153fc97e2a89b814f74836688cc325c31bbd4ead00e4faaaa3a299c69bbae85e994bf3b440ece5d0d93cd2031d30ff34d6f0d69963824c5fe7538992e88375e6c04dea6d956e0bb28166151f179e89bf3ec87c649507129bf9c4bde3465c3f148e68ef7ca7b2e62fcb747d8aed15c4b0ece6c11aefdd8a543edd14e0112328a2fc59c3fb4789e73ed17d637508da80bc10397743030640225dbd566760cc87255f5e750b20f092b5dd820b2a297a30f299ccda8ce3c74c35f6879734616ba5309f2e0f4841e8d618a1d9f4ba40fefb8ab9dacfd5ce1c50a613bc26ad41171bee129ffe753ddb2daf71051f79e480a3b51e7a6ee8ca7db28efd399f8fbebde5f7d300237ff986714dc709fb6c9182363315fa92da31a797ba12ce8ed48a59629704434318fe1d76fc9f7943f98904d85ed0b17461f46e85213ecf80e4091d1de5325f3ef7d51bed3cb2e7b2e4923d56003161812734578e3e27661fb4caad30de53ec5b276aa4d87824d800bc29e8598fa177888d2bbdf4e418c96ac7271ec488ad0be36364701eaf08e5456620e4bc6ef24fcb6cf32824042bcbc563b2329f86fe41f522ffd829d0dfee479617e597447f4b357592edfd9fcf29791429bd95b1b6409ec00ab61205d742a65748434fe09f483ffc05c8b5f9deab746404d2d58ff1c0b6a566a3f29be77794a2f678418f4a0f8683a6bbccb713a1aaa907dd6a0e4e7632633206e95d97b4a46c83161dbbcfa10f0a57f501af5cb57c3e4d093ecf145b1a481e77c125bc4561f0136bc71523bf0ef5c9332773db8b93c7eae9da10c57b17ccde9ed81def3190ee6ad710f11880798e59cb719072f2508c1618dbc0648e43c52b8e03d6ef976d3ac31e35ec7e35065512192b045b465b7418ae195f79c67e00e06870794792d26371960225aafeab5c3e23b51dd18a0e04fef027bf444dac6d6620f64ee7911ca954d2634adf1bb6d5d41dff8ec2d9f4ec4df5fe638492d7500340165050282aee8a6564ea785f461e53206b07e105df32ad9237f87f6c71fd2db2c6dfe9787ac9908eaf6f3c311e486e059fd4bf61860e12a88afd2b9922bf6fd69f1cc04f10bb3a85aa7dee47ec10e797d87e78dd22d963e3f403e59ffbf6c5822c75b6fa03a2df2b8f6368bedf28d73776e7e6691e9550a99bc8c040711dd3c1eadbf9da1a07628f03130de2478aef7d0d3a73d086e3a361fa0aea3099036f073d2a6658fc5736b5c48863bb54b9c6cd9611a6ead66217905aca548976ab4fe34a93a91686787e23e9fb35fba25631d6fc5c3a85cc48c61be9f7a7c64ac2233312b7e80df9d2377910d3c11b1d324af076cbc975b20a860147d7216db1290b4230a429e44a75eb8f73da173627003afa374f066afb8dc4e8be928f1b6212ea9175272e40f3b4582950b9d603a0767aa01db5f3ffda074ac54db07f2b9ad85f9bfe4b22acbac7c59d7a747b1c5e5aba003f25fc3452511acdc7b7ae11f803e948b30500f9635b3c66823095d65f2ef4d73463700f3164a36bb908970e3a0a0f3e296ea0e96e849f8f9cc9566f585a66646b62fcdaf447075a769387b861d8c7a96edd310c22d7fb845c0ce558876ba166f1137a649c79512e5ae89c2ca60895c4543246487e182435fab3ac2837b813071cc3bd5de0320948afab89bd6212e59fdd6bdfbfab3f15ff7251ae7dfa310a55f0dcd0b1fb793ac21824de9f6d0fc6b248489d05412cae47617e7bdbf4ea8436679ae9bce7bc021092a9bab55de47cc01a82ad088b0792dd06c780f7b0313f0a579f24c744add8aeb612a14a813faf3b7a5b83858602a5ff496f672a4082907f231428f56af1a03a0d08afcf8e63bb1d61005bd2e86dbd10b662229f020ca5c6bbc43160edde6566a3a1c66b2fff4d5072691854aedea2d7d8b397e5fe30eff3a2c48b3bc8419b9ce967db756173d75c455dfa3653eea14135899f367a941ec35d4f6417b07f05f6c64ee8021847dd73ad7ab09992d985ce376e1b4cfb45c109b8072b47542d6924717edbfc72580826ec6e1691d63a31effbe177b64dc709b552936c2022b8bc5f3f4077d398dae5bea223d86f3f2c089c4b23aeef89571c8b4f7b5146f877b03819ddbdfe7d2bbda00a941e60a5b9949504eea2bfd1e1ac215cbe7aa29c6de68b66e92b145b6de25efbd5fa41e6596190bc1441d7759ec4041c8258ae8b64acaf7f133003aee553afeb41d1c1a3c9ff8e43b855708afe4ac726702012fd6b05063e73146881d5082ce438c3b2dfe788fbf6ff05239f93c69968e10c8d236b62c250442eb1a741c4377b616a79ea9667610daf838aaea92c47b67637901acb7dfaf8781df53ee64d06dc1912f5b4189d834a965ba835d18cdfa8e38ae04c9d8109bbe2d38601fe39489826aed6d22f212c3f6ea4bc11ff093b24d8a6503129c591e1a0faa87075994734e4c1070881c06840515b10e379f522fd380b67a1c2834a4be1fe15c179b5f5d1ee5b71a88dec4ba970ff042165ef3c3b2de9a06d9c53595bb0afd439bc2eff2c354779825ab66d0b59666300d3952b6f39b77df655fe1be5b02b48c5c7880803523ca5c3aa1b545147ebf3ac4db5beefb66cfa54bf3be009b263f97b5f73f8128445ff1bf6cf6022de3d2f27ef903663b93ac7f1447e4fe8b1fe01874e636827a829f6f9234e5d5ae73c33fcae319ea0d370d7b0d1df2b10f4eddeded7e856d5bbf457406d80e0ca1a7e79fd4a3376cc4d6bc5e8c31878852cf505cc35e8ea2f157664a323dc188f505663bb296a42100abc413ae6c07ebb16847cd38a141368407c94b6f820d57c1f430b0611fa786048da0c555baaec391d0706945d988353bff5c8bc490dccb5750bc427d8945fe2a7948af944f066c7e8332509bd57a206de55985ecfbd0eed820c1d04a8fc48aa86200df8f2e0efc6fadfff0f998b37f6e8d83f0d98da1374a96939fe2590e40ec19d4f31c3b9c579db0ea9ada4968a9649acc536a3b22db40e44d9eef7d5a3493646813db9e6216bf4c5b7f79bdb6f761a7fad11221b0820ef57e1bbb75296d0638cfaf1f1cfa16597fa5a6cdbf63f4dcde1164929cc79131e1b72f1145b1cc4105f428105dddb56c4269a397b06f5519084b0e65629ad5534a347bb2999368936ef710ed521c8710d9caff2a7852ab8cab4c23fafe275e3bb96a72e99db5c620919e6cc6147dc9d887bd32442289c79489595a95aee595466059c9e0a40b7172b2189605a7f4d56332b23e08fd0303bec70f907e79861a795b5c661dda36301aeede4558a98cad9956fe0d3cd7d9d0cb7784d21361f9a7275e69efd022492f2dcb36fcfd62aa0a0104f087e012eeabd60b5303e35535322b0611c423bd372d2c04fb9e7f4f9cdc3ccc21535ede788105e998b8475ba97ffa430ec8975667ef7fd6cbbd7c8e573351d43248005c6679ce7778449fe1705cc04e60e64324ace1d74d28ad755ee6046e48aa3ad456b5902e7a6ad833c970aad3c549261046ee1da97e8fb23f5fb8a6a8c00ffc8ece0bca007c34e53ab00fe9122c9dff57406bcaedb8a69d5b46fc89777a0988f9020d7e8b5e1e50952d888ce08920629653fdfa29efa8d392f355a97ee70860a8ecfa9b4027bf4f5afa382b5dc283927f270d0ea429d9f8cc35d7aff00fe63cc0fd82f8526a831666ccd5532db26030cc700485936624d42262ab3243cefa4a7700f4edd41cfd82faaece34af79f0f25dd438f20632a2736182385241f63ec63b9cfdc22fb0f47ae28aadc982d6364df552ea0d0e8ce72a94a246e70cd71708c13b3e902c4aacdd6e0f00c10a32e14117b050a3727826a045b23156468a2ce2a7db62e342b68ea3a3082f14d93c1ef959f966caa404705cfcc09cd950b700cbc8c9ce47ba7338ddc4bde85e292c6a9a678023316f9065cbfb916429d505e9c21e60c8b94d427d76ddfd12cdf297126e4b33ac2296009770fb7f176525856a448271a649386912ff7f64ec1a3ff936253c86aad8535baaee2350a3a38e39563b674c4d49d4bdee8cc2056c235c277bfb67c58974e60e8b8435d40a01575b42009a2af82c8ae1cc8d1a15e300c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
