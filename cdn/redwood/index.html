<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76e1cf8a7bdb16f6b66cb3ba44922b06eee0ea68bf8637ce19b6e6513304ea82cfd0b6b735ebc308b85d2ce5c14da71283c79d2be0385d6a15a5d52acd3d4d17b083017b4f4e72dd4c331e5663d9b878caa3e4dced48344871435a24aa5b9fbb6aad73e1aae6c03b475689d5f035ef2480779667050506454a6a56bcf32e56fbc30216c0706ff9f02c1daace59b279846291c9be4ee55320a8397fdee9134992c7185194964c953856b56c449bc66ca3c537d652849ddbac3063f0e4812f63c712b69851c3e6e018da95120cbb615e6f3647d717d891071cc67746b4f1104d26da373f7890c861f5f92923f3010d16ddd21cffd142d1d708d182e02cdefa6658301e394cd0c9283b9c2dcfb8cc3d0fbcebfc0adce83ec59035a4b79f33a8e1fe4fe704f372eb725b47d084d74a6bf24f3b4abe940b6a7a0f91c36e707b2406d21a2946752c9213b416ecaab9dd0db06cb3c5364c014373269ddb8903aac5f24f17d6f41dff6fcc66412233cf5cba74f1bdb3dbe1c21051411b925ca7b82cea2da832e6c10d1d7e8a8803bb5a75d9cea01d684e864688521213237c67710d77db72410e8001b533a259e9103e1a8c8048e94e8047981968564e9e7dc9aaed968554c64540e2e7838550fb440459cc89299a119d6a7745f404714cd4f586f0ff2588a25f8a1ba7557d693f244974f81e5f095b3754fbfa296e19b88a21dcd88ebd12aa949fe7e5425905d71522af9691dc2f7371c9fdcbf96f9e543d0f412c5f18c2783f4d62d1f6ee4111c73e4c15e98bb95ca6606457b5576c2154bf8d54321b668b22a8a666cdf4661e55601dee7e885866672a6aa1e9c9edaf2cdee3c5f50754455d14939cd9d94c5dddf493f4f8c471b7bcf930e8186eec32013e43c745fbd7375c0c24f4b8b50241ae1476df39366e587727a1bb8a9d10bbc7e8e45091c8114e1e9cc98163999a854375ed35fbe1c19eeb496a856491245f0998dcdf709efdc2b2cf1d3611b12e0ccb52264cf93df1964a480ecdb51d3ec917ab46d6be73a398e26768bf90bcef84adcc669d524ba6ef6d7ea4e9c19ece8839673ba0cd16f67e81832fc4618dc8d569082b9a6109854bdde1722abd4db62954f0927bb68ec75ca751a071ff47dcb2bf9b194b1d6f28457237d3916cdbcb05452a1db6ef3b02b781d09c6b38e438a7267bef2b48928714ef51bba7dec7a095111b8d65d19f277cfdd1d0c8506ce5284537429b5a5f8f3c8fbefa5ea19625ac082d1e2f40080f0d1a265aa3796b3a29f2b1ed2039b4d68779753235ad8cb597e52c0ef546bc9f3014050a22dc36541a27afc2551c9fa6768bc795729ca4233ad33c145daca1134edf7b66a9f734a06e54b31b7924503a34fd0f126cb68bca27d57eb9b0ff88d36792ffc7b1a12e5fe0a14e30b44d8d48a6ea380166d162a64956c3fee517a7f8e341da55cec78e13a545fc4b292ff966f70c77c49842ae02334e258b2d475571b7f15e231d788f4aba39f4533636f50943ea0a8f86213908e5b33133c14c87f71b79e5d0f6015af328965baf81ef1ce246625f5e04d5bf30390cd4691f2ee88529a376b26aa218424ff93169aeb17cd15a21233bef4b7989572461d4eaa0a2af77aae07143f0f8a693eef007f9072308422218491119a0a291267e2f01bd4bb06ec7114bff46418191d0e5d6b354f0db8d14f98de3b16e2c8dee802f34513bc627aedd13139fae63acf921459997b0ee2018744eebd728455661fd8e2e56837e2e7ba33d342ecf939086f27b4b861a3724aa55fe5f1c8f57700a10d7632f05c39dc8f965ba3522beaa6224a29c517791dde8dfffa2810090c893605384bf2382cc0726438a173a25bb9968928b9daa6376f49bb8808b16133c3486990b7d88f0e3a9032e12d646a4e895a4588cff6811f3ab50eea9290ae97a038e89ab82f7c31e7e6f8eb590fb3b5d3d257587ced7b248eb1897544e5104b59f0c441ff1291a72f23bf0cd68e4983ff643eeb3542e834ddd15c69b16543e5a6641e9513faa551bc185d48dde5cf846de58fd91c237cd0755f16129b92da403f9908d015dea162b1d7ceda87849ebd4ddd4c5574605782a0a8b79ec527da9c08c80012473afbe4dbefb3e8156da812eff2e3a53862875638a8716c1fe53b3b5ad7f4dbabaf37119505a5fd33ddbb1c2c33597bb215defe8c0680de4450b680a62a0def26f136b1c7ac5d0749941c9a7a5b313ae099a06c6652d6d614bfd84e6a2228acad53ca0d9551cc82f63e4483d47004b8709178c21cdd2b023578c49d69365e5c959a44819aebcea92b4aa90c4041cb7c1cd92fc94e8d3de2cccc76cd22b069f56cd3a314f7941ccb562dd2aa1234d340c8c4253a64b3a5d4926ae14c0669e8585470bebd1133b2f4442ae88da10772f3dd329beb8fcd14f089ff6934a0132a4269bef1e3b50c6356fa35c2e2b426ff32ce91bf07ba6270833b6bba28134f1409a5423f12f8acaa4799956a2327d968aa48650d543bd0b4aadb34bef24763381de77987288d6c589a05fea8412570520893ef6af9ba89d8b659d2035db0ae7e5a681c173f7b28611a951b90e3965655f5f7fa083169e2989aa9af4494411b71c4cff75cef06fc56f4840a9f588ae9978f6a9310ac7d8a7bfd2ea9ce30ee512f7c1e11a8ca0948fbba87900985f202e0081bcdf5b4fdadd0a252caa6e967b344c096d4895981c8a86e264e17cc848e34d8617cd07f220bedeabf1e5948f831ff3d286f459f3f0a165df8147fbb9a6c6db1c49d870c7a967e9a430b0fd2e3cb5589a655b7c2dd8b80425bc419cb850e86629bf57897a8782e7aab2de210169bbf7b08f7981125a0cc63dab3188a9d2f8caf6f36988ebd675ca46415853b3fd9351955bbda59690b6674dc34f368b5ca690db9428b061788fdba2d78c0e0f31425e038dd61d79ad8537a35dc849cfb2ef900891bdd226a252c5e9be8a1207791a9635603b161e03555d1771de71496ab45078d8848dceee3706ebd38a3950063cdc67fe05ea47eaf1333ce1eb9fcf9622d6f1f7a353bea868c8df8521d486e6ad7474b77c310b2701bb53ecbaf9c2d400c037048a84bd7131d7e22cd4ab35fc9039c09cc1995737f6a66caf4c71577f503dd7f4f696d342263043cfaeaf6cd5200fe211754f0619106807a55748f0c369369e3c23c0cae6c802c9c4e995f5449f60f7b7c25b1fe40b51382e2e61e68d5e40c23637d313d86d2b54d2fb17121d22302b2c2f8a44eaf16356137178f0a0ed09b272af35b0e792641dd0be93ec2d0ab3751d86b112a496c203b23897ec4dd064d595864bdb361c49824c323f33dc230e10927ba4a03bb60f7c170afae0274a95b861dd98405583bb5292e4c2d89e58c1d60ff8729f42bbba56a7967268df578225cd51773fcf2e9284c96f5beb6edf13c96af012f86f2fe6a202f08e5bea7dbd353c721404ebb65b51df07f65d770b0d2344c5feada7584138941adc7b4fa8bf9f7057114ab6f9a8151ecb3bfc1ebeeb2d6cf3b1d86f0f31dfe095d9dba4f4e0974388e9cbfc661da38f5bff3cc9861608d50645942974de7b1371378f59f0970ef7e2e20d57ed4070b3f0b2e95d313cd7aa4e0d177dc79d64e3042fb513bb8ef4a3205fc5071858f4e8d2c7fa21f92d5069152d1e21241195e3db3226e6deb53270e701ce16ddfe0453e7574a602adc0a3a155bc654ddee6d6f39b6ae7340da515f108e6640f17c1682e29db2da9e7c924011e12a410f4c2ca58ac665a771a6214367f374a4517a35856fd4dbbdf32394c732399e84d9ae92b7864a0ccd0da1ab904ca413c18b289826477b6e48ae0cbc0a72083f765293996df9ce10bacf5a5f84dfeb962f053b12e7382a5aa410597c23770126cf831e3241b34bfc64a9cf8d1618f584601935026df3b94b64d090cb82312a831749e6b25df3222a44881475546f7060a4410021859961795f9906557f5e013357d424691c018f219e1ff33c5ea88a5aedd7a0f6b95753d8a927244475a9015da89575f577d6c76e97a18bc8a6a658c6c3d2275929d10d3ef6151747d62edb3cce0439862c4efbd3331814ae1002bd88ba69bb43de72ae871ba4908c23a14d25135c5a0ac278c76cf2f36a1d2167450449c3065a73a0e17e345063ad58c0eeeb24f2bba1726ae0e287594ef2497d4363688e7d2facc40eae2508339e98f0149c434cca6d11566fba234a4f2a5063b295a8355e6865a702ad788d68e6a87c83e43af959e059c7eae218bcf3b63a331207a6638e4e4ac06faeb37d5af12d979f3518555408225fe55fd2df163803dcb9d28e0051a991adcde69ef098cde91eb84b00a6b23f053b6ec8a36ae03188e6cce8ff03070db369b9812c109e5a645c25ece6e81325dc5abdf6d2be05b33c986f8108b67b0dabc7835bd4abff1efa53a2c1582141b4935b50b9556690616883e1824dab565b4c0a5c7a3cbe13aa2d94db80ba86e6046ab04c0164dd954e22d0e8b410078ba886b539c78199661acdbbbd8ff432a6251bcbfe25bc7a1e7a4927f3e89d8741113210a6bde9a1880d66d3b825f61d8d3f44a78f3a1f4966627071b455491d59efc02d41c9704a9633e14193fedf2d2c17071c68762878646a07740b0fd03e915d33abca66d50ec137dd313f84b7092c5ea736740a03a6fa46a437c39c39bb86d87c54ce3daaa3b65d200a138b7307be80650c72227fb970c4231d6baca0646de2f9ea1a2ad0d6db50c521d8a955ce115b95054eec28cd58618a6e9b00dfceed90edbcbcdc4d860f14f9c6691e71a7d68e50c0247820e705b881c26f97a6553bdb8e5ed42e04f66343b5efb57c6e16fd1a999385b804ddda2407a623f435429431cf1faa794d970e62fc9002ec67354b350e99f24aa0bc355486472c9e2d410b01ec82b5c9c48a7b93a9a04e8337d5df8fa00a2a23095e80e3acf92193ed87a8549edfeca6d1994feb6c84d4e14bd43fc3ab37fa7a2086ee96ffec7bab55e07c1aa06621daf7adb26bf6f387b9b91ff22baa5efc36facc86404c591e2761e0a4bf00cc06709a5f3d8823da41520426f4a10b78866fb60d820cdf010a08af4e6632ce9d737b00a6f35889f063cf924f691c4038967eb39f3321ef87319685ff15d097a9d700abdcead3f54949bcf29afa3f5c1159f6c7a497339cba45a81aec19560ca2c2cc61afe9fe9ebb4b98a682b5f94bf8102e261826bd756c86f9a20867e389028d26e487ad8c6d6734fa67373a8da861bc655148c8b7192f02d6775fbb490e2f884af68fe296db539886c176305132212a88cb1d39bc2c1e913e040bc7a5dcc901302019c7f34d49458e801ded347f4cd5210deb32c6aa4e85ac7171edeebbf6f4a54486dffa91b41a49df455bcd2a900c7a10f70a23d7e973fbb736221e9c9172bf917a1e8d3e4a04d383ed8dd7b4b9b84a18188acd1a50304813b9e471702b638e4c8d026df8d3e860862b4d385e416e630339711fe78ec665aadd412f2f92ad5140cdfe9ae95143200d79e4344fcd7a083e17464f75fd1bc58842bb778de17218e702850cad5dd18e7d0a94b05d1180639aa8b14518c09c9437281af709057549927737d0c52aa2e7ffa4888abe759efd1908af6ccef2eb221bd81fd061b9f65116aa7310f5160d32c344e8472d34a5ba8dda6775fd4ef65b239142f1897530b42e6d5413ab2ce66c3bb05094010af36e0ea9b6fad3e6588f96157d14c507b9cab73dfdc970acffcf807ef76119608a82165b7fdc82883b21cac2ddf144fe217dc33cbf8d7d831c8ce9a31e809bd540929a4c05fd612e86da42f11d027a58383081ec4254d22c1103677b7d399d64b76fd80af4b1440eb42cfccd3f658d16265eaa71a23826f7d602b2ca0c9cc10fa70e2082c8fec83a846646c8ed7290bfa6e4c2f4fa2c3fbbb6b43d092254c6a5e73dfcfe71c0f3b8535ee10c55c1113cd0ea0208a237c4ab71f7259f3ed5c996c1a6608a66fb36c42062bbc5a70f5e566ff8af066b524e61572b32eb3c425e590bf9068684493914bdd24beccb6ca10db50f7b727dcb4abd0ba4f41ca72c57bd25dd9c3013028eb6a1fc8de6a905aa4e68fe915732c2ff8ea3a78b2fa51a488a1fe78094894c2c0250516ceec4b6fd5fb89a93702fa40063339e50c6e208121f6da4332fd2138ee0e3dd6655c41789b78a9625ed9966452bcf1420b4f5818467d4f739fdb9d95a94e24f61790e0008cff171465ac8f23a1f88a72eef8d0a25fbe4e6e33a6e6bed493e59d5a7ed73f41b6744380efb455898e122b72796798693cb12af9ee2c57aacf9a9e2c77200af4a015cf8a514984975c627fbae1993dfdbef7b01853202a58c90560590f1182f927241bdbae3c2f600a19bbe4a0f3c6002761196d78e6f9dcb67f3285fa7a2b6c62bd481f4b0944cfb21a48a3b8ce6c5524b75e864fc201313efaa83a9b68058785d502984b7988c93efe52da2dbc376eb7b6f4043316a48213fb4b2e60bae84af040664b76d8386e7906a8109951f98271e2b3131edf5bfa75bbaa4cf70e3168061a2fc34c5022fae8cd972645d3905c1664583a3297b9b4988f318f28e3acfb202f6738d9dd715ecd87ee138e01978a570f1881c29170304aaed01a9f839dad723dd857a2fb44a390b2e4fa7d8d07fefb7522a28c3e604cb743b6b49a727b6d7cb12e7725433f2121bd99bea9e5e97e5167e919c543037f5742c32e35e1d15440c8ae42bf6c2d7910bb6fb38473172f016174262d62505179069e2f9d345bda76bb5a1f5dffe86f506ea9e6e00345481b449c8949da64ba29c05ef8b27a14d57ce99466b48aaae7b0430a6df899ffba91b373ddd73207401b1e85b9fdaa00f9789adddaa2c7874e8a75f282cff9f7f049e0fa023fdf33cec0f011b7c8912cace6c96298e601697bcb6fabd4eabfa3bcd67b19139d292b58d2b91e7676e2ec2d99a3622089a70f3fb153070c02ea61f17f27c41642f2e0584844b0e8eff3aa17207e472ac7cf99c00d5a214fd3912c74f0751f89d083297724d6f15ffaa458a7c25d35b58a693b0a730a153c3bad4bdeca703151e563b2265c2a9197f4d0a38cfe375e7cda68207cd5ab4b73e13d42a0241f8abef4f52887c7e271119033080d151145526f5f6840e112e6f0b94f6ed3bbb017b16ff17e1b770a70b349aae8f1088015fdf70e198d944828cab92088d98999ac8022c95348b8baeba50c21d9fe563ed6303a59aab5a88b6096d9383e7b3e870fc4598c972d92839ccbc1714bee5a608f63cb2e279e53816d894843b51a513f96069f17476e27611203475e03849592827ed472ea6e602112d5ef88aab3e4bc529e111d203f4fd9bec74bd3452d5f3cc2ec0e1e378eff74df643d8d7775221dd9f14dba507e5eb19851b42a25b607447b38a9e9176ab12eaf42f067b6be3de2ddc8eca4738ce1cfaaf10982c6084027d1e7d2469dc38b00827c3ea88cf12434612a13d8f66b94ad9e30bab6862d73496c15a1a45575c4a671f830aa2ec1d844ca21c8f2476ce467c44d7429a1a826e560e56c8852c408eeb12aa9d0698e6f44b0df14988fd18a7a3f6908720d0a16988ef11c1fc3609f621363da2c06844de48e0f3077666a4d43165df140d113268396d279e38b42d3a828cb6a4797c60876df3029e0e5d9a7127fc8d36516315bdd1f58df140ca1ada9c50d4295886fddc96292fc6b9f95fdb28aa62de6f9db5d50a01c412b201fad6d3b314be56205dcc056e0c79dec6103de2a2e3e1909f3b8396b58827765baf56c8e3f0ffd73ca2a307d3fec19fabe702875f4c4379c5bf84e9b96c7d787afe1c184e3e0d546f021502abc558f0d2c536412cd4e6c84f93e5fe1cc1c46d27e7f6e1972771369e0eba05d578e3d71f5860f44d769831becca7241845834b4fe308d6de6c2518858ec40eac8cc2a7d0d4d865c2b443b33507ebdabdc7b8db81fbf9ba6e813c9ba6bffa2c52aaaf5c233052e47fb588e5cf51dbd778c285d5617b5279117747d4bd72b719d28191210fd7be5630126ab44fb478647ed3958558113281e35d0b24ef225bba5fbcc7cab3b3ed9339076724bc66710b6f4449513d8a225acd99bfe41bb19937208060475b16deada05cc84155f5b9d8e90229acb59a1dab06563ff3ddfc50a8658e41bbe17ede3a23fc0e66915e4e77cbd9211478647072f81d0362c251d6ea9293b56e1dd70764be863d756f195a1f659bd0805d7f51f16deab3578303ce26ac915aa8e6fbca72efa5ae5e40b421d97fda148b0cc7706b4c21d5b843e92ead58e91e5bd301ce0b042e03a6bfc346a2767e2dad05b050ab3317b59461cd4270377293f6c352c77d6d61fe919317b895aff85cdb8d9c4e4e342665f02b9ef47d840b2d47927cd1afb23b0b7b125b6810a2b2ee61429f71b1da5277bb56792730294d07f2fb517c6bc6fb452b2822225426f8d054e91e82bef0b22898435784f40b9ab9f2dd3ceb17478b84f9645277f77d823f31a833dc05cb1b282ecfb24be92a1d6c9fbb1d0d4381a342979db4151f5cea10470f2ce46d18f717e820becf4a2d29b7d74cf59d78c58d0ea2220ddc62ed293b17c6b6f408537f4136f3e464dd06f79b2f88e2c9a4915ec50584a359dd062a267cb60be179671af8fb61a05e11a6899d6e62f7ed3d642f77f9513dabcf918d86cfc6f6d8c005fe3bdadf6f724c4fb467fe256ec5551adadc15169a0a6d20ad9af1e64da74978fd81036d0aa9aea028f103aa83760d2a01b1b04adf12ace214aabfc32899882c39fcf943b33c1e7bfb22f244b80c1fd8fe0eb9363405de3ee53aa03216d08cd2af03ae05af0c998000f0005fdd0b608bee74d1bad59dd4d0a0f556f68b6a8895a80e812d9a4ca4148381381f7eb7c7120bfcba673248562451aab4e8c50cccda1c6b0eb4469211167890935acf6643719381080ad1e02d5da0f52b880ff4d1eee17d8402cbaac6b1351cf0bbb0d3353eee7838ad91c25bee2da45432734c252869c5c5685025b9811bd647ac7cf050142c6432bb627368c702696acb5ccb624ef7e0538594ed10f817d914351157ccca8d2f320be1884b6d8253b73d6ebd83f0222770f43a0e8e25ec4277a78e93eb7d2ae9405be76f438e3e30d5c2220ba087534832c976235069a6e0388105da70c41a2cf741f7a6d068f01fbfed63f0c3fe93c71628e6a588917022f32d57d9b8d003f76cae01c9b971e3b222e8245c422ccbc48a0e61806b63fc20ad750565b2e53ebfe90368a84c44bcc04de0d354350aa91e547b41525bd2ca32e1ffa1ed5e0712decc11a7d760517f49728c5e671b4e618581a2538a5dffb61826ceb416ee2ba872acbf83435aa43e93a8a987ee424c6c71f280b90801e7c3b774dbf2054ef99d549b02fc04e428ca4d02c83edf5a78a06d916c7906996a958310b71c52d3db787ef6e7c6f14e0266c4f4cf6313e5cc564dde71192e34361983696ecc27fb66492b1ebed91992dda55c1c54559e9ffb1c3f9f99f1cb1c88db1ad758fa2ef0c72680c517eb62d20128046ab5aeb583a773eb6d76d7e637536d0821c631f05bfdd81ed86cc397c61cdac181a92f6601f6601af895d6f30b8df0e1c06e578c5549eec6e35a9eb76e0fd39be555751ae32ce05aa333d16f1cd0d9fb8d7f18b40986769ea3b3f00d05c4377de7e1f99dc4872031f8b6c49ffe44488de8ecd762e227b0dd9762f05a7ed6a4f8e37219e1d45220e65e1389f6fc9b0cc028be43a7807f7ba7a866344e43b201b8ec13497de8361f459b79d79658e23a9eb7f94d28f33e71e753645343723d6fce050b5c6b2ae52ea3ffa6c9cf4a43cfc8131f68da3c6a501591e058fba85951cf2fb409c5aa8884512bc34c0cb45a0fccaa05f7890834202eea7046151843048972d3f1ceb19a5d37479fb3f3a74702ceae7ca62d97cf99005998b0a241fdc9e9c02b827d6a4d63b61f649f2174d7dbfea5db8c6ab6f30fe4f64df499d08842ca64a01f770937ab30ff630cddb4ac63848ab2f07e989cf6a886665c96c3fe0d74e35292996e52372d4c58a23f514dcb2ce5346f4c36435bf297149e08353c1a6bf2049b109408505082294bfbe4aa4041eac282e9aff92ad7fe7bcaadee44c1c98532af53073926c43af74646963040651afd92c9df4bc5d44d4cbb0bf7d40cd152a268e1d05ab7595d136953a9eec0434024e507ded7d716c69b830fe4b730c49f54f6031ef0af6c4d4a39b2846ce37f386040ca831d9506faacc271d3b65e162d4cf325e94865e24bc611d71ed244beec38f99ceaf4d321e7e1e0f60ed3b62703ffd300e6fdb73b87af126cfa3b321582138e3b11d51d7df94330ce66d8db738c26e5425895dd9d7427370d2de7322f0f2d2d52f4ef1abeec60b1fc55effdb0ceca4133876a13b7504e04a85aa24b2508bd72df31962601bc8a2bb9c4fa63a1dff4d46b1ef759fee239f3667cd134351d6ff5ce6dec77137a95f0180724f604f13dc86704e1c82532fa104e07d8a5a9995ed6c9271e52193720857cf8c68e1ca20b186dd0e8dbf84c07b73c45887755022d1545ddeecef1bbd5e76e3b98a60bcaa3c0c8ddd1b636b3fd2a55c8fccf458aee8c979bf34eda348c187ab39c6817a60d46fd906a6b3c8e32bfca6b28624e604f5a19a60cc7be70154aecbba0291bfb92d1708f463a872b8fc773165ba1b57208de7a7fb25799d9db6ea328c58a92341aed34027fc09ec7774a96eac530af14dfbc63f1d84a79fa1cd3f6ad3ceb8d96b1b7244b0cf77ac7bc653c8e4ec7c2516e86dac4398b7b90c60b91e18cdadd7336dfcdc79b05817d42885648735e53c49f2e5ae247b0ef225d5c8cd2428b0df48daf496f6321ce686029b2d8bb0c20956939775839964b39628699f25ff7bc4370148f2728b6b53a50e2f55644a3703471fa8d69613dfae66cbfe72002838d703dd303094496a1e4e18a633f0d388533a51c4cde8c38f94ece732e1051b101ebf1e7af0010c4957092a4ec3c8ac8f1a21f082b5dc1408ef834179e62266b5c225f31dbd3e07086aab299beae6a036a8788a4aa6eccb54100d0d2cf4a80e84bc7809580f4218b7a6adc39b5e7419b74d2ba0a0d5bc7024e882f6e57e0e988dcbc4a4d844953a7de9a038f6e8a8ff1a4730ecedd925245b680713f2b6ec593a864779766ed5c4100dd757aa699843e9dad16d7bba7a25d0b5314b1c220dfcddcc5a74a8c2b854a8ee1df25afa2e38e708e5f9b9518e34db7418b26a3c4f56351b61603464c14d56cfd515dffa8d180b761f4cc7348017d0c65ab7a47c041e68cf5dfc3cf8533640796044735cf075d4e078acc675b65fa7122d1c99aae1a4929f3854b3d8893538dbf33806ff21c7ba15897fa018e8146a21128e434f52cf62444247d0ab14657f99b43a16521be55b4c63d2b250ac836ec595cfab07f65714371308016f18c93d5a201a6384e83b01ea95db809becc1c04301e93b9433c2c644bb063ce02e4c17f9255fab98b3b52ebbe57b183c1c90ec8075275f78f83754e2c4d14115704d07bf3e854a7a426ee8b10a2fee63b33f1034e3d56d50649ddd1efbb7c0d57ac1c8c232df5fe64a9cdb9cc87747ac3664af88bcb684aa145e389227e7f8501cb9b0ca275f22c533aeb1b420ff9ab01ba0d39fd2b97ac25de7b1d12685b416949f04614b3fa0f0a4a56d533a475e2cff5fac476b1374244111be74b210794853a2e0af2af1c115182ab1139cd9d09329c6d16386574b329b7f01306857846f6d2297d4374e3aee4156d9be5eb2f7ba2d8ec8329640255a455b96004b7750dbef4a0c1a7697d0592e307e2bbe6f0130bea103a88319ef22d1c64063a89032de1f0982acef488217b5a3989307f0135101443d874f71f8a19d1d4f0452afc59b81815fd454ed26e82b756e2a0355125abadd3933fd81515464e4ed86710b459068de95055db51b86aff7c1613e62d4890eda8838738686e43a5d28b0fc6213eee817be20dbfaa7ae51abbf3deffd011e74da0f016496314bc7f77283796c4dede2ec5dfb1f94a6b2ca0821f91e6776422655009b4c9e6b0e603365579f1054307d6b7b672b90642adfcb6c0c12f48564d265a06394da1fc6ca2f695b740c751136cd6da58cf0f64720e4041d3a3b9398964622c1b2554404feea81320b170446d8f4b1d49fea67a4d378acca090152923ad8d168ace429acb1707b6def78ef1b9370b7dbf1a6a323ea40bfb847a5e9007456e6c1229b97ccbd19929c9aa0be005594eb5563389202b1a6d3e0d075f7601c7e373efb6a4578b8bc0f19022fd12b809dc53898f0d16385702a9f9c65d7555d6f89eb5936bd2c0543be76d1e41f39e36b00aa11cd0d4c6672f5b5cb60fa058e63e84ed5bc5c78e9a6e247e9348ac44a28bdb70a05404e4628b09fd4eaf5986026622280e1e2f848b5539451a92406cc13e2377fe939a8b66f1d576ef843d8a5bf8ea6e66378ca0f593062bd8fa3f2d8a939247851596e76b9c3be2ac049c7db69a373896061c2ebf5d94e7ada8a558eaede812dd7675274b586fa5384076ad107aaf6d3a1a639472dcca8b62b1293405f8fb9cf6f6a405aef5b4cacc7caea2a679748f037685be0815b9396add1cfa9b5fa4e85fe60ad92f68072b9aad5afca770ee86cda657b7c30df1a1acee56b55adaad38a35dd4cb59545866185ebb980872f024154ecccc8ea2e1cd20ba5c8fcfba762d75a5dd9aa951edbdbae26deacdaccfa6470702f3dd4d079a6d0b01712d76f3a7207034f53bbc5f7a5534d78a38fe9bccaf7a39b053c1aab5799c298475a119a97f1f1e4d1f905f2d32e1cd55c1936d016cda9eaa0bcd064529aef7d58d333b7b1b56bf913199796a0ff636c8a889846550d24b2e3934d4122b67b76a992a18d908994bfc91b3b83655c3ebe8991fa502149290ee2b8fefc6c8337981d047beb4908cb1eb48b0b8f674102e0e03429748089770259c17721b4d12066ee32158019e1004d05a8f97fd59d8b9d00687d8986bd125f0bdb9f54c20c2a638c9880453509374bd06348502b39f857e8ac0f299a305ea2cafcc8e1f2a3023120d7430f48d90a7a52fb3885ebb155c9961836bd69949fc4104240dbeafd5a2729bee55e61379524bd7442d1cefc0ddf3e588fd86f7a29825bc32a833984d5f23fd4e8cbf62a2ecabfae4cac52be8c2073caba88729ce4cadf0020b0db0d153ca179b5462c1829a5881885599fb190d097a4cb5dba7a8f8d4115374c2e14a139a1f49a30869e38097cac837271e49fb09839ecd403372d95d5172433639debb45a6329c17050d44034291c453d8a7b0a55132ba36f4a0f125c53228b952532851267a82a274cc98ef3a01239c56f16014f1407e5aeaafbc74716286d9fd0ab07d5002c3dc796789208430c07166f682a606a750bffa2a0ff9713b3a6f911c71a28209250cb52d31e6fc2b105d692f7d90667336de074732e0ec8a784c83440aed172cc74802a4d287cb74535b454248cc783983a964a28e5c4650e5e59406f046a4c91017cad57019340dbd698a04800cedb28f559843758d4dba8dd8623b1ac6bc1094246487d1f83bd1f87693081f0f7570264ec1b3bd62ac8165cf3ababf69979b3b7e645b6973565b0c35396777135ac752797393819f9080b14d557d1449596e4afcba7394b08458fffb0379df07d790cce172d130c70d4350706c715e120254104b3d2cbd2555e653d5fbb58cae0fe80176e2d4749f89aa9ef4f3d13e36a662ff482a5c2abae6c171f8f3febbd497c126d3cda752da2f99c7ea34c7d3d872f9287446e6e43aebc8844cbd094b3246f08bd9318120bf9a97510d30729356106fa2930318c3835d7bd7b272ab80ec84725fd47c817547590c3cbaf732dde13c158db735406aa61632e384a3945225c42c1537d73225406670c350d423f11f4162d6da71e31a37643798bc68fcdab371b52ef771c24885a24fd3d534411eee09ee3373829847bdae8876326a7dff5425254228188ff1cf6d2f62b7ca851ed1b4edac002a11058a7bb02869ab28b77e587b152da81625d0f4e35563aed3ce2c54ccb72ff4c02b33e3667e5d25fe2d432db98241f66f47d879ffa1e7f3877c5afa0687af0dae469c967aa0aee0e574ba7f50a8f62da076fb358fbba0eea24e5e9b18e1ad8944e0db6b7c0e2f9ea676aecfe10678878eb7270e6fdbbbbac644fec1df99a33fcdde1490328040e278f3fcef4272af64d68429a24fd0e99ca50b555524ed2ed2de8264a6dcc9effb398f29393d0480acc16ddcd7da9caf9e25fad3be35b1486ea3926f1c8ba96afe07a6e1d5a7152da0fe5d067ce4105e878588d2acf548b55102c9be7aaf28db5c6b50594b79c2344ef73f33d0b05d648b1e1f6381a090b950bec11d1e8ff347319515d4f6b4fc0ff776f999a91402d6c2d46bb1bca51744d4d6c8ba27fe8e7bff99e61c87177bda0249e0925ff505cff68819dafdb1da2e47c2d44f85b5e3bd63af84757b3641bb1af0c92e16c56bfaf82235ff43719725d75e9aa398e77cdb14369438ce8b5e7a1641bffa7d0d640711b5cd690f926d668085024babf302be456cee2df462369bef3fb849498565906c39abb225cfcc6de4a42df0d00723482d47c6ae4d75001845f278f03f6bdfebc0c6766c0a5c559357523b966fd67b4ec14482d3c6624542adfc1bb8fe5ae45ac1a6788b49a128f042a110c3fe27c396158b7ec4fd8ff8f5fc6f8b93e2e58bd7f45329cc12c425e7147ca4e25b739fe4b93861f31cf0064bb5906d07f15894a51cdb1eafc8b5ff6cb2b26977f043d26e4b5ab74d1df262c1036807d0920c93808a167ba677832e1f28795ad3bd6f8d57edc25af339740f2b2beeca39c58425157f73e6515d2a0913352c48d4eb2cb063732383267e345fdd446fa729689f760d514da547b0646770513792b4d9c8ef3c85b395bb369ba7a6da265b2a37f6010786940067b14837f661f3e2d5a943f39e49161a73261e8de14c7d86b7c1ed5691f85481f58b0f8b4a7167ec7dc842bf1a1e58c31bcf286492463b8256e0745ff05af5a39de0347be96ff609602d35709f38a9cb53300045d5e68a28bd8cf9a970165a5e5b4fed5ab52ebac85d6a765abe1aa2bde84c42ff2bc4f4427fac32706f7db4bf08c54b71d5744eab4d823d265e800664855388cb10d745798cbfe9f5e4d8c002991ecf87fba13d2c30b440d058158e558ddd61e63c5464c8d0aa6710e0ae8469a814df9dbb67a2a326d4c6b03a00f1e965cff5f21e8a62bafb27224acb7cd364fcced5a76cfe1eb600d10742dae3be6ba2bc28fc3bfb1cee596082e991f927599b6ae0ed670996c5d740047a02690a2072316719684868bdebc230581607bc61ab6c9a171e7a53a5f202cfaaea78364a64d3155fc70704104a3e42dadf77b8ee3a303f2081ab6241e14a9a44e40fe08e868d1844cb259480029b563abc4e6d3163beaf098e44699e8b41b60b802ef140abc08573cd25dfe93f08d853b40a8e04e901ac2f7da6deb73ab5cd9cc9fa5b7abacdceba876b5df989418b7cf4252516c1a0d7464192778cb6cd47c4b9d635090ed7d0e3740740157b6aa270a170f07c6c6553ff76a2aeed165454de8d4a38b265a9950da528c412654406e75b8d510580928062ddf6c4d3956f24bf2065c97211f1f0ac206ebdd3efbe608aa5f1120347ed58e725e86f473df113a31cd8683ea5ec9ee9384c35e678e4577f6bccfdc347dc7c27a19094e72a6edf9105d71ab7b57fe9bed33cc9ca703c105ca3755005f9f86ca3f0c93b91c8147683eac58287c3803cdc6b55b65b9fa3456cee46d01f0dcccf9de7c958d4860a40663663d2c47738a0b4d4a473f00b0d8cb6b297dc190c465af4d83ebdebc7fd4bbdf903c6b2a181f4659edcc3751bd49366c2f47ef66670cd9cbc472750a21bde9e5633803b864495119dc072103d4e81aacf1af9578576586a597413a8c7e429f72ae9749354ef81060a7681916e8080de21a6b388cc203a47f8c87c89d697ce1bbde01701c78e2cb0a54b4bc15573c5d745e3a06240d9210788eb913544e9ab80802767160b935e2bb285bf05ffe0c917f76d9bc59fc4af0a8dfc470751bfdaf5f613aebf2faa34c91e4bd2fe70621eea8888f768ef2420f198d94930246ae3df599ee3d4352e8ba06126ee0bd9df8de66a1bc022679433fdb1ca398f027f1c65596f5a6fffdb222b3d43ee8bc68a9f6ee27dcbd440ae053c740adf8dff058d92cfa7a2a234bb60f4047cb7a923ffccb837fd0545cb843d5292c41d5d260b1cf269a3d6e29b3b8fc1d43077a62c80bfb9e57e752af9ff27ecd4049967ef69b4b8f42f204c01179d6c9dbb739be772858db9c6c7532e2f8635bdd2f363067c6aec4be8f768dae0b15f83e779b54ade636810c857bbb2cecf844920824cdaf345f0121be56c01f60ba30f45c4e2f95601321371edd4bef0c1130becc05b63b50d6f4938cdbf31e09728601ac2ad2da30f21b1bf4943f9822c7b6bfb43a5a589a8b8eed00a0befeb097eb699c38fe7edd21f1380ec5a54eac3f26fb45997b2d10184b525ed3d6e7eec72ea760dc78c144ca5a1f345137e4678430b6815c677da403ed658c405d992fd78c833164a221277519e2a4618465afc1bd5c0869e9567aa9b6dad486bc768ea5eb230762d846fa95f81015db688f76ffb49555bffe6706b442751a016d5cb08cdbbeadd15f66c12aa94a060157f0b2a93a31fdf06843b9ecdb595dde00022930a4b3769a5e3f30c70246b827aed59e7650e153bcce9a3aee7d762963f281a4c0baf0578c6bf22906dd20c9ea2f6045909c33698bc705d09139464984bcc309cd001c210c2ff0a8fa1de5b56ae773f214c2597a7149b465b37c470f0bf29ff53ede19be5fb469f5fbdc04598d017f3ae814736dc60cba7967c7d8ba36e5676e416e242c46d45fe36af76d80d1916b5e9be3c3f4b40f9f25de941bce1ed7fb09867b488639c14852980dd5a949ca9b80de29400495b266a3fbbc25493a1be3963ad8d1e9467493be7aa43e0a29f1a005d87753989eabc4db7abe218d212b55db1e11aff8897f97fa772532eaa9b0c904502a0e705485830f088ae2a6df73434f13c26e333dacc19640b82fe352a7a6d39509c573ff2ef695d1eb4a4ba559257212b6ffcbdb3768d3634ba0f66b650efd9406a11a8c2a036ac15ca25de8545e14a35f936c175d1be0b290e7bb1c6e09555d51811c6cf4ce92aec56d83214646eadf8028679f66c61462247180993d733e0437a59adf1df1a929d52ac7179234a371ec46c96f1df7f7fec8fdbd9e658c55d7ea79374815fcee257cc6dc615c592c520058a2d504a5517cffff2f5869cd5abe2b788e5292ad4d60197a3f7065a7556aef8e0e12448303730ba0f7c0deeda69d09ea80177099bd59eb5f74de02b996eb821a70aa6604c53489dbf50c45920c864171cd5a06daa6f77c18d27754bd15bb221d53bb8c28e3aa13072a2b84a486ec17c4a7f3b10d47b37a68d73435ed8e6db2c58db5f68a1d9d0087d553889b14837f05737e28f8069ac4ab4c84ae5d9cafc81977245b0e72e5a016a20c3f3c8f492577d932f5e53af78a261c7551fa60b9c4b6feaae0bb5812e08428f3fef34ca4992e5306fed2dc21e714fe4efc35c9c08b22b004ea03e15ac09a9b3998723941f51e43fc5d0494d4d6c1748683465e67dfe7e5ce1402e6c419b08b1a7fbce088472980f2679d0d439dd7eda984e7d38e772ba78a6e16bbe6d00bb9425f2c966a7d0745f9ec1bea63cb70e411962334b7b9656a17ae7b76d7562b6f95ef781f46bd3dfb107e2828fb4961578e8127fbf7bc212988d705705cab4d25c9655905d0dbcaf6dc127e933e6fe5c43bd20f9f6dcc53617545959102ca3ebd7a6e1a766df2ccb14c47f430c229fd1ef294d5d04574456fa0747db393580b4b35680f804277e0001d3e8dd56ce3a74eaf6e1a1a13f8df115c5fe20d68e13ac09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
