<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f56cb85baba03d887e3cf307abb1fa831210d8ae9313647a1a251219b302992368c5908968bd01033f915db0f89f67ee7936f4d355993662d59b7f687fcf43626f1439775227984920afbb40bdebf2ac82ab29f1031b2bfac1e3ccce20c7e3a68d333dec8f2978f42cababd9cc9cbcbbff6ffe6f7e713be6cfd8114cd146e779e039d0fa90b7c1f587dbbb69d399c88de90d366e073580f09429106238cf80bc0c61942701cbcc3fde12e375d833f92289aae21965a04a1bfad2dcbb4c0473e24fb4abdaea21e15307c39bb3fd1b7fc0f2c2c7645af4bbf0e7dca718fda11bf3ca483fff5d9d67ec4ebfa5b25ec59df312884c110b89d4a2d8061b8fba9381d5cd17c0d1bfc155481ea2a4938cce5252b75f08905073ac6ea938847ad4b26a24442f4861d7188f3a894e1e374582d6194775d36a442e9341f140599bb28f6e407bc8e49b58749ee84db0ff84b7c14aaef15e54899b32453eba546c4d92615e2f23c161331b3802411568cc6b9d9469dc72d51e9fcf7780cb88014e2644191384beb956e209a91eca5edf6746d2628b949cd0addfa49b8621cbd5dab56534d7af318ce92ed6ea52a49da2616bd189e38440c4ada38322b6fdc42f5d82f5578e18ae173a1ac98cde8c3a925872f6a83da7ed7ea7b5f79420db4a4e2fa5669c16e0ab67c673850f986bdad6c0297d0ccc6f100a0589a9ee44145c058714b758c9650f3884a3c4037f65e923a0ecdddcd458c2f33686e25e954229691d3bdb8afc8e6ef407d4279e6f950352ec2a4fcf9f95d47dc12ec82f0e49e5ecf409ed07d88862d6ddd9b8087310274fe2db1c07c684f78d09d706ffbdd9e7c5f3d5319c28249b16acb7df84fde4fbb797aa4b1f4e451b62d64fddb2f2e9930ad15f7eca3faf631712c1ea539b28dbdbe5998fb136fb3de66ce0e85c12bfd6d300077bf998950853346b439555c0075b625fe2168f25a47518ae30281f63597346c1f7ed44d12af7807e72d7aba7232cbe1ab6971a44a28ca01b37f88442682ac786581c80b0610c570ec7de4a209a07fa3d8318e184b590721247335a3b46e71a8142e91c00328739cb6e6c6f4794ce609d0595a272178a6770e8454bb3355957eef9343bb303dbfcba4ef58e77a3b7312f30d3d6bc0d3b41a9d0e9f91f47bf30bee94d2c4fc20acffc16078335e3406cb91e2e7172b5fec3f2970d653e1f7e4a6b374a6cc17f5cd0ba18f517afdb0fa11f4c0be85f55d4d26279a9cb81d60474b05180af848f5c28445a31a7f7706e1c152bb4f8b41c3491a2dcdb0b701368f2179986c60de7e650e83e4bf034cc0d57cc3b678a33c0e396caea2e8ab124a1c43590fe093a24474a8d3027d00fb2cf3e2d5b3dc65c170e846b0c6d12c6ad5b74b8631d6cbca4be5a81b357e86535e60e71fe2c732cf0f0ebc81d4f0a0f98288f5b6b1a332fc45a57d4d2dfef5ac638e1b0a0486321380708dc2dd98e801b596e7de549c14037fc7ceda4bf14105504a8d3d545b0be66711b68a560c8ce3459f06e42e0a01b5cf446cfd80d66a335c51fb50d9ef2d204aba99a703e090639437b8b8f44dfaa5414805ac420543f42d1a4fa67b2256ab7d33c9b457b5245e42d31169ce0c475e6d751431db1a448a6ca6e39526bc44e367648878c7b627c4fcca12fd6b7f062b2eda31cd3a6f82b27c6cb86b8c2db7a2a5ccf5d0537c4be4108e2a8860ba6f27a423a228ecb61b0874d941e8ae471d94e514df98f319c28e818fe304952200b7e9dc0e15a7497d8b02209bb98b9203af9b993a2e4d220fb06349aa73e41e41a88f9e2bfe1cba8c5c86830832008301179e27185e0c112fa42652b013277b5380c4a942ae5eacc694051ec37f12c0358d865e150fea673c9c3c9fce75b72cc111410cffba50637c1cf39549820426c68037a4c8494290a81feda2d3a5d86b8f485065efcbe8a17a8b3a50924bfea16ef1f437e3ec6070bf092c267119c1ac8bb50a45934d4db32f0b4f6630df84b2321193290f44404944756e15b6fcf3409be936206bd0e4eec0215c9eff09e0f4aa914817eba87c8511f587323ae29367fb92da27c7c83dd205cb83190dd62483f70dd4b58d9f6039341258d23a24a668e281f30934406da347e83d11766c8ea8c796145d54c55c950e2ec29f8456bc77a5e9fc13dc9510473a0e1df44ccdd2104908d8de2771ff4d2fb6f960d8ed5cb36f398a224f85465f4ff6270e0bb05dc9193cb977a80c47b4756f61c37ce424e24082164e51c32c9982dc5024240b1e3c68e602d13cd8f212bee336ed687d74e71a34a91aa13aa10110ccbe03460b82455bd751b4877465825a8f40117b86fba0fb5bba826a3e4e8584ccbe859e0f086063efdb81aaceb32c79a94b2d6b612b6f7ce1bd58e4a835221273bb39d7d78d7ee03f82cd4a2da88680d4284b059f1d8aff4284f006c07068513e336fbfd70bdefb9b2d9554d57a05aad497f7d2c007a9c1221ccc0a477ff8fc346861324712d89b49d9b1a1c1d70a88ee5515d9e62540bfe5ff5e86d6cf7d311ed82fdf3c82caeb19091f9da8b88991e103c0e0de093be38a490afb3e5b475748d945dd65e9f3a7a288b918117fe0498f7175fcf9d2cbace17b358209a30b2cd71b4e0b73208891bae9cb13cdf64ffad0e9f007415e06c2b2d1201e979b75054fd57fe9a981905c5bf7b4142d6488e59315184539fcb7990d95b7262eba692fe8fd1a315834c1b6948bb3fb033154563204586b668deaa90feccba7d078734d325ffbbfd8be67a1750a36cd22c29558f1fe008b50345bf6b3f68e595f09e4b6ec16179de8c49cb652021f63169668b7fb53a7c2ad268d3fff3ccb76b6773d05df3c6bbb40f0e904c8986e02d5f5a3ea6c8aff060a15c4d9603b73b254f4203ff01d2c2274cf163a87f4201fb6eb7972f582eda855bf921716d65ceadda0fd765ec207cdbb7e28770a2a628e484d7db18c26251e349466ea1f9381beaf153ce162a12c04b9f025b9e13c71e3bd4766d0145e44bd41ae51414289928f73d7e97f07bd6100fd9fc77d49521fbca125f1824043fc5ca1ec0fd24eb61524253eb5b136ceb9098060f16e73d31c1ff301336f36cc8024b6affed07fde3d83042ced0aa2169305cbf82456dc744a39097fafeca4c1eb42e2044d260f16f26a37c70e7c1e323846ef9760eb82440a2217a9fb17939c830d1d26fecf8a8c0b9b541cc6afe45afe3de6b1921aa3c988041b02d35fc445adde3549c02072a3065d669e00483157a9a8e2f4824afa61c722d673200009a14879692fc6099cf7c024125aa858b1ab3cad7a61ddf7e17b749d61b48188b30525b6bbc725c20ea1aabd94d069d1ae2599c4162636614576b401e808e8cd59420bf441d9680182471e8f4b8f729776e77aea42f675891f60e9233ddb1fcf3b085dca321d2b4feddb2d29f5eb50e9acb2e1c113be1359c904456436bc5acedd61912066234834f3c9e97af9848174d15f52a7be6a91f1aed8409f4cbc27279c3648623896d90a29c203d35d30a31ced063d9fb78983abebcd6f6fa56494c667ee00d54eb2ceab95df4d23fd2ab76970b34fd9841676662a779262fd7031e2e39d01890da0415d49e784eb87697d7ab0d56dbacd58c91165d96863184060791f8136dc5ab0fc9f4857a1da0b5e51356c60995d23e3198f42de5bb43a7bb6073128623cd1c9ccd04683d7378ee4dd5ec4dd836b91a748d81d2008d67d84bc4d4a46dc06982f65658047e0321c98e652ccb21d61f02d31d7b2030ac83f0d1bea375df250386e84ece317442e5b07a4d3f885f42c59c7cb0be1fb8d3da755f88ef17b968a42ec57780eeefda999aa99fbecdcee2d3727a02b0c5318a0a07c6dee7c7e2cc80d7d673079b72485e813e7bcbc936b5c7cdcc20b8787ffbdde4fa13013b2fe88a00a9f76b413a88b08f3d3ed03704d8f5c2799816d6483fb025682bf128e109dd3de5ebe00a205539aff81f77f3b67c76b1c250655db334feb614a0cbbbaa257165469d7100436c85aed89fc3aac3a36e193b27c660277bea3e46efe5e8aee4e7c5fdd952578d5398e2822ac533fbc0fc95ec0d0b41bf63f45d114933c5a0b8c2be168ab76a6ab82bed12ca2d7a30e53706a7382a5f0c5030d5df2f4bdf8e7702247f6f3c4bb2774231a903df29074e6c857b2782e4cced5b0728ca5e112af61e79a56fa0cfd8161537ea775c6eb04544a08bc3318bca374314ab894e26b64fa70a1e2db4163c1548a5489dfb290f0698249044d52491008d991b4a68a145a95b4603f38cab74275dcbae4262a3c26c452e94ecf4622a27bb9bc37b27e4abf0e221b34ffc2d4f12f8ec51c93ddbd7af35e683c3a3d53c02ea7f71e45e06afbfd080e4867a12b2717485e8f604591c4ad49af398e7bded4339ac4e208580d84cf34f705ab213e81c0b0f2fadd05a01e2b047e436cb7429f510df955a5425377496afcb236f48afd52cc47422c28c0cd8f78e1902097ef8e5873c503ae3f8143799a007844420484992992e550e6cf048001b36465d47c4dfd2d4538aa8e1f17e80633ddeaa2f9efc7cade9d52dfe40227855931c733c6f8d92b61f711aeb1c440372932a3be816997d609067c8d4802b94c69ef4aa45342efe1dd2614e1d402b3c8f6428f15c5c679806124520bdceaeed12805e154de890138f17c3a6f1f276d5a7d36413925844c28ad9a3b78df1059b462aea90520a8b2342ff0bb9b891f31ccdbcfc6f0e9a6e4450b2a189ba16486e0d31edbcb5b0c9747eb0f7051f1947781971b1dae2dc0b99e4d8de75cb4748885d99125f5eb486801c2110bf1bd45467ac264fcba1dd1cf79ad389eab18a3fe1ffc08692a85efa1d66a1aa99b722f02baf87ab5715b2ccc524900fd134b69a0dd9262244b75efce9e05f9ab545838fe40d39d79ff567589f5d0b81123180cfe339be69702dbca4ffe93e45ddf82b70841124cb01b9303165b7d29906eedf047ed28a67703333bc80a29b1cf5c0855e3472c7dcf12ee46abb1fc75abd332d1100dfcf052f6e99f5e5103300093213cefe20246fd21984e4e8827e971a9f8d1e79d10768f12edb0400d6b891728f1a2ee9181101f0f5c2a0e81c7a5553e661804537813204fcb8e7fa1292ef5c1939b937584752bc50b34d432deacfc31fe8a413d6de1aec80410c88f5b44b024514b641276107fc100fc78c0069a4514ef826d3a7750a034265ddb8eda4b55b6a95c3bfdd3efe5964afa50462ae3b761628580afc17948e17f9c6f826dcb9e00ebc23da13633fab5b178ebbeabb09f913a066d0b8cabe7da330efd92499d5ce5653acb15a06a0e908895ffc5a22efab5f9898d854292045cd2c9ff3c35ede55dccfe96dd94a6d3752aaedc05964bd536d4f94f2c01c89aa9fc89616d509ca985761452a6bd87ad7a705cb22b77b41c9e8a2ecc9f3734b74cbbb566a6ae9ff4d6dbc53cb0a6706bc97eff21c850a1779a22f5c459881e746fff990c9f67f9ebafb075ece7e18524aa07f32aafaa43c074bfc6a581f60a75921b60fc6ef96a00542fd1b219eaf6d4370187cfac9f95a1b6cf14a9933aa7b171d628a7554f18f56e34a19a3a688027cb73e670b0c763062689eb1bbe7085a352f6ff2c09df1ce8ab55354adee2bf404e722e3c391f28682205518e65aca12fd001995ebeca7b8b5d917e5a8a1303148a292f10cd8ea19e09de8499f432e2dd1dd6b802d04b37fdbe6a7a451f1e7d579a1c48f5d786d12e5002273b46796db4f491000e81138813b4dfa31c1f52cd47acf88b9bfc890ec93539999482d585754b61ab46937fd7425680d11e8d8bd2d5470b5d4ab06d71c8e06f99a9d2e8d70c47a0bf959377ad26e161396d316a6740bf930b9a44e8f7bddd646267c6ba5e9de6fde4b591edab3e48c0c8ebeee34210b2a70035b622a12e817a3d8b6d613bc30002db349c2a15bbdb0ffd6292cfa043d47f658e6dc3e7d7302c348d078c805747f1ebed0a60ad66fe654aff10e743e096d85092972418011c0c7a3a058b860cba4fc096ec5547e09fe5aae94ae744def572fc24da4fde8feec3f647b3ad026e84f60fc3e9af317b3203e9bfe131c30c53f2dd83a774034efcc365fdbfae8d59791101122c0ad69df43f727adb12ce36ed29ff594b674c448879bf209b25d4206436b64e8ddb17e7762479001032d7687269b8fb0f940cef3cff983e3bf466641ef934b2de93c7c22048c29328be33eff340f5ce6e63c2bfab796ada9350c2cf3ffd09cdb13dc6482c5a7e96b3f216030e143d163336b883be084228c6160a07f8ebf7c74f9452cf5bd58c232eb8d58bf18656a81e617e5de8ef08c425039d430d4f99bf546817621e5071767ce7d55d0ae6071e04845e4f70ac9d880b28af165a0a88f62cfe9a570d707ed1cabe7b049db827ecbdee87ffccb73206e5489518d5acd04efbfd4f48c0ea44e694ae9574221b4cbda0d46a6b3ab5ec8cdf3cbc5f635aa8f8b79392d5cd34cdc31b912491237d310dd940426cf9f9b142927c47bbb88de63d4ed4db6f3d446e25ae1c2fd6035ed1f853fb4f05a474ba7cf790f10b2e00c9fa3fbf3043f3f61b58752c2615cb3a676115562771af8cdbc4fb4d363be1e8f76c400ecc81d02b063115b48e41dc624d6141825a7782d08a00b6578498e58d8853fd94d149c338f397cc0384d06e6de4d18a6f93ba874dfeed64d539c024515fc69e9e771a5d75f60a711a4b2bad0cad4d57612274cf4aa029ac8e3a6a0da99812ae3878c733591dd0dfc24aa33638e2ada2db4ee7409515af8c0a866c71414ceeaf2d04c5a71a96dea408a6a23b1d45f51d0716356366c7be3160dba10c5fff9c1a724d884646d60bd9c4f0b06ceefaad0c65b054d8f325e67b11e7b313e9c30c88bb54f8ddaa3741145ecf7834e0b66bc82d3e08d69757c56d742882d4d363f3b5c7c1ee6d5b252eb62b599e9325469ab0f83757f9dabba29aba9256e23913f9855df8ae06df3eba1c93997927a3dc2ac883f40a41553d356c0196be55342bad999ad3dda3bc0c24dbe177e01afdb8a5ed3cc111c5c6c896b482ebcd34ca185b7339cfc659a3e6cb8438bd1d8002b18a0657cf71999b8f4ef74b7971eba93b2cd2be249524c0bfb4e0cdd3ce12136613ea1a2332a3430123555f8db70ae81eab46d016974f6ff8d6dec8b0033a955c3cea0aeebccc8d4451e5933b08cd1ff5ea494e831484c24cf7da47c707b3707f75f7d0579708e24020478ae6225991a8064ea2cccd6e896275c553ac98a0c9ef2e40506912dd1dd74858d69592ac34a7d3785d6c03f7d9810862e0bd45962bd811ef80a136e6699af27665347883a7959abb72668a8ff6d67784f6d5a620488ec793a9c6216216abf5ede586f78e7eb3b4b79dd5a854509ce871ba63ff0e2589e1753325dfab6ee65047983449137a4331931a3eb64fd9925e691cab98986ad6de1988bd62ee09abf928b763ffb1432751561342781c757ff1f1790f96e06d596ff5281fffdd8885a91c18384ed2be892fce3646b8377c7ac16939c3d9be54608be46142d92c0f911b95776423f12cfbca0ccde3b3bf16237748d6a3c721d1ecc77309f3ef3d8bc4108ec80d510fe7be93015830d1e6092cf20d2be29740a4644307887d999a224ab55232f5a3369a6c19a3785bb2a2a3f01567dd2012e56c0c601e36e7bde99a30f777d901c17d1342f04aad8feedd00af261d0f6effea27c9cb587c57387ea15e4d0a943be5876d24324e37d724c818f46cb3d8876dabcad54c831fb6656ca2e834b82d08dcb270230e6500941f7be3eec18ea8af77ae21260c4b728ca9f054ca00efc3c3b0cc5c2cdee20260741dc8c669e89b0ba60adf538ec14836c2008b10ad919fc52e545e6f2df0217d35a8bfc2cdc7c814d8ba3033b4b6e72c33e7fdf317b02533fff44df5073064fdf2c58a0293a2b0f631a14a7b7cbb57239f4033f26ea5d63c6e2e8c0e2efc41bec66731572c3cf2665d251acb64e7696017d5bf15eb8a6707d3d169e2212b924819c8eafe3fa5014cc512e675d079a7cb740e843033ff8de2d59221642b5102ddb42918891a4089aca0b4cf9db26d431a95e48141418505d55343b8b4231741ed11504260da946905694dae4dd685cd281cba4f98380ebbd2c9d1345392a65a0ddef352506cba8d595c693b8ab257099e11c45ffba3a2f66cf7dc1e42bc1f713956a26ef370bea65fe5452cf5b1645bc946e575c4a5e1782de020ed3327abb354f352981d77d2c914c43950b369a127c6ed077d690cdca1dc480af151aa20e7f4f8f8a6b5132f259f798fd2d7d919bdef6f66cc413346cfc1aeac0201d2ba23ff0969fabb70b6fb45b0c3eb80e3275abde400f15247a8d0250b48ff2f3fd21339d0c22f6998294e006fd18f8121393cb054c27e01078003c7a5f2f19cc3ad558e2f65d7382d737d4d17864cee8628ab1142ad0caedd6f88c33cba688e8a9b28e9e1927f5d53720f082cb664684bc6c979da00be8806dd20f10bb29ce5999e7218b05886aa4568d46d04c156b35c7a6b7946e5de466499e5e1572c2147fb30d730e1829a899fd20b319b18fa2e2f3e43505272262360f417e1a7f021d130f107596f0150674da41d40d559df3345a1ef89334d0787ef72e862edf8bb0de663c7319edc7dcf35ccd138737c45be358403ce37af8f9495a966a6683905e5ade242f28762bdd4b1f034fea7c99ed8524d6c3867e7c93895d489450a3823bccc9cb1590c20a8a87747520bcc1c3a8e9e5eeff287e89bd1b98bc3141aaeed3fe0525dae01eac8fde67f5ca9491660ec1df2641157f25c1b0992f9b2fa097bd8bebc22f8dc2d8dddb42850db169056d3436aa569620c25f04a99868fb18679d071b6af32323f1befb54491c2a4e9238e536316834eb45352a90d25d83d2c070c05898ec6bea107b31b706d543d44b1843c0201c4e6a0613a3c5c1a3459b6db6b8b6336a92b4a849f187466cda190b2c84b5a1bb02188ff372c76a508d52beaf68f14d96d086b35befeabc807d634e725ef955c44878571bd649ab990c88c8a9ed1a94eac82c92255f05c222adfc774df217ec9060d73a394131a782df183c4a7e435a1269cf5268d0412c9801a8050ca71c5e41705e2e4ae133bc2706d30244cf377b6c6f8a95b4672a0cd053728ba8b77fa53208790d03924d8006b772cc3bf66675d0d484ab7279a314b0088ad92126cb054e030ae648a744150c1ee398333fd58939d58a2fc02f829d62ed85843fe156e2722b72017fb2ca4490df7ec4037bbf229da0f5b0d2107e2e426d984e3b73cbe16e0341c228d1a4b038b04a1698cd192e0ac6fb08ce7ccd309cd67231b625c8dafd91b758315980c39fad7f9ae73a45df7f697dd54ca0b7e63b020f66997155fe8d69fccb6b92d31218684d53b2842a419269b97fa66dd47b1644bf5235f14d401293258529ba2f19f2ac50e3172202c40e855e199f157dc5c5051c223a6ab4015610c0284de19e9b633c4bed9d0da4b544d86bf84488259d5c6205544b15c7ff506de7f655d2c4706bc67894d87a3a718ade492f80d5f9e58a74d6bb45851314e95b6a59b3b278a29566b42e3a16580d670cc678617c9bd20dea18e2c75d164e5d26403a3fcf48b755c05458cc2a27b94a1dc565e39596554edb99fa97f28db1a1fdcdb3e517eca443ad8a5daeb1759fc128d32fba10207ed66929857286db0ac2462e4f8179d241cc81f2d4ea9bb6fcfeddb0be2bf1d45ba98e352e1d05c1e3f3696cba413e1ccf65da14379dcf01405fa289c53df5bb45df4ea945f076c4dff725f65fde870093b87ba3eaeeedd8e1e6c79a1ca9e7d9cc6df7c220916d6ed923dea8f0f7d9781d389c40587f3bcb8f031b9fdf3d934f8dc19df6ba40928eae38edd5923592a3847733c0bf42f8e4da673effc81a624d094d80657f97b740095a5ac31da85a39332c9fb9e57b92c5776ec8b595434ac04fecf718a47012606055246d5f5ac53ddde1fcd89da929d94368410560963bd3f4ced5b532297c885cff18f8faf50f56d45f0fc54affec60335ab975d31a9b52e575e363b430dc2471a97d9494bb5580a499853851c99ab1e28a4dd9ace42e4f9203df4f52e1c172cbcbae41f152d65b694d714a041b08aaf208f326219676af1ac18debbd0f78b70ea395079b3631c4258619010e698b1bcc90009e51be72fdb626b0fdbbf2f35436a86f89aff5eb4a8bb0dc3c259ed4a487a620bb792351b8d54821f2cead611758fc2973420ff5839720abcf7aa164abf813893a833b14496885c87602cd5a341e67db290b306844015c4f4457a75544a682409730aa90fc2ee9f723dcbae6955d9c007240e4351a3016c54a17dbe65ee54fb83663534e4db49835fda41ed93bdf8ccdec8fa2cf04aefb7e9ec2233e3fceecc426043de8596a8eff11947d1fc676083c907f36b41330753ed406c460e87d41248659b3517042d0054a1a32b0359536f7109c174d35a8d1b0b998a17cc9a2ddc3140bb4f590028c75d5f52ca74940a845f51145194ac59c03d972d60e52050f167ceb5bc15272b6bf6b2341a9290fa4e00a5cae4ce49c9bf7a94faacf31bbdd37e6ed50c3f8641a36ad0f4c5b404c55d5721396edc8ebbef06c57db5472432f44df93dde60546e0b369b6a38dd9d35f918996957f0b7d5f0720e5614eddb7bd810414fd98d1e7bfc5f402a0b3b00c97de2daba4a5ebd306b053aad48d6f6428c4ad7c21e9f0fc3d36d0c552eec4f02920ca7b0adc93095bf90078030321aef0db84030fda7d4b99bc4e92d76e4a2acb1f378f74cfffe5726e38efe1eef4b4ab76bd777366d8911e80b9dedab698531c77f207a8c8747dbb993a432dd4b8a7f42e2a8c91aec2aedae92d39ad43829fbf9f353bfc37fa3cb9f12fbd16ea6d4838793e95c3a3cee7eea655ad226c3368a9e68210b17760a530c5710bccf75b48d2b2e416d96b58a745c9b1e17c4f5a4129ee5326124ee5c41c7245891681b48d6d48a13ee0a67d5d3fef574181d4077b94c92c57ccc526fa5fd9e4a4d23c3b53db479fdef6c1f7400849217dd06eadd3b0789a52d32823849735e79117f3d2c50d4fe7b9e60c9aad878838852b23cacd3602028fad4292a044b23bba113a8d9168de1dd2ef0e63815a2dcb80ea3d853ace6435070e525b6583ac5b8531be8a617f3ca2db25e3f749ac18e8f050a35005fde2d214abe0b5dc88d7ef5fb80f9aa71046d64af66a31ff0b2576a7c9208afa9d1dec397405a451399ff5a6d5b7daed358a32debbff4a2c6e8d500b3e6601729553249514e12025bc0064971aa80a9106b82761ca0a7f08835cc3116e54388eb642e9eea0fd81dfc174a8fd5abbb319568a1de35e83ae7417fbab84f2e61ede02381e50a9ff0b7b4fcae0e082c6202df6d11e776249774236018c0be1c012f8f60c4f143dcc89edd82a9cf9b4da48e0c692975ee7572d23b27b578c33c47658f6f0be4df7ea7348808a1914fbc565feb74f9292fed82e1c520ede709bf759249addc600a66fffa3a5b9c98cf567a5ea800ff5ba05075f928b73a37f7ca4cf537be0d7b5f00adaef659a91c97c8791dac531d0e122c00bc299963dfbc082cb94c626d2d71b4ba2a7c747ddf19d7f3c8d32ebfd3172a1f68721bd8d730aec420c8eda0b97997117d27c2920cf8ea3de58fd568f017c845507fa4c48e113e24ea6736cfcedab27b005d34898f4a6179db7e14d5ffb3329c59a7b2ecaf135e9841fce289138714330e1b0b6da168c6dc783aeda24a0435e8694f7580b6300449742c1e4e66020534f191aee1be02a6acb7b9648f7313e4927ec7fac3920a1078c6ba7e8c6001dfa5bac6003d3deda7862949dd76e1a801de447a9638745c074cfa6df3b5429766b881403198be18494ac5c8b89f14088bba3b18037f8dd0ff82f95ce4543a1bc69f1d903ead11fafc6e07072c8e55960312be0d8aba0340c6e4a8a4a1fba47546f04ba448b496e0115053a13355657c102991d4b9cc7a00b974bef46cafa0184807c02bf469236f564f4e807e1699f5b45a7438f748aa1f0cfb7f87a96bb587b4980ed03104fb438daa15f47262375c4e8d7f7180f243e93782d2217aea5221534f9e44e4ec188103ae78369e5dd1fa344990a50d5301af81c3c6964e910761181db3eb30ffd42b2c9e4d2fd3ea91dfcef3dc32285d8188838b34ecb4b9703643752d2ea70694697d22ec61d83f437687f55c9b7dd9fed478823985dfe6aaee30d7659414df651f4b6f0c0749e6d59792bd16a45b6f9730b6ff9d5022e847330c39fb54be4c8ef598055164f965f5712d1286e7386e4d1ac682486d7a3e9db5fe162550e29e898e67d3b76d1974ed9cca8cc0ab37be7a4379a2c954d567ce5e3bb0f5fb97eb921d7957b57d6e9e320e7e339238fe56fdf553cc662ebe6fff0f1a9b38352b63f5dfbca6e1831821ed1576b72938c7b099cf87d64c4b6ecd78b9920869eed89f194e39e12183b5e56ec317f555ebb5aa97970ab8d488660507d5e4ede6b5d7484a1cef17f2b503ab34f4246fff1359271f758dd6122c8462154925f34144b0457a23896b4336ff682db66ef87d0b1b68a86d434a20d663e58d4e8d3a693aea9d9bb155bc7f6376284116240796c0e9ecc1e55a985849df04dcd2b0aaf0e6883481fc8f47a887b1846cdbbc8cc4eea03d532c4438ec916f9cac17a453ef69dd2de875e31f7c11feee36864ee047c05f4fd187e24a3bfd11fb43494c7702abad01308edf7f56f082870ccabb40e6bfc7f6b4a6452dbf8e83a4dc5794e6b14f9f793330d94f8a444969aac2e48ab571a2b07ac9074cc968f7dfc30ff2f06b861751dc3b032827ce634057b64c78760e6b1f432d5b6cabe34a752c0d6ee77f941c06e3f85695280de0263f832f6133ddad70fcc0fe7f48b90697d0da9f2f234f03bb1685e63476b8e8be943319259f05367c41692c9ca652c6e00d86959397fcce3e449850f4f538e2f2869aa6c4505445203d6c4578ec8c20cae167250aeaff6f8909b7ed23bd4750f6d073dd432236e9201d1a027ad90f998fa1e1c941df6134d3de0db610554999642db10bade34d3b6e78d32870505ed9453d5e3345319f32df4e94b7bf138d3d3c33bb004c697dbea07206a117e4f4554895897f789165de75032c198182604da4db157a2e173c4d35588f802f2d10707d76b2004f652858098c6b58135e348eebe5852013ca33d3ecbbb62bd690ce8eb1b145f24049a1504958874f6ff07f630ba4fa6fdabdde21a6d6c5eebb69108d48d83d9d9aa01d96ff3da419ca9c317e8cc80363270ceb9135c0c91ec8d9d57ae41c8a0097a78b2c77369d92ae3b66f45d4a2ead4e910f21cbdd07a5790ac291180fd8e48f857789ef520c5f68aab7b685f83e9042720097a95bc1855dc290368127c08a91e1a830b85fef6fe5485d0e2fe37e43136d22ab227048c8a2a7b50a32785939a283134fcd5700d065948de715a76129cd38eaeab5d51d833ab2cc667321d755fd04f93868234d16be965f3865a33d0c0a7334e52ae13388c4f6ec8456321eb35f0806f455b7e840ff3992f1fae3824494e7cb03d31fe199f28f4ca7e08c5c777a9a9758a86d66b040ec05cce7556dc9a7bc36282ca0b584efc35e6bd39784446c6ce412279bf3feb554d6dfad2b534a1112beadee16a34b1e042f15179d6e220b10cd08ad080a035b8c4b299c1fa24fc9a818b37aa5a051e599b6eeed6434149f2df67a25abaffff6f46ca7bc7b14e81867d9b21f9e068849dcdc127755229df1d529a2004be561d0b6ffdb619c202651dbc75ac5b7d2ff78e41e4163fd65296c0e086a602996ff156eb8127aa9338c12ada444636129004b7d4a391cc4c47d7df5a35e9e31cfc391c7e9503d31d1c47f6fe696e377bf43593e457fe90bc8eb6da9f1ab6bc4cf7783c9e96813f043e99a7c9ed4d847f269f49963952f01053644be530a53954f4d11db24e943708b6c5609d4b127a52645a0bff40becbeaf432a52f84b462252fd0c47a2e6c098280d1a8d43d6ee5e95ae78593904213439c8aff29fc1040e81eb62a4e90418224814cb15821798f44eb8db0e9d92656574432c277120c1edd53e89bd0304275ea4c49a01efd9014df8110a07c7fcf6ea177c9f42d80268668ee59cf92cf896b322bfef171f7393fc8f5a560ee2da7e6f4663c4950b18dfc584390b24c9b437cb446fd372ff6b904f604fd7e25d0cd1466592e582e125126e2a5e294cb16f40413e88163dfa50451ac01d8dad3c7c3de4121212a988ad5a6fb367f80a3bc751c9ada74c4881daf1d44ae499a802c2fd1431ea63a16fb4cd3999fe5f737be1e822cf6e0eefd53053b12ebad628ac082466d8dac8968c7156b69763078e2a78f174c3f6a2078afb5c0d747cd8aa1bd0b52b1e4c6c9404b5a1c70768c877211ea03bb146273fcb966a8a8e07f0bec0324207deca95cf8694bfb76c8a8251ea326b0ab2d9f427db87a4d3efb91e8445959075d3963aede3e1458c7fc420f9ab960b78e5cc727eb51f73486c047ec4e94b81c88004dc0f0ff2592b6e89b9f07f4dada18584b7c568e51efa136889a139a6511e19cfb56dd1ba86f5d5709fabe4494b92793cc5f73d4887fe2bceac26e81e9bc5c092fe26093554a4d35238151e0523270ef334d0e5a8db9cb06886be2ef8e5fefe0f82f1bf6e7d88eb8ad9bc5e975b81866c61a7202b4762a6d5bfc68eaabbd9ef955c31424efb3862684148825faedf9c10a38f5ff06cd5da3c29513087f7c5135826f4e28f6d742187709a69afc2b2708acbe52edfc2f3b52287c2598715c0fd48b657431a2e5d44e755ee3bcb19281f7f717b9ddbd5ea429d2a2bc32c0ac951707d4461e5ded6ffd97272aae003972434585ea8caff2c1445e45ee7580afc102614e66b3d9b30c523e9837a640428c23cf9290be50b27fb157946ddfb32110032030a985bda7010bce750e487675fb28dc56596e0e8943e138a24d88859f9b3680d9f07fdff9eb0f420809696e2d9659701d245637625b80a8d2d9f6a6715da571b395f35f194e1b7c7513bdd41f597753e8c443caac5cf8c280759136549fc4087cd13e3d37cf7ee6108ce0e0f79e9b9e329d1a2167e1bc29c1f87a6cbed6a8ba48b360f424d35a18c459dc40769e13331f0a3874da21c1c1337447142d70567fe526f4be6a34ca8a548039aec7ba3d1d59acfada5222aa45db8f00932fd5c1653cf45200279bd2dd3f1da76e65ecfccb254f1a177f953ec78310bba15a0f7656f3a6c40806d6b24547c985f5a55ebcf79635ead05416b61f0eb6de0851050a2fc3a79490e68bf19e79063d8827c46cde6f3758c67dcd1266492f18d8da1ee3ea589e30251292f0dd2767f6c5eba43963c2109312d4b9ae3e72cedf9376319a8e1da6945006d109edd7610b3ae710e60a595697fe4f0f7b88ce86ff0d821bef1e2f6f184c9ba2aedeb581989355582feb50aec2282ae71cb55d9ce35b4b0732ab7c8bbda1a858841b74192b7ef701c424c77743db51157a477b5e0ba11506df25407d1926f848eed64e606849e38dbfb60d4deb19af2828045c397f835be94cd98a7eb6b42e96376413cf11cf6ce77bb7cd64bb344606a29b6e63decf369862a1265a34a51e76242f482e57ed9a29b96281d9baebcd0b3afcebd9e7e39d0f250879d0d569893e6caf6cda369fc453cd3ace711993731f804c2698a9a58b3dbfb780227da4e51cdaf8325f5ce9fb6a0c51cff061b9b50104f959caa489ccf8226187151fc34378374d973bf693cdf214335b4d0a170fd4d7209e32cb71ad1d4221b2ec650adeaa7e4f230400166d423c4df36a77584a8c8fe5a00abb0648282f7895756ace5c546901f77430684b955409fe42af6d30f6898f49665469be4be3d59ceeb5b18d6c69526cf9f485b24e232a693918575e35946a4bbb578ef5490b41269205cb14d278def3f6892dddbbaa868bf2e0a2f03b4c4fefcb0155ff9d094c0e22423719b3a0bcecc5bd0b85516be2fde14da000782d39ce7bd9cc2fb29ea59d3cb4d99f8c2bb907fc253df3882d53a4b07c21f2ccc34be72ae2a18814899a5002431457a3ec095c81d7441a83080a5e75d2678b10d189fc384f61987ae0150cac8900f69d3d15dc75222ba4abfbac22997a36e0f53697646bcbea292072f0cedc85d258444232f3d65d2efc357898a2f140090f520301aa6d925b23e63f2c5b1d5a8d24ed8ff52dab7da56f6b5aac8c73310d524bde61ee3ecb1da59534ad1727da41990d0f5a0f4348a2489881b8bb9d448f48f18af4e571719663bacd06b9860c9c0ab72f2616591a0215c1bb62d885e95eca71220aa38f38adec9568033ca461605ad032cbffa28039fdc5ea558a98e794619259a7be93ae4e712442f33df97d75902d8f7fa2669cda680e5d808d817737697163d294b27f858e21a7fecb64e967417e7dcb965537c7b9eea2831a8f45a7ea7259a15922e9c9c8473c2a2699ec64e0a21a694347755d83cf7603e4715f73002f638bb61617bdfa17e70a5235ead8197e1f2cb239d3fbeafc4dd0306a265c183e31923cafb1734b59144286d80f564b0a9fd2ca8a0dd2869b99dae1ce8b7a5b2004a2d3e6ed1f6aa95f0587c0f192d15b03c237f18647e3596496899ca478b099e9e86dd379bbe6177f68c99347ba24c960b878c3642460a1dc9afe2400d6f0b241ce7ea4a6bbbdf3b7d577d30a6570f070741b3e9cbf254b619fedd3a9d66ae8d72256ebcf95fcf5b96f7b418076469f6f3ff245e751831b9f238541f900fa6bc4abe6103ce7973ac0581509b704f123399c2cef20b463a814e3b9463ba31245380b68bfa7eb92c37a12eae2da1c04150d8c39f61ca7d8b12ef722cbcdedcd086fb8dbf579d2ae19bd03a55aa0aab62726f9a474d729d5584f04255506bb6aab7e7e88a1ec3507d19ff25c82a4031602528d6ff862950ae160a768532de0de5db221da6cdeb64a02336be35780f398c28a9c85a8552ae9c2d9da2ae34c50abf16ec7b393af8bc7ee523186a1e59647c8c8f16ee1d338abea27658fc2796fdce415bad53a808ae845885f4e4ab8714056879c6be773ef937ca57aa24e944ea58c01e18795126bccbeb08791dc074376711299133b349a560d298941462340984fdf4c8222b5e0e0f007844dff5359cdc9cc3cacc2a74bb3211f1b9a0bd265f792d492b170c4fd0c894de9a893a1893a136bcf047a840eeaf57859b6b13c7ba4892fc438eb6501967465c697c555eaea6e6f7e7fa1d5e1f575d837fffdf5f52a033ad1607d72f295977b8e7f9a1cff0448a731ed89029352a1a5be793ad6a9c228203021410d78c363812009a396098e9a5673638513f5e6fe50323ae7f9e34abbfb20ce2c197a91ecb502665b972d20daddb8eef12a0caf67ff820b52cb5c54749b75a266b983d23d991f7be852fc593182fa37bb8bc943a1c6900351aa67ecfcec65daade06be3342fd9a79b2f35131d329fb769e38ae88256053911fa1b07a3d9caef1e6afc402eb9ac76820bf69fcb7e850a4bd2ff44baaad82cf01187682812b6b0b19acbea65e0b9a972e282c49cb6f1823a6c24a5b7e44e043032b2a9702ccc537f9236bb299f952a0370274755cee09a050836f20889c11c4e379995f6fd73ea6aa671e34684ded5933c6c0b4129ff0e81676345dd8fa85e2dbed84bd2a2f654db79ac12a5af41e7c62b3e12bc636a7ed5092a607a127de08f53ea1c130d86ad612063a129935b761ac38cfa27950a15a407c80d072639b0e72294b9d46e5f7a47a695370f1c3320dd00d5d6b7e153f9dbe3a5f1ef5fd50cd0aad60df604b2a48fcb6f7fa8beb57bbdeaf7a691f59c09962fb536084b9755f7a320d8aaf14a9e415d296a7696b9ae0be48dc53c1e3e10ac793a1ae0d91ecee1f26dbe02ea1f3ed035ec48bd8e2120a39d2daaa4ae2a514e49acf7d46eb2521024a99","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
