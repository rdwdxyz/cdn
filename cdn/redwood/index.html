<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9497baec6de341697b18bf163d5193942a2e0145201f6dc2c7af8e144de88dc09e0ed0736b5f744b1cb9e27d1cfb4d1d9f0e3e3da4f9012d322af6a7711013e72445c46c7576e4f0fc98983e591cceb1e7a45487e2b24e694d4d2443dd6997d95cf89144b3256f3f9988430df444d06e1f64532e9a424eb13878b1364005c1f60ec99d7dc311d3dfc57d50d0d97d7a127e7fc71e46e89563b15c0fb55ce3ef6e81312c4ba6abc1c698f06b883d401dca53902f2ab2644ab4c71f2b857ce9ffda81fe359b88401fae056e78866728ea11ecff82286289fa894f19e50a24a9e7f453f8077403be60a3343e2b1d9159aaf1dd8659a1b19850b7f1ae20b465bba4c8d0e4b946471cb33be3b99511c7968a4e9d1624e2e16abcc22fe55291d3dfed6fbaff82557732a17ba383c18bd6f0bc1db499e9c4959f8e974fcb64eb52df4493193e8d2f676c0a68568e5bca78700f69dd92e2388dba2945c640121821327d08b1e73a62a053537ef3da400c89dc24600dfd480e9cb485c446549691d7f0e75628d69181a90b01987eeea9c375f9b859a7c91ef0d4025f8ec9a02cebd3facb1a7020805bace064f3dc0cd9270937a2788f0ad77d0012cf03ab511e59385792f2a3bd1b90e6e16878e7a885f451f440c23622efba2492d9c3ba74091c529d06cbc7c4f1f0156dd209bef2ff2ee6a6d5fb107d89f2064a9c02526ecd21f93959d09391a4f1acb4003fcdc79282d64be750bac10afa7817e56d94273258e4969f55d1e36f4aa5b574780df1020a894be99f432f8e300ee35a6e5bb4ea091ba4552feb523531d0aefbb6eb76bae670e13a747f842c62614f32d60542ee5fd0eebf2c7b58d7ba999a2a7ebcd8b66633f66bec2b94e06de02d56a18da852d6aafec4e6bb1b5fb12c4007910ad315ac8428fa7f9fa115f95f10795de5fd71520639d00ca37bb094c775809668def75a63978e565741319f786932c7ce53fe4115b7af8180bc5f8e99fcdf0f48658acfe9c81dac4fa7aec37d06623dd0e802ed4bbde5cc7f76f566a481c07a06b77139441fd91f7089f642d19de9470723e8dc7d64bb407a5ed6fec8393c6ed688ef29a48fd179d395e7472fc85ee22af9610695abbbfcecfe064f428ab4584e2c97ddce184930f56694ad61d2dc1ebf8d3c6dddf383cab404993df988699fccbb4e4400ca6775c1beb42af8930955a59d1b82befb0f16e71a5157daccb0997d15228f53a83feec3bd28553b1627bcfc6292ce81c31047aad81df90f7682285c1535b3b5b170e9a95b6d40c96350e34c3cbaba07c7cb24cda7a7eb6fa34358c6c8f3ecbfd47c45bc9794084e2121e2ee0ed46e0fe4acd65d1dd317baebb4aa2400e6e9ddfd3c791d72665acd34f6a178b29edb841f173d5c8504306d449d1cb5de690cf10e56638873078385f2b1bf7319adae51ea109a47d93b5911797aee04ba93f3b00645fcfc86539c24569ed29e4cd300a3c3aeaa2c8676c7ba6ec9f0d56f61a3f7b68782ebc0225919d6e0f3e62424cc84a7f27e0238eafd6d4a6882a5aaf25260c7979bc140c5c0474ceb7f6fb4d38d5ae55efc3ef382e212ef0f80aff273ae236048233d113540238ba5c5a49aedfae3aea5d373bf774e03deba123a1fa70bcb6e5a6d811ae4da61cb72c2e9c5bf68402cee6244c017cffdb366e561cfd3848945f63673e88c3d7f294bf9eb488398005b74ebedd35196a68d586561bbcd9edd756f9b5cf23f34c58615ce965d2b7ac175aad93effe2fdaf11a957b25a7d817536a107a805204e55cf78c8bce86b5a5c12f544879c24bfa246fac3301a698b3f0566a4be772dc669fc322a399f333174c778d14aca35276a453c0752878e9c0403108ae3bd4b83e11512dd484a895c54b1b181782f5b326bc7af77174a7a07be209bfdcb2f06bea480eb78b88d8e926007927c999489374d2a6af6e89fb7d07f55277c1fe7420473988efc7fbc741e60db82ef57bbfb8ee043cf225ceadd482f2627e679441c727c79a6531b469a75177e67bf83e317b94415e98151a336207425fa391678a908a459d1dd4350603cae7b281a49c6c6d3a0620ca63b23b59845a94552478a7f982aa34486722a95c2467b7510cfff716dffb826f94e7284cc0f22e4ceef12a8ce165f1061cb3e2ece7b210dda2f59a8661d9e6b89b717a2de369e8fab3c7fe8c76ab2ce142384c77486e20739d8ec9cf80bcbf886558d43e1f20c730a09d5878b4e1283ee1c27b2c0114830facc3dcb2693ee6a95f86eceb5333619a6125d35a2e04d3ac64d9678157dfb1fd07d81bb9a3bf91c06c8ef4b8db97d13a98dae74de414091602724af60c5125ee3b17170374835fc0fc42d596510dad9882dcbf420e2b5207f07140566d4f8961ef917305e7580b10b64fb4784240a45dac011a1f705dfebe310d77e9624264987371e9c29ffb49b744d4dc383926dcaa9020a3128027dd04968d9e558de9deae242470581c32c0113688f494c6b59442a72b6ae3ae08de305e73671187c52d1e304de2c729236d1b4f9327d52971929a7ad95c2a0d57b0e7bc5007285cbe938303b36d0ea1de115fc8bed004c2eb985a41186f883c0928ea45910bc66038de1cbc1f6d81818fafe7f7ac6c8920392363178ad5051f0ab80ff039c7246b7cf289dc2e2ca9f37705cda5c06eddee207dc1ee76c3adc26d88d933dfd617c3a0fbf89fdfc3b5c7845642eeefab18104a0547f413f270b9695080547bda56e81ec23bfaba7136be5992c1ad506ac284891b9d1e2bd9502afaef5f79e37846def2bce008baa87a1776a66bcbbe7b8f1b0cb364d3e7dd3353e018ae03688a5fda942743ffb9b9bcd2602aea3c3454c8de47c62f1d90c482df3c51af04528c465584d0510b4fd86a1652e104f8f405ae16b595c82496bb8fe4ae0efe4852e91a6dd41cc220c203475f9b7d5b6b26af297604c936ce5a3ccf08de83785062d8a6bcc6fdd94a10bf3eeeba78820acae641acef871cda12c8249953da66816b77f8de03e0e6384bfbfc099d0b261c75f0433f3dbae1ba692d4e6127968c4775511bd771e7b69f0de1ffe9fcc3d83ee6a80f9e1ee7dd8577935586f19cf578272bdaea72a6b82cd389a0daefbb46a3aed36dd9de33befb605ee58ca7489d243596f9be33edcd81dcf09d41deefdffdf250abf9dbd55c27ac7c3710842832d44e66677291c6676d4101050e4fffcf5f58cf8ef8857c66167fc2cb23d91a955ea86bfd7774e7490a8a1e9cf89a220654bfc6c95893e1d92804e6ba071fe37635a4b9a3302f1df685f3d82423596b7ddec273f75d7394c5c7097c4dae7c392fbd5167ad159426acbd445d8945602a038d81bc57d179f5b92b351754e0c20441a6ee038df52083e2c89d020491756078981028cce38576fd19443322755ca29dbbe586c603e8b84b5de9bb5ae97caf7e626332cd1c63de81b20f7483e4ef48d32963747fb3a8bb72abe5c8526b44f06d88830efbdefb10b6d2e847d41091c794b91eccf33adbc0fdc5506f939ee3b2ba38d733a0af9f9feda4bc105364e8ac2f4c1f598fc532166069dfb3bc3346c3a847d78b1ac124de29317a7b255ad71be0715ccb445f51873ca4167aeacdab9a66eec29e50a19f448cf49d9008c3ad91d7db322eab68fd7ba591f61fef4230d9dee6d8f701f75445ab3275b07d27a881a59e8ef235d838b0053203e70050640205fb880c9dbbb041411214cb45ee4e6b04fb5cd0ae057f726213ff3af7dcb9085415487a3ebefce0d1aa8d4472ff4a5a4776a7182e569e5e304b1600ea8c647825313e66e54d293aeb5a0354fc6cb5cc6ea4b06feceb765276b3f40778c2aa22a2c1a1066c504dd0a4146f7f3482c6819231e35210a3581c9f122d882561a8132a29ab9bcc0a5064fcf233cceab610e4e6921bfbacbaee20878dcc7b806cc93ff6cf445b54e1255d49d440fad0b2f71d3145b6e81f022bdc76f8d4d29de22df7907b0ddb4d7cd4177bebb76b2007735bbf035b0008c67c319c86461f980ba2c55e686919d03a64f4e0d5aa99723425021031135b957b98fa5144b9910d5c8fcc96feea547c3baa32e67527514fabfa883e093aafe244b800d713b76b20a66133d0a1ae49c5f42b92b25b1217cba08d52375fa91047f9ead03cdc752b757bcd43847eee5aa581abd28a9cd6a6e48729571ff18423eead585fd684702a9fa5b790acb353451dc879feeda0a23e2a1f2afcd764d99b90e607c969ba150cb4fae6f3a98e6ac1234cd5c4ee645e666f886cedde0ddd190068093b4823d8c0800a0cad9b31ef2b22556277a37207c66a7b41560c3cd33694e489c813008fec0f4731b490fa8a04fd09f5dc686b395272d11bc63222fea95a445509840a86d371b3fdbf77bf2ed6998f1eba0aaa2f8bb5be512e1b8c4777cbc746d739404c61df77a56a761bc39ede9891dfd0165914f3c9edc71cf959356fefafce3628fa133c137a059035b06869f7e771b663bc1979e29c79216dac9c335f869fa2f8f175bed14871502bfe2a0929ef8f77d8912283b61d74b6fe018c84cd618e8b3ab959f71022cc0ea243f980761a1454b0979a677499c10b241ca7c5279defb21fa96562052f15565905110bc683b24b188ede13d0ab0504bd7aaf180fd993d592a7664726084f5aca4f7624a697f67d94cdc509f40e54d7edf08214e18d7ee5d68989d28bc24ab1a170e2de562ec55452826ade6c670eec179df2351366c962107c6d0edba5c34d92b2bf77b8dc00585392bea582c1e13558154a419a1e014be96982851b6a3551a6a243c1923743d751f5451be37c783895f081ef18666bb6af54f8480e188b737019fefabb3fa1f4c83b78e687a29d6e4be82d03b7db5ca55519ba0bd106d0b95e500037092ea4e5d36a2d0bdc85598564a4944eb975746a96f7608ed92f0ad5cdbcbe5eacf5e219ce81646b3de4274d2a112fe7f255f1b8b3fe2449e4e0166c80f9e576682490389f2080ca14c77d69860b4ce810fe0a547e663fabb670d4011c2c52f4df4f8f707babbaf5bb9fd4ba394d041583634fbcb18753d8fe333bfe5af62fba0278b96d5ef2a841570f2d0f543c7af578132ab0c9ffaa0ba5bdebcf37200ce1b8dd44580193822abca12c99527c6124529628479b55641ea2817ba345b1cae760b97f39e28404107b210ec939cee4e8586eb341558497ae60f321a04ccc3c0bd52e1d63853a38287c33e11c68cb9f2413c36fbebdf89174e7cce9cf05677e38a25b521f69876495798c9985d7301bec1133a8834d83a254aa9e1294ca83e958ca27f6c50fd829676662a7d9aa1e2eeb92dc2043cbd4d52e9e919edf4b3cd287595b2d14c038d6086b881526c2e20e8cfaa2b4b2f3fec0ae7885e9e047807069543011caacecffb8d24bbcc44f5f495a20955a7b398ce044a59ae565b906bb3e1b1deae27bf91027ac49b02f91429f5411bc2cc5327b6feeeb07e3d32c6e412f42e3ceeee7d89dbd4e4efe7a97d0aa45f8c3b20a2b5dfb0ce9c337291cc4079b0fe607448e16870b733e9ba3ba47f750d86c6d0bc0e323621ae0ba152b7562cc4f95e808c152a18574901fc5aeae52590b4a1bfc306097053c59726a4e2c988555e95aa7cfb3b45301061b98f8f8cc04abf462bfb485035ded2608772686f8f970690654466dc57720ff7901b8e538e8a23f0df540e9988404609f9fa12059e51e625d7ce9aca5321c2c35b8221848f84b815d4429bbdb605765c23b63ea839ff1253753ecbbb162465e7119ff9e840a99535a2fd6f325e47f594bddde28a9a9ec086f27ec5cddcb5d2b279b5fd7b8a650b2e46ed8d50b590dcfa122a23fecc12ae581a780a98f800d4fb96787e3c95cd0e2607d4e95c5ce2e501947e5de33d798b8dbd010bdaf2d877d797738f0d51414207fdf3df625c4fa873d4641dfe2bf9e665c54b660ece3d9bcd44a55a75936eafb4c22a019bde46a910fb903590cbc16c25f9f164c98ea820f9479059a19766da7b9f3e79d375bbf724996cacb875f988b9bf658661cbf25e395929d6da91376951c05549ae6eab54ee51080f0c8944121c7a8aba3b6aeebae51516dac9015b58f0bc173cb803492d226162bff25a00dcfdc8460a976fe1f210e0acdb9bb07ffc1462555b74056d9339b208db0987d812f1518dc01dd5dde9f3e172d680063da67cfe4e830219894a5e87facb120ce0120eb7dc750a34d612e7047e99fcc544c0a908c4bcdc2fdf3e02c2e3898f55145b1e0ca9b613538f36d16f29ce5ad1ba3167721d8122b17c472ccb6e24f21c42d5d6bd51d268517c20d83be8d611f66db59bc39b88209552160c0ef16bd244e32336ec25f66f2417f1c32aca32e6b0e6c35327b7d81e622238dc208773e9028c56726fd41210cca23a410406789b1d2cf676a89e6a7361ebf955af50f35d87553af00d889dc683362caaae54fb774b378d6d54b263f7c46f87729678c0c8fb680d73bcf134698f6ba51294b21c90ec06daa6d1a52d9a9ba0174474c3358d70d217c17332170a846b3cde4f708c6a1beb3014230bc83021024a3840350c3abf833fc057fd9c7488d83cb27f1c33d240894a9b88aa1e82c43938ddb790ba15d51f207aee28488b79882de4d2e896d5ad238a82b2d8f0b006dbb605dc86d50db69e38c81cc51821048711c59ac25d556f1042a43cae5b5133b56113128dc1c7247286f92375f24e8dd7b00a2c8e1d5824d7806a769e17afe0d710450161370abc037b2858a70f221ade3dba573e3bbaa6abe4705479e32d60414e3b8f425dc5a2d0be482fd11fc4654ad1e1f72df9f97b691f9bd8150215bdddf0e303a5fcc6cd4290960e2c536ecad3926a7a59e85665fd0acc3d1e18af549736a284361515e94e08961ef746827fb4d1247d2500a2b09d4e9a0f58d6c26d1d25241b353ce0c4ccd9a4f6315c4ff89ca02fd759b73d4fbdd5e3ec42670bf4961cf4eaa0ed1e1536b29d32ed08c9eec7d82860b355f970f2e392dbb698a0cd2e7547b4a5fe7dd004363a68c9e9216e3292c301f85dc88f388f950a73b3b0a0720c970ebbfa60944b483d27b2731b7aa2aab960db5541fba93a69ed9353096a1420ea565c6281f4489bf09c3be5800546078f2837b93dd5e40e597a4a31e2673dfb1c1eefa4587484458172c02c23d1117b57a5910c73a89375a43ce097114fec5ffb309121b1fa4a297b0fa5f7a9d7d07ac73e220b7ccac364998909dbec8bf5544cd477784b6f29f481be843ca0346ef534df7d65b2b2c46a1c4d6b861d8435959616975dbaa721fc2069903d9fd28a87558751a5ca34159a4af7adf4ae18354702e5035bc7f77cdde02df4aaa6947adabfa10a1c6439661fbbce2612fb6e065e78d06b0aea007fc04ca30d2705a6965f015337bfe88d81071f452a4c23114da297737c8675b5f955f0e22dc111fbb0f719fac81c7eaf3430c531afe1841802a9ac4603c3913cf6cc086c0193b61a66e72b120bfd6fd75c26b812af96f14c1dfd908021c2f718bfdf5315dfd55803d09a10384c977eea4f476492b17088cb32ecebc3fed343d36780fd9ae5cf715cab0c89e9eb71229e1e34d1549127020b999ca8623bca5a870f58b7dd987e7f503c3791b311f8ae0e24afb773baf977ca3557797fd0ae4532179ed6e06b1209189ccf9a2fdad39ad8455921582c593031e8bf9ce98d6e00d8c051b3b9b09c33c92fa63d1ed98282ff067f281b4710d8809077ebd13f4c1010680b96fbe2dd3fa49fa0c65c60ec68ad1a9c8241e498c2510b5b77b8e6d407f67e93d6044e33c50c1b3a623a32e24c1d17db15dd73dd9c3fe3f85c65e70f1502926faa643699883be7c6ec4f1b0e93207623f5915878cdb5e304db8b3cc6d015e14c81e20a693def62f1b9aa8aeaa9b404b4f1dc02e6d7de7782c38ca8bf3c26665c7d5f46e32d19840bf732a8adefddbbca57a3191dfcb553204cdb1967cad578d6a1d3b4264adb01538e2f3380fff6904d35e7ebcb0d4030c22401c965baa7d1200946fcbfd040c586fc5cc2bf04c235d400436f174bf260f904cffb0e02b7959daed104cf1eaa69dab87c1f896f99f6ba87a37792f1d04bbdbcad2e010782bcc483af99d1f8eaabfa4fa64c7706713ada09538a3cb2a3319ebfe87aebb802665f4b0cc3010005ca70a894de543138238315be561d85520c033d8c3c176874a1e521c516a5c4531cebbbb279d0131486584b7d79de5ad9544dd1a23f05bd9495b0d057c74198d274214dc9d0464a5761266b79ae7d58ede1ce6efe718d87d85eb45b8d192eab9bcf16e5b2ef98c0a834abf4d9f65757369556add5ecc887993b4eb763ff6ef1740c33ae3f4a99fcdd2add1c3ca52957871189ccd66994f12a3547f480bd7041867f118f6bf589a455a5c7214ee66ce9aa71daa93bd57f767a94a03f9dc48b374fa36bd813cc6a5b888a94f051eefbe271364cfe7b56f4a87852e4bdb395a3ca55c7df33e32b597e6270826407791ce5ff298a9c07bf0601fea0c89b05c46803514fa361b8e97c9cfe3c56fd072a950b2dc302e1c5462b7e1a2f390f3287c30ca20880b30c0d40e53fe3ff3a240c330f2bd79677b67ae20b022312c5fed126d48dd1bf9ae73c212687e9f7657c35060e8aca451f63b78e51c3450dccd2712340ce170ff7e70f8d9e234e8a06e98f639a13ce29ed1ec22cbc468bad5ac6b97ac248c450a5617a541319e3a45373d4c52677e3fb792f2f3271f2e5dba008c9553fd7eca5c4b9a4dbb50420edd3feda63b2b3bbf930fd0a3e2659605787318982532ddf883fbcffd5476ca47fc6b485d5fb1dedd5df2d8d00032a02e59b2a2dcfee4056344ff2ec68906d2de508d1cfbe020daa55fa9476d133c55c86c11b275b41e7655533a53b3a5dbdf5c44868e16e3fe0c0e78df2ea84b9450b57aecb8a5e96f51aba2484357e476f8438721a9e7a560469f2974eec929d06217e1ebd1dc84c16da8af41859b39ecb16deb27049029c234cb04671f0beda9184203daa701c664d7f0a5cf90fbe281be332c66f7326aa4ddc07b379ee07923e4a532f5b5d8ee8f18a5df9a29e3facea1b8eddd4fd89aac28637d67cf0db78e9619795101b25d4e07fbff7cd8604cbf8272e78052cb66755366502e1527501e51955fcab9fbdc7ccc255ac8f13f589e3cf24f624c7490af02150eac110e3f300a404eeaf84a483fd8a21326ee25c1b4c5c88077bcf6b551d679b73ed9abd1e2e3aa3531618365396274fec66260c9294e8dd36cdef869a61a2536ae58cb99ff9973fcebd749c53c84cddf7756e9b6da6b1508929be246c7c5f4d69674bd488bca7bce105faca8fa06f6bc9d7abb84bb2413341cffb41ab93ecd4ce1d8be66d9f8516a8fe034ee399c412d41e1cd948128556b77236b18782adcee450a1faf9366c5ab592f9cb77944c4fc51eb4a00b8241e28990db019b2eb93b165bf361941bb8aacedc6937ee61e97610318360586999ba91b8ac7500a1d3c83c84667fd91af3914a9dab122b12909a9aa990d59a602ce3544154af207ecc1951e65fd1433dd47f5dd67315f115ca20ee770d766f11d918df3addd0a812afe00d7efd16227ffe1ba3d94472c84b707622f965790b9098662de603665445fba8ff537133cdb351ca3e5fb27a10b3ef5c289323704faf3311380607e1df6e89d8d13a15c2844ed3d18e35b38cff7d92dbc00a30cbe2bec704f1782ffe7ec93b4b4de00bb0a5b6a571915c5575285af7309aebd04b88b849ef1d3c87aaf066e4c41472f66e7d35dccf5c996fdf3b21efd77e03144b0f1f649c1637a19326f56be8c7bd4414dcbe2eab7a8cc6867b37d1dd2a6bd8822d2fb356aba881d7b1dd1cb84696662619942da10c0997106d5f1925aba901f34934e779edaa17be461dad531b07225e28ed153f1466013fde79a4e8ead6a331817a5854462774f2312aef0c1e2d1a5a17ca7142700d9c340b5a0ff68f2a750489c262c660753cb362dbcf3fde52672a63dd041fd9d74a83c5925d59d06c909baa16a3b03bafa5b17e9bb139afe2dbc60ffecdd3b62bb7c8901feb1b46cdfa9b6121961d143738b3174e4bb3b191867ba0f1b25bb4b709682d9cce0a2613f4f1dbb5617e707be5cdbe8ed22390350c4152b0d9f696eb78b2ee840b750275d8bad17e8b074df3d16729da06615c98f4fbde88aa7474645f7e168927c3688564d67b7c2eb38da2c11ac00c8b0c0f4197f475a5bbab608a20fb3b467ed7b8115a664051e6f115ca5af6186a92aaa82a3d251dff0363c64721dda654c177c8c78c2456acd05a8f9818c686d61652a05f626d27acdee5a327c94c70b579e0a263ad277cd34813e38ad0ae789f6614a60c32b5cb8b94842ffe0fb337b522de5849323eb030d0ea98546eeb125d3cf7f28b29526c1e06c5db19425e3c56706e78b3fb28950483a0750851f0b33d6dea942a4b233ea8bcef088c12dc03694d4b28a01a7f0ae1da233fc21e8ceac120770df67a2c5e1ff84822978ace40a8e5ba2ef70fff1b144fd995d964037f67db73d9542d5b49ded7531c1cb50b66d2c37877bdb57f0553bf67f2b5afcc03719f0fb64c1182c8daed1bf69401cede1eb423edf69528dea27c36bc8b1544ccfdf1acc145acb381f58fb713af28b577cc3c36cd855cf49762465dca3e20d57b2b94a00af3d17da4b5179794f3e417615154d7da6215ad3bfb4255f0d235eea89451b99fe4d09321f284cd101cf1cbc4fbc2c32c73f8f27322876ed1ef52851dedd07a04ce0707c28e8077a8934c8721c696c7dbed3c884dcf7f4784e30b6ca7acc59be2da44a7e5490d9221abc975cd1962f13f3973e31cbf7720a71d0ad20971a8b82d54bb7bfd67459b58d1a29b85a1bca9419e3457963d39f16882721e0cd9018f1f414c2cdb418d03199c0bdf8aaedb7aea6f09479d0f724c8fc4b1b48ba756715473111c6d11335f07f66bd490744cb04c83346e3c52bfbcb2a471767b871a2263c3257b677de37f44f6e848c8f0942b40ac7e108b5ec3dd7792ad438f007249ee5f7893e0c1be635a9d11254dc8d9cb0905953a5f24300f2db4f8eac488e0c7e4915404b08bf83256a055c13fbecd0b2cbdc7a27b4997afcfa632683619cbcb8b8b4e820b6f32a91273929ccb11d0a16202816509383e4ae1e0c70e784b06b5a59155fd33c810b8cc48177a5dac1211144ffe3b136852c9104125575f3d4bcdd9b5c81aaa3a43334124d0ca18ec73feeade70a7f17ae8e2deb651e5642ef003be003b1ceabcde8ef30367682461f0447afb1e9b864e360686be48b56fedd068e36a0a661d4276e8354e756179d965854b20c58889b3bcfb8048d848ad14816a434eb2cf5deb010aec4b2f00c636d10a660bdb7bc44d217a04167148909919b725711264de1f8143cc0510ac79838bb3fa978500250bfb9f431082c864df1f2d69e7f6bc23dac5c0dd429a2fffa584c727be1175a01a4b7423da382035c043791885853556884ee5766097c87184e84e14e06876b32d03533c46c1f135df3a86400a6b3fa115738f2821f76e721d9282a24372c2780abc6cc82435bbeb7162b6bb968d50c4c4d1f9aa7cba7927ea0f775f4f5d4fd0d5458ca03f5501bae6350cfda19b7d0e7fd9165c05ac450429760ff2bd4681b2d7775cec5bbb9efc8e1e981c554e48de8c6816107457c13f0e9573b59e2d3a37232e42bc5e141c93fa37f18e1dbdc148d3ae52a3d51b7d7c355ce9aacd3b21209408677a3368cf6de508f81eb42a77b75e39a3f05a13f6ca4e8dbb567407cee8ef5993031dfd0a3bf75a18318da73de47ec275812c3f1656d0aa34684286563f4e44b72ca0ce35cde044d25b7caf35cda08df3837d62f75e5bb4243fe26c5a1d54577343fb0fb6cbd9f91db1d4f0ca08e8a3f679c7ed921f70f21de66dcc2f6ec0109d563822aa7a582157c934acd7577cdaab25e53c6592d6199a75c998c32507823a4a932395c8e564dd8c93f78cb74c50c559f499e07393ffaae6242a58a6475aba7f1c33bd663a79a28f0f627ba0443820ee3d64f662f37f925d11aab173c005036c57eeb7078e85104b5c7ad156670b0b706c8f482f2bfaaedfe07b08607f348f7a90d606565340a536e35bad4716232cbb99b7750e57701c22feab2960838b092c5750069060115f0f5fb0a98abe524f57647d4e34479234b133e30b070909827e17c409837b1c353d32c0ed2aa2e2cb5afec1eeb4ddc3d4e24d92ddc1dafa37da06db77e39dfafa7314ae07ffd5be5ef3a6a8b1419fc914602ed4fc2a1f6f068a09c85cfa9d63b8b4fdf65b432fece7e4ca39b8838ab036d5b59b7d360528e76e5ce3c5b56b42436082ac813f32b92790bbe0bf28371d0e7ed8147778336e5531f2dc918159a61f10ba10703c055cbaa0f2f8ade50a6b6f95ec844870ba9659f5b72eaed65a039a1e6a2b6223987cce79435647b7baa36466dee3191bf208e2105e5bdf7df388e9bafa5d67a032e1fe4ed7368224f047ac455a90dac475b008e795d4fb530e83a2defc375e9dcdcd6eccf31dc1db67b24f726ebd2cd77d97142cb4eba403509da491c24c7fdc23091c824bae1f7783389b34fcf52a5021470a0c940bc015e0df3a6426f355a19c9e8ea70812a184376667e1068d3195d946a9899770e1ca4154aea77f250515424cac39ec9e5c3413db6a9e925cf75b6eb3f83b32745c6edb084ded19adeea8e2e474c550b54b6f6c1eb48627342e7df30f7a85ec4d56afe2d488672a06b6713348c03fb0a3a2114a4b7215de3ff341dfa5dd960f5bab4b57adb98ee6a52cb4ba7af6ef58699f2e15840feadfb70c191a1304a3df77f97d05acb8a31b3d232663e7140c26d763228cd3e7abc979f5d3627a3352bcde54483cfe1e56e977a825a8212db666b3e8fd157abc7a05014801cdc9c904cc64fbbbb592c3b2261891a0e95c2f883f37e9d79e66d98f8d242a745b1c4ef54cce6f060b4fa053894d814c62955c5bbf635fe7e88b53164c88cc4512df12c017aa1cb6207ed3435ee6448ff5c0dd8aac5558f86d657ae9b9c1412d9f8127582bf6aae79f5a784bff35578c03489e03e45b6f3824825f6bc30f34f0c007469b93ec9ea12b61cdb0e6b8a33020a3f75bf5492c33be0730c5a3a8c57956f005f72cae17a2b2b2792df2f4de4d00e81a1bc37106af197e1bcbe007d9e17f556421184742dc804c4c42864b13191fcf60633d94ae32fd19a0465d878a42016c399f24763469ccf639950f21a28b8ddc8c7df3d2642464cde7b0535d55b9175712bd419a853d95f6e1561f3a337628f9ca2b7a99fdbc4aa97da1f468628a826b6c98ffc26df23b7b848ef3fc43c9425b21a5907318fcc9855ccf92cae5d7e50e1d1251d4f1c406e454fcdf8199a44352b785f0d4d699edd7519642f50658312a5ff7edef10775715573b4f59afc5bd90f8d84f20b78c55fc2c61c6cbfaf3943112d7ca7e920b9d5602d37c1e8610cd14a07c2c460f3beb90c67215eeede1cbd4224ee55fceca4bf874eb6cdd5f37e7bb1952c630680b54e16c5f0e17339672263782b6a0961bcfff5cbd622e03e6e78fd08277a3c498f8126219a3717ec7698cb2c7f434c29bb26d90b76c423f75031c6201a6ad330da022e12a5a25c106fc822f15e2d2183c8464c33b0ec986414cc50e30ad3e0e642c792d781f4234d3019a66430fc485df49d9a5d0e4cd2dd893e644213f0f5701e418aa406e20b4b3aad81bf1dfdc57c17e09e49938c69bf24a05af24e6e387b35a41b7d0b5aa423366eb1c82397d0bb2e2e879997912a1ec792d49f7bc1cb696d1d8eb944d58633a440c51b0c300e9ec4aee4d0fb76d17cecdb91dd1de1ca994526cdb294fb19ccb923f372f676407615f5876072e807433c6d2027d6e0c2c4bd35903baace221a280596c05204536e41ae6d336b90b2361d1344f5f86579ebc70052b264157748414f7a9d20d9d75c12712586f59e63e4b9e99b9ab17084e385a9cd0454830846ae0b49d5220407968bc3c82b0d1c2ca1e606c7021f06978b1f86e40fb805f4810e75dcb7e911c3c0d40a89bf46c4b0bd19e2080d7ff85aaff641a3d92d4c2412b879b89c5a6ed82ec89b019d2daecaacdb2a7ed060960cd9fa74371f17fab50122c5b9c8a2f2dc351e36d7b58c45643d8fa663f600d429aa632e1bbf25848a19b7257268ae694f256e036d978c3ec1b5c3d973890049c2f14b67fe3b1b04dd05b9bfa922d1be2f9ac6a2604a384809a81dec8c059815b54234b032689d3e64f58512b576d59e55ab57e6cf7e92201dcc48dd7325044b11dace07e2f1a00270b9732b2d54f7c7358d68037fc6c46b7eb5b4aa52d41c5530b638f84dedb3703d1e308e34b40b5698d7ce1e8cd7ecfce196481d780f851e5d4575e54ced845e33829508acec006fc903a968dbf26239e83184433e8bd9dfce0701d46f6cd238ba0c452afca33e0da66824760349b0796f45d69f8e7a8d717984fe456eb66a6e4667d3270f6464bd36668cd885a9d68abb25f59e140d4eaaf92390aa3ea63271b47c637f842637541329012bca551f05a9846a3cb4d3499a9ff7ee53cc97041bb21a15ffeda27fa2571cb190fdd2863d239ea0a9bc1dac823fc0483bf86ea48c74e417e2176d0b6333e93e8baa02b9810ad2226d7ec19735117d6c45e5d6bc4d6553bebef29cf3289c373ba6d8ce7a09ea467e0a125c9b61bb08e0ea2e8e810447bb22b45a2f5d664961eee995ceb77c5dffdbe63111eec66340c8a466bcc20705dca2c0a54b0924b3098378fbabd528066faaee42384d69c3247ae7c69ac2dbcd772bcd37850b786104d4ab6f5a86ea1b1062228d5a358cb8869025c2686bf90e371ca21f74062564e4a58d1e9925ae6d19052b08a317125c7123849fc7a1899115d63708b2dffcee038aee6e7dacda9229fb929988140396b2f600ab0c8380c6c787f826987c76c116277b60f4b3adb053dc8f924e0adc2f73711f920666300ffcf3b8a16fb73ef7fb03f5e2ac4c0f9e6a8d206a2949d5e713a9fdbcd790c7623c6604db6f1af1bc923b6224ecae9ebbd776bb6d81cf42d07a51c77cce59e2e23fbd3f61955b1cc128ce498e7e727f2313859ab3206b3f356fe1532788397c45bc24d386c3179d0a479d8af51b8fee0cfb3a3133c39379bd657006f320718184c22afbaf210cc066277e5929a50848f41ca2cf404d4b25e318e31ca7ff0f7363e2e03b5fc729fa1e4805e87d5171c9b8d21ea4dd6efb26a09c474912fed0ce4a5613fa54e77446d59daaa94d9b48454a561a2a4e06724d63d0067142717782b97dbf0fb001ed5d8a882da9c8ab78bbd237b4eb34ce438ae332750d37f71700db64d6746b43dad35fb082e8d7b1a071d79dfa962f6cbdbb11259b7481077444aa6b590bb9e67b91eeba4cc11ac57bec11e4ceec12bc56c298db3490ba8ca0ba84bf3bd7a7eb4eecc3876bd8c8fa62ca6b4b2c8f515168f72f8b6907a55ade21bdca14f193706bacb974d4f4699e90bb5c04218eef1f897096760ff5c1f5b32223d9b7678504386186d5629a63f4b98f2c612802538486dfb08ba6fb7a65307a363a538fb9561eecb742c427aeb8ae426c6b4264510322c3084a7bb68a14c6469b6edc82c7c44026c23c9a1fd9f4bb4bcc1e684d3cb6a3dd7a5bdfcad22926dfc1d1924299faceeb0cacfd0cfd040433163dc0c4d82b11ab93bdd5fef183d3d8bb049fbd8c164f30d256a033f2b3102c1971367a862fb8db535fd367a36b2000fada6b40e48907df7174c3f22a9f4f358dd71acfe0e53da7c4b05aa6a9f54e5130d2b77ef90c1712580ecaa2557e7a43c050d765348efd0aa0a5e5b8e1109ccde7b9e6a5dbf93313bc656e85423d1a10c9af25aa1efe0f8f10b2f104aa12db4e98bda49f28f533ec977443d25a1f2ff01bee9b6418d47b92868fca7baa9fbbd56218008d24457ab5f9b03e552eab9e0cc3826a0057ec634cf5bce7b2b4025ccd688434f42a8fc99ba4e68fb208f33ad58029d24902c2d9a98c7b5dba95f338a96fa7f7ea096ef2aadf0cc7156378ec81835c088b6562072d08cc1d392baa2ea4644e68d4fe08fa9312cd7d610054f96a7b886998300aaf31c741b5609b897b6ad79fc2a9206071d0d74b3c5479cc66f8e28d633f976019261f75410233692996ad28687a8181746a4b7fecb9e7e6b6e2d473e66787d13b2990d5120b918f68201ba1b7177e00dfb9a0c38fdae27953eb0ab40cdf6f720af1d6ec1c6b325eb362730fc4f79982e81fe4d59ad0f25c68c4b612c6fdac72edb08547f1870c14baacc5cb3b1283f077e3b7471a30498f6499101e9ebc4b651017e07d82d2163714efc2b66c75e0abb799e3f859788549faaa48f962f8e422b54bd04bf793fa1d9ddee8a841b19dd8c30489941da4063063f625bdfb2c81bd3eb96498d6a911bdd8caad039db90bb88ff941191a923e1a590755160ba5c00f8edc6ebccb701a37a636a75c8f6b9dc8e436bd54dfdad41087a8d9659dfdda4fef13d787df2d25aebec8753d91a38a03525ecc3d386b3ac90c74de650ded1907e51a01ca94732950bd9f32ebd89545548443763de9e8d414954282fca1d4ca22bc6cd49fc394f27d4b47f4bbdfe114f4a4917be2997fb40229edc24aa8b5760bda792e8b7888daf735d6c39ed9a9f4a3203a249e80b9b188f246fc4a6fbe89ba42fea0b5b176bd48bd9030c45d9c1ee0d78ad9dde77f14ebe61149b6b6efd87a2ffe44ab201ddd56783ad53d70323764d652a8ca2c56693758c37cab79bc61e85d8503aff8a97f7e566a0764a64977cc10d05ca1597c5a709a213ea7c46edcfd98b9440a256f9313085063688c78b30bbd7ad9b7918821abf450c489d3c65946de38a24032babe1ae76274a44b58e5c1aa267f29936f400e62204839d446fd4d04097b50599a263e1bc560fed37177de392e71b06ec657155c950576e6e75c422733facfe8ec1486102357b180d1e91af83ab81e61c401e4fdebc2d53684f45c56378be44e1a12a9bb30e4638616a65ea0025aba4ba80eaed63035e35f792f92aefad7098a5ad976c112e76a10ffffa1ffffe520413ceaaa7664fac2b9b9e6249e3e7c3562a20b919c3e1648a1fc59bf233a151bd5f6431f8cf230d32f51e26f2207969bd5fc9eb631e0e733e0e988c33421e63f942e0907f0fa98fb8903917fda204ed357216b943ab33f71dbe22ab4077aacfe2138553a24c53da00cce0a98d0a9001bc5fba1df276d614e8b2cb2a845b275fe72cbcd6bef98ab5430404aad401fac29f9056f5088f6a637aa5a2a84969f6dbc285f8e6ccb9e0efd4dccd276dd4c47b50efc8a5c8f16d1f6bb7bb9dd0603d144691416dea71f02eebe62a769b87e141578041aca42fece1124f2fe22714573f215e1277f3f2a459cbe8737195fe79aaca1b550f2a036c81893fe911b88523b15857b6e140c852ff89316cd114308408d5f49ffbbb412f73225f728c09319ad3ebf0c4c8de68a6e9540f264a7f9e6176b9ea5aee9928fc7f12ad0afca276dffca4694dec00cbb8379b374a193e873aa58fa0f9ac501f827dcb4600c2fdef46b95e1db65bdda88db04bb58e22e6e2cd9dc2b56b9218ff09768787fb1754971acdff87693f29b4bc3ba35f6d222224b1488fa3138f0928b5527513f0c1c8d0decdec5fcccde48a440c1034ab4005d411c7abd8d230ca5f3ef9b4799bf88554ad0d6b85697d61f4798dce0a27599aa0a0add6bb9a8a6e6f78fba426bfa5057f1d46727f870b0f59f89869f5b426ae60866f74d98bd186aa3e10aad5e296e7a4b4e3fa5f38366694c34f55f90efa1ce4f03646bb75e9b6f44b40012ef5e7c44d764c1dbf86089f47f095e220054d1065651628fa3f0d0380d4cac0dff4c678352e59a0d9c9b2914a6bd23c6136c4e0799e5edc19d3eba496da9a1814c8f4c2bcb788939880e474e44744037538a6f5f9c65c7286c3b72c5e74ab76930fd7ba9b22","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
