<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0735644b7f441447801f40bcd9b62c5bb9324c0ddcd3e56528c907c71002d27f59634b7e5907ab2b271a34017a4cc6caf572c76be90b59d36152998761083cf91c64a9e635f2008d47787b6af7b3bcaae3c8914c1d111a9f15627b7ee9ab583682af4bc3c889853fdc6bd4f7c7ef7b0604102152eb476e7d46a13fc44fce3848d672e175ec1f50193c498de444adce0d9591199f34a6b4d9e3832c0e09467d27fba612a71ca6d86d413e2a40445983c9c43a8c8e13c85e3997ed6ae5a1fcda8871a764d3c4bd7c79157b83c172b240187b5b030eaf06c7130c5e1a81b18136009a9f6da5e068f419631113cb188037a5b26f6827167650ded67517a53f7d0a999c7ae70953e1b444e09a440d44c35ab8293cc0ede3f20736b3bbf230f0c4126db3aed70c71fd83c32458fee8fe632656d16bd6c0984e13e5c2255ca7e079d2c94489cf8adf1fdb55754513879e617bdbb044e26054c9be523d3247d59ccb0a6124dc42e4f5d5866715d3cbf0d62d6a6416d0fe670edb991697640cf7adc0b736e567e8701d9291d8a1afe8e4487e8242a65428206b0298475a8f95d2da7de8da8fe050a1e1405f5ce0fc306b569fdefe3c97856de5d6853679dd8754da7adb967ad2e8cf93b094871c80d6a55684809ad36b32c14b333d9e28470c7547535f54fcbda675576e8f12a481e9ad3a3bbf9c5ed740896f81e5edf7aa65f988660bee3bc9b84107f9e6242bce25f25682da9db016a7bbbda0387c7d70f65629c5ba36cc26174d3c11fec6562801c16cd2cce53808aa67ee9aa8922500f85795a6f6d2c05cbac49b3df2fc71acd7f51510cc496447798c518e88c41c0306a98d50d9eb11d1de64fd4cfb291a7fadf48fd36e664bb7216b43a64a3688fb9102080a47c54c7b533d5604044d7b18bdc6151609f1c667a1693cd342b72936b26ea261efafc8afde6c1a49fb9bc9daf2f02acd5a42bddfb2c62ffe46da0f3c97f95594127bb097d37e83dae69f6dc79fe9d116c2f5637bec144410b684184ae329351939c15c14c36dc51b61e392717d9b32c3c3aa09bc01d01d86bba294358a4bedf1ab17b1dc32596546f4d1f664d4c2336b207095c0a9097c444b0dc16eb7317ac1b9219e726c4c53f135801b7ed743d086791ec15de4734132cb5837f6278475f5682ba9c43518d103c9456c297b735e6bd861406675121cd8831881f488c184d9f7965ac801d3018a488ef16e5fb6eb8533adda0cb83bda7e17c1c24a20f29e4f2a5a35b276310d28fd1880d52a0581c8ec422564758b61ee776a818257cb60f804f3577d3f5c8dffbd55ac1a6cf43f15c98423607d69139834f3ebe275f5898e4713f1891f028b6f9ca84e0f54a3a7e79e4c072485382060e8a019e3522e2d85893d4a2d7a5754a389c3502e3ac47b5a91758dc9d977cf302c28e7b6cc413fcb89cad678d6d89a1f20490e96e8596a3618506b51d998be028bbbfe3e6f2fedcb2f4439f7f6b6f9bac2b7fb0bdcc02131e2de849dc836555dea23282a7dda5f04d9f989d273f47921e78f529e008d07dc23ab8955c18eb89f3db8681052f55b4360b086af75b15577f24b2001b590b4cba5c76a640f386c0be6085632f103b8a772bf5eecf9d985ddb771a5152f4022256a4851cde9e8a8d632acdf7184734b3ea6945bf1f7d3ead5e6e15c368ed2013484db91657e464a192b1f7a16a981ed4a6a551dcb3469fecc5c77a1cfe2f170d488f8a4f1af38427ea683438b5c09f646d6844b5bf8ed07277dfe985d0ec73f1615e8a0ceec6ffaf7830dc9ac51d98d622970d460b46c76dfafde8b492d038de169906c6947195520aced30a7309c32567ae03f25d78b9d9d19130a85cbcad5a99a0d44b6cbc0beb5a3c96806ff94bdd65be34ee595bc4b966735dec14b776d0dd4c05841f5583d458aec25c8ded06d1f054566e88f54cbb63e88f22b7ccb9c127fdfe3f2515e8f66b6e736daaddb69f95435c6ee5fa5bfc176ce249e7000a42db3571af0b1ec8ee61135fb5185a760d0d1abd34442c61ab42f50d64fb009a4f6c204f25e52dcdc79b20e990158e2b45a88ac07380f333ccc302622e81ca35ea6a1ff7acdde6deb6e545480b3cc60d4881687413443ba4f14ab07f853e174d51cf1d0c334a19f889ceae06a0dd46f4b6047441fb837ac3398f3f4e5106f659515d93e98f09031f8298a52e05685219b904374717dd1170b2ea676a3bdfacecabadab3e34b093efa9d955c356085c1e450f38ec54ea20c6d1007ef792e3443d5978a8d81ff2919055feff25b856f797907dc59536f1267e6375cb0a19c2622e419bb1ca569f3b207050e7ee57fb031d00c7b6a84a09cefb55b6ba99660528ad4f7c077888aec882addbd71a016ecb605b0cb3af4ea7baa28ae55583020799e3e9602b27f45369170f99ea9c52c239899d8c477f4577df502d72de2fa0a5e5212160fbcc066e99ab37b1919881faa21b8d78e7fd61154e9907f7fac4fe7d6d57232cfa5b6617fba3b8b160d18c03a435367fa82da32cd4245861de7fadf3f018761382c643a037c4b1af0b0b96669971f5a73f16a4804bd2d7c9c63c5ed156d3411c254bb72b309d4da3d2a644dc970a2b398c9aaa577e6f48b05712257c8d4e10ef0176ab186163b3bbee1a4daae2b220082fc94c2bf637cc6b724c93205bfca6da2fbbca77014a3cef629335e4130877f388875ef3aaaa800ebaa77a6cac694ce41f944b10a9de0af50649952f5c90635e0f10acae00adcc883301857f4fb961941bd6347cc86c05e0e193e5f8e360f80207ac27e9f6adad2575f26e78ca968196b0bae9650701ced74d6f353c8c0ff9def35f3d6e23f7d9ee2d56e9f90b6f8fc13a6c243338cdf81fd6db7a6249fe44d2b71807a3ea3ce25b292f2ffd6df47703c341ab29c7e9141c9719a489bde85103223cd9d5f543bd9d0f3e90c198cb4b4da2873f3bf48b36728c2ac5c96b5de775225fc38d5b5d42867de29210622404c1abb8c80c5511f6149bd8ca5dc4c3692c555a65e15b2e35e0c9ec99e98d57548c41b2e4bc7e642c377a6338e74a9cfd9b704f70e356fb477f7461dc6009713e75afa99c9b33eb91808d7d479abd73d00e70c9e23df4cf83c6d261b2d8a0dd8d48382ec5a4e1ca22360129bb0c11e6f16e4fa21142122508968df5bceba9c55be0e13e004da011ba55334e006c85b99966550c9c6c75fafc3310f18d75a3549c4a0f427e679b4fa9bb19c04705834dd70d08e708c4bc95fc6444f3738fb16594a869358225c872e6bc161c825ac28b1259a6a67b1e850b85a12989bb600c4a5df676ab6385f19d122b0a9f89ca9b131bfbc5a60732ea75444fa091ad9888d879d800a655672006e9b6c7dd77b00ad393fe2727111650f1ba85fa892d2473e04b18fa95e20cfde6860e34df9f1089a1234f9899f7d0beb39b482f4ab4fb1260d79f755365cd66fe47f26913959de80ab4002f04d04548270c63f6d901cca8bd5b9d0c620faeb895df31639422b754d525b64cbf9e542e32eb4bbdaef27e6aae8b5574c223c3e6bb0b5fe3417aa8a6261a7192c12f1358411ad6e084efb02fb90e31af7bb94eb562611cf75bf35385d3d521be9c769c2c7ddeb68a17011b22dc29ac1c0a709f5c5261b9f4d132ee274d9c17a43c5ded3b972bdccef08d06fea7ba6b26a19ba58fde98c53afad96c0c0735867667c4df2ee23f9d930a6b3a9bdfe92f1ecfa73d8358c8a1199ea2a41d3d5058af287291a2526b1047787b255fb38c4c9ee4bba4cdeaa188de6e9c516c9b7721f93676826cebf6f90233607f37bbb765193cb01d895fbd82ae59a4d46cce660773191d59fe306f01552a9e0045094024f3dfd28464da8335ac98c9d7a9b693355d1ab2850b893fd1e1e130088f7e31b115be7e68bfc56b869c9c241b9ecf49908404cfe48387818cba17fecde761d987be94c373259d3d2938fd780195e3c695dc8c0461b33542b7ab844fbbc13c2e15e879b1491be632e36dcda36ade2a934ec210ca33ebd9858a391b89bf101a00ece4831d8b2edcc4d8f43a0e3806af284ff9c5bc124bac949e0c19ab02090cfbd71d987f9ec19fe490ffe8974e080b8c0367ba4c2852e24f81c2bf70affed505a00110aafd479f7336fa2e010324ab95db28002995b366e9782416c4d0202049f051fd9a98963f0395b09703d2fd7fae387111f8ca073506bcd61f4f5fbd93e69b3b0be7f8109c3a2a32d0e16812e09a371fa5747fac43f8d8a053d68b2722f715204c2dcd0bacf643f9db53dfc657264c1beb25eb20632a13334fcfdc22329c65d4a4af6bc0eb846f7fa881e01d7ceaf6861f38819285adb040677c65f47ff5f55cd1dd6601c645d1fb89d428ba19d6a2a7d92c62cebf79947b443fb45634ecb81d87ba8db57986d5c3025fdd4dc0707858001502f58b850f3ae0ac7a492525b028abf5a08f0f5d01a60a9d785bdc9111d3ff7cab1a8ffabead22736b0fef1139c41d3b779fe095a5ada4a0d1fc7cecd67a1b568db2bc2671a0a22e76e9b45665fbdb735e2aa05e7f2abd95cdd25edd6cb05e534a12b4d4fb2745d8e2adb78c3505cfb4bca6c4a78604b9aded04925ffd385712b6d0998feae6c5ea649c26bbe4550effa34b41e394bb9b7b96f9fa53fef70b8be7a80ab25f33162f054e4e2ce1c0bd47aa22fd683e71d8738e0f25a16120b97d8d2586c070e845d9c1efa717195cc199d17e209d7cbc43cf631ab08d91a9c4ec99b829775c0e6bbcfd05642481545b5b57dfe7a1ed4e8b25d77b4114e2c77c3d80ec9f6f9bc20f179b2a3af378dcbce52a36d9ce521b63de90832ce9e12b44f5447ba9075847be87d18bcf6ce4c264e54371341bf88f86a45e07a0d5e5d120cd1674a1668e373aa5bf8bb7acb8d798f0e5b4d08f9181fa182dec3d10c928bb5c7644fedb6d9217fb0c7d25a39080ef7168aca4d2e202a46a7edfdf9a3fc88781d10ca0ece908ca1a3142b25496546a49a9dc1ab5ecb44c3defef5daaaad03304ed48ede3e0f371373df77426a9dadd621c57d451e2009393a38a72ad70da1b1b8f05e1d1a021d45311a46f7a3e9292e0995ee551cda23fc374f52f73f27935d58e555832833832ad6eac171423ad9cb7a95f3dd43bc4f0e4fbdc286a39ff79a2f8b96605513a88f99fdf4cff8c6e6103e785bc82189fbbb27dffa6660e49e55bbc12f25ac2519bedd384c8fa43a1ddd11f93dc47625ad8af22f9990a828c996880a4960732d07e2d465eca4244a779da649e55bedf65979c159134a00c7ee41d1cd0dc9704e4f949820d61faea9da00f81d884269928fff0ac1739010fda298ea52847964c2182ce6000b28fe791ff0ebb0327581e4668709ddd12ff0feb07f03fe3090d72395435c4d85ba5e02cead6079d933fb5435915b5ef8fa71c03ec557e0a852a7bb50af8ed6b6e9f7516692938eca3eb34c8a8d5dd77098705ff5efd9bee3df0837ff79cc0c2c030e1e8dfe9c9085064e632bf7b4cc27dc06ed19054a6c53247af65e81fb06d3c793a27176493ae45c748fcac687f6d73e869012a20e69e7ccd811d328d896ae6afd2a331549c9de056eba84a808f1f1a4f144f5bc7be8638adfbd906b7a55d93fb86ffeada5ea07619d3a77eec3a7810fd305499785c0289b7c6c69f696b07738cbd59ff3f00986f5b9154eef9d8c4e7467ff904e408a56939cd184956213b9a2406abd210c25b9c2f154aa80dba367a1485eee8e563ff0a1d869d11ad4acfef779a6a62ca0d2e8cfc00c16d6e2bcbe97a119ced8c6fd2790908758337e5d7369058758fd6b68288d8ac88870306156943e77b00f25025b01ca7b83d96680ed336543af29d61f9127898573cbc9d078c14c512dec0b31ba35299eacea8a36811bf949e4c0d9fa4b418d1d7b12c07b25a97e6ccdfc36c5ff436a126874096d490479bee87dffff823fe9b7a8679edbf9d12ec39e14bd36b12582e9d7098a0460c869cf58c722b238597d5dacfa37cb69d3989bd095a4a16ad06e59787bd1e71858e4e4f46067d3f3d22c4fd69f7e781bc3b0991c7470eacbd1b495a504b8d828b1ba4d9e58ea7d1fd366216f6bdaec71dbaf5b766447551a93b7a25fb0636f8c99c0bac63ad0bdb76b1303f9d4196d298692660b990045f11fe7d40f87f6fb062426fd8de06cabcfefaa7e5ef2622b89034fd98e65272867ba9259ce0fa98a1107cab7e057b5f96aa775f579308a87315969b9ba8a88f82024cd9fb318235d420d2cce6cb8a7a37720b5bd656ddeb91b5c78074c43d9182ca95ddb255f53112412d0ab5a91a0ead595ab88f8cc79fb3fca7f11e17b973ca423c856bb4a84a2a8dedf2984df152491f9c13215499c88dd9c8826b546ff34a4d1d91bc340bea6b16dd5b114c0639884b4fb23dc53080493270986c0cd5761a6476a84cc48b796ba2955ca999dbb7a33511ff95cc6045ed12b4178e8ebf375b94fb9b68066fef41a1fcca279185f5479955c8eca02aca092fe955711451167bbb5af555a7f9c0808c79c9ccd6a8b0f22d2ccd8da642d72442608b4154cf1e08213374dcc7b8a5855b48b22ebe4d6f4d0d7bc5b6b259b605673a6cc1d9b3ac9c0976847ce477f780c7755970b882acc984a75c7aa2b1a79786eeef9db519d74a8ca289116bfc367ba3f3114e851821bf5f6852c06331456635408f36d729197f7cac4d0f345bd6e9b84fa3b4f22b0a4124cb793578cad4d9ee56b0f1bf2438dd20716f53366499507f4e306ce2cea9decf3e871d2f1c9870b075ca16f582f3e29cbfeb681e421f417d57165b089a33637148375e7342aa65d1e3ecb95d78aa76262961f96f65dc3b02b3b9f6247f3e618d22a83ef5c1bc08727fcbf571f4ca1f09d713fcdd6a46c70b2d1e91f880080d75dde1da25ff776600b87a24fad1206907ca2ccf3c2378d32aa30c53f10d8bb74f3682d6b55199e0fbf251685fb6e1ed2440226ce6b3fdcc8e7ce14d704c693b294198f1808b30d8fa3ff3438151d1bb77e7025276c915a35192bec13009092e98d859afde62bc2a1fa52b1b6c82fd2cff1bbb887f46601ef423f5e5bd812269cf9b3d2789f8fdfaac2bcab4096e53908029415996af0fc750496505b4622f976d709733f8e16820a31851cf2ab727472e1efe1303e2599ed00d0988e4edbc5aed6b84d3dec1a1e57643fbf53237a8d09a455a0ac11657e8a3797e799d5fc9e3bf145ccc84830bffc06b91a841d8fbc98cbcda06e743850c8bac23d7330b8587c995fbfdf83f7fd3391111a4fc5b3e15cc17261261f42456fa982361ab576a09138715192b1d7814a4bea49f3f668021f4d8b92806ba6a66322d866b9d5bf92f6c176f7d90b65719d1abbbee61fe6b15771124d683a0ee6f54727753fd28084fb409f50d2d18bf26596fe1962895fc1665e68789d9de6f64ed7483baafb522b092613a663aa30e60af57ac8a0758bd5cc126eb10ebb5b0b171244a25371fd9715d0ec759bcc8dbda484cf4bfeed1479ff0ff2400d02170c9dce0b97abee9b75f88fef5d73574cc06003bee8a20906655ec80fded29402ef8574dd12e4e832944dd83a82eebfc5745157ef9d759696e96687c2d4faa50f5decde865f86207c463fe69fba6d3eacb9df75d27bb83810f47cef644ec5c59d5e966ea422f782e8a8969cc029e180e08209748cd8a2d8f0fea37c7a61441a7705ef8963a075d6b7e412c7c01f5261b39ca40d9db0093f743beee5c85eb4b080ebf8d4d01699c6dce15bd6f1590ad54d872a2aba656f4812cf28bfc53241dd307a3b44256b49fe9e628f1d65eeeef44a817e826bd85c9650a3dcc813915336c4c608d5679061574bde057be36e0298a458936c1fb2e1c2f31a44eac8085b46e17aea9f780956fac64aa420d427341064f5bd90b0efe9c08e9feae6beaf23ec1d9ec369be2b4c25bbd5e99f260b62b113fb3765b9999f64492f821d722eee44e14065c251aa5f1a07192c810d2e01ab180c7379dcb7217dbaa8ed8f5ee16f976db41da0d37a88d6f25f1b7cd1e6a85a549557ec96eab28dd9f3b1c88a506874609077e829705b7fe9b08144ed94ffebf5a5f0cec05b19555628cfed0e414b2fd131de8d25f6365f4ccf1a98d977f3c6b300bea292f6ca726ba593e3fefc5e28000607a0fb4c307a0d38d63b9cea78ebabd29dffc62275a1d8dc271e984ab24209cc288466ba28f206d69ef4947268ec0ce246e2ae754b24bca15cf2f6647a38b4e706fa9b7aea5681d20eac0f10c2f06a5c183da8061ffdfce8029e08b78b84595d2dda719416bad8daca7c67fe82fa72efda3ad57f9bbec0358f1e1d58d4486a19008ff223f989406e048e4e8df089053987a508b862e4c049fe9fe1a6dbd8e26c9af617f12149bc849a65d6ca695da349e5184538f1fbcd4e8f1480f54ae03882e306192d3c1de796431606ee1d2330164c5e9469052b9c9858a596be3a1298a1ee788b0d67023c91b52216f3bbccbb179b8bbc6197bcb479a6643868a512e8b7bb888fe8657945fdb463fa9e65b53b2a8ad128e0421ab30da7b296e3e0fecee6a77c365a34afbfeeb8a270fe612903c1ac3e7cf9e439c134d5ebab6cfeee2d2cf886ccb2bd58bec4218852ff932098f5612f57a63b520acdcff314ff79fd9cc51ff6c2b32b0b9c9d016301e4c4064d1b65ecd7d60d9687e3e4c9199811352ebae1b84e1531a3e9d2b1289133fb481bf76ace03078a0536096446e05912e17521eb9d026a40d54a52aeff03cce7301ea936dca4589717c83b43b49e8ca7b08711118af46b8320cba45f0536b85366f2af7c8ca85e304c241d092b7e568acca7139bf6bc2d67655a61f14ac88d7b0f07a663e09fc8dab922b52dbb314e8c9ac524a9ef5a13c462aec447f0367871b7e4ddc5346b918024cb62516088e1761ad1fd368f1e3ab20f192c49e0637cb42dc2e23e536c17cdc12f74f52e53d27ed4dab2cec3c5c01ed26c858ef864e2051ba64f011b12798d13f6cbdf7bced999578a6d8c20c5fc0ebc5335b8f4cbcc32dcc0ff0e6c0aae6207a7ce296d371f0993bc6a7fdbea798b2c17e44e47dba1d1f132fb9e43b7c14ed45a52c34d60665c79c310dd42c92aeb6b2ef463a1b209f222b4c51f59b26ef1d12962286ea0be1aa5e42b488606cf63443c914427226800f0c597a7c9700e769dd3693c02ef9ed95c79a437b254e5973cfb85faa923742acf24475bec269f87f2cb2af0d8f7048efd90e7043b67503295278ad6d67a6f1688d78d52b0cf955c27d3190a3ba82ad95e2b4e3ab5b5e830b4b4283c3c74aaefbeda324b20422bdd941ddf446d8268598c4a5863739a7c4de9ecd49426339c34d9a01af57c161edec03e4abedf2193a8e0338716a2729f6f30a374dbdf4a8db72d8919d9607e02dd5d31ec28c25b4678e5b3fa444953143b0922920c7b07e9f467d0bc841ed04111768a22137277563aaf0d89885079c4f828560807c1083498831b37fa55eab0164682fd1b7dc74a3d303df2dff0ec82070474ea8d7eabc0dde5dcb364b043f7ad06b72516288a692c057d1c59d2cb4981a3b5d1d54614ad1262ff8774d43a643012948fc4aa3b840ad0ae951c7e6a6cd47bb16f8d6a18ea5a8d2822849540de7b27c421ec87674bb3cb84ea8e41c71d604b6a6bfbecdebb41f5d5fd794e9382b8319fc529daf2772b98a15329d9bee7b3327f95f2578cdaa6c129f246614ae47cbbdc955d275be2d560fc99d44e1bbd74a45ed3d6926a3e7735d9e3ff10d95e94538a965cd6881a9402292966129c318f459216bb1371c2c202ddfa00c10492b43ee7a52f3ff3de466f1e1adfca37df27f14d5000b861697eb57169cf48169ed9a4b84d82ca535888c80c1d81f355d0f1a80fc9927069ffd78bc52a5c89e354d3a5812d513f004dbd00191b93fb5de0f629495699f5d81cb0ce4e5877f173725f96b401648c9c1b185a14a5c7e5c914f55a7c17417267b2fdc779f282b7fecc8e487a2ccb9974248fefb2c01244de4e6e86d5fead9d8d6369a77ce98d24e5e6a412bd0b769b234c924154890e8e920b440ff673a594fe00d5590424a62fbfa12428e22a9230e5d3dce39243b72995b17743ce693fc64fcfe9fa777a5cf12c370c7366dc8f233ff492ea90522cdc430a22b747b6d83af2f0c6a01324e2daebd0255dea938a09229c781d258db099f1f3dd18ed003af5d444b8f4cbfab6277aaec3991eead9530976157488e523f01a83d7de1163d1685adca8f742e1b0115c9377e04a74eff06973b5a0b1458e36942c7548828b10550f21791baa4aeafe550b16b63a9458e6a387b03d260256b90ced340c11b58bfeab683737f8e80cc4e841b22275c96c37afa1eebed5209995fc4cc153305576a9d5070061315599662f2212eefc0c6eac9d796461d492c34135a085e3285aee1216e03d57b52ba01a092eb947508ab60d2f2da4ae700e41470f947810877b75f08c723221409d5a0ff05770cb8615ee1baa8f7b7184354c290eb7d5f4afab1e5c592608897872b21062b048d8688815b4fae07c6abb19524d7dcd7e29e3d25511b9f71c4f9631fa447831ba6fa9e228bff53366589eccc426ccf14fc4bfd03ebc26c51afd967397d5ad30245eabb2a5d722708c33e0b7113fe3e62d24d1182b4370537183e28ab1eeed1ab1d3877300fbcdb76642ffd36959c24253f6ab039e6239b0612bcd5aed54edec480940795c06c4b4c514a7802f3cd213e77b63ff9f5c7d4bac4ec5f2d1228fa7dfe76abee276260526827e5364e20aae7b3e192c985188aadce10997e6cbdb8a1437c88ce904f22e905e3f616d48199853e10cfedfef1e2fcf98fa727b45828f00a1be205b89b0e767f7abf63b3dc710b087c48834aa2cccde3c1d767104e5f75bad3e957f2dff82556a2ab49d419304941dce3504b8014a0176d3678969370d50fa4850ff96f02c0c23a7c3b67cb3a968982ffa28cbf60c6a0c1c5b5a4db1a82bf04f12b90ed4e020b06e1aa4c7ffde5bf3f818ea11239a082b7ab0c1bf3df5cb4586c826a89e44cfe2f558f552f3b40174df2f89821cc2b059ebfa06dcef14e52ba75b9579a1e707e63b759dea62e949856ca6c79a96779b53d1915b1c5bc90dff9e50751b7e6ec63ce0b3b2d930046498c628cd213945d4e6534189313d1b67eae4ea32b32e087d153401fdbfcc0a07cec89427ad5630dc78bee18333243f5f3698751435d7ba6323493308a4a7226c30015907d18990c4ebe28f110020b047ed7fb461d832e59fd069baf3871ea5f8a3ee3c738b590b2ed3a2660f035898a1b88430215f8fb11ebc86d807e75607ae4205dd84ec8fbf2719cbf63ed9ba76e127915baeb2a8842910d7058171cf78f01a4e4cf6b83c5f18d896f5193ea7e1278b0216b8e65578af8715c926a76ba0b8b4762aefa4561803dd986ee06e0c59b2709b6130add5de11a4cab38b1c5692049674d99bc2dc2379ad8ec64500db26ccdcb6a6644bf30b6828dd41b36b01653e433dc0952594ac79a6498b5c8bb0e56f5a20fc822f93be61d523efe6e8f9301f8e8c39b27b6c154e683a0d96032eabab22e46e17d842a65d4a775e94a0440c7422642368c4ae989122828657908b27d748c9be6e954825d9d1ca858ff2f63e36666dd23fe52519b1c9670fbbbc4e128ff7dc2800cd58b47d00ceed01bf0be56f9141f9727c37df07c468974b238e91a4501ec1f4fd0975792cfce99aac4154f276208fb4eb1b57468ce85cc5e881c141a077a3215cb0700b73f98a5e60e3e85a6513bada9d64f155650ea982ff2c4c6090935e5ba1a8b6b6538c8017eb95b0805c86cdf985efb8fad9708fb06710f49daa44cf883e66271bc27b42dfebe3d2a2f46ff5aeaa27f26aa14236be5dba9ea70f56f3ee7f8e78a2685100c2e90eba57450b35e5fc1567bcf52081f9a22c4acbe24537269d894647122428985aebd88d703a78f0aeb179c3b53e788a99df42821dcbb49f5668150506f6571bab5961445039637ec323805f3592cc8f4e9e2c539ecb0cde534bd4f5ae77d6b39d6a422f32fcac8c670dc91b61649b6fef1e8d5f571b03b526a70ce47efb1c67b1f49dfd414bc0df64f54d6adb15b7230960ec108c5bceb4c1221b469ae81d2f443326d2f75a091a90e81d9d7ef0d871f8887de1173c111e55adb5bacbb12fa0322cb3c891e85032d5f6a052771088ef45d22eb18af9b622e45c1c27af4e98417f6bf1268b26b4081d1df0546dbbc223e2faf64e2b1d8ef695e3ad5391c4e0a933fcd3053a81f244273c791a27753b5a2d0ac37738660e436d810945ac89fb4870f930989a7474db4af5856d378161588d706908b38b5c4c0b0528daad2288a53ae527416faff96b3220ba786d0d417bf92644970191831ecd879c42749507d44c0661b60c1c21a31e46114127a2ae34d405c3e56b5616eec56cfc5dd1c03b7ae3ec4ae1e84360efa1353737d55bfd9d8cbc7257fcacde33be46aac039930242c86dd31195577daa9db69d86db604831a6ba6470c06b8155b3562694a552c9ec1f3c8eaea029f08d4879fe77beeb7a10936f59afe9d109d1c2d1ac87b0b73c95484047497cfc2dcae16f394e8a2a22d07d1076e9924913611fc72cb96da51d72e218257ae0a045b51499219ad05fb334f413b20faf3f7430a60b1ce6739bad1ac2bf56c2ea16c94539737f9991539ec3752abb1c31a1ab318a9a19e25043f025f15401cf46d5ce067b0427f04f96cbf4771b6daf92c566a377697a2ea6180e3420c3126fc9edf8476f82b9da8d099c12656956519e51588d3958e51152b0231e3c57462a071084e8b7a0d30fb8d3b7b925ada8ee0efcd2a08ef0d28dd3c0529afe32bbe15ef57c79f1d410065207083829e0fe9591db51b4eae580e4f3749642d5af5c560a84bd924d3a2c822b3d6752134689fe978fca6970f90372a552af1653fd5d27d5789ca82d2b8f30b59b5f45908230905401a94464e4590ca9851d36710becc0449863c56294b8ff63fddf3b93bf6e4bd8b4c1fb359ae02989818377aef910ae521a1a6ad56aa1cc2497d264895872755840bd1cee276756fd78719fef766fcddc22e8e59b0a1c71cc7864c0dd2b35b334b15a99667b2dfc6ad9362d12e801a5f081b3ba01f0173a6b48c2a048990e779d29391ea6f3b33f8aaffded7e86ed24eb874927169553dbcd7f2ca727786d1cdae3fabc3db36457e7fde97df4e6b478f2503e157f00b2cfdfe72c9b619453132920164992ee14ee7022c256e79af3048384eef6f3e15362e9c2d4ad41cfa3596ba2315dfa5d7c372cc57d585731b43123625d26a3207ba3c70b9fc1cafbf73ef94045688f83e30942fb39178abf4f0d797fab66792652b36345afae5f97df65e455d73b95cf64ed81b68aa820966bbbc0363e3794d86e5b3aa3803e596e7c3e357b9acca276a72a681be9f67fcd1075b82ae7e3e4bd76804ef6de441c6811caf27f91ffdf749fec439c6207cd2f7c72efb704e9dbf8f2edcebec35fb8a49b55eef0e8eee6c06033eb6fbf42df6b66b23e101f44df73a8ce22cc8e3a32f55410b34196bffb9d885faae3bae4d3f745ba1738ccc9a6388354f829ad531875b0646db303916bcaff949d69d3ea2b37d2a81ab778130faf7f985418d21a99e8be0bd310a4b0a9c21440363885786d8b62f006efe224f502777653bb1205af87bb3e0e12b2753de4512dc6f2ae1ed2de62469266b73f5ea1826e66aeccf1891ecd3be2451b0ea4c19d2d1881b5b4a342d88fde6fc9c689c47291b7cad99653662b153b72c0eb10d7ec5f5c466a93c62122e53716df8dfff2559885c8f64b9c4ebf94225b62b96026cca91ab0836dc1fe0ecf52cafb55a01aaf7781eb96787cb40ddb14012ae378f9fdf88856388dcc87ac5bee9e895d65bd3f9a3f2a35b3987c6377d581b2e0d8bf29279e853c2aec8a81233aea5804f9029cd8768e46853dd4ac11bff361bf2f1ab8b89d7f8efd7fe27279aca69fac8c9a0b1434fee53307f2f48770b4efe67e621bbeaecd979f3ffedcf94d15562a840384183b5ff90380fca6435b693803da39dd921b5d678e44a9a911827f41289955bda46389b10d931cc8e4ac62c2134d4811df556aa03ca5f3234bc2432a8c115a380aec1d5c23281268541ab129567fcdf0e56f4cfe9c5693fde446fd3e23c9feda5b380441890212bf94615a39dd51a479b82a7eb7f25a6632fde6d9a8187dc3c7ee5a05f3b247a1574d0e9f00b736703ad9bf58e0e4c409f93ef441321ae316ce1ded6421b49cd331fc51d6f628886e2386709f9580c887c80c45ecfad1b1dd86b7be8402c0d252281127b2850b4c85c6f5cb1a0d77e7458fde9a7b695c70b69f9dd5c610f44ed8ad0a0eb3f76a9f13a0d6b051c105b1012957dcd44895c1ef82f4bf3116bf9f759af7ec25c425ab3bc23fbbe6ac73ee81e03e98a0706224659e6d1edd295b9c9bc0ad90bed09d5620933671a668c2236cc8df24262839547ef03ec42955b91ba0cb52b290bba9c3798d21feb5579b4f0a368dfd70964bd9f5d848ba4259f0c1eb2168c4807ee29f8be5abc8a8dafb125d91e774af206625d1f5aa74a61272bddc8fc8a20562dc2d5ad105bafb9e153776fe64b4da5ec760c4c99b2db3fdf8a7283abecbfa8bfaec1eb478b60e900dbd7dea0f7a645358be7b97550cc6a014365bc94ca3768e4f35e1c645dee2e900d9e0fca30005e2cbf917fc105975c7349d5d51397346f3e43a9ce8bcd5d8bb7e72f9f70225f743d2bdeb5a6b068d7ca55b60822679df81aefb90f9d2ef0d1a1022b0530f43695a533e0e712f589429a6b2c1e2b58608456da5dbc9692105fc6e3e6f8c5265b5ee924a0d0e9bf1e558a2215f9f844e6f554ebfad52d47ed44253152c5f1d3de49ec137bf6a09e9d39147c469d6f5dfca5c3313ec284989169835c0945180b5ffbe4eab4db553bcefcc77372522a74089f6ece7c8073d57529028116fea830879dc99f54d2d68c37a25c7daab381ba38590ae913351cace2200003698692f307148adb69b5841c3e58ab081dfa99afab475aae3e60b56358758fc2a682cd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
