<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4cf7a00c6bb8dc6275e50aac423bd5209810749faee013d09162715faf0d64e306a9d304fd13fa08da3231814ac7cede42ba9552d7e82c1139fe01515a093e29af10268812ab493d556a84180885b768c50be57aa5975563f1f4323e74b75afad0129b8af215228ea5db88991c969857438e5ffa7719ca6b415b28685ed8c3f671553333411ce8b97ecb6a8af024dc2c84fce1a80574302615813fbb59a4c07213c21fd6340ed29a9ce7d6d15590286aaa4e2e54c45a2f18a4db658e5ccdb96eb788a3058567d43d671d3e55240f9ac25027488839d003ecb798561c6fbb99f7e77d2f3aaa1ff551df7aa210a90f2ad41eb85272d5a8a2bd08bb3d1aece92a31c87a90d04e3a84ceeba36e06762c2b80bdca2013799b1fb0017c21257363ce51addeb89183b3f8b21646ab8c1f4ffb0e32e5ff029d643e76c753134e72c35a91c8b3c6cb1ad8df76f202dab25a6693ad13531dfd650ad1d2bd642be80c4de5d67bf8125ceaaa854ca453c81ddef9b004d50587d5381a835395299e081a3159a6e90899db6d861b2913f2dd52e2af4aad53d287e8db37ba71d2ad4dab6f172a3c2f8a421e64977046b909d1b439b0d76fd6dd47b67ca8437065ea0592da3032e562d41705f0e4c1553528a75480210de84c92a3cad76571eccc0981531460e8e0cab7622de21359e75fa416c5d3ce84d2094e0aee39cc126c4d1851606bb5391ebfdb997535ca72054803669912f15e5c815728d8700e4eda0780d125613601a588f3acbb3e990252a19f76c33ef85aee89cbc5f03bc8a361ff519754a48ec98e7f5cfb248439fd50d7cd2b99cb240a24dfba1e4acf9994042d1b37b3077122054db573a5ef54201e3aabdd7342ea0f9ece03535ee11368cb6ce2437f3b7b603bbca3ba4698de274587a780b082c30497cd0859d45f053d74e1297c5e3d7973564b22d52a02f8cb9c589f271a50b655d60a1623832d66075fb102acd42879c188e97986f3b8610452d6bb557b3909aad9de4e6e54c096173670670c6918cc650b12fae223cf0428434fcf6979a47930615e1ee0c4b217ae33312487f4f91838010a289bbd562a7a01545b01c4a8a54926d3e2cd20433e136d447e6389ad53219d7abd7fa9c2cc47dc84852ebf40d7fcde1c020241d58e026e575de596e209c14229b8f088a06a8eb4c1b748c333a22a2b37c83949570f5120fd778990815d11484b0e11a7c503efa6c0c432e8c52bb00b17d8ebb0363a6c1060254051ca31d89418235400e6fcaffdde3f3c77433968a25a5e00da2194fa577dc9fb33b0d8d9b21828c2c11208e46af30966890696a7e9a4299b7fe3846ce2c641c88e6ad1f1d411da2a2b55c5883bbdc619a8cdab99810b4e00aa55e6c374cee34add3cbc130f2f5d8c860ad9d5e11c3d6901f2cd17a08f1c59d802f4ca52b07959c9cc16e198f129e4315285b2b4c397fe3ff70ccf3740334c7489786e01e101cf5aabf81aa407948aa70b0904169a25462733428eff2ee2adced334462fc5c19a1adaaa3bcb8f2ef7f7a9a4534c290315c25312e195688559f1169074b2f93e7d5d2f1fba97a4aaa78a0b858ac2af06b714294c67d6c46d9b3b6b711dc36bcd53cc662b1716658760d6e6e1424a124a5739262f918b43e03299a6ea22b8cb9b91f6f6eef5060673e294a46f6b30a38ffb7034552689ae5a405ff0602ffee9eb5c5d80d2781468d233bc1894d920632912d7e6562e04e66e47432dc42e81d07621b9c548985644cdd7c0398bcfa01ad98680b760de5a6f287ac462b94a237273f1d9a17528ef56493acad1f8e93456aca849c3119c2102ee38a2d8250e2062423a96fc5844fe938a5c292f9e24336d0d10724fb29ca4bf36f665a28a7a207e4d2bed73676e2e6f260a5ec89baa437ea91fbe463db92f1179d232ff71c16948d238f9c1276fd394c856edd1b977b7bf5bb8fdd2e7ce6daa26dcff1bb6840f6efb1ff7e004b6905a5868600b1bb8aa6cb35391225fcb33f5ce25dad5d2303109af4b7f36c3e2dc7dfede2a4b3304757e8ba9899f3d3c8498db210f322a1d989e4f3740e6a42c5e4cfeb870360a422f0db412348bec0f523eeb216a527ed7dd92fc496c97844ea96e9a4d6c7265c0cec4f3907a37eb5ce0a6451fc42e86715a9cfe87ceba6b47f33c8b6442709b28f90325417be76604aa2997e6e611f543292d2df81dad329ab085605e5b7ee398f2a83b9cbfa293084e9b6973c2e9ddcf4bfbc9059da45dfe6990b2f78ce5aee950c959d41abe822535daa4b01fb46218179aed53c31eeee0a54c9a3328eed6154b2a8f260ceaa75688227250a287aeb45b7ae35deb5fe07fc6774cf692dae4fa713d9843136a69be6644684c0edacb514c335b0f1f6ca72e8fc696d71e8a19c34b6bf3b2ee8fa66d4c9a797cb9efd1398646ea133d8fa599d0b1be832b9627f99ce835101d7625be91d0e1caa4d7467bdcdb11428428dade7946393b0f393dccf0c03043d9961c78e90a6d9a00f8a0e5456e0d821266bf869cf0dbe0a97e3803350de5cddd6d777c7657673fcff669b46333feeb5fa74f4335bbeeee6abab8865ae710194374da3bf19ee41c8787e6f6a6cead7c434a39eeeb9311f652553ff1d83c63dc75c97bbeeb39b13762f17365f0ea312fd5e3c0727e887d91ecd3a36b6292f727862a7c783375cf5db1436ccefa7f4744195d78a1314e0089abcea198d34fe37841030dc0df4ccd264a591c08cceebf8571819c73b688eea6676f350868bfafc9f618a0aeecbdae383309007a8916afce4917b8790bedb97286db8a644c28a7a3c84e91eb517dc6ad27c01ba5dd4859c65c550c12149bd5e57712852aca5a7b2abb9055944d86b1b6b9a735273a757c9916ed80ef1e529d8b8b7fdc34682bc68f0544ca9a71a81e6404840072336472a23ee4f26f1860b28a87b1657abbf864ec17bf641877abddc67de42de5469a62eb86141c2e5aa7a1fb7b8e861cca61ab72ad049313f727066b1c5f4b2b155f45af65e2d0e7ce0d1f2519474113bd9293b3211428db6d90dc3d4e2bd127259ceb3c1415da5e3262ad26a97e4cc916ea38644e2872b8dede68b8e4aaabb8c02b5cbee672b2bc6aaeca196c60011ac57297ec9dc60b8f697e1e01d84a2ffe86a39a74fa59ff485c9184fba4de5677aa1e6504d18b04c210c351be77aad76073e3a0edba82cef9b8eef6e8939b2a9840cd670ade24af04caae35465cad0c00f31caff1f394315562a354015781912bbd348f5c645403a2784236ebe8a3dca8a24908281cc496530e00f19422ff4e81107b98fc87560f13f594a99b0a372f935970482eee9c3b11ec297b5e81dd816b98c03141970a57ae8f7ceae2489b38fe509c13d131c52b052603b1b2ee56fbd56c20eaff5cf4dace2aa7539a7958367f8dce32a831ea621590bc9c08fd321550406583948efda3a0b3eaec8c7965902d74fe9e875212b76179a67dac23a119fa0519ac8b81269a89a23aee4570bcf9cd8d2f581a17d9f54d5f2e8a237decd2dacfdc8d58166fd46b34c50820179e89e38f9b0160a4b08cc1c7e8d2d1acc3bb129dbf2884e56f75c39e1b16310d666e3f48cc95ac7991e10a07c25dfd730e34794170b4e0ae2d2261172b5f2ef98895af99fb191acffd3ff92068e294f31af4f5d2bde318c7c21b8bd7b5e577c55d73975815438176ab8a2915f5a525341a3c07ded1c83e7cecb54cec96823d718a13da0d24a672c7df5d1dd14d3be9756dd47fca32074354f95787b36537ee8d4ec7f5954cc019c582775bfd6b6a223b947726e8d24562ea035d12a82877cdaf8bda2be934e4f8ad26a483f8e502c654853c73e46675b6b9951a02fc769fd9e705cc3014568561ae3f231901e219ba2b7cc53f93929b2c67f13432360d975ed001181511f2bfcf2d39e518cad78b03883ae15de75c5d915e483b62b9ca51854d03dce2884de4660b0030c56b7a89ebe3f8feb271bc6040f750e37b482db3c1a8966a083e56f9ea72487e9552ed69528814630d7756609ceac0532f2f04f43fbd699e6d8530c2d8377bbe493955b97ac7e57cdbfea1e26adb76c06b61f7b3b85cd5f96a7676fcb80abfbe5f5155cd2075dbb850505ed995e4de84ea07c18cb6feb14c4d916c127c8f28dbbea92aa252a84a73087ebf7c96fd783e0517592725a95f4f00ab1495eeae91cc753b4b4f699aa9411fd54a09c61c1fda60b94304a7dd4186e54e1523f1496cb9756a22cb22afe995accb0aa95b951d191292713a3fb48e1c78477e61cc7e3fbe411ac6d04212718d824b8048cf4c0a24142b92a12616a3df399fb8b4407ae346ee3c00652f3c2701001e58e230ed38dfccba73f96dfd3642c11034bb56b5fd34521929f569b137382af07314ff1c25319b619c67b0436896a06eda113a952c46f6f99ad2928a260b02a99c9ffb5d18da26ec8f22f5a0ef7064cef6cc0b2aace3687fd215ea3730f4cd64d58d575dacacb3a918eb6e020ad8c8627bf7c3b7784d8d3cffb625c3a938634bddc7f3a9536df4d6374adea1330e469fe74b35673b3ca527b16b594ca50b43fd9af0ab25b57a88332446f313fff5e59287cd73c89a8304a0049ba50a7d1bdc8eb74d736a6ad2c3201e064bf58ed38455079840e5df4c58f6edabd6fd891b9753572cfd262d69a1e067b1492a62df23b12ee4da2ab923b70622575f8b0a8840f6ab9e5ec1e0a4d9fbed09c11d8a506f20803b65bf4a70b34198689db68765046f7d95aa4bc60cf837ca998d325a67a9169583a60352c3d6e0f4b00b88366533886d2df874671b23e04b1c6e4718c460d24c9ee101a2bec04fa15e8160b16541d5d4ca9287c39399b5108ee44344d3bb69ffbe87e174e89876a8d379c482260b2a357d71a56a17da52d2a4c3e6adeff2ccdb144df59a8102ac8c0df0a356234ad84656062b8b7510eacbc122bc624f3d3e9175c5fdd96a31339db409967fa456d83be1fb8fb4c37caaff4af9ab3a058bffdb539dae0533a912d10a5e9bd64bcabda3e25fb4e5d9d761a20fcfdbb8d68febdd399ccf7affca8eba6196ccf5af3a2f40f42b73bcbbbc1fe160bcb920c8e6f8e2b31818d979d9b90d0b25f8f1fe9accf3fcc86409b2853db1ce17b0317e8e7ebfbeb68e65f71013db866310bb6c96291ceb86d5e3efe17670cca945ab9c366f9cfafa23c8614aad7858721da4cc4df8d7be22171bd2c4a92a55330ede702e04c9423786ff8f396d8b29fb3e2d1fa64af4fef157158ea4d588e6aca7afb4fa2bffab904fa174842dc89c79a90f9b02f04f23945499e52c54b327a0d244ec2d46702379a0009bbdfbda62ed1e84bd7b363b938a8ba5ed80625dd029f3f49dc42354f284c57b41edc31a775be53790eedc7d46c1ec7eb66f4a5b920cdd6aaa45f086b0d291cd2d77d26f35e3c12b62fc7365e142db4b3fc5635db63a34e1c583cfb4ddfb912c60d03f33bcab1a90755feef61828e93dee76a5a488531544e59b20ae56d1041dd44ae50b22786d980308c6a5fbaf1664dc545b24550fe2787219b7d3723b5acdd27f1ffa4f0ba02c1d21dd923b6e6485f8ebd170e573ad017a1a04d09e921478698938dac7904cbd6bddd0965095470229db4a3053bd097ec78588e5bacec11f5cb14b04d9a03929598b46b008dfdb9dfff58179eebc89a76f7b0ec29c9d23cdfdc857842516377ca1b50f00928f535a80f4eae0765702bfc3f1d0c28d5f65ee98e43e44fb254a3d8362ea0d8c75d0b6047ff8a7ecb9545721a1ccbbff5ec52cda1279ff103d09958398c1a292fb2ac8da9f6647b2afb93defb95424d9e0bc976f5babc25a694388179625ee58bf45cce7831cd9a3b60985a5139f1b144e442b68467e4a8089cfb0e095803a0ec36a29221c99d2c48706b3d90fbf956a8ed3e25078ff0c5dddfc66fcfcfd1802171097016e40f71643e7bcd84cef95443218cdcc819631ef518b150bbea468fe4ecf5786aacdd5ecf5c6c4ab6273d943203c0cbde53418967f3ee577118509bdb85a3048078a48cc22e2925719ad081c89bc892e951df52634e5d74259ce0bafb37b3a578691c51f2393c250e3c32936c9f0711b2f7d5a8b795bb477a995883d313c8605e844e6060c0fdefb192b7369adbeb887dc61e65975a74db8e059cac1ea41cf9e65e4b326a7bbbe90169d69f38bc8177d91b76f111d063eed1b509d88525450dc331622aa64f49e293c1b89480de6c5633d390f2e35725d5aff70c92b799387830bc1ba38f7067867c40bb1b971df3bdd0a557e78060dfa1fcd6486bb5f8e020e16940f8b64b19050cbb56ea15edb94d87a578d2e5fa13c0628ecd4fa7b82b719335ef7b8fdcf6537b2ca24595bc14bbf59af2f2a36bd2341571b870c68b34149a45d357e7cc6b23206b126f95bf34e2787f2ecef73c6d571269f74b068508435f03310f6520bbd9af81885c5ef890157867cf57b6df81123e60e27693510e9015cd38f909501566a3506f83ba87c205c5329fb214fa54185347714cf0ff2a94b7cdf3b9a3860554626838e0a26a6cc75a45d9749628930ec5b4fe98c1de751fbf8aad8a83e7f8b1330b20c58f022bbe5f99d1be7fdad8a91a14c07c18d2d8e66168ff46ac9bf0ae4f433427b4d96a15d87e3219159637aea3efe2566b862962228da2b5b89b62ec5f9945fa58796cc46bb6180552ba6cd495a09ae94be166cedb77e1a7967ec0a2d951ef850c7af72763a8ee233bcae3176e65cec50d7615ff3daf202935a8e104ce2856623ed43ab07e04f06e9b612fb04db3487fdbc0b7f16d2b40e9c355d11f6fd99380687eb568103b309e0b14fd411ab6c9303cde4d229a5c59fe533b3cdba00664d6dad36fd3cd2cbe0ea1b5f28fb0e1bb561526bc5296d6fa00dfcaa7cb91be25f63f99e1ef530165d6dc2da63444bc0a7151a4506a266b43ace8e61d105445abe52c7117f2bb38098c3fa4347ab10a6f087534056536b3ed64aa6b68dfd1fcc9e2841973d5bd30e586775b29d66aa83e98a10b40ef096fa5d3aeaac59d82eab74ec85f38b8dc39d47ccbba1be4a798a58a4314ee98595e8f3f72f9c0b84ad52019631e636d7bab06ebf50347d24945338a8cdb595972b231f7efed88f08d1441c67486ca2efbf716c534a30f20f14eed35294544e0b34d2a7cfe33a27cc9be2e09b166137a964968e703bc1fc1f7f4e73bdb3addb51c6a6f98c39eb19c6dd684fbcb0a94001d489de9cee88e89ebe4203e2abba95cb31f0e24d6e9facccaead72e7661f588276bd27da8b3e1b16a65cda86dd3bc2770843645dd65be30c6d0b18125e5187227da7f1f2afeaa4398a2cb6936d0a21ebd24874d20c98f44480f9394de59b5b2fabd671f20f08b69a31675f7df415bd9e1ca280d08ff100706d453b9cd62975129079c6cc32638c865acf4fdb38f7c87a50b28a14b81d7e87e75f6a4659b11f1d4b7a2f372778c2ec01e9c9d9f3e74a8fa78e1d05f1154c1b8bb1eab27c7c976e545deb64d64f14d8fcf1e2c9844ac65879dbb90e6888e78c4969c517e63c74d976f2415c4c7e167261771c86583c01ea89a46d04297fb59714e20a633adee558f8c6f7bc762a502f5913e5a44c4a34d76ae12eb40d801ca56ff0ffd2ae621d7f73bce2fe5c23248ce59999c197c0a92a91ceafa2669be1a10b77613f3c8b65066a32fdf860cd8ff82763a0e38d1a6b527cf2b93d0a88f60c0b4b6b3c999c544d28445a4bb654fa2d6cd1184aeef109a812d7fdf32d6cd56085c594ef66a8d916f60cd91615e64c22365ea4692c54c7be5b0d7bce245fe63f0f87385453cb9f09da1a83c7cf2766fb7d87ce0b6e6655b3fab60fd9be6599f25ef7064a7ba041af0aececbfe4fcd9232276c056ced4a83074ecc7c61a0f3280fa3d22bdfa2848830396a9cda64ebed1c6864b72d3ba76e169aefeabbb953357d95d574fa3efa092b30a66e5e89d68e2851071527c70d0241ee18a83d154d3a9360b9c8bfb9a054adf729c527386cc5108f7f2aaabef58a672b047d4e6f98cc842f435c49c77c1da3e02ef349fd5edee2771aa01c6547d03b72143fb56fcb77d58eb5e052daee2a0f9f459e3e03fec6926ba0763ff1f8da732ebdd3fa041391e57d94fbf0478fbc4513c07fd56a66d31add3accbb5f53888a8b40ec1e2508f4606a12c08f9e2f5af9d0d4038931d3c23857b8f7212bb506357afb71755a90dc567ae9e5617d8490e165a801e6213e34b479a1d36db54790b5ade517e6acf90213ce21c2b9c1326f7f1c83330497ac50b4edd051357703c8e5abf3ffb4b6a322637b4bb9aef1c211fdfedd16f4eb1fdb7b5d355c5833c0e049c6546ff96d7a2bb3f5ec18a69ec4f99f3883412e75250424c72b9dde1c7922a3b1ce852d43585d7a4e68d5dd009789d95d02f9ed8c6186a1fdacf8b91b6e2d62993906f07ed5242fa10bb6f2dd3a1f093373aa08e6ce9f59ab93c0a982dec03958b909df7c68f84fb74b945315142750f5b9c41930a02a26ac35e95b9eff5056eeb29fe82d688aa2a9a60024e04be3d6e58417a99846df758f76dc3dfb26d480e6fe38765c85c12b489a113a14c2f8da87868699bb8b446a8a1ada7c6112f54d55da81f4e571651d5698336622abd4ac5805b8c0776958213b89b1beabc580c488add667821127e7c1457a5da82d18b44c42bace3b1064b7762e0e85d71a524f6662d58170370f050aaf920c7d93e2ff7cac60d5035b77734d0838f90df8ba34712b56a01f1aadd8a9ab1fb00cdb0a4b03806f9d49a09cc7831a4a5dcb5bd82f4c1f84624e0b11daa61c99a8b5d2e929cc47fac38b749f15fe7faf41446ca3d5a8d51fd3f0eb830e4324c99cb20174a472b4b0fba4429aba1c2312ed23dd221c6963773cb0af7c87152e0798d0279321f24a61630ae7c5cee42631dba24df2879f5ca4d5e2c823c32dfdcbef1b1c62da50c8037dd3012bbb9e6a6d9d1fc7a463c47559000ee391ddfbb40cf47364d0141a103e3aa9b189de3365c376de9c0d234f43a1d9f70b2d73bb8e0f8b0dd648f2c84a68bc1beaa73f6edd7334374da071631da2a7540df6ffac16ee75945f294a7b372232ff733597a3bff576b9d2f1f0ce9b23daabc0d2b7ece6974d5e1537edcb71dbf3283137528a443a91122edfe1563ca103ee4fb578d8036033d1ab4fde1162c79a9297c46447b09acaf854a6a13a34eac5dd4c596f7721588fff246855d944afff5727de0b4bb2eac431ea9b4171acdab6c04958ae0ec8c7323c65d687fadf4713092a4465ddd5d5635d33ade1b9032009706f37b985d741324375e8824279fccc6909047ec72acf84eafcda1dd85d23cdb99cd7a81f74d711d7a43f9edf242607620796c5246a85ff2ccf2d501d6b07475ea7821697772db2e6fccb88fa75a6e2f5bb4932f8f2e27f4ccc35dbe8b68754ad7af7804ec25798ad6281e563ca6758b56b207cd626729184fe80c1a9956584197ca0a364ce28dbcaaf50c9dcb3f1c329cb695efd3735e51414777f4d860da81f6388888bff6ed4a9f7351c7ac22e59bac4d5f3e5823d8bbc89a0d056d2632a350db7da92557de9ab9054ac1d2332ba239d322bb9e1cbb0fbeaca7443bd5e2bc031f6dddd7ce2c6f671bc3672718aa52a4eb0fabf76a3bfd06e83a82e47e20cd9fb753691d183e20accce0c8d3f74a49b09f90c30b95a685bfd30eeab488e32f108519584b8199973b1343ef096b21e9b616ba328182aef2b0767554c86d5c5824565e3849b0d93a57164497d3cdcee55e08849fb6d493051e4ec8912dcce2898f5e50b10fbfd3c61101247a3a1909aae5dff721c878365e7dfacb1566b57f26e7e7fd3291a2e4e296b6f636e0e879e4c7a024e864cea5cac48390d56b1a235538c2f79fc83ac905546553d4e236f519754139074dbf78a8771d45810c546ae9bbb1207d2ca7eedd816977d2652ad74ae248ec3a33c10d5499f40da0b42c72f550c151fd05d5d872959b672ce1361c0e65c28fb472e83ef1502b4fa9a6ae43b161f576c8af4638d5ac7f5a984d8d86f6e9452a490223951e48037182f5a1586526275720dbf8ca1999754483db53dd6aeb113d220d6366109f63bfd824f4a1ebd025012849704b294915093476d043d238f0cfe1e421ebb72d8a74d0ba77085676346532e1f18193a1c4f5f8315fbdece6da5e7e9d53f7ddddf41a19cd352a620d95671478031a3a17fdcb7ea3e5de77d6d7edd4ada0d16d582405b984192472567f55ce25467d5633eb353747bbb51d147b4039d519076ea9168d9bd2802369dcf1497b6730e3b0086a3d4f8071b85083bc44d383b87d1ad0457e889c02e902fcd3239f6f69884e7c4db6f8b11b5edabfc8169fdcc3a1166e7613ceb59acc9588098c0aca07c6bb542e65b2c901512d5766b74168c9bb83ff72d115f63ddd63d500d702fb33d5f2831873209f4b895eb7cab9362aed004ac609cd5fcdc81a92ca1fee4dcedd449b13184ecc5bd24eca5015e1df57c0ef1c9acf6a9b6ae6b5c5d922dea2d593b8c57de23874909f126d15e7972a7c6fdf89f488734af3835c69a6debad7bb0f0cc34450d2a65a03a26e763286776eb32a0202dcdfe1362fbe29d4043ed65de7c2f23ce76964e01b0ac003864e5fcd108b082717f70485475f5f8d419913db26cd6dd8e81d758b52bba6aa1135acc732429528a967883cedf1c6ff107c3390eb3d201a36eefa791521f55199faba46dd2fb23c7371629cf69927176fc03056f4fae3f3ac0d5e57038791790ba931802d6c6ff289df9805ec5cf74d14ed04f2b5c1a620e00dd741dc7aeb1c3ae34d5910d4bcb6be42955a09630a9f5a6f938f95a1235a8aa8adb7d00810aac24635d77de45d17d7989a4ead4d521e033f9e9f7d5fe874058d49d1ccfa3a57619664ed8ffedd1b5af2a9f6d78b1b937b405eb13304affff1457ff154986553f01048dfa23b23430276ae5cd3ec31943ef2bbe34748ee23922d944a0bc0867f556969309c4369511cd7508b1ea1fe9d9b74eac94b2f495cdb635ad51964869869fd581f7e27191a0bc5a819bdcda0bf487c955ef92a6283f78b8bcb174de516a34e1cf5fc660157d6ff2efe70906a4eb54af487bff0411aa755de22562bebb102a0a8d7a51201f42f061b65334d721af75f83c585e087ce496f756978f56117f7ef056feac114c94473fcac69deffda7a3074bf229f98338aae4a9858b811fbc784ad67ab3c9b0757f48b8f64144217fc408fedcd0173a9fa44deb3e1f71e002fb895da1a715d7adff8d9a115c86af8dacc894f8079eba2a8bd17d2319de3d385d93af0f6d0162eab633ab45bdb5c9d62ddb644fa35dfb93f71a8ca5cffbb5285c423c8d7dab84eaff7dd09af1630b057472685af67e3b675492e05d72bd5787da52c0d014018f755a44a22cd696cb2b2e185ddd73c3427bb4e18f906c4dd4282e7eccc5e418b4b9b6503054c92238bdbeb9ce6a5373de4ca711e026516ad932275f1cc3b7539800117efad78f9cefe22baf44d3cb566f96a878dbc09fcb82b879afd0de8b1d9401a2c577a1ae8873044953f612451498cad81edc07e8f7c354121adafce304802fadbf02f98ae345bdbddc371bad30f939689e8f665946067712d64230601dffb4673de5e75a4ff4c2ad78e0d4f365e48b01067b2e82883648902ad165249cdef48a2602a91d5e4cc257f735657162bceeca35c83aa6ce293f0eb924a87d82a52e1b3e3112c74220ca00356f45f02aa472da6619890b6dde543c9699a9899feb1f9e331179ea1fcec2c3fe30a21acdc831ab1b1e2d61bd33df09c7532e306213c8632e24e561aacd7ce10afd37df72a7bdab290c984372e2b6cad9253c4ff989420ac360e31f68051bd9813a4f414eda6d2ef83b3ff665c4842d5da47cc665ef929cd6f292356e8af4cb5ec49332a9629d7cb61ef176d91f5d2e62c811739ab5646823c035188c12146cdf89a41158677891a813bbe921c4c99e80293dc4c2b2ddfff9c6f9d70fe1f9360d428ecc7470e04dc7dff21e7a8bb2b0cf8a635caa006fd487147215d3c3ee2cb379b05a1624d9a1e692442a0243afeb64e5cec906127cbb889e9a542d0a4fe9f1dbddf150044393eaa47b6adb61a4b7b616b81c6de434985cef08c94088f1a8f20c18cbab572110e88d0f8f081c1001978fd5f18a8f2581701bf54b77e3943138db10737585baa46a13afe377d427f60fb3f8741e0e28b72b05a05108cbc1d45065caae671a0df07660fc2ea3916feb8eaad973605fad6661296dade7bcd5d4c73836e815afac1871b69f5ff88cbc870b1303b85daabd2af0d3747bd55e350259d3e002bd9699b411dc3e4bb186a9a15057315e6e84876797b5f0247e959327673d91a37991696b544591720aa6f7f54191bc004b6ddca494b861afab2e1866a624e5623e0dea63634f45cc6618666057f2df4c6a4e902eecbe6ca5b5395aaedb8cdc1d87bf1cc1a63cc6d1532023bd2ea73f7dc999b325440ea234b3630ce51e2c3e1c4e941b5f361e057079818bee464a9c1f3d8f984ebf09204de5c509a8a4cd27498635c6b39aecbb45d69db8dc6c45eaed5476323c7a9d80a778e0c175623c48c5321987b4bf6f08092c43ce157bc32b2fa50f43b3300f2df8852f7713c611c09eceef5908e7312b9e5c639636e50960597c542a2b0f16b2a80aa95f34dbe250e11e6562f919b36a6ce8b80f89614ac586b68de529033f6a48f8c86926ac0b3f1bb4dbc1983efc04090b7b5f7b453ea61ede07c95afbca918279e0e119b1d17ca4feeb317583c335d856227a881a3257e4d57bdbaddd652d19c4d55936fbf18ccbc8a285d4f190d6030df5d680097d620cce8332d00149bed8643a348a2d01ca8cc859d7475a476f6820a5ae4652f2bfb6be190c8ee2bf55fa6ea0892e876f333558b74a6bbf6bf548a8dfebb9c2d9f0208816fdef483cb13867dfd98eb5c66f50387a6e8f2cdacfc180a9b1d305cc7295e57dc3ad2741430547e2fafdd3e7dc7e5904e6d42707a65ff092829ce2bfd313dd7fc5397834390d55a25d0e1b0cb56eae82a9b7c73831284b355d852c8de7eae1fb582b2b1c05748c505b4d365fd1a3ee85eac584a93e093d8eaa4f33f26b7df39c73fd9dde16f588ddb57212c06f9ec89b5c7982dea34085b977c389d18f180871998ea9451d08c4c78c5bff4f14e846232dfb070a0f42ab6772694d5f826a7a1b6729cb5487e1c4022418e163c28c1e5452913c1c8bfe16cc20f729d87ea44f9f17f911c4e0273abdaaa6b97dd264e1c74752a553e63999fdb578451a52b2d105c0bae2d3cb01a0d07beb220be3bfd10812982af0359a4a50de5c1e6d1e9fd5cc7ef4b8928e6416693f47ee40196d8c411f3839b4e76a7c4967763673e427144f3a244f82c8b1f0e8c6f54fc8b9575131ec16a702d332dccbb23e8101c6c3f61c63d10c0c10c62b825d33a13485cb526dd715d971d85acc263ed9cde657bc44a8dcebb0713c09723e476918987d8a1f91c05f238eaa7a1881db1aa1fe1c9fdf8bee468c1c98e4d0b3826069c02ad0317220c1d6f8dcc1121a5838a9caaf3799e386c9bd0b1cb54cdd9074351eab8e5761b93dbee8f685b85fa6fafff93e7245e764f4089b1629cf01acb6433268f3ba52c53bf74f7c8b323258cbec3bfdcb6db39ce5f1d0dd068770e9a630ca98af947d79d0a7ae91471c14d36eafdc9ecb5d2919b8ad4d2cbbea15292080fd2d90cf8e2fd24bc9db510e431f4d2bf34fe9e2360c0a53f4c0e9460abc9a8adab58bb92f380d98f9bf12e2ff6f2ca185eed135effa6ecc29ca4fe9d836cd37417d0a02a6e4e7590cc7ba194886010ac95a253cb518ab9a9903dfd90a81923fc95ef797f633fabaa25d51a3632eb09bb4e62a92d7e965bd9d49cfe976d682c27097569fa081b70c4a5df89b4bc7e24e42072b4e3b3d23419be8e294e608aab0dd5648f35e7cdddb6877e274ab02f396fd1364055ecb291f1a1640f6c2cff59f2d308e4c29ed794cbd797012537b16bdfca37e5013d198277a975d664a09b36cdc4b0c4ba2d94c2325b3f33bf59eb6f0e7dc698b37273d429638fe571cf5dba2f342b257aeb506f58b37bf8ce1634457b005fae7d8c1c959128d5fc97c243a4be8715e691d5ff4aadeb472c74236ab524059135fc63ec6c85974ff6f3a928cbf410593cca97e237c6207f976c7a54b96cf25928d0b6a0a3f8858ee1067df0e4cf2130aacc1feb69e778c4646fb40b491b1c5437c91b165bf822df44a59cd5ae28c72778b1b58c205be5922a0c182102bcd5a453968c05289fdaaa0889ad220c494f5720292731d92cd826684db020419b8c9166c1af75a394521f8b43c867f11ba412bffc373a4e2bffca8f2f06d20cb329f97d2647be9867f15132be1154a533a5b5606cd1747670e083dfc001418b1fd93b26d83388f733b77034d66d2f0b76a5a7ff8c64023735d9d383e919f07953131107edbd6dc49e3fc7ce34fccf244ee98bca8432319ff3ad2463dae88d84942519a84e545ee8c64be89b041fadb59148ef05f104286cf6479eaa1cd91c9b22e982381f56458eeb247359d03200ba69846ccc0671ab1ba5ccbac15f8339337b30342b658bb2bdf6caf5f297a27f9ca9bf8805b0e7d1f341d463984df5389822fd5ceafe97bbbaad7e40e77854fe1644550a22478b8006fa37f4b8a78f80134dc028b0550aa1e3fcdf82637cb439921a64691621b13627a682825fc71d0a29560eba95adc870c745a793b01ba195d9cbc18651b319a86172edd6f269de7133f6b05ad484ebdd30278aae33dd4fe333522ec364133c13a13147eb4f959046d27343c988de862bb37596d6e4a3b14413c4d8c14e661fd77d4f013e5d0ffad027b323899602ab2b8fe91603fac4378efdb05335ef67e4b8afd937a936aefcd82db17c779fad8b39778f86e9e60cd30498cefee8f065b6afd1d734adcf67f4b2a49e25894a771bfd2fd89cdb2436046c9b59536b9129361930164a3797fafb61ee51e082d0dd6fc4b5fcd2adf5d46e3032b6df255604fdc6e4263dc6770f8638d4cf4aab1e9f018a55f77523ee6bcbb4a2fd462cb3a16af1c892de12d0b90956f94c8f610ae8c329524a15f019f03e4d6301c36035669fc09033d07c330882a1784b7041d80447fc74c752fa64653bcb4f18da437fde6700e1fd1c9755439d9ebd2b93c898876e1cdb5dc17234ce606e7234544a849dc6611e5229f3f8e2f9aca6664a821caa8232a86ef8cbdc1e46b65d4dec6a70fa7f97a211383eacf76d69c55be46705aa6979b340f4a8a1bb02a813bb9d6efbf7b74a9a9c3d5afa8445705c13b7c4221a7bce1482d2785e7b21be7015561fb5ca0bb42da0b79fe3026347339515d064e52f441b1b8ed7774947cc6bd619a978a84714e7c61b4079a7d9c7a884e5ba9751e02d557b219ea7a47b0c5d129d4ec0480ca36135f8ab8e1cbefdd8290e890ddedf1b132e094e0585a02aeb24e94473fadaf72dc61fec16e005bab3a356d00ee926851b34777708411e301787323852a9cf45cf4d5838188c3777f7b1d46f2161d493af94afc1f3583b91d0be4fe8810d264e1cfdb44f3c423d7bcc4f1344e69b3e6f0021f3b025c2583a682cb7f2bb314a6c5e63790eaf3ab563b5bfa6184295f6a93308930af18b5df97d3d3ee5058282f56a1f2d56278a88f7553bed711eb5e8f57eb392b76f5eaadcd6ca9ebfee41cb330ad4879ce6bc98572c04748a7420a62e32fffd681a83080b202992e6ec6037e846fcada3929ca7c7e345e84821464cdb5208964d95aa309557d606349bd85aeae06953e59364d47be4a0682f08fc0552a2c71dd041db9b413eb700b7505054b0aa9188a6cee74ea517a1968ec27120b5955e3a105d7d2cbdc2220d1a8194275ca6c9a5d7ca2738e6edb4625edb02d89f60a2310a290ea2411daf6a594dae3278b58e9d6f4bd1f9058d9f4a70dc7a706606800c436c5c614affe443a4cf2ac1800bb1fd6be7ae1c1d165a4e9549217581d3fb1275529885e24acac225b674ced9ac2966f570b7f5ab66880849c852cac7d59914b1521dbe23dbc593eda3e570c88d86e4648245a0bd25492621aefd356e0f2affb64816e9e1cdfbc82ef5cb062f8c0f3bd1f81509a8775b6879165054bd48439ef5f27d170343c9ab61f677da34d0757647a7a12f0552469274050d2c335ab4569f6ea99ce9cd07c1d0b882ac1f14f9b2a291fc81e7510f0be19ea01041cbf517f3d595635c8d8691afba0c98e2f2073c86b23ba6eb05bb71cc9632de16d4e9771bfb589a6c84120a1d3f28841d100ad127e15d3dbaa14852d4a8515deebea881084c95c52812c17e1e84e308f1b812a8ebcdeef8b3d8a9f5a5e06b38fecadae00452de773fa4fdebcc7f5e65582b4888df95594e7cfb2a921cddd048695b80c333674f004555390a25bb4a2626e5139b2c3816e85eb3a790152c8e78160e1df8d3958312e9ca1f99974c8efa348f63c01eeccc9bbdd678004167acfeb62f5138c51ba2ceaa150782480b2df571399a594ef6539bb4f7ac9695b2b1ab858cf6e62d282306b4ded2a2cad50fdcfd22e05a3b921332c0e4c03a3c6a57dbf53f920d6ff2cc8f0b662d94fb6946e129428a8a3ed011e57c4756e82914cc764394a1eab445c837a932dcc3b89b75f3719d2b96675da2d6fb81c6a9d6721009d9cbce63091218427f3b5bdb20b72389e64e658956a3f88aeff8d7c8b3253a3d90142b8e2aeb99bd7712206aa5237f8b02ee8503c48a540bcae4cee6ec9ae9528e5d7b532f5af79c720e68daa7bdc87bbd2f92854ed4a4fda89a5e7fd47569b7b80f142f4a68a98a46d83f23ba8e62d4b806b2891e28d1db7fe08b216bfdcc60de2afbe391ae17da7e82e8e293caa2e161711f094440a9d4fe682b5ab4ce59a06d6b2c9b0b7bf676c7672d627a9d5af1f6cdca7ce26d354bbbaa4cd198d4b3cdd66cccaba78ed0836646ad3a8c872bb955e1c971eb971ee8ecb7457286278293c8013a41c37df61ebf3931f8de3dfa318ec2ebade646f88db5bbf04f1b7222b21468a86958edbd82c38f38c4a9fc56ed40a63dc7f1825eb5be37394e552bd625af883ee444695a8b83d20d0aab7d976243de16b8a36e5fd7d636321b36bc0af14e8715bb5b4f0ab2ebafc5d6136a0487832749a8c78ee65d014458dfb64a51775efa51f0b19e65657e3af0477228b9dc4bbcd9bccbe58365fae80b37509762b7439c5b0a7467d5bf2b7b864d7f771dad5a3c97283ecf4fbca1aaf6da30c5c9c7b5abfeda849d7d04c1c581becbcfdc820d495b7bf02da8752eb7612d7916268edb75ee6331e453cc48623b834a1c6a3b8a3afa0328b5c04056289c9c55df746ab30053030bbc825ad549340e4531bf20d880873453d15ed948192471a813f75c9c8dbe4382b5b5bc68f68999de2ef0a5505036f8a01b9abbfd1534f604896f71b101bc3e8122c1aeb8e9182f4a72427edb2282f016c69ecb7b5ac59589488062390b446cc2a32040a96ea9b6bf6457cb63b773c5459cd7fa03bc98a674972fbfec6a5250a577707eb0b8ba8c56ffb448ec12881ea3ab127c727ece6bf804863176d60d5a8c0078b73cccd187dcb23768e3919346e90414ab5847c29614ae43a1b0185387fa4c1f3215c7d4f6c9d116e38f549914da1a5b144e30a729bd198e0336e9bc353add9d8276d6fb63a0b7a817a8180fe30d91affdb732933aaa79eab02b2dafeaa1d99a2a753a3c1b5aa90f3b6f5cba236c20b850424f025adc47de1bc5cfb63444325a206c5784a388c949e65accedbb7345832698227a0822fdf7e5b630742dbaa34b37cdada5fda13067e601b40d47d78c6d6b30d1e2058fe3096fe38bd37b714f3ae1b26fce04c8b0473c132be81784de4e346427300148af055c330826fd99f5eb692c5034bafb439579dd46b4836219636fca3e12958932491a17bd584b2d92146ed63c29ec3a0795df17c5c2f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
