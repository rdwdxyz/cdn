<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"075db2f8f07a40391e7965c35b6acc4d70f7402396da878eac043446797815f25e76589b8691be84f8a97a868bfb38212b371745fd88d682c0207839f2cfaea9dd300be9850bf0402bf5f17c3c3345a1c15feb6c2db0e8ec5fa2e2d2d68db3928d238a2a9f97acbeab1ddf1b35e563475d890952c682cd61c9ef5531125592a56fbee5e5f595eb476fe771faf17d65448d7a57d3a115eb352544a4d45461f4e17e948f9ae8d0dedb2271025963a3b37c0ce950b2222b7c7babaa8c0ba7bd326606918b17055a2094610a5cc8b96eea65f56c8cf8999b29980494bdf5f8c05670a82d3d13c7794475e8080b3ba268e24123bf1f1df41688dd8ec930bc025c1c23b4eb34c6748da5b083e5b48d52e8875f9a5f63823f2b5da9ce1fef4022c00b901b4bd2906b402f2ee58cd04110e22a10a3dc1a5ce68914edd5d818cb0eba220dc415dada583bb2b806d805e22a3b12b4e7deda79c25c916dff55a2532b0caa377b97798d0730cd48bf0610e1a728b044144797e9abc1a5643e8864878d969b628dfb3145d709672c3af714a45b8977f0ced1fef0acf2f361f578c4a769bd8559cf21552319a26970caa0d875064b91bc3d904949824e09a0d542c5d0f52ead506ecec59d2e684354aa3ec3dc3b92172e66d5d213e66f048a5e3df56a9f4ed0cbe514acd5b25653d717c6aba4835002693bcb09e9d27b75b67f87ae9cd82fbffead8204fa520813660e4d59a18ea9b4ec63c6a1f8e84b425b372b4bea3a0a73cdd2651eb689c29adb424776ba191c8fd22f538b2bc95bf9540a05a660a2c763715cc7eed8d00ab11067ffe1116cbe95f8b46b5482b95ebb721d57d6793205ee0eb4eca4a923d441d0bb9ebb320cbca9e1bbf64344847cde46773eb2b11114a79aa42bfdfc2f137f9d0cdfc6d0315fc6f0ca414bf808261b379a3b9bd905742fb1108dbc904b0a0dfb4cb52b94b14034e2d7641dfbdc259b2c93cd8d495983ed3d1227c2a915cb4f74674c611c824510c4b82cbe9163b242d9c49ced75539697f7b4e673afb6f4639d75d6048a674d129bc00f77f2493444b347dd4f74374b07c622ae4746ca8198177f1bf96eda46bf291cca6094850342baf28a72872f50e8a970d17a418a64772b752982cc916fddeb4d93bd3e9a9c4e70cdca68e432e8dae94bec4f65d2510deae12353e05a8f6e165938b47d71f1c97cda3514ab8a1df988a07b85f3720c8aa8640c070290e03b15d85c14a8b46d689d773df0e77fbcf215e5403415cb79e0699d311b05d9307960cf9554df6aa3dda7a74f393a2ce63922849bbda2dd369ab00e821177de67f80720b760dcf2052c614dcfb81d8e739d13ca1096ab656cf0bf24418894a18fc0a42806103097ea760fbfeefd5c5744fa18d6c9700b27380cbafb60ac9659b314d88fcfaf1554c2682c5115b08c004407f9a59d5340322adb37456e05bb83840636a26eebf8449bd56ea8ccab26ac1e9708ac0657bf9febd37a3fa94067e6e9b62e20099d95308579e512df2e53029ef8250b1ea2b94e722683d8a441064223010c10e10fd48fe0e2a8556108983dfc079de817422948cad401114882eeab9614ad869b3ccf3c3d096ebea0e75b5b7b208bc4708a85699c9ed278121ceace8cf827d922c0c4f1b8b76db91d62ef3ebd38c5fbf8b0f4220b830884df86391602c185c3e210670a0263da4b09e46f6869f7511cca940f737b96b33791c511513b5d25c407c88cba0f2991fbf5c67b66284d504b5e62be462c9a4184802687dc95636b1e07cf387bafc6bc363eb7c8594073065dc9d228152658c42e56c06272e545efc7b1009fbf9f7ce4c5428def0c3434a13a597cf352dd7c1f3d4c79d9b93a3bec85de6b7a543647e05adb11e78612d77e1b7c42f9c176ecb967036d53cc49f6f3394319ac63cf3585e34cc8f0a0de37fd7b93d49b80d89979afe0c002bd1d6104dc493ed2aad8b635cbc4ea8ef3f02ff0205482fd456973c2f43edc621083343339a83380f2b75488655245624756f2fbf3b08649ecf7277a2d0e5b76fbba664128dcd5122dd9abf0273d0022e6c3845b3b185cffb3303bc14d04c46b20bea60b73f71933a42bfd00cf0947b4fdda4f1950cc8da2cb2d330c8eabe0e9c74624595b12de67e8609848f82d63564828155366b02a56cff1ac9d57f0c5fbddfdc22175a6a15393c795385e6338e643914550120012207db1806a6ad66c96d6a19b5ddd9ca6ce4d63dd87ade16e211e0d05703b98e13d65cde9fc45cc04522060b9d2eee2bc831ead78820fd02e48796c9a12a9221bde6618da016896050e599356322895a8356eb7f13a8a2602378eefb9cdc70495dd93a1f6535891ed0c2058ea065746d33565136738ced0c21d3998de04ed60348bb4b3127e565e15259cb70bb98126ac5a519c8a7b9514e324da8f66a970243b24646e270d866919b2094242958a05c214e85262ab2ad6f8fa1622caf518e3287e7a6df6cc9a89efcaed6061c700c4c10791abee61ccf1d4c92f3a4ec2aea65e691995ec6edf66c5e42cdd1948ce0b097a8443af582df41c1628109c47606ce0f2d83179fc48461629ff64bab2daf284429e255b54a984aee1c05bc3b4c9592362ba0039887eb0095035cae365673c9573fd6547944e03eb4f3d9792aa36c33df354ef871b5a622b4912e3b29fb5bd73e72d11c9a290344505b292e2f648df238477160c1fcaa03dbeb23fae57532b51a654573952ab4c07bfc1d7e3da0b622f51156973424424e9c10d951a1604c76918ec86299a8bb02c79cf721338ce4062e8e0685ca1703c66fe394bc997c86aefd48c736ae853e559895809a5d594e865644b75bb81b24422ef1d880f4490a2dcbc66ad8bbf919a7baa1a41e8ca139c1b8b6783df0868560b0d6eb483a0c98c8c1075cd9f02e87d642b302eb542f03a35b9b6c1d2103c6c2d910e725e12a0303460017cd825c32660f349a3cb1530ae84fa362c5ba23f9c7b2b863c0cd90bc25301864e0e4db09e8e01695c057296174020537ff8aaa20ad856a383c54edbad9850fb4f0e7df9f4a29d0827f5a6a279bc9bb07ea06cd939ab150f91d18d7a269a5e2848ca92d138ad9ccd1be3f320b0eb6e68a04e0c6c429acbce8ac73932c6b0cb8bb5362412119106ed933934baa5dca058770d91b4c18d57e1716890ae6ab7a6f523409ff1c6815b61f75eb8350c2cd9205f862b4e06551829cc346c73521ccf7594b9f258be1dc138617629b2b56392a253a3f0756f816ec08be120ad18b0338ce104f180a8038bcfb2c05b02eec82036a2a88628df7056913c9ca61ffc2b6f4a9bb33109a474e35c5e54ffb6b30533af640a9d7284e78c6501dcd43528efe2b592e5b70100059b535bc18cb117c8a2cebab2904d7ce5fcd23439cd96ffbe9e62b1205d94aabf1c6868c4880afc37dbaa410c0945d969d0939f1aeaf3bf684e3e69575f3c98052040d7674351c7e8159dfba07e79a64ac49a78d322989deefc5ca43de3613e51a8ecf9abf206c55d2912234ebadcf236d83c74bccb48d9a0bd1b6110849d0317a2754a141f8bf33cfdd4984eb2a3ea2eb5e39822c2be8255e48cf1dd49293cee984d0b6663a073b514ea6ceba3ec6939c76fd7b859d23fd1fd4989002f29dda7c4cf792a6c9dde72d2a9ac476e0646e0a67bd94992ca741d85b621b48943fdf0a161c90da8bea47298fcfa3f6cd3b90c4cb8692517557dd3ee292c024a1c4cc2fb405fc5af6fca71ad995acfa39381d45ed4872ad3d1b00b8d6d61885d39569cdd60e3916404c10f16a21fed18d152d2c8b5f54ffa393df9f2d366415559e7b5f768c3a945134854b2c6da8da8eb44e8605188c84ebcc697e4c1f6c21abbe4c6619c93894a2a7dec7bea48efe4293b77ce0fd9ac6c8e3ae6631409c9e2420ed109b4ea21c6f107547e8dae79fb8e634517beec72325384ea66362eca4e1724891f2e20677cc5c7e3def27b7a03d0d290dd540088610195e43fe44637bc8c31fe8541fd13355e268f759000564e39f0695ccc7398570ab09631d1b2fd841c66b3b044afdbab92223810ebdede0ff4be3b6a123175283c816a6941479ffa9d64bb2944c69d2b03c32922f442cdbaa4d8b3bc6158a8b8ce4b74e5a18b5bf36214473d5b5c9b1490f90180443f132348218b68914906c47bd5f12759a6a36613e81458ad1297f5539755a4815b6f3a92fdd29e2a51130add7e28a1179aa0442f10f261a1ea36c45f55d1e3a7772b34d214544f7085a4d8647b33fb9edc07bb3c194594ccbcb1538b648812feab120c3d455f1cd2a6f45a57b2d2fa74aa214e5decc06a665ee02de19c3f9c2a57c52d5e002017400bcc792b77356b41300bf21242eefe2e7814d996762e599987607dd688a052c9f961aeb955b37f2b0b362345586d6b6db3ad46c6de67191f62a0c0514cea330052a4c96dc422bc9309780c2aa6d645989f2f380b5cbd2d7b976959b7ae72fd8adf15dd0410d75ab49d76eaadfd10965aaf9c35f6733c29d3d425596cd4e3bb370dc389da6b402bf0c1633854ae1e7ef40cee4b4b03408f4c7ae98bd325d40ce7f0362c122617e780f2fbeab0e784570fe4c209b52155bf6710f38f7d59caaf3d8ce8599d5938331ef32f4a1aca72f931e378f28aadb20a9eb18988ebc4fa1962b5114f395d9de3ba37be220446b38ed9cdca10d5c289f6618c1eafbbf43b92a07a9d28d69692017cfd244959290c55f4dc76daed208605886f9d9ddee5a3abb7c81e04897c906603c33a91c7e1cb13301afe645d39daa871f304129f9f76659ad1fb79f9adf62aea1c577611d946d210edbc12a17199146745304f334347112b79de25963a733a950afea84dcdc85ecd976d5bde51b7232b9bcebd6b72f8695be11c1faa770b2ba74461d75a97a99e680ace573d6babcaadc85ee8794e44644f923f088a0adb8d8f46a8f67cdbfcefa90eec0f9394c1921758ddd49da2352cfad94732526616b4a487692ebe57b9a322b4935dfdd624d10fe8a0c51a6b2a2954382fca36b03a6d87cb297448784f555dc17ef6709dc2f106618cb44e54f31718c893c54c36fd6a7ad5ebe32097c2973744a376e067e1dc1dedb4d4a6704d542ca2955d4cfe590ae9f97ce3215bd41f91c6abc2179e3e5c7f7fbc79a17837e67de08f38f18f7e6713b38b061f4a5cb5881ce71456af16a056f63d973515d449d4a81262629f02b8e25aa7f351a314e59f23ad843a5d25bd9713629712197c2866aae1d03a4fb80184b3abd8533257bb05f16e680021cd55d851b5ea9b524752141ef3d51245e946a3a4f1c520d77e66864a618e43b9c1c8522dc4b850f0a3884de22db9950e67669a34ca6e2c015df8ce92b61e5f1921ca0cbb02ea1b971f4a45dbb2d9d0b8684337791026287b61b4c520f9eb8ece2670582f06ae692306bda1eaa0b175685969e9d8167c856cebb58b4ac4e82409bf78973fc4143131c7f887cbd7040933997ca2b7017501c6bac885b706919484a281077b56e83874f2b9a32d3847ad841412f18faa227fb2494177ea51d5b71a34d41eed7629f2e42af21535a442b266e09b3cbcb0bc2a1e8d8050d2803d6c58d79f8d4a1d22d1c801499c661cb36c2d278e79eca6a6aa1428d238047eaaefe69da9fdc1a77aeb94f711ee73b21ed4922a912b430254b790d180c63ef027f941df3f07906144c2fa95dfc9f6bed07010acf40e92e96d28ced9d153a844ac4e2aad7a77406fa43902506a2dc8c583df0fe8e36da1ca1b5f8783cc72680a802773e97939736e26ccc1894d99e321e5dad28fdcf61854c3233a0008c1cb908985c75084e0e7666c9a76fdac21523ed79174dd32d4e68d935ad4fd80a7ff88c93d174caea3dcb480da811a1891b6fea3f6f60ae8d8501d0e60fbe87d93d8ec40a3d9620e1e08d208fa9509774d5b2a360d026388f278a9c2c816ff6bd9a956195a19c40a8793ba0f8d56351332ee5d5c1bbb0245bc90d900b9ba738c537abcedff6e65fb76b177e782dac38bf6010c711d39d92e3366eed4e825b52a37b76ba3e974dba7d73078c7e35fe70860140ae8e617e4df7e05352bd38d0e0ac14479ad888b6d56fa8b4f2327402eba2289a94cfb9250c5cd6e165a108fad3f8b018a9c5bbc5ae729be627c05c8a41b52b6b9ec3d909f4b3f869b9c7c80a568d06cec8be5700f7505cd1f40c14eb3f6c6e1473f1aa3840d02f415c928f65c2e6337bcc532ecc52048bc11de870af6167749eb5eb0193c2128ecc890677fb109303c2ec4d2c7bdac9dcdc9eada94e7bd56d8e32d91581b6cc618c80284f498f5a85b8adfe466789df9fed46140a0dd0d300967599017b75eddce9feb06b2881714e3bcb218faf161991ef919641e092ef4573bb15e1838623d22f78fd8b5c3cb1e22cb7000864d76035a29f5cb2ea97362d0c0de32399ffd94cc1e46c9ec95ff2bfe7f17349faba5a5d9a2e578db543ab3cbfe726c3f67218db17ee6b46db2bddd2349e639f4a9e440ffcd47272c92582c1635a7d0d51043adab81a994e0a8fbaf3f129990f1d2c45e64c3ebff28df51ac9ef8f9de190b12c04a1d1db61fc93736cd3c34d6f0e0bdb0dca480848d2855626f1a54b7bc19d882c0c42b978eefccf7c5a20f1cdb8085d91fd368196d775b06f209b12dd393ce6d5fa37d094262758e3a25d4f7d2acda516a6ca508f14a3abd5f7b626c0144441095d2ded13d5e422f0d3b6cc4f26b4dab980d72a4ce859f48cd3daad0bbcb9657c2a0f6fc241f6330d9cc178f11032001f3060a2221425bf4521b03c4407a9c3019ce76be66c1b90ab0ea0b6accdb9283d695b6ec20a0ea01a10f9b55b095ff5341d4e669ec0a04f5a739cec1f74ab410e8c383ddec2f699481ed1928f7a27039ac054025c28e82dbbe36e9be5891cb75aaa2b406080187fc6224929b6296903b6661d79877deab85b7d4fa8227f075035e1a17e6b14df385b6d99594875ce20683e4caf72f83e40cf943a6dee9f5b61cd529a1723399973041c1f91649c8b1762114ed5a52e3099b4c2386ff30ddeb8c8134535b2cc049ed2858d6a302b6cdecf6b42d8a4d9a5048b0f2bcb540c1532fa3284f555e3581b1b74a6de86130d1bcc799b46df836fddd7b15e2afafa9f40b2c2a2928cf7545821ff1d133caf77acec6359495668ad3084d520dbc75f84e01a05c15daff11e9b2184a35ef01920d44725985068ee835084badca666054164eb858817a0edd59c6e43fd7d6b9e9246dd266e7967441ab3713c7cea9da1c61fa0d81681f2a148e3f366d2823d71d75ed7bd95d2d16f53cf18224171b8704111b9ff5dce3762f3a4898edd2afb11a47832e7414ea02c55b9cd273f0b8123ecd5f6d9d5ffb262a8f40fb89c0a225dc52443e5e03546b05c82ed08341e387f4cba4958374125e4c87b543b836fb226b21e1751ac4b922807bfe9a0b6c3842d542bd29bc41d9ba1b96b312a96d8addd40d03ebc3127190d4be48e4eaebe6cda7dc577da341ee262a76f3917233cb5d7db7c49b6a773b36aa7c6779a6fe86c55fafd75bc102d0087ad24cbb9f26172c96af9c47efbff3a3ffb39300eda0d4ea4aab0e9361b6d295ba85d86669de855a8d9838e795fe6beed6fdc10cfac15d65986d3e6451ec98e05940fd3c00f93d0c23d8c052177deb518bd3a0f500559b685719d1207d2e9cd0c4e3cf37a6921eaa1ad83d9f4bd1f3911ee0d0414c9d4c63dfbc4fcb76659058f88c016a0125f2725d5fce7afc130f23b143b0e4a5d08ceb9800efefb76f4c775fbbfe4dfa4f203942ba124312698e7d602803c32b46ff8538b4e7b05cda203f9039d04f67ead688d1119c4ee945adb51c9acc346a3554a2df17df22d77a98f62a05a3889bfdac43e4abb4006abacad0e7a153337ae48d9dcd9f939ca4c220856a113ab8f729bcd2b4f6f7e4c4d5c736c318f10ca73b36b3ae0431511ef4aa664ae3caafbfa7a2cb14631a96e56231af57e4a678b4760aaf99b602c4e560d2daa25add9dafbfe322b04aa4327b42c8006858a1080f5bc0a44401775904770c9ad2ea3b167151b10330bc69d8d6e76180bb530d0ec8716121ef254dfc256f16899042e0a451467a1b94050ae48f3e844272bb49a32222ebe2f90dcd808a3758ca0264819a2cdecccf15c927f3de020836de556ef4d10a9a6085f36f1b39c3d87fd2f94a6b268bd31350c9f47caabf05c17855ac2ee89cb5481dd72f5bf83e98a6c561a3f287b366212400f67f42abb7bc3f5e923b96cbe8b82242c837e7877ac9db4f5c659744bb25d4c758ecf50546f9c0bfad319182613487e8106e3585679802ddf2da12f4a20a185fd1a043d1ccd9732d3611de00cd5aa902ae0e94d7877f0ed1e15fcf579c00cfadf0c9bab8f9c39a12e04173c6f7a1d6bc72f2a653a22c7bab70cff1aace41c7826a04a79afd8650f9acf1b60d8e6d3f84118f9deced00610d361e6677013f02f0ad571b26b409b546fd8403c3af4c4cb689838f671673131251cbb365069f92387a71637ac48793f38c14917677393aa82e9fc45fb3769c669718a51bbb90f35115eea177f1251169de1c7aa5a6a66339e212c9b331f9e5633009c16407771389df5f22de6596642d70b41741732a63ceaa479fe9495e651970d0a5a4b64c831f77ab27bc768adb32862e23090d263e92639c465bd33687d2cb8698dc0e37ef2f2e4136aa2c1ad1c9261c2caaa160822a9e35fa08723227508861e2124bea014243e8842b81c97f50286e8cba2f077fdb61e66e99e6b696427f88ce4581f4128bd7525528139bcb60ee21cfa30ff5bb6774587a7d7e6816547642c683478e1551384e1640c18cff73f7401adbe3c738b30fbddea0e31895bf05399b2779aac86dc25b6c98ce7b0d25bae981a369bd4fc71c8c35e41c622607cedd15ca47f6845ae6edf234d6a4555741d5e0ed24f1b245084295b36e0955145f8692958a4dd66cd76d2edad89b990797441c5cc4ad20fa7843358bb56cf6517d6316caadc97ed06a1a7b568e07690464aac7c482df251ee98ac14c82cca6507d636879494aa06679dcb1a24bcbe736c2a674e671ed550dd6bb41e092d52d054aa3c2b36375c4bcc92211896c5aacfda7a1ecf96ffc7b7a26c8c682d38f8bf5c88e785d9848962de5aa246e3e04e79dd78a6a0b2cce0ef5fe3207d1a575588c139314224dea88b43e826ab45ebe6f0a2fe48bb614d1678a93f4b7ca07b4895c3b9de7b6c47643d3d9e39a24b457dbe7fb2d79cbd2db702d02246a5ec1c91f19f7090dc82cbea62d02b4a39151b1067f1cf261cafa4dce126635e394ffd4370fe0664a997d59675c7c855a7e6e63c083353ef78103e819917ffe40c2d6266b264d1d65ebdbae4f5aca6133ae775b27c9f715d1ddbb06a34e450dd6421af9bf6e9f0d2cd9465f16809c385944435817a2128fdd3ae4e0f347260087d4093e904d5a93058b7a1e47f1dcb74fbb71600545d9c3f4d179195510244482a578dd46ceae7230ed33c0338d8ad36a292af2550673eae40e528081fddce3987375fd0fb2a9a5cb5a9d54b8491f3f8c08de8b277bc435fb998743834978d5352dec4a0a669591a59b757a5e4a7e44259195301b40868751ad695bfed38f2893269d620d1a63512795c5922fc304e5edd42eacefcdcc7d70afbc9f0502fe607d15c097d2a9edd07105349b2c7cbd83b11219d869bc996acfb275449772655f583469ae192ac3896d53ce3cd93ee60335a04afdea7b214579ee64b1040147f66a04906db8b036e0b96c26ea57a14953dbe83b0e12a485166ee2a3f0cc08778f6555e7eb5e7fb6c2e8072d714d30f9357029003c24ab417258687ecc4a903172dbb05ef3550459d5d11358a741bf38cda96c9c159533712b0fa6c1fb7820cc8b6d117ac4e2d5dd2fcd6f867ca8c7818235236711a98125e6635f9868a5288f4675fcf130a82f9685bfe6898e7e5462739f6265d561cb78f01aab7787dcd1550100e1503164ed02ebce0b55c9b28e60e3029a0185f477db53014368931c5267c8208bf404542ac72ac83f017a1808d584dad2944356a6ba117eeac3d43ba157855358dfa71b09c15bff59baa25c98825d4fb9877cbe6f08d0d9240371788b7261753b8a1ead1b51a63e545fc63f912eed5f9d8769634988bcbd3fe96fb998b9986449c04ef28023cd3b2d704755d0dea735f45a8ac6fcfe70a2ae34a690792c491c1ef661e71575256172abff219315967c89e969886d0c4bbf1e6921e7182055cdc4449e030a2d4491035034b1fa10425e7812df56321b70aaef69a1ff13832eb601887551074551c10a009d1416d3f79967be15e5d0c7d8c60bac633e99be254a8a2191b8984cbf296b7a5a0c32bb7e61678cf1b998ca2412a36e3a4a5b95580bae4db41860bb68f33e9a3c13a435e5af00861746fbfd149d0504c268b0ac96f74d23e9f5ad2e8fcf5909fc57cbda56a5950d149aa816da5d277056c85f6553d52bbe0efe6f6582a645bc64f88ab278228f27ff8efb09fd1e45b6728955b1a7179af7b8d4c45868c5dec7cc35ddde6b361a5b5e0df6a5424b0559c7f51f15310f53e2cbd9ac6ccfb53b432aafd4c60183125189225fd20881bd4ae5a97308f990d4b5c4d405a84d85742834f3bf9a3fb7805c8bf35b83b413747b53511b21a5ad13efef2407f8204a92111f1306a9d264ff03e44a1dca48c853607a2e9648ee948915d16893f113bdcf181ff2823f32e91a5d3d3cbe7e62436250e0a3282fb93d79fabb96bb6f4504a832834501854954a62855bbc6396b06d91d46506709c395ee61d2f58903608c7906a10783c5246df2307e455c1a0d991df0f7845b3159d8f27450b64f3a250965407eb404e3892a9b79f7046b9c382f6669c5e4bcb4d92c06ed666f2fc2f2a92f2e41180d339aa620db88f820ba3fc6cefca12e0a5b15ceaff066ba209324f80a8b011a853d96d224bbed767336a63ca649465e099cd36adf89f65facf025d6d9f5542c83a7fdeb6fdf41a047a73e1e3c28e98a7e12f88cca8fea2296dc7068b5db6451605beae8f2ca8ffdf411d544b32396b1a893c2f1bc62b10d5a19ceb81b2c16a9dbffbc670f094aaef0fbf64cb1893f7015105c8744e4f3d7fdd2ff094f5dea639ef7e89048987753b4365db57fff12cca74564af14cd8b866df2a1ddb1018e8fd24160f31033ce601a49d8786d86bd475042b8bb05a9b79f723d2c878ecf50b4bb81ccaca165d1d117823a51a1ae422c9732807275f1ee21496df6e01416a8c401e8c10df0bac15509bfac22f996fb64206c656638fc72abdb7b808ca6df2c762fef718a01e64c52ec808d6b587465ccf4c5aa8911b99f9e2fd028affbbd8bb7ae2ce31cec7506a7cac968ab661d8e2f2b288124bcc372427106a37535092b813f36dac4091899977e980d4b3dbe27c7c2808806f6ca21931c2438ed9562647365fe07f33ba03311334530dc3aa73593b75625bcc149133d1545fedb480c118ea5a10e56b5a3e0cfcf81b7881d17a328cd00be9383aebf96b3eb94303969a1a960b5ad30f87f35c41c83494fd008a26925a900fd4598b6a19cb0a2eae8268fabb257e21d3128bf8abc30519b7a136f68aded79aff5a217287c23361cd5c17768593e79f6bbf389fb43187131d23571a0c9d29879290fbfea5c354769267665bf28bffdab1e00b491c84f2b9a42ebd3d31d7b7a1f3992fddbce12ba3a3555a22e406472c7fdff7cb7debe951f2c5b4080bed0c0c47f3fbc36b3b19332ddca384530247614cda87437f7972749037b6322247c81b8e80c982ff74ec2103adec642b672fb9392d171ee6b33af96a85d841640ed7ac1b49168a9cbe962e56c00eb95f2928b858b6200a8437adce855add8aa0428913363655131010f9b54ae3c8851d960290a7f1e8752b5b56ab3b4fdbf0192b78f22628e0568f1428e4d1027b58b55e63af322af02aaf79d1231002d78e2853c43623691b85a77b77b59c55e4e78e6f48dc17cc8fa01df7111d970a913f0eaa0e2b24a2689f9d4331f7d6b4595e746c12e631563d6493c3994b2672cb5687788b6c26c60bcda10faf3f5130d9615a6664d36696300ce4e083e63012fcec976f232fba8db5a8b2c0812751aa5932ae963ed528a10a15ad5e8ccfbead27a15d828e31c90762e1ed075d14926ea20b3b09761530fb0130f811f7aef15bcb502029a400b786cf10626aadfbfcd7291c408f476204a3708d166ef11f173edc4592e4a06256f690a3fdbc803a6f5a59b7d0173fe21516447bba337fbe0cff5898994ca905aaf2f2b3c73f8819b4e6013a2aadc146627d51e446db1bfcc9d19c7afe1aaf6ddb1da06372704d2ea4443ca433a6dcae14d0de527c8d61f77a412b28b292f3be152e446a21ef4931fc5934d99318b13296903dde5a9ef8b18d048817f83de1275b8e5edc7adbb24019b13b1769bb3144fb1cd176529acb6debf6244afe221e55c07be00e95c1bc14e0e6f831a343b447fa5cfb5c19124e0ba217f2a530798772a9e76c58cb3bbd52fe4bafc3e2a04b761ef6591502cdc0dbd924fa42248254237fe430f4a49bf2473ff51a255b21a9cd8111c436d681defa8d9a1d7803b7e71b988ef8a46f117ed808dab7e8cd6eb1d695a93b8a4e3df9f20b77b2c59c65231f4df4accbba12d92646f1c072b03ee9baf998e2a80a8a1ab797de40a7b34d3072bd5292fc8084d8a47fc558d21ce82a87d49584171e333cab4f0635ad75b093cc84c107d82cb76f03d26f3279a9cb609a4354ee8c588cb264fa99bd5a8b9ebac3b0696c3a074f1d835c85ce60a3f7922c473e509f13701c292f88eacaa268123208724eaf837201a763ec3e08ee3c1f3223e3ccb0bd5dfaca555a3ccc8a07b916f49036a6e4095a3b36eff8788d4d0228ebdbb8bfd22dc978a2ec15ef3bc7e0ebc4c6629f03d52a816a5f07255421c1938e3a400c57ae399e6f39054d28bff8f6c8fbfbbcaf195d83f73480f7ea80a9684d78182ac5cca8440444c7779407acdfeae1e96070b6e769564a1439b7a1bce937ab9c1c8ea92c094793d18f1c4eb07fdd88a837998c525ed7602bedd288a859dd04d3a57e1d45c012693416aa00d835a9c73b85a146d4b2dd817e8c45c4781c417b3b4e3125fe4cae88350a325d1ee266cbbaf60989d07f675dbfa75a41b80e6f1d2623cfa36a9aaba14d0afdd4fa57731742af965a37cc0d7fd8e350a798adc7e67d5fa4b199453547e1208057f7cd6e2b8c96d6ac72b0cb2f0beff32f325cb8fe21b9ab72b1c7dd1f55a1a9192b7ebcc49479a459b14fefef25fade6f8e0bbaa87f4800a7e9610f32e781135f87a52a66a8a86f49c87bf98632afcb9d78a85d6776ac7bac1b1ff6e5b38b8b694b2a7f0c330f7449a29c872b47578d2b87cb7b1c0d10bbba4049056610336834616abb8e92f5236b64bb4fd2670968725a78b4fac8ee50dc013259bfb826d28a33070205204f00f4d6553c6a4410665df844a4e7fc1f0bd9cfd798cabc154ba6613d2dd003fdfd878a34b631363a75f99c4ed01f8ec78216cb45ed0c7fab0d8a112122af3c604f4b34578b917db4877ea44b14a482cee35987e79adff7b9dc3664c763c53b6b7b7800c9a4291aaec0263f0970288599d1378210a48e2296d1972974045134efe9dc8b8576db912467d16c3afb5e20866a73aa5bbc4d8d75f4021766f386c9c10cf078bc5006fdb4d4a563f5a9cf3dba785be825a5649d142c1dd0d207edde4552d030b93b1d698a21d71cb7c1f3cff65b2f2b4028b130ff91ea6abea3f4eb96a1679befa17788cd5d7ce0c9fb0915dff5c91da9c14b0f031e9ee4c67541f5ea077675ffa58c58de23816e524f3dc14efc252faf09642f0901367751a87a117030c255e45a5200245bd9606ecc78346f3afdc6bbfa47f39c8900482690104ff6e5677c141acf7ef6a2f8e2636e62a197ba477ebfa54246130b8f2ebd06ebed44e7faebee7b614795e9b7d45922f2f8525324234bec226d4dbdcf885431e596b7a71e663e4080d6411a648ee231492608812452454cc0b1619b366df9e3178bbd6e68930e419800abb3c6b26dbf4f68cde0ed7c3fc5eac9c021a315b41b1729bc5b2f2ede22fe81eb2217ce1101821616b905fb7a186d5ba5cfb7f35b28566a7b6d18a676277287dace6114aefa2f9a3fad6ba5d31de03168b85605ce2cff52fa617b6b837e2b916a0ca17bcfadbc5f5c2a7f0e98f45ca4aaba3dd75e209c18d20a2fd1db6bc5f62e425466f180f7403be9753814298c22bc8b43e129e43c3db28343a995cf5cdc9785ed651e2ee2e89c0804ffd5ebc9e576a1574c822208d1c7d21f9696d5a95d980977ab10f430e746625e3a1c2ff81271537ea93dc5e467afcffcc7e9c6216afc8bbffeb1eebe1728c74b43ee27f43255f874473e3b313f202cc9207f05782b306f92c6b6d3e3b6787f9d6cf5a1abc8f9c3b2fe0b27f9a1fe810854f0a9cf6f48255546f49d8f6b126d445bf8e5152c2049ed1c7ac08947f63bda8a47e6be59355284eef8ecd468843479f9bb7d41e876563ee98c8d365fc3b5fa9603476ab82367922d1370d3291cbc15b7394f0dc899ac92182b5be03e3371f18e72b50fdf498934f11825658bc042371aff1a077d9062d75e1f88b2fc946d289c9301aee4062d32a03661056a70d6fcbc75c1ab59765359928976b75ec0bf223a53a80a2c7418743bb9310d2640cc371d801ea534203f65cf2d5f69aa7393029b816783dc564502d2b788eb7778d88b4b85e3dd33da2c202da441ce013aec024bb3c9ff8fe76f106ebf28341589141d779e145889ba1eb0237e08bee941ee471fc95ad30e8009fdc72766f26182404825f649e4cf2deec2936b3c8c923acc075ec23a8da97254b8c46da87fd4e6916d099cbcf23ee406166c417ef06675fac685dcd2ee8dbab78f04738d401403b8ae1d353bbb4a3ed35d9b8141666cde1b4b699e392c75af93f1ad3f511e44bf7919aaa7c3b18e436c7fd07128b580c16db81418baad9256ff5fd894bda2a43fb024f5cb504d541a164fb0087984bc5fe43532d909309e457f0791097dcdc2ffb737a91aeb184e968f8f80b705e3975604de0ea8d56a9a52b4a57583a32afdece22cc30e32450a69c9c8aef7eee04ccae8f1ee15332f0dc8d3a5dc07e240fa72c1759ea9f256e143c4ed669bc35d3e9f614c10730e344e418ba47bfab97eaaccd3cc32ba313da066d7d6a4863fd2cb2a691e412f83b524b5ef3b2d66366adaa100b3e8fd2558fbf40a524107b4c2fad359425e3f790233bb05474ce006559cd8929a1d046931034ad39b1d9772d71e5ac4c4252bbceada803d454ea8a169189be7ba66b5b7f8667c75ea1ebd6b2cb73cbb125d64ff16999404fdd40e4fa1a533121e2f6f1587008f7f111494119cc8feb647454cec41b42fa22a73299b8a963f575dbe1c7bd59d3ee98041b14b92a3ca2ac90055c3b565e45463fe57a8956920289cde66320c168de693d4e896c3ad174b9ceb6453451b7b48c005e79e8ab7f7f57cceb4dd1c2af27aec43db5f49fbcc60b17fe1489762a387d755340b27517eeff0444f5f406428234b5c34c5620a6668d8c273d434f944f5481a86f5d60bd14af06166cc79a209aa3f86406e0524cbfe0888d26ef8d88f8145916c90a1aeaebb4084d3bdccfcabd76c4ef7c117d4c26f1ea782343b1e12491ed48f065689f3ea2eb16c61f35cbf3f58393ae9c7b5cf70dad0f739be22aad174ba71cb6f546773ff2e3da0ea529e24a35859467a0cfc92e4ef896170dd86808c3db1df454b1ebeecc4e1ff4cb522d28c2e4801fab543fad01dd0a564ee7710d34e51a6c031feba5796301ea4bcc798319ef412d53e8b01ac4bd5a6176fc7dc44d8e61a014b5fa9bf9d554224625595445228cbef502539ea8c10316ba26942b883408fbe24cd4c9f0648a3d18f2a8c8430ab68a18d3a14f02a0e3e7ff5666af26a3976da8dee2ef3e7c8c4c124f8427535593095d171ca3ef94918de200a76779f36bf65b8b1deb92b04df6aef23bda0ad6e439339b0383114b747de24fa8ca160fe3541d6ce68431cb3e45a165574924b71b9fbb5f7a4b3f99de987d0dad457ecc4010b4a22cc84f59a20ef0b85e7244c0fe12b0cfffafdf076816d3876a42beea28de49abf887bbe96764b02d2556814584cf3f1317ac170cb47a94bb36c71e060e3d95116f6493c9dd77df79aa25dd93c500816a00f1a084855e50c0449a16dbe401a029b527f85ce53a054f18e3dc3605b546865f79a821f3d640ed3304fe889346a229d75783358c7a2cdc5f7fc47d0e221287255fc177c10b54546e8be5e6ab7c595cf5cf6dc7cc961746d7748fe77cc43d0df942f862a59471d029ea81f17817a22f32c1679b502bf15226299c860c489b64a17e52183796c9a253b6cc48542d030d91dd2b291d8bb0c888b7d14dcd8f57d3f0a8afd84b70fb7ac713e509ab6c1d6eb1c341a3e2e7f16675d36aabf8040d608f7ac923ccdf2813573dc1986f5fae9e25cd0871de374aa19fed5e5db764a868e6ff35f6419c8e763e0d0a9fbdcd32f4d4b73add8fbf177ec6ab0f65aa2d7f7fd4f9800105f45d20845f961e475c4b1e71bbf7e31cc4a1f271b8acd844269bc9811d6bb7117e80f67362c07977b8c3e69140d4671bd539d784768de6da350f737329926debcc8da8bb2febcff1902df4d4a610c11c1aa34426dee216121a27857dbeb4ee55a00086c66fd36553f7f7296ccac3507afef0bc40229655117b820d8db7901198ed919056bfa97fa7390f5cdc669f03238c13dd10d0d79661a59ec0f600e4cef6b2226d54681ade50966468443d5ee1ef50947bdf01a4a0f2743716a8925a9b210a315761d60ed9d47b393e980370534182cce884097ce09f3fe9a457171a87c4218964d619cb3d35d462e50617d48e526a79074f25f6120c69c8bc6341d51e078a745928fcf73b5b2afd0ed29414d699adf27cfb4a41ef00e8e860e3f3ab395b7b36ed2e495f984b3480301856167826b357efa90e6a5082eaf1e837affcb836b09609e7e4ff1c872377075c500786eaab425ca356c785c1c3111506464817e106d59cdd70001160806512c16ab7888716cfc45e95ff999565d915bfe4b776e2878a92d29106bed527917d47868eea34366924dd1d2a347d88e2a9db61d34749117453c82ce6f646ddd9931f2241268f16a6fae82858aa2d0f4723a3a2f44d1a31aba98959243e29b2f855630187682ae5c3618de6abbce0ebe362c17bbf2078b2fef5e8df2f78fa49c8831949918f677a7e3f3151dea6497c20048412b37c7790fac37dcb3393cca845e19e636c8ef56bbfddd201373406984e73efc04af316d4d3612b35d7a27c7a2b181ca35afdd6394f152747fd0fad46884fd0aa626e7495f93a334f6d5c30d8e2c19b44171ccb2e9a5ff0ce553aa288ef0f2e8e70f8728da64386b42f7cf89131787ecb09bdc03bccec61e3b142caba07e7a0007d1a3ee48b557d83cf38c14f0e1ec601609fb77fdbcf3e47b26db0632b29a8edaee441843c172d567fa14c70fa3669f6c38e462cfa28c624a27ab3a438ff307d667dc2fff4d71ca6c900a2a941c608e06baf014a81fc923ce94603a9f2d28542498d7e31c16670c65df689239a167a0209eaedab2638ec596d3d82818d3044d35cc703c2566de1ffc0b5f46d1bb98b07c09472ab632eef9d9065c2363a840bde5b68fa9559683b504a25a60bf50b327429f5c5b5d59936cc9e1e2147f261602d94548085d5e85567d035237b7361fd530f6d6bdd8cebddce55b2823b82155c9a505851a1c3b752d779ce550e5f9708a6020491528df04cd4bc1be1bba0c9aab32413145ce25cb65edf4eb4d8d92595394e29cc50070ad0235967ca74fc4eb462bf9d0e12236688f44f15e75cf9c7b615458b0c148ea821fa0b672a9fa2fe8997f326712cad919e422b4106b43d9602086f0a1fb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
