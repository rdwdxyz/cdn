<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d77ec893ff1c4f3fb837414e2cfc8bfabb6ed7fbfc94d3ed8c3a0b70587eb4bb9edbe3731c57e6daec34ea1faf5bacc12012e9fd3b2f20ce2771615c8504b9738353dd5df62b39142c66c2e6940648bb10065989b4b57353c02fd430f036cb306a3257c83aec88b788a94cb09da18be46522dfc627914f70c341b5f72b33255dc47c49fe590546920262e02a7230a79a3d3593ea72aedd1f2ab18084f3fee3a970f5f0429af93e4acc57aa58b7d04da99592fafbdd13285fc841c4c8e5571f030f4439e18d8b8ed9bd737e08df13fd29a396d46b3017505cbe4c0ab22a5e90f3793c76f40da8f47c980134f46a8ba8d8472fcf3da749668d52c032783b52f72de112e577207c7e1d0635e7bc02ab7986762244de8fded3d6e6b098f590d613b7565db7a968d7a3f7eb942382c8020eb43a09251756c7e26691c434ef1cf505ddc7585db178b19ccf8c7e410f4b2a6dd5dbaaae53b8137bbe919b0dbb6a3e8da4bfc8b7ee3607d1f2bf0d8a6de42ae256fac0daf823ff7a93c6265357b5185f244a31c26fbf7c5a687d1271604b774660aeffbfcec95b44ff369153dd6e3f3cdff90e470a0787b4dca792295e54088882bd57ce3a738043ec0a0d386ed232bb0f4392948b45f9af133d08098558aec69bf5f7f70b4b7eac496e47ad32fe750d4eff444cb1c5a4dac8d28e267e9d0e3a8572c27ce536ad0fc2bc3a26bc260df7298d07556e516a7c6b0b62bc01af93a304c9cfb2a3586112d83200aa7566c9bb24a507abb1b3f5e1475cd8d059fedee6bf7608418d7d1f4b64c8631045776e0d96d3ba76475598d5c8e645f0f3a0099753f6e4fc1b0f478361acc60afbb77ca1a3165a69950ea747538271f69bf70ad8204b9fabb88f7f49fc9b7f694a736df46efb366dff4399957f0c612677c679d18b723cf3dd7982ae7151572efb0f18a01a47399428b947edfe85f6c1387811fc09cc647921d054620bbc34fdddb4c66362256b8b4b7bbc32ed9a17af2b24412df1edb5f3f1cfb9dab5aaf60e209894a489603de02e0a45cd63efdc1ba1265d1dc1f5c656b94796079f2d5e6e1867c00d3eae6de722177efc3874f566e91338bba1064c81a968456da4d9e3adbf9fbf4ddf0d02b8979cc89c83a92488d57ede0fcbbc34042bfb383a9a740ded982fe4919184d7a85670e783256387924095adf20579726d21fe9bbd7a2b842bfa946a1e8d77b8b150b1a2b17048b54d93f21a9cd5ca2ddfd258ff67ec0cd0bce6c0fa405c9c79cb86948db13c49e07da02ead8246f14169e96c3a6b8079cd305b2663cd77a69c89d877d815dc7dd93718d01efc0ea97bf3b97c8b21934eca1903a33a7df49748a9a6d4a12f89adaed0b8f223d1f56cfb5cf852babc450ff1f1fd3b3766148bbb10329a6b731aa735b9670f6fdca92d7dd5e6ccb3f0dfd918c0c94af5d335a9b3353cb9b52fa1d524412a82a224825adde25e027a092efc48f663abe9f3d59e725a7cb9b96ae28d0d19360cbfb9ec29c67dad777ec5deca81efe1d3abec6808976370f61e90402eda67735e8ec3cf2e9bc3298dc679f343619b5b898d06ed80ed4063ecc47b9672b99da166d38b02be1c32dd9966c44ea10f1281457d36ddf973024e572528eae3772a1ed3484945824d9d2a0175db3efa276bee937aab45dd26b68ca988c278e48b2b793b0b6e91d5a55a8fc75e53bb3f4d0a1c36cd2ea7a2da3fe25a004e738e5bc19e3ec640cc62fdc50cb40d1ad0d47050d1d13d677683b40fa52f11fcf2cbf9daa16d6bacf3d38126753d3d8312c5dd5ca435a93e186e3e2a8b731a7cde9bae6a4baf9c5cf5a3224c431a7880c05faef9c516864b07ce2c0d1ccb78df6687b58a7d522b083eb0e2e0bb2e5723c038f77482549eec263eb64f6bed1c9e471d46f56c13fbe9780994b404806bf480091fd8fbfdfbfa42eea956b00370472d1a0c0c6cf3e68b03a7ebf199d8dc73c34786aba79b2262086e031fef1134eca23cee95b2b4f4751ba3bb4dec2e8abc816c222a7dd6bb5fa1206d079d70aaa6cbc0148691ea004204c42c5bba8a121565a62eea78cce7120993da24e3d56fff5ab833dc8543f36419477c52c0f1406a3439e2f5b4bf8145dc623405b84dbb29385e9d39775d8d8ee5a70e6548ea3a1b12ee612c38f8264257660fde069c353e46019951784a97c3d874fb8a7772ea057e4f3264ce7750f3f6e264c76c3a5864b97450588856a5916e940e63f082f8675e0716593f5b5fd099fbbaa6ccaa91a3daa855e3a69ae1cd59bf9a573be61247e6a954d39ef16a155240967b7f485162721abaa1f9abc75ce8802e192a5ab26d29ed5313aabcc02fc0341b62ef3015fd426d802f3b8923d9de30889bc548d1ae8ccf76d63fb71b0b1ae76bce9250b6b4d14e5b64532966ad620848e4c3d10024b3640dcfc3226075fd90e8922b43cd990c15903de6c432183c296f674c292dffda57187098e6e1f3d6cb4909da779422ec333e603fc5dadd07a1c2efeb9beeefa9c35a30cc0ab1c7935e817e4740daebc684623a94ab2d686f325a2db96798b63d7e3deca196af87e1acb5328b7094eca04e3d3a4bfaa24d4554778083e8f1f4526959358515e13316aa5fee92050399bc6404ef649720f7455f22214f69b70831edbb5865e56c4472bbdf2c0696f42b64114439e85edb4440b2037f20f94f08dac53b70f11254b0da31dcf315d0542bf953718ca9570b674900029e8182724f1c81609294e4e74924ed3a9ea8a43f618bd2794c44c8c78784339f3c2c2017765c84a1b8844d42dba34e021f351aa07da921b864189b1b584647608f1e6614cafb152bea78f095c67bda9bf786c5ae2215579a33d4ad2b275e9d5dc54c23b7bb63cf0c2c9d4d005b804e50c52faf114fdb7f4088690f2d238726cb3abe1c2b2d6243842fae6c433e81058b8d2db8411ed6946911f2488bf0c86995204271cfa60fa9c098c674b92461491e30ec1ca1614063d4d38cb5a330673e4bb1f79cc4ad7321768bee35ce64ab692348b9e7433cb2779ed25868ccccb11977603da94c0b6dfa5184eeea8b6c47ccfd5cd323df7be84f41f6d3e9057a8baf765b620f36c1da31b8805a5eec96758f10284108e740317526eb9337716fe27da1ffddf4f90039e24ea9fe989638f16cbaf1fa638f65513f55fa3a6d00ea5c34d636797422cc7a0e6255b76bd7b66a5b7c8529ec3a63068b6a3723362d9c458de8a9951a9c1354e3bbda7b8a0fa8c3b92858200d16730c8ee1a6a5cb8f9c4bc87bdfdcc71d5e0fa193f52a46a279183075ac843791c821202c4f91ff306df4cb98c57be2c1900e20d4a7dbe30b01f412d2e7c59d7297820bc2768db7d28fe44590bcd34ba0a10c26441153993929838afeca6a8c86daaf4b80c00a23034be8a65816db0020b90282de842d0105a65d21328a48014006863a905ffd3f81dd24d01039a6b1022096eadb6a213e6abf257743b2a42777d5f8dc3f07c371646f5559d29215d1ea677ccd809a96e2e0b3a2e949ce569e6d7579a1f10747e977707d5355ccb8f2fa02f4b4c8ef7373e46da6ca5b41b7b13a6d713da153e81070c1aaac38662165e8844dd6108d74c6f0b204b6bc1a4c716e36b56d7706cd9bac12dbfeb0a2c69756a472fecb9d3d615d14e0edcb1afa4136bd8f4de54a9081f2ab8a5c2d9b473a7c368536f411073906f24de3ced6b7ec4f04f788dee793ba1f772d7db3612dfbd9d42bdacf5ce0d9696a2aa0f1e1982f4d5b4d74421d81efc6d39df55923d67fe9b70c88c31741031eee8568b936e66f57951756fac4d3d9d18acbc02d3ffaa8e2c23c01ba41eff01a2652a43480ca3477160045c4378a6bc67f471683e45468872b3d784b20a2b9529de26672509d7dcdab260543556e95494a8eafef7ebc98e8e3ef0e93984375f9801cfbbc0325cdcf5dbc9dc3edc5f8ac8ec78562e6202a920007cdafc62ad6ff6f92956a5231d415d55bdeaca284adb6b7092d335b5db6c84394e6ca23f0cd211228aba8b13543268307a83716d53737b18e91ee378f6fb1033c84b92b68cc88eba7e0a038f1b32a2ec2a2c9c46dfef0e54b66d586565579694512142dd76675670e9d1bea930f9b80705ce503b5350885fafcd88c80db2a167e5881a75c1da50277cf359bc728f065a77091f4fdb0d7511eb61555a75ecc93eed84ac75338f45c3e2b2b7f3d211209f966cd6c0fac1b4099414f5551a57cdcc7141d70992c9526cab27ce13abe3f150189685ee34fa23205e2d417963f03b0e5c1464a41a60ac65605b9ec222cdfbdae22aa5851883910b1010c14cd7c712c888e6b14caedf5d7c654c24a2866f212f21787ec7998ddce737e342d2bdc4a3ca08489142ac8c82bb5c645f0bd22246f4950519528151b7a5adf358874f73f529fd70d9965633f9ae4fff12fe24318b4cda4cce35da0ef4815fc73ba266436e2c2da3e19ceda36f7d79c9d84190eecff769051ff2aa6a3997d744d2fb8db2aa67a91c3d3157a1d55fe4ff2b6ef499f1c5f7d20df5ba6b49b50efb65c614d742604a146faf9ee1532a0f6863311a7d4cd4fa5f266d5cb87dd3c672645ad4b3d88b3f625a722830913e2894398896f6bde5c7114270007f195faff5db6db1f99a81e96d846ec6edeedc862acf53421cf50c35cbecd1731261b9e007f809eaf21a45b1dfe4e8e1583b787a5976f538d69173364646290b5323914b4e08caee83d4045ef1dc6a941ca3aa806e6c1ca32e07b2edd832bda2c28a426069d95133af674afb5d8f060c950f178a65f6f8de6107f46ee967a55e77710a1ad9779f661a73d2cfcfa728a5eed9c0898073904b10c36b35363e872c3e39a20d1ae73a96a15ba1774185491b566ae33734c3f8724b77d0bdf71b9a9391d2deb0d670438c63397ee88bfc88d76ea886846c4383e8c14f93bf94873c9f1ab6c55c6e7e345b96300011a699eb9920a2f753fa06c4db47f562a19f9f16a3bd8e88b74910b739d2186bbebd9f66cb60f38fea88f50392420c48620cda62c27ed53c7abe4d425f82078d42032d15f8224b4206d5f61df125e964cbd79c3adb8e8d551000c6c22f61f9ce23ffa1ec85fabd769a48c85de7e413f02f89ced39fda355a6d2d0bce1cefbd0a2833cdf0743095083939c7108e75ae6867ee36867b051d31597a9ebed440f36729edf5d23fb954f520cb0d21333609e88adf0c33ddfc3eafc9dbf08abece529e086bc4ca10e0649a58b73cb39b4f61fdefd072dffe9e9f6f442b149baa729e2ac2cb8b1d7a7005cffe54d5416f7b1c9bc7de46b8d363439fadae3623effd1e653be459629a0260e6dbc06b294c7f6955a71eef6595258bf24682f0210bdb073b1edd88bc07072e17cfe5fc35433e23ae66ecb1bd15a9cc122eb2d80d9623d145e75853866c43b67ef69a620be1bb5506a70ae59d975f7786b461e8e7502cab5e0b477cfac82c528af3dc86aaeb789935d053d10e0646d3829fecbaa5b7230b942d25a2d565cb6529abd1485e83bbaa313f51c8f47153b60248ff87a936276059f6c409385b94d9ddc8378bd6a981bd9ae77e0e278dee997afef154b9f32ccc63b35d252c7b292329ccdc247b289a92be8b5b30fa33359f897228795aefc3c95cd4f8c222144adb7bc1a6741411ba9870cb2d1d1199f1f0d5300db65fd75073e2a8f8f003ab8f52e49de37fe8330820c1de5171636060bdf454796096010c6ceed8641aa147e3a0572fa30516bde3430c2d25d97136aed5b734962b7e5b905518d3b1f23ce8bc68b55ff7c1537ff8a537c055026e1ec5dcac6b1289bfc7be9fd08347c59592a532a8b26f663abc5ee884c8887505d86cffcf23486e0683a6ae96069217c76b691aa48f247dba95506c8b86a2ba4d06aecd903a3ac5b8dabadfd51abe95d661f6372ba87fef0c4871bbcd35dfc76b3ecb778c0ff6dfca3d7bd35bde1d8348ca9f6c203972c46cd431e364d773f34f12a352abc78f48a75be4f6ca899bb56fe987f6774287eeba11acebfbaa07552d5bd5db9a8230d8a49f434cf09a8bd438c24276fbfdd1e4a8f34216c5cf54104c7be79524ca961312743696054d936fee5f06f6ffb6127de1349f9eba51d30e9ff00fbe398853eb8f55d9cf709182dd782a4f1a5de725a242cd9932523d86c4408b3176ddb4a33b9c3f5ff9095988606420340753edb643374fd455f856eb36373d4c99f7397df6ab674be526cfdb12c07ae16bac9a09c3e75c9bc2b974b2d968dcc8c079eff962d62fe2af1f8b8b8f268da287caa4d09d0ddb0c40525a4b08b50a4dd057e43578f97547da057ff3fa642fdaf818c858babdbf50e9f95ad4a198f3d530914a7ea06dfadd89e314a1ebf77785fc2a159d6fba4f83e4e68399f35ee4e7831300fbf72f61b79599680881c927d831911b2cafa719a34d6eeba3a96e42dbde50fd81b23fb0fd54090e109f37817d9d8dcb0bdd6074fce215d2c6bc9a42802660ec359d4de06e0bb699f4847f44d29a4618dff63ee6f067538705dcc7b461405d200a46f25390e497ee2107852735d76bbd4eb1bcbd6f98f47ebbe57582dab2419981754fbd36fa1d0120667f4e684e0539451468dc78173560bcb384e36b03a8d30a7884b365541c771d80a9f3e5980c2a1a2f42fb10bc1f5bead660346fcc53de6aa71148a441378e3dd0dfe7402f4a307e466e41fdc5423cf582d3614e1443e7bd5d1a8db2e5ccda77a7a20c0108c5c45fbc0faa5872ace7a7185a05d013b7d4c04b752abccd23be8cf12b659f949e74db0833f347d25824d772a0a7254b9acf42cb064eb13d92e28bb39b385e97b4b203793a40b55eb4eb25596b58d2abba3f490f9aef53a44355a830d1edaca65ec6dd1f0592dd31d6be7da1cf0ceebbc1341b7f5f32ae99af7fdf9ab7940c8f3eda95e32f5e1b6308cffa436af54ae88688ddcd5d7e97eee350d033284ddb2db16183aa5cf8c9635ffc5f7a29f2c66636649798a49b8786c04a2e4ee66599fcb46958e69a9d05cdb3821d5b3bde93ee8705e4a2796fb94017d246747ccb7fb20a228c3c17aa218f5c14bdacc8e28467c7755c428c7ecd85e2c8a4b57050bb7dd8b12de2ba44eb0bc369f91ba0a1898815c71dda048221c3263ba343ac296f3b075728e7afb3994bca69df10628d0d94b2077b50e5b761e671c196bbb26fd66c19412f8c0a74055e4eb495f712351749287739adb1a2a77bcf4a0c92a70fdc1359b708d3a56ffbd4a93a472783ec0cddec44efac6e08ed1d3056d035db70ca167dbbfafd8b709115e5f1dacfad09340a26213db4a64521d0bae68c4597a9e320a6376619284626fe0f29cb7d8ca067535be75572dada97e20a33c71e0e8f7ec7f2dcd1e4445429989fbd54a4dd5e78f6e77f6e6578969ae880d3073a5af7dcf1d82cf3e716d5356034a59feb9536088678e8aad61ec93224820cbb44108cbeb357313a38e2c8a7603b220e25312ad1410573d7ea258f9baa0125808978d9123742d8b88edfe76429e2f7e7d021dd25e49a224cdeda07dde5370dd19ed6e6e546c58c55bf0eca76f5cdce37c4a610c716a5701eac452f4653a53858751db89e149fbe61452394140a3ffb0014f0df32066b33301cd295e4d105369c83faffcffa6d996fda68c68ae5635e4886bb251f209103ac27f001b60b8895c97df786fb85afaf128e55e17d795e257f796be6b45678f770a5e40dd670ca7f362e58e15647e22981fd610be04a0536412dd1d4a9e07dff201cd62fc8f5215a3e4c69c0f16e3659d703d04ceae1662fcbb8ff5e13cae20184af19a814e8d42cfd02ba2efa8b777969a2af5a7ca4a1e78386b76b8f4e38986cf2f8509c30821624871006fa99d4ba0c8273310c6b7b3c086dfaf697fdef5f9967a618997c7795284bd6ffca3a6390bd35e4a7969348e9a0a6917be335ffe9c252b7cc0f15f78f6f8760f7e49225a5dd9d40019ed93d6db5bb758e2b51d7b3d21cd03c23efac58a237a9d6fbe0931abb2e10d2fd26a21890220a4f2ded34e9159c17607f4f8e0ce36e5352a1a875fbb68efb7dfb1ac71f0f54582ed4bb96b9b020ebf71cfb01165744dc267291535d3709174a3de86405be06119701f9d597f9f9e21e172f8390ea2be45b418b590a0e878a024bb0f56affb6936dcaf41f27204da5685b7fc1bbe029a1e654e390fdbc23125333745e905a449cfbe77e5af866138df0d0c821cab4998d143988fa80792c8480208174af8c93f55952b58023edf9f1d46a8332a729bf97e140c2e44fce30c707aff853dc3bb220b859b1e62943eddd433ff997af247582d77441a0fccd02f8863937378fce729936dce01929807e553688feb63719a76f86547df658546afa9a4d49b6d5badcaa4106856b0e13fd267119f45e44f8bfd1325686bcdf52854cf3151054d66f3b0018f5ee30dc9e3cbeac827b5438c09820283f554a5a63b66f2b6f2847f202b96a25bd9f8f28907799fa4fae29349e96237d89ee30ffa8fb694012a3cbe3b53d66e60edd52a88851b8acf0c566e6db6fdfaee27e8e5de07cc809dc525efd1403a2ed13068bcaf7438fe79d4bd36632f1d1a02e99d575362840ebd1e384117c23b2a2aae4f653540d5983dff9af95ab58ba0e8da2f1b61bebab8141dc7b9149754c22dff7c87832b6f70ac2341e4029c68cc1b4c3d9b7203d26f245d97cefe2e6264c7b3d7b6ff2878a509b95608f44d2b5f7323e1f2e7faea8896e4724689e18b40a2edb23f3cf4702f6aea84cc5ed6e792b9d76a13b40cd9bbd2ce0260a5bdcccf3bb3d6935d2bb007e2cc4b892c9e7676b66f7eea3d8febe1bec378391e7894f4b2db0e2d5133d3fe89518f3e844120887c651b04f8364a39e76ab24489ec22e407412fdf9133ca1b9baac483772e19cff151b27b79c8dc0d0a814c24cdccc8a37213ef036f6e8036f5c23cf7a440a75cd1aec415b71f2c15a4996499d4a18e1c3517b928f3bccd60af79a028481dd95297b999e2dc2ff26b57598ce38f935af6de042dc483ecad274d67ad34cb39baeae81b21e78c2407d3125e3198003bcad93c2734e62c57c9d5a17b078a05291e35cf1bfc2ff1e686b2d131754ce007c5f2a2c0a635c746fbf3645e454101049ac512c686394e27d44ed1a21e34850fd7dcf70ad9598917b4a0e0086608e4361048faef55c1a1121b4a14a9c36b0bc7ffbf1374866eea349d1d3752afc935d5c55b336b101fe61c93579d7e488cec7466e59389e15762fb7fa3c03084543f69bb3e73a692cdaf656d2064c3aef36d715ba5a59af6c54d0b6415d6eb745dfb4a2fe6b6b53df3fef9cf5851bd1c0de153b9445b3745cca751515a88b4f4a6f23f44cfb62b24fe2b2b9afc1c4d98878cf22cea99d7e4c610e4316ec06b934d84dbc5e77c62c3938683b84398cb82ce4539489df04288c1fb57cf1c17825584f57394856e46790148e8e1ad0516bd99019b9ec47681f2cd2a56e641161af06a652ff8d835896c3168faf6cc17e4f1347e9c46ec0a4293a6a9ced1c1e466b1117a52f2fa21a5e71459fe4b77bdcf09d0344bbda01980d7e69a9ff71bf05de430f83a693e0a4a5cca668cb38a7ff5470ffe1b678d22052f4d7d45cd068d8d4a98bccfbb24b864b992ff704a4ed4995f5fb2bc1ba606249a869a207ee05a0ca8e9f7b7186ec23930e9f7c5d96e9eb9f1a467eeb29348354bb2d904b8d35203fad110a0708453bc1d2939b9df4d85d3d27611b12c7c810c98c1ff519878402634abee52bc87233225acac9d4317f3bdd1238f0a83ec3c03110faff23b63843206cf6f191632cc231cfa087db1f5ee22d9226606a49ec3d3e0d7ff3a2257e0193c72e86e4a87a58e3c4106bc0914fb44d0a7b0a11ec310d586a41b766e3a821bb763b453b42ce60737e4a5c3d966a3d4d82227c0e6247c9697ff6586c433d577efdd93290d9484d4ce4d7cb972c8dc0c89b0ce1512756d2bbd2bdbbb23544c76691af2eb78890c76ae51d086a952fa40a7004c9d7f5ec6387c57bf9a45d98c433488e9b597b602fbdf133644747d63f7936624699a6a469a845cfc65d51a68b0726c0a71e2173053c9bf048d15dfc4826835aeada3ae65e167b6999ee951874a76a8d5b15bc551b1149efb2393c20ae8c930a737cb6e753262da4421fda1622b688dddd137935998f27970daaa6fb4cfa950ca093700a709c2cf8ece31abb06670b962fb5ab7d251390679a5b134cf4c728d812d1280f323c523dd8cdca31641a43c4db861f778412bda58bfa46daf612a5bde956b500a64467259198fab2e0fc9ce3b205d967304b5098bd1dd22a95562cedaa9d8edaeec298ff73ebb6bc2b8bd53d27177af9ca5c56074bc1f1ed1b06bac2bb8d37f88173361ca80e372a3628eab0661957a426ee2584ea95bfc14ec6aaef36307c3ecab6b60ad2c59eddf20adbeb4d31ad7158425bbd794ec92d8cfbfe3adf67a6ec37b22ae48059b320d5ad6995229821b748a70e1b4dac80398b49493eab2aebe16f29e43ed8d89a22bf51e1e7aeefa1e23fc79044d68c3441f0071bac287ffcc2afabb0fae751114fa1f3b1279866ff248f5ba47250e043409e9da0cce584d89640d075d27e3bb988814b69694c4440ce1f606d5ffedbae1e40d5a12d2337dbcd21d0f00fc6aea6066460107de09fd7db0c218da697985410773c2abe7c96092c356d1355f36fafc792d6741e3734d505583193448cc44ffd39a8acf216fc4014e9fece0d47dec8c53f894c278169ba943aff36255f7c7fa74b96162cd897053d237fdef79e7c0a1bbcfe755c12b5abff814e7c7f6f3c4883759c2c8b62940001269f8b4a5e8d9cc0d1e2954e5d09767453fd3ae188f10f7158959fe67d33c30adcc08b7a52661202d6ca38f6443380bd16305376ce97e347e08e633a2c558e463b45e7853c124f259b6cc6ce0d07cab147754d6209b6c676122ca222cb90953af3be09c03e5600bbf23ff3a1ae1c9fce6b04a4b1e7b215a87d95588f1c9d931a182899bc6be64154b0b4d57e16196218160b00df4a81f61af594d8493e208a19b0c3736db05b0225c84753000dd3274e6bcf980ab657ee232245e511c7dcc2be487d39d95711bd974f4a05f74ba1da92f423e62853443f2d137dcb04bcc8dbd1c99c6c5caf39704165c55b397e73719933cc7c22f5b888e4a9821a59e2f7441df9edbca945e68e50dcc02657d4eb94679e056369be9bcb3f54559a9df9ace97b633accd7dfb646225097c656ed95edda402cce2deb5f72d80097f39680ac038ce6d3084598194d0b6f977a8509b8c85627d3bebbbe7af7a0df7de3175579119bb74142c8d562ce51ad71f855294e244eb555d9d3ca780c776f5918993ba2e2ec36c7a27b2e7dc312724bf8cab2c7f71c33d0b5234502b5533a64c9b00f2b4ecf621d3e23a8e1d2ec51a41d35284c37b6394e22d700487ba485b7481ff6db1c861e0e9ec968cecc4bb2722110c395de22e16863ca656a47a61db30de1da53c48b1f8b2e1782de02fe41d5d2cd6506dc674e4042f3ec4e5d257f2a648a91758d5d46b1e9b97cb46de592023d7aa2289d33704ffe39163ffb81fe8d8354690eea2b7344602403856c4984f60f68c6838db7e4dc40434a045531fbba43ab246823a537f6947350ab1a67a2e815a738f1bf3507b85547b2844332f53c096f0afad6263dc670040f699396119248512434e0d8fcdb4c0ab82f923702b71cccd05829fbf250af30f121f18c327c48bc21e5790cc5e1eed5910718011a92ec00687434eca10330d4a4308b83bd78c166cbefa48543a19b0998a559344114076dd80f1bac419426f18de59e68461a3184f523a9db8e141eb4997eda116011d3cc64acd0924070a8a259855109457cf2222f047105dd01dcf0a8992a727ff8bf2b05cc7b216a5bc8ed86c73b4f7771dc08ec1563050539d19ae2eb0085170ec990d51dfbdb9c34c6167770d1c50ac56679f5e109e1b0dd4f79dffcbf932a41497676e827edd53e233fb8ba0d8af99947cccd522bcc771fb33b14c1186b29e8b4604397ec6a48258aa14207704bf97d0d71b7c28939cc9b3fc2a82011adc64a14f37c4e624e12c6973a4f9ba066ef5eb0d927f24412a7ea1ef5e39bf5e8956b9c10cbe9b8579434e6afeb0923c1fca8b6f4e24ff363b3cd7298eb871fc325e296c19d9727391125472d8d1e64e08b7f71bc3fe23716cbf12fa393c6711dab1ee58a5b59da372e941becf9656581e53ec2d381e81a1925f36013680581f988d4945228afabcf5cde4e3ce54ff87d599d753d3d3c2bb69e297c95c802da79977d3b7bf84fb688f671e839ce9b63d44d4585d864f11ae4e11a2c79456caac99e87423d02114a056febca0edc0f90a9b5888beb5beedff3951de0b0cdba645f89e7c45b11ef312c41c688d3c38b4dba1384b616ec5d82bf280244531792005f30af7d252c08813e47aff5555e60e4b20501e180ada389683a569b82fcd6c5a2d80cf52a814e8f02bcd917374da05c7693938e49adb92488c772f30ec53efab7bdbf1bd1fe30420f8cc7660aa458bc95e2dea69629cc8102abbf267888607360c7494f738fa1f783799d8858455fe69453b004ec48a8cf972a3e4ef2d0b9f2d03f1b9afabea4bbd09d7d32237e29da28223f2c3b1d16db1b21eb918e44ad8d21c1408c4760254a07cb203ccd62602006a1e404f2c5d65ec94409ccf577b493af9fd750bc5f94da1878aa3e040e43e5d92f4e8158a35ad6479358d0cd6f761cab5df3356084a7159cb3828a8be947d9ff4e61d26d56fa42c620983047bf101e642e0689323eaf994059eef5406d6b7f736e777706b3d0cdefe53ed287b8b59f5c261f287e13e3c67b08898ffde699b03657ba6b0c090096524a0a67fd05d1da6252577b9bb6cb3877ab566052df1ce51a113ce621965bb264350cfda95ff001d05e246377a7328dc3bbf652862d5f98c3c0ca01f0691ac9b17da984eebe2af69204302305ec8030eb0b556f603780ec6d1391d8f2e1e7c57d288170dd7efe5d6c588781610741824d10a72e5670a50bee9798254538c9e2b2bf35075af37300f74cc6bbb52855b840c3b760fc093509a1fdf8924b66b0d421ca33f348d113c66d5db9ccb1a17fb93bde688b3da40f3b8dbce232157a75959795f946aae5eb432b547eb841f4515d92e0872676e69ca12baed77e4bd650addec2e01b0d48b39f63494d9671f616b71c48353cc72373e4b2336d80e5ca8c3915b2b4149a01a7497ec339612e2b25bf0169a78884163f04dbf8bed2d5764f7abd4561f160b568e1812bccb9b30abe61304eb9c6e8c87b212df18ccf5038f270481ec1145d687395be4c6744a5f5b8b1157c7435166d5d0b7e6b5278548c609971ef779dde65f7894edf13f9404902bf46775bcfe5e8b68de0c29cf3ec7556ea1f4a665009836aaa28c8ba3bd3b174f163ae9440e62aaeb4d27ebee9352473de973f1e312981f07025f217b4c185686680c941c022a0da93c64bbf2f47c833e53265ef1a640e18d70a278f867cc7bfe7dabbd83e5443473ce923ecc4c75443b8e0044a15389d88614eca261f7361ae74b572e28f3adc803d78efe3e5b124400ec661f26129912d5af7cd82ff4139451e3ba4a9d74cd8c383c3f1438990d7fec887bce652086767636706059ef292d3d750276e1165df9409ab63e53c6ec817e30e0054a02027e521947203e8c9ab4a44dee26b7d3b1aedfe5151b3c27dd3194695c84d8ce3c0121891b2baefacdf16455c201495c5256af34d8b8c9052661fa4b26c93b8250dc9be6683c8e4cedec3b5b39ff3a66c5b226f2206228bf4383df68f9dde4cb06f6ab14e92b2bb67e1743d1197795421ddbbd32e9744eeba932c1b345698a08b1a4c5a1194b6615dfbb0c4233dc1225725fb1b1dece0518224f67d5c6326af01fec0a9b03cce1a7baba072d26c065bc9037fb8f78687fde8d7db69826127a4a2c8a3e7b3a74c9e8397bbc38db569f0d18db5e46fb9fce6137a036e66768c4d43938d57e6eb99c3dbe9bd1918d7c0c63fafae655003905dfe266cfd86dc42a46eef6548435cf0fe8f39e5f8337f110d98cf2d113d0c261c73589c688f0600d90d9f86ccfa1edf0cab1ca5600448fd1c3319e7b63fcc0a425e9bfa94af3f788a4158f53ce260da135348884efe475c178e0625ef93a5c4b36dab4f2f106c688c4745d6d80fe19f40277e05e44234fc71fe4457536a5aa25379c990814d8a55df65082761dda69f4d10e86d7f4fa52b3cb84790166b7d5dbfc65da08e12a610a06e197f98b3175f090bba529eef1c1929f4568d276148867238e62e0c3a4fc5e53b0cf27ac099cc048ab8b4de7e8dd1509f0374c4a0d467a90ff2113e103060ba6421890d6f59f2863af257805061aaff8fda9bc089a95d9a4fc995517697ba9ebac47951f92fe7b48d91cb1ac583b0fe76bd6d418e4b9067c0df27f4af4d752fafd4b4c48df9ad286f2b16a91db758800a59cb80de06a880982301407bf4549b369f8a89f07566cde30b51aa58c5d1b0686ba029c9783a66dc03e7b9cff6c30a5d5c5e8917b62148ce93857e02ea8ac36027980bb5610c834ff82d5113e939c957cd4258707c2eb787116a9563cff65120d6ddc38a47f86cb4ac01e6d9af99c259dedd320545e338ad054272e816d77e05f37f7f1df9be7e8cfb52f452c49ee14a4d916c698e0820c3eaa6187df3760df4e119fddbc1174df7e379c46af13a34e94209b423e075afe6053e17b38fc0ac87b16b902a62adbbbc7d71a0c15d69ace1d4bd48ad182d1eef0f3cec8e1e4aae8f2811f7d9512d7d682f0d0b985a27f393b75c1e106c48224b98111ca9ccd70fb06fda709beaead49c58d8e9a161c9abf950b8048a7ee9b0361bf294d55da21a9695e6184127f13fde50e59f5ebda6aa06761103a4c5a77e06cc5efbf6987876aae47aa8f485ba18695769708b2c147070c61c3d23de8e5a3482b7606fd3342010935416e8caa3a26e915ef736a88a40953d003a5930a1b316ab2ec15ee439ad1e09712853da1ede491b6270d9ab57322cd37d794887d6512c27ade5d1d4390bee2c4bd9c7c4d9b0c0ede5b060861da85195bb8c4499ab5351474cdff546e0342eae47016810ffe6b55ffeda8f2f575753ef48fa2f477a69b46af7e76f064243d046b87a314c47e51968c1cc7556c94dde4f6470dffdd771033bd59a713d648b16de56228aded4c5e3ad6611ae1d1b9a3709d552f299774da67a81f81fac1e22ee66dceec08684f22b7501da7f5e82ef648b6a07ddd9e7e3d5ac766d47c6dc6445d69021d7d69188555b23f606be6ed538b10ff49fb113ddb2b2bc6c67ebc787fb41dbd7cc55f16fee9e5ae8c2a810af0a18727e4efb1252f612e2561bf59c749a7914d60edf0af86077fb310f5fb486d6e0ba09b920f4ea9aa01d5835d4411d63dc3d353224066c2ab58ed763eb8aadac995841611d1d022ddb779f9892409ef72ddca810c99b3fd9bcb6f8aac60e44df343e2b5f11ee9bf051f61b81f9f247e6d309cee9ce1a1a322fb1a63f9c4e42979d12f6917bd6b23d27d548b9d6c244017fc43a772f43169000b6e6013c911f672c55cb8fde85aab48710dcb75de2787a6e39eaf41e848ef5e1bbcbbd4b2280b83b7ef4d6162056fc1964d3714aaffe99bceb0fae1f2865c7da04726082cfc7f282e1d5dddf4832330c281b74eb29dc827982734b7cc2e54af8f96f1cda74d6c1f04512f40e746a0813e4c94b04d0e5ef4ccda5bdc4be97df98e28c1485ad9f598179e78864955ed6a12da8a3014883f989c7e470f16f7e70e79ca4ccd38fcc1bb35475609e2174318b7382b34f04b8c4d2a67825a4e25cb97922c19531f8a8b214a0a0b6dcd0b083cadefbd14cba440193cf9b7a50bae7afd713126c8072ede522dd3a761a71db1b0ab0f633fbd644ffa7371b8be4759f7024714549aaa1f787ac6860950ce245c98b81cbd643ba934aa314c6354c2d529b01e2385f348b73f5f9ca60c9617601649dd0d5377c38a8fd9057580f1b53c691e2ba3e4b10c5ed7a87b1071228acb5662938f3092ba663e3fa78e997850d7e6a50f4a5dc2c20fbb47956302ecb92ea95ed4c11818ec28bde4699aafc981db8ace72392a87663a4a87b4b0deffda725629f8713976e2a4ebe64af5c281e5a3754bb43b21a2e15b3c428c8e76d308b2468bbaa5b00a63c67aa54b463249c9a480bdadeaffc0ae6356244947de4ec1ce6511f257693f708d74a6f7066c9b9e850f078377fbf989ccb54c76527075592ec0e61912bdb230cd744c62db6f6ad212cf632bbce00a51bd9b0e6af7f7483e8606e6971284ce1281cc17d951e40c047da4c041f18dd870a74b35da2b5eac70098e804d18571b6cfc972279c7ae6c89fdafc52d254e49f3ffa71375298cf62ed606527465747f4b444257b26060323bcff3bd12867e0fd4534e86318123f07e3fcbc9324b5e725ef7860cc6eb7223af0f1d8ccaa46606b9b9ffe1fd45cad385fdb587ce392ca76212d239f06a516b5a1cde2a9da96e2f3a2746792c6c017ce0cc2d43ed77eaf1e499023c714c10b9fdb0aa584df60aeb9f8c8eb62bb3c1c54c32f5c1682267c5b34d97554ec2da951fe1a353076991e3386ee42d7df5ba91d8a6cc46a4acdbe1a45de508fa70fd25b59daca2b01c2ac61b8a58ee61eca01174e6d13381077d5484e7d286f461277bd4b83c5a3ec4c7573e584f9b051ac3003f1fc8be171c41824bd51d2feec7410cb4daa2b886b0bfdccf0ae86c2f03b8cbbd64d0f9a0f58b410490d44bb556f245212faae83a8d6c8c94a795c8258aada17e2caaf85caf7b69ffb867ab6c0f822338567bd0096212fe148efce81e6692b8f9f61cb8ab951727092ad2fb1b0c51e871fc9aff0c9abd4e0628147b5fdb9ec47b0ea77b79ee9235d7c342b02fbaeab3051cda47ca928b1883c0fdf8567c4ef6718050ef7034b4b81a36f62a0ebea61eb335761de19f63daa61bbc8fbc4231915dd6e3cc07259699666eafa190ea82e0c80e5d69393a3acb208511d10fdd49de5017c1e95b0a0dcae40d29ef04ce6fbe3ab21707f85f3d17d3cc7e2fefb5327469c32c3bf2909942a2b6ac6868dc115167c0dffdc5f96de8929f936c627b156b80fdbe6400cf957cb15bbe805d52862a3598c9cd819dcd49588514a00b71daecb41d17453ddf9749fe8563eb1199bc0f3423389e2537dd0769dc37e5f54e4743a4c17061fcb99ec4a4254e47ab4aea44fb69b2d9fb455bdd3f8c3b764ec776f3e0c6ed7d420167f8cfb10803039b7183215535ade62720bf58dc0e7239f6c7e8c5b87bf232584d49e22a8f3a4743bb903e6f2b9b406ba9ac8970beee226be2deba93bcbb0c746448cdadb397272461baac7ff0e70c3b5fda5575efb7e88f32966b05222741c5800fefe3e960a49e20c401dc29e23717146f581fb8657bdb9472a2bda49645c6d1847f6d5432cdbb5c44ccfa763cee6cdae860bfa10f8c93238f66d777aa56f1e12abc4904a3a341d363ed1c3f088d7b73aed6c439318801b5bd25fbf177c7770851c38516172a16e887c399ed9ccf31241112871d946e973c888a7485395d881f145eacce36e63616bc6152091a4b5a2e206e02ed153e18bfb7837bb424743fd5a1b44883a6a9151fd1e78834522615145c69d18f436a24a9214c001a067049dfd3df536f00c56ae7865d1a2bf6dca95608b3d84aca5ba4f9019456ebe606bab39ccca4d1283c932a3367076f3eb4f957cace69afec1692451428d56f5027442b207bc519d29e2d2f0359a0bee1aa31b16c663e34152fc0b873ab0698aa782046b9c339024309f57409f8cef696c8980780059d2f40978729237586e42f873ae88c71a446693eb95bd378df54ba30471dd2d3b4e901b396f690e618abd63e80c25bb670c837c792f54cdb4f0b3eea349647be73a2e6ca5e9a994c892ac5e8f63e3c1293d33e886dfc6559a50433200021934641e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
