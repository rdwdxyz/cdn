<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a177938c38e19d0b241ecb5d43d0f621ae149b2bb2a719c0625ee1a323bd4b2ec19e327b1797e8e05d99a315fe6c636fdcba195cd430a055b450234b149124621939f575e8210b7f771d9603cb7ac7092f053670711be4578b09eeddf98bf742e056d9d8c25d4e04779e8541fd3a9ca163f0b8473512abad91b9dd7497ccb61149cea5a8522a3fd5027b79268dc114953e1fbdee6abf71a8fafd77b6de9e03608d276a1a46fb9d33ad6a387b765f53fd8e51340cef61f0f60110bfc048b5f23c03e4fbf44f6dcc780c5d19ca0b3d4361efced8e4e6fd47bd470b7f92667cf5deb0962db131adb859f02f283567637d83b67573ce9ef127e708eaccc4f9a9a1cb123e8d9aa1dcfcfc6fe0014d4f9f0e15d20a1d3e7cf9b4dd6c49407712f9c5385cb6dca19f975f4c50533bce1bd1b2e9f363b102d2639a82c95077112d3fb7909f6045c818244cbe9dc232c6440aecb76f54efaf763d0232ad9646eabded43fbe5df7c325c4a384346eda45432e3249c99f3afec8347720fca2f96736b67bb2a60c9c25ac35123aeabae3b3807a5b06f085e8e19fe3f2da14c63e0f0a3cddd6097e495e42fe3d937c6f05d9572b160d3e57a66f1bec99f29060623820fcaa05a68b531068721c60c320930cadf6bd8360363ca1cf6d47f1fb2de6acf8fcd4888ce523755c98ea0f6ce3de0e9be6f2518ab0f0954fa81bdf9e58575a53105ac1799917a401e5f313dea6f917bea886939a336753f0e053b60b7ba3f0ac247258620fa7c8e2da1cbfb57db3eee1ca07749e5c046bbccd0132d47967f6c6b18b684116d56cfd639a5b86acace8a97f40eb5166d6bc99df618b964b159dad4eb121e614dc2d0ff0f33b5cfdb4fe32a74b9a06ae4ae2c9621f0bef5deb64ae245be93f272b1899599eee0f456fb0f86c2dd1c767e26391372840bd7c840d79a6a18def0b22a5f50e9eba2ecba76ba4215d16c0c5148883a8a7f6e79bb0315f08cb8c93f9288f08792be38e5566c824dc83222be8bca7e8bce530f0aebe69dd5e5c0e16b8346e6f819ce9a090b122f3f45929147d042f9b1ad57095ecb7df0c4495ecde900f246e37327f974a293f03a3b0b88dd342b5a0c5c8008e761a5600408256ab5d9ac8a56bdbaface17c7a3533fa982f4dd2b43eac2eac99e2f8dfca2d2169c65ef5bd6835fefc0abefd4cbd9c3c7f1d3d3e14625442eb2be4bd6dbcc87341fbaf53315e0f3b1029a3f54c20e788cbadc574e1a78904d6c17703a609f428e3b140a42fa6663d6cd4c621f9541d4c944966776babec5573ad9dbd5ee903225ed7788677613e5f3b7f971bac24637f3fb9ed429b27f6e986234652c09a4d1b2f0342d69f4060468fa211f330fe23e97d8f4a9a94c66065e037a25e79a9db3158fe7c0c700843d6e9508fb31b9171915c5c703dd5cb0f391e095f3a77cc142ddd225b57ee2f936ed1796a71909b56da891007d33b72f732155ec84ce6c316400cb826f16fc7250dc51723b02538c144c4e0c56bbdb21dac12ec6365d32597ea63c90e2d6c9060ec7627f8b6de67116a0eacfd9597b72b07ada2ac5af3634712d81f8bc73105d4251b0a2c687fb8dd31f0dd327536595cd4b58b34db8bef582dc3e739549d676d5fafaa75ecc51712499e71a7259ca3620aa61be0f2a14a018bb8a26066f5904a1d8b55b3462cf18daa9d5adfb82e9b46a329699aa728658c27491cddc26bd01ade4c8013e3d18913b02d4e40849539bdea59a824c2c96a1fa5eb10c6b39b94d3634f760da65620bc1e3c5016c5577dc83ee64cc68bdcc262180f50422b8b1d0e99ef918be7904c3074b5df77a8a0a912f3500991a310f1e9d8957fde9c8cd12ec45da523aa9e6c46ae866a4335c8cfd774d7117fcf61e6a7f85f5548550d610ff0c0fe0b24164a918e967909c3755129887efad733b8591599173b44a0142c4aad2a7dcec83716ae7cb36f574ac7d114d04d01380905d8c3e23ad704253d3a065a24bbd0442b6f95c08a577f939d337f10f1a2ae386fe8afeb61da7722f73fd7baccdbaca1048392907b4033d5e2e9798ab8565725c25847e23939490d182a9c529eb8311fad16df01182ea7cf232ace08278c4c41500e4d1d11b4864a7ec0f0bc1db9a7d86b0beb2cbcea741a0cca3e4467ec119d6a26b8db72c2db4dd10426c2b231151755d7e24798a8e21d91137cc36bb9a5139b242face57bcf5b797f8f4027b5e0eda0246606f4b16e1fbe538535288ff5b02d469680a1edaa1d841835ed2b3d5573f33e07989fd54b0a051cea8925cc09b8aa8ac473d0a1a9d04f7954f0984f615b4b56fe607ad44f95a8c0462f014715e0bf9cf2d6a1361c009ba0f8dea59b0d0f8c020a26ab3fd5ad5705eb7d19dcb75833b0062d27ea3aa0998ded11ae9bf3922908694fc2ffaee23d8298e68b00d798e8301782e24575aea650bdcca3dd286446cfedd5c7820ab783eeb38805015af0233491ed640c79571c4c42667fe852f207af046f2d4ca802049f3473adc6c2a884d49faa0056c81e0373d07b165057ee29f15383e5a57259293b17ad6537fe07f04bbad1e07192a150305d44b57b68010707291bb026c202ee29cb25548c20cd2c4afa60773a0ae2b183e5818eab3169da0d2710d4576caf1292986119d95321eae8e3ad5ff1de7a4d6facc8ee6fa76b3263b19bc097e448e42de3943cf2ffd20c2a401d18df4792f6dcc044cee598918d6c60019718a2ec9e18e18f31a23710061e5424319b104b463854a4a937af196ae8ea33f2220973033722718b28ec8a92ed62c5ab5de5ea672b24692ff49648cc492d0f5509312f9b8b5f4d58dd8f04552978b2da07ddb4a097404b0054e87bfc8246bbff021c2a7b3eeff024c1f3a2c40bd7838ebb7b1d6b643ffbcc0f8b36dae78fb024feb148db902f3f9bbe8f8f70a7ecd2187a0001089c4203bd056f6cc92a01a2029f545ce376b6444620d914e6f962b66c4b2bdbf4522964b71aa9c61fd7c32be44ad33e71fcf2d06510d9154c2bd83f706f1c579dc3aac10c52e9366f3ca747db1cae5105025b22eb7a9b23a90849fd3c5ea83373096f2fdaf985ac066fcf4e6bbd9d7cee0bea4d5460c4bb42f46463c1ec63208f6f6b9bc6f5cef5baa9c52d74bc21b7b9a5782e26d6102431b65d1b2df5cb664e305f28f9ad06c4f37cf3bfc8d6076e78cfb7a0d47ac8b17a965ef11376fe8ccb95e07e8fa2c242f1b03917db546d8e2b4ac7bb6e2aa7f253fdff102b73e29571fd8cced5fe73302ad3e3214f2df915278cf43bb0a73e915c8bf8165585fe4ae2edd7d259c7c274fc4143b04fae63dcaba06f66a84007643541c830f2d3d684957efa5a243bf994fb5e1bd013af49384585320d85e92dce4c74ab7d96a1dbd7be29980d55e490acd7b08a9a7e8dd3d481f05b37caf72e0e5fb093a1927a7e31f36cb18f9248026fe940a788d0ac69ddcc31c0738dbc0c31fffdeccc75c0c7615c32523479b54c7546dcc691e7ead85f91bd52649f6da27f8eaca872bf2a4a4377a93d7132914dabff2bb5d17e767de0d429527a653517691a802dfbabe20b7c6836a30e6eab90f22efe47cee3b1c7458156fc829e8ced8ea035c0b3dadbf94c8e956f893b6816579ebff023c87bcb7141a70d7873e7df310f30e8e4c6bafa995be4008f21ce6635d5664d6f9b8b0fb30ccdb1b3330c0c0ec388171ada620e56bf1476dd045e3150289f1ceff9a5f80118ca0229991b1ad9b6fd424bc6da78b6d1e70ad25200a00948bbbc549510fe3c2f42170dd3227a8c34a23f9d6211e97520cf2edeabcc02ae4cfb74f74e13a2c3a30d2e038e0f3d1a788fcceba3edaf817f7b68639ba4a876279294dabe82b544a3cebea2f495bf3fb1e4fb1d43b32b28197f4bbb1a9cd8a4d17349def2a40c738aacebcb7a8ddbfcfc751f048eb3f10aaa0daeb3c40b8b7bf0127173cfe55ffc96e2b195424e9f366f9a631e628f5473d8739461ad5eb1e2da95a1770a0e175d7c7895f650535f78327cb15af4073fc43c46cdb9066bd8c92a15b6e9e89361d89938a3a5db807f8ec5769a5e520900ca54415b1f3ed3feac94268b5c8c99822c518dd3a07a135792381d71b68aa304ee4eb1d1ff7e324a57c98c928f50ecffb598d6a83395850030f6ec8b1f1f8cd5a279a8dac445e9be1aac39685232d804f721b8a8020e8d66f9f9985bd1a510180be2cc4c1e92566dfbab638650b3f9b012c6dc36d7ee076f1eaa6dc64c0cebf1891b0e6f781403921036ee191dbc4bfd7243bfb231bf987db5927e32ab5730639906b297a0a099b20c539889e0b88bec772f603320dc0e5746c852c048cfa68d94e527647dbf31f7cd3ece3729632c7aa7136702b05ce217256c25aaddb917d26aa2ff89877bd6e3518a390170c58a4487ea43d2b002203beec0dd497a07ac2d231ac0cb3ecfbeee84ed3b6d85105ee06abcdbd87c60692bc9b878343be5d4c1972572bf4adb447ddffade4b75f247b0a72f263f7e387282d33c791deca1d562f5c7241f81282c9975c54586138206282cd71ab048d2c0f130c2082c052b223349d43bedb155aeb0f20dc002f1a267c0904cacc0f37d729aa9db3faff85299cd65252ebb23de6c1d8311641bb042a7ce2fb54372e21abe4e67e7778b6b77652e94f623752146ce1b3e7a06c461e8a0b266fe1446833d18a33f53d78a6608babca8041101e3635417c1f1b56b3b32f82dd34d8c9632025ee47f86e4783665d8304be3c8e5d1fbe12ef62cc8cfb9842b918395f2a62c4070b2ee7553ddfa62cd03cb214685739381acd32e055910a498004fe44ea5fe46edd017e2923eeb4ac65e0faea27037b2e28a254ff3f0790a2c03e81d845236260d18c22eefbe43fec980004844a8c1f42498eea4c19155c15da41cf7c118686e43063c9e437f1b5bafe730f96cd9baacd1eeed6f41c22f953c01ad1e005d5c40b608b2f66c3900ab8cef7994a2f3f90fc3c17637244b3c19ce93aae89e9edf6e9c4732e495602935374e3cfc93879f18eb3dce351be914c8e6f7d073ba66606d5bb559398164b54211801c6017143b4e3e77bc327151aa373aa478695ec664f03106c32d261da23a2f557cc920fe542e0582f0d88b66b33cb85aba07c2ca25c2f757266cf3b0bd423f72a4d84c7f8e0a5391c63f3a6a59efec0d264ab5d69a7c5513cb59c4fd474436cf50a218254ee953f3dd4222e1b57b0abca4e84ea620efc10d294a504c37115d2686c95cbdc7be78f77dd586abeb158dc86b86d777102492fe4a10fc8fba5336efc7d2b381aae3b27d2db1b2d81e536a5ee475c0d84322da08f9df298c15eef9526b5fe220411091537795af3c76a4f919c0334327cc120656ad01e6e5f2a21867263a07fda77cdc8795922a41f070e2706eb69777d6c9197ff6453d5f0bb6e7ca1e06a08c605cbe56f1fd286291653eeceebacaaa5fa3f429f2ddb1e32cc2feda0dab1d3a20a7806bfc308c3ce2c7f4321645356d412965b146b119cc3b7ac657ffd43e5bf84fdf23c2d94817daad233f12ce6e47b74cd792c686c8e05691fcaac6292c9e6c548f8ab6078fa48c228911b55f086cd931b89bd4a110bce0fd5de56be398f8f6330c1adf5c66ff2d97c6259b4d2220e731bed6cf8bf65e817c3870fef34dc1e5fcc12e25b59d65e4c689c0a18cdf42845c056acc77798435c619c78d7a723dab3cba0a59ec315b54c44a6ac88b33d4f95bbb4d283e5b6a4a23a6eeacb2aaba93c9833bf5cbd5b202b410ae7f6e115a3c5bf23a413f6612fbe99f5e4f11c7b160d334d579eadd72a69b1c53aea3dd796ee93680a2340a39592c1260fe58ae114b1bf8bd1e57529a469099021cf85fdd1e2e4a1f632dc4ce7facc20ff1b968c2259107b87dffb6d019d67aa7a23aec851822542012b9c342b9ab7a187f2c73f791786919fcc1f4b133cd82bfb7f65a4cca07d0e7dd4cf38c819cfc255e388ee902f59c8c6f627bf3a22fe571022a05ec5d4768a0495a44e6ea82ab248bb32335bf0a6cf054502b1660bcf63b15dc2591bd23bd83822aadc3e5376e9900dc0158217835896a7c934d9b9c3933d55cd232f6c1008457b36e86f417199f68830b1ba726d52c880802c6958125eef5d7ce2de1463c4d53c9657cf73f8cdc5db038c7f88279595256bbd01b0622a66b3386128c99a18d41364e74703649c9bef0ce0cbf6dd843a4709852b987b9ca78a21ff805537e365971bc2d2e25f807de2cb413ded8eb890a0efa3118825741b055bb23b68c118cda077d72494e05ae6cd73251570e4e614a5e91c0ce037532af19835389ac2d3a6f69fa88a4f863611f1791d35cf4a0a0b6df687b71bd742bbe6ec1f505e2eb786837373610eb0be2d82996b72d46538b8236325f461b3af9896f5a9afd794b56d5b573997520c0480843c1d0a0854ccc4e8f3929d23717d667088afa61d3909326699f45ef008726d0e204b6439175a7c2fde54bef43816382cf3d7687010881682fc6ffe01919573594f8750f3a0c401c39b28dc966469ffb523f9789fbb443704d722380ae69e24b174cd613cf1504b71584cc84d2716b05a8440829981d511a283e76e30a0a80e12e2ead774d11d2550606f9bad91d423f86c9ee6b95e13901368fbe54b8e726f16bbe01807b3d2761840ae214e37cc6d133c2df86c74b814a277723e33ffee9cbeca61f07a4624cb1d310cc97af786f1bc3ed2fdd5a3f71b76409c7184081602f3c46cb291604d2f97927014a562abd457dc77c31ef885441982d33ff11a2e0e870ebae47f45fcecac254abfda98db819192288466e5aa6fd2460f658a848100069966bb8b29f495e6ef8df82191631bb406680feeb3f12de382e1d383a6bfa071238637b37d30c095d784eb0a9c8d3e19db78b11ea3bd9d0f50553eeb11472a261eb67abe202d8a15c608ea0b818dcafdc8d448f7b29482951a6353b33556b63fc9f57801946d3583af507353329cec47808ee8859551afcef350e01e868e7bafb5aa70f3fb56edd8b171da594fcaf765589979fe795a7fb38f07e5b579f02747b080b9c6518e3ebf2817fe15097535634a854fc0d9cc55a09305bee85b55d9117ffaacac8aaaf09ecd05e8052a9930303e8ec3b8ad5f120084b51e7b9b2ed78d9962836c8e76b3c00be0b1a4ac4e2dfa5722038e40b71bfa62423bf8bacc67ec884dbce4ff0b2c16ad6db77fb49069c6db1561d5afd71d4078607b704725b2000c45dfc6deae9fb2ab776c67c10ff275e19db7e92a8f6c1fc8f896a08a715ecc7ae53adf73c79dd044e0cc876ef7c9af29bb542e31d1f217122856544641f1b6c61a5d65d214022601224c621964e84be2404caf32a39cec48903091528fda52a3710b422d4f285ce49c01af1b35bd0bfb58344d68f1b3656c0fe9b7cdce9ea7368fcf256af71012cc7162006afe617277d0232a79c73bdc4b6383e0a475f81c93ec0f50cf1f2335fb8783754ab2494d290b84fab715118953ab7f9c6ecdb5967ea984a25accf32568f3c71fbbb22b97416375f1c18966a4a1c17b5e8d3cb98a24790e21df9bb3b80e458366d71ad6e611ada3cd6b5789a9e128111b9653ff2a0295a4336f4a43b19e96ebe1ad0c128ef14cc799b53a5dbf7cee09587216823219134f820a3b9d050f11f2a8f4ec3bb9a1e6416e69ccddc28e72cbd79a2ad04014ff5f546e7e4e9dfd8bb00dc2ee6caffbdaddffdf051b48f9ad3eaa41f0ca17e21cdeafa93e75af44a20ef52b8bf0ca6b63ac0834322f35cbde294f2e4ca04e0a0d62d7f1b7371d6624fa08d9214a13145f3ea3dc315bbd4c67a86c6670711e95f39c69d5c2eb0fd147784bfd89eda9e3f8c0a52ddd249173f43d559e75a77442c0a1e117b48298ab3b6eca0088320fbd9e840b7c41bfd0df16479e75fc8d57888544bccee4ec20b6de44999cd47631b9f3c84acfb5c7a77bc4638ba0a12ad1dd27245be8718393a067af6e5841ce1680dafe5f46bb17d8f4acfc156d98601306fd52158671948cfc5e40a8f689dc92a7c40e0356e35349116981d02b54b8dd107aecd2b2bf3b979d1196c7db8ddb3669349c9796fa5f531df92d19d072021d7bf7e1119d0d03b74d01d9f314c19f20906267a56f0105994e15f55a8b4fc306f5ef37b0f19f26507650ff9b857f9d3004be07dbfdf2204c67ec214c67343cf5b1fefd13c129a6f00e9c0edd4e8257e69890261e6259a29f6246a64d96ba1b6f025ac1a90cd6f7f21d4213c167806c51331149635613937ae61972385f9cefd98a761144b2163cca991a1ab2817a74855775c6c432bfc6ef74603361c93355129e55dcb16ad41b8d37ed039c32b01e9981be12625486240b108515fae64b3d5b690e69edb82305333c43817f3181b602967a1520bd164423b58cbb1d65e7c9ce82c124dc21ab9a58c4c59e3dfe81c894a3e151105ee0973bd3ca4cc9b6e00598441ec88c49b7b768c38e5f3bcf12a099ef2c32aea2b0ec0a9216bd6813c185e78f24647411faa0575bc831a2eed05c7469d591ccc3bbea08004de064098e35c1ee97c4c197022591ef5e2831ee193532d1f88d6c5ba479efd23200290250f4ec5d557a5fe073bc8f39fee3e6d345a2f9480e790233443df0ba17e246e5d699024a307ee291184f423662c87514217c8e03e01230edd7e6bb7bcfa2d7b7c9b4b670ef8091a25ed0e8646823569c4a206251bc1b69371f843532cd2969d142a60a0aba6df75608634e53a91c2152127c0ff231d5a6261ebdb420e8959f95dbf4020e18d243496a080914e8018b0c2452bac25c923529a399bc5a74f093e86c24f8d70709f27465d765c9bf7558877dbcf559382d2a609c11ac30bd919e6333e60572183830a14e040afb60b1712b4032ff0a427459363e1c501999673de8f1b7de5b51783d9757b5035af7c8a047539470801181227a6c498c5d7bfa6a50e3e8d83c7e8a17ab213d324c4464f58113af43ec17eb9ce5d52fd48255a2c455e93e19346c1ae5f91def40991abf398f434d695f8cfc5bf6cd52028d57b830e5fb7fe875d67e7ffb2cbc5b02e1a833bc8e831886d04c75a3aa333f072875f79af39e97af04e5fac0b46a9fc47c2015c76bf2e18379e205efdefa366bfa74d170ff519bec5c51b3d2c7df577530af17887bd3f48cabef52b7aaed9d18ddb036d2e41fa93e809593e5812842ddb37bda288d5b04c99f0b30783cf97177b8cc47bdcdcd02397294f8ef91a2d296230b692c4dbfef71a964ea3c890436ac2e82596db9d15c3f919452ca3f0f3dd8faa5cd166040505de0ef276ee96f57c8e80aa38b938811f7aa1e37a7c44e67e20019fe1c4fd033b2a05d4b3d2a7778943dc8b9c1bf95468f5f6f3b0f1675c143e26a35d352f5a7baecefe100142cd88e86723c0d807b1aa6de358a1194a820474e95250d94cd7a0e254bf0ee86787e57696b0ee09596b29372ab655d1829f06e845a191404e40d5e63c2e95d56ee521d52a5a8a20808fa764a0820c6e1530eba3c015b7d930faa7074a1da9670de45521054f9c14097773d27773a3c657284747c85e3d5ee8912a4a627762b63ef2a37b716e1a5cbb8de120e26d80da490217cb9656400892dc66490a2b113dbc43d8d2f783324c0dac7266604bf572265e4d6badedc059e6e5bb63da2265de7bf165cef58db393566928b431db9382c088d6a19c56effb660d19546d4791a4eaedd4f4e0f2f347fe5241b9c04ae3f56c77895f428239bfd3b7598d42b6e1b6e183437ef4137feb32094bad26961b5914be93b6d0939d2fa58c2470b48fc3f61bb6b2b6b5c3b9ebf6235e018260932adbf7aafac53c9659732711673ac934f5a5db8b6281643a2b2136562211c8fcf6d23652d7a3e8853b4e8a162e566c2bbf3ab963c67d3cc6d5d01fccde42f04ddd8a5b9bd7f54f6f0818c95faaf55b141d5967da302c05d9f7814a60b363b0308b5e96136f9536743272ae7e804386a86552841e3ba012c17e954200fe261906810ffbb69d4f212079bcb6b415714aecec28dd6c5d1010698067e2af349a15ad647b8cc7f447cc3ce030b367e075456558126062cb36a43eea61d4c9571781a96672d7afad7aebe216c685d42a0a5941a84be264d30e3469a8bce3676f2a45f52951b0f726cfa34d922b34381477182a31b785a14180bb0cffa823a675f081a96abacf389e3ce11100b15fe0a641befbca4fc2d1bf769cbaf1a2c5402d0f2219ee9f1bf18e36823eec46e6183a68aebc7a195ade61df80c7f4547988f33c3bbdab2be941115fa91146fbaf91f69bb486fee05675d17b4ddca3390d825e5d066810f06a060ad787e01e93e7a16a1d79ea950d31b919c4d40aa4124bfea3de3550f31aaecfcb6047e831a28430452e51635d551aa96ecc1e44e49c1620323a71d115948494161805fb1b20656b3458eab166e547847c4f8ae019c54eb68c2c185ec74e14baebfd33588dce6d52cee9d04e266780526203aecf784b65656434468c934c224970462a2ab0144a2c6dc8337661fad01c7147f0cb7a54c26b236b28f0c4010957ccd941c7641bbe4aca5898e4def058ddd903013287045669f09b44fa75e14a1bd07bb28479e7faa0fafb626b318966996aefa397446fae36151c636802d2ffd46738ca77fe3c4273ceae9589d2087af298295907582a16dba0f6509f762b9cd127019b68d20227a2c5f57227f7e3bae76f27b18237051803f5ee3f6a288f75151a0b86d5c6b3f1b91e7fb54e3be604678c7f9bb6b3eaaa46d5a9e7198f5b412eb0d046049ec975991668326f0281582ef73e9e221cd5aed4630e86b7a8fff83723445a9c14237acbad6f6ff1cab08d3b6b8416203870ecbb398232cfebca8114eb551664e6a8c8cb21536fdb0dfd9222b3ca2024c34cc3f3d4fa8385b5306173c29ee1ccf0b66cd427eed972eafaa989abc651641c9d03ba20959ed832ccbbb43353b988d0254c4ab46bfc37b4ca2c5069e60506d1aeba395117f85ffaf45e61a56303dfdcdad18081d9bfed2ceb55806c20020368155c1891e69dae8ce176601f7d3699df94e0b5573d44f66bad6aaebb888786d8e489e76dd10e9851e4735b089209f647b83ea09754e537c0c85304c17f5a3eb90e26b420d3babb1ff7bede27c2624d4814c191e90551199d1199931f80fe33d4b39388ec8bd520265fc7a650a0092e0ff49981cddbc21b6c707b8d912d76de3a9e2ebb0794eefa3aac8dffbfcaac81369a99c1d7a49e8acf7d42419213a0b4bb379fc8cd7b18c832fdc8bc3e7de627cc5b12eb15ec5f60dd74a4e878a7bba152b22dee068da91c23f3e99b25c486170cb2fe7e21755a4e91631652620aaa4f7d203e712e6db7911d823bfa7798cc0abf7d21243a39af6fafd25d8661932ac1347d9a569473576d1a80e5c438958626e278ff894d8b75160afe1a2b7a47007c702aa0dd0f83a41da5099c4d964706c850ca34c7dd7aed4dbfe5c2bae30fb6a257184c5abbb30983c34d61c2b32ce0a6bb792498d11ec5f75bfca63f516d6db9b4297efd63e88bdf478454b0f247c774a5cc77c17ff3327f3a1cfff35ebb22a4fcf3c535dadf0c017c3e84cbd54b729750cc4756bbbac9bcb1a84c34a63d171b18ebf5f1bca8b1f924848491fd6e1e8ae87e6efa3b5c0bfffaa6a0721f7bd603bd9b41270c6d3ee74cbcd56685651aea8c54d8b151fce4495fe798340e00e996babb0e4cdb99b9f365e1d434958be520f1a2fcb635aac6b8545024efbf4b57353abdf35cbba64143330c317d5cbc947fbd07a95a5c39f96229d56d27ca1d5474fa8abc4bf7172227879ab92647d06fd4b2ed8026280f4349d83d9c348e120897977c98cca22d27663ebf705a45b3ae2d8df443c46b49742f852fd5500fe3b2ca4e39184693e42769764702e1695e0ae87b7d16fe5948619566ffe2d1a368bd8828b176540da7e3b5f1befea04941e6781e86367e0135dbcfbf1159c0fd67ab571ffe6b703b87b55e47a882fe270d5ae52cec61d42c412418a53eeb9618e8413b465aa5655a547a62b28d561b84626d3f75e1aa883fc5a414310eeda55244fe14b6a57e42e81b78386b71c7fa6db3de60d03670420bd8b17186701cceefb7ab8e1ffea60e26f1abe398b900821788c1cfff105705a6e1ced4a0c6b772f0e5589f48795721acd6edfc3012a6985255d0d757ffb20b7f3a023fef8fc1f5172f619055b1eef4b47e8041140a76d52fab43b16748058a760b2aacf6b05d1e0e7fe4a0761047095976c1ed19b75083e2a029c8c9edc870f138ff24334280809351925d5d3ed6f22a5e6d53651e58027074eda33f60f8c8d9cdfb1219a15922666e43d62419717a15ae478a646d1ecf56b3fa46bc3860c9bb1c00df7d51412eec6f6a837fb79cacb0d260f40d25cfc66a2ae083bb68c60756460c8a368b0df35d270e6afd43be5b58b659c984ba3458265bbac89d45bc0c04fe749c8cd4498598e941fdc939c7b726cb30c0af62ac2c07a26e81876de0655c7a6e2fa157fbe6c81674798b55b898cb2af087d39bfc074161d2da2ddff3c0311308affe5be590728c6638b3b7cfa3cc19651a62a26ef2c877e89e41f8b9ed0eae9c0f82a23063c3ad2520ef79cf92a31a4d1c1e5fa21e7a9b7c8126ad2d282cd56dc387af464575f014d56d00e16563d0e19724892f33ed3e3c8649e0d2ba1d1c1d7301c0a685cd67e5c359b2c842b507de2e39ee5949500f72bd87ca4f7acbd769a2ec393184a4c5b8c7dbf64851a95a6a72ec4ac70e0735d58ef14d7d8b7d4db312314f625a6513c8777bd1ca3d912c3dd0cee5d5ab6077b12d1de92325086e6adadfd1c721764bf9cd92498512e3b2174da74b9531958fe3e36ba4dcc1f74a08b08ed706921cb794496331a858e08f26a22a1efe3c6bdc192bd69148ede6fb50e26086a59b898a67ff4b0b76b22e94172e60dbb39d6b13b57e43829796766bf4d4c53787cf0286ee826869b59b7e68a40bde5d29d767fd42e9d72c17a25db8dca5f426427431a0604c4c1edba5ea58b3293f0e1b3cc7c2bbe7caf9bf20210aa9f74eb37279ed96dbe30f8e7d5eb17b6413e667a50f3a7631ecafcd38a56c59e4fcf9aac1f8b40f0af4e62132567dbcfc57559ecfde400b09e83666008b9a1577061c579bedba39c7b652858e02c4027230765b2ff664daf45bf95917a55519f848aebe926488ec0de1618954a33594aef6a8413bb44ae2557f7fc3c8ab06dbb3b3d578dffa69b4a06a618d779f94d1adb933479f2ba5816285b09b1694aff2d9c765a172514ad059ef1029cfd7a0b3d1e7b83e8af4ba53c3d95035560ccc131b50de2c8a2657a6fd0d98dc3534f9d34396e67dec3bb2ae6fa798a08b678a5083562af8974068c521f38780b39d0ffe6c746fcf6a5041a66407cc2ece4f1c1f00bb8f86444e970e38fa12428b2cd0bb1b6303eb3a26c31678e2528b0b6a2bf4db797ab6ee1a9e3275ad60b899dd924040591d3eefb040346bdaee07e3ab4fa59fce8c0de8b9afa97fcf8c19890c009f8f90b88b231831eb900fbfab113577ac12efede9bdd9330eefef42ac14e762fd83c885f9a92b019aece023fabc66977a09b39a19bf566cba53136ed0b8b96f88b7d6233e6d626e01c1000605384feb3a0276d00577b044e20c49b44af51cd70fa8269936df984864c31e89c5cbd2d9ebc101aebbcaf6066fdc99b8d1fc2a29de8604b0b02f3e96ebeda6c8802cd20cac0a1653dcdc7f1671e1490880602a73074d6292268459d5bb96f48199a5bcb751380e7458194ab79822c12c2961971b991051c48f5dc5f3dcfddbdbc0e813bc7f4347507b7a6297771ecfdf3ba6cd41b68091d05fa058ebb07786da291b215ae7939eb8166ea90c024fa991a6ceb8203af78ffcaba92835dbc7ba3085a79803c03abb25029319816454b89045bdaf1fae004acea7b2c3743d55a9fb161b8120f70963abd1c6e197b5fb79e1e9f22c6ae2ffac2365307b67d57f60e458a1963555be5b73eea023a7508f2b4d22dc847600b600aecbcaee270ad40cae1292168fc339ab2f30a6cafbb3d31fd0718716f7cb60cedc103ed8af892711aa31cc567e44327330d4cf9c02231fcbc47bac29afcf2cf4d0b3998e4d440e9cb61d729aedabd1051495a408b6b2b6ac8d68df4336665e208c5a9b1e3b8cc1baf585d082c298162fd68fb440fdeb1980fe9fd81c283df7692f654ad5a27c758bd87678e1303c24464db83518d69e5c206e13f33877d55f83ffd997a85113ae1a7bf8eb8edec464930159bb082c69e6d37162ae70468b835bc8e611e8c8a7359fbcdc67d064d9b6193223cd570fe470c35352ec59302309e005817cceed061b644745662979b9b113e7745e247bf22b74d3b16fbdc4303b1d929e8349a50d7261b26b1e127829b89441628eb4d2fa64d16a8e002fbcc2e3bade09b7a3be43288e37f275152a7185af659b16de52470cb9db93f9c1b22d1143b68f1236f4898a5428e1d24c8ff4261f1de20e1567e52d3d3269bbd7ff24c6d742e25c87c6185397d8d6693468b2f2efeb18106967dd2b356c9496599277e693ff179cd6e6ad2701fc9559f034c914a8ce61898a59b297e980a1b422f854a8f6a049c7a47235b4f7273c5e05d17de7cebcdfbac2eedd027bc11ccb36b7fa16d014ffb10355c132b8ac6aa81e7437688ca44810bf378c37eeede4fc7d11ea20e839064f709be42a3bea4259d6ea853a90f47fbd8df679a94d4aa4d946430db1d31138508fd4c23d825006a7611768446f8d0aac5d615e5e75fc56a10a45e3da424520b16a9389aac1556bef1d875225dc0b956b4c3c58f28a47bc65b7019d4a0d642a6139ad68a5cdab5e3dc376e25672bf82ab6bb387490d3a22475ae3a2f559597ec4ccc764c721599bf3133ecc151faee0378b4268d1cd125509a682e45c33663295eda0890d46b9b6daa45eb08cbaf5e1ad0015ff6c0f8bac5b3601d3dc6ad12c7f481b76ac0140defce59e1bc06f5547463bbe831f7e53be426a15b601039c1f88772b5f01a8009f80a76765172f39cb8824461a52b7eb33634d8d43ca4957be82d39c8b15c175a7845d7e086ce4952696cd372aa72e774eb487c4d6028256d9b1db31c1d1dff03e882c0f0a1fb860b0726db5aa3bf96cd717d74926947b42d96312a05c5f6d3f884abe5d0e85ee922fd24748c6a120a019cafff73985ffbff74f84e06aa47d8c653bb43930a56ee135b9027675c8975b6b2d3f1ef604ce4086621eaa45bbf38fb0e778b0024bc70c300e4ca7988e255866c59ad5ac1360ee5c985a2af30f1c54d967e356fa3a3522997948b44873c451f8472fad6bc46053591d2c8b4ab3a84dba7d4d96455350d492ea8e8472632939964b003ae527b1dfd190274c456e34d0f23e0d2d0c0be92050e6f5f18ea562aa1be15282a9e26b17fc879c57270c2cd5b0afd3a658d50d0ba61bde836a189ccd1fb819a9e98c26c5c6a3719651c492a6d74fb9d2ba9f9198eea61835a3d5b4717af3300470e003e5b22732d175407424ace28ecc9bf4831fb6e0ff5dcff973b735edce488c6e8d2654ede9fffc9a5500b8e417a85ab16fefd39df30ee0df4a5e729c9d5037e3317ac694d3da5bbb8999e30f96da8ffd96bf88ee0b9e4176aee5134a22b1444cb8fee34272601a16d13f23989b684035c0cc3ea03e3f951bf8748c1d7fc7c2fa8848da3ea98f6b75fdbc5463376f843964a2cf012157ba88e78a100520473786432867ded48973d2378e9fdc076a83a9067dc4bb968cb6d578b556438b04cff300017d60809cd7beb9bb7d48fc0f89c3af0a1a4a72ca7901d2945d4fc0dbab2932c24d9705c6f5789ecb35a703c146887f7a52281cba891136f8d4d2ae8a061da33ba3da1d2eb048db1075210151912ad6a852bf1c76894bef30fb27a5db78261c5450cb339ecd199f636580630b72b87167eb58ef724cb70a93a77060e669165eec4a1e44a84b5eb57904464dc49039c80b4465b00624e4e66b0db362544b023fd100057c24b5a105e7dd2408c30416e4caee09666729cb6c53db26850e05d297707d981aa28e7754ba7690c056b1c7c5923f24f413aecba736a1bfa329e45882a852f9755eb3346a0395e8607d7bb4ba1a94b804f9df05d9ccb88188bdbcb859f6c20757d112a01fa8c4000df2197210f27ee01f1156b83e2afc9152ffca77326e190fc0d1ecb69ce8dac12a8362e691c2ec551461a130baccfc62ab9624681a9e627fe0fea9cf30308a4eab09785118c53c65c914691d8eb90fb699a5e7c930bd288f2c950f91ab56653846c91c84444395cba70225b3f8d9e81652e009d9d1233c05218f8732b313a9a5993afda23f4294b7e8c18968fbb6269b66959618990c288b2f3447294250fb98ae8f352586fdcafc57ed89f43e0a9cda22350ddcafded6cf4f9ae8a868c4fa5a15372127b796c9d3b23389ddce25db859495855114e0abba8639a0351bbb520746e854e8eba15e540838499d38400f9ec2edf8af8d21f33292247998d0c2d92898ee5c5bbf0923e1da6acac74213dec72f669ad4871bb864994300772a367ceb5548efa0faca0b9e1f35907bfc0ad5b2707659c58c2e23a2647d5d3f058267651efee4a208986f290541f4051646fbcae0c45884a37a12612aa3853dff9ad2af18ee67410338a3b077e3a3bdc51f359f232439995384d438864062675f053f685566b7888d02aac6beb475b17b53d8cbf442c9911e5e7bb4af25b4942da1d268496c7267b55db960ebebb8720f0be06e6c6d2635993697390128066c7cbb06d5d6c665bea21d521daaa7ad7568c5d318d788ae9d30f9abd8042be86bbd469c9bd499ea25d06eb4258b456ae3de0f7a9bafca276a68147a2f53398f5f06f54452ae3fda0ff4e15817a00a7e8ab9a09c64bbb5af3829504bc8d81e1dddbe811e190daba4ba5668220fdaf5141685e044ed4f2bef4c6c0720829c3012c6e6fd7325ecce7eb1d55b7577384e015629e479e01ac276c4fa5c2371a1d8b8814075ee8fb90dc8837ddaf3873fec2bd9c7adc33503e9ab34c1c0f853dd7312728f816082e712bfb29c7d9f177250657f3e838c548b0c74134d0fde4df9da882b8b9fffe2568a87ba38fa2e8a43b528d8d83c8d6b9c8c7e9cf411a3b7cd98d980c9b60d6c35ac79dfa5163ff69f1a5cd8280aafb0067eff165266bde7a50eefc3a8b44b9d4fbc394ed16ca198f03af0e700d1cbdb3747da0c9d5c9df97ac6c23cd8b6cc8e480a55d9fce8e4b3c262b70c52e304058f71cb7d992b2e4eb28917484f474b38711975af6f03e3a128516b1ee60d1dd806b16dcf17e8b996798aeecdcc56865b4a463861a28d29b9555eca073d844890777c8aa8ce1d8a56932b38774ce5923d512cb3fb807b8683a8fd9546ba9aeafd888aa44185675b7000647fe8c35d12dcea2bb679babc4342aefd17b1d99ca847140af1b6058c1516ad49ac0f810e961b0a3bffd40388a4bcbd300565e2a6d182c168abb78c035e1ce8bc4302661ef700e4e01a97f2f05308b2520a0907de37c5f0235cda52368ba82fefa4762ad4569343b9e4941fe0f694023310e35a8b9f8e1d21cfec26d900d013efd6ddee20aecb54dcd516c543e3e244875c3421076e4400d95ac24399b3573602d53ad4c1d1f3887030bf948690d214bf0c08265ffaed18c6c71f190fdae44240a1f02c5f1293583eadbf411ba0125de5c1c4001defaf0e0f708ef5b8f26939682f61375e14f35b5f1e723ecfd0f89386065ca42b5ec06879a48bed3e24362ca1ac0a2f78f4eafa09d141400f77ecf0ed37d332f87c05bedfc99631afbbf316fef7d89ca3cb41388bf079bf7fd6b9daf04a524891dea79a3770d48459ddb14256a5937928b82d523d065d764c8cc0a2b6c0ab0ed2022c4b2fa9401b5df3d826bbb669063ff2e37183713cac8c394cc7403353700b8468a528ed5965bdfb98a69c41152f1cc9b9a73a5a9580c75fae0833d69843f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
