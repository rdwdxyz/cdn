<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cce284f2012602bfb9effd851184553a7e80cafdbe6469b52139bf88ce76d2c92fa1135c7d637bf89ddd61c40f1385ad1539dfcac189bf5276f237c723b4e57f39da06dc78e6c05838e150f0470a4e86b751a14f6edca55e99aba72ee184a7662d581222eb2062003090d8bbfe6e04fd8d2e460bda8e4897b7f92213f85a0056a40298417c8d0f8efe07fcbc28ef826a1e15afcc22095031b0a88d35d6a2b0792a07286fcd3f7ebc15a02d738f97c88907629cd5ed136bbc40355855b30c6d64748aa00f3fd45b84931dac6e51f92263085fc7a2dfab39b441b54bdfdfe9ac476476e7576b1552e985de5d0e8887c15c5a6618cc64c1fd805cbc41e561019905f6d4a7ce593b1690ae632836164c75138f85f60f925af1369dbba1ee79095d96d8767c4cd75671397a7d0e3d99b33a4f02717bffe1f86cb952e9631343645d6ba2ac93251d758f608984faf42a937dd684ee865caf0a44781abbcc3fdb8a43a424f597440fb786c65ca2cd8e3bb5d5957ab6c1676e2e529663fabadba7b51b12bf12cf4e744f3ed41462fa6487af14eff98fee23c6a026a3c4732ea9f002bd64c1d79e1a9a66d42466bbe12521cd590a45bb8cd8efb714c853261366ca13a8e7ab78d6d31ec3cd053219dd18aede6b091c0bfbc094d3168a80da1439b5cbf4ee059e5f5f807d94a76ee6740c4ca3c7602d43dd7171169f223ab771ce499925a0d23b45f570938c40b884a5dd9bc358a09859ed1e9df6c48b70da1abfba61bbf171e54f0ab99bc2c0dc2b4b91a562025e903f4c1503d10eef359f2b2a9a39462892027b6bb1d92db0f5a0fd014f20ba117837a4cb02af206c8241970dff79d7f7fb786d61c5bdafd990921ef4ee96fd8c471f22a9dc645e1f5ba6aa398e23c6590f658b7c1f44ed027e1e1ae7531a3f6a3698592d52cd0ceb38d9b1f722853e358400591fd41f01411e8bd34c5a38c9b0ce5c88b7b9c3505857af257042d093fdf4992e71758eb5036840765eef2e27c57a771b80ef5b384aabcac348b1114baf0f61941c4f2b1a6d86d0147044e0690a2e32b38d92cc1d74142f6d6d7b51fe70e3d3802234e562357af17f2f4dcd99b789646a573cec305363197221cf6f86e99d415ec9f659d330445d64cceee09eb9ac6b1f59a8474cbbc98fe674670f6a5215ad9bbb61c6d78e5e45195d3e0d4ca42592357df7527d5a9400f53b1c026f1f1b9fe166567bf40270aeaebf242c6b074f0fdc13388d73ca85c921169f9f7819831f430d30feb1a07c9348de3bc4a5131034c3420dcdeabe1ae9cc5153bce08620cb2e8d6a1feee181a976b3f1cca98979365bfbea7d022748e8138fbdac916597f038faf190cf226f53ebe7554b1298f1665d74b1aa583c8b1570dfb2bf731ccd652aecdce19ad5943c444be4384e69dda012edb24f6f18d63557c918355d83bb6259ebb9c2c0ce36875db3f5edf478a543f290cd26b7a2e3b44a872e361e6b37b6bc3823db38ddf26e9a99a30e83f214e763d950269f078bc01a3e5710c2fbb109be31c7b348d9191a8d89e17ad460de7c49263cfb8bda40332ab6e20a8cc0aa774829097b69edd8891380668be13b7cfb1a02cf64171fc4fad28f1bc142f72c889962fe74f170237ff8c6d35fe34b99dd854f0f6e1e5676056ae64508840b4b42336ec8e3469d587282c2464ef1a8dd17e87500d0424e39faeaf85d86a810e89815130b8f4557b14bf478eb9e4dec745af6f80c6662bf58412dfbdafafeb90c45736df63ac748a70b023cd669cb80a361bc5c1351da5cf62704da0ad694172aa9e7a208024c570beec5440a09eb929e32720a1144f818011860c3e6b35695af6b9ef63f90f4c60c3c81bf55acb8e59001e306eb5b901d578a3b1fa1fa429146738b2c7810f0b5e17352c6d1ce29e28543e25b8bd357208b12d2ed45fffc63c74160ac597d22cb239a09b97805806e4159a4bc3b4d00d3edd8b8fedec787ba1db84c0291b843313a93942587929bd961ca8c1ddf947f27a27cce3ceb7e53188153d176089095bb9398b1c3132c439e4145620921684a70266f7331673759fc962277c4c81724e6c5067ce93d2cf2b4c9ff232013d839a9a302c632f0c6e093fffab9f880d4bc4a34d36d51b1b9ad3030555634a5528a2d7b5e8cb2800a684e3ec9d0c73541e85369acfc2594607e420a350e31ff6de5fe242b9052d75986f32a6291f80c77ba3af1b8f8f14a7fa0ac2d63a6ba070143612a180df73b350bcba73109f258b634d4e14ba67856d4bb2af324377ce9bc7eeb999ac9e195b9d3159deab74ab41eebd2acb64d1969d50e8a3a9405de5dac2404d6150950086835c4da30d15d63443ea8a6248adbb0cb784d546f485ec9fbbc1d81a01534ae5bff72c85054e2b37d6df3588fb3aead51d2411ccc385e485caa351551a64afa580bcae23128ecffb3d02016efc54af29a8fad73427cff645ced0ba700829ff73914b96bcc93be8b4b544bbd845bb56c91912311b8fcae3f826957ef088c8e164d0399e343805ecafc89d26ac57dfbd399f934f4ded26d5716e8c864789e4f5ec761b045b02369375f017581ed51377db19f0b70d428109457c931e5624709835be9398d7914bf9189ceaee3aad1c73d7cb29583e6cf46cfe3d36497cfb8d917e8f0ed6678130871043fbed028483dfad21e6626e6b7a048301060e3bd118b3e3b495ac621c620f88177b452e38238a92d414082e0227d28e5f770ed2c032f8a8cea56fce61f95de69f2c749b26b3fa9b19202841c445d95c542bebba25e7f55b6df0d3bea21125df33b977a5969e917e3f4842b6abd111c0a8a9435425d943bba61baa7b33c6ab973e931a01a2cc63e032982411c06aae3591c817d0671282f0d993f2edc28119480d3f8bfd77970507f8737a38525b9c36d265454b82dcecb4f6ff280d8f88049811bb34a72d76e2a283fe90f85a5a9aa62a301224b10cb83a42a48539514fb51c6b9e483a625bae32e2e1a48f463a67370d7fa89d47f9efe15bcb79f4dca8f6288c327d3f9c00080f8cca2df813d897175d3f5b9c75a6dc6201ab5abbe50d72b2cc2e86f3f05c6641d557475a1ef8f7f4a24a5d7a0c676b33ebba77e176c637912e75c99803b6e8c28c6ba70d8ccaaa2ef14ba1f5ae58c5732d331a35991822111753501840d7dd565f4b01c755b42cf4ccbbcf2c4ba46f024f55d1f423f7180557ba5ea67688ed75bc4ef1e34d32398749ecf31c10b1eaf358d893a6b79343804dbb6324a0375ef9347b0f9acc214bc0a08338e468384cc56ebe4b6d1a021a9ed920e99501e3c937fb1c53f7431370d2f184b41377aaaa63160303f94792b59c363b2d9c4221b67a27b8700f8279c369bd3bb4076c5cd514e6120b54c506ce25b79437bf4ec39be7d703e87c8177e93e9c9acfcc321fec380274bea3b772e7febfaf771d2e88bd385910a7c819bda46ab382426f87f4fb00d81cb5f0fddc2a5d9aeb5dfec1b5e4aba9131292dfa158ea478c8bffe4ffdb3631cb056adb5c797fc068f3dc39954043d08d5910c084125830aa09626bf8c9de630cd08591b414b1c8e42302c05442747750f86219d58b200d9e137be9b4787a0423188647af96154cb0c8ee1ea3d3875238eb85b8758b13804a5797ec8c0077a53612ea880b3b6cb49c567426dd8646eb41cf326e6ebb86493927eb39d40df668234efefdb361561fad9bc599d09ac0fa29599317876dfd1b20cc04af3c3c6e6f14add0979d02a8906d525246d7a438e145687b988e308b824e948e7fb09209e816110bc042032758b4e30c25bba85eaa43298f295d10d521cd2bccb94ec06bd5b2b45a00fd460292c5a058ec045c88fbd2897717ff759724716c315c4c0b3842a4dfaa62342cc5628205128ff85a2558f678038a5671f83fa3ec21847ea8e50fac95f4ffa221f63030a98c24cc1e61100c86cdb96b7db24d708a7bf1e028b0eefec6c7293a91624798f1f10700ba4179ab6848b75cab5a082849174ca0a80eb804129256101011e8aa2d4c558cf622af323df47526b817e9e7bc783ba579fd30cbf7ef650f35172a0990dfc168c4cd52ea4cb5d2dd2e7c590196af6079009dbcb831ba5ae8055ca8149f32f65dd6d624fd4fe38305f1eb52e7620c1c0b2fdbbbb79f7acf3470a978df0df17c0e3a42958475701a5fd31261936bd67d58e512005354b04254f4ceda973cd43f321d9b4605f02c0290556e1ce75d747d441aeac62ffc98c7c4fe9ecc13a272115b4fe54f6ed11cc4b06fd0315e12e69e168adae2d5c67a1ff22fdca635f11fb40eddbf00b2285560d8aaf4f2c147e52467c7c5bf2b1b5cc0c67c789784f13553f32b97649f2a76d8de5b5c28cc6305961fba513c6c5d710ed74ce80f658819b59f2e23c66351eef8677a03fc8515044f2f1d7e0f1238ef1fa9db548cc0b430c155f225a306df567f2fb63babcab8ae8cc9627a4e1cf591d2a9fab3af3ad029b9fbb16aa3777b10e2465e6544fba6cc6ca94995fa901cefa828b975dcb2da7eb65b96cdb0b5093a75168dac3afee48571e31485a0301e8fcf53d6042b7aee01b604154df893d4de8f8f97259da7b5001ae533511292cd32de42971d76e02d4f6ee7345a90f0832c256bd6f1619a66f5f8368c7f063e0aaa77d07fc9f41460cf6b48056491f46bca978ebdb73de688eee8dbaf0052d192a95ba8efff0f42259a31500b23905ad7af679490143d4751c1d4a2b75230ab6e5bb18fa0eee527b71bdbcd75027fcd9764f9d2ac37e6a49301dfe63809559dfaa9b230e4a52c55c8367e57f01dfa17dfc48ed47ab3b017e7f8dfcc01bd830e67b27605bd618f426802505c255457c524270e0a4b74d9e6da21b3e495d76cb26cf8e9f3615d3dee15c4157dfa9e2b8bdb6f1db8ec3d97bf867feb436f600ae54eeb60c962691cb6b9a46ba0504919376981ac57828ed1e9b63ceb5b3bdb95c217076bc25cdf171e4cb0a2d918f93430f16348d49cd7405dee8b216ab525bb30e7a2e23ca238d601a8c1663505b17fb11dee65fc63cee76134942c9f6fde4aab084e6a87814d5e291bf0ea6d5887e573bcc50ad67e831ccf42ff0846486cb25175568b2bc48187e494c1dc08b57ea90936eb191b224ecf1e60194a40e78e9899934ac4e140e95735e4261211a5ceb05c6fcce4ac31b5da859e6362d384a9863a11e6d22b4a6d2bcacae4030e08ce5e5b1545b849911a1cc3d2b8c9a3661d113b9a158c1c41c14dc8db5da6353864f293582679003042a95df17b9dc79730db264c879e4fec615bb72625a07006ff3c5cab02cfefb2b73684a225c50e7494c9f6b800fab740c3a65060980f22c87c736a2f4710a98411271aaec5758394ee67b8bfdb2aaa0f6dae4f7c70be9a110ab7902f22628b84692579f9e509230e7e30723b3dca1045ee5c1242bd80d5afd68b39f81988275e7b0dddae760091208318adaedc6cae03c82862a8b599a867bf4390f291b23ccd640b8b9d28026f691b134f1b776918628ddd50641c3dc61f0704b2853b05ddbf19679fad3072d6eae3c62a9626307a24a7a1c50c8dd621957b4c8a82980417343582f83ae803938ea61bb687adf0301b206b940f741f18ded9c95e2347a61a3e61ff5b8d981347e43a56475d078e0dfa6c8b149c227503a5c5c834a8fcf5d6b878298fd3cd601f04c40c2e77a02b5145480dcc6241abf97c749698631cb3f3eb87a2ae79b512c7f3291ca1f732685048cfbc6e5c6cd7ca203c08b707ba5868b1b0de2940e06d5e26a118233809ce4de1242dc88804358b570619613f5c355c99660f2505332e1d1fcf1701de705aeb9c5a3817cb1ac73e6d26a5b53b554f5cdc678c9155f2882e8c32ae3078ac0e28c06827728859aae1411c867c085729ecacae148df18d742f4ec1922d2f03a0d14be4272cc9844a9d43476a6c707b072fcf325824e6b6a2efce37852318c598f414bf86a8239a0dd8d268f4c232e8ec08d3f84719944b5b90da8394467f51183732bfdf025c7efbfbb0f5eaa564ce23a05ef91c601cb9a0febc62bb9009b57ba0adc3712a73d985e62ffc334cc0510df6d780185a2c30023db954067ecf1cac38ac90caf2604f765e593645ed157ff3ae0b9cbd4aaeded4c5fae1b41ba283c3533486ea909475d180e045684a7d2f4a7c6a1afe7fe5a8f8de2207728757a2408a652dc571a2ec92efee3dfd8aec42d9501169687fd0978ad7291ce3a10f81307af6f2c7abac6b18c90597b645786b8af368c1c06a0c97420ba85fdfac3f5270874162b9c94fdc641046333c2e6e640363bd20ff48977fedf6b1a9a5e939f5d8c02ad258c056f29ce7d758be5963bbd7bc928a7f852f45b2988dbaa8f3345a0bffafbc30d0afcb5cbff0ef915e02e0aef1dd40712643cc0ec26791b64746281c3c83228b1032b51369d100e421ab5dc50d88ed84d19036ed28652af711ff1e9b92ee53dc52ecb7105bab9e01e2c82d72dd4ca7c27b63d16b76259eda00d73d4826d8f82b98d4c962f0548d48dbb3d3b2018c2d7ef59b5880b89d2358ec03a1a85da7bf3e119dae29f113d855f299d6b3d5c70e4a3e13eebe643a6051b31d2488cf13f21cd8f981d20709d06742d35a22d5cc47405a31150478b575eff776788469933a84ae78993b7fc03ee22e6438dca5f4623c0f8b02dcddaa7f13d04b3e747753390fe7221b21a52a5658abc62e0e3b60356b37bc5ccc56619b58f8cb7510f9d7b032514e34af98c75621952f4627d9afc28f9e3f0e6c173ddce5a75d86d5573584ee256bca5b47c5a16e95bbf041c6ef5565e18b4b60b2d2817a737ff0804acf37466a309a1e5392f953ef5fe8bb7c3c902c73fbb7f8d05e5eb46457e6187467ba3329bcb1ca57a6a2265ec44f17091f2da5f5bf6647aeeff6b563d9922077dd2971de15112a0a2530ebbf4d20d554e3d1c8893967d6b548d59f2daea1316e7bf91d69732467992a5381c94858c6aa9734ab35d91f1a8071227880e69cdc3c5ec49d70bb999d3da69f9f558d9dffa0527989019547617a767a05737efb856e1c9a22b3ce27fea1891da7c14671c4e3abc21ee3fb3633cc89be5ec0fc70a900c0be9e9e610926cb7bb1e200cee7924c3be965f7a2f24285f7e0f3e68ac53a111f090d91bf144c0fa49d8df7ef41d0548c5aec2d11355a35956408e1f1f118df3be966796b33689c46b087a047ccbd4370224751388880be5cb5bffcdeb8edb8460a230fda359447060af323f0226d0c6a720163dd063e5c78753ef35314277f88f6f940c9b8333ab08a0fbebf080dd0b59182c11ff1784906fe1e2d1b3e6ff47508e2b02631f6a48efb99e9e548fb7b2a84e3a29c15b1e7eb959f1a858450b5a9ff44e19b27ba8f758228268f17de318b5f700dede16810dc09d47ecb4b33f41d464f59ebf1ed282cda31a18c4e72f07d24c69a150765b9815445f8490ce6aa3faf5c143405688f67928ea859160835c7ad347bb91f1c4e0e740997740506f111ecb32c5447bcf691609d06deeaa5fc6d45b3c4809622731c68182f805341bbb5b795332c21807da67003464e97b06f997a5ea41d6986c763ced401157e0b520e0fca1accb88ef30ccb5a6d37b395d7a609e13b3dce70a0edd0d970cef130873aff23bd1b2d171d686bc6d3e568109ad4f0acb20d922f5a4493043c69004e567e9d632b1b35ae57f65272df9fe781de6aaf233a5ef8a21423ff4372fdd2123a0a2b848e5810b3c822de0479ccc4fdeb37ff477b8463a7c6330c4765dbd6284e3b36d6b5125db63aef1f1e450310601be9c62aa5a9ab62f8a3efe27acb8ae6ac9425aa3ced9e40ad80d550174facc667d54fbb7e7c49b4771394510f3f24d9cdf5bebc3ae2b1f2c54bb953a3e97bd7e845e7a5edf56650c253bea585209636d402dfc4b8ed2b804eb116c66a6c802b9632b6f30ed6bed610afb1af79d4ec2eb1bc9dc0e772b8f8d2ab182176841981ed07ab20ad5bf6807c554a1fc42b9791058022df5d6cab694c348b6f0a75119d5c5cddbbb8f12a4bdcd7db1834f9549fdbf79f0d341051ef70462634da7bbbcc96ffc6a44d011e208438db96d421858effd8a155510bb86b7b997573727bc777e5c4005477ff27d5d4e03b92200fefdb5d06f2a70fdf2d5ae350678e861020f7872e37145ae6d18278dca541c05b8c8c5347d4cad9c8d0b672db296946e8f0a3ed8c3b2cb0a7d0f9525b91bfb479ea6514b151dff0a098ca9a8b88eac850ee6deeebc57bf2885da0a46abd1723cc3d977b86d2228b191b3508a2ff99b0e63bc1434684343dcd9c72128df94afc532434b448de12a7b271e12b1fad48dce98f49157165b9804eea7d1d38565f8a3ab953a9723a2ba1b27a367f9d3a54e54fbfe9e512d22a95fe43b74001cce37fc9c4f48b14e5279a08e297538800fece4e6135ae753e02a0deadc6a8972f8a2a155d4daead706a8634b67cee2d73f81eb6ec93b9eff4dd58ef6cb0e03abfcea68c49804d417ba2fb22f1762105218dbe63e41b395355ff0f3d222fad71af69c9b54938a368a680e73b8d7cf85f54380aff3ce915ddbc149408797f096de8b08527d5a027dbe30770ef720830e895dda8f294ca8faff208a79282f45d790ea6298c0f162c43982a9638a80a2a3aae1a21280cb7e90852f77c18260356b5f770cc6d7c8d45cf063c2bb835a865212439d5a8b758aad1409b1219bc90654f6ca19999191745e13f217c59599965944a31d758d87ab532c6abe65dca9296992a853c70b598dc882c77731b431a7647fd8ef4543e907bb5979a36010c5a1059338f3db7b9fd3f98fea369e6168d4ab6d3fd9a9ec77d664fc998f33ea4c5661461f2a6fdc23aaa3203e8e7c6aa51c9cd9ede2c33acb73f18b48a47f8595245ea77a63528413aae92322d98e4301848d8233fe4bb2e0b92820b42cd654a15971dca17bce0055abfd39fb052003f776be518fc0689c4c433a1f8f0bd3155c6a3970dba9b9c86d80b7ac9c49918e4f37195a3a302880602d9974dd2ffaf4eadaae5d3281b2c9e80022cd8a6976b1a2ec2fb96ab44798239fb3e1fc2625c5dab23bb5a42bd41cf6ae57f1fede470ce099672191c65ac4996d13fc067669360c20ef8311a99689b6505088545a408ba339ee4359cff0d1775af03795f9c701e483ee891ee0f2378e9687a6b3d40c6d3b387b1a5f233ebb0718fa9a506e7a73a6d2a5fac0bee2972c5680174aca62daf531a55c60ce738637a0fe55dcf270422efaec4d52e3bdf1410300ec982297d893e8dfa36c62cd2d96bff918c96100b3efb478a3a8d15af0f4afd3cdec9cbd952fc3b755eddf3c33ad17098072d446955e8af2b6b085fd4d043e5295590f5005c03dc8222d0dec5e7b5c73cba43169f93f17ccaf9a341865cc542cb17ca411cce5b659ce7d16c3a104168c5fc011c556320daa1c3c27a06437142b6ca76cb6cc9487745d14b19d4775be4bca4c3435d9fbaf28f7c69544616f530b88904faabf4e1d847a88387cd87067d0c1a0d5540a10804d857560164a24b9ed3c4c1eadc67cf565f8d7ba132fc2e16070a54eebf91938020fe98be86eb76bc83f75faa82dc3528101d56434aa90af7fd4052eb1d4902f82c5adfea73e07774450d7e0c0b9a83244102d28d2b3c30ca0bcf13f21a220d974dbf60ec6d6173b0b7dc6fb8ebc7f7b4f7419f58097795d494cb5e97064cb139f4923bcaa9b53167ef85104feed6dbe46d4fb99be2a62cc241066ba78fad4ad43c07b140e42c3c4122874d8b985c6e9ace93f716e33beb2f67586d72b3c500a964403f7b24157eab3cf019419cb648b1bfabed2c913b48d765df1c83495bd10730c163632801b4caf9d54b638fa840977d716ef6a0d84471a252d6c482c7a19871bd7f6e735f492c2468c8b84247f891b01f6e3172bedf92a772e20f8d654f09fd3b693f5f505ec73af4375a2460c1110e78b3ab3d6949196e4c4b4a7815b6316d02db5e5106540e796fc2e121123970805e450686d26f89ac4d8a222da0db3ead00ae1be19fb016c3f537437e8c8d73913096af58561ee832ec721386fd5448aae35706c359536c4c3f756710df75f8e9912b2e167e5863161495cef873401666a12cc37b1839fd731571c7967a8e91931c15f888a35272bd4460aa4993d754641abd2c5cd3c90599f22d450f4e58c2684eddde7ef3701374a5f22b108729a04167fc3fd38a85d916c8b09a22820ca571f81d66a199347372925dc416dcd85934422ea40a91caf5fbdaecd62b46c819b56607c464e1c3eccc3ab0325a53c1003b8cfff3722bf7a610c5379847b67d4fd62149afb24dac763021944546446a8d2258dea28c887eca7a2198ac2e11793ea1c4b98bd1f427f716f47a69212cad1eb8b8ab830e1075007835eeb3d4f5aaf35c609a6eb5870c4ce48a773e00836707e82d4660e8af228ffeb0974d68a0b84323b0bd8ea9558f94829cf3be5a19d594658256fca262b984ba6a7b5656a8d72a33616078e7680545671fc1f0667045d6f33e24a0faca399bd8c3f6d0a55352035ab4b260bb0a83104d1eed4cd2817bd73d077d57e37180b751927ded114d3b0966d87fefa28882d3370d2e25830f121fee508d2665e0b5deeba67bc26653cd7613f5d8248ad7c48cb9cda6585822fd50b3b0e7349c68e6607e1ce7bf3796b85c7ffa79f33202028302790b204d0394d8288da08574feb69c66139d2a6deb4b5bdb160d1dd8201ba55991d25efdbf194f9b16f735bd938110c0acaabbe3ad67d8aaa3578c3643549c4c38db7e7fd117a92169c264ac9e942fc916e43c90fb0037a8726d8936334f6557380d63a10e54768d3c32f3bb3a8e712298c510a989c8f8bad1ea097a823621bd36202ebd592e3bd94bd1fe51c81d8a5c81d40bcc1d88e2bb0323e77802a42eaf64aabe7ee05f4137bd00ae7c1895e0888bd13dc215ded37e3c8dd9a25314b0cd5936198d49abc2c8814a37ecd2299c46e327e57a5b613ba3ef311cfde67115b3cc98fc6e8789b830dd595e48d05ce7bf628f0c1477cbf4b7dee6ce13aa28b361506541f7e5b3a77c0c48703e635f54b5491ab60bf562bf699763d2bd8b98f8cbb5c955e572268417f8209910388439036f0a249ae7cc8cf99651f194484dd22fbc266a32f32f3195fbed0f4a441de5ee04afc48a96754f8504fa42204733c3556ce1ec964059e3bf2d7d34a9be82e0597420c7f974ce1b0378fd608a27cd38dd16d4b0c919a540ebd9ccf46bdbf5cb820b3dfe20aa0d1310412dd0bb9cceb1e3091e2e10cdb1454ab0d02dd7b7b1bb5ba3dfbfb0b1eca4c5b0e13774359b9a5bd43093c1fb3f7994d8bbc9192882189d99db1e604d3885cf38c4ec9d13e7b64797d7ff9662b45c3bd37cd19fa7c05ba0ddc0e98633cce3e02261fb17fb5339b2b43c7ecdf262cd466b0f19926921aab7f9670171a56bb60944dbfbb9f0e92cf9d393a804386a3c61c95952ec0f6c43a2becf4f78ace6e903ad44a4abf7621213fd394f14526b3e33a219235accae20963604c1c18e50eea85624becdd34fc25aabea1aeb3bb9c57a9b8295ce3687f819e5158674224911570f5832f9353e006aa790be19a0efce25274d6b401c8be4ec17ee8f7337568a5b8725ccfd6d0c01619ea6ce8323e543650573d38859c07c90e627462b633d0467ce74da5ee2d5a9798dd345f0a882e740457faa4372a42b8a413b54fddf0845cea96ae143ccf80a434ff667823e58f65f57c4c62faf9d78bf759f9bd5c1b37194d38162b5563dbca6fd52424cd6cd20aa37db0f0bba53da2b9e03f6dcf71ceccd97f9d398d95435eca117114881d2d025d7cf5b3539ae09358a470738d30497cf042e55bdcf2903a7fc232c464afa447241fdca9c7da2fa0cc3f23b87b047552dc620517bbe298b1cc77fd0af6f2020c70950666141fbd41aaa11688a181535b6ad9664aacfa8c2b3c090bfdd607fae3c778bf4f8c1383307054db2f8d514aec84cfe767a5d28946d2e43957ca609b3a8b1ba9f6f5d9c1785c14c55d7428a35c368925c5079936b8707817152431337e382e4cb1a3df8300ee5fee8d761a12feae5aa21213b7623da16817586429127ff864f170d68c487095245e9334a32a36b4984ed4a637258a5150dfcb6933dd8a0dcbe38d746acf649983b87fb32ba8c30e4bcc1516c2c1b9518da3bc60c53d354b5523fcdf03bd3e9b4f5d0c7161e1c0ce6aec90d6b2ed58450455329f3e79406ed3967ee34c1de898e0568333f0f19cdc93882b0ae7df87eb3a36ff5c0f184f33ff8e276dc80066d680a64e5e561b5cab45215211a335fc840a04fec3f2efdc7cd51550e710f1e9d33ce3857d1d897bb5009128364493ffe00cc8345de020c9b919fff38e4d36aa4f3ba213e6de2719545e8ff56530da99c638ffc03f876883352fda0777ca2eaeeaf4f8f9601bd69f79f982136aa92e6d8252d43d1d47dfb43c79d9ade8ab3843074b39b9ddd15a5d65e3ef3786fbd5255afa324f9c498de6be2fc036e75aacc5a51402c6dfaaeedda30974de13e86fa309f4d686b1b449521e8d58a32f33c7662575650d52dc3ae4c58e8ccf388a7b814b81f696efa01996a70272f075f4b4ddc87c62bc12288b44d7403275a60bf74e7441b507fd3f02ca889eac859ee8d2b78b24505a05fbda0f02d8cda8aef3d996cd00c0510bebf431c7bd80866e4c783e1c8cad92a52858229bb91478646cc795cda3e41978b39ac602c64eddb89b885f8e6b370c6c6169ecd61f491d4a052b97dd0f0b2cdb9f673514114631c6ce714720a38638d2afe2bf1c614e2174bc5e5b503714deb358371f0a04cbb1bff269f53e849a9371ca746889503f68d8666c019fbe2c7b54ae766d728b2af85c388390e29961a0c5497a2a2d04caea7ddf1beec1afd5197368e6723cbc0793c6c670463d7750d09f3c28c7d1dc5e478a3309eb6cd73794c8126513f9a8066dc53ae926893783a0028cc97eef1e9f17de39797b8f7757c5eb10149ae64aa84a2ea054b29354761583c44531e6fa51169f725102d85e141321cdb462d2a22c683b27ae49f69368feea25dafee115f3c6b90401439aa387d69fb82525de4c954fb7f1eb141c17bd28b1ef19063699b0904a15fd460e3bb7a8c47e8964d4d6e56346dd1b882d2d4e9b289d2998038dcd7096b714f9fd418039360034ad836739cb53b8d434990829f04ff2570dfbc2475335b5fbd35e17c1aaa0157e720398b8416ef10a9431b125fa7ecc2a433817f2e0e07014630479aec6e045c6719292a56f76785b9761ad335bf665b5aeba324482696945b561af20a678a1919d396c4c573971b8d139f86e4c5fa6882fad7b19637310d5ba00924a0b3146274f2b16848e943981dbfcff58cabfe8b7408735b06f29c58f56af764bd78ef1c8bb2a3153135510856afb1939d44ed479f127cd5ce0dd6997aa21a1101100d557d49a802a1cb30f6e8f7ea480ddf3d9c12023102cae43d7ed38c08eed95f32fb3cd55be8e1ed6e8d21a6c0d7ae26bdf208a77ae7fcf9caf76dca5a7907a5c35347be6fe86833133d4bb4b6e02ca0457a43df9ad75175a97eff598e63def240fe47e8c0adb2c3c802bfce9752e0f69d7d7461e88c5c17f086353a0f802e7b5ded2ab6acb3d8332f184b20e69dd6af045f99afd917a22ae86e0113f5e2ee876689b85f83876e68801c0f94238517b5f7b28794ed33294c5341b2efec3545913e44f222fbe38145d09da222916e3e64b14f5532364676835f50b88442ec501e1ab828ca3301115be95a06f6fceebf0d7251e8a74b1774bd438d1d1430aa737b20bc1f6ccc12d9e17e78235a1a7cb9afae4d4e8192534bedca17ca17c39aa22c1d39c21d95c36daabc11bb951c4a36bbc10854fd58febf7393cb03526b91cd5f58f4253e46baa31163fbc4ad429ed9e3f27632706e5c180f0eb8ef74f2bebdb8030630e80b7d7b477ba175cc6f8572922ba9783b6e58e5ee34c1ab1f0d0f609a136845023a07b7bd0bc681093a634d1feee7620ec85b9dd1600e24c5c920e768e6aa9ff9b2c3b836bf624436f7cf288a6b8fa9f5fc2361895b100ec319fff4aed3b351614d96bbc98b2cd7439652c7b7cd5910826cc14eadb6da5c4c3a56c12995360980c12d15e953164aef63ea53a6b2a98961b6eb8da0cfc72644c372403e0a64b024a892f5a4b6c197e6e409d6c26efc9ec97d011f929583946efa38f93421c2baacd8bf74c4bfde273cd6524294be146d910af3cd6692df3519832b464d981a53aea902e2c14fbecff41a82942ae305c9573a20794f1426f2ea2bea017d2296846841d5b2a4a7dc318821db4ef87d45460425225a5910f3bad8a599cc615d730c66555af481f8dfa0f1426beeff4c952725aff7b1905836ee253395c0affeacfcba4ec23655235ecc58198df81f893ffcbd44f82499487aec2858925f31125cd82ffcdbf3558a3173cd9975cb7055c728cf5c073c2763950cd308d7619e59bbdd4346081d3c8965fdb4a8c51e16d391be76b4e5d75e80e8c8df38339a5f2b0b928a14f762de4f4e49239f36e65dc567cb57c6246f498d395ca2781de71f1c6bda098d7e72da3374ca8dd8a941a8366ed05f14efbc5615096162b93a5ad9928d61a3177b616e76d865868dde9ada9c7ef7242c29ea8c550d0b20a2d2226ccd9b29fea46a8705d69a762c00fac05bb68b9095aec4f0ee0fce55ea445f57899f93a8a78dd6fac7169faa9425ded209aa0f29ce1b874041557209565a20eb9fb7b8f59f2bd4d1af7ea7ea8b96d4f0b98689ee76951a9cf62edb35488684324c02e71acbce62849eef583558f0a6bdd3b453276c1634f986c5f1bdfc41616842409e4d61f7608a3274a66eb6710139f8da59880a1e57857a55b21d5125164d9fefe5034f9178d7f32ac1e4b3cef0e3111b5dc994b0f8e966537a74be7565f2e71531ffdfc4e13808207628bc66ca7111f513584d6b28b4fd1c36988659a0a681ad82dec105b2cf5f0794151b8344edfe712efe50fc0b688552d3892b0bdd4184ae64160ad92066a2b9a4396a33989c6c91aa21ca2579eefc8abe98688edefde17c0daafb353d391561591de8ae067de09bba089e4ff59c1b92e4f8ece803cb1af79fb599493111a374fabe8d20d2ee7d38f4f73149dcd406efe33efe4ef691da8f7f52a5b67313cfd91aa65934d7d4cd455d1b771c818030f5f30ea0cbeb363ebfe2905c4fe3de9d4a207af1999b6f7fdd3ddd6fb0b434c3ace23f6fefe6eead8641bc6ff4e7760322daf50fdcbe650a70b64a23b63f4d4244112e62a66a19449c35cc12cb35b5d7306cd69348be99782630f98f98c542b8ea570609bf4d771db402bb425a02841dc18448674562b32cee85b0cd7491d16d238d2ef904f066efe3a3eb32d1c651f8eb66c508106f9a2556498c099a4adf5ebafe5989a373407c97640a6d3e2577df1deaaf48658cc0ee2da711fa2b19b378308563497cad5fe0036e33eac530c83ddcd159edc458fe604e5650a362bb7208e1e2142014faeee9dbf4ccf9a4ce0c0498c22de772054ba1e11da30216254536871a0052053319447a225c1e14d6d340700423bbb2f90a0d5aee723b90d0ecbdcdc2110cef435a2d65fe07087a4355b0723569d6685ce93b9eb84492facd09a23b74150c6547a08a00e20ff4829b95c402956febbbe32f62a81dd1ba2354b81b8e69ace6bd8c69b46726408bceb3f1cf06d19d92894d018a3355f02cbce5d17bf60e267adadb131221b32fbe80c2d5330a4c84efb0d31fa9cd11638e2ede66d251e9d3acd914d80db407655bc1e5fd8661403405f2eaa31318bd1211f7c363f39f63ae78b74cdc9c21878543e75faeb59912aafaa3d024819625f62a4175facafff1a6ad644713de9367070b084910a7d672bf5e70194f1ad625a14bba6c7e67394acf54e40805df7f6207ed6ea36caaf8b7fbe47f945cf3eb2c22dc3d3f718a7a728205ede34b669e22829bffb79c465af567c2016a672896d414f50d9a5bda6722b8c1d6bb294508ce2861b9854dd7bcf82b1566ca3eaa13467a97049f010f536a11c2afe35f1da3ac8648c27bdce7445fcb905411de4cc5b0f25afb617bbcafbeb55d1c28df2014dfd0515b2f4cd66606446af49155f64af11a7479f7273743156506e659947751b30fed65ded4a41e378361a5ecbbc4b66c191b8c679126bee0f82bdc6ddd5978e972bfeb82269ec31d639fc18054e410b8a5362b357450c8cf579c7b3f311389a5c8851adcaac0cedf57fda1de1e014d2b5fe1d7d7999eabfc351cb4abd0f748259c40ec182c1c3fbb5d23ce8554dbcb76d58d8bee51ccb8b6130b4ba062c4248cb6ada4fbee5dc5d9e0f7416e3907333226f7b417ec1a5ca8d26eafa6b0ae53da55e361431f28900d03f949104dc616133e32be337fd643fc9d4e729d0bd3578c899df8eb64afab66d7389751e72a17412dbc8806cf2e09710dc0bd37625671e21815b2cb03ec865bd1cbb0ba35ef8a3a6fe36509fa4f8fd04336013eb385e96c9c5d1a3759fad8103b6e4936be499910711162b5fc73fa54012fde9b40e220f1ab4a8e896aa645ec3973296d1e0b445b1047333a07f607d77ddc8163ca1c020c2b3d138f60d2eda78149762edbc530dac58ce46043e9238b9e6e7dd346e23c5a0ef61ec9a8cea63ec6f1970c4d0a6a766a396847fe7c596eda99e72b8020ff1f9badaf58beaeea8e39d1cbe661205fc4495d3cf1b3316e4989d1217e81b618b56d462e408fd896cdf8919ac40aa3bb186cafd7cab20b8456f6348b3fb0b36c8d5f7652e4c74c03a3dc1d261370097492f64907a30a42a8ee9f25d2a9ef9a9cda41f08b046c3bdc7eaa9ddf9ec1f65e1f4cb680cbb34f5260ac6ee2388eaf367f158e5d32a6ab6c51ed2e14a6896b0c98f859fe605b8869d92708275f5e415f1b7085e3bfb5f2e997fb2f91ba4f8f544d6b5d6259408991d4e63e23c679b1987db3957243d37be6aa840a4f4f9b476c2de67e2b4cd47d5bb6531913ef08fb75745057f42fb04feee6a060e005426392b254afb27aafb8a3aa36841c9c324c46fe7392a1309178ddfb54178d5e145b6c4004ebf34a9d39ab6aebc1965bcfc06542e899d294c2808f38d6ddbb827e01f2e08f3a563380c8d0f77500f3aa0e1792272d3621e2b1b1e4542c56b75a4a612b607c99d32cab6a94ffd8db446e51a3cfc6f0ac6571c83beabb8cfa9b8aaa17449fdf58101ef6b9c6c2e24a0dd14216bb27a224c24212fb8a616c7e9ab4cff5fd3d3826292a0576d74dcb5a643c4d559881ecd2697b2884b41d3fae649f5e988932364d95a2cc0132a11379084820364c6d555aec9338c3fc5a0a10c80a1dcba3d401264ee6a4fcf86eaef68dce3f5f7d518c121599ecbde6ddbac911fcd1274520afdd895d700aa694e0f3e14db12694491d69f01531b37ad5f5390fa23362658f30e53698397ff4704aa0e09181719599fe7bfef65f84ebc4d15be89a88eb9022de52d49488c2b5186394616fc419018b2106e9cc1d69ea8fecc2935ffd294807408b28ea86faaf9128fdb0e10b0c718fcacac32bb9b8611c31787390c15e5aed37b9d1bc58b09e0a410017760b7291e8de0da30e007c3e136a594d66e8816560896e4c20bbf53bffd5cc77f497f803e1b4df3d983946992c6583957bbddea64678845f92b6a208b0638cfc702f9d91cd5791cc16c8cf71a3560c17a43d4531926a9f406098e105c055a5aa5101beeb504fa2d9bc06d8e36ce5b8bd6c4866d80910e71bf9393c5adbe308157669b00b8bfdb179d2f00cf450092acf9856aa186255d6f2c6a40acd2c0de91df8026763249ae9bba7b5b8cb05ac329fd12b52568cc0763b214b17d40371155f588f4fbad377ca419710dbb0dd25a7b4a7c809c583234952ee8cc19b0602b9f5c3135ee494715cdf23a4ceef909b35edadbc60375a60bc6b9337fbe52755595868f3f1b65dc2cc59d8c9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
