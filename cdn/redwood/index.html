<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9161e458acbea567c21644916f0ed85a520346654d6b68958a923ae09ef07308f1d228ec2193fe6f105e8148e18f0820fd0c7c3f995f14b67dd835d2554772fba30c828926422e588d650039eba9c134fb47d1e06549c68bb19fd13e0461d3e5f6148c2d3f0b51263fa8e83b05a1be197716799d1311c6a0a453faf19c36af7ef3b01aa61b9180833dd9ee5580526dbff99b90faa9fc7aff6737adc62b9e6977fb122b6b007110727d611a3344a6e12b0e4954a4e7b0af5b5b77887ebea67070c4d1c5dae66a3df356020153684376dab15a4c0fdb3ccc31704751f2079da40105582d1869e43ac231289e70a7becca8752505aa18a7a1d2803d61b31835d827fc51e2ad4385d1a6b66ae0c006946bbc223259f7dab3ea8f6d8b3409f0826b24eccf29ef810273dce6948c911da60d95c2c84fee4dcd93286e7bdda358762d5607e15aa3f452e76a99b7b188240d8dc6ebd32131306579f6872b0b7b5e0c2e8356bde5ac21429eac28b6bfcfb13378a3ea08c643953620ccaecc224ed6f3ba147e55fe78e63f25ae0d4054520bc645a5b8d4c99b31824c8ffe5ae800bdd7b284d18aeac63730054d33d879870a3ac461b320aa4d5b5a6892cbe8614018a1aa767284a2e8402b8be44fe96659623e669ea2b1d4cdf81a2dabb65ea9e640770fb5e2e617a2fb92751620b2d1cefcede403a777071985095b437d4b5228d2676013c4d7da93c02c786aae7b16d52104b3e0aff13df1c52948c529c913e6cd2f6f5a128279731ccea38309335dc969fa4db435074e18a0ada66ea5cc7db91f2a0fb50d11088a4d58c5a3f7277d97c14e67d119b4bd392904d03360a0f054543540b8592368c4b3789832340b51c6e9eef03c05fd4dd9604ca3db7230ffa47d2a26051c8aff2d2f3d28a36831dfe96f560d5b5e67e4bef590dce269453e6e75e14474257a90a6a7996546f306bc828537f2464c21e36cb9006737006d370dfddcb4b6b0a23bef1ad22c9c7a252f6cc65ea35298f9d40a6512f632910fc20703b1ad7d3b4d614c2a7a64a69def407088bd8e460c02c5fa57dc3e5794e46fdfc53827afb4fc7c1e6664f88d9b3fc2d392b1ffcc35c13008d6a66e31c9151926e2319599e3f10a074d59cc818931651ffc252dbd25dbd71383b26ceae42d5a94181beb412e0db7815ef89b893dc2f2f678dedff0e9f28a36e8d3c3e98eca8ce012ff24bd95edd25194cf8452198f9a522a83cd6f1a73a94a6da02484989eee2c353e50cddbbabb427afd2628e674be836ea2423ec2ff47d5cebc902fd3a4b904a4513ddc6c66566c1975b28192cf93df713a0819dda577c0e0f833c648e3199f0bcd9376508769ef904ae674f2dc30e913c973035891c7c41bf7a3de620729594aaacac1cfe557ecb76a145aa321d80613498f0415791520b5d6c33f9ddc1e1a25843cb5457a52a7f89f816c0c7912c0c7ec3fcf4f6e629eaa5ebeabde16283b37ebeba30956e7a62e5037a1171b4183aeca5cafbaf7601b401c735c8bedc2c439d0e045448c5b7821f2861b553ac63be00e298b640a140f6228dddee229d70e203affe625e93faffe92126ba0e01b4d5b5fc764159110492e6eeb2c6d66c59a394a6dd87e7cd426d473cb0d1055b3f765ca455416e73767a086223238d542843baa1a968252c46c7c0ce08bb13b5f4e536dadb8e53ce7765e64e40381a13a50699e87add42810cded17f95acc804e04d8a32a4db7de37b1f114a2041cddccbabb4951a11f793570e4ced704d36e3e028edf3a478c6f8d805236e5acd0cfda7c9dadc5af3b3b0af27713b0dd50c496013792b0d961722bca11cf4689c36aa633b6cbc120921bbd5918a12642eebd86b323c4460b40bead730c0b35e8fb5c807a948554324b3a16546ee7108351ae122dff0018748c017ead8436f194d2742390b2780f28acb458c9a0288c83fc808be2b055c74a6815929aed5989d66add2bb4c032d7424c4f3d375ca9b44e0e4c524345347f4c5c500dccfad86249fcb5fc265bcc61829db43d0b007a92a0eac8e8f5298f73268bff6876ffbeb8f34daefffc5585d244bf6074d8822a68db2643e973aa2646b374caa05b5defa1dcc561e0d083f83abe59c43c1b5f3d58c1110199b1bbc4af59ad1fb54e03a361ab75774edc447e2c09d1a696881fe930132d5a003092a50578e4c5bb38bbfb155fa34d73096059290ffa0d28d54e13bf70507cd98604fa03e45c0a7f882173e1b591becc2f278617579d0e5f1523ffa375c319ba5c2d082dc0d2705369f9d7526733d123680d198e55d6576b20391175aae51e34e90fa2cb87c66cf1cae4880d077062a163d4694fb3e512a5a0c95bca70ad463ad585270aa375b54c66522359d3ae04456a77e14f0403ac6f942b7dc952f85ca7f04182f809189ec36b8d14980d5f1ff7a1250dd834406956361a0aa6a27bf33a95d79d2182c502a2815081866a5266febe95be225a81803c5eae39ba00fd351724e748450da0eb886b672846eb5c9dfe9ba55244e61df30b676ed102105a514bcfc500988a767304df9548e286993927a8d153580655c546bf88a5640e5a41b5c3efbe52b8e101327925a42a8db97531e1a7e2e6574008acdddc76bfdcfc386e26aa07aeff7e8505846db5a5cc9e4240fde62ae20df014ca9638e904305d35028966d5206f6bb744bacd13b9fc6588205d4f2b7612abafd3886339510726a1801ce453026fc7d8e94b127189306b1f6b595c85c8ead5d857bacaa6df51f6d250b4518f0186aa4f129558f6da2f6222336beabe77ea432976f5b39fc8995e096732a2be00a0507b3e0b775e1919dbb8ade40728bc7c58448c166214bd991a08b6f7fcde5974026e3087678b8f146e88dc5aab3d162645578217817bd5ff0bc7c112d5c26ec90ef826b678dc096c961af9ce681604c93590491f52d1a6fbef419cb2eef6e6bac74148679fae25cdf55a44f3a852aeb55b733bf76e5baf8a92a35d5401661c2ababe9e84e207725d9e979b5b0a11056654482c23e86662ef536e4ec0a6d6c952b2dc30e93c33ebb3913fba7b4623dbd3fa9b2573b75108a5015a6335dd7fc61b585c81f88dfdbae748524e8dd9859268678ebb3ccdd513d32e6dfdd9f6bd5f436d109b6a4f508d52b1e04d222d41b496053c106b5d35cc65e0f8c5da4dbef012f8ca7698b2187571a46a4ac00569cf632e94d23090331be939206a228edce616dbc2ee5cd78a6e5c9e06b1280211aa48249a2617c896e503180d658fc8d058288991ec6fea56634dbc6b5f29218a91ae837156610563d177f345f089e24693d0a59dfee02e9f0d731e15e94e5fce22ad8a133459346782042f5a7faf6c036f233d041f2bf8340ba51460bdcb8de36f02a75004d9c6c93a0397cc68d3beaa5ac95a019a116cea811d38277c01613c6e63d5db2c0bc25bf52153e8c23b1211a4df813a187fd0ffe9506a1d7df2f9a196febc267a1e2909fc092dd587811d1ca4c3896e277500f9d05787e8538358ffa20506790923b1717bc31f05b1f19555b2d744125378b31b2f213778010551c29843aacef9a037f16d8e5602d4a3007fe6d68ee3fdd679ee0d9e12fb3e70a4b3fe198eaf265c2c1b7fb998e25e35e441c62653173c68c6f378998e380a6b2484e90178957a4000a4bc82dd9fa64aa9d95780d2732c52be3d1374f0df6ecab320769c09f069f6e5cbaee9faa626db5cdcbd206946a8ea6c2ae0d3522b065cfb9daf729d79ebb60ba029818fed032f355ca95a16a26825e735ef48ac4c77a7a4b9e11acec3336c35356d2cff9a7776314206abc6f72f21e92e579c50032bce1d129c7eec0bfd2df725be4c421c6004082d563056c0c95f6128df64888d36c33c020e9fe1575229356a4b0bfd7e0dbc6f0601177fb5e28103e8b271f058cb2de327a3fd825ef1234555cbaa8221c3fd8bfbddaa88cf5e6980b717173718ddc8dd15246be2cd0052a7cba26866b0baac1eb0758e9491958f33250c4515e049e180436f2248ce4d5febcd4bdec9c4f34001ca93003dc26f564aa691ce6046ecc9c9084797a8ec1a066c8f2a3097993f3c308c06abca4000f4588624097ab74207f7fe4efbffe79dc8cc653ffc88bcef8307265a927c4eaad50ce9475065bb06e77acd43e5655a80f80b2d4ef1fe2636a6e49c3ce425d6de948cbb0129f53fdeb2010e6abb08acf44a4107d1fcc0cf9760e40470911bac3a12e6a23cc01dc386b0fcdb5034c67c57d153f0d369a968a54ec38f3c45838d8170570f36c1362d6de29a369a555addabc6355337d359006fec77107ff8aa1e435a6be9415db5cfda2ec2023ea34868e661b79e2eff18054f1597fd372fe178d6248b55513bf31e7cf0df06b607543ba6bf218a6110e6ed9aa2c94f5c7f2624b9ccc56fa8f9ec605bbcb6c0bdee27974d9934329bd6cbb2b4fcc585853f64b431e4ee2ed844524082dfa9f0d5c0f094571bcf38eb2698f1f04017a1466b2c978db5a561c8e03b9552b0592bc5334434b5f8ad7120abb0825ed13aa9173cbabb01f9d71a6324fefe9ae31e9df34e79bc99da809244106fc91d7aad667fcba93c09af33632d618f2947a3f04a670ce4d6a6af481796ffabb028dbf012b2d73a30cd6a963d465693d29e8dceb9a7e36947a732eef07e114c1cd12f27b95a89a97f9fe6f6c1a45ab75b53186f5b2370536a2b83cf8047456e90e7f9714e9646aacff64b3906c75d18b20e247e3f13aad40d54d06d1e114c94a048f460ab554b7897a18c69c1551c6f3ef17d4ddc9d9537c78ef2a29bc5ba27d55558b6f3d6a2e5cd1b9a8ccb69fd69d67fcf950ba026acbdf8ac32b638c43d22f2c5bf867f72582af543faf7f463a1ec9bd21fd45d0bb84e6eccc409d9e71c3cc4517cbdc34416687bad01a950f12966ad42cd1cf623c3396d20f98c63dc93f2521b36c02ce295879292381c566ecefde522d8e2585c9dbd8fff9317d2e69884840743c86560ee5d2bb75f6ea3221de88506468ff10da5615568ecc2c0545fbd688cafc281cbd79c27c3aa1d15c86ca6b869ea5ad8b84ae0ce08d348d9ec00f65389cc95cc9d3f2a2d540d1026da8d4041b9feb8eb3913c99d872a09a00a6a2e8c74f036547fd9d204860e43e393d6bc9f8ae59bd4c4c82f30664ba46c8daaaf833f475eb5efaad63785ff0ad743484086619ab7937938acb1d53619bddfc4d8857e75b965cb8fcd9a09edf7fdd21c0ca9f3140c3d159a3cd1112386e07d17f9eacbee55952b1f4080e4b284c9532fccda0b4ee822c462c7bc8c01264660da3d5d22c688b61b6c342990efc594fd3de8c2d8ac3a884f29225e63f2d8e35b00d7c160810d7c65f403c0c8c1cf7c78527a5b99ee0944d90a5f3ff0fab5c0de15090a61a2fcca2a5cb3090b198e3c1356f99ddb3682cd37921b074dab0ed63e2cca3ef8912999ba69f7a349ed4b75b72b604a226fc9ce878db13b094cc43ea717f6dbc4121401f21b8913af108d57adcef6241499eaa2a4e9e81910643a64608d94593c62ea2b03da95b4ca545faedad4fa154308202e4310d03c67faccc83eeca9f52afd349665ff960f4ba4f678bc18bceb3684a164df25214f747e7fbf600e97940af895d4db35f01f75fe75f7e221728f2d6dedff4a733964cccb19d9edb00e9341f81871468f8a329c4148a4a10d4cfc3702789cd0e24a2bccefece3d937e08567cf7ba594725415a6daa47765c2f9a263e1f9dd4209597c2c7279706a8cc1a8637d8691789429caf9a731da7d35abc701393b77af8b20eeb8a040e7f7a9aa4c6d8c63ede4a718c0403d4df8ba74fd5529bbf2d1249a48a5b31a3a26ad284117956f6fb3099dfc48b8308d4bceee28411182d1beec0e3dcc01a4d216e0ecfc2eb8277fe681dbd4167e705e2eb4c222a6e6bd29c2da38e73b18bffbe4a728b8f645d82b260c6574a3d359fc8897a8a233f50e0d9ebad2b44c116f70baea000a858cda912a5311e8f68b3cb3c1774238a6fe03ccd33048bd90acc11091e5a5b55e2d3e0d73819322fadd49b36e681e4f52f38b7c42aef31f492d6c2323adcd57387c1d94ea7b15c161b5583e2bb0a5cc7c0037bc2e52edb03c80a1dd2f105022316929d7ae14c779ad91a53f920173e492241dfb10c7e527114ee475787c0127548c415a054de3418a6fe8fc90bfe206932ad5602e8c0006297e96336808e5efd9da9c9685ed837b340dbb97df219cf2a46ae4596038db77cca040d14084efd88a4dfa5b1b27f12d9c7ecf32f41d5f77ecce0d8d2be9d1b2d7412c9eeda83194fdd189cf9eb373c5ae28ef888634129192af373ad29a5a4d60d081cb19c056c668a521c67e69b413484592cc528f8cd3da7b898647ad81f4e34a9220cd1dcfbac060ea8b92e14ccb658ed5411e7fd58228867b4203b7c39578f53dc7e419c2033cb242493009e9a5f05c487f7612deff40afb49f657a87416f4fc7673745f174715db392dfd135d771db53f143dffbdd97ad82b5964bc336827a4908bee7add40f9afa125dcf0bc40fcd50653dc8bd5ae601306a3e01100c4df828aa684836db137080accc86476568cb1aa85fee4bcebd4e31a543f3fab101b368aca6a85aa84ec75cc79a64c6f3f288b048ea52858a5fad3cea3563c6807ea09f46a9a3470011764f370d4cad30c10128fb114dfd613bc86444a66c5bb661b5a2062ad73ab816246e46f05da43954008fb436e1ffcbfb2be397c2a0745de21a74b20d76a717b449945a45a5267b260b97fbc3ebf5cd286df051670f776322edf6063274b48bd30fe6f1958024916da2cfeadacaf6fa5ea1df6ae2c35bb96c061f5594dfd96ea6008f7beb44788afda4720dbdc30e0c764c81dcd0e5e528450f88932050acb3b2c5352a694a02529fa3ad3cbe96f0c7ddb5a59621101524db444defc8dbb3861291ede8fc2cb04390ad7f6af451fd9a38bc6ed5c9630db5ebff350dd10b217df5d5b234fcc657b60a5ab0eeaa0bc63fec1e0f127db269ea45eddbe195a9804cf383deb321b1c4278a3196f117f6f231cbe128bb13d23b8d7d341bb29c75e4a60ef20bf1cab04f883e9344dcd37fc931ed018875444241c925b7baca5c3f1b2a80aa4a9da15937119648c62ee45a474bfaa09d12bdb6ae7151ea27c51ee6be58ec61f82c9ba0638b5a4cb5ca390eabd0381d40185d05dd72eca38cdd2112c3936b45826b27f78dcd8d5a40a979d1755e5aa4644024e051d9413c5939d2ab135fe94a421f0af2307b8557f91edb76a4bafe92b22be4eddef790c00246cafd0c2a1e0f5445d5e7b0d8f9637fe909b57f9a7ce22987fb8527205f37856828f69f670bd5f9134cd201bebbc762c079f53b12dd36347a68d9771b27528685bd76cb4d90417c43c0984e9bed198dd4699618ca48c253787d031573c68f267e05ea4b0d56014e801ea8db77e07c87c684e165f812852677cd08688db936017479705006db72239c4b80ef515af48612e0d8d4da96ba3cb8757c9d7c2080a768706a62004489d54624cd97ee3d5b83b096fd6a1b4db7cfde0877f06a00030af15053d47de11270902ec2cb516842f96ba7ed6dc4bbbbcbce32cb11bfee44da1df30b31cb4958dbf399a36c6d4242317841bc6107fbe580411ed55a802abd48f0f38dc331a4ba986481c3c60786cd1101174713e549d9c12dd1d6ed72465e901dfdb003c579114ba69c6eb68440eb0b99097e31a8643102324a68384d90bd150db442ef0d2f8462d4cf32e11a8f66bb3ecdb6ec33637bdd0f8583e08814345ab2d4b0d0f4ce554cf4111b5159113184bfd3fe87760d40095685aef15cbd949c3064d98206a5ff7e571d69b8b9b25d59fd0a73e084af22934aab7cd3f22ed8da82ef54036751c720d5943c4380846b951f218ae3c0292eb910910effc32593166b729c7790c47ec2fd9231dd28b36bc957d14f9d07771ba8c162a48529e21557468018f63c768356ca272132171a8c1a4744291d832765e6c2c9d8ec8ade0795453dd61f3f4402aa26ce1ebb01ed68cd79100758af17667b680c30d8ad85a94ced061c50fb26818f39447aee5d8a25ee83e6aa85e11a0a1557764a5e7eb591b91fd756d075c5641b3a9fd9827a47dceeb68f05c000ba2222dc39794902bb68c778f6bc48e5422b8ae6105722a7a103b74a34e814d3ddcb3d29b33be89ff7fe9eb6580c6cc74e1b6a2600fa5e614f5d7bcc467b401f895aa04c93c2681723f2ff34eea5c8f8177e1add1afd7606ffa665fef72553766f8f3cc713befd99c078bdf210a388021ae8050b38f8ea4add5c034ad33eda54f7145b367955cf26309e1b4a9340984042e97fa79ba65b93ab754ebd51cae49f557307a4c56409dfaee21519fd70d6f18d1487ec9207a5d62b5d3598e7b28a3a5fd2bec7b560d76f21ce222a7dd6ee652d62a634a85ec979b9b0215ca8e5676b5801f5355b2ed524e57e78e5eac06c39db34e45213902b1b6669c2edf6343e145d836fa692465af98c1ca043147a88c2696d0fae52e11ddd002ea67c8be02502661c6e5ecce0a297dc3f1d3471047182feab3a3a637d6aaacd80a15dd5b47a24b175afda971ebcd474b422f86f4abd0ed01e9fd3908aac1af8273488a77a777080ba81937d6ec766b32d88b632c4864a587900690727dd5691d7b596bafc753d7209d646d0b543f13f7496925f6e31b026f40afbb90de3c8d080bf0772104d95cb656c200afa4c1c22e6ba375f64aa6a7091d32909ad0dcdd5482e23459c71627e6d90a04deae60ac6b380aced17d43a974388398e2ce71fdc64b73b9a74d16303d2509500698e32d21a2c6931168df223b3a4e082160f5be05c8bab9607d0f771d296dd398acc82ce1a924a61b74e06681820a913eba4f175265099cd099c8205949bdddcaaf6c93efc5b0d3071bace617ab2ff564032c869764d2043d7a840ed58b2a6c6d3f4af6ad048155ffd823fc32f8307a7be4ea413df0a7f71cecefdd53fc929a0836c2928f1a394f55d81c373d221d3a37b75c99bf76246a7d0d833445c3b822723f797ac406ab4e8107a5df1d3693c47506f654343b852bfcae9a7ddfdf5d4b433d3a9c0e54aecad128a45d35ee5a72a5217e34dc8c013f0ebad7d9feadee916b7feaeb9c5a1ecfec776ada28874c017a6affad645382d573b444bd4af31a89160dadc0f52e68d2cbdbd24e08707630fca25976d870c2debb37852ab736da5a70c47a0f93080c845ab75d598b66ee404217933381a174f30e8f42761e709be450fe0792431d512aea5a56e0cd6ebea31b82fb79f4acade2af76e009ea17d7109a46508c16d5c9c8f72722f756d6e2bab0954a70e3a06410fb71ca58705400e99622dff90d4922bf474533cd6ca9b18faf6faf2e0a0783438f5f3d474592aac3597064a7cc1aaf136b94bbcfb0b2a59d3b184e0db98149ae19edc259625e6ab8fb52e00531cd77fb9d7bc589a4ecd9a11bca895b5949a9fad66c5e9d383d9ba4e01a8b502224e10650bfe7dd0ce24dca0810f7b430c300fd1d58f1cedb95bf641fae10bb715911270f88b521a4a532a005033a6889ee04e4b20160fab3e360d4d6cbfa40ff8d48c06e87f0391b6f5d23c80828a07d935c06853e064df4ed42270c188fefb71b65eb2d011ad0bb87d974166515547fcef915523e841a376e63a1da37533c72e23a9de8d62ac182f2403b3ec4efb293e8c3aa0ae498addfd3ab773b4a6a6388c8db11d7a285c057a963002a4a68937bf6e3d7e7cf358c36d39e2e311160251e0752f1846d09b3a678db911bc2bdc486fa049e1ed89ceab72e7d58fb236736051c5666bcc47a9db46415925e90bd1d52c6b3f23390ef6d6ba5711716bca0aea86d68310fafc67ca4f3613051e760be4484eec18c998380d23e6f0289034208ae42583e87bd59fa2b34055c31ddedb69ce7d4de03ad1996925d8cd9b6f745b6e929f8e3546aaa71120efa7838e5cad84166c5b3b89b8ccd4d2187cf27f1b19eb72fa2e2c35411971b56f1f414ad725c163d26f816236302bce7b5c10600563782e6a24b0d3fc16e3881f046faef11add7fc00e92a53b5ddc03251627d3dab41abd20ade8bb7c431f236c362e4bc2952e45cd597ad4dc9d801d4b3d973958bb81095b2a898fef36439f1dedd776371b060ccc61c7f28b1c4ed1c889eeca0243d610f0eac8ca0e1a0b021bfea45d226113834fc73990828616e618a9c363c6bb6fe05a12dba5237203ccb83594f61d90c180a3f5e35d451d008a1522b82b6b0d5088b16a5825c2623a8773fb0cb8fb9cd3041f30c976e63613396a8b57bd99620dfd8831c32470487ce0e76e26091e404087bcb79e4dd074a0e9b4844da324248ad08b18db8ccc01fde34d00cad89c731486a0ab0976e2502933b4023c416af9c34c6a09ebbebee3edad1ffa5cd276563ffb29bc79d92feab3d093abd5c4ecebd6249b2c8a1b9a213210846977c230752fdc11bb6251f408b8941267dff257b9bf7ade5a73fee61f3fab459d3f0c4e6ce550b4729838e5d54bc488a5c76baa6c654a7ae6673a7c1c4b8706e34ccc14538dc11ef980661c0310ccc9e71477e6f039c5173b4aef39ad0515d843f96ee0038d76c41bf51015f7acf8a8998785680fed12f1afc219f5f46791fdbd13568dff09987ed0b08154a0c6418cf489fde807e63643540d0af5d1efc1fae29cf46eb1a722e5d6f1b2d8ebf4c45b22ed6a3e1b0e7f0dd7ddbf3311dcc13a61c8e89cc2f6d59d94e0040e55027aeb85256ea670d351296823636927872b6567d85b4251514793a62196d28cbfdd9a8d933a757425a2268fd72e3741f1143e53c80d10a4cdef47d229cc86055afa2a8193b2881db4d3bbb59f6532ffcc1310d2180b713982438d76eec96ac228b500c9907ddb4ac8b19c0676d0bb31934eda868f0b29c8c1a46dc0d48adf8f2c25dd3f347d937ff9733494ba9620a8916deb53fbec3828a14eeef6c18c2fa349557fcacbfdfc9bad40646d0727d2eca75d1adb89b3fe230743202fe6e0c587d84b0eebe2d9006ae7d8fd8f6487f6de41d8b5b7e1492635986b1737b51bc33b1e66d69798dceb333169a5433122c287f43e37ab869637d84388b8c15deb969f21fc80c7b3d117710ce5b1e870dbc27cd1f6d812f2dea85a2cf79ab974ba779a6f10988ba0c1f34f31fff64fe78ce32fd417ec86a4de2c3e4c437b0a8cbbfea348eb775f3fe042688f8317af4a6fe580a37f615feb3153188e9364e17e5d17b909a0c48dab9ef0a8b86b6f9fe822f82e4829f529c6cad2e9b3693943d081fcbea9a603cc371f1789a9a2c81477eebbe06806f647ee063d7b7206cee44c8e103772ae2199cb249479fc780c28cea9d68b91716da0d8122f9a764f08ef716aa376da589d357bb59cc677d4e15321bb3891c07aa0587fad2b063d487515f3eabebe6459579c2d6389802d9648bb9adc7c931bc801deb592b56af9047d02eaee39277afd147ecfa21ef0f21da63ac85eb9b8956689318ed2f93574f31c37e0ea1b2b59e19d8fad37d2e1b20094df73ef0407e65cae9546bd487879f96efbef56a117fec0b1f92baeb4d1a53f8aa20b81926d6263391578e434ef135db332bf4de32a925df11fdde9dce7c50bd3c80d4aa976746ef403cbe919c9baaa9f1290a9d61ce0f8512c910b63c8ee28637efd50cb728d5378d16940ab8c0ed201659c7651e26b3289a4b10489e7733806d79583b84391b6bf787e0d8f26e7928065639b4cd01b85678ce08cae94ba4fbb3d1cb9f4737dbf1b2dde76a353732721be655caa4e6933018e492f1ab3b4b0ff3dddda174259248ce37fcc6b3078addf0751286a37651aeb046f8f9cf0febe3aa3de52bb76060040073c2d404d1ac001de9acdb0f71c973e3943a5bada7811996d5d3f044c9d6a1db88df1fdc6072a9d4b93b12c6344dd65585d33166656f1293b9f6002c4eab87163afeffd12e1086f446245c36ca5dd592243508c60e6493f3683454e68276a1fa31a96dbe6a315eb95738f445ffb9dc75e5e25a1d71fec15139de58f1a2bdeb255b6cf8ce1a3c0359c7dae583e01b774f582fd4d33d04f413a7101b9c41565f5b39e56e64e3582025ae07b7b48aa1df671dd5844829d8305d90b5cc2dc178cf1b9b029d8519118e34621287024ea0311925bc6eae87c41cfd6975dd56bc6dd15b12722e23571d42479517d78e7f1a737fe21c22fbfa09f3b87d2eda5726bce36611e965f179c420454a532de6265bab6240f7e6a8af0d2e632646b8d7a0c842bf66d210ec0d2973287d826e9c0281da3accedaaa140b57f2fe6aae88dbb4e7bfa48b96ba2100cab2e328b0ec405ec3e7c4b7c3811216b8d2ee0fbf0c46376a08b924c584a6b06b3767dfd0e19c73bd645798dc775f9244685899a8f5f64587bf4c6afe982f2df3ff8254d1b63a5c27c7de4808090833685c721110dd4fa915eb2f3b9f5b95be741a85f3f58c7093c57765a4a08c3c7c8dad72eda72e712468ca3bb8ee303f41a2faa1933804aaa8e2bb04f69bdc97ddf651e9083794f27a618389b24aab635bc8f4e43957db6665947876acb81e8a7e12108af644aaf8c9814e34b71194a0fa0d9ecfb257b90ee3d76668567429eefda7d0d659307304dbd310ab8b6d3a5329dd63a130f5b06964f40786a1b4fd824caa8bc6b8e8d19462c3693ee356857fd69ff880fd87fd521da5163079920cb20df237de974cf71d1329e9c4d639840b4b1e37bac8f4e6607b6210ea01598d9d703ccdce02fbb0389ab77ebd396ed1df1581ddaf4a47db20db083feac12deee1ed14a81ca9c599e3eadd038fe1699bb7b7ce7a0317976d1bb968f8fe9e818e85a4344c98538b49c893be4ff76e63e32ebfbb0464e05a8e07d841f5595ed0cd66eac76b994559fc666e685339abb12d54b4cd0ad7f850440ccfd657bb60b862a03dfe14b6d6ea7fc8b155f72dc7c75fa503489c279c933fed146b7282b42720bbb9b8e51b611829977e46a13d427d539e355741c2b05633ea60479403804dfee2f7a3a12cc9cd63cb3698b3bdb30080b9566e586ae7b961a46dd8bc2ad615119b30fc62996d38a6207249ef6f0c445eee4ad1b31624fea33021533e16f0906bd29246b7c5301b46a009ce04e9da2ef2bffbc360a4b0eb440bff22c82cd8545157a1b89f80165be306561a7d8da1c25e2992aade0ba13c4b90ff31d73fe37a7aa3699557427037b54dec02b541cc6c3fdd27096dc25e4280ddab26b264621f5b625c4eb83f104f3e857d7752570037515a119be04a4f14a21c200a69b78a25116117bb8fc46395364c54f7248611e136e6ab7df8bfef9bb33531f4796613be412907b6848beda1cf35ef92223875f26999bd32b1a6f78de5112cbf18605b2bc0a929892ecf1c2a674fb371f749ff5cb08ceab3de74045b5499f5913a75cea7f0bc17b95b72cd9889c06127472ea38a3f7d57dfb8b7a9dff2c6581bda7795c54fcd89b1bf954002198044f93381af0a10b17670cacde1572143485c3c108965c3c630a4457c02e08ef32a6c7f25148df7998e9892cb8b569c6c7bc580dd3dea809e687af6aa6f60501b79c34a390258aedf5573d8633b57d910da489d7cdca6b3a0af8318e5a30421b14c7e6a918991a1551c1546d8504637eb7e021e06176b124fe8fd54f4b6dfa097067c7a5e225c26056cf316bbc24124016759d119c58577e15020ad7b621d0cad1ee0ca6063973da56c1739163eb9943778921b2e2b4118b6a1e4350483a479f1d0257f532c188a499b89450a18dd7b354c613987adf7edd26ade0ddeb3b1ce2a8ac33135a6682d26b986164de3c907c53c19ffc7c11154ced1567953684b823e7176a81d965c80ec05e1aa86fce6f68272d1076343a32b89e265a7b6f5d9074351308a4595ef311481bab006987b1327f03212cfc2487f1f8d7718e489b45b603045ec4512a82e66d6854eb850ee1ee4707ab4c7f047dff1a273f69e23012a4ce03a043c639ae7c902ae42469196ed1a5244b1b7d812fcb65d40173c9527ce6c4ae7437fd3806947de04c3fb274f144b130474d9a25449628d17db72fbf7c924c25f4b7e66ad3490a26fa5f39894f62ea60e757c8566c9ce3f237c03b125976c8117ece9d4b921585998d879053ef5792cd26f43b97bfe5b26fa137db53fc3ad9501bc2252e92cbceaebe103cfd85b426956314d6f3cc7617adce4764152cf18f32e6c0daf60ffa767de1917e11afad5ac82afcd19578f7a98f9487764bfb41e132b4569b6be768e5cbeba22b6a62df36128f76ba32217bce1636f1916dc6b2ae0a97ba7db7d95c9385264b5fad17c17c10123cdf9ba548e2c0ff1e3c439e1183ba7d9f4989b910f82ece0bb5b4fe6be98d72c8a44cc43844c7b53b954cb8328ed8d944dfd556ff59a57c5197d3920231bfafd48998c030848cd5ab4e515088a416c403485f14da44b8da3b0b81d5381110571e08ad38ec28c4fc0ac9adfc26e0737b2bfd351265bed230a40572d60ea0b4e6b08500c9469f9e10cad4526b0bcc27b70572e9d7d15c204564b70329ea67ff9ff43815f6c5b7f0647c5f6f731bfa69255b77ff0daae671906f5cf36a9ea8a3ba28de1b8dce2c3a2ea2a0822490a58a8d215094f52aa6ec3499a9c0b1ef65324cbb7c86253717261cff1baddf02d8dd7f65558a4c4a2a97c5b9a3aa0cf22c5bd66e173aca906286644a6970eeb5c8a8bde20142bdeb610a01065e6c69ef0fdc28ff6dd3d80fdfe4c51be49a6ae9eacb706321ed1c43ce677a9290ae9e3e3e3588d91ced7f1d074789b46387363da4e2326c6f654da58d3f8b587853dd3aab13faf51e533cdcda24cf6635e11b5e9478490a98689ae5baec3c8da3fed15cb6eebf420d94e9203dff4fff6105fa36fdb85ae18d98752441cb55988e5b801d644998e8a4aa0a3cf80c3c313a5d3d6c18e0713f51757d07fc72f0506bf1d622b9540de3de794daca0818a48f4f16078125dd352530cd65dc84403fb35d5ac65b7bd14e31cb75139cdc7e3f5bdeff81a412d7b7d0ccc8b699634353735378c507939d733efabba383b70992f48a5ae83b120615243c338854f6d2b643df48666315628a3e5588dd5bd10aba33060b55eb32e0291b3a0029ca895cdc57f7c52fc4366aa418ef8ea73e06401aa2523083def4e471113d140f1a5e95abe865e042dd882e4f9550ac2fefd931e731a083d1f627d3c2b0d6872bb9b27effdd394f8b1c2587121b48b9d95bbf65d09bb5e8167c67bf495dad66290ccf8f14b7145fb02c040bb9955344de49cf7957e43b62b3ab723402b5ffc46c93c300b9578327c1a0018584377fe7648b33f7f1ffdcda1acef39579fbbaba991829b04256c96b0782a283c53c30d17e67d479d7728d4e451770f35398a8eb28cd1dbf7c12c66bdf830d7629bb9879e02c3b2326cc5d537a2b4a50e8386ce502e8bc8acdf17d47d151147e87ab145962c7fc4c4697991424dd3527cbd56477ebdce2762f0d5cec0c1b17971ccfe62fe4322a1717afd35239c424e4c0ff47f6a577a71d1217f067ffc4dcee20ca20ea6f90e405daa7842a2d635ef07823344e929f27ba27cc3948ae850d2d0d6b64818db3e83b29512eaa62b267691d955ca9683eb8bbb9046c95a5629ae9fc9f4f41f285367694cf8b5d9c01dbce516776e0279080480f0185be0e2f316a02a2265b3efc4ab20daf5e7bc8dd80142cd4efa85491fbfb6508bcc32540a4d230f38f9fd01febc5af14a5219d65b51b72128c976b415bca236b07d4df70d82e3bda138e9253b71acea4be8a211d51c16714dd669f094189797d4fd5a343c66ef915acfc3be43167cb6966b757d7598299c5329f33c57b44e805b5d75c76ef9ad0475c261c238acdbc5f58a49bb4094ad7c9e587215529316bcfb482825fb9e8e57e680ac8c153e18f8ea4eb643928a0f6677665c67773af9e98c60953d8ab62b772ad4ba0cde0f8d1814b3ed9d9df6f891416e0d84718dcd51af741ad736c4416b01d597298cc991a95d37fc2466e2b1c47219d5d2ad9d7647fc3c336639b6323b8c12560486ee907fdd2a1be2b78a0d2b727334fed204218d830b09bd0d1f5d3982304e3a5f31922ed9cd992cb84e4762043214b8998294dc5e639ab898ade76e58aab32f729467e9269c53096e97f53b01799f1125ca2c4105a86e6ac1b148ddf40a8aa856f651e599ef4c301dc1eb004297f33633ee38a2dbd0980930e802084f50de586da6c65693da6c493744f8874aa5c6e4912658f4e1e070930229886305988ceb977a02ec782051722cfacd547ba031413cfbff40c28b0070a0186fff7beccb1831520451f4fd0fd012309f1dbb7c60320a20c7a7593f31015bd831590daa1cb95554eb1c2ee146cc5758a2fa6a5bffcddaa3b565a6aae5be789c2e7a39d46aa2a142227e00c61b09bb0d664b99c7796ebf767ff7e28ce99603dc9c1c3595421557745d05f1cf04a3ff6cd8b5ed3b81c6cc6cda7d9e53ea83f5d9c1e356b9727429aa8e810372a615d131712329c7d1e9150e196f8c515e19bdb292048c6c63e1c7f7d588f50e2517cb4ad4bdb39da550e44e5bc801113421a97d219b3c8fd3d75c434017880f698956f66ad8bceb226e3462354714e290c25baad0629101a87cc5d185ff4b95be071ff367d6feb61323da31015fe40f02880f6fc2e15f49f37b09012b62f00f7e6646e30734e4fed06bff05f4af3f171879aa49af4aaf4d53a8e5884c7781368f50bb49a744109607e9f0b9eba047701709c9afb51f190f7965f0ee5e6e4ac26bb938a8ea78aa660a67c97b4396bbc53820d8dce2513dcfc8fd174b11b33c244a08eb95c4cb778fc0bc0a9b3b18bb86bac5255eb28f2e08c8dd5f430d11e4b1f1391810af10d332a23ea3b475f92e7db51027e011ad85dab376c88a95ab6bf773443b5fdee68b50c7aabe48febeb24db6fd4c722291f1a0a5b437f2c74baac86d576a66b056844b42e828a71c24c6beb45a03ebcca00d1b325e1b5fbbbdcebe0f0240b492b670a3944c2ac72d913022a693df58fbc30e1b1c9538d46f63cfdae93564714d4599bb59b7b7d951d672f0279618d922351585a015d82f3b7a4d289f9cd10fe665c61e19c6f2ea959985d99ed3f5222ca4fb370a0a1f1fcc35b823a2b286ce2c18611c9ec41a8fcd0f907cc9a70212656cc64b1f1997acf44dd4921e64bad3645b3a631627af25dce4e3f3579c32f42edcaee500de209b86c9838ffabf3425a027b376031179fa184fa71ae352ea9b1f70e6c79d904e59ade1a0acde4c7f03842ccb62a04352fceaf2ab9a5e0bec58ccf2456499ff6a1d9c47b37de291757157ff8ae41cd374de60199c87e3d1c84c5cb2f42691a5c236a0e6ca0ca14e5a4d8c3e4b7eb7d87fb7fbfdbe5020355a49c29e86b72df01eb1ecf4f255376eb46dbb80a71ae5515fa16d73546c05f9c62b3342d0d731ff0784367c93c1325a0f48f159c3bbba1b2063343e7d87e3b715b0f9730bf540d22bacdd2d72e8e9c57e14ec40496e89fb58c9a15e8f5fc8e453e4141f1a8c66fca415e588c125e49d62fc39ff154f4621bf924123ee623eea19073e441b2907c5e24454a63a45ea60d4829111db22c89507042e73a977d956c50b17d8b34b339718954e2a9a58c43fa1a7c2ae626ee0da2d6f386940f2b13f6fd248aff977711cdb2c092bd32eb0d5a687e71a52f3b089eb00c7785d02c40861c23cb01ff9cdf6bc1682d4c93d52855887ff1997beb76fe4e09e0a01439e1ad910b2c0f47b48773309c709296873ec82a20621a2abbf9914c1365546791f4a80b5a7fd4cac28288736ed607df1be9d58f642d28a3e62d4496dd38322ddeb169730df9ced51a5ba5d3f35ceef71566f5b2dc5b253d5a739d4a09661d1ca90606704353615050a1d2f027787977537c5348951eb6123c43c29d313a248b55861d94928587b7e264e4331c582f4b6659c98f3d57a8c48104cf695fec3a81c21a290a2649c9a1d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
