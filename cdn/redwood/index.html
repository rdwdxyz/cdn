<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f9df5300b57d730e17dcb27f503a5d8e66a89ffafdffcfd04ae8e6469008acb8e050e211f12fa5faf8fdbb4ca71019f77cf033944f68d50bfa98c056e43489b9ac366cb5d9bc93bcc5a1ff8684456ff983ec945b82d9076efd99e7be09922b2b24b2fa90af86494ed533a3f7eaabab05e77bbc5f5e436f73d95ba90ba905153f4016a66ec97fe407dedb75236bae96b20852028d24f45d439b55e7474cdb3821b32ee09c0a95ee952ec2738644b197a63a7bb3a1d555fed4f9208b3fda7bc34bd86179c312e013df123945fa21aec89266f9d1bf30699dd6d2c0478ef8427cdf09d2d25d0d5af827324b2e952efcfa9da28f411a9d1e319b1afc598c4b78a2dff47f3417ae35bd45b929d370e6aeb1dd281c90c9437c5fd578477b9d48749741491dea1d8a041418871ae92e1db5dcc02aec7880d67a611f0c526e6c1bba11d5dcd77089e203dac3219f1c7801765c163396f368ad14142045224c644522552c73f0b83bbb2332c5331b3184f6f7e16e34d89e81b53cad35554756002c4ddc9edeafb7d5ce80c0b105584a7a7158b858ccaec2610556412409f3e324a2f42daa97457b65deae2a471033c90a979d6580ef46734e2fea848319355e89662169e7b3d8fca6f00aa6f7903dee911a35dcb1f1db469226a30d8e86d51afcd9b5bf0a67bf1b88b69580052b5c08a848d99b4cb241404b0cccb28a7e23bcd0941ce62a746961292df0d79a0b1e3c117ce9916fcb82386097966658ce36f9aa1ab0b8de36574d07c555dfd6938180cdfd070e5620c26bad78c98c71a253b4c6ce80a194b50a37bada302b3841c1a7bc69a965bb766eb1d6213ccc815c73fdb0c328bf515ad06bc0ff19452499ab931fa9059da8efd6d1bd709f2292a57563a7c82fe2fe1ac610788f60d44033acaacd9950f5e967db5fb7c30b99d532a0fc65dbf222de8d4ff701b6f00b9b3f10606472ce50669870995ddb3b6f637d481fb166f35237076c38cfd41f6bfb9368f95928635f6f469bbb996aa4dff0e464de427695faeca2fa73782184c11420d61c32ce9e04311897d4fdd3d0915fc1de899adab513758d2467fa5de97466c4b7fb5bddd470dd751ce9c61a572dbebde630c93d874d019217f8f2d127a66fc1b1586a88ed4d12197af8c342634e8b0949c1f0f340b0e8eea91bee3a7ae5faeeae20e718adfabb2281e4cac1245bbd9b6334359c01429964b3530970cdf139c7530b56b96804a2ee38a6919923636741327181d1e15dae91a2f4511bd0912e035dba0fe6d9d00e742f3c9a528eea2cb398bbdb95d26f8bb9eff930c784a18b6867f3b91c684367caad48930250e6677f22da8e267c067e64078501f3f4187f450efdb380c4f2d7d00e7d8ad5689945fe8d2b511cf9ea4ade226a1b84115c551eb959fe225b1a3d4d67ba6d1a986212a0bbe3408810e5cb7d65f90778571c7acb50aca72db84be31600d1b41d23d9b2707caa519af4cef7e29e0667bbc9c6ccef7fe07aef1ce18716a7e0f447935aac035e36edbafc09e0dcb92c7290aab0cdbbd686a900f6b1455f198e3798002ef7530dcdf012651c175c4dfd1446463497358b9d9cef6c5543814a7bfe6022a1526802a5257bbb1e676bda94dfb3be3377f299dc850521a96d7e39b389443aa80dad1fa650ad1ca7c356b232936713dfbbb84e96e719eaa00c912c876d2f06a133aa9548608370f6c68ed36492985b2947f2daaee1b1e30ea095b767c028893a8098aa8b74d372cbb2b654bb878cead8fcd561bc52ab9513b599954b07cde52d65ea9338aff117b2e13cebeebf2764c77398ac96eaafea7b11c1524b9733987a4fb99dd9f25bf42b065f6095f7ed414277cdfea9fdffa438a31bd9133ee27dd453f44f72a05a336f40ec5cc582b5ce9671ce92076fae905ed5c5e9a8d332125d57988cd5f9ac8c04ed19526fe2cd5aba592f2218817df549cc4fed4891c0978bd29d14ad7953517ebf4a3ecba836dcb8992f9922462e9b3584477dc7054983e33a3623ee36fae8d2f8cd70bb65941759afe3b8f0879d681eb8ddfb8096cdde542b91cc639b821f7aa27b4b76602bd210ce518bface671fde3c2f872ebcfcbb5233ac0317ec8d5707a2f184d2a42c0a385658358efdf366ae87ad296197213ab0810abcef9314edaf87a9d2642f95adc8dce26c30065ff11272e083183595c785f1a50ffff6e8dbb24a9170c824c7f4f3783a5c254f8f7592d7a599ee12ecc73e7f5de2c01c6ab2580d83d5889f0a7755d4ac4983f6a33f6c720f05f3ed645fc7c9d984716c31d3bd2151901b0ab9c553eb9b179d8e8239b6e588c20b3ca1741fbd3c7650d20e0981eab7abf3fea0b4cca54983ed43e828415fa564396f2536530ea2e58fe758bfcb8b35ac28c610ea47dc62f03788f9f54ba51175fb20bc60c4d3c5902540c8e1581847b0d2bd300bfed5d29700088fd84262123a12bbba91dd7f8e140a99ff0c0b725b2bfa7e230da6e73a606d5a50ece388d5ee1de58c9ca95f128800e64572dc9de5e2ab2dcd9dde5932ae7b11bf66c611f724114a9ccca45c63837f753af699fc78eaefbf4435b960d107b656ab2c000b626bf8e7dde13565acbb2d50b646084f5b878ecec170c4e9de1045507d7349fc2c71c772f4d1b0741307b7c66cf5ecff3398edf6b56d11272a045e7e526fc1839d6485c0ccfb27b132eb4caa0595eb83a4a06bcb5f71d8059191e3c27d0852ce1138cbc62fc54a43db3104ea3d7d92e0eaf3742824a6279621d7d73cdfb06108363bb8c07e957c4b3eee090999e24aeff02fc1af499d4bfbd502ad61b970348cbb85af149d05ca6d242699281aaa8928ecc14f246791a1ee10eb8d5c00f206781c4f6ebcce418df1cb4930de1ff0e8cfafc57f3fd0cf91f7de5e6e35d688b79ace4a72289427b4db326479f57db78f21cdd2c144de2b082342625f057951f1f2c7b4928003e6cf487bdc089d9e629adcaaee6cf993131495f636f4cbed8223ff70119602a1c6c49e4006a039a8076511d7116cf1262f519cad1aa2440ccc9d6fdb36d6795478094d8655f0e15275582fda044298a908ae3eee9b1115cef35bb81014c12d262b0138c1938c691eff8e4ccad9be0f1d4bff772a440fd846007b0672a85363f616480f0d42ac68d793a2c9eeff24cd5cd69ee7233637d4d4c16c67f686fc0fa2b904d118fc5ef35e845354b439d61c01a83d85f3f21054edfc080abfdc86f0127e5e6690a5394330a9f63b8fe8abb58c3c99a636dea80a07831183004dbcdf9fc6a77ee6ab8c15eddfa1e79aba84492089b0975926ab28006b228f8520538ef69fcd30118375dd124bb55a405bb63543058628b465954fd6f8588d6fda5883c3a9f2d33d0ecc8681d60f920b9bb1ec392530c2183f99cb4ea2e1bd98c0392acd018c0fb84c4370cdd6dad8e798a9911c85171ddbd271021f297383d4ba45b2f6e6419355663cc1649b37b4fb0f662e0827810f7fd57149b021251a42268adab3c11f15e7c77125ffa55352799577dacb4ca48782b5c9ee91ff3e6808754e32da7677d8e5d2396677dfdb18a3b9da689b214ae52d27eaaee5819c2eef9b7728966213e65a0cdc25b35ed11678cf5c45dcfe76f53d4b2e7b97af805be0900b95f330274f0537991f4028860b77e5934a91bfbdd1fced258a6bcf5b43bfd6bd9580754805a2b01feeccd90c04c97eb87155ddd8bba500366623ebeb8def2d467824008ef8e021cb5b7a61a9742d659347fad8ceaaa23e95bb49920384f82271753a2ad293d066075157fc341706afb4f7bf5a6ab8def62f64223763f2e3bada0af8466b675ace67ca98a85e4205741c63ba0bc5323c0346ca36a87af9139a1bf687b4517c2c96ea4899f9a9c30ec7bb2a6d7b009f491a4cb1f2e3e4cdf1efeef78483e76cd9c31a7e91568825baaca1a1f572de2f45600f841286f5bd640d0639c55f0802ac83961b96710e7b149b61c2c2ba678dbd9fc057d916c91b6c3f9536508dfdf96975f60efb3d5d6224f425dbda9b933aa902efc57b3666f6a5d387c2cc92825670fa305909d17d6202fc655b496a229dc233cfd4c4598e6c930daebca8ea719d2cf19e4f87fc8435d609abbdcd54f82a4610bd710d941adde31ea7716f8bf9f20da5f20a9e028e62b911ae50a0368e503285d9da784833c572448bc9a0f10dd9f30e06812329ce41268f7eb10f5607a2af4fc0947cd2c5f249f16dfe3e5d56d00576763957af6ee670ba3faeece0cc3ede42ef591087d7cdcba4812ac85d44be77e39f73de394ad18244c79804658b7baf461d4b45e676cd5a8b116a9d99e0b658baec7a5ef2e9de3e763b5813a09c3bb6642a08806cfc72eae192231f2149115b49dfc5be4a0f50afc96e3f1c35d52bfa4d9b9ab31424f6a1e890da416d162ad732363052e2de03629ed1bc122016f114bd99bf5c94c65c8e0f7711b7b7e07cc551d088ae49a416e4a1847293320760dc371c5764342271aacf8e56b10e139d0d97f2d9a4d726b68bdcb4db6fbea47f8204e9ad243615f568beb7abd3a6110d16c146f0d06b2a886d23b04b648f3cd8846eba5dffbc0824e752c8748ca8e2f2ba6f6eb2924a8cff06898fa135e05f31fb28be7efe656420fe8aada8be7b519ac23c615a0327eecb9678ab98d91e2f208440801e93d051338019212a1acc0bd939f5faf7400a30ec78f675611839fa863979919919205d867af830c7a9a73a898b9c7fa017ef23a4a32f5faefca7023a7f84982b9f080614b2a094c6f6b42a49a005744b5eff07afd8485e8b2d42a4abb4461a650207d45153b457140fbee47e93d5d5d4843a177ce587df13f29f66f8e002c513c101c4aca623e5425a29356ab483227b42dd220fd4ad2bc9a35abb8dd29d085f573e583c39c1dca545a3b9b199d9f8a733fba3848bac77737273a88513f5d98bb73545b14c32cd729abb49b82f9a9ea939d376d7d64e5e5993986d0de97fa30af2b3173302374358bea034030bcadbfd23f17ecda2b8d2261d7bb3530bb4b8719a22e06e917438e4d4890c84fdc34e8b640d971fcd5d15355195f015923f2b7801eff9126280cf256cbac38026bef771e5df454e725bb378ea42594b92e0a184eb826fd6ebc1485aba9d15f7a1ffc2e3b2562c7f96aa5ce7be8c1a0fda088b84f06e7c1e1cc51a0bb1971d03839e5bb93f7f3371c5ec0d604d0f1267fc17ca64e712674293618bc72f90b7b5005637affee1d990f768bcecfe4c1beaab1a814a7212cf9fd0aadd46841664da2f82797cced78db8ab93d437e5d65741cf0c0bab97d0525f63bfcddd2240aa6703cca97fd2bfb7f1bec3a992e22e335f7dac48893d889f562ae2188e59de882b8541ad86724bb80d50deaf010a1f304828e1e61b659290676c9b2adc9e35d6a39caabae15ebdf006c3c1faf3f2fc806bd3360b40a34db7d82f28a602b01ad3102d907de5209b667bdae90c35e40176165c3d64fcea4c2d5780ecc02df85748bbd2b6150b96b011d1b81675d2afb1ec0078352b49fefaab6069d02d01a58d18fad2c7c4511c386fd7337b3e6cbf3dacda76a9e9b1803ca862f12de083f022c7b0191a1f203db2b8db7edf3697a5dcdd04a03c4107a5476619b3eaa5102b039fe363c6ccd656641973383271a89758be7af1efaecb572514b2ce9428f2632735d1b45c42f46b637e657205b4627087b139c21bf57ebb460c97e95d13fbb6d5ad0c076ad16eadc022ab07d16ca56bb6d5e9f119ce5fa9c44a6f59acb205049de1597aa6903638b25967936a4a972b306624c5285da93976d29ff34ebd38b40ead15208aafbdbbf354d0cecc985e440806c737f6b2a6fb23ce962309e983e170b1512463b2be741bb4253d5a977bbfac2a404374847257ffd88acebe53fceccb24c9a9538eb0b3799614d65adcb1e817cfdc9d7da7755ac9abb26dffa2cb91818b234a02cfb6c46e6524c6207778fc77a05ebb351fa2816c546da1ff197f77a1c660216eae234aaf0b95b48e432d30f38f3a634fb315932dab37a4ae9808953b9e23c5fe7fc5b139d2ad505ee842ed8751f62515ec3469b51253a88ddc849e0664d131f7e98f242279baf178f61aa6aa90dfca93ec99d5715824f78381b5669a79aec1e8def740b78e12b6cd2c45bd14375adeaa3e77d84cf625e22a22eef1534560fca68d99fddad3d6dd80dde9e83b1cd8c3b011f1fc6d7fdd4f925e4de7b8245991f12a6e7cd3d02837621add2a3c39f223c7b2b4796be2f5a09baca0af6bdf84818610ff63d08c67f3fdfc5cf4e24794b4c428c7cd510e63eed6f2615e494449437239e9409917607758903c08cb24dfc84466b203443539f14fae14f49929e3a86ec2307e46b3c638adc93a8bcef8609dc2ede5539afda230cdefe8bc88401780298ae3c179e6a9c9e83f4ffad7e08b137a4e1b7e167ccc8048e26abb9fd81ebdf777de0efdc4d311bd29dc162a2f6f7a28ae5b664a7b730658524450d08b21126997f6af6c2bc2992c5790b155f28017142bba6bdaf71c688aaa9935c3eca7c784915d9d670f3a13cec6ea49613eaf85aba3f740a5ac51909537be267d993a33fec86e8febd47451409ca8a6c33da7b2d0057e4d673d8c8ed4ec72b671f0fa280e72068d87d5160bf61bb00d7e22fe10cac2335201559937e53bd21c25084a11943b33e6a5215d99f6d23f950cc47b9abe73050867915fe3a264a88d2f405b26f271d7beff8b21004c24030827149e7185aae40cead3db7d9b38b98b8addfa948675faf147cddbfdd17f98ecb6a56bf18adfad9c39c1c54275f91eab5bfa2d9293392e068d908b1e58d82abc6506e67cc6dd1a34e5e9d62e75119fc21a2693be60301570d400cafb39b2b3e6e4500222a66b56dc24292b874277569c4197c16b10241f53fb8292f99f3fd8a7978e57ab8bb8424d473b5cf558d6ca6044b89b970a760a65550f42b312ce2e87fb1557e4cf77fc4fe857946e4e9328c056d0c4672a5e1bbf42869bedba8d26483157f46d7474242708847d259292984ade717a1c081ae8e83cfefb7d4fa9289e8b0e1ee25338b520ee682a71620dd2a6050a2d05d5019c07ae0770710e723cd7f5af15f57e4d6d09b020322c30e75a87eab9d24ba3b98649208b043a7345963b66e42f3d3aa852296adaebf1e45efe14a660168d7a367c7504b7d657816a79eb1df326bb9fafdd3292c58f41453f47d45be91187bd8b5acf6c62a9c7eb4cc7f8ea6069de43fd2a3a6b0f038db8050b1ddcfcca0b521023e5ce6deb9389c2aaff92db7cd93925f3e47a229234546dcf538cc53bab60d073aab64e61806a2f1c4553fe569e07435104293bbe6dea7aac8d38c60a1c96d69aab1aaa573a49c3cf034278aec185f6ad0d52cef504b0838306031499597d8f1e9f22d1776ce3f4dae733d7bbe7b1b92790d982f826cdce7fa8398761aa6758ae8e601f9006ea9983b9af0aeeae49d65230d2e5806e13cd8c1824484637419284c3b11d3cb9b71fa34bdf61a1f83e88b5c71ce0186d6034f3bfead5253816c6d633d53663844df8540cd1aa72255f50a84c836fa7bcc9396bb70119451a862f9feb4dfb7be31db9b2ab173f59471cadc86a9866fa0400a3716996630aebed56227cee2069ebf11032f49502b0a180daeb839733e882f4ef18f2efe77bed50c3411b81b2c661cca04623c845ce8d6a5efd7c0e68cc2d99479f60a3236c5846375b7077d4c526681204894b80885a81a515c61d38c37e71c7db62eab6158e3cec3cce54e38f8c097102553f16a3c5cca01ccf8f40a250e5c9d9d727fe7a712abb353ea871998b0fabe4751c75ca60a71dae4f4654d268f55cefe0cd37316753ddc38ddd49cb93b7a7968a76300c828a2b35415d669fd4dc43f1c320a2c4406f718548684e944669d79521d97f0d5908122fe39c15373b6815e36a155c8c8445cc792365c0c9fcf37452223a9f1553c0d9c499210286a8ecddbc918db2321584655f5c2f436408796cf92547efae8e90b789ce166531326f70131d8b9100ee03a7adc9d5c5cfd2c3cea5ddf9a8bbe30d9c41f742c3cfd3ea8af812553cafbe76919aed3b7cbf327ebec6608cebdb68a938c41d4b42cfd9ec5938dbecdfad2d75f01bf3ded8e9fc808079c5f108fee4a88bb81c61c341bc8df6582dd0dded35efa602cee0f7ea2deb3d662f9023d64f4547f6c6f1ebe1409212310209ae90c32b742b7b2dc527bde1e2a7d755b3bc755c35207376579d3c2313b7c468172e2eed8886646dc563f3b02f35c7153a2096b37ed50847f9b1aa0042a252998d6f1309155d360796f9cb7d2601712a5c6cf36d1ffb9c333e9c81c675228cfb5f10ecc936d92d62866619d6acacf3f2ed132d440b1d8d2e9668107d6ee83d6e47fd5600ec9427ad8955e0bc014f3a4ab551bf0a74e92b75b1f1723637bc6ee17229b9484d758cbd4ab5d4c4023789b9c26ade5c31b6f36374530985451acc5c4a81f779a88712dedbab69c50020feab3050999ad48f550c6df69485fb1a57faa8d288c7543bcb5303b05ba7024b4c8e8fb251c58e2f6ce1bacc047522ddbda1ce43f7d11754b1ad4a348f492bd964cac235aa3e366f60688f9d6900f4ea8b6003305748fcc5ed66d0ebedec384cdd7a45f3a3e0b2a219201a1b3b0e5940bf03345522a515a78ced4a1eb0614992abc522a9d2e2a368b795f28342584d2f5794aceee40106314f198a5b7e888458632254b220234dad8a501f9aea701b33a58e53fafbb9d2682fd6d44f4375372e987a675356dbc418678966a2879e04175c0df768a6f4d2350a8f27022dfa51cf823c45853c6b97ba9497f9ad4334730a73ef690576cd5bf1278a27fd45aa285ff28b749979f1a5690117fa06f10098ec21c7970d25ccd6b8174f2b9d5f4492e9b391f756e0d4822050c9bfd46178b8bc66bbe625e1d053b6571547561c6437b3551e319b012a016b0b9802673812ec1884a5774a1b283af4f136681a9f747878e875a2276f3ea260719515fecb6242f054b7053e9d7be4b05e42a4a0efafe88ce0e9392cd3cef73e8ee2ee8948cddb8d4e78e05dc470c3146ae2dd2f91dd16e7f793df56126c04253e325ad03ca7dbc8318b032bdb473ac97f81ed3e7fe7eedf2f0f70b6ed140ac25c76ca7ca77dc0f94419d67d77c4b8a3cbca3516ef1323fe9ce496c8e283aabee2e8f3393d4341304d86b6744bf4c7c7c6b039fd8df4b25bdfe1e1443c81f8ccdd7f36d65911e1b8db60cce530afb0859b763a5308ef4236d899a137e18db489e795773d54231b6cbc0ed6f52f2c2d6b177f4d85d01a144b02beefaa0af89220a407f004266b237546cc090ea9cf08e0d5ae69863ae3966dd67f27c49f504b2bc9cee7f6b5b07f49673b6ab429ff1368b1473a562e95278b115baf0a0a3edf54b882202f9da4ab9a66d7410289d175cf1a8237300afc040a094d2b693dc4beca36fdc9bf5241c2b79905d92226b46263f8ceda4c4e70e47c9ccb0ac7d832863a51ea58ca0eb0703ae2cdbab32508f8383dbf7951f4f07a76735590f92f2b175ad32ffafb8e3cfa1211afa3239a0be6418dc96d132fcca1e28f906f2c47757a530c01dbee12595f05401762f6ee4e74d1a1661cd1fd42e7396b88bb1300767eba8c55d9e90151398c23cc99fb9a0e7927804fd91af1c9bc051b2097a399d307cbeabbd85ae049b25290955da28fefb24529b87b23f955f1f9644331ba1dfce3b47096633741e18541658594c6173d2d14f1d5fe12c37bfe241cd30b743afdb83010247cdcf01e517bb84b5fde1bb839f668d5a8903a6efd97f9c65a734e42830da719ff3a11b408d553cba4b57b47a41cb17063aec142f65fc27c728c4ebfb4423f242c72098481f4984fafa40bfd2f8bb648e2956480e7c967d04f6c0da06d556700bf69f977c220775031b2b8b7f24e0481dc096dd065fa3b7ca015e0ed7d873e96a1c526286c52791fe10c69a1c4200a3b7169c0d0d21f437cb90cb4f53ca35732ea0aece96398ede67f149ec7f7f48244cf837d0d1998d0ebff9164cb2c1f8aefa4faef2eb5476b52b06ca1636167ad8c3a715fa3650f9bbbac3a89735195346bbc579acc12ee69b5b3112c2bbaadff7428dccbc0c308ca49d02910a626dcae6bf3c0a3c00aa5039bd16b7d7777e528e856a692933903e8f51b890471bf78da840338bb9602fdaceabfc762f016b7dfabf7038068bf96f3731d43d8d00cff14448da26109c820c4355c0cb884ca54e6fed0ebdc7e6d5912a791b91f42260edb3bc25f6bbd6abad53b93be8a86cbeb2002dd62316eb7c5114437375e5b4ef697ca3e24d9fa0574a9a27669e5acd4937320c7fdb1ebe996446736a106d3dfb4f20e6b035d3b81f7f092e3e902a119989e01eef1c9c3efb069dac648aa1445511f5050fb5adc36e67ccdf4fc755a320741751c4f0030d67bfc46c0c3082185d877b18e470ece79eb55c8db3da233ac3fd24dc0d9acedb8693fa0ec295ed1cf11b6df5ee7344ad08800fde48a2a740a37aaa4a57f9cf9160ed3330d09122500a3c2cb0c5a44b896a548aeb361665f82f8de6e778ad5ac2da095fb9a27288967608bff4de94f5fd7a924440135bd01ef2e57364d82d7963eb4b9a73332108611c37e2fbbab72b51b8894166686c085e807498ae184fa08913270093292142001e4b65284ec9588482ffcb6fce52cdf00ad8f7126f6d3bb5cf2e68b44d95d8e231f639ecd8a53b0bb4b2b4bb17e0900903a48d7920927ec453165b3b6d31ce236be5e5f11c173ae1b4530d048d0d1d333fe5189fe18b970f04e42aab384d7b80881c27d7b2bd3ef1b9a37a074c36c66f9c8dcd027d006e9a62cd9e259e694f7eba38caec05f996995d09c818db7693f7994dac4a5f1471628c7320fde3ff4e9fc0235e91a8227fcf11768a92240f8baba28d7a1b128562de9991a5527e63237347175c2b37bd150736471a579e9279680aa3b1080e375444cfcafc7621554c2d3eaeae48b2f06c8a6ce88ec243979d95f6396ee5908d729750a7ae4db926a2ce9244133dfe89175bf8698294c606e272c63a776b8cf8523fe2e1aa13c3724d3f87b8cbe99332f722ab7d7c7c7c71425121b79db3e27484ebe26a97b48cbc4c29e2007b92bed8361c87c7bd901a210a5ae187ddff5df2eb3aa116e0c38af31dad4b198ec5c7b89fa296f521c4a8e17008b7dd92231a829e4009dfc66c8c09f9e8a3d36c1de7f8988d1cb6dc07d4a25961d7ab653759f3db3196dfe9e7299028b7b0266923268d0e1d020ea8fec31e9d5206185a77cff9fb7b5bae96316f82f361874995103cd1141a67bf53aaffd12b741733fee03b43abe1d95b145cf73a6d1f99de9f791ca44f1562ba1754bb4ff0c78ae8d22d40e8e478a2a0860c23eb598139852aefb59b7fd1c67ca0553577ff97e75d8377f6a498f1bf483fe5f7cd07880272520031aa51a89d3140365d0675ba0d8999e40e89b9a505c14f26e77d0d0f741245a3e47c12a05748fe8b9c5297ddff070197a832563af5f7125d682e90ee65184de7b71c7a32f4736741928c1eb3f1b3ab00da61b02bd633ceee46c4dabaeb1f8848f844196206843a782795bd3d8f35b7e7ea458ce712ecdb33d73baa1fef922c046cfd957761e98bbf82081444dff59f081fbcc00083b60699902cb9a840a9e436d3dcc1e6fd3d148e42b598e033e4135c863306f91c5d8114a47390c1bb45e57f5652fba7a06bb96c63132d9784667b1e73dd47f1085784cca1d1cd9b0943c0b9ccf5c10dbeea0a7c10fb6dddc56804f6c44640b3d43ce1e595268441ba6dc00c911aedf50d8110435ffe58fc9726c3466a1b0a5d28d633d11fed91a09e99ad078bdf705e7b402f47e3369cc516059e4ea85fde7201fce34de0a76c7db718d15926131439d5c0df5d797bf9ea0f652597880c10dc4ccad801a4e6207074df60d29f0e82d91853d519aa514b12e06f8f7734cab485b9ac64675efd1468e1d6baba600d1e96aed8a7d1d8472331df431d231ee1f312a9aa03ecb23f55b3d36009c7add65974e502215d064403b6445c07df77232bd7774d8d3b987f5b72d511f559cd26397ae555b987b7a7c1d25117e9e1b1046b5668e6413141054e6a6b42a48c6f455818b2091bbc894a6f0eed8a768d2f25ffe5ec3b696f6dc0f6e62a9036c812e3454ca8cba9ae05fbc1777ddff2a364e1067d60a768db8dfb65db8e7d75ad287e5e45cd42b995c36ec06d9df165e43954b03d7a05c9e2a68bcb467e06b4cbe4798a82afd44400b0cdaa578b80707300789af33cb0b7e66e9baf756afdb00074fd492446b07a58d99b8cb82e5297e8ff58886821c3b6e924b178078ba42169eb7c9a8517e78c9845a7391010c728c6efafaed40f26bc27e00f08cfec5f6d5a2828586b5885fd247577cddc138a24de49b350a1e8681c34ba09e17370b19042bbbcece11f7537a02d0e2bfcc6b0374949f0aa045574caa09bdb8f6f647b91b385b4f90f9cd3e6ac952149d5245bc4bfc4ff41b13f4f2f7da000f6a4a35c1d07ba8701bb910ef469070081509f6fc5c57b5e6406ac8b6791f55bbf388119b8dd3f92fd2ad646d93ea6ffee4257e68b4d64677becd39074ca3ad78f83caffca385790c553aa70a5dbdde7cbb0393fd0d96e690e9e8900449199f836769acf5728a4e9b334782edb897fb0e07e7bb3b29cdcb6ca91ab444447c90f15fefbbede8ad2e54895c6db94104b23daa2d387e9817bf78fd9b15f756084f4e0d6f358fb04d3113c87f73f18e7284fedfba3bbd3849252c8c521b26d121326c52c207cbedf2611f6e47687aa4f1807c8cf9ed899118abfe648d43812beeb384213df1eac8e4939c18219755d38748dd9f1eba77546e86cb91679a8758991fb5af44eac5ec29dde4db47d52d00bb6c47c834b9075036352c180006a552d076a39621f145aff3c2b34118af65f7e81bb73abc6d2260134c2a6c047bb547c57cf43a982e2c1be3628282aa4f0a795e6e4c9ef3ed3673f4ce9d0336f4b5f0f6184d823a3aa6489b5903077d30abd22be5f5e878c72487e06c5d7b53da743d3fcb6ce532c93749b0af70efd1b75dd766e89270a911a94fc74bfe288b28ebb42bc257408f8dbc0675db52f30eea87b99ceebf4e4ecddaa0d166641bf74b92c054a66fa4c28a7b4491338ddb196a7d914d7703bee84f7b3964a547eb1b190943ba0e7249dadf656fa5f2b2d76ca97bef557db0098d47cc74f9ce39462b5c3d3f480e053ac4a2da884a0bfd99c38b00c193bccd9033e642a762ff5e6208b0931e6f6819cdd450ae677d4ceb30f1842a0d93f6f874978e285857cc77e7367da756c04d7e34800e576b603905ebd33907a5d5d6f51dcc79277f77447420493df06f5094ffc1759aabaa4b2d269ba761b03606decd17a62ba60d5ec18af41a6d5b9a0564568bd257905eb50a8738736259e875c19de7e0310e6541b58e9416b7c5ffa7d6d4e7666e7c56b11d61332d6d1713605540886e4924dd6cd797d7f80aeb84f2756555117904699ec869dbf0eeec3e9853b53ed48ab00b678189e8a4d5b8e440e2de44c37c144c097e917297298835a2a29c73b8cf81d0011f3a7452cf56c6d40b8dfa12fb9298ce306dc680df500c0575e5bf71b7295f256544c00f11661a97214967b6465cbd4dc5ab53f23dde60455ec2e998d111706663aca3846d4c0a93f84d8cb5acb8bb24f5843eeda57fa7699a9264d975cc28d1a1b3c32da35d14640b7e76989156a7b0fe1cdefebca61a41aa334d9506f7b64294e3d8b80d609eedfcd4be7d9d36976b50358434e802c1ef14d05c617a3dc0992c977f3fb571303ed883398b31e3a7d0191ef130c57910c6eddb35be700681dbf6879d7a003152a056894984223dac64f5b12a1cd543f8f1413098aa8bef210f951b250f8fb471d1e30fbea99b1bd66ff09ca6bdaa020bc86e44b3edeaea1c0241b4e1999473d46ea7a7edf0164ad02c8bff6f571cf1fab30aa2c47785c9111bca99edf3a5ece97e0696e14fa50e1bd1bc8c9c8b2a946e3bca07c101e1bbeac234593ef55389fc0d7f1bf123878612d736c5d1850e8ba0f9e6db7ca5b0bfdd4f401d2755fafc728b5b10971d5d692fbbf15d5e720514d66f265689fb072d922e6c46835e4243d3ee4fa48c04b10b50f1adfa03c78b7b378180e46e7546fa5fa2e129f10e43ca43137bde4f150ddecc9f70051edb1f9a82b4a2826c483bbde62362be4f3d640538b075c2cab83a196056564db0cdd98e9ecd7e18a4a1bf20364b66a10c40eb2752387f6350fa8f5ad7554c55535d2fdd039915e0d29cfde9480679ebfaea7b71639ae6e9ff74ed334bd424ac2102936fb31f88c5d51ce3af9f2166d05ec6909d2a80ba65b2e788dac7b2597d2360e4a7e870455e6f9a850563b24ec82bdf177ee003530cd0627f7ef863d026439fd7e9ede64cb3fab9265046105ccc57bd7deb97a63abfd9567cfbc031c39cad64614bfc4a35e72b76f3610942e11a563b71f5ae4d403a95fca107d9d08fa86148e22807e4862f0e50a424de57072f27c27583d09a62b604a5e6906673da97032bf883b73ca33feac16fe3b77cb5e582263f3e23ec51133d44f88a66765567d13a31c0fd0775fa7ce883f31c9bfaed5234fe2a6cc16a70c1e744878b9554a6696f36fc2185c9c2c16688c1df22cc68be3514af35f23120cab14169898682780813767ddfce892f11a7bbdab42108336a1a08258d70f9042345838fc53ba86c618df5510fc6af3bac41b319542932f0b4ed25ae4eb956a502ce010ba5d332baef348119f3eca367493f040ae5c6663e6e16c7e2322a2f36da5c94101b3c5ef9cfe2c1fa9ea7e820367a6e71d3a5e274d1a3302a9903ae2ea73c67bdc9df1165c694bc89a2a48cc4a11718e2fae14ad0698c3e9a2252f9ce1a4a377f26266198a5aac3a20e194ecf994aef89ffe618787d66481392a801da79f1ef274a92bef2ec2c511137037a78a412965cfee73450a6e04a6ffc4e02a80fb9f235d1dd1bea6d0558d57422c5807da7ab3cc3a5c481cce1a9cf17eeb16b64d2a419f2aba2226ea95c596fc766dc7a79449c1967387154f39a019f0fca2aff7fa9a32033405ceefd260ac597551d9d64307a0e1f4e636f16999033827a164d506564c01cccbf756ed2a65ec3e8cd82edd1a3ab35764dd06c9b976fd1be632b85cc7a30ca7f86f7b1fc2139de29c6a212ded729a9c9e9d84810aee108ed34e269c9aa2e4fb35fed218027edf67d7b0736216ac7b1a3fcd7baaaa0d1fbc7395bb9632ad61609db2a5955da10d70ce735a709c094cb886dc87f8449c87e8023679ba45d1c01996541d15ccc80cb5c550037355115885b08c359cdc587a141135c8b03e5841c1dc5f9c5f883ae55c02f2ca189a0ebc03c6420780c68eade85061ab4f417a4ca3477acf22c41d34ea3935ed6e71b6fc0856a3cb28465cadebb6a26757db7a5eac51bdb7f3a4f1a53acaa66ff0b592f1395e3444e54bb231ab4b7d5428c717e48f8a07ec8870853390c23245de2313d195ea65795017573f942c198466d4620b17f5ff95e91c226d0b9740adc8d6c6bb277c26f65cb4072de1fd11797b7bdc6a816cfd2b0e5f77a1665531d24e01f16bd2aeefb22701bc090114e8f49a8153c44e43c36c910fc23ed5898603b571d8f60bcab9650f1cd1ca8ba43e4eb05d6c784d958c4c1fec2dd612cd6989bd2fdf943ae8cae09f48558773cd9297b9add0bd333cf42703324d480c664fff3048dcd6ef6909bacf4d1a6f40e72929a8ffe3dd3721b2cb2cf3a1fc62f573d1827db4a43ac2ddf83a40c6fb2ef6b9b9b3e1d64105bcc11cf9acbb0616e200d7b1327c36dbd510eda41939bb5778020f146f2062ad2a6dc25ddb8600ec71b27d8af82ed6181b6d1f19e62545c3a87a44ef097652de84365e90e2b810ec8c7db46dcf331192174501c127369fd8be50b111ee5a9401909b8042496974515e791e53d0c2fdb965f6fba22a99f8c7ef1d72a57707e917da5e54dc137630a13bcdb02b57633af332d0af32782e7fc7dfdd1165f390d695dc5ce7b5cbbd7b4180ec7f4d983c9a312d4b2a485063b46f9f2b4c28439f99dcb9a1d2881ac6647cd9bbc5e0a2f20e7c162864521708eba2423a0fc90e0df0f6d1ae33fce8c0a7a1c75fc4c19851e76638da2decddad01adedb70d4ecfbdbdcc15a793f0628aaaa7d607206a1d8715ff6ad34ac470a70401fb6fee5e85fe28568dcb9dd0fc81422faac7ec06ddd7fe37f379f7bf0832a5853424641fb0b6673a3baca9c8d5481344be7d51892aae6b88a254ca6fc352286da7289cfc9e69aaa9174e2dbf6131dd0fbda6afe3e1c32060beb2d4abcc762b75d1eca2d47fec16eab4b5d9c01a0259ae7720939bc0cc513ef19bea85c91c705bf2ecea0a94fb8de6ae8ce8cb9c67811dc9352fc9d995fbb44e15e51e9496770c991e40e61d943ce2f5b39e36af7a841d4ef7e6fcd80118878ea1e07f448e6eed682f944851045246c2a050b4eb1d5dbe8ffffbbf1cc79a2734b6c550799de52967bc50c3e241290d1d23d74d1abcb4fac4bcd74493b5d9577b0051c6bbdc45d79acdd99cb013a17d0bfb77b6620f39570857d323e958788316f516160987b99e737dde43e77dddc3911960a5ae212ed4daeb833e605b0eede1a7deba70f4f04712b971a1a9f89216b7608cb087fed5132e7a167e2bdea673c9974dc6026ae1041dfef1c144e8e7abf41af263c51d4ffa225c0f0dfec0dcfb6691d9fc0715f38795a6bb57e11ce13da9bfacb0d0453bb1804a5d579cc6b154f0ec72fa28dc417e4d57aba8a9dfbd37776a725c2bd79fbaafb83ca0e9039840168c49a5610834126b6fcb2958d65f5f939b5f24235fdc76223586bc928a13ca73b18cff228968ef88a07ad494629446136730e6eb84c6774dff17b055a4a44a51f6d327eea92e74c5e1a03df6fbfd76e642e4b53a3b1970e989b54ceedaae63d3c295d119a7bace5f5db7075c7037b07e147b06f5481b2fee3eb00693711fd22591a4913063624126073f662f630989d6b4c6644204d91685dde73fa81b968e43dfa70fc8b313374a424f80d5cb6906926298cf0e74af8f533a5295f812844c8c31035931a567f6ae4892b24fd8676670f71241bbe4a5b5581599063c1710deb9b0182e1b2427e0edba34792bfaf67bdbb355c6f2f996eb7f3c512fc5ead031d63e4eba1d4d9b3c45d4685d2d8f897b55e9f48e082fd1875c61635612cc0872eefad03dc2415503b85d9b9045d10b4c03b6829b8593c85ef5d79c2cc4034ccc2f0fb9acc3a2663c0d868021880cf7161a8e508111d98763e86ec51df9c5cc1dcabfbd20ac8e70f201a037d916effe94b52cc1df9f82df1a64ba6fd48f402077a46f764990086fa6c1a1e0cc059b42a2072825afeb47ac0aee29413ddb1e7cf2de1891d69fef61322afe0e40bd888442a6efae4817c3f9a1299793964cf5a707d6ed4ff5181d9edd7a9ba374090786ef8a18070656b89f523c5121838792b86db49873c08b6db8c3c8c43f067a050497de511c1af34265fe534acc9d200232d46fd63585e5f8fb46c62b239a38881ec4ec5a64f9b56e7d24aadf313a6ce892ab0183458d791e569fab4387aa368784a8e67d1610d9bdd353b68555c9a22ab751a4b16acea94dc243ed25a586ea50b02c72f0d9e7d511bed58be5a9ccbb5c801307d67825fa8f206e520aab601ac16e6aa3bf08e87425b95b3c1c0daa512f48c936d66061fa6df8f4610fdd8ccbd4252abd331ee924bd9d73a2358988629993d6589575cfc988686618a63cd3a2bb90a49c82c91737e5506919a3dc027294fc749497044080cb7d9f419f3455e4de13ae68d16c687ddb712a4b1db1cf87fb73d13742514239f0850843060717ff8d085688e20ef6279e1162c65139aeda47835a4f61091e20f49e833ac5fcdf762950930b03aabfea94ef8024f632eb531b5193","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
