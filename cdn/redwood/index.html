<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f82582adbeb652d5b7ef5cadd0fdb87904cc16259cac158c03fdb4d73a3f9f1fe1717595036b2efce83d33f1bafca570e1d6cc5836df1d40c1ec0ac186bc74e80f751ee75aa4f68469bbba56cb6a156f02810d0e099c9553db51e60f752b50f0408f7de7de392447f17daf98b35dbb40cc665129f9f9c6abd40b06b8c7ab15b85cd014a0b0afdcdfaac1d49d4741d50ed3f74a3fb70b806ffc2ae4cff224b47da52de97662058fe46e4cb6a529783dccd694bd8fe1d7f854ad59a7efeb46d13bab16c969b49b9db7082c3f98400db72c5176a56424f1b860c5be1b1617ca302676e86ebfc9fc7a963afb51324dcc36f1e1199a89e08fccecee850e795b78cf7741314335e2426810369dc3801dbe18c8c4818f0f333e9576a159c61f31f9dfeb33c55c850af6c44e8fff9c1c8b63983c174068f44c8a7cfea7c7366bb484c6022d11b0f778b42165489992ba881b5928aaeb0fe07c09a1d8f27efa81689f9508404f231ba718575051f783b221700aea38138d04fbb581a8b7963058665df71c30dde9b3d9efcad50c5938c46f34618ca70e2ee12329998da16daabff0bc6c099935c56fff72fa2d999c242a83709d4c0a4a0bf8dc83f74b7cf4005c06c8f16f27f3ee3809d837b4d8f683b2e08ac983d5a2fbf7f70f2da19cbdccc5c6eaa181d6555eca78e2e0e1afc763dc7a9eec5888cb066c2c7368c8391a6c0bb8ecb63fdb9125d657ed8b116934c72329ba61be71a43768dd75caf1b65f4f8211690b8362d7b7d0584aa9a17a8f4eda9fda07c7e8ad8f1fa5b673dbbe93e7908d01fcd1e6e7995ba06dd91baf8c28b45bc73b3e3e317c62fdd8d53f7b323cc10657bcb618c942f2247e6de692047721703eb3e33d10c27402f37971eca4b67d084955a52ed4ce4fe955c4ed58707999a482e01a5feae15e996c8797778220322877daae6d76839f1cfed3827d16e7712a47467d16da8a8f9d821335836cf1d355a0a1fe5666b256100f601defa8b6b795644ff0005c784d37d20a4710c93066ae51fe7bb3297cb4cc8ed99db1e8df5f40c988794a53b6fee5b5e71af339063d2d6a4083693b42944c8a2fce5e1a8ac8428ada17ae6db646b6c8ce5fbf844072cca011175917aeb284455bf5c9274808d0d2db4c84359e585bccb28b8568e9866e7af6b0db339988417278a150efc41a023f0e654b16edf8d79ffd8aadc074b2d34ccddaec40eedcc577e471066dfab0a62e87b9ddeec63b7de7d37208b9de9c4106e4685aaf812327c128678601a6c31ac15db0ce282fd3d79bfa1379b269f3c98406d0a8aecf96906e0e44f230ab4062e111ef9fcadce23db4ce5129e9c6baf1bd43184da9905fe7e7a48580f53f31a1885f94e7e0d69f478697d6010f0271acacb023b36e13e8a15dfd6e033674d738eb5cda9c8157c0532b4a85ea5de7aedc79ac9b8c2786db6225c31c287224ea549fef42997eec878f8bb2da511fdead83f72d69a6f4ac9d44978a3833d9c227682942835cb9e829d8355b7db0a35ef3b4ae7a6f7f46217120ca5cccbd9876e0df1d96e3ca5f7796a56cd57ef565522d5c0a3c6c3a24cf7be8366c222c0cb32620bf4ba0a3ff9753e5ab0f543c038f4027fe395aab06360494460e04d3767ceb374ea94eb59507a26c0345b9d82aacd660b9e5177c27607c8c664fa453b4f5e3f584aa608ce03ee8f5321d38b421778ae23e6f2cff2207589390f570910d423a9700791a811728cf8b25102467399609995315ecf85028b47c6b418819f95c16073f643b26ef65059901c9b0584a4221c7c8b04eea346b4eb7c16d54d2cbe2f9b9fcca461cbc0dc207fa79498c3bea2131d1c539c88441014c864cc33675d1621acf89dc43d25333b57d60fa2d20ef4fb39dc6b8a12fe8ecf7b00fe3a6c790157c323d4df740161966fad5c45585ae5a76a6cda085d01d81f6403b5945faa192ea6febb17b02c447b91bbb6cc8ca28c590f62116343824819fafa67034c7b1f11192a4489c7e98db1e36bc0460e32c968bc1029bef62fc9e32a5729f635fa8811d26d28bb63ab768e6fe034ed82998be8355159f49169926e9140cfec96d93044aa115dacfc46f963125b5c226842cd93cac8d9d61493a0412abd18c321b5059676db7415b20daf73ef49cc9fea176520424fe07a404241176068ce6ba196a7d9c3f6f58a1cde62be59251d1df24f2ff4f4f729c7e6becbce4752a3c23a675e1711ace5b7be65a88c42effb94f2410a2df659c03c0791894121a5f538a192b6c57f056afb5c023419fff27e0d77abe31fb796d7e0bde0f410fb27dc863bb04418b9531a9ff7914c4657821460d7c599c8022cfca981694ae451fc6a6eb6ae7b2b26caf795308c9e94894c03d70e776252e3174f40fd133e129be3aedc2fba0d610dcfb5e166b96cb16e30e751d5d828edff478feed8e2fe720ddf2061b8edceb457efe2c6ace269e915ded12f88ef9e635007da7a073ce15373527a2c27f26efa1cf7ee3d5aa937f034100c5917fe35eb0c168502c562e1bb2694d0478586fb1ba36a1f4e715946104c28538e8dac40cabedc592f86a7c36e7a8de88a668981e18638f527b53143e527e05ed438a842153046d9ee301c21bd508ab7d3327aa05c735ddeb24f1462bf40bdc7673f922b1497326f34d93a4a6dcda7cf6cd089f614d0955f3bb4bed5707cc3943e2f2ef4bc4967b2a6ed2af4334b1b654a7ee3bf723ad876be8c4f90a533057dd729d56b1b18d4e2634636ab9c36a8331a04a6462779595f9a625afd9972df1c61dbac9ffab256f4f3d7153fe403c1aa9256bde3a04d36ae4bc23dfd4d1b721e3e9c15ac3a08ce74547c450b9c8841894b1c3678a62e3db8f4106075132fca5580cc9fb0deafcd0815e267ce747761c787174a9815796f2d18d4f8e31fb030ebd81169411ceeeee30193da8dd25696f28ca893071e13d85a77f6d9198a4428ef69c7d1114c4aa89e7132874036668f4076bdb233bfcc75b7ed2b7676970f4d7257f8a7979450a6dbc695ef1b561e991ae1faeb38bee230d9d527b5ab8ff3a171fa1b8e80d51321ee2f456913c7a8bb6c2d03e53082270a3716b9131faac90702875615db9da418c41015249a031a9ac2912d3ffa67f91f501d4eb0b37df47c73864f142c7cfc929c715c017030fc9dd7a076bf3575ed668686a065934fd5e4297dd6b6cdb653ea3b795219c25867fa505e8a8e115cc606727f7938841605b1b95cec01c6e4eea2a4a9516df003bd00dcb6a815c2a1cb9b1ef37b1bcd419d2ba6af0b3fc3bb4475f671f1f3e9e129ba311ad6b5d2b8715928b7ddb9f4aef5749aa9ee1a1c533451da7fdc57b4d11fea8e62acd395d0c56a531bc6db7196bfd9feda57e05abc2b68509fe8daa19e138acfe36a8e8979ddcf10adbfa8b5e75c3f3f5b736203a17dc43b56ffa99237c56c4359e16d5c359c546bf6339f6cfa69e3b1ddd54eae5bde123b219365964db54ff7ce000ff3306963adcb1d375b5fbf847dd53b6b0d5e510acc5c8728baa34c3def07dba4f0c541fba480a59b11a7ee2594b609d90669b241522bb9d7960dabbd61a93ca363b07bb8194df73c81f36d97127844f1e5cbbc021b6f3d4518f7e435a9715fc813e5cdb9218fee8f5744606d8204e8426e5f855dff0a0700b88e0095864876ac71de6d5ecfa89f83a5116b3ce390deff5ae930a269fe02726ccc85a19e3f9269cc2a6818d94dcf717e3b20f4da1bdbfc54bb70bb5cf3ef3c220baa146d5765e2098d3f5ca7d17e0db2fde2912ce95dd66f2927080948a213940b3b3b2cc3d04b98910a79b040815b9145a3a9d7d4c9776f847d687afc1325ecd4e7240249c772f7c4ef2b493f495d7c9d9e3a47314e17c9da5767aa5618b6e633db00c30d050e1c56191eab79a82a8db7037858d10eb1d9e25381af82502d39c636167e0758381b144b77371ec5ef23673acb34ccd36598d8b1d87d22721245a7b9db1f8bf435ee15c32487ef01c7d4a422922a13b787b4ff1243a72bd213eded4eda2e7b83af251351d21d185411bdc04b5d8b3d88ddab97b9c5cd014d43c0fdbbedd8ccc4c6d353cb0dc3f44e7e5b47e05be0e9ed60bcfc649bdb11bf221bed55fa292ead460dd4507b71f657933a75d9e78351322a954cd998f07d4f895199876f2b577a63ad1d44d9e712d50e4b3807132476f8ac1283b318121c1d33647ca9e89cde6127a02ebf4305e2b539ffe09cb9610f75194bafa4e96f1c366523b2c1cdf00f32fc38641367576225917af8ed1d60a44e79b2201d6ac06488e5a49da1f5d64609676fd0ab68dbb7d76583b19ed0305728564c8d7a2b6e9b6f63696b7df88d0863d4fda501b633272c6cce89dc2d48ebf01ef217e3c62ff4be8fdf644d3646f19f88f26b2d3964b645a1d3ed762992bf11e918225981104a990f3d41c6e19a3a261fe7fe19dc1675a0b09414acda1e20b50315f5a282d7bf17550f9181736e4a8cf685ad9d2bbacf872f050822ac38ad9ca226410e5e2603637e8c01bf945557f54924baedf1a625ec9ef24417ecb05171a3a380cc82f38cddbc1830fe072cace099d4c5561896e1cc1c06646722e73f5d657f38663ca15f951ce5e53f7a35060edf4ab4e04d218e0ae91816939810b2cd3045756919bccc344b280a2ae20f16bc2298de594539abb9f7a579796563cbcbc53ade38638a90b8eb75ee06481d69702ff7a1e83efa0ad2b482a63033cb4078ba5cf7e5ac8c3d4db71f40889bfbeb4b6d9aa70f736df93c646baacb9d74937a973970dcdc805a301ec4b051f2350e058897169354eefd967d8e89f30b4bc855b1da1409696990a8f2bd57c276917da67129838d1b9d8362e014e78f6ac84351122d70dfe163f16b849c21abc99eddaf7eed9cbf155cfdb106a69b478e749eab8e53d2b9e8da3109887a607ad336cfa6d37e0f1882d78ed227c30acd21fe87f0e51c9847b8ecfa6466f5721b2979df1e289016f724bcd931c1715840f86e7728472ac341abe34e0498143f7df4a42f7bade77b3683b6787145dbbeaf156a56303e9bf6833bd3877d24109aaf4c19d03f62cb364b337efdaddcbd05b5fc173795283e8f47611bde5f13606be031a23ca91437ae823f252a46907e2ccfe2e28d065d463f63c934a63e15488fedc20eadea51274d23ca5143077994685e4674d9a432ced7dfbc0dd8501a81fcd4155b99d2a2f1f8bf6b02dadd8648635777afd60fc03409f49615523ede7c3f28931f72002ca8b17b20739958025dfb9a0754d46b915138458aaf9372674f442c72a72aee232daa6829a5ed0dd42e355f2e9d9a658a8d0f31bd5c050c2ba2d0b42f5a9c9e4a5e913713076c7cbd975240c17895c40dc9c1642ffffad60de4a3f7ebb1dcc83e4725f59447c23d8af66fcd322e76dfdacc304ef55b1b9a8b7a5806a8d0613665aca7b81688ccfa334bfa1ad609b8bb9b362f845d4e372a488e40381a917171e6607bbe9bba14367a30a4f22d4732975f2b32e3012c76201ba2e7a11191e99c9fe3195bee5fe4b89b5d8a2afdb486182142c02e7798512b703b797491ad725caf0aa7ecd8032fde3e30ce8e699355fd08b765d57a9b7662697b66d58ad97239c6c3a3038811da0b7c294d820458c7a8b6781591d70024af65af05515e9019c7b254431012544197c0bacc6f64bc4fc4aadc1e47e85f9169577a913b37fd0e4ed50e1033c760a38fdf3b20686e873d40bbaa008b77cfaed0d382fe0d83cc3f0bed279154ef5ef8c65db5e9ed6dc95c1b98a00fee964ac7aefab19a7c210c1eee096ca5ccf6b908098753c0c4f1f431388e0a538d91e1a01263f6cc759fe1c86453ed47dba293891d5c070d24efb8386b27131c412663004605c84dc6ee74626e1ff37250f55b2acd22b13626d38313ed37751a83d195c26672d3922cde86206f060ba2a0d5a57cdaae21378967481f321e5fa43c815bc09cdb5975d79d64eabe5323789328420747082ffe421b7b292d3a4c899aff9fa5d766673de0dec447ea906d4b2afc5bcfc41eae0f34d301e89cc37b85e4ce359b68c5e182f23a254a8347dcf5e54791e9722124297afd452680caac0dd3a532472959a9595f88cebe57dc72cf12e384613544b96b37cf0839760b78812e02561ef0b04c09ef8cda46cc2826b70e94fbd5439177aa0f7c854a62fe86a2a09daa275aae60ec88487a67a0c8855bbf4f3f50a4039b172f72d4d40f27925305ee9f86b45932b35563cb6fbe2859c59bc51a21d75c1b0814e6de95ed75edb8dbe4c9fd4e3deb27f600029e77b93213ddf2a7d64eccf3dedec4bbcf642b6546eb48dd0b48546c244ee049fc7188039221f0c0ebb3a732f1ec152386e2fa04b29252ef23abc9cd3b88a0be6e2df29e6f37051825f5485bf547f536d5ef0584d1bbe7dca29d53cbf4ba67b2e42a1dae31ed76e5881bd2e762ed386d2fda369dfad1a800fa30ac9f812236e1686dbff51c691fc79d8959e8db8821d58c582c771dc69e8b86bc3fb3332de7a178120020c09266ba2b8930acd4f72e54f9bf20c28a1d6adc07d96033cfe15bfcdb3d5f7f867722f6e64f3724a48de80b7210ee6ce0ff40bda1442b58cde796adc1b135b9e1140a1f064a22ea1e221c827c0749142feaea80f260a80e2946755835b373ad5d32c025980d7fd7442ef0c06b45973f4d11009faf47267ec9ff292ba556c6e454d9a9f3cd30ab4849fbb6ddc6259a1e0751c40791822a8c756573692fa22b6f6b5aa1a9255087e5d6ea05fd86e9aadddc29795d3e948617b819f8801eb975f5f2e61d70e9e4e7245345f9c6d7d105b5a2a69e4ec3f248087756dbb82fc7c19b72ffaf35a5414a5c458b5786d6471780f4f6a99ff4f264e5fdf3a09b961560cc5059c8a4c6fd7237f9309a9d11d4f3cb663d61abf48b2e761d03083f930bed254ec5292c9c9a043da692ace43c76b5c41a42123c39092c82fd77b61ba9c382928e4ee2b7b0171ca7ea934cbdc27a61efee4b121f88374d5011f51d511c50720984d297dbb9d15a8fbba442c7899c3dbfc095edfdab7828f90b2202159b0cfb658633ea5ce73c896b5be245c72271e583b7d7a175a9b72e2f33c6824cf72ede6306a0e8f425e81434912089868bc73bf410b7c67a3abed995a5101bc3dbc5cb96581c132aeaf24b3298e81ac9d8dadacfbb0583f2fa8af76d91174784d1cac7c0b647fbbfe70de5642ee7dbb242ef8b60ddeec85d0da4c79129c03cbdb34182ca0b1fa36ab9a7514e3f7d00cfd0b32c6c384e2f5df602e6f53676cd7a858cef9eefa9b8de3d796b7b861c12bedb402e273fffdfcb2b509584d4b7dfb338412b4307dbaad31f56fcab84702e8c31709e2a11305a796c769a4318f2fbd225cf4023e0fb5c9d68d0566af7593498c374d96b5ead7895198236af62ec2f256fcbf08db171df69502d1a2631244160bf231b1f462b4d693ad02ce233c170a94153d168314fc2fe80a5ae8120e94e301fe703cd46f4fe5c861f00eb28625f4169750bd3475d0078a218e1a7c3a806761a2f2ec27bfd3e3530f87eabe3304ebceaad0174f3418562ac9bd1d3900303e75dd14094aca647151849d19f87bb6ab26d64e17dac5c64921e7de99e70024616fca401e4220a9d7161e75def0efae50b2afacbd5edd6b544f1e3587abd0d093dd760a033aa01b275fa35056a7a643ac028340d70202976bccd37109666586d19d987c90746e5a43a1c2fb9158725b7d4338ce5ca9eb1e6875d41576903602e42206fe42f4852580ba46c98c3cb3214db7e12b4421c4149dbc4e95d706e95eaf382243a2d77a3671906e242f0a73cdaf052759edfb333cb501c555e2c2f05814bb001b1275991844a93c64ed38fdf2f3985a717c4bdc894b3b6ab51f6f7f0a02e81f6b021b8dd5efd00bb5c7ab663d7adde307cdd2987f8e9a19a6c8f11c70e4757c05b39541818de60159e7595c1582877c423ecc35227b237b18054acff739373c8d33c7e6c088973417bf20865a0803f0fef0058c252fbfaabead925df86ddac5f24b227b81316855488d16b45aca8c1d922108480c467ec12c9424747b03531d25022f4fb4c508acac40211aeb756e86277b9734344358d6dc5468e1b1aafe807287707b3be943bc60e75d3045fcb71f2aeebc79414a855669516ef5b9a54a88a9c008dcde501694f3ba4a592a11088e053f0f666a47080d60f57b5ceb01af048e2b5b7a76582163e0a47dbf34fd1fbf344812f464dc16d6d435f9893b86a81b92c7d6334d0b66b9a95428c38607307380b45156c6ba6809e28ccb2289e9c849690d0106a4c6ff64c25e5b46640b2d8e45ef59a470d8a57bb124c6684f44e43103ca42725f8c718bea8344eb50cb1f6f32b6028af64123f3d1eeb80aa5e5f0ae7affd2a7444970ccbdae582f5aa592e6cd543a46754f76c424d6e3c4f985823332a3cfae7c2b49c5d73ea75c0372667fbd8018ca413b47180032da676eaba6543ba340a9fd146105239985f1985c4779c4ef024d4592c63162a92efa7ce4051a377a13003c4b26c6056722e2f308229340f3780bfa3730d10d4736c9664a8435a28731866bc2971aa5542f5b4d251fd70acf98dda9673668d1654d37c590e81951a484ccf0b2392fb6e2161977e54ef95b84fded46e8f5a15d9b16916a4e839606b4bd4711f3cf87c8329f02d463ef7d2a57e6195691751359d2bf500ad8f4a80dc4b2f3fefd2442102a687378f6f976a84c5183a89b4886588031c264f3642d56e4d70c4c8a0e045afd19e36c72fbd25998af671b68144029159c71763b5ac329058899cf0dd7e71525ed51502fae17dce49a77ef030c5a9d7b268eaaf3bf61ede8079766ffd219f19af39f0f2a9d54f9073c4ab0555e2031ffa4696785e441d849f3d8cfcc961c0086a6885671b276aa60b36aa28efcf1fa59c9a4b26b07369b4d126b74fc7f5626e8dfa416149eb42b0a438b9f0ad70acaf89c2cbc825d13c88fc882fa72814e7739ca025358e1e14cfe56fe87ed9e5043361fd3b5207f621c644b445209fdb290e836f2e713a7b96fa4272c9e5f7874d5dafcb3a34006852411653c386c3220f63f0b0f036f077f90ba9fbe94d62acae51859b05b6995fea54afbd917808ec15c1e32ce293ab968dfdb55163db0ff539e4dc7502e1d942518c3341025035d0bece3d786d80c613d817c7bb97978a101b0904f4600ccfab8e57ee0a80a90b926321ebd4ca3583ff56b8b4da7f759564405b250de16a7e90f7ed1d1a4ade377133c53693a40ce033d13eee4f996860f8e79cf9c331d65f9e35203a8ff731fa947035ce0632155c14028d55a3bc653d5b6a9c61f11ce6b31b4c042da48bc736fc61128299a6a81ee1a863934c5201ec70b8d21e16afb4205cc3c288a47331220a2bc6aec9a2b6dc28656ac8fe07acf243e5dfb820b0842d2ef459765f887c98691536e3449ee46a5fc9683d90bec11b853d8b9d47686bb668d93ab24412c4493b2b8c603aba15fa9410b8ca9d150fabe7aa8c757c72416c658b3c2132545df8a6c1c0c7c6392744f35e9e375c4528a1e09250aa3351e51daa1a4daf0598ca1e501a4dd0fb8ce982b8b1f1537ba55c274103ad054fc83058fade692067e85cd23245c8feef8dfcef1c8d3d809debee22f5f75fbd2c0d996bba6bbda25088cc8cefe1be4fef44c48f1ba15e01a80c260bbb5f58ce2ef7110d391eb7f1d32d4327dd4fc52d547ea85d766960d659c6d058b93f6429a9fe114785f12cf7d9da206e66da6b7219365476d6b3421b0dc228664231fad390f05f9715cdbd1606b6312d6aab4b1d75420add7059619cd2f9f8c7c6641aef2b7188c7740a52783aed6a540cc8466b8201933859af1dabc947b2197162c9c59eea99f9a38dcbe87bd82eb2919a3903663b06a61dedf695a69f78c00bda77b8d74eb7b90e01a19853f56fc3282586eea45430bf3b0ac6536e06d8841ab3da01b7acf260d5d9c0c45b02020836f0db53022bdbbf4fb28a53ccbe2167c5d774aaafcb32254738aeca3abbc9f8317f743d07bbec3bc50412b0b8531faf8fc77d1f4fb32c04aba2019fc7d4f1ab8b021b951e64dde47e0d71af3e3e4bc3f573f89c10a04de0a571ec13d92fa28998e3ed5af130bd87b16baca3fa6a2ffba7dda5f96c4219ccdca510b88a4c65876cc4b264aa6ee2176fb8d97a68012dc9d20008e7a94534dca5d22b4225ec48ef9f75a8940ab5e5bbff4fffa1aa6bf9a759a62047a9318ae9954d608a2762de11a06efcd513fd2a5fbfe01fe66ad13c4f337a6cd056787b013fa66077b3ef0bcd74da56ae58ed26aae254b228723ee629eb6e2aa44847f278699f4c74d9f692db5d04e4aad2a0546485f0f2ff62759c4b8cfdebd2f3bc709f49e18119c8c7c67be2b3b1a571e75105213ffe9c73567cfafdc44a16995262c61c61ab0d12499ed8a63b74f549f4d87e5ab5d405236a4542b764545c9908e29784eade93e8e8da831c5919f3dddb46abb135f43839311b17929fc43aabeac35b849988c9073cafe44b54d12fa38f951c2f5c2c868b00925f44f1ccdc827aa9c0fcaf2eaa022cea38790b41643d571e4593a25834b2286d1db1d590be17d4206f7de1e75b3c8b4f8065b1c7de82f07b133b80699797713cff0f8812adfdde58c16eea7d73644fff4b204d78c828ee0e77162aed98db1f7cf961c1a5d9c64973a61f852f7043395ed28599ea897775223913ee1e9b763f55702d623f9b6ab02a28d87321f7f25e16272c7405b93754d7759e641afd7ce2cf716972f5d057ee061f81fa92691c1e7d0f284d00d7861e59b66827b8f7d99a1d276f37d0e7451dd3cd7164e4b30ac6a955093c483a27afc83277fcb87418cb264f3b82e5bc6f4ae836f932cab4aaeaffad3495ff9ed16ac08d52075d869bb559e20ee624991363d0cf21ca1cac207046c7fbc76905fe7e7b79a37c1387dc95cbc862255d79b0cfc8ff015a25b79c6ff156b4b757a05b97bd7222a978f47a95d32d5519a2162fd740b9861a4d0064e4da086f8bcb832c614a72a42fd21610da91a8ee329e77c3c894ad7047fdd3f182e71f451f041833558ee4b557eb0d46da1ab77530c04fd39e10a594a7e8ae0b6e97a0ccbb8696cacc28c9a3a0aa21f31dfb90bed2a2e019dbe2dbd5e0744a61ebf5d95dde6533b06141b4f6b08650cc6e45d16ebabb9fe8a1c707a5b01909fbfe253bce83798e65e71a89e9406143554268b0bcb8b2c1748d0f88262648fde497c65ef8c02e933868b9925925f4e3bf2cb5ecf37eb6ac44a0aeeb8197c9ddd6a5ed9f806bada5d1e94ae25516063ae3a3015c4b20b0d579b79a74146e4cc7d7eb468d0ae068888fbd1eb3d0ae5f9944669c7e79ce332911159502156ee5b4c8c80792cd9f4dfac685dc609a9e35905b85eedd12afa87dd49cbf6fda990596f54d9f897a981bea9bfb0720e81bbcfe43fed0f7e0febfd2b7173d70555d0d6e502130ffa610c06a71a8da01264329b43fb7b91717aa57643afa9365289fab9e1df2f522e0fc9728d4b9d7bff3f5c1c8cacb533275e2cfaf953eb85124e555fcf72315e09edc64a5b3f0161cf0fa34349bb8cfb18cefeb3cb4a01648f36b214f2b4754c6bbdbcfa2642d18fc79c5852fcaea364f25ff3dcfb96ea05781527339c4b35482fae9bac47fae6637b1a887303018d2b0d15ab68c01249c2e2d261daccbd647cc824d585d60699d114860a1362decfbb8c09e4fa954879a024d3ba41ffc4bf1af9f9b22282c3495724006aaffba1e72e6226663644987d941454c594a43f1935469a61df9fe22c5acf534ca9a81480670f8c1c73e8fabd800c467a887b38c39ee3f79c05433a685e6ca21c64d2a20d0c206c63b7280d3050fbde9dbd2ebe33ae003fb50e83b0b9e40242d8c6ec6626051138c68f5b194f80e34b669bfab82ca77c721951889bd58d3c314789ef9e1e422ab3f681ca520f2d3486882e710effb177e2fed579b589eb64dbf6ef5ef89260698ab6daf939e6c74c14ca87aac57f95940bfc0e81db4feed24644731d44945312fc8973a80378d4fadb00821450ff176ce6ac4f30b1fcf79fd1f923dc33169817473a2efeea4a28a454f976a2f83dede6eaf00f994fb475e481d18600540386904acbd130aa2de42474e677d7e4c84c4ea0d2e43c56de14167cc1a3d9feea07bf1d6241092f6c351c4f8982534517e1008d9fc685fe8d361b58ceeb0108d104e54f31f421cbc6ac001f4bf56d3d780ec4eaf2b8467057d76758d1b716464a6c272ab102f60d7dca4cd025370779b51414d79c6565df151c8f4417178458573db34415a43a569eeb53df84f81e0859f3246f57e8d7fdedc59d2af8cd1d523149c867592914d7bfef2608b6daf2b67b33213fc0ea36739be26a5f655ed7942adf4182df1aeeb04aacc7b1e6ef76e1dddcaafac0aa1cf95b9eb9479d60a6511373da943da468f509d4cf855be71052a6b9046b8ffe4bd8775e2a9eb540b50a10a6a02cf44dd5ae53adb79c47f8ee3122d45c31c9639a09a7f8be1c614655929ebcf4e22909c2cc4da79aeb250e2a4928120e91cb927b66cf8d3cbddcdc500a9dc1745f22b7fea39fa5e0809e70f024e307a869e4ccd47ef51201f6787b3846d241a560d414f55447494d3d74e826e5ae2a76e90c1a01da712ff5df621e1b217c7b6e58dca03daaf25a232c34ed887f544dedb91a6402ed45e205c2942549e9923647684e23a1eb506137174d01d952ec56188328ad08d0eec054c6b3454a181b55b9496bfdaafabb1617eb1a28a01354954dbf304ef937e0856d20e97439407b062735d82ed6ee093719512a813335a4b902a2ed99ecd34e708bd70260703bac66efa7d4b82a06ed74a286213b4cdc67985ff36ae2abaebb25f500e3892526e2663860e00ba7adc4b0fca200eb67ea486e3dbba389433825ad566844b6193517d41b3edc294524c03ec2a11a20dda29d797e208201ad5c6f0e5532867a7aa6dce68f1b648e6e5d55e5a56c03e779797681a3a6bd0329aa288ddc40ad9b23717cf091c49387895e9dbac31b5b2516fe5f798317df00826f1539ce55f8ed6b0762f713664ba9150fddb83807982f4c2ed0569dccbed50607c182aa4eee5d9bb67048604b6b189c68f0deb3d9949d8aa02d8f7b5549ff77310230904809b81f26f599f30ae49fd35ab0733261d3ab0ade2f8d09ce844268a3cffa50080a304d8db7aa545390e88c814ecedfacef6296e779d351ee18db70c3dfae693c1e3634d8316e553ecce5106a7cf334fa4630dce7f2e40ad514545b170de3764dfd1c983b1d1b6ad090722af393d7096c63da561b93b4d76a6b8f2b8b8ef2bf979b78e53563cd85895c491fd3412c69dcd520caa1fc70be20755e6e14199076e0144418195021170d0aebaaa7c549e79aec2e217195d08d1fb2737407a257946fe882a107f2d035327a66a80fbd66e65500d9f57b124f1b2ea71328e382802cafb51a46f897ee114d6cc845e7e2e5f3e7971abef147e1b056b82af931654c4565dc17b0efff9af0dc221ad973ec33bdb2344c62592053bea72d09b00eb5b85f1588c98046738fef1920775601a31f7451b1f87e42ad7468acf001622e62062f28e36b0ff524dfd6773c7baa9115182912f5b2b0643059425cc793e7a8d5d9707e7cebe67ea116e1a860387c819c70eb6f638df70e4c16f9fa25c9a637f33c877a6b716fd18c2fbeb8b94a563328d9eb53f6caa4d2ce14e04f3c83d8c06d4aa7b8614138f5a46ceaaf33ea96fa42923160db2ad47e76716d257f2c1e5637208a2ea5125337a25eee8b4524dd434dfa1619e8b2df49b950a9e86699cb0205f8764c7c1a9a9372fac063c0e481226c09e692f28930c81cedc155b2c6d5c90c32de8c6c84fa88bd46d22abc0e9637bae08560b070edb9d9eaa3ec38af870a833f39ea063d999363fa0fe46cde94e52a1f535c3bef23dd47c98023c537a6c58350e4c77d22274a2e33c36abb05988f6d18d2f9024bb67402d713ba0e2cc0c2121d6718c058c8ca6124852ba76c974ea8e41e098053c8dfdbb23c4b75ad6a4711efc03d4ef83c3a7c7e72d11eb5533b426f3159ffb5374ab5152248a78b5a3a74f68ee8cebfc527323da36ac4c0b7192c0200b9388c848bb96dbdef3a58e2851f4ff5165e2cd7978b5bb577f4b8094525932b77deeaf9e8276a10d147f85beab4506378b9ed074be59fd82cb52154b321dc5b6f7dc120b8b319509a9800d8b4c4f1cbde00a5cb38f22b59704f6c03f286f48b7e7bf21cd22fb969d32e77972c68fe7efc3b5fceef63bd082408086fa8c9d9f5f6163747f230fd9cd64871233cecf6336e9cc794778d86d38756ef35e757d3552a0da3a64c14bf1b8d1a12e68853f106fa899c2144e580f5bb68749112931f9e55e7b91547c2c4b4aa26b7ddabeda47fe6720137dd3af841320d405aca524e05a41372062b7f1cc14d42bded78fe6957b16457e949bbef0a98efb7f65f8cc168f494bd313973ae98cfc6d17ebe9bafb29f54572a81f3003f4f7802eafd85bdec55314207c60304dfd087417e1bc8846866f6f095666ef6e265b4ac60bd9899055155830ba337b206b1f728a3ebc2b20392cac948e144717efb6d752060b54270ffc7fa7ab351d05fd4caaadb2188f8072494ca583913a2aa701f79a19eb647e01cf172843ea6881a01a7f45ba585db34439475916976f928c97fdf00be6750c13ac3b4ed96822ab1a62fcbe4fa9393b373a8deb8df67d73721d07906b585ba0887e4b6fdf2d3cccfaa0d8557fd5c7a480cc5b7c123dc547af6844c9cf79eaa114a5db50e108cf06def655aae8d3f6a031dfa34467a3cdfa82fbc8b07c269275fe5cf99c794871d5bd99ddfd4b34170c77d9eb94fa217a9dee7681cd87b07046c923f9fcc12c7a89f57ef0dea3c8d1ffd525b04b67844538830c7ddf04a7c3a0b54803723a01509aa56dc96d6aed42edf945f1a00d828ad991636c54bb135682c41fa8caf7357f4a7cf3128bfdad5d9938d446abc741709e3b93b5ef78184b60a402f0ac1a4d60bb83375d844e8145ea9c5ba963251908ec616759d6e1e7ddbe3c4b262a91f20b374a530500679b636d18ccd4e06e1bc022665cfbbbc17f2422505fb4ddfaded537ebf6f9b18d148fb48091a7a3f1121d003ee937d1864d0fcd5d0040335cfd99388c0725e09668fec2e839c048affc8980dbf1e9943f01714b95e79689fdca8b3c9b003a6d5dd4312dd6e2cb4a8370eb5512e27b70fd37b033dd6c036b3e7fdbe863c258c2c3e484c54d0ca0615bad56e4fe03c45001f11d5906baad4e42f72d86c6a4fc90876015c775cb62a25153147e4a7c19a6045af045d112247bdfc74ac2b2c4c7d35652e38826c75d19a288c706d9b861d0d608a812cec59d65abf16b9a55c3b5dfd3352701bb210d22df4907b5088a6c171956d289d546c0a37e3cef6e135e4b9112dfb4538035b312dacc8c16791789e2e9c9700ab6d43396c1aba20be6dc03584329b0d4d8ce0ead70b2aa6c0972d6795d7fa3d43093456e6fb596269369b50a9688332e3b3bb2fc2e486c44bcef3684052571dcb9d82c30ee7e3efb91934c760fcbfe65f1d490952ba94928701d993f3c557a30929f56e919f1b2842b02551b8b74b956c1b37954632ab3890410fb3f2e8fafded00361a263ba03a6ac1ac5382828dfb9ca3c81c39187e49b151efbf3999fa4ab33256c846874f191770735409858c92f6af99588f7fbe6550400073443602a19ae553139d7676d0151e3e66ef9e7807ec402dc877feb1bc3b015e2aa0779cc1ae965af2227e771048e5caa4f1adc9f883e90156ee181b93976b478b259b2dc0d095c4171532f049903ff329d8435fe76c5e138bba133f55df5503652c9b74a87d1869612730f0a911d3322135cc84b9484e5329cc21d00786d93deb47112b879b8bc4021228d41a9c7faf4c3f5cf09ae39d9f869d16367dd034fc062ec49c6f1647b66fe17cc57afdfb2f370025e5b3eb82e95efd8f1d36de884a53832f274689b79cee5cd049fa6def652c1cc97c18cd9219157358fefdadc4b2ba4d2c0f5e59397e3bf589492944ec6c958c15e3f1b7db35ebdd64cdb791219640d1855c0f8a9873cfb55d5feeed0ce99471ac9152b855488a4dcd0ed4fa5e0fe4c78c5a9e4ac85e8a0a828cc2abd17998bc4433b3339f0c3c5cee8e0c9b29c11b3e04c0bba272e03f699c811ec998e6e5cb53fc2a5df615188ace2ba2f0599a918fbfa6cb5d5b53bb5fd8948e440a4c6cdf66450ca7ff27f2020887177242245a9819c3eea971b2d9c84386d1b2495aa82a469a8fc8bab538855ef296b9ebe2e9dbd0ea73a58b634c00ef8b0ec189903564d5e42acda67d27fd73617797071494a1b46307f43b6db61a8254e03d5af1e30f4e666d5feb356d7b858114f347127273893cfec47e331d135c878d741777f6558b98c27ce75144168c33c12e64758677dc38146326226d19fe69e30231b2e40b5e118f7ba822f4df60f26cb29d22bf1727044d0f6a3544d770618c94b0affd40a4d764f70158d69986c193094fa1920402ee11e6a04652897928a9be2e725623c721dfc67e9f05bfd66763b06d9a84258309ffe67002333747bf976a28302422af90dc0736c29557251c2a3f6245ccbcbd4202b96f5d14df6b590eed005012dec39b3bfdaa3a79ad1bda84df3e33d0513b03f4ffd250ace4894f94137730bc1f9e70cde4cbc13f4e4070b6e22bee5307cb40674823193a3196f1a47c9eb4130a40bad57ad25053dfb12bcc2ce7f18f07bcd9da58e88d5949a369a6059870aba06e61c51db7ce92319ab3d855ff4a7e930083d64b6fc264c9e0b96a8f29bed8cf621f4dd62f6abc89f25d8b3aa67766389fb5e9dd383a73a3f4cf0fe79ddfbc353ee9fed734c4c5d78f6d3479bcccc008207f9792341165e113c7253c4672abaf824e2698ad978ea5c42bd19a7998d24e175a4f1181d701137762290a009f08c6de276824d13e3a4a7ae7dd384c85b799acbf15dc20b566ca1fcd114bf926895d1b2a356b779f0a25e9ff50f8a6f908c475548323f55d10a0dc1ce63e834f499ccc8604f6e97ad695f3a02de4caf36cc2eaf3a3b925b61c90c26a80094e2e6905e9089cd7157e674b8e9c49931273cb3738fd3c0efc316a619e533422d7db23e134de16b0010a3979579ce14d8e0093169dfe4c8e90a56aca247cc206e1626168bb394fa9b7973a3968224c17b90b3ad762d86c0ae77b61a1db4a2590315d3f93233b852e0041d343379d5c1cedd71df376ae5d7e284505664bebe20cba106845ebd13e2e7e85db7cfa30ce1bfa993c5f3dc819db9f408ebbde8810f578551586dfdc8032389528b243bf270924602e9e033cc978730294e47d064ab0925ba6295b273206c7fe4f3c517d84f18485fe359f3541ba9a6979ff1d03b17f17445bc97c6456a28da494c7f4bc7e6bc195705dc91903eabba4ee9a37b1af6b6d315ee2603feb6ee852a41068ea07ef8feb9fa05c8547441377e8e226bebeb2e5fd84b32269df2b75df26e1f944f30eea3e4f505ae6c375db5f053898c26b4b226ddd39d35939131c7e076f271e821dcd568225b7e0e92141a5ac1b48f0248fd3746c37f96367709ad48f6c1c2f48e7aeb2e944027fcf25db721ae79f030f38a788ebcd935266a786c15a8cf96b1cf857345783152885b1286b1c19535ee0c91a1dcf667c9bf350beb0bfabb6870524848866b92335e25a9dc43f092045f5170ade989a758463eae9d7d69aa200386fad001ace797ee7d43bb66b75134a7f12a6b290efc06f03d9db2373052df4133cabf016bae68ccbf8a9bedd7f7f6c0935ee05ed7dcf2bbaeb6c7c57ac176ddf5a6fb0feeb42e8e7af9e5c947afbe3eabe29eff49ac2379b9da62654bfb6b0fc48a410c290e72225c4077eeb51b9a12db39fea6de64e0ab0af2d937d41f39a50178eef58075cb7c3f73e6d3428d08f7c6f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
