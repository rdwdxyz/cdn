<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bd0a3668631c36bcc5a2b03e2c704ba943a8e9229799e9800e0a3d0d1ea6c7a6efb9f6080233d48c0f002b98f2eb17b6f47ac602e0f2f506a2f9fc22db02be071ddaf02fb1faeaa14081d694ef12f8e6b0909a2aa4089138aaa800813800687c8ab36d754d7a716882dc8a983c107ff411904204c1b5d38d7d19724af29ed937ee315388871ddba5b06dc7c6d5d0f3acb7572353e8d29e7a865e38d81796012cad7c606391e4708ed2a336bc6088c223acb22e3cede2c565c1477d6e7efea1082cdb65640d52909a275a1666ca4dd294079bea74519268032fc277fef7a0295618dd82b30695d0e3e8b55507c70d7d7fcede13253dac2ed2393e6e68bee88a275cfb1cda889b4514302d733108dd805f092442c40332defe1fef384706cd7f44a180dee9102607b7b54e96c5e930b34df31e68ac933b769eaff92595105b1ebebf5702ece922d6888cd3ec28b28e575e8689e552de20c95d3b457f6df14a5832a912fee5d3cfd912bbdafed175b25ea0ced3afba132a37017dc1677df4c7f9c394df42bd0c573179d16d0d46aef35c27bb7fa9fa9b7b5ffabc70885f545e436df296a2fe7bb3f2e65eb8ef9987f87bec2c0ec60cc2cf038b7fa33f76838995e34f6794f36103a51551d84805ac749d68ea468569c7860e5bba654ef4341a3514d7a1c3de4b706e0a7f40aa8fe15a199e10c68a8ecb1eff43dc17a3db1d380c6c5a82a3470f30b9038f32d18186285e90b90a0fa69e92ce754db6ac8d82b4c598f3bd11ffefe115a5004bd3f21c90f87e6692ecdc9aae58dad2d7ae9ee10c769858e94e4858f7031abf826c232ba4aec07ec3ac2d3a32c5e9e68a3e8efe61731f7a985cfddc2730a795fef973c3bb85be8dd2dc3bdb2c6a69d0f87b1a9a703f2c3f20034b45b963ab2208cdfeb8a2d9d9365dd3c7dda6c05e3a38fcef82f3bfaaa8e67d97b9e60d24d0707d399ee374e3af6c0cdba80f41561ab95f9a8db27aebbb62d2c7650bbeecfe6ebaf107bbd934ee79eb9d1988465d97f683272e5b24d0d725eba7aed1a6ba3dc336b93cec506fd895050981b2a9c7cf709580d943cc2a043e2368b51e9b2df02759be285917194189b785d867ca9f12e032d933af732a2408bc82d873023aa2c8b843f60831db398b2f7d38a83401de414f7ff9583d37488ab817587675045abb4f06e89bdb63a963eaf83269588375d62ca357e7b25de2a5a74e6f0eacfb7821859b95d2fad400c3058dc6ca852a479d816822c8454e1f3ce624511d98fe1c7f8c9ecc101df3010e1fac8b2e4b52b4133148a6ad3cde3cddbebbd12502e3d22faa809d12d8c95aa4fb83b41875ff0ee0723713e40af21df0de2d72e00ef57f8dd67a7420699917534f0981244109af833a41c423d14e47c13293ac7f2dd3588f67b34494dcb1dd6288e02594949c60a8e5fa420a2ae4749cc60fa0afafa77969d4497b6af9cc3a17fed8cc97734e55394ffe30a4d644128aadb4f490d6a90dd573fee59ea703235180f3843ff7da342d1759b3ec422ca1de6a8895635024b452995a4960dde25d2b0915e833a9f7deb00f86b16ba14d4271f9b4f1a2c2f42cdf5cdbddaf5edbf01efc7f982103b006f9f875b8d57acf3ddae88bfcd425aaf9aa859ab03fec0e8091cefb712bebb2a517c5754d3958301278adf1af1f16df9a01585f8b6521e5183da5b3bc3b90d031849946f7406433e1bb666834d5a409104c77a4db19a416595cd773077be496626bdb56ff41f8c36c3476d757c829e29f1e856bafed190fcaaf59844abc10da8a764a74fb1fe493f7245af1d1e21af26b6d526853da0d10e955a18cc48476a6b4bf05f13f9a53ad9a690fcb218560b7e88892ebb3b53960b8d8fa5d8842cef6aba3c240fe60d89870aa58628f8a87292dc7496905ad5082dbc799d9f6f062b382072ab5b4dfcfb86870aa5074746b85d75095518fd3e8eaafbdcb8f879f3648e7841d6033548c22e03aa5956192e27328822abd1b075027109255c15cfbe81de17efc60c062b16e48c4659b4eb2a3c91767e4a42c6e0fba28c65d4513d75d83479dfeb1cc2a2bcabefe71dbc76a0609da2b62d1abd109b43955ff6181890d74f613e146147c8f8884c2b7b7922aabf71da73a834867dc9a6aca566b6c4a85a64d0212aaa0751b3aa21ab963e533350bbf6c585b4e9bb19dcebb7e928604f7c47ce04782725d07b2b58938dc765845df7ca1c74be611adb79d13d914feca4d607307383958d4425fdf221ce1321015ebe2e26eb72200a4ed8db69648e59410d264a27fe5f0f954863fc750aa6cc235f80151cbb0ecf6de3f6758922dda2f5924b375316492ea987e68acc70619f366d7107e1c7eab1f655ca32d8393e0697c0493d0d12c63fedde986358f3b311bc75523aa94ae5df655f0a7fe527a4d59e5babd4a2746d37710b2729e2d071293dcf3b10732ced7891cf4b5686836bbb7861bd02458f011e8db138333be6c4979e3c4b176336464bbc77b6e5d80102c69173deead375b913f027fb05ca8e64b80c8ba060664392ecf81104818af8b1e8cddbc8b0c3e28086a4c82b4958ae2e4c3a6f3327cd0cddac3007c870580280d0695d10ceab7a6886d9df6b3db486242cd793e7766851390a5f1b9384ba687dcc969d5ec82ec36e86d7121cf602017ae291261329db7aa87ac953ae3d9e5c53cecc0263b6000cda23ae4c39354a5bcdca6bed9b4f06f949250985e67540a395d231c7062f0e53e9fc8360a8750d9a90389bfa3940b48bdae72f28a554a9c83b85a878cab699cec01d85c1f7ec59e8c77b158ab196895b0dc6b58a4037a7e04c938b07cb283171dcb243a1a94d5339bd01608e785aac15b18203b253f45e5a1079c33870631e09982b33305906d9ffb249babd764b62468ec83c88a03ca3d923e868a22ae0ab50a0e662d857f35f39e5ebd5f24f82c094c5de56a479930b16fca96e627e2c5e3617a101a990312432dcff8ee93be393dec780dcc23fa52e35000f886218a6e29e50fac61f2521b6bcd294aae842fe2e400e5236b6776f02c0c5a7e69c5e6805a8a76f2989f420314faca955de2e848a0ab42e603f76059e281603fa45f50da5e5fe56c6998593996ff292dae5023ac3c0ef45c9f253955b09d52bed2d95bd0b3d40c89ccf0a5e24bbe3a3362dbde63bd0abd9bb8e83ac3ee1bfd271890b57f828ae6bbeef2080d9d5045f5ab2ccd3e678dfb74b30de65bed9962c1b9a1c5c59a90437fd2fa744e1b9f0aa9fecc11c9ab85e10a1c0f6d2b060a03a40d996696963cd80656bdc3fa71e1c993380f6086f562e77fece85ba90ca31a4b9a31bfea9179590c1aad15d894423ed6d37478c802125d416c6ee69592b7c42d179f6bbc75856b04de941d2ac7956ca353d98f1156bbefef4227c4ad5899d4298d74c40657b73967a0f41559b8b6a165112cfbfa294f21e6b048533a0cc6b140cc3160ce5a9cf5eec08c37019faf96f32007862bcdd730733602ef0619153a308bf481e938aee417a9663f537b1c890e7330e97a0dbe3f3079b460063b4acb0b23c6656a9d7a34e196cfaf931237a7ec99b660fe8a79047fa5e518d89da32032f1353207bda20293c3f387ea48edc7183295b6eec4609d916c3aba9f088ab9c7dd18f80d18ac30dbd2a8856b18a290f716b5b6edcc1af45e1fc93a4f3cb4e208d334c3a312373d0ea2a062e000e16398fbe6513f1b0ac826b767d6c40b7d5714c398a8f01237bfdecbeeac1ded5b2097845c9f655e8bdee4a2eb0dd77d5be2ce3f082a237474ced13f3a4e1da98c6addd31fc376feb575c580b948a308a7d78fd4e35c398eda49966711ed5b868af987565168c7850b4c6cf535d452196014e9f6d32c044bce79204437e828f56ad546b4564c0c7a11dd00c42a8df870e55fea98ad5404dda6a071ca353e61f8c9780a56bd3fd6db7cc546b8556f963baa8a8116db82ffbc8fc3834426be5742e4c73327a81d019c5f5542286c4c55b66595c17491302bccb4ea31ffdac50efb9de5e6eca92f672e422408bbff7173cf0079e595cc1c1c44dd2399b701dfecf9bb1260fe62995403023184278c8b244b23095e440dd34b0752d998db5f404e8ecef12a6707f2a092e4e197b1ad521bab704cf96b03e00c96ec9703f4472efc6c4ff621732eb20eb45e7f34f26e94731367f9657dc3ea322b326fcc271dd38873b285d2f7b3358327c9b7b165028b8cc5a2af30712a61a53ac6e61ceacda314409ed9621f3bd16594234dc94afb363a620ddbc95a33a566d89e853e30043ced304d821ed35565db470156b1ac5a08767ae88e904454fa8e29d6922d52715d686901cceadeb2d3a16d76496ba2cd3e9e454f8a8f08b9ce31a025063678409e6bf53d8d0ec12af0c39c2c6c4d902dd91acf2acf5eab8bbdf92362aa296cf0a5ddaf131374be947c633c8f031ab5937fee21b4d9fa4efdd4902f7e3ca96f98df5db12046b4b758af4beb89d872f2aa28658267e569556206cc81f41f66e65f7fe09fd20d82f9b46cf54af1dd3a99b02ea56b3b78e5601e8ea76c986ad69625666b1e3be18f2b7d1ee153deca75c944457297903e9db5b3e2337e51b2745f53dfc8cf45cd6a728321831b65ab4bf2d3e46df991c1ee0f8d8b31cc5c6a46a83b2ef828c4bdaa7407dda523d563472a8e9ddfa5981bfc61043f1a1dbe033f27db282857ebbe7f206d5f59b545b5ce880894512aad03657db21643abe3d99005663f682765a526c4530d5988464df3a318b698053db16dfb4120785121e80deae9056a44c48be0a907ba40eb3daac1a01e138028beab7078e0c2f62cad1f4c53a7416b16ef7d142e8c92cef00fda5bb03a374b54a8356c6eecc633faff6a3fdb8a02d6d21b7b21663173c0cc1a4ac8465828c81b9aee9ba9af612441806345cd2fe8e91d7e8d59af2b4268e66520c9f1e110cc828e2f92c76a8975127cb0f7267e426f4cbc3ad9052fff14bc0697b162ee5c3d0df14b2d71e1a1bb2032e5ecf9ece167d1f820a90757012872773ae0805553958e51fa321670f8787233bffa8ff300984981ebf177625ba0e26fe3286e971066e0092310b0cc2dcd14943b01c99c351e147d5fae6176e6aa79ba68cf83db18fe83f6fb6e7975c2fceb86eb0ac530bdec27203b442dabf77c9794dd2d4915c40d33b8e1d8f8673eb84bd5df3fda9b8c6adf46b35bd303e17acb8288422975a5fa31dfcc6921e7bdcaf599be5690b39abd666e0f36865a65001d7cca750ce1d9e7665e131d1e778c48f33f455f14f0a6dd76487ed0fb8c69d1328f7b1b096d1dc34f186328ca9b7742787ecbb6d39a22ac8bd1bc30387e5836a6bb469f711fd6e154ca6e5eedbac3578f165fde717d8ed981c77809813f772f8a47293e16ed420ba8ebc4d4486f864928469df49a8b693aaee4fb936b5c741e5b67ec0b76e2eac82c019f0f9f13704c5f0f2070aec3e8c8ced4411c209d4c965d94974078524b579355c7b37d21760b407412b2e7861fbfdd73ff8b865b4c1cb6628376da8c38b96f8c7536d509a890d059f4ae4e7cd5ddfd730d0f72f05a71a0f1d693ac282d1a6ec6620640482a93a7e5a2562e1f18f777c62cfc40222d5d9ae2d35ab84fecdf69c69de7bb0f81a741c43cd4effae190109942f3c676b1095850e83d75ed8149a3f04c060c7d0cc02ffe9faa446ca543332041869f9c452cd6dc3d97061ea17d214d3844c4e139f72b45ccafd012cca85f4370dd30c191d819f88aac750cc6b13a7cc0aba088b182773eb6c87a9de8cd04ef63edd411c874aab49246d9ac0dac5b36cb3cc0c38b88ac6751f26d425795ecbd1c17dec601f97da76decdc5597ad13197e77b9133fd189e4b8c0f9b9ea36773c51a2efb1a8cd52bffcade8284ef139eae3b4a9c9564402ed77391acb497db15b194779e53af8528b780b2a6827563a7719ba8faf632950881a4a3caa44da5c90fff6604efe08a87a834ec4b2fd7f438085d88cefc248425b3358cbfa196c17490e1c4c5812f3e247ef1a377207dc4766eadfbc94ee6d3582c708504ccefa2bb37e7c1baf3a1896f1a1a5b94ab067f261016ec809c5162a06cdd139ffe18c9434dace8e3c79b03614770dcec89a7b89bf44bc2df09a72f5d00c0a44c394fa042eff8170f1720e82f08ba2abc390e302055e9ea4147a4aa1eacf409f63cdb52ce64fc3cf164cc2044ece9aa2c8b7afa7ad12a707dba072e102f2b459412b1684a5eb9ce21de7aeba22c9d708b4561e99b026b2edf8ea3fd5c3618b916bd14f57939a65aedf4f3f49066fe638bb7b80bc8738219b1b3f70d85543265025bc7d3bde3228216a49652afbe8f8e383fc17d5f1337abc06a51d9696a3ab3745c56761fe667a7dbf3940704fb736be17a9fadf5b8429217e5d371424092a48c46c60dfd30b8082b9148bfb2ffe0c44498d416e485bc515c48e99e31e4bd19e0b56e2499da9816ef77c7efd95efbdb775565bc741dbd80eb451a7574b59745150095e26cf6063a8c52c967dda6da4bdfcd8c4bb6d2065e2a3394744125fbedc8ebe86ea5dcbab4c80d0888bfbc2695d7a4fa1bd3d03deb8feacdbedfffb7ee21cfc2ea8955009963774263bfdf3675bd9d6a381c3ba53ed7d8814118ffda5dfa76597f679321cb16f670afc11f1451a64be61ca2d1697cd233f2af00564f85dbd91c8c0adb807df947f1a57207723b47c96d8b4894119da49450de10542e425c7ff0010336e5fa696fa5901572166fa9673d71b8d979757368dd5e3a9309adf44b2ced09ee498b57af11103d988a8f98660324889af76a27bf5b25810029238c77457ce118b982093c1ba1a7e3bf186584a6652e9a05386bd43473c7effe3d71f547879770c0d4a51e7e4b0acbd31e347f7bad8cd4d05dcd02ea0aee754ac76cae171652ca7ec8310e510c9011745888007d8daa0d277b1d47bd5541c44dd6d14aaf6e185a39d244a6dd7833078bcdef448b96f7a5e2457aeefaf75cb3ae3c16e7fc49070c447d01696518d1e2e8e99a6f44156853dd4a56332fe0d86413b10df8d7d78aafe377d38b8c8f8c977ab38cb168f386e87329c04c8c3a816f9102efb672d0a5668fe9a82502657860258bafdeb3336a0cb762ca4efb90aed7690d30c645a8e2d7a767c5f843bc9ad5bcd8eb0020cbffeeb4bdabc5e445c4f35f37f87c456179bccc266acca9bfe57505fb232f62fc88702fb7f8f6fe46360616c039af7980f893ba6d5c9ae6806b88eff68da36e427867aa81b91e37d2b5b8491c567e05ac1b175bb35844b08e89386cb6d932428eb366aa115c7d73088af163b7880797d7980e50b5bf4e887d5f659b7b34b180150ebefaf3d19cff1d140396b95224e7a4e3289c15c6e5c24e0bdaee3a6dac0fd4ce2e53b82ce2bd5baaa64c10a2c539ce107bcfa9197a5028644b935cd5b470d8c3c57e2cdec44efb06a5c1f84aab04bb7481f16fc3584e1d80dcd47b64ba0553596dc3a09fa62c01d0af79ce245a7587cd6115e25b80b3e1a5628baa41bda660cf2acc9f68dbdb755578d0854866a16ee817290e521c9873d1d3050ae92163bed2205c8e8a2132a81b6b2dd6392dcf86448ad93b3bd2730554126f5891ed2f6c37047e59111c9edd856a4859f3c347668066b89d1f924818aa38ab5d882793269389d141e1cb3c79aaea7dcb62e9e7460762c41858624e32aa05841f54b6c2ea08b104627f116457dd08816ebc7afdfeef74b58c1321741d4e81cdba149ddd50986954a173c1ce1a50a3ffc2bc5f88c728bb442a9366ffe80086455f5d5144279a32582338bd518d1829606f59208ac2e5975b09642596d25cf712466cf942894f08b612c3570b83a6f7c0e7c081372849c823fcc57191de2f749d55105e6169939a07c89d33877477921dd94f1546e98321c6faba746adcc2a4d839903babae43e28157b365b7c05c7a107416214f06c9c41b05644ea43c509ea3c6d240d3152a4007523551c4d826970e0f14e86c8c1be47cbcc4225a48dd65d0c7889ade1034c8594e483565ce74e4a638058487f8127c2ef3ac9e2bb587dac87863bfa02716958611f199b582ef6251cd3e28db8df973c066a04034954f3771662b40f33a4a8f2a9613e04d7ec4457f6d3ea24b5af97d7fd242ef9d4b265ecd12165d726ede7d6b6b3a1defbbe47f18ac22faa37940c191831009f654c8e18f7e8662cbb10055dc9dbf09d48881146e0ce2b9fa39c98e3a36d026fa60c59a57a684ac2ba0c29c2f4c6f9b5609ca21a4370bd6b1fe99937fe98580ff24d3a830bf6a64bdef73c509619908b4828ba41eb88b3d6afb3d3589acdbde835fe3d4e214b84d9d9d51dde6f19c1ab226285aea6e7ba3acda185b698398395425d35df95bf29f8c2634f27506e3ef82108537addb641c0f6bad99f0c8b92eb237d18dadb6fe6a12fe7d34cf4c6d1cf56de81d9d4d427ad47c020ed322486f5ad6f78069e3460b77d8aec874d53130bd31d05a7564c21409e0b59686afdca411023d556157495fd24f8207a64b65343f19ab07e0980a1c7cc7039ba852bee659b1a95ca9ba2accfc516a62b6546189270c627e0feffca2849c9f1cddf047707166d30a1caa0b347a33a36b9767681eef889cf23d2753d93c7437ba1677e0bd9959269d12a67b9460374e8f6a2392246dfdfd8ce55d6c8346ff9c3f0cfe6d292185bfe14adef4610f0ac5c251d386266b7c861aa4ce5723f9f0af75ec742418c8cd739747cd4701d51d0ae9fd492678f4d5681e4e879ceb91011f1e297488bcb61a6430263fad4a7609829dc9b132b091c38728e4d566834c9680ea89403dd507d1d6b9024b7bbd4602f1368e69b0340aeae887760e5fa67d250a0197cc9cf69896222772c1d71f29e0315c740281b5784cfbbc7290476145cefeb08f518fb14d0606c684737da6b6f6c7043e46a750a48f755b0f3f8f88e59a23ab7c240af1f978eda8c6e128bbd784555ee8430692a8b7b1fbcfa473843c48f66622ef1bcb8a3f55445605e3d3bc089a0f710b5130e7f90a3dbd6cf2cd54b8849d39b743d16c1f364f4a8e3696d5cdde3a65814edc6f0ef2eb837e6a416f132978619bc455e3861e32120cb7c8f24cafe96d5a18963e4eed557558f7d85456f3a897507a096c43f46a182be0111958f128010835e3871c5fc68dbc5dc1a87c182ca6a05603e7d900daf3bd86c4f3f2a98f4eaa9f0bad23c658f6f72d7dbbc832476d6d7ab245edc5060107c8150305a64d7d8752f2749698b36ab2aeed7879bf2de617f712d67b1a17a7a98f05d8deead80f24806d069f051d569feb035ae72aea9d00143408302524642be639b52bdfd410c3e9b723138a6a8509c61ccf72cb564c55d21d72e56095c39866ca0ba93b630541e668b51a6a0f1c4e29925b2d1455e67ce9b315d9c6d7d604a8700398c5e5f24d06f126646c3638465814c6081a7e9c73bd2a479468c83d3173d6b5d0987ad509905b963bc03cce892d6788a14c2e516ae71b1f28de91a9eafb708be9f7fda35e1bf3935ebccf68f96b462dddeed79903d33187d45274ec836216c81d9af4134ee726b31281708e583388d63bc00dd63ae739576e661b1256bcb74f6b5a9e7c69be86fdc15cbdd287f813fb11138228d484c36f1e5b4bbf8d4f1c8d541b6148320512116bc1b1ae67a1b2f16f4c269989e6f290d4eb26f21fe10a2cc0030899b8219a4bf8072bb662326744435f4db537e71cab9e797225f09095d42c4919c45aebe03b0c2bdde03be0a382cca250b5002949ab54582f8ec9244bfa6d983c0d560cabc2e659f1d30b1f257a75066b2f407230d0e0d00349c6d59c1359d9b6344b35ace210806818df72561e069ea92401bc8b051404b5f0cd22df55dc3d50f579c629e93610ffaef142f70bf7fb56b9569de22f769b19066223cf54d35192541412bc7d2929b6bbc0d927bb5c41967b20a787181cf4ccf305731416ae94d51c69a123a4575f2170976eb6bd009fe484828c7df98d777b2fc39f5abece75c12e29899b6668f2de07fdaa2d4e61a3e2c1a78c814fcdf4e6c5a849b789b134b2821eca3778919ba43ef1fb52b8cc3e21f2826bd9104228007535a473a9c0ada650df0de89c8d837ecbba419bd9e88a15caaa6ff246dddfedae12be9fd43e25abfc36d1771a5db808f30addeaf39cf1bd9a4bf737589b742c40100016b70eea4b0610444f1821e598e277462ba39155841f5f06ea7187cb219ada5b14b90c51dd317be689b1d106542ec9af7e949004c6bbc055de65784f02bfbde983e41f1e142827313f6e5a5f7c6c90d08c5a296cbf0743f051acb91aa6d22351612362540605d900413d831a47f334e26e96a4919bf303c5984b13a7da704b9e33e16db7469f20eefe7a5804506c4c98e7ea10c4faf3d2fe1db9b4ce775b303bd661cf59a26cccd05e7881eb5ab29cdf3677d8bab9dca883543e9352c14123e5a2ce9d7413aa36c59920e1c6b153e163d045c856758b1ad60fd559a10530b5b252b3fcada6f352dd4d9728c0a64a2cca7fffa08406cc6b6d84ba437f9c2f97a80edbfa927cfc48077d3178437c192049207e584a8fb4311172244a1f7e89845d3f593438f993f2b040c5590f3c515f1e20e4364e91a66adde310c9614edbaedf11ce51eefe3c6648a8c22fded5d3e882a40989b429ce642b60e5835e3c59b1bd747f16b94bd8626b2114ee307bb966b8ba70207f21fd95a654a03833efda22cb78fab0b29ed72aa360b4281510d657b64bfe2a6da9ba225c80de7a86c6a32f0612ee2ec7582a6f95681b95f255f43338e2365a661621ec7d3cd9b613f3d146a900ae0c1640f9a57626a5a32c92ff53defd67b83286bce1ea05fb55912d6d7a64bcd9bbda9d15235a95d316c4e4b6957546601b1b341e70aa59420e5a32ade3267c4b9b5605f17569a7550c6e53258d054928d5b7ef71d05127af872e924329a646c974c33a884b37b661e427693f680cda2b903c1ef58476f39f9ff167c4c055d77dfc2b79ff05c0fb4d6fd48ec95194b62d756ae53fc3ec921fba12321550ba9bbf48edcb0c3fd3576dd7cfc51e87a238b3e4952d026416b10b4aad59fd11588d9971ef7a508065ad65300ae71f0dd417c4ef03b36407d4f2e31ebb55b631714a89abd7678ae3b92e0f6daa541d37f7d1bdcf351cf8ed510c533cc9cdb6ef226b1cc3aa9c683a14fc2e427f16a3758419b0b9c5dd3471c2e6e91cbc6389f083717bc79b2dc25e62262de18043bcf52001c01dc31f6d42cbeb601363c27faa7ec1ceee6d9d7435c1cbdd24b7db1c4bd1f99f37897affa66b264931fb20729a4f34dc5ff9083171b7320c03d197a099b6d4edfa6583fa5fe79f888d9e5ef3f2e005b5d8ef1bcd989d873b852fda91a18d122dcbe330a579d6505450f0c2e5fe2f12cd1de6907768ee2770e30312ccd81ccf781b697e5b2dd3036de59cb30ddcf78df3f20110830849f0cf65e83aea18dc9e5f900bf94f6657368aa95c6c5652146186fdce66b30ece7a0eb7c3be4e049d91de5cb50f40850bc32cee16c9260e0a47f73d0638eabccd1ba4f0e86c50a2192a9b8d5d6553aeeec609ee0e5caede1dcaf034c878cc2956df3bf4afd642c8b8d0d85ce1a9e2d5b40195c99ec8d4856afd4ba0f35085d49973eb4a51e33d4fa2cd3d1fb661f6576ddfc34514756676974e9e20f3426e233c23224175501fd1018cf3993d8f470cf834341284713db3602cb27d209e17229ff8808406edb0792db7b0ec5d3e385c79b4c117db21f3efbc04e40ba373e0cc9db1e823602677aedb11a7509a178b6e928d502684da2269efd006af6c83d13d05e7ac02bd88e0f35cde477728081ab0dbf28f03ab7fc8d51ba434495e0feb5fc172ce7f0a718e46827fc0e62c4f98ee736ff1df92523579b338e15e66f5d9a165b4aab4b50b2ee3397bf75fe47dfc2c0672f7db93f453fb7735b2a4f598f75624c4cf2ecda37fdcdc1a3d51d7a396b8cec2d7c34ba6cc2f26d3d76b2ddcd92ff80d9dc9994b1f0eb271da5614a608a69e7ffa1d8318066f5bda5639edee60f8bf4b71f2fba0194ae83086d647df53c6dc5ff29b628db34a7e431d28ccb4380d7913051777d1271574de77af47b52d4c6e8089e5fa19255c5fca46c058e14a3919d0e06d932f42e2211dfa3de31d6a3bfc5ae14391d95fbf1926d9beda162c476b5fa6ab0f38414c87286043cf1ecb20e96b916f80daddb6b19bbf88c7dd023994790c8bbe239cafa625617cae741d9d6bbc1b7ee15e557bf4dd7d7001c492087b98bdabe02d6003215de850fd5c75a37ea1b0c6a508a714385989dfbf7358e323493b87fa46f38339b0275ef96d9ea2cee4ae958b6858ff54c8cb3f79128d549ee77cb752f017a2876038438e4ccead383584da3753b7be60c80612e1dbb54cc697f5e6e066897a139a193cf3066081b24c3efbb01b40c144d630bcef3ed5ff280593b4fbf8e7892c4b2c1502f4434b9e0f8f5cbc0bf5bfcbe9f7e6666917e4fb88514c634f1e2212f4727153b3902c879213198e7eb10bc1445f84683e38bd6cfd67c80e3e38fcca640b8301f3df88930b9690048fdeb67b8d94aded21a8ee12d25a304dd3372a10866f7f415f07cba011d341a69c29b14a8400a6bd1eccc4a832c3de45c743de669851c0b33c02a0410a65bf1d2c463d59e768484d4c7aeaaeb9f6f3d1970131251ea37510bcb018333b4de531781f28a03b4bc45c01772fc86bf4113889d0b78f1e4e05d47a7809ddc21b3271a3851304589d97af9fb5cba38f439a7161f504c71a2f1da33c6002daa11c4d658bf6bf30195edf173e22c0956cb8568c53c66377c7f4008bfee3fac2b29172ca104d85bd9eb856db9df52b33e7c1b20daac1196a77f970ef28052e490dc609b61582fdc75df33ca6222d71e01fb3b66b55801a7f979a97873ea7a881283de96e3b35f8ed18e7829dd6fed5776797c64f38585607dea6505620ea7cd747f95f59db404d5035cab8263b859f43b3e8704aab31f4beea857217ff06f18b7460e07f5973a764f51e92e1469c4575f25bcb1201ac9513dd41d99881eb4fc47da16e80e3dbeb585ecbcd42cc3d0434ae3f351ca03bcd599a6424f0033293e82db996fc1899d19ae8bb5678f73583b324911e0aefecc00afd01d8a76c3458bb999ad95770332904ec47958b1b294b70c4140b140975b31739b92f9d5588d3294c53796c678251f719f259097fface07f3f90bf1e5090f47af267b136674cc2ec4ccb7b36938f4b2186a92f6ad0795f8b4112be4486423ebf86e114ed9e4a758561d40aeb56c05ae84fffb57e6b879fbe437cd4114bd3f0095811dd1b27504dfdd15e416a71d42a1970108b8fea4ff6bd74cb1c9c1bb0c2e24db39a152a74998bbaf05ffdd964ae04352dc92325d20990f15d4e21011eead42d9abee82a21a26547b45f4ed75f464ac510f136dd17f401a8ee97cc7f26b8c100440338ab1eab258847c190453c67e0c05f51164c6bba0edba10f2f6d84141b490d6e3930604514fac5f4d078c8ffa269f158cec374e43d678b8a25125147281f6c06a07ad5da04ce53ae9b503c313d738caf063d4f47685c446c63f5b44d57bb65bbb060e8ad6e2d2c9e10d44da26c8ec83b7fbf6682826d8f6eed73e4540ee93993bc6c07b5206b5903d850b1d9bad393b41f80163c44a152c2d2b4cbfd5e266ab324c27435d5fca4619082db57827dff960441532d61d108d0763d1ce18cc4065880474526b1cd594da19ea29217ea59493f4be435a075ec21b7b418c6f35ff5ea5a6a2878f70fc1760002e16c47aff0f35e9fa0bffd9ce443fa8a79724bb514ddcf2ee7478fd6646c40e0e9e8be0f5b50f97316108e52d9e4cbb97b0f4048f781b4bea672d9cb8f48c3e8e1dec5ae0d57ca0c24209d01cdcb7db7da6179fec9e30d32aec1e1726c08ebc9b289bb7af27997241234423045326587b46b8b899b13ee6c4f585c25e1d395ed9adcd9b17a19f7163ec2e8a6f5fa211b31f227617177c63c1e33df42d512245585445caf93ce084d73dc5ef3bc1531aa0bcc71f8f41f8ff151aabf797e76c77601f3c9f19599c87bdc155cfdf494f4a08c6bd4a0ea1a9272fb70519f028ef6379b33ef7577ea0308d94232ce09c86c9e0d083f3d1464d3eb0782cdec459d24f91f274481f8b64834aeac370268c31c9263121251f918bf787097a4ea700f9d463b387dbe7a37698d74564dea47d629dd6ac33b86cddd70d93f003e6745e95c2266af5285a37a50ea10c4717938fc573ea05a965eaf4899fecb979e549e0bde3740b4c48d0a45d85a2b2278b16b39b2995f0e3e75a27b0c3199702cc7683d21777cfaa699adf714efba1ce3d0a66a7db6185db039a853086cdae07a4c3bcc46006d7e4b954d091625c47709eaedc7ee4b7fd004803c02e53e58098dab28326f4cc41e6a6172216e4133618971be203850a83c9c13942659578ab29db05f032b43c6edbf364e6515243c0b188d4ea87430cd13f9f70d7a79b9b19196e5ca53b613c88d10c196a65ea2991bf614fbe444cf8e1acf2eba664ae5759cf28b219535179ed4ae5f66acc2783401082a4a5c2255638639bd292e95438f332097cee7b3ec0b5b0815637079d23ad8dd2baed7d899ff37015349a2f30cca2db6a75fabd91a3b49b5a9a964be5ddf95168ed1ceed48da4adb32af48e76eb4c08715b668aaa0e0f36359e24240a7e6c240c710531ce76cc91475d6ed14834932da74886bc4cf8ec2361109a48a8498f084f778a6cd6d93ad44ab6b651082912e56c05eb8cf25f8df0eb088ded6514d056ccfc7c861236248e037c4476e9c7a14eec9fda06669c39a296ac12053f0520d6b434c3b838babb4952c4dc4a9e70c6d260ef7738155e79d5a41564d0b39b83806793229341a9e03fd93885c59443c21da9903d3b3cbc7533ec1f55f8bb3e0180c9f7abc8f18065d28b2def2fb0883ad7144a2ebe5a15f6c338ddfba11a36971c8d849d125eeae0bdee3d91821b365add9d0b6413b60303c26675cc3b4e060acf450a81a580f9092cba872d6ff8061f601067f085242e4ca20e0e1b608985110aaa913a2330ab0323e8bc8f23b99afb59db3e467321a4d0869850e6a7dee1d18ebc4c74a23578fca1df78fa30cf0d66396c6b25ce334db6b892d00d0df74a9f7f044c0fe39aed320ef8d12ef380f5f4e3843e33976b65d02ec6d97ab2448605ceb17cf87d4b35aa52ea9276b512997c47ad6a1dec9e6c275737635d3ca0c47d9c76882980c5653f7ef74f0f661cb2398478acdc37ecc7ded04c609381453db7aca1fad56694dedaae0f5774d4a6b0c3bb4de5043edf04e9f3a4c4d856d99d90922a337ffe7c2de207ca4c010be0cc8564c4ca53fee46455c95ed7e2c66f648810328324cc2a02e5f3216921d3e4fd4fd31a95a9848b668aaa758a9cb475cdd728a25921f1920c07f5ed2393bd0bbcf2aae6e6267a2f7d8d220dc7d73c6f46f0760678261a77db73cef7981be55fafa8491ce1888ced126e8d7e3bf72b7a1d65267f81d64b2ffee685fa105fbf4e23d82ace15392578f29ad5c7bb872f26cd361af8b0d58a03f3a2b91830164248d9a1e6efff4ef2208566b58e1502f82121b031fd9d97edd3a59a39e48cb2bf755fc1e61ba255aac4bd10b5150f1f049de083b45c6a221019e40397945ad124415651f2fbaffbe7f5f7fab94c07768b7f91c8743a6dbcb533d1250e01bf1243a4000bde9d10d9fc59c8042c2d0fca12f6412b9cd9231415ccc2a37f3f73d8ba5f3aec280925c573ef690e14dafaf76c79e71ffce76104f06a1171bb69ae50b0582187fcebd0198c9ba02327b293a096991066f15cb33edb7f20ead09cacbbbcee122d3bbebc2b9451680ab77bbb09e854bad02f9b39cfa19b5be0506ae131e0b175b4540c831628b681f8c578b87345c4d0754cc25c4b4adb5502760a09d054ff3c1e89a921badebc277ed6c705df0289edf48f564e066efd94e08059b9227c5b5bf072eaea118e4d5a2c4c62c87dc8c419829c5744a2109ccc74111153e01abb824bdf604d82a2c03b8f234c67eb000d65904069cc08dd8cf322d34b1cf49511b5182b5da5960a3d8467504385ce10587527f59eb0c790c895b962cbfd3d9c3a1856b6eaa04fc0cbc8d083bf383a3036ba6ae94ae4a189326f1a06641fa20865006191646087aad0e64e229fa4748769d8bb23eff6292dea7b392ea08290559b2731e13319da34ef0fc723b5122763aa940f5e69d8f87ba671444153029443a59bd3362ec9e67690f875e99d72625968239f221bcf957fd7e99ae20b9cb40cb35483162cac60080c8f3f10c4ede7e5c5dc646f13eb7ed79d8aa70272bc1b79ba279fbd2b3924174e260132b7fc8a54d6cdd701eaeb4ffd68914790f7f22f43ca34a3ad4d4285776d512e9cc33563664556c3a88af68dfb7a5dd6c1ca6f854f594a43d661b3a3dbfc81568bc0f11f4bc1614bcbc11201e1618ee8a8739849306cb110f13ba1784fcf803dcadeb9cda678def15cf2793df266ffbf934b8640ce839241d608524871b41159c0397fea9c57b782fac24df2f89b694cfd79d23a3313d9619ec3742b59e4d39bade76559c283d256af17bcc8389b7e90c1b23894cc47f445d96ad6e2c2016dddf42795d6c34f04b4c03a0e3040e54374e73728a94ee3f195d4dc52e92da25cc5ea3e64982c00a0750f6eab0b2c8ba58c0a30f12eef62be89abd1f37fd83d934d8e6507d0d1aa0aafb1d38302783c4fe68d5c9fd00477b5e7a87fa33f9968a35e614ea9f74a349087e116043d5eb0cc7a14f4cff427bb03f9ec7124cdb1e16ee4d58a45eb3d1c8670a9b766d4b8def483005769910bc1381496067b0bed9bd9dbf04252744dcca331d8aecda7a63647e4cd8747bc7bdbb53a5a7d867d3a0f3de98ce76abd796c31f53c246ed3b862925843bdd07566b0c7ac3137730e7e165941d634907601070a539ba5b7605bff6252475861d3161bcd92b63225ac43262e8099fa9f78b01245af7aab1e7f9cdcd212ff0d8dd4e58a447f12722e7b4ec9b88211909219fbf871262d23953915bb82918897c93d078da4579655deadac82989e50d20f68f7641ca041c7d37d8f7c51c7e14ca78096d3f400a2ae82c652d5f0cba012a33ac8723ea949508b3d6b80e7973373e7495e0c950d240f120632ca5c68bd35901274d767a9bc321f39773795a3d6524e823fdc58943e4e5e5917938607e33a3e51e82d2e54512e6ac1a9395bea4d48c0e1abd4f169556851dc4d5d2276cc05fdfea08d93d99dcae86df973538c39a84e8ff4606ff663b0606f114cb3ba4181446f7cbe2b6a8a025851d71d30a25a774a70243b55157b922a7746289086233a7a6395e8d794f04824a2c9f0c6b2ab4b7f030ba3e13ccc53b8611f04937bbb5a11636df39453c3781e045df3dddf3a8237efa13c0da00efab918d1e7fcbd3d6095199c2c06e252c844fcea7c24983652b177aae3eef431db949a2447dd8c76f965f512059124d6da9dc74cfe1e384dd551fd7e1f43bcb6ad3b53b7e9d195da4921e9ee2094e9deff9c37246deff77ee1b99e4255ab90c4c97f6d841da04beda92d9a9e1c4209e322d834eae2ab2e632136f916e853083249eaa07db99a3b742b053ff68c85e78c3338853c901156505a2a03d18e3cf9b034ac07acc3f85ec263d8570c3abe648a9f47a4f94aba4e3dfcc5299c6e86576d6566ea8ea90f2889816a961fe6ea2468c821c81aa139cff1939e068a8e1bff64e08704a3ed550ab15603920cb118bb311c9110d1f2923849c300421e93168946aa5ac6048293a18a9e393289378e940c4681540010d8cb5ecebb76b4853c797cf32f935c22b7aace2ad66e458f1ae3c8a36916d92049269da106700ba7fd62ac52c92c6d3a6ccca8dac8d30bc4ebb57df65b6e3f616aaf171cadcb49a7f76edea66499768b7f3556e86215c7720dcc683da8a2a624cd2a2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
