<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"218d0188230db0b41f2599b575b0dc9de2f50393a28cba0d4b951bd9ddb84d63285b75dbd526c794ee5fd4cb2ebb836790cf1555ad74481d5237094961b2eb7e289e6988993199e8eb8530fb5bb36bbb8b40cabae3a5466e8968ac4935446b9bdd896fec42b030edc7df16aa696d77ac7ba8434b2305cbd87360665022a2c6bcd54640f62352f3ad664ad3c8173dfbe969a627c9e76ae0c4cbe17cbf85e1a5480d76b079275e46e44b7626a771ebf8d6971598969e734bfb893cfb32ff8f02597d3b6de7a3c57562bbb3ad45c4763c572325a34e8f2ac73b18e2c8db66b256c32c5a780949ad03c531e863306158b8fd23b55f26c34ee8f1cdba646eada0a29d47d1c75f82a5f1b4c3c75c712d81e23a2588d0bae704b7180f52950c18bc61e971bad7b85b7f75048e79a30c032cd4cf4daaaaa2c3659929dcff57055d05f0c6ef2d446c46de7efa931b8969c729320c3c9dbcaf3fc293f54c4e9cccc86cc1f693677cc37d166a04c31f6beb2e3aff846cbf9c1bc425272afc517a1e3a61d15dcb08e87bd7edb98799f9d0420cbea6615f92aaa2401dd7dc0c9b68faf287678bef918036e687de42fc5f8e33bb3287a00dfb7b7bb4d75de0e88e281bcd0f3f28bd6100c8f55c5da2ea1496c72636bd74f08cbb6f21c5a5b267f3f083e1c7c9f6f2825a4a355076f49cb4e39394d8f7831617608a5e47b5fad3e26f00fb89ac05b62f66573cc1964743275309503ab94bf28f7e848078dcb9344aa58b6107ac2feba1e930b54224a5f693f644d1fcfac78be2601b49bf4b211cd23baabb98f65892b1ac57b77046d542d0ef6ad8188bbc35196feb94c02bb1659651be588201ed915627d316bbe4e858e25fae15cc9fd5c6980b9c225e464f6bad47c724a660232c320e5f17cc46c8dda0215d2f2ade59c879e82c38a2df7adfc3c838e03d3645dded214af29e0a5af7abb3f5940f965c263f24eba0fa952686b353e8a0af9bd064f5c301bd6d0cdb6481af1eefe89d8f187ecba758357bf2b57a725aeaab7b7ebca1a21ae5870165f24b2f92afe25d51ebced698a0c3aac916194292b7e72b6ea7f9bd49873cd4918ed6cd3fa3b5e222fff38805edb7958f28260e3c373a3a21e598e86a990674e524e82c39d534c0823dea06e483a54e574a66ee0ceafef511d26f8e270602917d5ac709a400518756c0586c1bc0d0ce35ea6aedebbf6c3f9eaaa66ca7c9c3e97510b605ce3fba8a048a8bc55a8f8188afa94cf40ee847ad4d2cba81e8a0dc250ac05128c25b6f719ae39c0d9062aad8e37f0a451c5f25a4ebc1395215cf6917eb20c8cab57ff39fe9560880eb096dcad6a5e1f2b11b997df9c429ed15c2c0fb2a37e1850c3641bc826d0303a600dc382a851278529c3a0d1c1538fe73a3aaa337b8138439d3f62817246151ce83c2b56c2b395ece7fe0a14b7298acff348af842d11e43634d20c48381badc525d90de361b45d6961e176cdeca941dd97fca5780a8a4263fec3ee8d399151e894d4db1ab2eda5e0076e19844ebe2eef18565fcb4563b878411b4f0db781ef6bff3ea272928ca8ccbee0594f57f09d9933ad2336c3e10cd37fa52dd828aecba1d434c44a679b2589411d4e6f9fbf8d9a4857cce0887f2c29ecfc91e979b4b55a12aa63caca0acfd4805c4a50ae15c0cc8868d4443b1fcc2ef86c18fcaa6ae9781a867d84dae39f1e48b845b85a8b356104fedb48fe208ece7f9a4a85aeee88bee8be7b266cacfcd0b49c1f78e9f8cbc7e81041f34fbeb9b0a42a6fa63c824034ffc2069682de121f7b7bf1b00734a480ba5a9498292df400fe158bbcfa75999b76f7acc707ac840dd9596a1584af8d7633e97085d34dcd3d28daf76cedeace5ef46395fa97ae6104370ff02c82433e8c338b24dc8b62e9ff02847417b191d70d0bf2f682ceb88caa9524704594b831a8be8eff410baf29b308f963c12db8b7d23abcec192294b2a47166a3aa5acb10ef03f3357339d95785b36891bfd3ca49927abf06c9da1ac66350d7217aedeaa1456d09f2e29b99c3fb47f251e413f2abdab404d8947bc5739290ab1548e03995894551da9c1d08803121d3335fb9e3b919d6894594cf1f9c7a5d358ae3626b518bdf04b1d0c605c77a0b7a0fe50d888cb7444c4b792cfa88c0c67e73c270474288501a50f2b59308f8909c2a1512caad58698259782b3487118e7ab539d972f80beb312cedb19533f53e5745b5f9c2f210fe28f20711139819a46d44d78d1bd57cf76946ceb24e535cb8935cd6b7a2e080faf010fc9d3cb145bc3aeed17bd946a8c45913754bf77ca7a4a1920be1fb629e85467c15da3940eb9cc2a8fb574c9230a9b63f0f8937fbe9e0167657d8cbd58e3dc7f5aaf2583eb04066c8655e7e9c5d062d39105b777563a6dce626fda8b5a14c473a3663c58fda610d827bca914252beaecd66f57cb5cf057a7322ea8d10452bac9991b931a8868a703f0cf1748f4c8290921b06f221a133de0dcfab32da8f8c168585dfd4ceb132440e9d9b1b29125cd0e1c8d74f04d9022090755a0a935ba5cc7d51734ed42d8193d9baade0aaf1b80c412c4e7c74cc9cec12f7ddde7d8b49971f3161f6305cb8378f7e35e328d93138c7c608284ed19f567ad30bfe0061a9f58f9249faf789374b86890caf0eb6cfa30fff830d1e07e7bd128bcde728b561f97752a6469c2b780bb2813a9956787d48e95ed51344a337ff8e872965fcdcc1cdce3f6cb1579bcc450b0d97db9bc4cb2beafaf412086554dbc31abacf95cd50bb75718f1b8a41ea1d76b32a67780e172fdb89595eeee01deefb8c5ba2fd2755118d41aa8418922003476c0cd97e4619486775c934078cbcc54e553c39e4a7639fbfb5abea02c58d5c9d3ecec6d917731de1c7e1601d8e9a81bff58515d880cbfd79c72b16d40a9f006ea292d134f345a594a4359337264887882ecab55e3f23a933930236708538a54275775a641d40cc41d4d04815664b48418d2d0640c83e2ffc4fbc567fd9e2329d7afe7d7c874802a029efe4a2085bcd081dfe6b0ad330545849a22b0b368257c957711eceb7d1054f667944331a76765706adac7dc282f5f2142391ae7275e183b0ba40344149c6bc275cca6212635b4996f54e46ec2384d7227a522069ad7af124c98912ca800bd4f2382b816167bc0d9a6ffd98bbc1e9e9091b6d7432b774683017270472a49a12150207dfd35cf1aef4fd9d9de83f6cb01fe6b8848bc79e12c7eec738f66f95199b95376367b9c20e0bb2747303c31ea783dc61115323fc902a0b48d23ab907013cfb3ee840039422b772806ba1cfcbb23595d6c47fb1a9c4d0b3ce81984edab59b33953566e59e3a874a51df287c08086097ac4790ad027bebbfd506ec6dcf949f39a9896872aa7967abcdc4eccc454d6f67f5d37b6230f3303f8cf31154416deaddc8fbabe22695ec18e8a9a4eedc735d43251152cbcc6722de5079078f91dc837bfc8ec7699e67c0c1636cca7a1b4da6c46ad69108697e464a422838777b5ba27a4a51e66de1e762618965515d1f47cc5971b88b4c3a5c083114c7ff66b07befb191014696c6487fb74647592a3853c686bd2ab47ea967fad7b5a2da8702e3e50bc29fc3959c316568cd8260031575a2dbcc2e9070367bc2c30c885263337c22f447c3e82897de05f8116b28d129287b7641856c77300373415832e04212ff37d2b71431bb4d2ade97a83426dabe64a4fab5f917f13fbb9aabc2fa49626818e3537013f2a32ba9b1becbe26ca0526a2b6c45e51e43f003391ae8188c0eb155ef30b3887c9a8d56b4c9c18c8dd357750dff6c343516cfb4eb6bd0b0e3ded78b64707e62c280fa7c54d7d4dfb91ee537a02ea8a6d55dd676889d1b7da03e2596481440006d0fae6fd925cc44132f130d89338d87f0084cf61408956eb008617bcdc34735a1cc59d7b99103c9a9fb44a8eea4d9628021e7e6660cc10424c4f5eb7f927b21f2cc55d6ca87e8572075f83683ee7cada98e89dcb1fcfb80e83bb1459cfafbaabd0b391107082147051e8a59b9e20a65d312d97d5aeb976c02d29d395e7cf7ef0112952483be3d49787da49282d308677c5f0b250bdbbbb304d78bb315e828508ae6d7bb28bdaa89a4fea138a78be374fb59e8c0788568ca8b039d38f022aca0e54af1bfb74fb769b25fd9fba91ddb3f6d743bfb23b5ae2798cc272996a5147e3283c90bf26756b3bd35aab554ae0e1f728012e0f757fda462b65c0314ab3d59ae8b0ce345b84204985a006572dc1a0f070c17b98cde27661c981fa4c2f9c3b7c0c7fb90f7803605873aa92d8c0a0474690afdb2b391fc66fe946a2f1d93a75c1615ffb06145ec05c64ff95339b1d0a8608f181efb050427487d18bc98eafbcaf75abda0a29a4d8d68a818daf3424a498e45b375b430702ff6a9ddb80fae214d3236c7cee57302f8c92f8d72b0d31f8ec602f23bfd82f238c5063c00fba09b8c304b107c645019e0894fd9cfcaf602f646158765978af1ec4a506fae555e7fee3c5eb074e8a3efe406c1e64cf4f3d57926a1a20465f46d5a0030472bf9c9331081c50325b7205a3aa43120a01b406c0c4dc9857276d712bf4da54238bfbf9e03d4ae54193c4a68c671b610c6b4598a7f01dfd43acaa64506fb17f7f7a795e5c2e8ae866abca202c53b283488da89c183a85d8baa429a0188481fdbc85bebadee1b6efbac297027a5685b92cfef36eb7106fcf49030e9dab10db09b307c873929e5f68d655c912a324d24f58ab2b91df775d58985acbfcfc0204cf2f0aaf8ac5b62a2a464e44b6b11284faf5098a8df8f630fc00e7c87eeae522a86fc2eaa8218568875a0769343214f9913d79a4e79245493bfc3fa69b8132d81f81995810df2b21afd3928974184f347c463b857587bf27be9b9ad0e8885b78a9f9124364efa503297e61a7475eaef9c87e24a3b62c32414404e532a23ebba2484a421e9763f236cdc08ef4dcc1ade7c561f432130e25539f443dbcda8d4cb5431f813d761f2a7c53b865cbc393db5f8dfed21285114330a4b744032437cd285d4b279fd1330360d7c7d42bdc6237f2a04be9734f0adcef6e8eee79a3aeb90fda26683ee9e29ae012fb539ae7a8effc676d027ad31f4226aa5f97233e113396042e0be781452ee9a9b69dc35819ceee3b31eb64a671cf893eb92224b6bac150ec08a5f71138c4e2a177adca4f8d7bcaf27d4722f5bd8aa043c49a42e70056ef5c08720ba9a3d52219990615154281ff777fdb4b850a7ca4dd30e568311747bb6919aa65f660ae42dc257c58feebf5e6e99b8443a58020cd99d8024b20a168dc542fcf076e4f5f4893fc647a7f5d0d6fc9d4596411ae89b7de637eea0c99e1bbf6c3bc4cc9e1bd65b7e2bc711d6b4b92f87c6c8e93bb4cc5fc8de270f65cabcf388e4e6fa4d4661d8b6cbbee6752286cfe992dbc5949d76c6377581be1f7b89b7069f8ac991078c785b3c56fc1c7c2d0f8fa3c59c1cf0f4ce17781e8d737a8f5a598c654695fcaa9eec5da515b5b6c148804767b0d77d08b4ea6f311d47bcad45f37d0cac506c1c54bfb4dba7f981fd1865fb4ec18952ddcb656bb3cf5a6f2b7aabcdde31a3480a0604d9fda030feba8836fa901289632c9c5939906a3b5aea36b94ed9df24030294a8c8217370e402cb3597bcaeea0d63ce629afb5f8e52dce4a6e4057b359910fb1e4763b3fc9a666bdf49de0f626c85c1b6aae2504376d8917f159e5968ca56ed53a228dfd4f196e5987b057db2bc0c6ab019a636220796daf2a144ce13c405856dbc8db86ec178a27f5b7ee5c6e4c04d8cefaa7eb64aa7cdeeffddcb8c75fcb3335cbedc7f28dc7c2ca128d5424faf75b6a0114ebe5c7bea539dd4c8c07a2c191ff1ca7a5529850f03cc0f947cec3b1e7c590af1566b1f9eae06896c5eef4fcd4bfde4fd5fe25c853d3dbbe50cdf8b2c52485f55be7dd8b025ac3870aca295cb2c0b67f71e4d1f7f71b5215918f8f212d542937f404cb6e32ea4669beb3324faa7026adecaa869e2245ebe77236e194a43d98b6b6fe9679197477f49107734acc4179890925ebed0c790b8c3354619cb3321f7b0dbbc2ad05e7e1b431416acd1a290fa69136f5d64613a073bc1c5f9bbb00c6de94d43c0001448c3e36d17216f75366dd8a26c8d48d76d98dd77bb800903d059e59e47bc263e541ea4977830d43792591a51f99b4ac9f3e5bdfb07ed215977ed5c7fa433a64b3c65b5b5d6ad7e223ddae7e212dcc52883723d1a4ee008737fa75221323053bcaf325b9b229af4615cac962f0819f465738a6593e904fd5e95893916fc301dfc1038d10a8e62a65fe07f7931a0e156d3ad56671122c47b6fd9edd1201c7c1b3d426bd32ca5b8855798a2cef4ac8790c8ec534a59f1cda1b7fe94682ff320eb36e9ea6e0651611b02e2ab153bc69a585871c05f1b97671627763399f769fe2d49c628844df42703234e5428b22641d42c89430965c25ba7887354e29feb489b4134cff8983500c3323e3762ed8f826ca2c5a2abc54fa6b81260293d4278a694bc37317a26fba1ccb03c9870a501d21643bbe15a2c9c16f61e61154ba1c55bea99c8b697979227caeb5b9976a37a54e28b63b158a99e8ac7903a49aa8c80aba96fb7b2aeebe2536dcdf8ab4a05b16ca0aa27077acb93fc50447a643129c35ee9a0bf3bc595c5645a3c23fbb2ba55a599f0c12096b7c7b4fb065995ef8c819c724a575f7547a75c96ec0f1bc5967983f168c3679399b2bb7d1095838abfb1881adbc841a6650c49cf979e9d9ced7f2ceb773393d84903b80199c230668e898372d1c1db2e4f7a18ccf73c08b50a36bcea7ee784edf4eaccfd1526d059cfdebccb68a6e609e4ac19c8427e5eb657bcb3c77c4e28c179f41df2a5fb28a428956d45bb7502808f5d448acd2ea160a4d937eae97729355485f56a029c27327707bcbf39a650a52cab0f3e5ac34873a15d6319f2cd8c54417462dabb29faf4745bb56fd779dd52393f6770c4190ccdfb2b67958a522c259749d9bcbfa996f5e07ff2d3e24cfaea3cc11d7657a87ffcf3ecb2d0dd71472f6b8f4524c5a764f1cbfb763a49bb290fb855f3a395a2290063461d6dc6f517191970ab6f1a7f7c384a28121bd7fafe5f1cede91e79b9eea51ffcfab45127d27bd282cf117c454b892fbc30d6a3b418bd3a5c291298bf23f74b6e536f6e17c4f802ac90e26f98db8676a98fe83ea590f3d41cdfc3f9b7b1480802e0f41c3e9938507af7c773f1aa3e2e999d324c3a7a4c9454457b7a3cf893da925d449e6ecf77095604d4d8251697bac5d37a56cc217f452d27c0dc7c4ce526d23ecefd4c9b2962cf695d32fcccb0ea30facb6e849626debb5fc7e628d8eecb6ddec7202ba45bc5e4ab804ee889fe20fc4a2cf44866c8c3fc68115161a6f7611293004b89c6c7ba4a6096d978d0f7d69e8ad20609bb4cdc638999a7474fb1c24723bcf554ef65787b46836498591f8320ebe159a041c5981bded9b86d2194bd4120138c4e5da2f7b3e1ce9dc30e4b7f78299b0a68e395e8b6170211eccd54eb01a4e283c262c01760b78d3f1a66102966291213111ff493359ddf6103d8c636aaba626acb096b7704e0c125ab2a1a37269e15858e6525e52e83f94998becacd29dd37fd19114e871be61c3450010908f6702fda28dbbb56c3a6ea408ec4b7782101c0a3ec2035acb88787348e1edfce0cf1e789c21569ba231ad7f93be4d964b76a6dd150420fc15c8ef939e082cc521b2abb50dc25d72f2c31d2fbf3d175ff71bc11c9b07ccec10a11923f44ee4cc12fc5bc9c2ff9a1a1dfd5e67ea47bbcb2a6321591e69e04ce416b0fa29895e38e7e7e8aa295ac64179d017026f7c94ba0e4e7a38023d5de9bbaf50cc9a155211dc48de07c71c9a27c70096f471175eff6635b723146cb7bc29ad0e38c4ab8e560373c21c51493cb791ad8d1db5fc688fefcd9d22edd02bee7a91147ad5f461d4bbcd5683a3868241cd36a553a10ddd1777248419fc1aa1d774e8606e397970b7c84d74aa095ea5983e3d10bf1f6dda0025ff90aa4399e72b3a669dc6fc341ef25b69da5842eb04d9792e521875f3e7cccdb34bc282e90cd4901336ba92974c4824fb27ed738b62a3e87bb803521b9bd4163c09e55ade82c90a5443be964c55e3ae4123b479a5bece9c8672757d3dbd217d6f5643c0615ee5655acb11aac8bd9ff7a894d766d8a3844b7b1774fb2c978b4fd90db23132f74e21a3abe1ca192d7eabb01f4470e1a83e67d7f49bdae734f6d72401e789011d8c8d2f9384dc629232f266bef851b07259d999e96a326631c6b2288656d1f1ab26e10863b49243e2c8007e9132f083ce2a683825489802c7a48f079c718b2c0a03a46d866e7ba0a0bec3033cb07b61a67a6e19402839c572d2f4586cc8b4a6fc52dc12e8927e0a9dd146b784324f455924a6d7a25d969c2b2f3a761d11e4b359cac9a2d025c3f416dddde4bfdd464a44a995f15c94c4ea68cb6c9c7f3cbbe69417cb9923f52dc4c6574222519858b0bf1f46b36f9228f4288194e44e515126c0d8f09a2942e57880b9bced69ec5938729dd1a8ab3d712e308219dd27b28c46df0f4ba7fd4d9c8c4d36a2c93842f78a64158b58867b43ea9ed25b3ced6e191b5f7bfdffd7eaa6f8fd9404adc40c81e2e0ad2d17d7286769491eae20fe2debe0d7b15d160803317d7b9c74392b111c03d7f3ced942717f9570f46c4ec17698abab7184715699e0b35a198a8decd225781b9bf490fd838d7de20a513ad288f5715def1a7aaeb59ad3a88c67151ad27e4fcf67896653ae66ef383883510a68c68ea6922fd7b377bd83d709b3da0e97c027ba8cce9ed9ac8200d8e1be6982213b52bbc4fef21396199c69d438e882dcbdceb596cc1874ac491c521bb28a2d4fbdfd97103c0b5deb57b9d46b88deb3dbc08bc8f64756344495b4f6e26246d345efe8df560c92648ed4884eaaa529c840f4c46a1cb25ec8e3b215e2b2494c51d1d2eddcd715de93ff4421cbc8c54337284a721a67960a61b920480763119d76c0ce16b8e45c35ecbe445d50dd2ec5a3ee6996a8996379061e9cef02107ed502162112177b3648a9b4bd1e8499ee81f0d7973c28d66102f7a63d63b6a92745a30e1da24db70c5fe741dfb29c4d2c8f9708350b434a0586cf31a4ba11d8dcb3855281401adcd82d0d08cf6d2dac40d6090983b9f1ba843c1831c4d83208dc0f1dd8c734f2ede40098f26ab1867c35e049eadb8647113d7dfb7d3e83403891cdf82b6b6fcebb26a6223e59132567007c2b8b15cc97698d2110e2626a498a4cc2d491585be181f20bc1525357cd90a1c39c34c155f545124eb46448329a5f22ac2b61d557b7bce113077c87380eb93cfaf31f984be2386dbba2ac673e0a95cceced7efec3a58af9ea321ba889b7fc3763e479e0d7f9dfca80346e22194bbf16a7e8d0731f226e20fde2129f33ebcaf945762f3d4b7c24507f43f32d0f265f30fef0898c661a9c36baacaa62878799650896804d88757559ccd85a588fa463f76e13c8782f2dc0ad104a09f17f89de7ede53b46c0150539911e1ba6a4d41a04f13a9d09dda295a6f37a65cddc9cbd347eaab485df8129c0ddb24569e1b6ff0bddc3cc2d89ab78f63ad7f2ee976a9e632d9bcdd2e561c8f950f44c01d7c27eba6bd193474f5ab19ef4ae40bbad4133b3b5386a14a9822d0ef3dd70cf5e0165ec864d513a6a9436d766b64dee29d400cd0e09640054b2821f5dcf52d0a9e74b7ff3fa34118e1b984d8da862bd36d808f4300e0efeb15acdc233a427f9abb668c5491b0168493a2b6ed423692f60109f8344cf79e795216b720161a071ed787a7bf173f5ef3bd7c433626cf27853899cea6a9234c19bdfed2c38f8281cf5515a1e68db835e31610c946799c667e2219f3187f243237af790e7b40a17964709ce18b3e36e353296b352e237f4a03cd8ee1b5d5ada27c99c090714990907b5978d6452600f1b59eb3d569db189a1f87382aed1059985a9d55e49fe2ea5aa9d56e379313352b9df9ee64dbb79bc45caaa0394ce10189f072eed6885da6252e13ca1bbaa66b07f0f98c8450bb475a1f5b8a0f3d8eb4e62e553d5f7ff12b4dd306811d294e328e4822da2e8e18b1670af0c854f8afb496c80f9c35037967fed1c1c1e79c32616737cdd9afae8d93c608d8a3f1c256353463555cc01363d15e1c1268c4b217646752e393a9fd1213e038594edf6b0a5ca206630674b27f1aef115a8e0d93c03687e850e1e0fc1a81f85e09e5e6bed4b76789289eeda7355414a02cd8e44910b036fd1919a1111da9a0ba6ed3cbf17c482e2bc7bd1a53bab7aecc9890454fc33cf9923714198dc5bbb285f14c78929a18bdbff75925ff7036a5ab27f59fcab319e6d105ef567854c258bce905e2ff70cf24ad98a210395684dc755e7e0679ab6213bfcc384123e4ee742362a6a5bb361f4a8b68c99e4658727955a84c2fec4a8e5e85310b8400e00c146eb04ef673fa01f2edbaa76254c5c514e85addafa58524870939da72d84dec4369c9792e43dab6207fe19a1f974420231bd7934f1da3483a14b1da3b21b6ae2220842aa65f067a122fb7f0f6f2197b544b36cbfe2955b29633b391307ddc6ca5087fb9242542ffc3b6f0af135544b240dbdeca50a39c08074e1647db41f0577fe0ca66aa4c53bdcbfa1e4a85158a971103e6b110df1af6d44159b9dc591413d994e9851f13c1f2f78e2b64097a6ac34e1c8e894b23b689a0c5f33b9564ced792858bd10de2a4bb2bb7e220e2221c52c216a8e66d3da88f0a964c4486ebd18e4d01bc10cbd7c348a408a91876d199fdabe97561f6f5cfa63086e445010b30e17c586d2776e50561db2902c3ca200141bdde2c4a6ea4cc5514fdb8a9fffbc8f8671e4fe69a34a8d47703eaf67ec9bbcdfc6232dbcd4c7d9df79392b6cc96ca64ab677167438b072fd38d6778c62211f10f77e1953a54c246397916b9958479be4f5e2426a36bf7010022740d33c9d5b8cde7dc4c26a81079ad4602f3ae07fb81ed41ede3c6d960ebd815b5cc84578597fc7a3b7ba463901fab5294b6a037401032ad43bef908fc6cf17ac00ade0ce60eed7bab190c2705c44b5258df48abf021a4b6b79326aee9030a020fd33641c0634edaf122f3e7fc8585ab08a7c9f464163110074e1744188d5fc1f67ccea388cceed9412ca6553faac77263405435f96b048d964ade2945b912fee51013348d46e7cc58b97debf39ade2fd10c109681302add4c95560c7d37fef791dcf8dc227f5d6db37b9765f63f941c26d62ae53c8aeb4e1e6efda0673daa281977349fdcdd462f8211302231711ad68d00ddb00d44dffe1b9fad7560b50ffa77e670a97df1c2c462700daae061a014ed814b80669ed8d75f1a7d6b0762b6d6083d24b977cf3c530f677f1e3a3cb3c567e94974e028c75b67b9a2527492711ea1cffeed6b9a90710dda6dd7ac155402abd0c3b5e3c5078e5367434882207c9c12d174a8dfcbe7c8f8eb98151e73bc169f99abec6f4082769ec7aeee8dd99b8f7ece99cc77c800a8be71c2f0470ec318757ba29e60537c1fc8c1985e53e4505f279451c940f715c0415b4316bbb1e09562a80fc4500efdf3042e30f36f6254d62362da9618992aa6801bef100d43e4f541cbb761ff5891b299871aff67c7f7a55dc0b29561a821b75fef6ac8dc70c77442006800f185a4c1ee9eaa32c99490e564794735b479a46c4eae808451332cfc991c2cba935c9b2ededd4b512df1c7b42d19d9cec8db5c4ea9f2866964df1e29bcb9d2fdf65ee0d4f364c06eefee816a401ce969ec265e4c12e9b82938585cae9b1e07c8a3712e05869df629e0f2c85de0ff879eb6609f97a7f291a78ddba1641cc52b28dfac9b205e4c509771f13ad09d17ea285f091f1c2e1f234ae15eb97aca9aae18f4810ac99fbc36e798e3d56b0a439f6867d07cce5de11f59b7761584485bf8c91f4b767204b5dc12eec9f70cc18f28e2414f2322a58123ff57d9fb9a86d50c2109c41ace27aee3487653e68db4f7c9f40310df03361b19a5b09a1300655f8ad5d39286ab22d43ea7a613140733496302306ce0c779741947d40e882a43ba899bf7d0b85b0c396102d57083a014855524f23d9ca1a2d987f43fd65a99502a57fe5c4fd30586b59a6b86cd876812a0d4b293d5c438a83a0ce4c33f6eb6b5b2abee4f00fd82955a9b360465e9381befb180663d2fc702f97f1cf76298f997082e508824a117a66b5815361d5de371f514793c99aa31d50e5a7bbeb47eaadb99850c448477c51849f4731a182a06fba469e0b23cdf8cd8f4fafe045c29b1fee8961f84f64f6275a93982b18647a6df7928cd76405088d6bb024f4f4e846dfd82ac294004be5aa6e5800554d054e1ae1dad71d4a090fbfba2867a7dfedbe1e8dc5a15e04f3d708675ae57b637ec692874b682f84a8db897e71a803d693807337f6739dd540c045a042a366c2d2665f7bc2bf9bde93913f43464bbf9f675d2e90c93cccb971bdb1b672a1e28fb21bd04675865a5490b998db1b661544ef4879e57918d60299b3cb715e5803cde33922548b63d18adc68b729cdec3d742bf356dd97a816ae42b04d0c4792ed6d3418f2e4129a3e14d6f48d3cb400a74eb8ff5175fcaa695f1e2c588472f1956ca18183b44fb786c154490d20305a8400ebd6916c3addddf60b3a6b49269a70309600880fe354bd56571e9cfb3f41f4e6ae29e6c8967fbd5627fc59c40ab0ebacebd9486ac40b31204c1ce9654c617656b6f95f7013c2d85c555897c2140d4b6671e73ca8757df6501e0e77a133ef747128d4c036182666a65af86b81c6a6b138f59f15571dd1782672061b0e3ba3e4ce8e4553bcc902671129eaf56adcf31a69d6a1466e93a9bd6d474344866db0e9bf3ffb5a16671062967c41701609f16ecff3955c03cb399391cbbd12522de52a8c561743f72e7aac01352555a07a0ccbbcb6123343f75d9c220efd52db56835f584a2e3e33b5ae4ddc1fa08eaad0d1ecc441e95967fd17b15415e3480f71af2dda2543dade037f50777cbbaea20999ba7143fa93818bb82d4b35175bea87173a3556c9f14c548022c59f284e2b76c7e6cd147e07b73a0799106154de3baf43b19d651576012f71cc05bd295307c011bf7b44527e61cde37b5f66c8a23e2f881d31a831e9dba163b7018cb5f43639ef63b044de85f615df81cd5ca2341d33f242606c9a9e546aabfc580d9132ef741018ab03bbb6d801d07383e341bf3d96837a4aa5718494903c369350d65732fd052064c28e547a207fb82869e4304a194bb965dbff04ed522ef955d31922893f6be299df1aa6fb7ce5ba7fc8fb5ee12a54b65f48e2a30886895d303b1d6ab158be8db207d21da82ca695d19e386ecacaee570ea7eb2d9557b6fa1ef75cf6ecc449737c85662e2feb56e6890c08fed4d39be45439bceaddea55d7530acc0ab3801187d69a7f24f3c12286eeb34df3156342f85c0100eaae798be016af79b36cb97f26dbef31d44373e713cd97c7599cfd25a01fdf16006dfa7b714a48b6dacc13ec2cca640eef52222e837ab977ee92ad80c5e5b0dafb9fa488273ccf30768e018c249abebc175145d81afddc27b1b6919cca0a7099acdf0763fa7e327d05d5800a218ad1c35cd207208a18da280cf62e975728f21a7f4bb0985eda3a9be0b7bf96247972a53679e7213c009969e4acd9b716bc179c7aa2680bf28b0284756341b104dad2b1f2ad63b478cca1cc3db8591fdf2358f9db8af4bd2b290337fd7b88d92f4682895cbdd2fb9b26de73e881713b79e1cd45fcfb66d4752107514674b59ba97564e09230f0d075bcd6602336bc9c3f978c04223b57d889e455eb6fe3228804fa45fbdd8e74373bb28c79d92a7696dd48a7c2762663b15243bd9c0f5e27a29ccc103f839de03330eea31269482023853c0606b77d3af24ab09b3c21c4cc650eb636da8a9c2b2f3288cccd09670fb9a32cad0f62504bfb93a654e60faf8fd6fd7f1254731274186b8be8ccc7234d7a980e422f58f35487ad0501f15327f1d12babb7cf8ddca082479011ca15f2930a9a105830e635bebef5e4471ed9eea879529944ffaefc54959bb03f20c34c63829116d30705e38fd7fcaff6d134f80c3914484f16e6fba07d81de0e717a3ecf04fdefc3b9577076e4fca689874bb9cdf3fc40ab9809fddc7173d3be2cdaf3d4b16097245fbc1d98f8f9c617487623744fdc9c8ff6da6acb018d973a7e2f1d9043baf684aace2cb784caa3f3f434706772ee06e51e713ccb7b96b0d2b6f9cd7d02b5439bb04e1a8bb669cf8eb3e4608c57393fee7f324a4d105ee1938c060353aa3d6d1addf8411b3fea8e4735691b3c982152c203fe65f36d3941198aa0fd01ca6195584a9ed395ead56a4393e6e1ee5ae627e1a9b704cd2009198dcc6facbe2a4b675a976102b8aced40f52e1847f3f1f78a59f1f0eebd36778e6f2a5c942fbe48e5db254f24c02a2171a049a2fba313b1a5e8165726ec8eb16647802223990045d1fe7acc92de65c78357134f614b9127c097c64bc7bd0bfceef17259f387c9d009fb72b95e26b6fdd295cad8a3e4e9d92378a3bf727c6ae8328ec6bf34654bd5191009994e7db22681845313b661647cd99a9cba729b922e71e53953fd1ec763f80070f89f80af07c536fe5b375a1f26ce76bf56a3ea187841b7b00464f11e5e3638d3b14cba5c17750079afb3a3ac76f35a8650e811391b6f60963b595b1a829222ac4a1a511dabbab805e9c0dae02b43cb072d162d2078885bbfda4602cb85c3b65199c64d985c09f028b1ea6d272b5470525c6b90530abc36c68d4e410696c4e3b60dcd074435836e976f889d63cc4728df38d73cc4b85dabb6664e9298d3da3aa7a788815588da07259056df428d53114dbb768a3c70e06b3a7155f6114ab3cf6b8923463f400af27810c936666e4e5dcd0df209d44c3256fefbd6e11763c3557b53a3318320d7eca2bbf65fb6574772385a0d596de6013e6dd36b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
