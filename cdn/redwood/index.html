<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ce798d788ed19028bde02df79ac3efc95a8e462a85bba560d68a542b072596d3694812bf132885fe928498fc6bf05e986938f0a52cbc80fc8fc8034ac81fa750c8e9785cc765a8a3cfd1770398ec5bab0ea8782898da6f4cfb59e1da0a6f7a9c7af356cbf886fe43f2f1e0a30cf44f30be0284d7ab0ca886a9d8f238c0026f7c98223811a5a8b1ccdaa118a53991f5eb61f4ced0d7fdd64ac081490f4cb3a9e23be5d176858cc2da7392ef94758932c80329e4bce0ecec2c8d1e5362ab900b3f37347f6c356c759c7d33682ed07d0d99743c397493a3427363ae45bd4029a2920e8244110b42a2acfd93599c9886355133733f91a5ba861b454483f2f01ebf55f4384043dfe3c188100dd20dc86d8d5f60ae14001e40632b4758392a3a300e32954e3bb324aa8ea190dd3e2891edbdcd66623ad82fd61a4d1022f441d4e289eb8000754a719b1ba05ab10d4ea594fd29fe30f1328d108a91c220d1f74a2196aa3461fc66f6b673208dea667b0a199fb29052c16f93159eec75174dea1146b9d5bf77412713c84e44cf4b8aa0fc92c9e7ece944a2ff225af701d8d0835cdf434e8c39290c68e7247146b1b24d795cef6942d9e6dbc61057f0e655e03406214a7b101c7ddcfd671ca82f5fd0bc2cf3e2b2938799668e346324a94076a49c205fc99bc8cda24ba3893a47fca0b725a43dcabdbeaf913c477628e52c944ce8eb6132163a43508e1c4738d207abe55de86e123354bab3c5d57217e8102a05f1ca012f2719a2e0ca792ff2f41241424918ca619350102d85943c17d2250f3908ec40f54cca41b1d698a0b5bdb946ae764999b415ca7dc67924e3c014636d4acaed4827e2762a8ff7d61b74e09406814e57bc1d1b8822bbad2d1e6c6b9cafedf926c169c4cf82ba2dcf7ae9db5c4c00af088211c8ae74e8ed76723a704e11f02d9b03d8a1a46f7a75d841c6f7f44ed3954d28c7360a5bb50f1daefbdc9bb1e859c64e434e295abc4c95c17ef1bf3d8c2c80d42e2e1c08b21267ef30b320f30e7c4a01e9c5f6330810424d269697a2ebe439e1c338fbf48a072e3af192c4331d24f5d0b20a3736ca25c68f13b8d0859abe086c5e3c222fa550806f1930a7328adcfe8d03a677e0d60d1c2467bb3f5f5b97bf91c9331e176ef817b34b4485ae3a8fcc193c993d5333fa6abf4254b118936ac6623a97e86beeffdfdb3a278010e4886154403bd8e98ba70ad0b204754af715b4c28017381f146b9070d59c3175b8196f0a925844711d5f22903c6ad68a22082cfc679e0d4b5bbbe2701cf655d3882cec7dc0699c3df6508ed4e084fd9c1f319eeeaa97b8fbc3ef7eb100ad9a9ff7a28f5fbc1d223078988ea7917467d0b23941baba5af19157045d896b8ae66c98830a8e5a43093fab6e012d55ebb39a5c6801039cd8fc810dda7a645e2bffb58f87af923ff57435fc1f8774282ad3eaa66ab5a24a848aba478b100a5b65d6bb5b8c16d851fdf8dcbc3a011bf0a03f7a72838cbc184df49a65cc013e2f93bf1cb8333e524da227bd0bf1c369511eec421594c90b35a65fa39a1773667e2754976499b6982e9c28d45212ccbe082ab6ee6bee8522130afe958dcd276383736b86ca53496470093c37fa694782c71deb7754b14da88969fc7336a5889ccb119356f0abea493b099fffe569eb5c9b15619187e39066741c15709b44b3a66628eaafdfcea15d26762f61627870760741ba2c1f554e377b894b93057320ee588e8d55b247ba114a40c8e635a6dbfe85d5d4b57f64399a58c773d42d42f1abe496dba1d6e57417f4e97e0325edd6e6b3e5bea724e139e504ab92250dd604e577e516fb30b2af21d407438832002b608ac6bc9d9c834b0c6c4c8fda397dc173307c7038145c8997560f04f27ae3ce3f633ec5cfa0925390b568e80e4a8ec383229c00b7769c878650d6f1b49f513ffe004b01d691d795c3751370cb76d51c67d0cec023b188afba3ed7ed60a3c3a95eb578d1ed5c4dd4b5130421fcd083367c48e67c787b58a44d4d3f789b9a3c7b6581a356562852e1fbfb3ab254009a1d6d278ce2e062d6d92b19f14c94533649dd3c8361d96555216fe3afb9a779b3a2a3065a22b81feca065adbdfbb82bb8cdbc32f329612ba53b73166f0b6006b3919161a122705689217fade683e4b5ecb950ac4875bc53ead30b9ac3b48ef5079aad0c3a71637e4fe59240bba43eacf0fc0a877cc821aa25943751b54be1248776c4da605bacd143e48c400bb96cd0344b264f1b2c75116b3bde712039a1ea67a85aab0254be14c44f1fe746f7d73b8c2bcce7b6d8136209ccff7abf78b1b793eeb4554415908f67355dff788f46b82305a12d92c79d858cfa2b815a3ddb12c29c87d98db60a37856e9888cab4f3896bbaddbb1e765b819c27d3fe05bac64ad69c9e49a3765bae9d94917d5a158c29932c0465caa397b9fd7cac7430f4e636b52bbc42e0c042683be4513e5df8cbef742bd214aa320537ca7b4a1a466e190e85e816c4cb4a076f78195796d2ffae701d37d720ffb23e6854dcb90e54336b5eb0d9f455cbb6f45e9e2f4212bb60384abb8ccccfe42242316b098f2915f5e006fa240f3bf2436734695ada5a1bffd5ef22cf4e99c612e4fd36b0d63e67170aff189bd137a521b5489906fa60263f07c48a96c072dfd78a23f0aff737fe384b5b43baa1fbe1adbb9ba3fb9db4d02c1b6835720589adc0d4a8b6c2431d3ac010c90019b9cb448a955eff1c09e11a189fd7710a6b1a4818cce017d47d3d577911e5a131228732b406442928e9266400241e3bac3b8cbe11f1fcdb9d293223cb985a05ddb1cc23fb9c7c4b6709483bd2a8d782c054c09dfd3e1259fad78f7e24f8bdc4a645edc1f0b8f663473e1481dc73f1ba886352b3415513cf0a0df0a4c8eb53215923e70bab1b816d12380a553508d0bcec266d1544bfb7fc732c3d2100858afba6feca5e6f7c3f1c75fe6052d72b517fe9152e28f3fa1098196a4b8fb762cc5b624206eaa5c39f6a656c2760991f06c96c5ac2ee262be0da90f67fe1e159ce804bae246b82421200bb34285be9bd0d53110e44df303cb4b3a6b6addd0276c1e765e97fa4481f81f303bc7f7c1d11e0669da7ecf5d884d25d279e9b665cd936891f908484648cbfcaa34c3405e22ad62d2f360cbf32b8db214cfb04614a84053703035164773a05b24355a507643f2ea1ecf55c12d0bea01ebf32302c9578ae45e0fc8c624abf7c4bf3265010da05d5e240c2a20cf6eea90f3a2055a8dc1efa55992ae2aebdb9f9a78177f87b3112221ec91e72a544fd5766d51d5780c29574c8f7d9d161ea11ac7d7db91d0f7e35c87b925e279ddf42b80b1bfaef569a5929b626a9490167aa4248122583e62dc9207a10505b48d3c8f9a6ce48309b804a1b4ca5cf34dc6985309bdd7f3f09afa7a0ff43e2f2cedbaa0a31262ae267bfdf454d4c824422dafbf2481233113445c5d781124e83531c9187b5deea429a08aed5e96d51b85dc4efd3fe51ff7d6f86eae927fcd309d1e5aa25a175686a75b8e8b03cad7ce82277547abfc0d4ca3c5c01b7898421a17ca5875b698ee44debb2888d6e0973c58741e32ad1121fb7211114c1a7d407c93b366742f82d6943b9563754e8bcadcb40312e33c62cf0a7df4fb3e1b519cdbb11a001e40d2f83b1f2b9695ad07b4a48b384040362c7b78b6467cbea9214e93a3eec76189f46d66feab170f1459a130cf2771c68208d664abcf5375280e310af50f8bc1ca674b13284944c595f59a1cbe675138a02c93996fee2d0ed205d17507a42e9c4fae8ee4f9c1933a84c95a67a52791facaa8c9bcddea0a218885ffc325660b4052cb5339ee5e3f218c3b5bba402beb1374142dddce3f0a82284ba2258639d286bd03ccacdd8cf7d05f22b9cafd895038f369aafa2438e36b4af6780e4524a0437f0de7a8253bcb41a9aac8996e9df112e2e36484830f2c01f5f2a1f9395236e54c18599f4fc42818f0c823dfedf1914fa643220c1ccc36e6d588cd91062704ee5a81355553edad239b66ac288fdda321c0934fec81f33ec034a23f2f5cfd963cad3219785239fffd6d5d852fda513734a07c7814105b08941717ca07647fad98c1e158379feadfd9d790f762bd4f7b78373e8aaa942d3c1d721b3ad4e982ffa3a2872ea4e644c7053d5a7eebae64f80106d7f1b57ec3d0c5cb2055490b3b7da15a03d6cd81cba6830eec55190f246f84e92037360cd45aabe88846bdb8349f11289e0e9610904135cdc6d829fb0076dd33784a2496ae3deb42fb37d499866cb6c76562836d56243091face61c276f50ec3eafe0a6c7a9c62c681aa3c3b9039936abfe776eb812a5ead314a73a9409970ecf05972629bf727a75ca58cedf2d167dea81d397e6af145c8ad491047c0bcb956e22d2d1c36bd4d0ca3292bc07645988748bfdc1cc76aec792fb93fa2e19f97bc9a0b9c3c5cbc2193f813f743a5a663f072fca183ed325aebe2e26b2efb899981e82a224679aae022704849d9b6e13537a3389f330e4a5ab675f63d2ccc21b381ff92150a8b8eab9fdcbd4a68e9504704c447b34f0c8f3a0ec5f7d3301bf966e869f79e44d303babcfacb64889c60909f212b364ba8e15f8a62feb54db5c36fe7647f463ab8bc63b0e0ed209f6ba3f4bd3f047a984233dad25dbe7fc5fe598c8939de1e21f0bd5b7c515185f8c335a72850519b2d0797f981c699c02f0b3f5baf1930a75b8b44bbd43a8a75f5e307416ece79bf63fb914238819c8b303d17b24d087e57d2e434e746e1f3baed540749a302b6be74a1ff7203375b5e9685f25b6b5e4ab8b8e01aa72eb58353ebda7f610918472ccef62b1008637f359ea0f5a82a2bbed9edcece40a8563c49ee736a248d3f9f647dc47045fcb96015793c367b4444fc0cc7935d7fde25187353e7cfcaac65942bdcfcd80ada6365ee77f43b8d16aca965d335f5e61a57affb647f7d3ace2e265617d1a438482391b3d345b08934b8629767bb997485adb8756a975030a1fe750bc1777d80e8f8e799b5fc8de19c50f5e2a771947499d7715bfa326cbb746a5e0df23499f41f3b14ab84474d7b82a9ba5e3dd01726466c25db9b167e038ef1193c8fb8cd76f4689289c4e0b8bfa16fbfa38af99878f92e39c2fd5828cdf89a985d1a733da3e119c2219133312f04436e0464c37abef576682cccbdfa14b5ff253e13e56ac43d39b9c9413087ea28bc1935810351d431f4bd206f077d6652bf8af8a5b52dbb1da986a6d9e6e4dd87057b7c20589fbe66382a941f5778153efb6d9dcc2648696ef5c897d1543a68ef7f67727a7bb6cbb698dc2f3b52910267a717ab2fcf7190d7b2ff561ec2f518cec6e0350a7cdfcfb2550898a72f21bf5c681b1fe20d0d7f97014accd96151dcfb487da07b3cc37911acef0cbd31259c520700bfa657b669bf409ced3b083d8cb6adefe66a2f691f903c62e037e2772b6243dcb69307bdccd1cab9234edfbf12b061ee9447d1c85b32b7bdbab43b4a5724bb91af2ac22b4a45db2955fd8f9126788702bb2e8d24f9cbf406945525bf4a876c7caed63a403e048e1b65192c92315803a206e32eea1b7416945628181afa4b643e903bd7225c09db1ae13450f698f8686fb7b3476fa4d9b5f95b71588e2635eb5364a41f0ccd07ba45a76311daf008d74a3c4f0de488435df82b6951b1582908c1be16a91cef093abfb3eb94da1e4441102d9f2eb13de6f1f606ba9095dfb62c313c9f401b180e1274a9f1eb86bc970e6df34cb87acd9da8ded3735ac2981c89f2ae1c5eb5bd7a55730af9b8d68b541fe7b61c6afd494021c6e556533cbf2f200336ff818ca4c8d04ffd768de0958870c5997e6dec8abdb67f1e12e40501c205269ef07fb8192a0c18bdeec22d400ee236248ccaacf7d078cb0d799d78da6f8537d4a4d29154b0204d0531a7842ae92443a646ad89d658fa9722789ff2a412059268912cd9189836ad0d694ce9b99364fffb844139f276443feffd0b52444cc915bd483590e0873b80d87c1873c3b60baf238944d2b816dca78a22b3a94a7eca574aed4045cbc9b1551f5e28fd6d5d04b9126d3434a0083c6209bd917faa7b6a0103500557da030e7205f19f205f30a3873ca0d1ce5c31011d54d11438d9d2577fc4df74a30af4ec364ab398827aad39949f38ea912f058730b09840ba79d6035837ea50b90345582052970b9e4a2cadb36d045031debd0e541a903ad43422c873c631e5ad5b463b9d65b29d93b397aef5c92da05b3ebee769997c38dba772688fa6b7bf991611b27648cf4dcfda3fe627e0117ff0c6af022adc4bac7de659515aef5837a705b7ca232223fa08932bddf144b14b73eef8f33a9775c18129912c545615469c0191a3e7cd5eec0e0a845f2e83c07b0b482f96c223ff1aec24c4516d101d4479b8962aabe9e34e5b5d6b3148ac717b7dca680f690275e7f56cce0d82e2f1e1854b2bfb38b03dc633a1f23ab7789f2008eb1aa1733614cb4c2dfab628c92a1b68a3a7f7addf5d27391048985a522e9239d6c16486f23bc7a2c6ac3bb619cbb6a8764e868428cb062e3334514a9d204648c0b4cacc8b306632fbde0e7a58096bcbd50776a8d89425d0b986070087205afbf2c2638856739b7a8adaab20f14bf74704fde18c6dd63534219e30082a95b7f20d7904c80f9bbc38c03de4bb16377b0729853adda6432ca7a7990e68cc5b2a1d709416f608be10de55f8fb35e616d826ea25d3789692db750b23f29aa0dbd251d9313e21830558388f8c5a57ca37d01c0b5eac4813406e1aedde0783de522cd5fd6b6595901c145e170c779acbe853005b8a0231f2923942381a53c492bcab8d15561cba34fbd025c4affc0d2fdc66a634a4bc98af183c824388a877727bca51389bde02a7449e4100c31a9e7c66bd9f72f10142e39b1271562d1d043af923a4e485cdc27ddf8c202a35711bb622414b6dad08b43c36c29359461506f918fe1a3ba97e9f8ad1252e75bc19a8ccd66d9a74a44c041de90df2c781783fe0235a8edc24fd869a99bfb17f76ec9adc385cb5a5dc5d29340f32d0d954346856bef522484f47a801448b4a870e7419c6e198488c7fe39a8a7f3449c9b9eb24eff60112c34dc5d72a164e332c466555390d1628394c00e093360e1f43738f132ada4bd13a1efe2c1593260cd92b6eee0b16ccb6c33b7da61a4cf3604e9950f96e7620705b4ab6b492235a7085e9f09b75b8cf88235462308bf37287d853b2fd88a33f6307d1e362d789a09171c1daf62b45c524fa65bc19bbafd0e130155a1877cb26fe6d5eab63f0da7ce351abc5e7ad4462d82af0a67a3fe540d106cc1c8f0cf39354a79964d252a6f0e1613db8294aee9549ea3a67283bb5977982c3780d988918d6fe146e52481c49172096ccaad81cf73b44aec076e086faccf95604663b20ac8fecbb367d4067635971596c1c3f19894da09e8b2296785fa14763e36e371fff609bcea65b7395f758e92b536f7052c3365b492d5e382c4930005898645c8960f5b44076f3749d17f1767a96a44eda5790b5b036f6fdc89b13c0f799c4286e7eb7319efaa31db81d108d9e8826405c349894eb0a975242eedc090b7a8d9cdbc5f9ab25f4285fe11929cc8cf6f94cf69b28aaa3e2030834b66be1977833c8218cc0b4e3dbbf0aa44a47cb62f09411b55286d429e30cff4fd3cc63bebbe7f8cdd9cb401c3b91b62c4a5c7cddfb495051c56b1565dd2c302c39beb7e1fa2c329c46ce6937f614785b87a9197ab500e33220b001d20ec6477eb91cdb258e4f28df94190001189813a16bcf85d798c822d8ec26cc03281b0bb71c2773640573e5b55bb31b6fa591308b5133af4c3f9c43e1e11e81cb3a36ed5377c329d88f24d9e6ae3237061e9e86a499d18a31307cb65679d77040fb65a6a959b1314846bc441ff6debccbdd5aee92367f7c94f2dbb6daaa6ba49bf8a4e1577860d78aef7c10e8ef84633920bec2b417a562ac254225a523e9329c6b827b0f4a454449da5a0f5acd2813c4d46f78be121479803055644415f369a93fbe9c2dfac09fe71ea79e5aa5d1a2784b53bf9d72e6c1cf7090a1bb2d5490e9fdc17adbf10eb015a401a1fa3ec6265238c02a94c0dc11debbd992fefab3371aa82fd51f479ada1d6ad81d2290d82715730fb718f56f20ad1de84bcf8dcc518e5a8965a57ea9e248a5e1b3820b947b25a93a6b1244ff28f878d7309c3e05ab4bbc0b21456f8c73fe8730d2e108da79eea532870ab7ef734138f39f495248667bae6171b8f31dc78eedb6302a23bcc7411a967a3ca4a5b04b8bde55a8f53d9cda7918c439ca94fad1e0ea920581b4608a41c15413461f4687485ad362be92197a0ed33e66e009bc226c17ec6489f24572367ac42dec4645f7306b78bd28c9c1e3b3ef3a0e88a7562877f1e6c176a1025ee691321a2c7d4a59067471ee629ca14c630208e21221e9338da4f408f1844d54a46e980faf8186eb50d9ddf5e01ba4dbd3d1c9cef9ed7819f7ec9c14eacfa700e3420cef46bebff66aca201aed99126ca9f0b90d207ce6f0e094356bd63f21659847434c8abe665258b94990a5d52d0852a22b0563bb146f6bbca7b8d1dfa7d2f1e9ddaa0602501287cc099236f37026908a028a22dfc64cd8edd8d856e71aabb3d4783828303436c7b7ceb56432dbab9da766cb2a46bf36552f24519092f5491ef9f8e28a1c7eebc4ef584fdadb14ea4ec6f0016006d1c9110bea3c3cf385d937c76bb0e89d21801a42323bd3a39f33aad145e1b19ee3504a677d237fbcd6113a26be35f8958ad31f12b09af1aad3b141b31b5ebfce5726cc12165b80924e149eb94ce430832438b018f0d0057cdcd7424b550244ce6ac0b14689ba0155844ef91be417ca61e7b3e12ea315c0e1af47b68f88a9fd95c059a0f7c622d741ecf7e626ebb4e99f7720b44caf3554f02a6e71d7d2fd03b3c19396aabfbeed2b7ad6fbacd62769e73c77ab3553935837d43c3ccba3c3988bb16c69cac11cc3b1e6b4cd64e1c630217045754ac325326b3bede241ff90a7165653f7c7a9f6c58601bc755b48b6256b621a9177ba6ecb24278bf3a1ebd7e8c6821e97a68bb7878baaa3b262c857ad57e3e54005df6afc0d5e47536c6cfc047fa316b8a8ec85467890b59e4c427e0614a42f3bf86e58544d2a2e085c3af984e031e4876e1f71cf462bfab87b65fd099012e7d4f8691dfe6e88a77f210a7d9ec3ca261913d78c1f70ea01f7a986d05cf2195877f38116b2edcdbf789ab4f57e8704d533fb23fd520f4f3a6ca45348b810811ec98d47ca4ba8b07c2905eb019a3c070969bd0e06e98b550d4acd508c2d6477d534c07588a8ebe8103ea3865cd7e68e717db0e914de134eead03ccbe5c7c92fabb752debfe7d76621b0c5eafe4a15426d3735e70b0ec685adb0774f1c4054b3d11fdf91e15577a8990aa70d72829cf4830531bc66cc6ed2f19ae2f78bc9a79ed579bda3a35f75fe5db029dee63407f6211ac78243d6ae6f6e2865e3c283b0af0698f9072b2d829d63111b2bcbfe899a722fadaa7d553321442b8e1d45677db9cba60c96f7e9582f2b9b5854d7a386e277ca41ead56b6fa91a4c46d44ee8ff6c7cea1656609ced43c6a7c8c1e726015f5fac9b3602f2249f317bed7ad97bca96c544da76b284ef4f8142edbbe9b30c63fa77cfd4f798b5300b467b0e68d7cfae6609f74736190e9ae550659cc743d8f7875de8fe8e40a19cc8a89ad93801aab13aba7b6f5f52f1e0f9a3dc0936a50157f9172e52bffd2a2e16440837ebdd4fa36ff8729efc19926b027e66dbde6434ddab4d0bb11026fe9b7ece9667447982b3efb72384645e84e79767f23c375d23b7a0ccd2aed7a76662741f72b0e2fbc89cdff240e59477da3bb2ec7925c3e76e6a96ff1a2912d3fea787974dedc75f4acd71d15512d4aabdd532f23791217c16e72fa6dc5f35ca78b51d21f218c4fe12ab7d0609b1ae1b2d699f1404b62957e7bc5fd0f343c85cd954b954ba895b9858b57fef5ed454b97ada001320bfcfa16b0039a6eff3e34e51044cdf506f4de1f042009af19495968940df64d4caa3e871476f902145b4cd7a8b3cdf99ea19bb318354ea2583434884739667b3be90ab86f49f854561fd38c9e4d373ab2ea5c687d1edbc65705eccfdeb54c794633ed28942624ac314d50bbbfbbc68aa86bbf32cda80afa3fb4ce1750a6be5ce1e6c5900bc7cb4450f455630117e068d7b39c9f8577ffbfe24280aa1aff60202abdf5f379000128d1bf8e5431e500960fd9883e4c66c4eafdd3786aa4161938f52b0ef98df871c6b4fb795724e8efa9fb74e7ae693a9fb5de564b24dd3cd213859da749847cf41deaafd2c08d7507bf655e973fd29db747dd7736828b437702d5bda2785caca96df86b3add3231731358fa51f1e697e0c9a331f18f96335ffe0e7ce36042350754bd8aec225e8650392d03ab0f38c8daa929cc5e4261b329a5836114226381ec7aeef7cf9f4499ced567e0cc0e87568018c95bd83fc4374cb60f140d1028758da2771d1ebb52593bbd7d1e8226cba6935136d7fe1981d4d300eec395dee53ec8f82ca6124197e081896150040f16ebb6a23ac113f15426b23e333302e1738cc6b213e84287d2b8158c483a07b5ed394dfa14f210adec44a0e9180847a719489bce100eaa6671a1673c920f739c1bba628255e0ab89d5964a1caaa9993a56514fb4055a42ebadc1c8dd41695647eefadea9514e2cb5f5e99ced18c6534211b7110c9affaf83978e5b1c3be1576144d12354521e43dc92cf1fb96285ac9c4d085e509102e105b0989261754e6a8dcfe4e0931b789f9b45610861f41d659253bec620ad1a926ad20f1191f27e365fa695654e3442eb0375af3390f3b95654dcebe929780f0ad884ee8447386110183d2fadcfc1deec19a372a10f111b1170cee4be303b0367635e87bbcfdfaf2de2e21d1e86fcf7bc2183c66f4408221b76a89e10879f9b5cb39afb547250c0159b0a5cf78abd8229ce767f2f10a2e53d23796acc9e5d4d87931a7817017ef5fc2a4becb9c884e9fbe1150921d393e747ab2055884d4e4fbd6533ee53b3ec75d37bbfbefb991b30d37f14f0ccd481ccb99bc6d53c7126cd253ddaceacc8ac5516f8826087aa6063f11b702a7c72b17afb03288be10fe2f9c3ea1c134c44e2c300b63dc8a1d4fb902bca590cdaf975bf8964e629e995dd3e5497439c875948db109e3ff7e9bdcf1ba84360631c86afbc1857f60d8032395c8361638fcc1522094bb3c2473c4c51f720941def7a62bd5ba49a253434cda0a907fdb51a2b3acc6e05f83b031f0df0d9de31a485fc7d97579a4fd261173c654909c9739954c854138cd86e3180382fe479bfba5ad338b8040c716be7b5455de4a6aafd72473d866f0c7c7a6afb6c3aa185c5aafa5981986e079b5cad4de6aeb6e223fc26492f1e52d997f7ee82fcaadff4d144181ceba0d5c52dba105ad197b93510cff240eaee8285ce091bb373c4b400765c0b4c364b0021bc92e61957aa068e469f9a005b674ca65036e609d83fed8943eee1c2c5683533fa923b858497b9657be1839ba209a11ecbd51f96999db2cd32c926bb7f5a0019334eaaaa67deb3c74db510e47e640620ee88544e57a97498ecda49556729a72433c14f73de3f28f15e1893b92fbe0a9ba630569a2974c312d47bd473449ae7ff0be46bd227a39ca655c0d1c4148d37d96bf286ea350be2eb532085ef5ecf9f214294a5dbe00799cc2dce621d7f27626a3359c12966722301f7f38e8cee42d5edb3aaf490492f1303eb9eb9bc70d98e7f04cc726a44fbf92d2523f86853706a253a20b362168a6b60fffbe3984f2ecbb26da8e3113937e1ca45f750440826173ce37346c9c4d9f6736cf43a2e71b7e560e124557a2cbc400f0d7caa88f46fd565104b680c17c14286eb7aeebbce56e608de9eabf6bce30cb4f8fa72c2ed730b2a5f865c2f37dc9f61977f3863000cd3592462af69341f75cf053b54e9281c557c577968339c4198f700e31a3a43874fda541633e0abd7f5233fb145e38a3fb59d85afdb05876a240e0ff72dd8fea6c4b50a47b7131fbd7fcf35a6684e5ee589ff7f5fb4ba634f458c54f93832a7dfc8753907819d2106e6868ea435dfb1c2f595bd59e534170cbf76eafc4e979cd1eb4c6377da4a4fc18159ce91bf9127b734e1ad81726922121d5da9a127aeb32edc462499d1c2e61a07121bc0df0d0df1144cbbbff1c60ead86a08ab763a5cf0546ec129bde54dbc7e2c6d0020925cc18f7045cc9cfdcae584e981b603ac1fcecad106068cd0c1d93eb06d52bcba4d329917a1541fdaae17bebefc136535a14a215d13d1cc00047e250208e2b8993be53f37b60f83f7f03d38089573210fdddad5916e4cba808ac31db7719135a9abfd385f2c21cd063aca89559e72f7922d067bf0102b79d6f53b73223ac6c912e108253f0f411915217c2746b0b53ab66856d78f66c52ba9082b55eaa2cb9c911cbe52b96d5293854c01648cbc48c852fb12b110737d382278856454aa630f7876bad7e61220c44c8339a2df82cecc40c44c4fae17266213bc5127c25a457324d5069acf09d8cba119ee7f930837d00f827f51b92b8f6b6e076c7f79848051f07e37f684c2225dd72ba8bea2237e98e9edfc4c72ff0157a9cc1e23d192cfe87cbb12c2e2753743384cc3e46b68c311dea10ceb64fb6decfc2ee00cdc8649e894b36a6806c38a8ab0589ea42e15c4f415e9fd661e3fdd3b6a332cfc39a583da201c067a0a8b8ccbb15ddaf4705f144d81dd506fa46deb0cce3bc42e972025c5fa8e79920ed24429c1be502b561026bea55102b238de0c48b20e1188c7f15a02db48cf3f2f8e70a9007f53ebacfb4b3ebf233399085bf027a38f49a86e905d74df1ef3e66795ac9e7f276f5cfdc7d7bd73ce7f7912b0fdfbbfda40e837292911cdfaada0de6e3e91404ea417d4092429f757959f11fbf089bc295870141c5928395851902c280eb4fea0d169c6bddd3f2ece5f5c305a88c6d17a52b309db3957cc28b3aab01069938d600a8aada8bd2efe7d192baaa830859ac230446517f6f1455f53c535bb5d1bbd89c9154a0db4d536e51d34fc9acd468fb567350c3c82c136becbac8e6abdeffdc9a57782cf1cc6dfdd124048e585b337f4c765a68bfdc3d277e81f7aad37db262ce4a7afb43fb9c09a880bea7bdcc8f777e19aadd1376163575fc20fd9bc9186a97f5899ed9f26de2023d097c2dd623e0ae693e8ca57c83161cd9d3982bac9f34d41633da7a69f1c85e77ccbbbaf40ac7cf787acc5e29b48e5e88777abf0cdde6b1bba6f8e9c81daf000d80332719fb17cae1e68d03cdc0d361ba964cf68b2182cffa0c32f6d795c6367462ca5abb1c57fc6903568987af9c8723b636d149dad72cb8fa63ed5336a57d238a3cf043b68cd4e606f8682d9f3d67774086b23148eb6b83c026ab61763e7ecbdf7fbb984584c2c10ebf7b53897575565541803e431a9e2c45691bc4f9c759a91af8ca4ea0ad68b65f9cbf5493e218d8371bf5405630508e399445846a0a1c7066ce7b773e36a0f26a3f3f7bb5efd9bbe84f1a674f06d067486f4d5143b150d28b87fd1e9cea2a261c7760a2f7f051617b66e59261783e4eb64749733f328691d714c2627c6cc75ca2aec4315dfebca191ad15f337ee229c95d18056e0f1ebf187331ed5d399a16d0823bdda474c33c00928cea98a657ea412d21258bd6796aa6d7e68374ed14c78cb8929862a7097097c1998d0aef2830fdf96e72c257cac7e878a0692ce0bf8226b8158c2c1e85e97261b4ef807e66ff57fd3bd5e3cc74919e62da302c2a37d654e7da7134ae126cbf64cc3e84db94fd13c46a5135dba828052066e476f341a0fe3287365d239e07764c8737a7fff0bfc75d6bd4fb4fea9f1bbadd2871f894a0d17a42cb6aba5c05a00ded48e8500de1f945e4a32b955a2eddaa67a644ea1e7b3895b5b498bede5d5bc218f003756715f5aa77c1b70e3fc9e653d46661b678f247a5f1cfd78651bc0f87918ef1dd46b68e497dff63c32f80e489e33417013557ed706fde7bc7389bb30ca54c1f47427389aa1f405cf16e8f7c5291b1530c211b020c717388740e8a19d5f161f3a1954a76093ffc5d236ceab9d6ca65a817372f5ec40b1df2d7a530ecdaddc00ad060225091b1d1d3a51a87595b70cddf1ac902bef7c143f1b14a99039bf0b3319facee565ab7b67b4109a3c6dbe28460f34928ef72816a66af0b87bb5b9d85b93257544becd7fe6de648c8a1e3ca68d530526af44f735f2a2fb82d65305148b4525ec2c6ececb7f617b037d79b1f55d613063ee07117a1fd4e718c5f61eb5cae6c63ed45c206248bfea587afa2589bb733b30cfe5d1850dedb1a04329096d768040462c12dfd392286d448311cdf54a5c71ed07d19ba533e35c50c98e38032188d5ce031914eaa7fd07817a1df56ae9c02958da71421992fa5805993d35c9b126b3879e9840cf68dc626c87ad6aeb41f18448ac0d62656764bfdeff14f50544313bd7dac3169307fe047107e391f2abf53e01c33136ce9e28a0202049da1e1c2185622763d22a33060df26c32e5d8fc405565be53227abedcc35ad52bfedffc66a0e9fb67649d8ca84ec8117b7240cfc530ea94a7e9a07112d4776a76d51dcc47a53018ffb0597ea9fbfbd33c608032df8341ddfa31631d61d18c65d754c22ddcaa199bf100fad6c01b2aac2912063c2c651c61211fa83f6e522ce960410346ad0e176f31b767d831b569d60e3fa4a958f7d66e3712bbb7d36f0c938b4e5b552ae9dbb901c5e7c6294ca5f0b3502d364c05da0057d4dfb8e1eaae4809f256dfd440c21180043a1abb42b31608159e6fea1d2453f1c1d0b9657e2155a205654995591e33882391c15f6ca3f40f0e6e7ea48b21b8b62a7ce87a66a7ce5cb2dca7f23c4d47e5f22b22fa3484662292c11f5a55e9a46d71d327f1356eb2903b397cb36e4436b0fd481a8e1a2abba887bf43e900b068bd573e113f81c369768ef52504ef2a8628d8a83d88d7ce75d3af1ec909e6a1b4a34556c4b4a46e44bff1f57c705d89027cc2ded0a7631b49bd3f500b229c2322ee101ed1999da00680b15f2c8cbfb562864e79e4bdfbbb928ca48c0123d2773808a817b88ec2b679bbbfd2896dfe46cf8d294dfec6e40a39cb8472a842f298d502ba17d145cc62497856612d4485f3834db222a24d5be8ad2afb6fdaa6cb2c6bdee4c3c09c2d301a13d2e004e895244ac7640c0a9b6f8f6a07d7f0475adef7bfad09e824820cfbab8c2d8f736ebd57676c3e88b031531765a35dc314af23feb06b12e0349d32399f3a41675e049a7021ae502d5c886618b7387aae733c877776f9cb310c75e9e285a1a2351c5d8f31c2845b368b8bc052190ae896dcbda99a78a6bce5ea8b9fe595ee4ba189e52353d11f501351ba5cb1dec829b82b771b963fa6bd6c285b94af6cdbac32546c8e5bd95b95a93c122599bd0e656c34fbcb10b6031d9213826c0c8a1b9bf592a487d62e97b577dd35fca7fe91b853c1cf47197bec89157dd191b78107f3276e3534cc28a368f691283ec30ef67d94aefe1777cb6bc852617e61ecd70f61619e8cc9c71413c8af01b63704a4ee8d0a6026556bd133eb1c7fe7a243b0e2b665c49b9b5fb4a70fb64030453b9686afc0594495105e498074459bc8721395dcd6c0272d70e566d1edf21f7d49c3ddf187ea5cf4e51a7496fc18546e449772e3f0fefeb25f57fdb50d95b498296624b71e06e3a0180c6a9213bec01be6244238d4edcb538731ae00dca3d7fa6685e4529ddf3bae04c9d5a219985febd90024eea44023490ed8c671e28ec3e6df15440f494f2c829aa6cfef1da70490931be9b07dafc5fe2f7f7094faf4c69bbfb7e5ca1d0654753de5cc8cfe2e8df3f08d7978131347fa296c0948fbbfcc0c10f0c83c88ae05b29c11e40393c00d3d90d07c4dae50c1ac899a9c4ef2b733ed82d6bc69a57c1e360305f622b3cd1b3388fbe166d9a2cf8e5f52788e01afcc677d91f4dd5bf96cf455c4f0d32460a6ff4b1fc0f50c1eb31b37a41687bf47078016d6f62b174fa3f24737666e4d4a46cf51c4a2c0cdfbc8d5ed6758a6a7397dfd64343ce29d8bcd03c32d19b7e1605d7203cf535db11f942ff95379f541ac1e51fcfa69a77d251f917fba82b0c05fc1b4d26f990e46e60804b3ac21db0e937be2e98b01e127612e3bbf717585d6c616c63db91da478405762c413d2d375429f9ffc4e988beafb3f94bfa47b426ed82a0ab0fb9e58ef17684f4ec3e760d3bd9a1b54493835a7ff0b011b22a622dcf4678ad5f063c5038a96013186f3de3bfa76202fd99287f87468604922286f4d5ccbd7a4927e76e26f42ce9aef3ab39698332b12d57127bca6b212711b2835a473cdf717c03b649953d6e35f3d1e8ecd873005d3133dfd3b133182fcf84eece57543f16bce381f9b541e384fd8f0b300e9cdca52c443a9086d0cd3c44e3dad6635dfe221e4e4484335bfdb9280868bffda8a656a9d73e78f9fba8c4f0c178ee16979df3fdb163b98e1ae23a0136fafcd7490be75f0773fe1f16fa5cd418dd9c5257a69023c5c956684ab3b4cb1e0134e7c57836cc57d597585f94c846c5fceac1195f97438d8e99ff1e94e8650263838a66cf0453c96fe7e1a46cecd3ca20bbeee7d560539ef7d1cc02b964405700f07e9bf42cc8fa52168f471b0118f50858e38bb90510d4dd8a1f6164b67578c658567a7e8af3e2659733d631cdcf6958b2b05c4ac897fa4922b7af5d3cec7d397c24e4a50b674b66a3b40997c3b09aee72158f42455fa4de31b25c0742eb3575b80a09428e2ce509beeaa17a740536770fac4e2b7d47150c0bb60aa2c370ba3ff183e0c0ba3593315e0cf9bb6317b3b4f5877512fcd5d0d2a92404daa8dbac3c3d154baa65f2a9c465af7491e1790976a505e13514a4dac2c9f93462e29c9cbc4f1e98bdcea1e9f04f28cd8eb29c1a56c5c8069e7104bac09b50e35dd0b68de200af53bf1a37f4b972d019f18b4b7281879b0f0407e083275acc93c440784c57492b9be4509f90b1a2f71481bfa647a6ec1daa8e6073a057bf7fd994ed3cde8111523da03947a14c603cc38f5ea7cd41bbcb94980700aeb295de7474cbc37f744565911d394036b1b4e8ae0586823575debab5def646285153a2ce3404d21401c174753d64f3581b0d7e2f2d78ccbc435d2148b3943c10a4db0029f03651b9febffd6b6526a27ddfa52dde835ef6f15144367a533c9cb7d4a50cfb2e7699be3ba802a50c05eb3177cfc513501396ca7818aea12b809037851da59525f14478c01c323141aaf10ca8790da571010413cad28d8856ae2004bac684ef432e4b8344ab5c0d74b168d28f49752e64009d2bb90dbf9b6a386202ade9fbc97b8792fdf4c84a16006f1d8e808dc2303e34bd4eb1134a5ef2586bb9ed3a8811e3ebfb752a367e3a8635246590f00ce0d6cd3294282cc493ec07ea2c429698b8f2a489af8a3f2ccc89ec4d0a48f830ab503b7766151caa9a73baff2e7f57c287a3bf82b74a4b13baa6934ad5f69c16234362297456252ac910b9de353cdbd1bc30a865b8ba07fe50d7806f2dc1b86dea07475875bcc7e6901cdf848be9f5afacfe1116665e5b2ee61b5666dd1bfa5e56da290c621be822f45b274d901d555f8b7c9bec1359809db95cde72f57d83dbf70b7580ffc75dbe3a0aad03b3c45857f860379c04822d320394f714b76740fd4d2f0118f72263b7d8d0cfeb28df75671e500e85fb31759b908f4663845962429912b72e92a56e5b9c093ff433b4426ae9238ebd258b01259d3452fb27bc958cead7a3fa7f237cb29b5febd68b923d86a2c7d318a2b24fd930fd74277ade1b4c6688047ea63866aa840a8d840198b8dea7a00213d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
