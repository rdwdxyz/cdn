<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f42e5cb580df72ee4ebe123a54f6b7195ea6d018a9d4d53c7984b9279c24aba8c9fd2b22ed4c019a452458e512aacbca690ad468afbf025d18e2e0025963a7174d60e6b28f8582f6e9b5bb9da9f8ae870cdcdfdd94267fedc8ef52fadf72940740fa96521a2279ee235976f3e5338038bb9a5b6d60ccdd739492d2226505c508e75e8345a393caadeeb69e4d60f4bb2ef4ed1731fa1cfe2b497cf00093a7e5e17429013c7a3608602925923bfb1d0b1dd5abf01ec103f3cb9628ecabd7bd159c596dcb3f7b479cd36f87df4252dd2c05155cf50074ab0e9e779dda93bf31b73cf55bda44136bcabc430e70bbf2efe31ea7e5f3a3bc76bf6a87bd36694ac430483da5ea00ff3468e1aacdcba22da14006fe830ab74d60f7a7e348c10bbf32593b22013b712b491c0fbff532cde2731f83aa4b49b5f719dc43b5b88e616fa7c4d23e685922c9f30b795a4cbb2db150b6262514d2e39b44d2f954d3a6ad39f799d0fbf51051b3010e4c4d59acc6510eb13246b132a607be174769eed673645caf215ff3bc29a4b3e929e9687ed91ba2a1042c234327f0be7b869e591edae955a7630ff96a6cdfe40fc9fa512e2b0093c025cd4c41bac1c42bca50b0c3b077ccd79a79aaa35e2db53b78b7c5894cf44d963c0cdb5fa28ffb617899abd3bad4cea93a862b50a597915ef06470a1f2c8d31ffe861702c99236bb9045abfd1ed7f75adf580ba3d7958014a2981f5bcb3bf9c04ddc701328f643b94792ab9f2b1dab25c83f4367ee467b78af4c2ae5a7644baea59be606472f618e5a7eaccd6431dce01fcda42ecd586662e859a93c8cf387e3b2b41e7e05d5420f84e6f7733bcffc628b9ce2edcabdc091da0faa7bf44dd4c9f2d342751daa15fb8204da5b806173664095aec2413b4b9c559168471e4f7237081e954f2381431735b4b81840c4be243b8e73a1e38a906c0058d34e4ad405be073aad0af690c3df86411c97f2adf747b489b11f802542b42709eafca18fdf8acae616f7f65bbf9e0e5d2892e2a4bcc86a687d73085d5802fc4121f2e1b6c0205655c948b9282307a797efeb092520d02c6258dcd9b5e49b2ea058e9dc6dc20fc9196dbd155e9be49f93b70a76a02ced647b7280ded0e9ec2cd9ad4b163b7a4c557aebe78e640750e02303b01ee8d91f328770e78982dcc65151af6a9477923727c609a9e323838c1345433b6eb8e138c8f63a7f6464a98f25f4cf105e931de8aaa5ffd30f1798c93b639ac67f091baa6152848b8818a582a4dbc486318aa55a4976ae133e4c36f22279b997964c8febf24ec262de009c23763e4107088535b158389d7b9a2a1cefe0c960a6070278ff709287a28db048f7896d38426a6de5f32f9acd0d914337ac82486d87c30c1578591f8c392092df1cc74ec9ff9c5f4b110014c5b7df21a4406257c809806c3600b5b15fa675a8a03dde204efe6c03ee8c02ae122eba784a83b5c042c218fbd71a0df10b8879e5f33407bc8df70e0ebdf0df5c706e8687a5f0c100932bcd93f477e382fd1988c2f9da00f03f55f522a28cc5dddbe7efde28651b2f46f3c6e3f7d08107af407cb558b8d9a3ea3916dca1e0d3a870477fd9afd4b2f6dadf3cae74a3d2106874459ce437246071ca659e381ea571567d2c8a126e64c9c73347dc1193b3e18e38e534636e100e3e315d30721e441a6c1d7abff6bbf4d001480a0fc00f6062d6c7e2b8b89aee6f83bfdbecf6e805a3d74112907999788cc4056a40793eaf9f1f7f33f37cb619b94e37a8d557d47644f40b101993b4afa8a9d58cf485870d4d25e4bb72fdf57e27a5db081ee275979d3d283f887d9169c888ad8a2de36185eb044be0637604863539c27c55fca7bc396e042102dde866e35463693926974c36ed84f5be5c8b4f64efa68d2120e41be08892ae95b6ae64a712f1aba626dd5cb169293e5fc656cecf4263b86b393322dd7ffa83f75737804554e6fed33e9d248e54c0daad6d9dda60fefd2e5252f3364b7758d8f7d9b05f344f578ae578c1f3c90a5f8eb106710875dc6555e4baf43446555c39742f328fa83018069379feadcb3eebf95d26386082d2a6899523c0a93737babf8c4bc1ed1888be2aabf048722ea3bcc0ae1321e81d866b2209a5e026beae290ec8ed6a706439ff3b991ee572bfebfb48ebb692a4198429f8a90c712100ff3b98bcefed5095da964996851261eae007b0222b3ade2ec0ff37dd8ed79d5e587df6b579dab9ca77e14348acb53acee86d0a32725f90f18781ef7b8e455bb232cb2fd742b777c997eea03354435ab072ad0c597bf32450a8506dff5123c0029db3742be12ff44034759bc808314973282197bce1f8c9b3418371b198b7689c7e53abc52198abc698e761d1986b1b4477e46df49268ecf2c446f3f9a56d4a32ea17e94998cb2f7d330dfcbc91dac4be9604274b64bc57542910f0b979a2375abbe23f7f058288546ee727cbca6241ea65e0678133640bfada2e1313be6eb7789dadbed862952014d65d22d554ded7a11d01e36a358d02d183f4036e9081b11dc333f22656b1c168bc550eb6339807a9f896d4908ed0c301dbfb0a71ff81b1db5faa975badbf5a0c4ca9ce8416457d26d00260f5b9eeb9f4de41cf527f35067912524c7fe3ea52f64dfb6b25a18b34a7c9b70d16880099543c36f34ce572fe5981bd1c908e11d6172b5eee9c3a4d7f18e155fae94888ec3778aeedf5a67aeaa50dc79ac48dc9c755cb8141d52e8993a91d45befdb3d15bc61747414704f3dfd42d98b9ef66daf24e222cd5acb162862f94a9ed5faf3bd713edfc0b4ecb5081565342a1e947731f2df41e4f851483b7f1ae43448107b7b3c20e7b0aa81879f85469f9f063e1116e5f8cffbb373e11206b239b02a0995c2b9e4743952aaf881f6b530a4dde79064d107d75e0411b97d08a8a444017864ad9481d7701151c9453846003c02b476a7a90bb5232658b8d74767d247ea5df76911d4a71b4d4f358a490bcb29a8f199c2267d82a2716fcb4cc2dcc0d41be72dd8d93b954c76a989f2f65b3e663c5b93b2752d66203b822ce97f800f726a7119615bdd00a10aa13b2daf4d0ea205f00fc082919c3161aac862659b22e20f7153ee2d7eb55889949acadbbd45ea5217fac20d7e78ff30373442052d960149e7251c4df0b95f1fa1343424900daaa4d6c8fe77f919c9e6efe0dde377d8d1a94c8724bd6d06bac20d5f2bb116ffdcad353c2b48daa1f691152c3c0b8767ba73cbc1b464eec370d84ba2cd2d2c0a2cd4b979a3d23db6736f016081c1a95cf70ea6613d97d0b384ce14b3a643028d4f1506b840d2179d2bbdbff6148a8c7382411bae396eb25d7569e72a482e12d73a08d0fd2f13423921de0bf6ecf01ac5f6d1d8db1998cdc79227a6079d57dbee02640517c548e2133936ed01932a5ffeaaa2a41b69be83f60b00ed3471acbb8ac50bdea7c12f06a4a743c8431b66a3cab86c639bd2b9e740f609ad929717290ef431d4255be8c4fc8381db2f47e921cfaeb946cfd93154cdba27d9198e1581d68993f08fc17ba6ab83a3c0c49bca02c9d72d05fb09ca942e91b9c0cbb9442f011b3919c2c4250d06c8cb49918b82a5c4f60d24c2dba4ff478fa2041c12b577f2619f1c4abb67b3f2599c65305a5dfb8f785a2e36ea281c7b531fbddd6ee528637c56862e9b8edc90afe00d4bbfc7572c9ea72d452af57e19dae577712bec068c89a619f39fede4c9d18416f9681b53f59aac67be7fbc95c42efaca55af557a4ec14f0cad245512a7fcb0a0ea36c2d4e90432b287b91b71a159c59cba3b05ad4998f81e13678e2872b6a5effd6ce8359b6a0605f8e7475999cb66473b21a9da53c3517f6106cbaa9f727ebbba5a3e1fd1851f1962e780c1d6dc9e14bb17c5a6b1c91179a04791a9e1bcccfde760abd8fe66a568c2c5c353a8c1dde80cce097e53b8789871d088e7a958a3fae250265eacc2bf9a3791908d9ab0ac0c50022c683dbf4fc73a727759a60831dbd63780da7a61c732774c981d0570d5ea1a118d12d5a41ce5bae8390d54ac08f97ed60774b93f71880fe0f9fb727c5ee8ceb99219978be156d7206ef3f17776084a2da9da13321f7a6fd04116a7bf0ac1730c042f6580f2f8434754faa83eb223e3f7a0ccc1065d2ff57a82224b682485ef360ce5f6a45d2460543fb8515fbe0a6f899f1d9f0e6263d6af77f5e83cda9689cfa4975690acb820b24734de04c74b4776dd08ce8e3781cae36bdd7bf95193a3c22acb06b29fe43d3f72d04c5599d2d2e41129dcbac224a7217291395222c3055fc4b7a1bbe0b9688272c12080665f04bc348068993f0b1eafc7cd67dec0452c07cf544f653a4e785dc61d0b47bf3a0e74092d4d5e92c953d39f1058c66a305b77bcfda70e06ec9d5ade95bc6360c61d7a963e2e014a7658f87cd73b64799682be1d98734b8de7e82df23d449a28eeb2b79ebb7f98f278352a1048ac860754bd3a64281dfe6f6bb6117e10e2bdae5040921717a9ac56b7cdf2846602b9c1b7232852d459a8b926db223feba845aeaaaa8d371f18034c90bb1c1011b3970e8ba109b37e8b3ef068381b0f2b4a1889dc2793198a18fc4daf20b86e30ed2fed6b556ed5bc2f2b536d11223c5cfb2741358b4a694fd712828689a579a91aa15fc58a2846d23b73978472e1d42ce6342f38399e64c9224e956816e38ff9a46576803e55fa403738c748c84e13a92e4fa030adab02296ef9b54c1331e9c11fe0cd5d7d9b064789f93371b7bd1c9b7292425d71610e593c3e55bd11facc77c5563a35c0d4ad4f7d73bfa4a2357d1ee78979f8c901cda910b8d443f346bfe4f8e46eac87c06a6eaae4386b4216d6c01969b4657ce2575aa7d5b1ed3b88c021d1463edde9e10458171824eef12aea8be965ffa2b94704bc9b92207b50933bb6fe493ab926f9733420b186b58a68b8b1003ee1d3e0c72ea7e4e2e6429b32eeceabea7ef645eeda1645f17bba27e4ba825cae355c1ae24c2c81e6feddb4c904c79d45c37bb4cea3ce42c0f625d541ce85bb84e59b2f311615f9f4f8882d3fb50bb578b721cda6e51dece5ba0a748846e95b839040e8fe0638a2bcfe9fe6fdbf238d7ce0563b8cf456249a82b53ec73984b7909557d0afeca81ffbaeb9d3b2fc62357fb413611fed8018d8a6a854f6afc2c036a9125df74070e2c59a335e4d66e58233a397a8c1dde1b8c0d967bd7888fe34faa2f469364b9c95169e8a33553b5aac8e2d5366d572ff6039b446d6de1426297eb9dc842f7e3245acbdb135be4b9abaa3372b03261010696ff29ad80f22092d7015cec1a95f4fd3e4e6dd27a008f64b2a2d39b7ac2db6459bdc900cddbae158da36ef5b9e0a9f2d6808cdd03906683d76827f3e1261b85763dd2a353e7ba30c6081fc96a9384ed6f2a5c891e91a99819d7af2885ed5b10ed271ddb6db0dd766149ed15b017a566a495ff0b33217018bdf505f0c96fa743bbbf043df3ddcf7110ecf5069ff549ffcc7f6f943c06489e347303abfd1e803cafb4246e6aab8387008e38026b3d63b457e42fef8cdbe4c5b7c4635e13b87de0f5985850f5f30c0e68767e35ab60b77fb1330fac11a476d516d7da32e0b5c7870e9283ddb25142d958178db48bea05d42650561eac4a372e4b86a16d3372ac3c6eda54818a483596b584e197afdd3b76909d33bb2b5c6551ddd38a920e9c5644872f5fa6eb8f94dc319eb9dac0077480fd26a529d73a2a2543018660d93a26426c53cfecd7280d4ac69f00fc75fd6f306f86b73cb6ad730c6b6ead3070ff85d4dd0b5c61dc91c7019636be101464571bc4c16cbc866d4bb993f8cf4139ca599c1a17a1b4d990e4915dd45f432fce90f2dc3c239daed3b23bbe9af64ceb0a626ef0983922bf0cde8baa02b97853609f228f0036cda137d74c5dd66c2b13739113db412f865e0a750873d2bdad582c4e1ae61121ef913869d8ef58cfc5f7b059a151b5a3cb779a06bc94ffd9b48c53f75d147d65c8dbc53dbdaca8ec2fcded5d1ce47ff12b8e16e3184b1c48f78083b0d9edf6ede2d40ca45864d2b847b2e4541e4d2594e3c997254f6a0cf6c28a31e2e2cd8470d3fc4e04cb1a9a8911470f6640c47d080af8ca793fe369ce00222eee8ffc84fdbf3a24aa503207b1f5ffdac42dbdba960cda1a1a2e95672c8c86f5f66599d2244928c2612483ac80b276869bc441292256ade935373eeeae6885b58eca613d381a2017ae6529b57a1f1b773e1d4ea029875cc9dfec11c0ffb922c446cbad63dc0176188a1327c81d253b6501cfadeb00637d88a0c86a8a29df8bf82cc376fe9a8df95bac9991b6163ca21003fcaeaf0c7987d2c30a6630019e969222aa7bf8df3d0d6e44606ed81418024f0f053caadcc7c7a87bd51ebf7b4afb0cae5da8116f17aa0c4dab195b38ef19b61997a67dfff230e0999cca2f8adcaeab95d0d06f0a6deca758664ea731a5b98b604b355723854a1dac0449709b3697f71cc5385ee1b0e35e5c50dea904c85c26bf1fdcfedb2cd31f841fee72731b1b2fd9ba1bef8c00a7bd51700f77cc64fe4fcd21826d60c2814c7d1366a93fc5a47a20acb986c889f7a950a8b425fedb6206372f9f8f23b3e5459a542328edd0fb3ec46623b2fb22046eda3825e452990beaa993abf17257f823b356d712e2dfa607120d64b5afc0102ddc02690493014b1078fd5209669435d947bb486d21bc8767916ae5167958ddf1f76ce9f45057faf1184d5b4c60dd353454f0e1cf50e23006ffaeefaafc76547d662cb87f588ed8a4065f6c129e61cf7bc9e90048d5d1c3214ab360fa9f1155d29f31eaccded8e4ce86e9ec0c4015ddc2fabe6579df460857b290c14c6f7aec63eef8d0103c7651dcccb31f15738ec2b138fceabbb5214d5d28b6a13d55618a799962721400c9a2181219fdf2c190c5723b73fd3f250d4c69577e7f6f0666b1e5bf11f7f3634d1c1ec58566479c3681b78d7b7e939eb89179bcad820d81bc0c95b15451ad37d66fc5a51781f458f167e9351d8e6d85e523e884e8637a38f15d397e9bec1ed3c168aa58c1ad3d0646104e9ba9a134840f220a9e39f387665ccf55c54e9cdb27dd5d573a2cdaf017825472f8f8c0c2772d109220667551e1e061a22fb2ee30f64845c5256f177e0ddfc12ec2b7822c8ec2daa58e6ab1665bbfb97c84e8d2a0521b2fde35888bee4a4ef917f7b3181940158cb42015a4524c50c53d8fbed1ff97f3b6d0b3b57b1a80154f9ca91e69a8bb58d01c4bc9f9726ce4d024c07739c1c76aa7c3635d25955687dff8ed10e60c9efd045338eb040406d44e192eb9ecfd6af470ad87feed4734aa8805d192fe36cb055be83d65d16b58de5db39af1e708475d0fb84f41cd4cc9c72199d9c7527a15d28fd01beb1edf1f34d4607162805868bfa81c492395711bab35d437fdb9857689895a5f28c554a4ea14f99b1c09d565aab9b348744d8fff3dad303be96946cbc111e03d96fd96907d61bdaf4b55cd354d91653eb696565c9161d18eb811a95f40934594395f2e0ab504b72af2e90d4c1ddacc5e5d9d1be42ab748ddbf7bff2f63c822a0dde087d7b6505769c4aacff459aca678c0342c69458192b5dc20ccd0d4a9a21f7cf4cc45dbf57e35413d763b451ab569afa65a296a00034471f83e8a5140d4af801056c215469bef31a82337dec81397e1b49e419885903852b912503b3ea535d5c3d599f878c3cd480bfd1ae9d7ca5bd3f9906940ecbbbfdefbeafa36bce610a18e57c51c5cb1d796f73ac7c8a1eb667018b5ee10bd45bbc00089b9575a92685438338daf46cf761721165ff81e01f56c3596133b75f773854605ac7ca555fc8d653dab81cb4638fa9830e3c08303a8e3dd0fd9bb31c4f187c41c4f23658a19beb1d498f6d518f8ceac62db3ee3ed41e83d673269e57e173f5594a71b677aaefe44a6e843185c0690e0de50b4eaaddf0e4391de76371db8742b6d79b404c2eb34e139d998adfc01bf4656b2cf5373b8d021e2cdcd0e71ccb0cca49daf1262ef0d2b504bc0659e0e851088ff24cc0efcfacc67254af274b793a206260c9afcbaa76639b8de6323247aa3de535f4be30302db8f4b798f3c66e2687d041d411819185ef993cfb47e7bf4f62e8a503383648a53379b31087493b49080e1b5986c7f8af185b81a4d7a1e5926a4e1122410ec38fc841cec1a6d3ffefdf987ba3513b059adbaa1ae428d507d1908d0e7f765b3258c6ea4213c46865986b9b34ca13c96c3886800452f2a692d30fdb35cef8a883d5dc586991f63aa63d4f66b080d56a86849eb9107e4913a46451beb92e3a536489b1617ab0536d6361a33cfe32e2dd0dd623c2a2e1a982b93eb2f719e8136e2d83e8b0a69164ca44e9757fda8c8ecf9ddced78aedfc0caa3a74353cce3449f9f4ab0d83a475fcd639478df7fcbae39af52b888b5ef529579d23cb0c69745b7eb8370cee307bd204a9a4eda9c43ccea10aa1ef9210f1406471adbc468f33cbb0e8c4ff14b4a608fa7a44599190e639ef469044467b4bf868bbc994f54f1e7154f353b456c3be327be9cf9fa892a52f31f2049853edf790ce8c7155907fda04d01ed9d1779e3b8b807d5c85d9def9280244e2c74161eea980ce5cebb4ddb32d4f7d0e85a90334116476e933ceec0462ee39b5c907519f4609474c26d902719bc454ecb70abc62d8ec9413a5b24bceeb09dfb33629c585504ee68d8dd54b795561c6788270b12df846e70c85ea4520859bdc9b69e35f95714488fde1ccee42402c0fa6f2ce54ec08700584b6dd796841066531f568fa269434abc159e6c9418d9eadb7013ea487a8115f06386e32fc5fbd8d63ee375784411e4ee8df9f6b42fd54cb47c3ebe6b0fdf4302d0a7b1aba81e7faea44d81b5997c9a6d326db7d4cdb864f55f579d712330c633f1c284556eff80af5bcdf8f406773506a29ad07c2a1ee4bfccf6973c123623a7933dde4992753b897583580f7f92ef8d26a80aca37a1a3fd1e54e68e60f8ccf32738e23388b2a4f07b04589faa947388366ab5c2bc932250630facb287bfb3c250567ae65ff74533fa49d73d28b76eb7f735725994cee26dcd03b0b56faaa57d1da78f8018ae2ba5bae12dbd8e79168465be2a50eb523409c952cdfd06c7d0a03854060726973a0c722c30fb745ec8a8f7a8bae6407d2a096d4cd64bde9129c0776cdd41665f95b5213789af00957c367d710cee914c9e60dbfaedc9fb64abb33aeaf5599eb8571d0b4fa535a3a83e5fc81db6f1c5a0331d6cd9d68218286558653fc09518aa2f9340efc4841867988e6e168468e6c5ec5d7a56298b15dc0c9b725eebd84ec7b13b361869e27b953074eb6bd5e32eec0f1a4593f5d71d415feae758cd2c4332d9c69159af2e6e43c6e31b964498029fc75fea7072e519494b611389285ff922493987e5b09e010e4ebf4114960126b065f0cba5f32bff5dc2f0a76b0d43997671826a8b5196271d99d7c58d8fd3714a8707c05514b3b51a1407360698abd43e4831f701359d972a84f056f0d0d26b97a98592cbac7b6b92729776d51aab7b76e0f25702a6cd6d217768e5f5679c7abf3f1cddd6c54e889b6fe0a63de7f01c68c6042c402ea55b1f90c5960d2310f30b01659d2318dd3170e905d5134664128cb39712925f0a01c80b523ce167ba427ba766aa65a651b76be0cda7528905bc63426f2619fffe81e8ad73908780b0ec7f7003cf205a438b83e6faf6327a2b35c77e7a0795efd0d52a83a101e6df52c98421a30fb27f1e103aa8e1da33e853b8f1472b3476c022d92c75dc83f0ef4f69ca4cfbce8f859bd2cd256bbdc310efe7d44b96a0e7b93a92823553dc8a449a48f4c69a56d3ba2d6ddc13223e5974f1b24272945334b011ef3d0c80530106059756f0dc4eb8498498b47f12c14748a4d774db0eb8616c592ddb7d2293d4d24c92387bbbb54354e1001eb0c9ed8c85065e28adb3d6b0fbb996af3475e8e78f78482a0f182c3363523d7c7f6df17376c76805867e84a4321247937aaf8b14dd0bac2c259fe6a7a4966d8d132926a4345131464ca85c5d9670e2a81dcf53efc03776c64cf01e25e9677217d22071d1ebf6921f69a41cc5e6e70fb9a7e477a4bd029a2362aaf652ea9ef854f0f77a13fcc09e14784586928df29a64b11f1c41c75b5f4e148349cd4828a5df5eebd2bc3274a0d51168abba18b0cbcf79abcb36482d5a68b7d2315d2129d1b7cb55d1dfd365ae5d9f3850fbb514cf26f78e4bf887db6edba0336dbf894caf58525e9950840372598bcb3ef13702039365f27c8c57fe29730f504ad504ea2ba2de2cab748b9da7e328d865da17b2057ee5198cbb2d5bd3e5d8c5997012c9f0cc70712cff38d1050b7069af45d44e7b720cd47ccdccfaafdbe5a5807dd2fac77b046f25274bf133686e82dd4014e0b8e186ca6e5c1d5f5ec26efa2c6c54c2204ab343cdd17a83f8d3aea6612104c8d3f04ff3c730d63d2ac5f08cfefe26a154454397d4052d40797193cc5507c494a5d8466870c10cbecbef9a36d8f005313eee5bd3298b1c8754637e64f0826cb872ad4b530de6d6108d0fdbcb9f154adc912751598fc5e0bf68c8f5e0a30aebff0910f780c8d26ed7fd22973c9e1aa3347bac9ddba3d15e58f43ca3144abf81938e97bfe7436838aea7e7d51bb6dd6acc25f61c0f1cdd7606dfec21d4bb18bc7d746e489eb574f7e623a42f8ee3b2204dd212baf430a81b246e4157d36c71078d88d7055fc859e65a6f1b4a62d9bcf29a97b7308d2305d8f993e76453f672706652f75b34ad6041d214f6b6f1584a8ffea2b38273e14ac0e3f226f67d7a3eff0c46847ea1797f82aedbca187110aee7a6379eacfc6b48b6132d862ba80a5acd3e6141be43702fafee6a05179389c02c55e597224fc454413f1b9770f15820cfbff66686d36a0b80fcefc1cf35c761c77b9cf1bdb56bedb4e5ef83a9b299eb9c4eccbb0d179350962d0f13de4ddb2176551b1aac8e5093c5bc8379862342ee465b779156ebec534e5102d3edc8921fa960e901fdb08c5b7a3aa0d17d79cbe1cc0e229f2f9d92d2c14a48ac0f2e7bdf3f71ced09ebe304655822a171a805b62a82b7a9822cffc9fe6840c5aadd54326ef8c9f13a43c97ce837435f347ca88fb8ab5a5c5c7d7d588fc5ac6999bb824817406d37a063bbdab195b772430fa6e1dac2d974c1176354dc211a16761849897194fdfa18ea688363029ddb579e791832ab096fad35b0359f1f12748a5e7e14f8941eb449905148ed7524e977f7daa69bed3b2a4d68e740d337c9e60e831bde173aee34a69fe97a4b9afbff8904098ca43a7001520915e33325b98189e5042dfe7a9deb48425a12bcdaa25dc73e63a8a2b0e4a35ebf467679d6b8ea14a4979af7e1d0962654527c2aa1c1fd3e73237c4ce428d06b6f7d6d2ec8dbfa90a7fd8d950e5cd8b011f042329748b4f3387384851acced779e2d3243d5a9b8ee0b85963f6fe96da085d309923c2dac94e5f211a7183026d8423fe8347c409689cda4b757688487e399131e56d72bbcfc01f67f055736aadd6d9806db9b277ac59f523f5b7f78ff7e39900f671d40bdba2b4a01c4a0399f4224c1811c93c07f06f4bc400215430415f5096efa5161df4456bc6fdaccda2e84dd49e26ed4f1a9e4f53ab867d50daf4e74b86a2ea5c0a011d5d9315e700ccca87cb4ec30959eb993e58c03ae8d02dba4b707bd2e5c84a47761cf2169d44db0713ef9947198ebdb0d332fe49161a6483c5bf8cdb4d007be243b4a5f825d7bed098a1692de9317aa5f5e5420e092e794034977b6eef92666e4b29f6a23a306d5b39be450dd9dd1eb3af1b435896ccd07396d36a2631d70d124b38d4f4ab962eb8eb9c6d4c366abfc1993f476aa9c0c6a12cdd4af99b00ca3fb382a1b2d01fe9ad7288c6b097f30c84d556e32df50494fd62feb749878aae27bc390262011df2c73851235ee5293c06a784aea7c380dfc98c6cf18046d93e7df93166d2285353af9c12b16f601f16ef622b7b367cd3ed127f05647005d7ffb1eb48870ecb1887aab3755c7c491fbffb370d4ba5c755c8d84b4deb8fb6e75a0b8321bb9184b64f777d400497ba37c35bc66fb668b5cd0692f7155de71092d1c08db13047d78da59d1b884882fa4c23da3ca83f53f1dab1932b0dfdc499efecc019e3104dfd88b372344bcc3ae5fdc68cb6de4babb4fb61206d33bb77e24b0b7625128fa110efcfaa60be0666439e99bce28ee270dde762daf951cd20511919352eef5a2f7ff4edce605c875427fda1f70690d73d90ac92153f15ddbf6f75607ca7d99a83d85ed69cf2b8679829981d506867fea58a7baef187673d72030f885bf99360ea95cb1d2ea7b7036633473684c37569d0f4d3627a0541573b13ef4eab4467cf18b1dea756b9771c3240c33a5e2e586055a027a6ad8ad140b46d716f16d9a09a725a90c176d9a6cb320e24c898e8c1288ff3730b3b90262051f72c2e609e24dbb43330dc84c60c35ce26752bc96a4ff816c2662f960d2e819e03dbc853441f0b0a5e67d6755d0e14400a743e8d758cd0c4fdb69b3b2876e2ea843f24682a67f39f2098b661ca2c4722a8c905e4f119603c83b185541383a227fd3594108c20543d34b2200c5e20ecd5082735947d55623555c274d6e001ad1e066603d0b88075e86a792c38e1b6279fe83444e01865f5a2162aa52c34c2b6ed6b1248b354f52f4760f241382dd38f6bc26e89b9a6ad5f760148e6d461b130c5903bbd8ed064092d97207120d5b33c66eb83b141d9862bf2313acafe41d15b504ef3a3ef428020e947c974840cb4a2849cf2c06d83f77917ad5541bd754db5f99ee67019a0ee2479e2c817d811569eb5be8a1ce45fc9553763500a99d1e00f219dcbb2a5747abada0c80070fc5b29692542ee5fb6499d1abc01305c26fc34030442cc7c2595588be9e88433d0394619e17dfaefeb6133a63acf6f118cb32e494b670bf70e24309c02f4320f10fca9f532b22fd8c4d2e34dbac1fec6ed993436d8204d8768fcccf47c2d55289dd9489ce1e1b0dce283f85426e4bb575a0169fbfa4474cdb99b23f0bcb0025ca40eadbd0d69358d79137e3e3093f5572404bbcf31a9c1868931b9f6ca355a3c1f6a8453b612e70f32d063bdc67cc90c47887edb009ce173cdce7252129d473c499335d36dfe799c8f72408823ca0317353d80d3c95a799a9d7be592719f28f316a8fb202690a06c783200689a2a159e990ebc1581582f62d57318ad455d99b2cc89d7ad6bd6dbd0b2ab8abb8f7b734a77079c69af0d5829773072b894bffec29f81fd78a67f57e5ea2ba7613404e8b4af32919190c26ae03a78311b17cf5b39ed33917c2a2ecd4855563f0d996dfb00c6754aed48fd91bd045a823e9ab3483dde25ae2765cdc83e00eb03daa213e18f16f9121e7a0144e0b4a81d157a2626c9f7b216652bdbe3950a8a7eaf52ffc90f745eb4af5d8d87dc22d6c8836af3e55b0b97263052a51b9782c51626ccbe3f5775c93ce4813e89a2d24901493c4d72a816fbabde36e4dc18ac5d42d212cac61ee18186a13ea0eacf3528eca4f073a72e18acd895ffd2f8dcd9f6d3831185b076f3c1e1dedcef9be155fd34bf64e0ac835f606d019613026ef97b257e0a2d70a74a7b55b7fd3760e4252a076f9c030153be0921bbf05ad3aee4fd1fc34378dd0090e470e4d320b400f7b524f747b667e76ef54811bc177ed7555ab7d4ce4663d9fbc8fd2fde14d9ea8d6b195e8e098da1ee842f0d3899deed8d31552d75f6fdcc0e2eaecce8658ff867f42be57a33170d101ad88c4bb9adcca00cbaf1ba287cc40f63b8a3fc5148c776f452eabfc86c6a8f5316d456d83c7168525d4ec03e2581b35086e918e37195be8c580077bbc85740703556f1f37eab38d203f41f1d4dc60be4fa32044d94432fd5f7e50466c2e7302c4160e42382698785250475ffc97b86f7fdb15984cd9c5219615c4cfbd92078516e961062dc378b2566aad94912d8521d0a6a983c2c4916108a53fc274b836fc62f1fc72bb748a03b94f31a2d74538ef67f2c877a817574e8881dd12d286ea17c2c9a4e656a340f970af449283dff1da523e6f0cdad9012216a0aac0aa8a5d96d2cb1a136e7f65a0c90d6574c703a31c8d27cbb0585453f92d3906424620ef635933ce88deb89ed9aa07f29916bd68048e3ea0a51462b95cb721831661edbaeb85dc7b0c3b3e91efa6902004eab5d53e25a9613266ad8c70a0c69c76618bdc899b382b9bdc664c7d1d1782f68f83f50d5a690f120e74d7f57f8e08f04a7f8f2043d2885818003e653f6b631c1d937d35e846ce566ef6546cdb2a97331a9fa358e1ea5a1bb45fb3f2e351cb09973b22af0fd1a8b33b0f72d6cbd1e0ba380652592697f399cadfb12e392d4a54cc1815ddc56152ecd0dede40c359b3cd96488feba9512fb00e317fc4ec9b64c42b6ba97e2329df47b012359fe400433a5c2ff080116b768d1bccb67cfce930880c0a20d0eb0450ad03f994d8013787a228e84ba3dcceea09d6c31d360b206913b1c10f45e480721e02bd14e7d919bb469601ba22be5e5ce6335c37c58b1121bfbcb09b8fbc93482b7b54385f6b04687e5c723040bb13fa2dc109ff5393f949ba314de6c9654170fbfcbacc08543f64886cfab08f8f7108591649307156f1ed8cef9a7d73b3e7f55019e36588579cb050fb3034f142cf45224cb3a29149f6fa593291f3c0380cbeb0169c65a3fe9a95e7e0932b8e45d582c7c1228db0233943df6fcbee265142f7f94dcdd9cb8458079ef2808dcf701373914a26b2c672c5334881806044a6b55b1b78287a0b056921d7dd58692cc2c51084d2bcaf283f8d5365f97d15b52b713afba5ffc22a23f427b8d8e165cae9b438728799360c5999a81ade388740500ff3fae4730d0c349e8c677c0efee18fbe78a01980338e65bfe04a7db9b9d9e3d926201ae682633656cdcdde9b43b57fbc3cecdba398555a7f3d2db2a03f4486be354aa3e99dad84f307c4842c7021ca24b5b5fc514bcff6f7dc04397bfa12a7a611c281f0754667ea495d73695384ef48338f8032f517166731892ae9362a3707f16fa039d4cd980c052678c082b817dc2166c5783345f7c0f0c726d116a2aa42cdfe8913be6921bef1b34ad0d03f881b525186487de4c2f05d332ce7f6691fc0ff39d1cc523c64eedd1a69da92e2cf038167ff7412c567d720f49e8cb0cee23ceecf29aafd9a6319c7a451bdde58e3fbc2b1b67b40cd52e649fe31688d46655dd4c90e3ec5365662152a584dd431143bb8c75e3ef19159403a7391edf250f59f0934c4b4eaf8f61593a7540cb6c9f005eb80f00702d48626c373d35078e9f8f6c1bb07c39056d72f4ae9a345085518c9d787ab01b7cf398684ecfa71e7b33dcc0879ff3bd159bf857a0cce0eb63350d51335d4bd959c7459b45fcd88a71899847210c5737b5f3c6e075a6291be5b2ce421323869bd35329d8fa802f576eaa007ff12dbd38f145ab818a136dafe6bd97c5650fb5b5218cf5fafe01cadf455ac329756275df0c2c18a2e015d5889d53187c3362e1e72889fc5f825539c4daae84259851a03fd745b260a8943e46b81d8e410c4545a1ad3e0261c55e6190fa317eb6a450cd2e91f0df327dc35bdc11ee18736c7844218dbf74d46f154e96d9fdd529b51ff861a6e47876793b72665590f5d7f95f57b67f5d54e45d992d25424d46cbe5d65d3755ceb4968fbe9bde21d933818044264022a7b7e286f7b42888bb8a1232466c0628b332b7a6591484325db8815fec9b00c75d0ffa0b5d3e0527ebc179a0e3d1690a752488733f24e238389b765f3907f875895cb325ffb341bec539f7cf227adf440ee99887044bbb1d910bad70f36a3d2bee05774d3843d449935948505abb42c6f5f9faab0af31ee91db33f1eda947cc3aa7affc2fea8d0fc6d7f20303b98fa240598fc264210fef4cdec6c5ba90655bfdc94484259858aa3148956bed1c75d26f3dc6d5eecb29ed601a3b075f87b485cc84aa78c3d57c037763725611cc2e619b7d1e92c2df85e75e62de30ec817ee55e8b56e8fa9c3bb55f27a5aa40b3242c09e5f488c0ffccc7e164e6a558b3b459f07e74dba3f6ad11f5d14902b35540a0daddbe8e3da186e5769fa08bed69c3fb0a924895c79e8ace1b0fbc4dac4ccaefb8b58ec108c8fcdb55827d24abefd2b8ae5bc3f0b2301b9e68bc64034559381a7379d52ca131b9d70cd1d23900ddedcbb89dec4bbf669271dd64f949cae22dfca29076649e307341d5ada04d14f6291cef74b354c3b9ff75dec8c78f9f6a2b76e8984a37d5c2d90e85f61c8560f0d9ba7c03f4a921a6ccd5b2c71edb7093e2746713e47c3ef49a13e1dd19234901571d5ad02fff5c9c08f35452617e7c6e2aecd60c159e926a1431e0a7dbaa35a1ee8399e0db725d86ede6a7e72bff03033199e90a647ddd0cd6af132b6815d16fb7826114d71c7229ba6def8939f6a3dced9b998aa3824af0734bcf6afe042b4f7ffe26e5c25936cbf5020b8b40d192cd0b3c1b941359450da2f6e1652518898dd64853cfafa6f083b6045545d8330b2558eb77cf2776a3079dd4cbbef95c7f7ac8a033d791843465f7da7e3343f031296902648200a8847be215705d3889b6d158c248bbc2f9d5bfccd6f7a3b3054c6e5947f3a474308090fb632301f7e3d6b8973c739a0d2283c9ea33858bf64b7a2a00ed081b9666a4dae4c387da0172ed72a6f8fb9538fda8ee7e4b6e56786815d52fae8c61a11f129f27e3587698417272d7094db2f5caf7e07d366795519a399a6cb5f1a903aa4b6729c192d10182895d680ef98f053590494ad144c7b84f96c114aff2d4ad85f9b42e2f4c949fe51eb6d15cf92ffd9d2d12f6e82165cefe3263b3c8898d8028475f369871bc278b59e0f1f568987f6105e930991913579007a9a2e7f02d2b5f3120372c1a97a23e8eb0352d26ea753ee642b075e1cdc31190e3504219ca1dde2908bbf04ff6f811db841f4f34a45565942ebb46e284f9d64703d16dbe4d6e8bb7bb6b3717971e1b7ea94ec2a3d9a596d33b7a6a24970040bc3af4b6110a6f1775a9e9bb383e5b9298bc88fd1b2ae7ff6f12fda4ccc9d418a878630c8560cc6eea36cc81d3c04d3ede2b94618758e646f1cf9842808d959d160d4b7c43e3c6affd638c27d87825549aa01b853f0d1dfeb17ce830a28b82cac1a8e9d4f6ff2ef03d335765a17387f95388f346bd4b90815d34edb56ac5051e6c07df2c2a7201a91d20065ae198f75d04b81b8c166bf4aa10e0857220125a06007f0eb4c65b075b1969b9c313d983ea9cc84d15635a80d5a77277820c3d32d32743e1fd84164b4cd8dffdb6c87001da83202d48d2bdf704c3e3e2f318c3f0407f22d1458ea48d5844a2f27b987aa92a815696701134fafb45c15bfdaf6a52b7f63bfc185a8bcb16e5ee4fbd971484195258aab5575c931c7afe4cb0bd1cdf6c28f442d30460f11668cf4ff38aec2e0afa1134145681f8f30eefa4a13bd4c41579097b4e62925e7084776488b23156aaa1075e0ef70795b0cba0e81cd58139970c2568e4428ade63afce0420f5442ed1230e8dfd09b7e934ad61eabf6705c0af858d926c4156d51a99c01cc47144a6f0af8e166ede492b1ca6fd480b6b4215e42f436cc6fcd7c055d63fc9dcaaeb36d7c383511fed537dab3bcaf16d0aa18f12552da0994010fa31563434b73b1ff6acbcbe506647f3501e6b47d185f19507fd0aba6cd96bdfde29ac4a78bfe69105957a6ff289b3e6ffcaf21cbfc3d2afa28392b9efce26dd505bd0e423f499b15673861f88724e4c79958014b8ca2a49ab0863d03df058976cc3c84dbcf58dad2a7e3e6a54e04eb4f1a7e3d008a38a07c5b80ef96edf09b7a20ef1ba716d2129cc9ad6aab6a4ebb83d84cea2933bd00a22e93d1e18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
