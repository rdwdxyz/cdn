<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84dbebeca858afb0b426ac18cb7d80d984c689e49940105125104651b8246b95f8844947ba8c315b9a10824a9b80ed0cad13db3e680dfc18da3ede101e2a715cc7b0a2d1c5fe4c04d09179c97992b09d06abfee9c7da315e761467efb2aa228db1670552edc68225c348cba10bc44c2aa37c1b9a26702714628b831178de70caa583eb927ff48a1397fc5f559d1bcd420c32c56af0f3605a66e1b47cca80ccbcee53dcb5f04df592b943daa1fd5121279e3ccd7ae029d12fd652a7a63fc5a10404592063d87e2182a3291c87098667e12b5202e00ad7c34e9a7161aeb59aaf522412a01040a010daf7a448c752e29a8debc62f8be308d5e0c8c999b39d0096a151cebe9388724041605c9e705374bcb5225c83b85664b2443dc1eb383ec189b7cd7b29ab987b1c2d7255cf1c14fde7868ffca1736914b914e6720052049a2731266947af7ae1b827baaf94985a70a4fda4ea6427abc5d57bfe6730cf9e17e0eca62eb02b2ca1c7ebf5152870d6930f1b5ebf7bc1564d7b1e68146cde712d10f2a20f92166d7a716897666920f50396e23412e80362e57cd80822df4bc430eed532a130d2c2f0c6b8b2accc61fd8d5e071f6bb15c1ea0e4e73e5260ce0837f6b517529a2fca765e9b30ce04f421369405f5b7d1f0c0239ee877000fbe599eb797d92793ec6ded73f36e545b3530cc31c0683ae39377578c3c22ccf743616ec1c4aa23387f48997567c8dafc82841b25dbfc1ebde0c6dc1741a4e093a99d7e8c192ec106629064a9f3a56b2a43e7c67e6142369398f6497a343dab7e6647780e2ab14c2b7823c9f78c3ff4375d265cf251253fdc4c51a318f8cbeb007bfe3faceb2e694f53d8c1e63f0109a1182b2cbcb7a98d648419f1767d58880237ca56e9103729472b4635a9e07e1130cba74bf09edf9e8b3ee961711405fdbaf8da9535b60dedddf9529a5bf1b5f7d3a5bc2a1106068dfeab04e482f2f5c37042f0477b1024b537ae0ebf973a919279f1d8489374da9e4a3fc588e148ad940324dceb02c984a34fd92110197d65185155d53a1753af6806fa66e0f0d44f8ece073c216dccbcc02cdf8069d5874a56bfd1ad5b26f8c4b54835b0b47d1fe26df119ec76435238e3dced159e7815cf01bf28e61fcf73ae3cb666b256a3aa07b7ac0261f8289834ca83f7251cba6837109dc9be6c269a932baa1a27216775eb26cec184284782d8e8dea03d617b0f557d3860c7215f490f0618708ecfb08f33fcbdef4eb8ca631889790752721c8c558c0c2f56b4f42d6a43a09893f56b5f55ad966496152771e93ac632f7fb8d24839d9d49154388f2706c0a80ef37933a9133510bea59ccddedf6986cc025440c098a4274837259240e3a2b1e4773a6f48708db471c3e477aea3983dd952434e74dc58ae0c1003adaecaff6775949ddcce0af60144b6ec2011891384dff1ac5e105cb48819e8b4d95afdefac852b06ca2473abb96ac3d6a73a5f0873c535a9603eaea84146a7fafae6d3c4b8fd45e60cf0235afa0c23a2db12d9f7fbdccff6d6783aa7d4086f9c83112080a85531254d714955aced23b0adfe99ca793542dbcbb1fa3dfc556bf86f3ae647def2c1fdf12d0d67a6ec743e985bd20aef197f9c959a4faedccaac0b95380b533925ccf414d172216a9882bb2beb47cb4a8f2946cad962402e248df722a764bddc098cdbbb67d972a7e40419c236f3204705c3d711c370dad686b8c0230f75553965a14825ed05fb6dcd5966fc12c8b14f82fbd5ac6a50e808623677883c47b899e9156ad4bdf4d3ecb7d68f23ef6e328228cf481fc4e19f01ece3cfc344fd4b66b6b60954938cde6a194a1a26471b8ec875bfe20ede2f07b601d889917a280ae33d9201e132e65efe0b60971f43e7d3c212f3e29ed87b260605762e29af6bd3fdd12a6ebfdd113a843208d350b11eeb15286d410e397ec117227fde70cfd09a242f6cacd40d6e0c2ec24eefac16b80e3c972d60bdbbaba7d3bfd65de95d38c366165dc80387b004f9c3e2657918809f6734038d6767b4b906f8dfd4dc540f1e99ac33b7aacab19626c70820380149406e9dd28fb729d22068b4b3db893d05acf0be3039dc3c8cdc2e605c529ad8f9a255d38b16a5d0398fa6d2d9e27fb7894759ac067ecbc600555502557472d7025528b05ab8a3559b4f08f2a1ce11c924f0445984125bcd8548cd81103c308ba0f9fa69ce1bacacdc5475c7d7f1713bb22b53b5bc6dea7a060ce17dade68366622592f58a2e07dbb30326db5586a483468cfd2c1b54e6ba69e9af59a5258b949a1c6a77863f617d1e77df5a01495bcd7be49f2ca2adca12212fcb167d718b43058a6e7093e9b0e88b1b842e3931d5db2c5c3123c040f33ba536e80714ec1d83142303b4801f3f17aeab5c9c582a0c8d5ea141961637809ac7afbf8c3d735462853846878b3767245fffebf9f723098bb8de5f844e15acb7acd2b53424c26118b9b04e95efba7cb95dd81a44d323dc0d5f7d502e99422a150db393d6abc4ddd2dca0716222620f6405cfb0c0faa65dbd68cbd104474f4f69e40c652f86dce2ae110effbfb20d4829772a877e6a545b0bd2134604abc71ab778df1ffd6a4ac48185dab9c0cbda2d7ec9f7831e637a3ece0c087e74e07f0ce2ea369fee0410f3d1bb1674d1d25893a7fd156e22e1cc7131f4219de4b4e6604c55cec0549b0fdc469d144883866f32d533201ac211f2115b29633bdaf5924b6a4bccb7322ccd19cc385e6396fa72394ebc559634c44b799a565eea516cbd78fe8089219741a206d0493efaa790782184d8e7e3eb7780345d4cd8110061354e6d794cc753431be4339602b2af14c8b18dd08056ab9b2de0a4ef1f40dc37e2dfa868c61d51b1ae7b28c3b76692995f7cde4ad7efe47a39eb60e158f0428618a18985788915ce8a4511c459ea36c0fdb9e7f6f717564694325edc3056d6d6e9f746f3e9b23b87acd93a380d3c510f0e51c727446099c20de955103b5583428f3463399befc6cb9e7ad96a515b63907d8722637d8b1f7d6db606bc59c80cbe7e780baaaa2c9fdd4b83e3a746659e9950b778a7ba906adc99a37c233ce32acf95bd94f0ee1b345548f3e4b5e2dd44eadfd3a5bdea36ac480a3cbcad9e0be0a593308bb8f9909b1f9e66d85c78084355b0512c884ba8250e7c6916a4b4a2a50f485cf56446a510a8f7bc56545c9897f6a209dd700349bbc60059acc0d528f435f9abd56509b12573992b769e089a65c65af016a65fa91169ae9fea96018599d83633fab9fecddfe962c560bd434f4815757f9314b092e317bb0f3fe7218b4689933ec0ec2ef8bfcc414055b03f0789000859df198f19d9ed725f8d0e45362ac97c52044a5346d3f82d96be7899a548dde939e999a7c4fd615f92ea5e45458bb9c2aa79bafcb0ba19d7c7dc4a0a2a460cc3a0b82fa608d97e31448103ea07ca180884ee8fc3fecda67a139b5ccc175a3daf5cefd9829739b982aa27bf13726aaaa11d4c11126e28baa881f6bd04f2d09075153292e62a453f7fd7f73142a2c0b839b248e27b84f0986c80a28a88a9c60e9c725386204982f1c2b3abafab3d0a5443a4cba0c4c6aca21de7cb79a6cd333fa7f61da704b03821e7937cbc023aea14c71b0b26a9dcce59c771ee8eb58823d1d9d3da8500be2fd0c26a247d4fb890f92df26954e1c686c90dfd6056851f18dce9b67e9e8d6b0f56f6706e941ee17619de305aa4d27a51df2355906267711107422dd5b40110bc5d4ba5778f245f28c47a811165766a5a1c5b4b2957fecd2ec5c954e36b8ecae9c4158167e740d98dbf6c86bd003558d91e6980b50e89a8efbe3ffd805e44c8b618a20812f03ad09c7c18f89e13e5bea466247cdb9d4c17c32d39842eb4be4e3286ba9d0d8d130cdcab5e7f5fdf816a92cbbe61aa9fb055b0c16093cb1fe976c91227f87196c2052d98bc7a20466260f1a03bcfb38d2366b606f2bc7e1918f4e4367d6bb944209b9891f4d56916dfb3fb97761be88856d398f12f0bf31c7900b347fb4a3c63c21cebc0d5210480a9fefd01dec6dcb4a0157cbc43e944bbca322b6bd7f86b4143d856463919dd4923e334df0379433afa89fca312bdc69b36214cfbda2cf0b5e9ddefb08cc36eee76dde831253e664781b42783d200dde77fe0064c4fe7437750b1f53ed440ecc808982e5b8b7d07d127be93c551abe6e62f806bf3192df254fc7fb414fa659774ae064a1840f081a067c6c2d0fe068fdc53e4746621b9e6678052b3da07f78fcdacf96de4bc8a0ad8726a445155fd612b6a1c90cc46298b2528cc757e73eb28162f669a11454e3705ac9e74fe9e92dd915a0069ee060e088d12b8763b014065e6e671876b4bba09f60a981805fbb94615f3b86ea36a07ce38535e10e5bf8d20a9fef999b0e22307ceb86160c1bb01a5c1126f6e4b2605d28531757375baf9effe81f456771b9e490eaa42337a972de10efe596e514186e6694800a069c0b700f5d896fb4da6c1399e27225d07e685f6135125715713f14f36c7f5ba22a74fa46a862ad2f443c4ee7aa7c9b0350a195305940e3be521cd73f066a5a8c68945338638028fac95eae097a21c71e88528b0ce645f070ec9a4fe55b987b374a273102ddca2697093b91cd96e8075c7a294dfccacb118a1a0b4bdcb44a51d56dc278f6298e358497bf9b8cd1eba3067863833ad4acea3fae1dba067f6efafef5163e634b145213ad1452c05a5fdd4ed21b7181810675ebf3388dcf9bbb0cf6de64179b8349ee7816f7f12590d423b6be0f17bad8e36aedd84ead3ee0e3013fbaa34cf6727fa295f415f4d39aaa097ef387a73997a4376340aba82b565a4d0ca67a61bd58af378162515e295625d48d3aeadadde456e3a5833520a70853746b8d97b13b74504a015c0a5c29ec59b7668c2f3b9ed4245e2db21349c7a60cbfee2deecc3a70f5ad7219831c50b19b7e4e77b970e4b027aaf6edb6c53cb7225c218537901ca1070183ab5b177dcd153fc9ced6508eb57d6b89724fa89db3c043a5f200f7ae46fe613b8e0ac9d84391ca9e6d3449fcf9d681049620bc57dc9589eaaaf6efaaf37f18accec8fc82c1d7fa1005c443374ac8d49084708186031711b536ed08ac727616c0717d8b00ddccc63e4043dd1c030c7459b79027fac1edf7650aef9286a8ebfc5e5de20639e15c32442103402e487da11b069dffac28004653b69a003ac8ab6cd00c86eb7aa89743cfae5f25be0090ecfe642d1fde36fdfd5b68512ba1ff26f53fc0d7b3c25c665425c53a01c20d413212d0f7e53a493b029792d2c8cfa15cc93c41c620e878886504ca5c4cd60312811dbd369695a483a6d52807d90d46242e534594254e7efa4ba04297148ee920484dfaa8a2713e0ca0cdcb43807ff34249d6544a2c459d41cf4890fab6a6b30239f05b0c06fc467b0d899688b7228e0d845f1e62043bf924f9d5c6d30cdc071641c0a166cd6f0baf379febce76463be617c10c4096022b512e3b5fda1681516df636988cd2615a5093560a44b8591ca43d259e3db336706daa2febc539a0265fe90fa1c8fbab2cc645078c5a79bca9369f1ba296c3762c14f2f4835e7da8cef578de2d8fc38354673ce9c450e5bb2e98dcd153c1cebf83f76295cc7bca3acf792ea6213cfb177ee8e9dd5bd9add5cceb6f11a468522ca2aada3cd929a1dc9f24886953d07af68493a82b288fbf27c2cae84a07fef6f45696e9b8ae4515b9b430890436e8e7a9927923591c8870bd6f78645d77e29fdd3aefe51d7f5a9f9ec96d824fbb6d5629bb6fd65806921320b2f19965c8ce12ace5d4bf80addcf779760bbdeefbabe3c84d9648d09b1fc9fed1c18a2cf68db387409edb068650985e146f1ad207117f6ea74d9cee616afe62ddff72483726754130c79aa0af5bf67aae08c2f849e2c77beb428d64b73118b23cae45e4a44d08f4790616a41e858821b0fdc7a521fb88a24bd16d3383de40fe5ac0bd4def29b2d7f2d8ffa4293159111f92125e9d4e0cd3bca9e9eed3612b5604b07ea5feb085d03732d9bbddfbed6ed096a5fadece6f718aa43757377f77868e93efd7d16af4bf6b7d0e34d77dc3dcfde99566f2c2b3293db4564173bc9e0f0c68c754d2a914a617d3efed2ad04b3bedccd404ab5660a5effa706edafc44ad1f328999fa2504f29c86ba114066ed85fc101f423e40e8846665acbd22c27f58d005eee567c4232f6f44f7d816fb751cc581ecf5a641b6472a928956a92ec519c053ab8636e700679c38fc2286dd707b4e86415131c49c76e0080529edc57f949df11688806ca4ba29e59848ed27c70ebe132a7e46a723b1a192c12463a44b5d371fdc27ad7df7faa25b78b4419b26cfa7c2b3c2098c7ef90891cd244cb7745daf7ecf7a113059622a278195511f4cb73abce032a6d535188d4636ddaf1b748b47b2830b7e17191bb98a066454a78813ee67173edc2e7645f0e84f8625fbc2e8110fa4468cf5a9a4e5c08ff3df95bfd2064ad93f81ceca191ac1fc8199cccab05584cbe272372c43dec318b36b9e2a62b1eb9662bed17c52a885e6347dc8b08fb6cfe6fe5a18b9b445d720373cebbd3d43080e7af113cc47ec3bf3cddb1312f7f89d29f0b3001bbc7e03bdd02730937912998189c25ece1332ad68951960b5ebd8347ae47a08fe5cdbae2aa0b93e0d2aa83bdf213ca8298863914cede4d1d0245b57dfc6e6b5f3869ded0b829330ef9f6a394be14663b363dbef207ac9014e6590cff6392ec090eaec3e374994450bee07d953a1c29c579e5ffc7a4feefa0828eef9b3508bc9abdd970dda89dec145edb7c2ce69f0ce489432fc9ab19641a93e8afa687e37fd76a6a96e528941b9251a23ce57bf6126dc50e5dc54d9a4d3640a011f95d1fba881227ee44ae1ec8534938c437477681878ff1982a766f8382c3551b80d286aeefb0b6f5a6506a948fe3f0abad900c0f1a10c947ea9d03d39b996df60ccc0860acd6e8415403ef06b84bd195f9c6052cb4dc55396617b8c0301fc09db6fa0801e3f08e961b5f0f51d594fff94f18795296ef491a82a9d0f8773607a0f343d88176bcf5561ae22fd5332f6ed76739160b87db5b08883d0ed74d7e361eedb4b6f9b5bc8a3a2b571f60dc0814db40a9c35169abb89192adb05e0bf2557ec0023054710e0ca3b0bc2d852b1b4d0b88ca1a29cf2621c0a7ca4db42bf1838b508285ce026db30fdb1ce8abe1d8f5afed147e8df1404ed716541abebb1a1cd3985cecf5b995c1c3297e36d1b288af4144b830d9ab328485dfdb620be6094bf10778b52f48788334bb73d277226da8795c4aa245c2c6b0d42cec282c558af3fc871a07a42fc8ff4d684a87ebd5afc4a9c297886c8b26c2747bc0517e827e8a197e1330d1d7e69977969bdd3190059272c44ca034b66fe44ab31c98f24672346ce4b184befd0e39e94eaa044162552df33aae501932e8149d637bd310cdd681aa3fde7dad38c46e9fef8ec1da400c0b1984fd423e6430daa338b93947495dde0131c4612ee1bf1f92b6a6f51f321e99ce7a7eecf48fda77259c28fef36d78be1c436d0c0f5a9441c4a37865f2db08ff7c22399e8ac705391fb2a8f6e662e6566446165c17c1fed1d0298d4f2dc638f7c8de0345c764d2691019ef593b03394fbe2418878780db53612d55627ba1be4e93f5cb6c9f6b2265d0c2f4d39d153f0da99e6bc0a8e3a3f5c68bd8ffa7ff07e8a598a990e954b183c08e714f4d759a7375dc24eabe8db654740bde716237fecde057b652ad7a64722a443811d09acdecd8939f2a74d73b839bddb91ae14e31afa598481011209ab728a3a52caf6c819c8f4721b1114dbe3a074720922f4c4a3966cfa38ce2c0210bdd70320a2abde9f838eca84ed7650e4985d0662d1df8e03be355ff3e401eefd014c85928bb2874e18c2472ae22b5e5a68a542e7c0ec17de1b6da93d115cbfb5bb746de3538e49dc475de2601529903c490dede6aff3b1c16e7034d9e28322c599d5cc175084c4df3549b56e434fa4d0fb17e93b34417e10e072193d32b1243059838a867cdf1c97f9bb9f7ae6568516afcaa73d4727c35b12eee7b5a4e402d5980ebe57aa241a3b28141243c1d51bfa790a0bee867123544b8a1b32c1d7a9edcf64e32d50e8f8ac66bbcb722512f59b1d37d59b7249f07a9165f21c6fa469c394a6ef530dda0e81afa06a982b2fa2fc5a019d3843b2cf36dcbb40e5498d7b9640dd0fbb0f6828537e8fef12a9983b284e38c720de6a20dd49221d5fcc2e2a993f8ce48fe72699e7fa38e647e89448e1e8b3cded3660679f1e86f5d617c7d7c9cf54672258aa8d71ea694248666155ee2e80e7950261dc912ca32634556af9d36226b9dbfc3f05aa35b856ea9deb9157209c5de20436fce87d5403053b3c65748308ee7205b6e905f3c1b19c2258cd46bdb452cb285a56b5f1662e10038ae5a6ad8e4e5fab7ae2b9b38cee2ebf761df00bb122100ba08f7d63a696cfc37bedbb96fe6ea1f0414644c57702f17b01097b4fc182bc00dd8458894011bc1933d6b769e4086c093dcc3f615ee64a761441cbfc66281cf8c5a6dabaec3a1054e21e2e7e1545c712ea82bca3a28509498357e694e5bb2c5b3b82b0d9d1ebc4804653386b7981db8c52413325fba50197e499b6ad66f7d943eee8f634dff53a8d8b618898ec0586db50bdd4865e7f5d923f4e81e828467b55ae9a205f396f88b1be4386fbddc0aebdbe89113d51118237b824078b1adc661336d1c9d3136f90c40a5b5b870818a5f4bacc6b31482af1990289bdd3b98dbbb6c54d7ab6e1d747e05b3ba6084a24d44b06a054fa58a3fe28825f0c9dcf0f2eeac39f919990f23dba968350edc2decb4ad4f914b39cb788bd0961705ecd0222e6dd69d0b75b64677ef7a6388985adffc6500551d4c0bbdf9e936519a98f7b96e4a4a6dd2486169d36407d0ae7983ba88445cfff1b97655e0585652f8948f8ebf067077ed948f22fde898308be05f0cad23690523e561010b91d4b909738972eba6c5a36ab319a44b773aeed29e7d7cd78d193a02e3ce472860850e287b2062e85df0de8e2fe0eb4c9beda31c69dbf9e192d002d227d11aa30fdb6091e42def903d4e643c11e360618cd73960c41c9e69713771a1f37482f49dced7e8fd5eedfe0b31f7aec19ba9c60b8349c35a9fb5e49470f7478e2a1239a5c1e5016947969e6c1b125fa4b608c344ed4f69e5309ff06343978d2ee5a8acb95f1d099b3ea8b21c7c20e6493f0a35b3c2b387c8a6edd2e91583d0471d4d9289a4ab92e504b164f466fc6c7f2112813174452b869ecce8348c1b9f122e1ee442c4685a4b148f88cc5984b0c318689bbfdc9c252752a3656323bba2b25c9dec708dc94f7705e08a9c87c082a713be701d424a08ca1dc45bd21992dbb58729337e448a39fee8f0da9404c0e112b90603cd84652a5d3d382a389b3dae5149eeb6bfdc094dd56359369cda96d89d4b192b6f4bea1c893654c3ae1757b365e36f8eb5cdc1ef87bafe3db3f1a078f1e446f0e4fa213d2da5121c9c52ceeda198169fd7cf21687b53392bfc0a959e2890ac5653a2ca99573bf166b0cdd74cb33521a3c923f63bca879c67fb351e411dbe56b20c0b0cbdee4f5c90c4927b207578222885e05696e15d997c59d4e1c2639eed6a47a1f74f46cc039cd7e60feb137be5c7f8c6d5837fee6a29fa0b0c0927cda5bf1df42dbb473628aef4ae61c12cbc8329ace31daa2d6aabffe428aa464e4a3b76c6a16d8836930d96922717a4db75f4ea69177a47a43dd6f2aa8ab9bab15da780f552b194048ff3a980cacf731dc3fed3e32e7ab8963a5863e681dc42641da77a4a75c15d4911c3be8596fb36c74ba110c2264635391ad7bae558a80c69b20bb552cc3e02742f7c818e3ef3fcf36d91e061d5be8c925eaa70a06b6d9090e3920f70c0d61369762835302acca4e7e522318c61bc4d760690b21c2ee58994ab03a476b2eb27afcaa93a6c9c71eb29a9b9b5c29c8dd3c33399206c7065710fdfca8d2feb82575e765d06f147dfd182715fb7dbbe858c18b770cd71a87b9229d63e6ea836802cd24b295cc00ec08f6e9131a4b31abaf08a0558205854426898b047677882aaadaac6bba3bf001b11ebf0ae28fd75fe28f5ca482b36a2241eb4b9d51e422d9812184345af28729e8a6173b4dbb8e49dda3581540a2b0817db058a6d19d7f727df5d14dc1173b1a70aeaa57d849954b6a7efb2f2ee6ed803ec6ad47360d58cfb5f2b69e0103e0d3f0a6a0839e74e3bba38c5dc136d5f7047f68e2b4fdc862342af59fc57455864672e48a609ee5d6595f67faa346a5e3be8c9c215eb0d5f79fa4e734d6048b6c39a781f54e7470af021f93d0159434e70f305f825768737c8db794039cc0645d0cf34d03900ba8e8dfe54d83f4a6bf27f09b63e869d2aeddafd23b991e557d2d7bf9150d376736ff743f6f40144c8b52421b879125e25851341e2893d09387b6b868b9fb1c12b40d90a19b5649509b55a564145b153e8abf216735eba090614d63b6da206984e27bca9897153196bec3ca1cf3a7158201a9479f3955cca4414d9769798d0533d8f8f484f1c6a7e7bcf9941c947e2b8308ccf8a6808f9782a6364e9d4ee729b19e9d22989d9eef1e6664b92b00754ffa8f07e9da47463f2f7e06b9b9674ccdcb205d69f1209dfafd96cb39bd1d744eed429b0a3b4bb6eac49efd828f7ec633def7791f2bc61b1c311d0d85ce87fea1315cb505306272fc5fa5dd3f7c7b8344b97a5deb60780363a713d28f8e64ee17be7d5bccb5e394d4a5554bd63bd443728dd0ffd528a8504870323ee75621eaaf535f6bee555888f1183e6b7b66de20121fce877592b0b801c1fe42cf9b9d6e88c58d780f43c9c3988aaf22b4e6e0fd5b2c29a88eb3689622df044f1f594c5d0bca3931250238ab8f393f1fb5b67885f0fc909f470669efe1358ad014d0e4a7018f3dec61854f1b7adfccc822213915fb391c5d23ebed4744e38d8007f4b8d23302e0ca497fb407f6de942f17c09ca42d62e96f5fb90cc26153c5803a345656fc80e970f8b902dd3cc1163ef659cc72004342630d1e3720a066b6a505ab97a632f304977bf545dc5d8803c769776327264dd9d713b8d94deb29bc1b1664f1c60c1abc6f4bbec5d5fbfc8c1ddb1638d1a8d4a527a60804742870da2a24a6e020ca508b0add90ef2f7b947e6e21f9a7ad900a0bd2b319fa163743b6beaf6849a6725773100bbde6c5f8a855a786e231594596c0c87f81db761ab04df76c59e345afc48ac51e3bea09b09f8b2b27b264307be0449e409998ab6296e3912c22b87afcd6b1496dc0d733246ca41049869e1b995cc8689fb9d58b8bbf90d663b16b8362cd133000eb0a3dfa0713c24ee789143f6a37da309e9b8835c1225cd6497f43f9191b727dddfc623f382239daec42fc3c5c1688229fe64d8e20ec335e133972f0302a8585c6e425fd2579b9c9bdd0b67fb2566cf65cc14e1e025bbd031153add7b581113931933d960b7ca351de0acef1695bf0a22ba721cb3735f4ee13cc48ff31306a2e1b57b5319fa6d3bfa0297c62786950325cb3b31a459bfb011733d06ef9cddee6f5909b62722ad7e4cbb2f83077220eab2ab29a5a4ea90210a320cd96b14cb2cae5c7ba6ebf4b867869a0023950f693639f21f64e53870999cfe82a6da1974ecdd19a9f453db433bb1d5c3eec7bfd3c872a775567669d36d74b7fd1053c71351a9fcb62f58b070541fdeced01d7f66f170a5275d7b3cf3350cbb75a826546f7d8be1b2d03b8f1cf4b1ea569079505524cf476170937ad15778b3c3a1042401781705724f6db60bfa0738d04561f97171f3d44ee0d50c3ab12a8f43a7404b418e326e5c6e446509f7169b2d6ae95dc7784a5aa75aaccfbc1f4b086f9ce3ab43abbf000fdea93b91a296494088b52530c9c79c6e93a6b38924212be5d99343fcc147649621b3dcc0d581a3d92136fa2fe2e92844e18adcffed2658a144a4b02b6396e4b24cd5ebb3333619cb82e4e1f881befd0b2b0e9d2ccae86c90d65989e37d459ee843a7de3ad6c426068982fe58791d8079f30497099484703eacae3b8fdad5e066f0c4c7a74f33128d40642165c3e8e564f5582e77099dff5eb3138a24087cd0fda742253d18d9ca0c8e0a79c22b94ac429c79843fee57a8150a65a53fccae4f4961363a629434795f6f67a35a145c54becb303c8ee76cc69d1d197fc7c1f2a5d618a92c52a529fecdcb3ca9548eb9f10364bee1878fd449c889abe442a55d13130a4075c8ef47e527e15eb4b6b8a0edf40d38784e7b1e7dcc2ce13f0609b8752a227bbadb4445ff13fd0eae24c8f16de5f0aedd7259efe33bb758f0f6502a28a3f57266f8e5d42a884b1f666f42b2cefc35cbc428a804cd910871d1c0f9db85f7a3a5703827d1edd148bb9a9409a67e3a5f10944578ad7368cef9ff4f90b3352df7403b25ca86c4a08144ee7ab33cc196c02e175ab85bdf3f53dc57577f65d4abcbfb33f09284a02800fd49de8d459f6432c5bf70e84de5510cb14f229e34df0ef66a93df5d476f7cbc09d7b2ed41b57b8ab57d562a200f3e1b79cd15439b3954f1e44df6b77c3619ed8eeb84484322d5d65716f2666809505b3dbf471b9a4cba6ae5987442d0665b62ad086a58de493146f0f31493fb42fd1adf72f7a294b0ae6882019c890724c524488b6994094f91987f2828c55937c7c6b91973048dafd695f812c2d105f8c4dd576e761b99cb4620b54327816eefe25cb934b1260c637706b7c1bcda01ce7de77b72339912265867ca383c08807a7fd4b1ead382954ecaeabfcc76d3cf7805c4ad1623896e84fdc6e400eef0dc31db9c3638fd3f2edd75f05515f11eb020613a98da92072c7e33c700f2a868713beda4309f9a61a63976ca67460a118b9281eaf3412ae3b77a02261397c74dc6e744c1fee3995ffd232f2fbe04e229fbfec36e19f6e85ebcc184fa384e18226833e09a8fed730a68e1c4cd191015ec1a7a68c9cbb23bac4dc2d163badaabf96541f6daf5629a7c481899a5b3148962404b83fb6634af0133c3bdcdb0be966c00e83bc426e0f37404ff0158553c63f6634c017e5a87e25440cb32481631469ad9de6b1f6827af5c5ce683e547659890d3c822f824430012cfbe3d7fc644b13dd7a74c034ca149d4249c619f33c868518a3f1522c364186f4d56e7b4b2a97d896f4c4d2917f1b036da97775ac7348fe1de5e74e578db97839de59d3010f20d6884ea50a31a902f3382e3eab1d87e91d9ee392ed7eb455d9db16ad9ea282985b53f6c83f8f2e1548873fc318499217c7cd8aefa759b67721d66b72399d6aef4939ac196cdd792f30cf64c624402772b676685a0143b855829e96ace2a72c7d4b1b228bf4c6952c24543fbcfc334dcee7ea62d4b1ecd49ae1511565d07d7dcafd73e58d8caf9f475dd0e1233327d24ae5f20c084fd4a827b57d91f5672488c011f003917ade60a5612aa01b78ca48b1d2a19760ab89431b41269cad364a0d5b086661348b3c08eecf7cd9afe716b5a0b723d0a059801924464567b4d03e50e7b79bf3e09115f543ecb57230d5f6f826ea259c723ef662d70de99f888b762563ac19fb1d5e6d58507d4bdf67fbca8efdcedfda6a7e880f3cf44138b986faabeb386ec2eec9562e9a842aa6b4652998dcc059b823581b83d8f2058a25b165569e2c50f6c08ae81e61006cc66fe1f9ae6d58355201712c8ea5d5e06c2f14bbf0658e3ad63ac8ca84e2223f48507fd55944eaa43e93f1a32b13d9ec75ade05074d1d2b6018104049c0e9952a670943bbefd2e9d7ccdc83134cdbd67450cab030be8b84a4cdf55c29da6b0c6d05e6ad053b57ac378e7810dc20f0cbf8ff9fc7ab9245a75461f4b70cab8b7d494b81c16cb955de99a3ae67f2a9b3a3e5581b9c243df224d046c856e589426a39a8e3ffe28dac6baa9454e9be466e84903a8d7244a9482d5a0389a97aafc04cf2e01711ad9c0945c0b3ad0891c359f11d20a175c43694e88c93ba85a0868f0422d615c8fef123cee3ccb3d806dcceb364c7cf1f6a5902a82feb6fffd0bdd7cb556251c0af0f17259b28a2c5b45c033ee5d6a27df17b5127d600c1d9f247725f97f24048b53eb1aa36a8cf337eb9727faeec840b1f91cbef166e1aa96d9fc6cc18cc4c8219c419c4a01e82b687fe93cb4f6d03d72df2a663158adfd23904e43557469c2c28ce88a78dc1b9a9449a45ad9e2fac8f6cf3c5a1f73891637c413e7f56b95e97c96ed3d407768cb13fd69bc148ddcd24d7f48c29238778179e455a50485d003ceee0fb06a6595c85f51c6c0222780c5af9fbdc0792148dbe836737a4374c440bdf97b9677f5b7beb2b5a39d57e6675e4e471b9f5b44ecd07db71e9ebd989f4cb31f7c9e091a7487a7baa5e31bb66c430d323a65223f081497e8c3d19c0b05826a834af6c375c6086217b312eabb6fb3352bd70360df6ac87d759ce6568b5b6b09c3c2ac3f946b303f5f50d46e1124f19453b1088341b352c3a4aaabfcd8ef98326158952d472bda36756445ed37e47daec42e1e504712881636f5170ab7044c9635f1b9e30a773169247a8a40cb0949c568ace5088866f4da5f4d638c0a3134f4b3f94ec0138c81ea9e191c19c7f17686a531a82dd65da2d567adf901b6051eef694f5f498021a439adcb04bbe0ceee4a2780f0b3c8ea5a2991dd10b211ecf83859049b630b8ba8101bcb1d927d5f3a77b7f1aca1bc509523c486b185eb1fc85a357392c690b0483ab221c21698cc05a23584c334d46649ab3c37e95bbf2c856ad4557d2354dfa044e6e3ccc198ef1d37bd2aad796cf3cdbff92131bbbf874da064207ac72f0c334a1ef9e0b78fea9d84d07ac4b8643f14fb056f19c16e592983f39c41b4c09906b2bca344d622d4fd5af67efe237acdbd233ebf4952182dbdeb2276aa7b8dd733d928d595dd4c0e47c24cdcd880a4388be97faa72dc5e4c538e7a48808fa022fcf047d491abb11edbcc5f8f5a6c1271f37a1311993e3ccb9baf91f28754feea859eb0fb85c1d48d66b6abb2571cfc9de9687c94ee90961fdc6f318460f044613efcc5b93b6e8dfe022972fc48469487cd8a7b26c9d6091547be292f1280c97c4910ff515523fbefe48e71dd4bcd7b337bc3f885381ec800fb87563a4b77b80159df0a886f3e52dcafa1290a6271f6817f17d73f0bd2b1b7cfa79f7549e584e09bd4f67d8a56296d9fb62f98139e1025475a319fe1fd0bdc485b1d08b9d7c35364dbadee5a361a6cb0de74ffc11367a7744e795af8b3a42c503924ee82826412fb4c610c7b3386fbf090f56de1e6036aa78cb1df24d63d71d678ceebed441a379cf31edb347c5029db716d08ba56f2e11801fb8113bc73d55e0b307bb759efd232e2c8a2d20e25703be378e04da2df8a950bf98a94e8e94b67866ce10b4b35c00b216ecde043b3a1d5ed81cae9af766fd4778d2681dc3d053e7ca7d575e1c3dc99d9561f874aa5540ee93ee5b629464d72f5f800c6e33f5c0ec12edf8f59cdc83a80fc4fd81cb6653844f094e7859c3357416a48bd439e959ba4a9bd761aa320665249bea8f50a5b07fa9d518be62286ef4227adc872621b1e294e94beea38ef941a76253cf0e8ab788bb1e0df0c868e2036c4722c3c57f066f66ecbed05162af17a4532fcc93ec6559b06cc0af633761231e743036786e69970faa81ce679c4d744d4475216d82b5b911bc2f96ff60ea036ba6147d332b37419b64aa26c8fb6424fc4ef69ea0a433118d0bc5ffc275ccb647efe0d59ebea0c837270b7e7c23b80af959fef20c741cabf471d72700377e0f639f705673475f912a7df6a6e8416f9a56ea18951dd35a82ccd6fa93d2f6a09d4f377cb17cd2bf419ffc09ee9aaaf18546b81168dcb271f86c5243a868a1067173b4831eec9b294ea0100c2415ec02c50470a004a3de4a5a9603a2a5de1d76a8b9c545ef5cba84ccb7c24d6e681db267c36da95371a797a314cc1af69a992fd9974a0337a05b6c3540d0b48c49c7f740da2de88fdc3aa9fedd9f836e8d65aae68a3983fd3f30b29daca03c12919ce8697bd9cc491947731a20c2e8690ad927d726ddee32a7a328b1b940ea7199b3ee0ff0b7e079fad391b273d6999dd4d002fffedabc7a2400d7beb654d6d305beb58310bf4be3e37229e5add83d7f9edbc0790c24bd18872c28941b0ab97c437b9c51c479197eeb0986ac0a0342154ee7366876b8d72797de7f0715214216f06f18ace0ec14148479e267f2e6e058febd7bab5ff8e1ec667d1a984f5c252764ecffda6ff855cbfdce289414876fa547ef5558a441e9089959fcf28eb49760520d8a06704e75ef694146d02935719aa46f1a8a22bcd064d23e089589390768ac2adb8650027ac3d8be3d25c9cb2a9a6734114ea90222e7243bbf24b6b284bf8f948f2fbe6b410c360895858c52370d99f3105ab2173c926a977c406e0e9e008b2d59896ea273ab7b83709679f2e84749cb42d2b4576f074c0b398414c24f03f7f817f3ec9b6138560eb9fcfdfac096d909f4782d0591962ceded2ae0dcfb6a958469f98b812b6561e8287b840871c6ef0337caffca8014e8a0f00d75b877e3e8b112803d96c5ab3c4e9cefddda336b951fed4f2d938954dfe4036aaa09fb4e7453ff143ed9c6fb5ddf20c1afa391ab0c9de5847786405f9f053853979b26acc815743ce4f1654d09fd1a0630e7b99a47d403c680989eec1e1541a2b64b9ceee84cb4373be40a6692c237eb7fe61ad4f275c6b54af2e91bd171e8ad87e0a119e5ce39d5640dea01d9f23af7e0e2d96b0ee8e296bc20d68d5ef10705e5df54507ad28b4fe028336263e81168cb7778ea9ca3946536c038461e3edef3a006da0e99839971faa67c86e45b82dc1b559d3f40a3acfba69932e946e6852af1dbf7a10fcea8787fea59830f8c2b82367848995ce06e5e5bc34a70288e5f8c6f01423a95fb9fddbc907b29feb7fcd9c8ef93eebd0825cbe12713ffd28dc84ba1b4be130c82a8e0c00a7419c53694d6d7d2974e9f7c071fd776e898ecffbb246ecc95189973988e2bea373c27c3c68474fd9a6045099d569ea1b7f9efac2aa871cf86c8cac03d4a99bbdd4d04d1b048a82450b41e95a19eefaeffbdd2798dc8cf8e1b82b80459a0eaa620a1f3472f1a24d51b34cb4a83c1e8e94f00e469919557ec47cd183093412aa82f5578ec874ec64740dbda8c22c48cad1217a98e58ab662cfa13bc594756bffa228f9471374418da2ffbeb87cb59cc1d4340ad399124247e089ab48e6a4314f1d85689e9c69cc5b3ce6119453eedbe076fdb755755d70dd5218485eea546d22fac4444230fd052db52f27f44612c3f1f7c89e29fad446993ac1c429e94ea7d7055d054996dedcf954082ffad67d0b40c19e41a90be922c3febfb20222565463361b98bc3eb5204ee37c636e1baf7e7e24054f385d51d77b72ea84078c696373febe1f248dbd4e9816270d43b42982d29d5f461808b6d364d6f96724b327d47b0cf13048c956bb2b997bcf29976de28cf47deb1084819f6eab2b97b3a9eeb7bcd2db0dd68466b269a881248e2d77a7264f55642d9cfbfbfa2d14e42dfc2fa390c6032a2e55b70907ec18215eac943ac980ee9e47ebd0e2b9eead1ca476e13d9fcea79b081446865f675ed23b952f4eec8a831f3acd3ea73e21a00d69e5ef11cbacd13d400f5c00ab02c400dba6cf96239a14f721e97dc01f7070f8d7a422e3006160b3d4fcd931a2ed42244813aeb47555c6ad0cc75a9512a62df0285e7a57558c98ce6873effe5677bfd0e93f9eb413df31d57a9e7eab88a2d827b149342aa1a483bdeed33b4a79f8d02f33710c6b3465955f626af01a869fb3aad465545e38b2f18c4fda5aaf8933ce9c12b2e98f5a8756ecd0e1d5af9be20abea758fcc4fc7860bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
