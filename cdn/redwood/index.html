<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a642f1ea16dcc3093870d644cb2d666143b78e6fca156f1d46d5f900f0ccbaef2f2d38b0f3c80e176efdd920b43c777074c38ac6f7749e27b6716d684770247ec960b7b7e73e894eb874d8928f9dfd149493dc2be5ba48a99420144a5a2dc908070bf661fb8e55970d7b015af7d4b20a9c7503be1e73b8e782235736d6526848d504e07220c44a26d5f7a3093909ff2b4b149e29cc2d0f1f7410ba2860f5d10c7e6d4536b0266c938a5f44fabc37c5beb963d89c613854ac7b04cace1132d70a28808f13111ad4ac506ed269cc87fafefb20c3df2a4b22d78efaa3f2f8096c92c1a1ea2121d64c1de27243b2b00f772b21d1a033ae8a3881efc1906343a2942e128b782c317039f00221bbb38ee4548e68999ea706adde85852e5de8c98eb74de31d9c6ab42f74ee3bdee8417b86df32656305e5c240d720eed69c6a426563b475fd0dd62f09047394d7bdf9c73b0abd3070745b73f0f0ab77250d8093d08a7055d5c7ae7be505178ec562726a64f7d05b00d6e1437b39f99001cb1efb826e48981225ab76df81e2230c50573ed918ae1017892d63297b3819d4562ae0e99158ab291bdc8bbd61d12954544bced1f47040ba43065653d797103a2742c68b47020c1c93054b34a419ada7b9812814335838567501c545d87517b1dd0de1e36dd37b63db9e027ffcb698ce97886d43b8f4bf5af0a2206d475cc1330de5beef83e147be1fcb0098182c48f9e6fea4b03d1b92dc65729e22a7d582f0b28b6cf890104e805ddb023104e7ad6eda057cca651cc61cb4b8453b4b2af451f5461bf4c075dbe3adf53b7cc22eb22830ca36d61e016d9792c2fe0994046b762f1975e85a43ec825d30db3bafaada58c4309a79b8a51a2ef086772778590bd508c5e2d0afdece17f332b56e462837490093370c340933261179a6cf2f11f5bdd726bd15ad77db6cabec61c912821b9abdeed14b2136a219f31c2aa08e249ae44b558dc752aaaca213799039780f7256052e24ce5a16e58ddf0216048ebca2cb9fc625e5665eae0a8668452b4db62d5c2f8ada4a8fccbcac2f1b1ca59e35eeada52ae33f8ebff52530e3a54b7edb882694c6307e39e900c4005de4092600f6392b613dc6637060e348c71c9d2c19d91d7dac1d95da735113e3a2ac79d5d0a7c8229663b748131a33c81f1aca5fd9acea334418ec8c02191091b31366fa2b5927ee0df754589ad1c1f58ab030cbb8fefbdc98ae0686584f0f346fcea2ef3f8fdd79ae01e2759863d22e133df8f25e9331693158096b7b12e61b0bcdb8cf215d53ca3ef1db7b7e8311431de21478ea1978b1b72343b32a13a80284a7f35dfd3a737865821d4853bf180a6dc77db69079d3126e6c5b151c85f8b57af014dd2e8bdb5be649ad496c015d46f1e79729fe18f6d95a8b9838e99f1ffbf0d7fe040b741e3023935f0d8ef4006a2c876edb8cd7d105327d3d193ebcabc305884c3129cea440e0a039109055030a92a215d7c0df01bf1e9ca9b93a7999e1135ee68a4c3bf2b552668f75dadcde3a39a76ab189e64975ad460ffbde816dc27907f7683a93961a4ee02c1c27b4e9af736049f3f428e3d16cce27867813d8dafd2490c049b07bac2e7807f3fdac7cc907454da6d497873a05f9f55d79d2ff1351974399e32a66077889bf29a942fa2cffcd7c3f6cb438699ec4dd50d185b39184636ec081ae47b559df8fd426ffd0dfd12a79ab767c7fb13a23d6a5495242ceff478285dc33d01ba0680443a2df28830995ebf24eeb63fe2d38209476c32d0905ba3f3c78354fc82942ac041c242c949ee9533e6f271f795eb81cb308947f7db4ef72c9d461214e9dc2e9131daab446ab5337fff0373ee888a72843af844b4f4dfa385aa979c189e185fa7586df4c35bd4c12f64f2b1fed89a1779870cd3effb59b90fe4e2b2aa584d86d9baa0126291fd749940929a3cd5f359f252b7c1061909528e80b28bae3475209a3a29a84d1cc9a47cb8d1131ab726440cfe7aac42890b9fa0194ff7f44c4146237240a672ed03cd234db83e9af1b276221d8e72a701633f670354b30ff9a56d1e405572625242a19e4a8e9107256f2a709bd97942b4bb95c2ec10851562906696d294274f60cec8ebe934805ed89c4aaf12134b1c53a2045208afaeed026b1df9bedeb34cb9cee19a4994b6a8a095c3a5fd27c8e9e26f37805064a43f1c2cda59353af014d91e6dfad828d9dd98266fbdc747db57ac67a5383d3fa3181c82b9824dc18a9869ddec96e10945b23b3e1c0d4f15e57df68545af9ac8663e551c475cfc4f2851d955c254aeaa024b4356352652d49d26ce2757886214a1925eb40b754d5f985ec572a45285e2547a6e54e853a0c4d2cb6fcaf71f8505511e32b73c418db5ca80c25a4c7583b2c481118cfc4726683c29d53ad881bc938ee3bf69b204779b600c146a329fc1b41ddccc3d01e662a48bbfad1fd526508551b1454c78db6fafffafdef1e078f91930cbc51353204950fecb5c96b0af62fc1523c2f181cc4678483f1c75e0e7ddca8d61f38c957f7bb92b748dc5bd91d42f39867ace910627f32e033f4194f2db16bcbe0bd5f5046b8d4aa524772936cad6d0582543ffb5787e45e3f14b2e9fc62f232a62c0f2b09d90243df810b7c5ca21dea2e44456d7587dc92d7dc7f145bfbeddbd610af62ff4827968c13ab23e7d0f4194d768afda90f94edbd9c9b6d1fd3d3a8dbd0a7a10ee8ad3864498a4135b0c389d096efafed833845ea51f3c4f7c8b5019058c8be71cb6bc4d69233f2c4f8f27f650d90f7ffd56b7711522c3dfc9a1644d927465f746b76f943d52c019b3c599a049b8664ede9a0992b91f7ce10bc4e4760464fab67a23ea0df670870da31f2dde18b3813aa2f1deb6d8c90b2bb6f47ebed638268668bb9aeedc692d4eefb25155502845c89e9cf87534e9605f12223c001d17e5805443361bbc551aa88a20b23ee045da8bbb783460bab0b3b3cd04719e907152ae2ab103ac89cd3e7e6417d5d90bef7f2b34341021efa4ab4be8a40d1e0f516e03ad340158eb6217889d4c57d893fbdf0e6c1a5821aca2cbed122825d55f28099a6ec020ddcab9ba44613156a7cd2e2f15df543703e0f27b25f6273372e71ae10bf03d709c615d71b4d93b9a8c2796207dee0f3563085998bb450f006b0415642b1e837f47a4d8d58bdf281ab37d1cf1e416e2a56d3afd019ae99f0dab82d9b74f0788fdccd60190ba67b6ecc239c24a58d78e9047deabee6144c644a8c9177a33b47bae507023d9693ea771fd84878f28a1f6cb93cbff89dad5b72e83d1feeb7eb83f5c25f881ad642435a804bb62ecf929eea09599bb3136f6c3c127e5da8ef8398a4628228d5c86ffb3e2d2a11589f71ff17c450203cb4456c6cae68ceb04ac0771cdcd6d573539864568656b054d43e3298d2716371f4461aeee164eac41f89d02982ec54391ff2ffc7a5fa29ad9cdf79a7b7a3165762e86f0ded88c36af37a0ca97b921fcdf9fd4a163917e27efb0f7faec789da3dd6a0a918c7d4331fd675a34ad115638fca09a0aeb85e56fff083823a9d0903413279decbb027f1543c3ba1f28c4db06b6dc76befdb9e38038d9207d8e36a787733773b28613e32d424d4135259da63d872cd63676cb377ec81594f2ac9139171ce4b73c9c44d66a2b37c8fec8b34585bd85e5de685ed7861b0444e8c51742fb57edf61795635a345116d8028c7de55e7a3534ce9aab45633c55d520433f05d161a667f21b6fa0f1e1ae5659d8439c8f24faa85ea0fc81fc4f2ea461561ab7478b17d14daa80fcddca8695057f11cc2d8f79423159e635520a27c5e7cabaa6197b21706c6521ce03203927758c3e1b0224d0f30af1204a45fc3c959b29c1edff5be0f85c0667e859c39e784f5d2830a78c6f8a780b758b8ccfa679fee76d03e0f07f4bc2692bdff05cf4e0e6e696e62ce861c965e87b8af98a69818b3f1f2f0d152a222ac1e5d187279d304809387a3dd4b323ac3d89279eebb309a66205aab10ac0aa38ae83c364b3f7bee26e9660c8b7572af4f3a8c803fabd6150f4c1e7b34d1d2a48df73cdd68fa9c753d87117f23ece6ee30c2ae6d851909208177c536f047b3befbe69af07760040d0ac3b70e92df1c32a55f2ce21fbc43fcd74dc19d81ff325b8c1d4d2633393db707c66ec2abf81b0848835840fb2137e26ef0cb07f731df60d3eed8bff90716228824c579d86f9c784779788493e2ebc9ebdca3c583d1fb424746c27e885ed41a21a3e37bdd3d51cbdd8fc74741d1727d9fd36951f148bd3b35a6cda1df9e71a0d1ada240326d2041932ccb87af709b413d14cbe693cc2ca3de7f7768e7ffbdbfadd412c02bca6ea63d654f14120d1db77c7e0133288bba3f72c6907ab55caa20e223879d5f068c5aec0cb24483394d6b71be9c4843b9f6de45726ce680e5c1a2f9a07031e1db89fd3cbd1cba7e539838afbcfefec740c591977e18c91e777b3567de09a28ea90a2bc0527b179a2981bddcce048e93ef27ea257a45f8ccef12af0bde31be742eed9768e470cef4da18fe4e622c2be9a3fa8d13037f36f7049348f0352487ecc37a22c8f5dc965b5127859e299ba672d9ad66bc597a7f90032fabe1ffc64d0d38907c34733af2f9d0c14b99b1be09eaa8a52572abc49c40b03f78e3b37646020e8ad709a3607f82753f6f0d2a401520f4bb56d37a0d58cd49ee3c9e00fc8c46ba1760e66377182adf87b556e3d9ff1a6bd7aec9fca5c2db3304e9fb90058d73782a31abb443e958c4e31e65bfc2433afd5fe65005b4a53c7deb7218885894d13cc08f30a0f878558053e6f8b680cb19b45544337c91dafe3c1b7e723fac4700337c1e525034b7dc3ebb32864751cc7f5a5d4267370d9090462961ae13e2b2480fd3c84cb26b36f3d0f49153ac8304084ffceb68062f3bf06eb367a7bf22d60861f3eb331902edb45268965fc4ca0a9ca452dd4fddc7c8f9855927b19b52f40298be2cc4616acfff74bcb04a1f27cad56d6c8447544e58f739e09171e6210d8364d7f357dad613146d13e33d9e4386e83e80f0fce2ba767b096c5625a73f4d3d71c6a331b14ab684759dedf9d4e9aedbc3ac05fad92714e24f689d3c6bbd065db638c96c1f7aac0eb9dd45ea1b28eae75085a7f47bd5692e8c9b485e57eb7d6dcbad936dc10e887432fa0ebf40bdd3168d02598ac0082b70cd0c8ad1b159315cb8d476271bbbe3ce33cb3e51f8fd7cca071581fde56968c8487318e6e8c812c44dabcc6ac9c37a8177ee6931c6d15f541ed2cae3b0e1ec0aaa13ce77feae090a3ab30af3947c2cdee45593adcc19f295e875fcab12c832314e53f280d806fef0ca313090ecdacc97af46cdbc79f4f09f5055cd99e69a12f34444618090f047d6793e08fc0967916b970bba81043eac32c5a66bb2da5343bbe4824825c3ab3ea4d2dc1ddfa36b062854ed6070c21a070f5bca4d9d02656f2cb1971072e82814912ef402f45f747933c5069a0107cb6bd86160ca110045bc7866566954f4aede52aaef773b3946e2d7135c28c104682b7c64d0f3b5d4e1b414a906681833db3eb8d8e535601346867ded0205bee13134c0c60f7aa6afa2c66f8f776cd28593da95f0ec35318e2e353baee5719b42c1f8844c56146ff6898cb77f3e1352c31d17f202df16b41fa311a170faf7469c4b2dd506461abf61b0278850c6b8d38981e8a93b0259744bdf3e476a9fac438a9f4c7ee7baa5f0d194b2c805aaf512520752da3b32b509333ea28bae61a97d38678e04cee7b2bd623f6e877be2dfc971de750dfa71d14960fc08e0105553e77bf1721e546837e556539f5f8e2bdb766d74f46431b199c98d88a27a6f061743f632382f61c281c49b1cea90c0bf7360b28d9d50ea7b2c432dd2ef7acfe152b7c4ab94bf7d1311958c8472595cab1b09af7382d8468a1d77a7438b0b709d84c9a41e758ce2df6c9a4b4371e5926aa900c08d9f8456464a14b0e1270a16ebdb40a6e8638adf68e6d2810475ba4dd74bcaab72433a5f7bc7ec1d5dde583fb87aea38c430db6d3976ee61535e8738844952994c31c2359ddd26449caf1449aa2327ba645f0d8eb4d1c4930b0e6cc828ff98d21dd4be1e82a5e1fa7d8564317d5b6aaab9915d867f5164e44f6d48433642335d4184a7ac7d19a966e429e813a7097940f1d4e42bfece67b9d84d4c689f0d03b7bc3db570ca0d39b5bfaf49dcb283599a3edb802cb7c3b20f9976e76f07a94528e648936e38da9eb79831999a0c40897fa04c841effe85dd226a4fef033a71de54061b0fe6b5a0f620a7fd36168e5bd52536347c54457ee0c5953d73094cf015c9803924d0d246db8ed34182aacc67ad98b443b2be7b5544086fc84c47a65bfbdb25183cdd38a81f6aa8abfcb6d7c9b4f39ad94def12fc86e565e86c3552a9d02ec4abbaacc18689fe898137497bc0c8054311aee6d05d788b1e7935b70ce8716531cd68c4e6e766b001a0a3923f3de507645f7d3f5de1af9586b66e809e0dddd78ae74540a5266eb6394203a0525796361bb1cbe30e7720655377fddc4a81cf88d1827af58be4b3fdf6cdec57b1eeb274be398956ba0671865bd101124440fee6d62250aff788b4191d1b80cdde79dcb604bb62af416f9419f11a6f037ff459615d721e1806e62db250b0f3490c6f753d19ab4e439dbf95f2f0c2b7df89d6dff53bb3c812fa5fc2bf12d9aa3fa4e5581d3c02dbfd1cc67c3e719c7e723ca4a56a670ed89155ed29718ea016ab8712ebd0f175eb86378916b8b88373efbf7001e9d6f0fb383299e8ff4ddf10f034cf77dcdb7cedf956441e4eda11a2d24d40513ea2dde58c5b759cf6545a8aab48b2653f987ed898d51bd280c4381de0fc456b1f35ba7445862a074485c2aa8b831f2198b211de710e392bef24ab389349e896c079e4d8ffb5e9edf918060f4dd948f047b632a6ccacc9dd10f3200182f01cad43c082d4203aa287f0fc3776311c8df1c091eba7738f84b849c67c74838a07ee151a6d7340bd654d800f9aa8599b03efd38d3a70eb8fa05e58387736ae58126b3e292d623886917a3249e4ac46fcca47c3c4781e2ab40163877e33f94f775fbeae04282be43d7d47e8e37fcc99ca4e5b1e89bceb145d0fd45f1b55f3647207c2b908a3d55ad6fbccdc7ade21ff10ef59af8bfb817f7e954976453ae31ae6591c8776b80aaf3314071e1e260911f0739860d33d123a2c499a6bc1103b4002097d8e5bf11ff64267abf06f998b3baa9325ea87b3616af503be75267e64de123bea47c7eb80fb3d143f3e26eddaf16ef60393c4d47f37cd726caf05c37b335f438b9d597bd26f15a2c65f330bc1d721e5672a6356541c8004e05998af10643bf3ffa563c64538871d776c8d0e2548c22bfd78981bce60790b45a96dfa47bf09848c51b7dcd892959d5a612fe13786d87abd9f951d3fed5734318ccfe040e7080646f5a7e5780e3e4605f424bb011b1c0a67245d166f0acb5f537abda9ef46753b7e901b5d777c02df1e42dbe0d4ee5d9d98d1b2b827c7ac9273b60a57bd3fbacab11558c549152f525ba47fbd825c2439b5cad49d6786dd2155e0e76650132355f4bb691b98d2dd75acbfd89ae8ca0bce4a3660195a11f86869b1676e669bacfbcbdc670ea7819dfdd676b7b02b5b5019cac04caf9360abd07c75f2d84dba7fa8de650cbcc7d0bb356724ba44e294aadd00303c4fd8293a505ceee5d9fe4e4aa31b5f5b3c243334a4bf77057e55f7cede349a11385c97111c9e0f94f89665718f1ade18505e273e9ba4a25ff70e09a8205e6108658440b696d17587868e628ccd6aa61631c8c54e836a4b21bf0bb44024376dfa8b3a3a30145309fd8386efbef7749794f2613baf9f81638271dae81137fdfbe78dc413df56fac56235893c7463b6a85a29bf6560d1d200ab3b749a84a4b26f95f17509dd1eed459086734fd83332660edbf1f81716083de79d2bf045f841200ed12211edb4f84096d822b3ff0b47fdc08cfcf12d4a44e5d58e7e864df10e1a8f052a9b398e899cca980adde1cd4ef11e20430f78b269196942cdd2a0fc12bb1cc3cc7d9622e6c1525d4f326ef3bbf0a354fab1923b699bdb9edc92bb3808304728001370d213d51413e4e3f0fd5b794c7a8e2a29c9fafeb70960f6bfe3c09bb94862c12d51a649f3ac41e0db75d4dbfd0a0cfc5dc997e1ded4341bc567aa4f2ebde11b21d1846c023e7df18377a8e74370a43afae1c759dbe84408f09c629f60d85a980a09c0fe18a9eefa68df52d8906d0bcb86a1e2587b72fc73a93c5173c37694bdf29af6fca6fe81a17b724359ee5c1a527bf0e86e6402b39057a204751acead15b4f684e119f65cecdd98b90cd5d5b264a4a2e4224a9adb7664fe82631bae79aedd94c42ef1b0d4404b89de304e76805f92bf66ecf24881250a57421b67e7852ba4dbb1e7f77f052dd004e256f9439fad52fd8bd506b782a28d9cb1d49190cf042cc6668947930fbc8118d01729dd8a072d01edb125908e5515cd55c707371255143fd31aeab430c057e78d286fe18b0cb7e95bd9e46e4f8c7d96acaa486c3416537ae9ab31865925c0ae1f1ef0e0ccb911e250f20735289e21af7f1035bd84377c9fff4480a661c4ebb5f77072f5079dca00b6da7324559e78022af62661470c54cfd845e0387338e2682bb605e73bdfa5e406aa9f838f3fdf4f8f75344a42bc823892c8e67c8ac930aa9cf275631a5f67f5eef64c349914e296cf2034712de49b43bd14aff8126eb48957128ab2b599b33996f434d60eb83d9968759d352e9e999b224b1c875fd00944a38e5a1297f2d3817c99f2531f3bf64dc67955ec201dbf33de80f01650472526cfbd4bf085d1528e8b4afa2fca7a55dfd05ccce261a524b56baf1ddad02a5bc5d8db9c0cd1c498baf273065a9f9518afa36619cc0757381fb3635ba3a2dd32cf3362b2300f367aece61b801953f516ef2bfed78239593ae4ecf13e37cfb9535f6d76c52eb72a5f5b8605f9d22118427c2de68bb969d01b05afcd2f3870942a3584e0b7547035d6425d37328480f371d0e19714291a6d25025e6603a6129eb5d19af0beed517940e2b3498a907fc5f6b294c3ae9a5841c67b8145ff10951ff95415bb0816a520db07da51931202975d71c3aec62ab2b5003d5553bd366bd9c4b298f11dbf966841e30af60bc9cc7880e566323a087fd47028b38319aad26f28efe1983a5304b2a7ee355e90c107166770dcebc5ef163d5cebf5868740d2293e340e640a2764c7a805fe4adbe8a230495b6e790e4b4a24edc634f0f739b8565eebffbf7ddc3c3fde194e246d35f9f6d5c7e4dce363f031eae4ec9d0af7431e591175d08afd1f0f37e18dab6cb0f22bbc15b4b86190bfd18f984947d03c762c38b990521cf9ee834c6ca369d54b2784942d3bc551fa905b9990e6a5ab7692c43564413dc35ca72843ff6c376b5fd5f345cf72a1688b8ee79eb146bb3b05496d113a8146f8ae0a5dab10f2d60f7e02614e59a3b8b8a3a152b1bdf3efa94baa25f4061a1a618b9cf46154a2d8625c3e9e9ff14b751945de69c587d19582be64cf244e23f399366e91fb6ff8fc3f1013e4bff3c096d29c852e1f88c22dde7a96b5d9e472c54f9cf7a03828bf719231ba145d5bd7ad8bacad0f48f62e5ad8d12433f3445d128afc844c07af5b3b99218f948b39a2cb7c98b6a21104195a2798f761de834e104e6a36901c264979ff920d7d4f4bf268956ed3e58570d783c7a4b5c2c463219c5143c2acaaf48f9b04da340ed8d8779a721ebd258cfdd8397f82543ae175f2a68d88079ebc337d80d55e25880d910be3fab6c8bb139efee017fcce597c54bec113ad628b760b4299a1455772737046230754987116cebc7282fd8c7726d4cde4eac02d30741db7d0d665b947e48a8a14c1bb6bedc57f111c4cd54fdca769870fbf62ded9ec2514918b2552a364db8ac5c3be325b6ce8d0a1818adc3b6ffcf81129bfdb8e9e70f389cdeee6d4be7951a1469ac641898251b6696749544dcd5fa00b8edc66d9c26e27c1287ed6bda26043b1d0c9d5632e939e7a2388c4c3a56b444c3eb8a6ab1ec7862bd0c528d4e9743f518f2044f4e1a454320b8215322492e46ccb692063ac6d6f8e46d97a618d9ea94ec59034e33f5cd6ef7ec4bf7baacbcd85506e74364d8f06a8c797babddada7c7fbe1b40a0cc1cca9a768ff235fd67937de031dac3db2e3b90dd8088894822f62e8c20519cd95022585e9e199f388192301cd9a4453e68c15517e899bb7cd9f83134ec4bf5797b9341e1567357e0af7c1fdf4f2d609da386ddb28c28e620bfbb6c9b804149ef93ed7fe7924ef66c16a8101636494858c04c04b8f94a1cd385b20f2289388b20793a56b8b987b58554f9615a7dcde83d557e425bfc619f0462f3e25d51ae88b38e5baea4257372db4d0738706be73a2a8d31b5588def23c32d01e2e423e817de1e8e94025ce8929c0a309e9dac540e1619cb7ca0830a3f30d322c8a6767755b29219ea1dff6d0a9d61281475eb37b9abdadbede1a865db4f7e300798f7a5d886f6fb10299acfd4f876647791ac198e0780b31a78c74b9eaa60934da3899367ca2e1921102bd95481ad0b5e576ae53a67362b98d8368c11f4554dd446b909a3c416190c45c7f0368d16a3f77996ffda48889cc2f8d4943443608dbca253ec46397d1874d1d0c672d9298844e1c17e6e85e4dc7816fe83a1a4c708e991de4134135647902626c3262d10594a878f8d5f80c5d1612d68b7b60a70cfab60fffdf30724ed5f709d05777d2d60dee3fce7c55d72b69630969c99e299de7c4595d70940c0e5f809fa42fa5237ea2ccd97d6baed32a5e68e9953d5c43960613435210ff6685d6f24c5fe63cefc5e0817f7db198ae9d1cf4e3b7ec59147ca84829c6cf82a25ee13799970814c300b24c2d2fd5e851d83f401253eebde2dca484d0ccac4588b05ab0c259f92824599a955f12316f95a3429e6e5658ffbed31fbe0338155a46af4c736815c06c521c5fe1127d8626cb06c22a2a4d3ac535ee11c20820405ba380881c01c307613653c1d4f18ccc2bf7619a62934efff93ef782238698be78a631bb19641028fa361b22be35a74c5ef39062a34ecef5f7a77f634ac26c2cd0ecf1488a1af2007d5903809ea8c4212bdd486ad841615c32e64521db6aaec5673fd38b8b73bb41e74052c42414046c2db0a90c962e6bf866be186242f806b7ce7b0409948a3ca9c5e47f22b7cf05ec9b7651fc1417f249680ccee63ff010797c686417899a9a1d3004087b69f38a17a56b8d238e89512efd590ea2a756863f834b2d5a5989d29f7b5b92bdf7260dd24ea3e0f749778c27d6af9cad0c39a615cade38ea30b4f2e88204368d05b4cf16ac45f0e7b4c705771bcac426dfaf59d409d0f4969b4e28cbe61305d137e515392c7a5e71f50653652f64e0503a4af44d87811c94d230d4c0bc25adee9726413ab9cdfd5e1b3c810817241ea050f69f77b68c3c089feddf9f0e43c2e9a593663ccbac23c2aaa5cebb67451bc7773ff339c28c81972867b75a31cf6f19b39a617de8e4b8eaecfa0056cace6d3af4053f968782ac82b0a19a97b85642f019804d3b4ae9df7733ef830b2b5538bfab99de8353388dbbd066cfb50b745d7d1f212bc79590c010e397da12683624f929aace19b363599e78379f53e966f143aa12383c9bb94c1eb30b57c6221e59d9b3c80e8d330f2f8c1b7ab3acc3a5484404bcc51ef15c69e21d8b282a0f9b09bfdaf9a0765721c175645665089dbc8daec91b5bdeb185ce773b6911f5d0315b58a9f6c8e15f0dfd890973bde9f30b80ff42f3c25415ffc614ed009b76ab81db7fd70e39224bf243291461128625ffed1caa880d78e845477cbc39593cdbcd333764fb46bb9438c95b86feb189f0b0fab2079798bfad7e2b56ae873156ef6018705cea629fae4d7f0862970cfdf778eb5ba8b849df6098a2a4189df1a279460314a33dca5ad7b3ebf6a1a756ec9422af8824916c16401f7e9f72647723c5533240d241c2fd53b7e0381aeebd9cef3bda8d693b4c92e3a141692a0e3fbcdbb397f08bb28c0decfb12f190216d12e2978dea57bf36539fc3494db90abeb86b681a4dfeeede70bfd4b37ebc2703c495f6a6af58d36f1166274bdb3844ef08750e3986579797f398c739ce5a7ffb6dd730819b205ed383bb3de3a2b0138b67ac66f273c23c380d25b315e9ae42763a97aa439906ee37a88be59b429796e31755f419c1f4976ebe3701717f46ca3cbe41b39aa41d508d2702c15c762e5f9524584696247b2f76160158aacad90a11260ad434346513b2dcd9b63850ac1bf14b912716879353298991fb56f2efdc23044f0568a0c46c9dc64067bdcabcce8f0b278edf05e9d9d499c97ef2fb736bd4dc61d068847ceca835110541b999891eb2b1a6265f2e8bfb9437c631aebfa62132232d7be100f0ce6a93ede0954ac4f15c2b6d6e5271673ee90fc3dde638ed88572efa5c6dee2ca9ae74b2de7f122af0ca02af4e8181d99efbdcffacb6fa1d1b13f7999446196d7831f217f87006ceade171360a68a6eebb92c80701f185ec60d2a17680008fa4066cdac1868ffcd78b09740233c9918e9442fde343f955a6bfd9e503adde9c27ad0069993e9f90b9bda10a1cc214a95f2fad433babb698e07a63909f676e7c7b3057df1f62db02ec8283ba93baef35f54a644aabe25d88ea5826396566a71ba125b390e252be2cb333301525ce9f2142673df1b54fca9bc707bfefa07b9b42c2c71ee4499d78ac07bcf54e99080f1e23aaee3fdf503ea37d25b6e812f70da365a02efd1faadad3099e6c1aca1d06728a15c364fad93d682c5e2935bcc4db85ba9cde8740bc95b2d68a1dd3f5bd0d25a0cf78121379401431a85750563766e7cbae8a4b1122fde17f69538cab62231fd7feb875268b997e6a3eac509fc1aff02c90e3f77e4589c06bc160ee750b912e96880b1c56933e1457585574bc48954569ed01253b37754fcce88d2bd51b0aaecd9071cd17f74a8b3372292cbc97ca24429b5cfcc9c7191cebcd9910abedd0eefe0ab175a16f312274ea3fc87cd4691691948138c2158f1071d45ad60be7d739a9baf0a10f9bc94d6e49135f5c3794b0505b7de4ce4adaac89f924014cf4ea3ce0ddfc9008d7d20037f3de3bc296b013cd7e80720cb9e0af80965049ab11c885f4b907e6f0c951e45f8e895504365ce931ea0d7f1a753bec760768350c2fba9aff76ff12fde0e37c17f3fa5e2540c718b0e9ef8d43f3d8d2776efaec93adde18e5e295873769710ec3026853d89982b8319105559b72c743b5c381a12b035c8d41dbdc29fbe2a094cd6ec8b1de16024cfca583ac83104d47edeef4ccfeccddfe0f897452d5a60c184523d6549090df045a6e1b14c1805a1ab4c24081bdbb3f882edb099088c99f741c46ccd6000d08e5323219747a454e0db8b82ad19251adc9d134075054d2542fb27c5888bd19e46cf8e588990074f1950422eda1b8d23a306db4d8543f848c0f85a0b238373b890b8e6fa7402252f76abc0f86cb3c192e20a9b1a56aeb726cdf024fa0f2b3a2b07140831a191df2bb2b6259544583c83c1a8b244e061ea4e2f0cb0f8db9799d3e558019747d430acd8ce9f4ed784c9ef611ae8777d9cb448ea93e95288c30ef068eb177691c9c65b22dc25038bb21bd17928e48d0ceb7717023bc3843753c2ba8d36307c1a3f07c100c48f6a210d31466de93bba67aa6b19027638e2ac78336218c4023f26716ceee6adf026f47f19bcbcea4df35703f92c8611e87b5e6d0b135d637e930377b0b5e6eb0b1a7579b2dc92ed61288ef1215d2cf60769b36c2550242a5b082777c851f7193ce1392751e555b20086f6be88cd35351aaa2853ede94b0b825420b01f540eb8a4b35247fa4901564143754562dcae53b4258b5d6a85ab5d254cec9d1b5f82f2de52f03ab903477e8861e2f8b2122228f023781d04cf1892242d9627fd2cc014d19b6ed40dad878b2bb14f411b4cb5448184e42f6bb583fe326c95f109460865c9aa8209a0e96cfaa64d64d8745a6e5a512ba88bd20570bc9d51e2c89daca416f05773a9ce0bd13c213c3d9046f22bb5ffb02a304909184ffb65b48d4ce5d2f8984558dfabdb7934424ae987624595b9025360146022e0e2d390d9a7e4dca8b59c96cb3aaf3f6200fa2511a13b28ef316ae82281efa4378ee0fe4cc9d05b7130b085353d30bbd66a47ef8e297748fbe873bfeaa41f0b7a6f26cf2968487b5d0c53426483a1fe323f3345ac662304a24e853ef9bab839e0d3ecf0c3f67f02015aeb7ffa0bad69d7fd1cb8146815d59f819665f93e0e00f9b85361189f7931ebcb59951abb5bdb53b3dff861b03280c33b5adca7ac4163b045eb41868a5e9ac9d3b89c827a556833f88c7a8dd4f8184ec9b555078c5dbd97d18d97e37df7d8f1e7fd0566dd760859eb59d027c23793aeef2303e4ab88edf829c1968c2d954a1e06e8ac913039057f6c820b78ddeb3d9917969c2f93c4b2f7f7b2a236fd7f3f5ee7f353aa9dcc09a59fefc64f89b137fabadc664b3dd27f00e726661674602a3769af9801490311d9ef03ecdebe73587e05e3f274d7a70574bfbceaee9a245a51de7a997eedf58b397c21c80eaee517fc07775d2c7aacb02ee8a021eea6a69dd297d25308a569161f67edc759eda1c47be2ef0226cf94569984798af66037b17250b4a9214061e549adf0385147dea93bc8f3dc102d239281e2fce2f1bc76595777dfce6a730248f8206a5a472ec1bf8bb8c6b63d789c7da63d05b43dba2fe53105f682802bd9ce1bf57868de12b3a7a4bb92cf1ff8367b650985e2a873b19c0d84b2f7ae747049efcb91510606431d43d36ead5f4b7e668ae6cbaa7c983503bf81162ceeeb83cb93958474a55be2d7cde423eb028c9d12e91c1f24ebbc896be753bf8c264693636a9c09d3e4080952a7109b659cd9cbabdfa6d49f881189bce37ed6e40c0da78542f82a858b2da4a7423937e6ecef2cc24275fad5ec3642c8f4536bb2c514264fc2a35e7200dc7c99df899658f3544bca21750ad469ac7580447fd365f9f2e666c4b62ae09f09739c842f590e99fbcadea542b952fea716d46363bfe3c5150e223435c05bef109dbad8b9580985a9da2b61541595e630c19547bbc09e5f5e2e966412acfdb5030b33b0174ec50da40a3b73c879d81cba1106620ab27296b8860bbbbd54b03a8a3f9633e3f9e0bdb7f3b7b440f01706ad3fb7f4f17d992c53abf9d73a344bbbb9749483d1303e8b83d94c46939d83ef2579a336632f1e94ed9fd26bf2348d928a66493eb00a0cc676f4b24cd167b658f1a29ecedd04b69dcdc1ed66ef030351d52d038a74c8a9ff22c5544b7988c3db4ab608587c5eb64cb4e8484ee89a0f4cba14936d9022eb230f00059a93e14468211860276c1c00482557f8a10653cb6bc20064735f8a80c5e336018a3b0056149fdd97537b0213719e08b57c76cc63ec9745f0ebb7e6a25d6b2e2c410a7b4458f6ebe940db2e02aab99f74f8c8c24ca791853f567678d0fbffef12b8597f5b6747c9c904c2fab52324a26f69d188cacb412186407cefc0706dabb0563eec361429019ba530767cb57a6f80a134b04663d8e9c40e3b197fed4f9b34e9b62c6d3e04420336d3cb9f806d90fa985a3e548ced89aefe8962cb50f59428bd006e076af18f8b395334b3372baa6160ec23c7736848299b9425d8b52b6d6974032369c5014813b629a1278bdf03cc116acf76681d404218bda604392b6298f50f485af6b9f41fa3db99793e3e8727f8b89ca05b5df50eca944bb0e4632c2bb2cbb0993230bf078c87624b1034da7a7a33b11ce67f6eb256898ea095a1ba5348abb9bbb0a4956fe52109033b6b7968bce1f051df5f4968fb926dcad618d0fe48c01225156a96b6bb6ead1143dc574da590ba2529917235e6c4d5e00781efe920499ff6155e2182e28a30cdc86dbe41da52f7d0380b409bea39c38e0f710c3614081deef5fdf9dfe4f28142ba7571792547368bd47af41c6766f6b0c0a8da2162f2439573db6d9b46a6920b64a64d3b77b8198c31ea6d7cf2b320764a41ec461e74feef9a512ba72a99ec40a34190c04a91fef871db4e896e82459454545aad3b53951897302c1ce569d413101a5028cae4f14060a80d198b751af27f3e6782f4e3c8ec024e8dda4a62cc29e7d30a7057f36d834dd0c07b53682e398b338b1e040917244ead6e4e7d763b9cb4ee77d0c8bf9709b52852adaa62a8fe4a0b74c2efd5b0f811ea7dc6d49466026fff11af08bc553980eb6fafe7dd32a32de7a344c110ced30d26d4351d96483e18a3bb9ed0e9352fe155cf3a178f8c7a7f2c093f6965d78370b5bd8544d99ae135e28b7d91cd40e3329d0c99cb6973bcafe8c0d2e9fd13bf46ddaa73260394bf5aa890b76b2855f645c6a986ab5709f282b0865728cf558bc6430960f924e1263c3fb295c030df1a00a5e8a83c6924e83937c0a9d4b760adacc0dcfed015680b1bc9f6b3667468cda933ec9834928f2d9968ade504b5f8368d0cc80fa2011c6602fcc71d5f02a27d5a0d5cf8e34176e13d04bba6fc815a2abf7c032d385485e1bf75c2dca4a4ef9220904515618340e74e674e07c6bccd88f83bef88ed1ed7daec805a337fde3c4afd4995d6eb0318de26a6e7534af9522d92174865e2ed9e4ec0c2de6e780c779708ebfa90771bf4813244e1fce47e04e46810150075e78fae18a737d4eb31c5d7969f4c151ab08e48429ee116d71ef6f425dc5fd2380d0c1cfe45c5065bdb3930f178e399d0a2d3c2781cb465392db7534ae2834dd43aa68df27f82e97795430d7fe0eb030d8fb2ba174b4f725a3ecf4a0c5204f1ff6adb26cb935d7d48285f8dbc5b218ff806f688c3491a14d2e7a232a4f2db254fe68868df7578e661b50ce24eb3b4065e35ecffcdf31cbb57ccb172d8538593ce93a220ccacb10cc193a41401fc3a7573b4a0ae439a490bcb25ae28a98e7fe82da7977e0de11671e5cf67a0ad0b103f0ca17db20b31113a0402dcea3728f0c56e86a91977e23ea3fa3ca66ff09fa83ee9c0a945f7a9437fbeb5dfa55ae635b299c2e0619cf26610b106b84bb29f3005d01b16a8e92faa11f9647eb8f1dc0f18b1b958e7408fa36c899466328117da636ab2ac5e355459049040e01de02501cd7043b2281841f03aa02d238b77e988d959981f03565d67cf151e953972ed4e2860a87dff844fb4b25eb8a13bf73aac0700976a3b5f99d54b6bcb38ba2377bc6118cd32f34a3516cc58d2613234ff2477d71be68a04115f8e040559f53fd3de81871723e2b9ffb59de845f53cf9034fda01dda4e8b597f44982b2f8773806573284e6ae13388e2f60a6d636369e9ba277d47c1d86739cbe6c0c87e4759891245309484dccc9e4b4db602e8901c89097c5ad133378729e1e1d001a840050eb543136dc23b9ad24c4e72d825670018691f1ab3e5b093324ee1a5cabfb957bd3529d2c8dd047400b8f5dce3613056326abd407c6c363efdd75f842c3039e8eb5629be592c20011732cd79de553f2c9dc3343269ed932c35158ad4497a9a9bb8e7bc045334cd68f211ce32b30ccd80e2463bb5414a15865d963a9765258423fdb345be0c37e4d22f28bbcb6e315a93b8e4faf60f48e8ee39cf4f137026fdb1aa30f1d09c0a94a3abb67f7dc61a8808fa09d6e157dceb3c0010591b49cf3315de3a176e313dcd6dc53e70f3f80f007067dad9b41d1055ab45185aa78af31d1cafde9b8289970c185a7e49f36b122fbb4cea428e890859890b439cc1ac2e3d3759fb8bf913fc5db5d84f0898c203d5da768202085673746193fc9a2a20def6248149eb4bf9ce2196ea8ca0fefd7e5f4a636cce9e5b12f3d5f0991d2a940fc11c8e997a3608ad3bb2ea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
