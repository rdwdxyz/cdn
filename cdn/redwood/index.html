<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8c20427a6ea1ca96068d74ee0ad30e6ee4721c03f623fe474eb694d5868709a7f2077565685346841c78a041ffaf0d3890bb84d3a1bfea4c536c713e23487f6d74f196f0bdc943dca997e0b3c2194253150312d8a8263f3dd147e3eae240c953d79bc178aaa06d84ea56a3238677d6e2391be8c4e90b8878af92412cb9fbcf30ab5b618c506ebf7265b0b0295065ab7929024c2acedbbd3d92aaa4582131a940f1d54732b5cd5d2da8cb7170e9cc7927492e849bc903ae6edba3356a5ec72c63a4a09eece18ff58c83fe0bd3b789512e47ce54a4b3849cd6fc9736d02e6bf0293fe17e9dd74633c76c12952d8b3a0c5d82d86a759a043f287bbc3a40aee301b98291b893de70de1b4670e074a014365b6324b62a3063c485454e51b695bdb02761a8c436853a84f43bcaf63353a46901646a99e33ea195d07ed0c9719a77d5c8046f44f17cd128a5945e494fca16b7cff2d6b2a0899ad3b7778b7b5bc47a410203eb13d6670fbda17be8d3d34bdc3bf0973615704c3db02b73d9fc750cb8d89e9f6f86e2146a322bdef9b71a16eed9beb2ec364d46d3c8ad2a036544c6b53d9487d148bd69f35377d6704f6161811ccad01775570f29c52bb0989898a589143e076d2bd0f3f94320c819caca47e7f41e2c22a3bb09a22e55ff2984bc3551b153b8f91ad0e17823f0e9b6952d774d6017192d9d4c34087efa9cf3ec29c935e098563a25c79828819c8b06ca707c3683ed74643d3b5af104d822c8def528ea97db30718e92d1ca85134f1b31d80ceb0de56f7dca90fcd0dd54f1d106074121aecdb26e918b6820aa3197df35a7c9a9d472759d2c43c1132f8c9945c83cfe75cd1496331901976a9e33af290191000aed090a291219a42e4af93384b50aa3b756c0ce8164a160a2532d47c34b4123113a74f2cb417e9ee8d37eec078e0b0ed5a423ae4e76bfe4a8fae6228f7d335ff6ca6afe9500f448b37513c22ff15b7fb58c3b902ea55ba22af543bbe5d199dd8c81cc71e00600a14a41c348f000204d60a620dc80f8552debca2759eacc9f8d89abc00dbff8ffba1cd970e4a4e4950c141c441ee1362211aca1d9df149f883cbcfdfb527a0bef95adbff6bd4d568138fc2c86bae8856ac951cdca66bb5097536bcc3c503d0bd4d4eb8685d265295abb179aa490da7a6382085e4406c8361fde0f44c6bb8c0bd29cf5fc852d33738c6e966f3be258ffbb766ad3987d46b7f8decd6801b478d0a3f30bcb0689f05744607a4cf8174b334a1872a5a11bac944b0204f3e9da823f04c8563331141aaa9eae95b4a642e344b915e39e3c21ac0a3e6fa81fb1e1f4791ab96e7ceec4a1ca2900e25142d1f8b957ec28d8c06d9f7e101b79c861b74320194facd0f24c8efd798dc18abef6f8ffac8cd4c509fd03b95596c20b97ba7317e60592b547b4a4d078ac96516425d080fc68d7fa7e2a9806a07e9189b1a8eccabdeca9c4db91adaa0818ea2a2f2be3d33fbb995e8961ab013a73d7dd55e1ee2deda2b83a7768ae5730cca215e3a937acb0c0d60c089aa067651b4f9dfe8c718f0d08d9e90b0428df151dc3884104fc0364f14324ca6effd2f13d1201ec1284df282eb001c40f8d6786f56597b8040cd2f0f0b2191a5551955ca0808aef985da3a0afc23625e44976685fa87840334f8cc32f987f021b33097891c2ad4d3821fb0382d3f2fd6024f1eb667e07896cb66ee8254459d5141478bb8d39b22ac8dc4e773c6f1c8d71532b9fea0b17866081f0cd5e4d2a148be9e5755ec829e54bee8d17433c24c9d3c6231ac1ae8e82e0fad48d1bbddd03eb6a55ce95073150d8e2d0e3b1217bb222a4a3ae996b48b19a362f33261ad2eaecd341b0a2a8d2a749f4742f0ebb8a02f6fb3740b819b42448a19aab1ac47a348ec8210a7657ad095bb61b72ba69ade1f6d877c60515e8c738b298c9549243c1e042c9deb416a592434c53b89371651e1538616ec588e4b15ea3e5c016ff21a3a511428c490728e4aa96ae65c52bf615bc7996851cd190eb4ac882c1884d3738460efd68bdc861085ea0a2033f7d26fce2571d5388b912e73f7c5834ddddcafac83bee7886f863d9a0e9ade49f257781f0221a72436b07ebd5d68a2c01b0804cc5ecacac227f4e8f6666cdb0db6cee2cb9eb6ae832678a62278e3be522eeb43b0ec46aec03a41f7a30666dde1c20cce519256da791e5210093c5ca40b1d16a1628d084216eacf54a07d1bef207709db1cee664467fc52d3b29db1764ae7f2e95d8dd5f0f813f71ecbd6c4d53db93b1f9cf71fa9e6a3d719f9b72de203b1899c019ed1f009d475cd1fed8316787c9eb041fe8eefefcb0aad18c67d54b1ceb308374e11278e4273c73f8541f0a071eff3ca17af7adf9714995a8bc05e81eb052050d11aa5dabd7ed19c175ed4fa36efbd1cc30b734f1bd9787e7d7800738608dd208348a11c800dacf0fc111d841bf7da214a29513bbec4b3e3794cd0771735e31425f0156b71a1ecd21def43525350070548baffb8cacc01b71299aefe9701fdfbdfd63e4efe4e559e91451b9c9ff2a4ece7354dd3ee3e8f1ec66a6095dd40dc422ab49e44a87cd64eb7205ff8265e1384a0ebdfe217ea92701f90a09588f842d9f5557c66b26dee2d5dcda467774ad2fcd45ad667cb456191c0ef0881f11ee38629eb4e271eec718518336f49e4acac502c6be88e504fc6b4a8e66d46c93837a9366bf9951710cbbef13c0bc6eaa032d8e6c6ae1bfead8ca9c98d8dcc56f96cafcf8ee6fb5390deb704532a7f577882a3dc2705f3bc56a16391ef72980acd956936bec0a82b5bc36e06ac05673c9e23072caac6723da85c148e739a406c8b1c73a447a8e4596e87fe3a1babf0dd61953ae85c11a56bc9ad9d7cae808602d3bd3cc37b2e7e1dfeacdd39581f565cd970259406dfbf16292142b01e7a92655044a3cfd877e953c90e23285c19f2f8cc29ea248acbead974c7fd82cd7662a083ff7e927bcd3e8dfd963563fe3d1068b158b1b1adb0feb9921024c6880c0c9ecb2abce001735f93a9c0ade789fe4ac334caec40534f32099c1fedb37e298470c0b1ad73a814e81cbd97b57708e5b94928ec028e15b3098251dafceb3cfb87f508dd15a86da35a12f347a5355cee5ccb27fe1d088ca0c8a83adc845867566f34d7d4e7415f2e399d2160a79284a4896c751de393e619be7a3c1231582e07f5215e6e5d5125a5d5f76a3b27078875dd5b4c44d6aca91c89ae2af272d3ae0afd063f353563e4b4ddae29e36828dc570611ce5a94898d032eb6a8cbd46dc5d28c2d6ca65b34a4b6690504d01dcb603ca9bf6ef9790afed51844cb725634dbf1ec2cc694b51d80c7910fedafeaf748592e0f9fbd0a939b0c74c9dcc0857adde8777d168aa427143a965a44c46b198f61a4800f3e03cd15fdf2a0d23e82f6fe107cee44faf11c3289932268a68e11bcdde83dc326e9d8cfcd9b50eef73ad542ec8bad7b33fd66dbfbde0c64662756b7b156272c94b63d4c271f9446a8b0acf88174351a4ff8fceafcfb09814c4474cb823ea53822f710f43daec2de52e67747d969056d7138ce37a02d3588023e461cb7375b550b4fc89b5aea6d4eced6aca8f065b519807e92c227d838747a544746dfc683359f7cb60cdee5de4fe1a46f1092be6cb7efb5ec287aa1ac2bfb7c0a59cbf525f3bc7d46718bfdcc7c3fd2f9655b5683232698bcbfbd77e776e02ecf6d4872dd6297b7ff7eb905f17afdd82fed71244213acf50070e9ae71e90ff7458e0116be2925d0cc1b2a8b550152a20ae83227b23eccda0d656a45dce1d172e2dca7948e99f879c9687610456b116d85fa8a08e599bb8d33e651c36eb33dde836ceec87bce3160672148e672045064b5837cd76916b667f0493f9038bedf9177fb3585b5209221c8494614543aa8fa3e4f318a05f592b452d5b62bc678a02350a445060bfbe2263b15b4cf07bc22724af1dc1dee63700f10848d9164facb631ca6d4da0cc6b36e6ab50ae82f537aac6c279f95e4100b5200639d86a613afcbb88f1f948f8850a10190619abc6ee9994620c48444b38d27bf2650dae6b6d977ac8248c9b355ec906cde51eed14c4926843fd18210899c1d78dcc7a57af639c8418014d0aeb9e7445f880ab8b838fffef70cbb60f7d3b0caeb8437466a12235ebe32ae0a316d38873fdf0324a6b91bcbc11aec6effb15cb76ad01f5c7caedbc5380880a8fc9ffba23ecc70f129470d7e1aa76cd911b6d8edb7c623fa159c4e08058e3a5a6d76ca7cc390f17310842b82ddc952de960c31bcc1c3dab7e3682c01c7b90064235cdff15fbb0ea0377221fd1c79cc26e0a94c5d5826063b98aecae16825e526ca11b0acc2ab915f81e27941b9772f18eb13f796e696e361b10e3be6b91c53bebdad7cfaa768bc7236338694b57261bf75c825e8faab554e34158c16773ea34bc46045fcafd4cdab04a816880fd7a12e36655cf536c6c0b20754ce7858073df8396c5521493d33bf89581517e81022048dcf0c6ac13f17a2100a1a9370d48c8d0e77660415c74eb988da424af513885d1471661433c50d17220ea74e21cb0e6bb3210a699a63030ad167eb4e011745a4e11279737015e3f7ba34a6e7d6ad7a74f4c2842e7762d567a7001f84640c4e3b279b3fd17c289e210564490126bcb39940aab2aa16b3ac3642005f16876fe4f87c5753c38ab4a36500ee3c90237f77df4e69afff7ef9be790fc152cef62035847560fef6f4b8699b1026116e722e9a6ec1f7672ad429fc05302231611f20d5bff56ccef7438b6f162fbe52d6d4ac28196cd7f2993bed643eb7c0b53da858f1e27d7c3072da7dc3d652eb5cd8e675ea3062793e392812065cb2db46b10f333391a36f97e31102736ffc82b4075d9b71b532b9e5367ae1d43f0a775e6884188f11629c5761b9a37787b52d7c9fd39ac3857310c16f6a863ab22012e079f9c6cf41c0046e6c9b5ee2f3d994135cb437e180482604b4fb6c8e263976c9b418aba773c937bbd16488698be668503014d123f56e370c938a2a34a4f9467bc36f74f719448032df42875188170084611985517ee91a80119187add07a11f81556b8e53968ee2ee4c320316099d66b4fb68d44b486929ab9b5549397b0b0457416a170be5f6becaa942ea5b02b51f4b4bc0332843a9f263542f5e18a9c8020cfd3a542360ccd6d1b9536da521754411e915e2649e54d43e0bbf919bbce8eda1f017108fd11f1d0939de249ee33a074ff19575209b63cafcb2b3eef033a9433135db77bed01dced904f906721e4dd097401829b7257810b04c166426ab0ff531dfc61b29a7a0ac175b2cabe1087a7be3e94217d9fb4816cef5c32a1867db8f6f52b8f89b0e9e0d74b185df7905ad0578b691d2b4af95b948ee69bf71f93e07dac7372dca1d5dce818713b32404f9e04665d2fc77322589ad936bc18f2993ad8d9b378bdbf08e1e9659a9c684bd6cf37cd0db7f9da8a4f6c3b62610a2ee7f3e541246c21272193ba41cd2da0d882fca9c59f2098ce30dce87269f5cc793ffb099eb0c5b79cc8dc692f295bbff50ef0007e187ad25e9da476f89b52ff334b180a989808110e03c8ad5abd435b696176b56462aa829f80e46b771f813c15f38c3363b533aa5fe94f9d7066e61f5d7fcf5e5e5f2d4897bd42b33e13c8b9c8c2fb9e951bb57c4d769a6a673cd2191754d2f4b8f892d3838600183c33cf0b2b17a6347fb028d2ccb7f9931f500d07a081fd0ee0e52a5a703a2b2e8452086a68268e0c3960ffdeb52d22064f3cb6b2333adc84f2143e92ddb407a3dde3c13b379f6d92f9b7201b6786e31a9f24e9525cc5484c2f995d64c8a937ff419205ca79d21271d64d969e338958648396ae02283efb1f7b41702c448c296546099ea49d50623cddf817d091a59037d9f2a6a31d5504c65c20d0311c02bf8a31bc2583c65ba3ac5928fec56025ee1252ec73c6333c8e8b38b1635a2c7149f551e1517ad8187a8fc8880888aa8ec77e689b0c2fc2e512219eb973cc53298d85c796053869fc7cf587a777dd328371ca1c3db67d8e60161324749e0b77b479daafe6d873c2654f8b60a4d2e22dfb48490507d97f52814e458a9713b53227dde279be2e24b8e99a69eb36c9277985d94aca640300fd8194538f0526f2e500dcb477caa7ef246d55056cbbfb2b332868193b3e6ac4f3d1c9897bfeccd2b78d973e7d301fef34d16066abc13d9bf49938a10c4d2776d506e6626c98dfc64305e32d0ded8dc22a44ada9c2f83e7e6abbe42ba9a12e416dcca44730c6afc7380878f7153bf4b0392bef7674415039e8ab226e2f188f44de4d3663c13b230b0557d86082f596ae6aa86336af374ac4643b1078ef46f9a54d1ca75f386640eb143826dac0939df5877e24f0373f70ae3f36b0208ed6714890d4cc0549921e32c07a4682264a81a0304eb994dbfd16a9918cd9aa70b3b5a211ffeaa3b4b07c7a9b925ceb675af118142c59ab5560615db59951c082f81fc180a3f25c1dbe2731865713e6e7f0bb99b1a66ac28ad28560051782918d2f24c70012ee2e2c6c172d9bb5ef20119be5d48da2d7a90e6b31697f5874cd2fda30b8e33efa31a6ed97aea0ec022ebed3427f34d4f218f2019cd5de2013d2333a7744a316c4af274558f2591084d7857c1255b65bddef7a49fa9fa5d0d16f808e2ebd89de69789c2a50915b2b420200e0e457362da7eb5a53d5321014829f8a5904b1e717cec0913104a3cc7585ea22f7991293764cdbf3349dd9e157fd4086ceabd2c57674f4ff5a24a8f3b8d475eea98118ec694fd334aae581f9d18f86ad088283b978db7780a521b2aae87d0f88b34dd3e81b3ade792c59363710dface13875bcea529a3c43b1d081191689a985580f73e54278e08dfa8a439bd986f805217db39029055d775bc190a4363a5d3d7599362d1638990967825c1f0b87c9930c7639663fdf934adbffdee0d6b97b6d18ad086bf7c58b5077da306a4a5f2e41ee0587bae872c7da9bebb5ab56e268c519c27dc7276acd50cf1df5f8541ae47c8517056d18c69f7015f0d593e4bc819208f53ef7a561e8c0b61addf76097c9f699828e20228461d0fea0ad87d1aabb0e1d0bc681bc9d2f9ead142d19c4fa0a076be30f87d3d546472745af88dc199787618900b2d91a8438f5f78517c2ea28014d1019bbf0b7892470873d96b1581783875d94ad6c08affa07ca9417e0ca43084969f62566f2990e9a5a3f7a0a7988d7676626c63f48e04b793985ca6fbfb35c41d740f4122c3b5b37f09b6aee53b5a82d5db2585cb1dc52739a8787bb93baf6a3a927ae02484b3b62417d17b354c9595b40ed85539cd68f2a2cbee6682c8628654ff98d3eceae73eae236137707ac604f9c304614c5093fa33c9b0595237f15b0d9b180198a03694db4b17b7f75c0739904e812a9cc9eedfdeb8dc3d5e46966bd386448558684ac09d1db153e288e3d69d468b92f974fe62867d53816a65fcb9cffb24fa13535c813eba4fba5d671a39f19ae20c56fabac482038d1d992302c26131331fa57c16c88fcad11b3d07ad40ae0cbc1626aa9deb834cfef910a0ec192e94bb0d26eb0c2c18192b541f9747a22871aacfcc3c70e3c1df72e7b2838744541caf48607ba900a5c75bc1e52d6effed2c8e2fd67dcc0d9db3290d03437d46175a4fc03d9bbc74cef30b9f43d1008c807898373627ea38c5c7b721e5a0fb4732caaf5b29b9b8a22509932f939543e1a6f9b7d6ccde6c0e793c2b2c9cda8b863cd8eb7631ef7241bb4bd16a3a99da5bbab3a744b6a6feaffc546064ab0fabbfb8f9bd7a10955958f3d4d09337f20314498cd58bbb3e16c192d0279a246e76526c3467d7d456329c904f40e7ca8def2694fdd79b255ebf7035bc0c8f127f7c29132ac8d12c1fc26ab6a381b44d46b287eedfc58b8e750c8368262549cdd0c5e4c816b13543f669a9c147605af6fc602d36a2d57860ebddfaaa72055089021f07ee5c96cdc90fec79a79303903ce28348c3ab22cbbf5abaf29093ea5798dd6d8882126b8cd6769f69150fb378cbfc3debf4efffbb060bf9d1e3d3af49915c2267e47a5a29437de18e540190497bb0fde781169b024b8bcda00abd65e1f5c87ef91ce5be62e6876e73c4c23559708a251180d70a562e4e1670efccf41af2cb004530516fc7f85fe9526ece4b9a1e3652be021c17b434398642bd0751afda0d8b6d3f9f51ec6bb6969fcaa93670961c7a6d5d95aeea2912ee6236942dee17f5f507e92a609441b3aab4088237f68f252202b684a8829fa0937b4025e31887e53222f39fbff15d2d479223af82c061d142489efe7c01cdc42dd16dc54395615525225371db609374a2280a5b157fa05f02d47736e31b18e21d73e7096e4ce3c818a104af724fc7f7d2cde94cddef3b5af93d1f83297750098116ed0a7a82e9979a39f6576f08fcc66f303f0cfe81edb8c4b1481b0858da55d936b2801d0f84f836e85092801c99b05c4d56f6d27adb9a05b1563a935a5b057f919310f1cb6288c22ba80e6c7b84d1084ee5b246bd261de47b4da0e8c345a9da261ea6215e0ca3dae344ed48f4ebd85679065307248939082d41cf3767ed18cad3d2310c095f80b9ce9ed242f58c01e6250325620ee4bb1720d6bddf152f996cef1012bc4ed45c774133f59f73e900cb44bc18939366fceb30b2c86e0a9b21feb6b2c60b4d59052782edfa61f8c2bfa30a3d7ef253b942da9296e3b133aad1297b8bad8c2700234fa3face386b5221f69428277a255851acb13a0811f1a962a98a4287f005dfdaa19e4dd49912c8dcc143caeaf410d7bf08a268a03dd49a22e6fb989b490f52f6b7881d212dd29ba825f1208060ef523bf160c7fe7f8b6b78d7ea205e45641c95ef786e2f2d6a8481de292a881bf6585d8fd276ada90f770447e9af9e7ffcda3bbe0dbf523dab1158a7fd7414cb57564533fc39c605695c203ca772238d6fb3f747be549936652acbc46d9b67d3e7c2a0a5fcd9cb70c758dd8f9e559dca2cf2073a1dbad41b047cf8897ab2ce580b3612dfe8b76d46027743a570f8e6454c8239f8b4cb7957af7a0a26dd26594928501b04f5048449d216cedc6c68632445c808f4fceab8a92d8182d93b4aeac03d91757263c3248768771c86800705a87c15317fa7b8d4a64762451c5b04c96209d41e1296c824cd0ee676451fd7c8fe4bf7da6427855cf26bf4564b2768c1611d2848bb2be7358b240663528b6d7fb1c29e0429ee44222c1021447b39e010e7e2ca5d52fdd09a1ae9b7aeb844defb4db539d206e0367d39ceba793f46cd100acdc610165d2d4309e3b7a7e089260513a22fb4e07b125033df7443e2d36cdcfb8aaa34f3df703abed820f7ee934cbd9560ed7af089517aae06f94eb62418ce8c23fa2cf72d0b9e5082e2ce8de2a7cd78dbacb2d393550daaeba4e75736d7ce65a33a2857853d70dacccb9a1a88a5eebdffa3c0d716ae64c6ee51b1409e21adfb53207d807c352e6ba12f6e6d17bdb1c7f66bcf8289f0bc139fc883fb136b76f8a66fdd07d9809766a47a0054670867d637340af9c8c3a7ecfb9564d5e6b79b050e49cc86a9fd811785a7f721d06df8572891218c4d98430009ff25f4716de064f6ed6e50cec8d8e96aa9e2dfec6c8ff1298d445ad5ce3476389d20dce9ae95e7dea99b00bcfd4d257f35b5dec0fc3382a45cb5f4656ca39f37b2923fc3e95628d9b170b805ca16d081874437a5179d0b48c9db2ee5eddf1f4a8a781d0afe0a41b4369057dfcb6c289a17efb009dd52deab8472ad64ac5ea4d09e3606a814a926057c2defc0d5499020b4c636fb39ccbc5f8b0d228658d6ff101a89837aefca3bc1e6ad92b74858fd88f75b386e83ddd5acf917c833216cd335cd25443b5e360977f48d33137027edb8f29823c1fec2c6e70f2979a693d88e193f816daf1f91652701cf7307d1a0abc727c9b2c88ae0c435b9d3eb81c1528984bd659329d1d1597f87c0e8de60a62e9b6b8d19c8be9e473f48a54d1cc985eae99d741f404d563a621719f671c1439dac775e882fb1c98c13083716bb0a2c5d9b04f65b9a13ec37b2f41e143f49ecb9a8833d4e7a993fe137f466a4e67faf04120026004cff1109c2bd6e55e784bd1abae4198976da34c9091be14f37507cad1ec456cfe4618e64f5e594d352214145c83ecb64133ad270e75dccf01776c4d39d5242d780587b6983ae35d14803a7bae3ff181d07f4ba3e6cf1c24c25065c091472ba7ff5da53e5382d87f83d3ac2d46aba9a828b6affdec294a39d34d7d5c90190c36312586a47ad5876afddc1825e3b3b9e2a605a180192be5a618cb7efe3b4b54c415612fd3e5db5c4deaf15fffebee15c9910dc35c980eab2e309e70c8e56cd48eadb23653cebd54bab88ed7e3ccac2a6548f915bed19c65ecc7d7397c5f133f3a514c0d20c9c0dda71b2593419f13a22d3d85e8f3430b8a1713069b0e0e556c127798802fd23b6e9d4c2aaf9c9e3d7a594d2dc764913d740721d10091aa710aa984ba957b16ad8bface18bf5d3f9face3cb62c62d6e1e842c396274c61614310c0bb53b1850882f7c914b5eb083f611e9764c5d170bc9db685ab669239aaa75a4080331d104964cdee24189582d766865f918078c2401462b1bdcf84b833479de503ca1580bc35c6327bcf185a0cea02bcb4aca112df66e64bdc7fe3fb65c93464153f428a446eb7a3311e9c6e417d786c1f08371c3b814281edfc4aae932c4099999dd5ba2e2b0b1eeb9b2816086e808255a9d90c075a5f3ec1ad921e75cb5444fccb67085aed54a611c92b08e9d66bfc1a7384d920ebd846dbe56f5cbceb51cb49a331ede9c485d1707ae4bd8bc874d2062fce1e7d0be339ccb6b3fe5a2e4dcf326687ea075b6fb02366f1d13c62b3779c887d65f70cd02dcd74a0b75a9dbed56eb37a060667fc61fc2e742a2ae9f648f0f0de3e04281df1c5b29e95599caff15e742bf2bc0c8ba09ac5e65590eab08c0de1cd4690f0e0bf1a8ecd2d1a1ca73823cb98bff25101085a26afba969ffa4f5f4a0dbd0fb05d07aa32245a7b71f8f7aea7b73949515fb941d5b4fa484bf3418cc80ccc1c55353efe90d08432875bd880bb3e69529099806351a19134a156f4c9f4b59320142fddd6f686c52b8827e2a4b3de6e159c2d94a26dc750ee70b186da530b335da76c4280549fc85111825f3bc4347fe36504a66492e972a6a1a2ba372c45c0ba20248838ec421e53d303e0a01b019f45dccfbf626e836aebdff377fe79233d39bd4e3a93fbae69119bc3569bcb0f919730abfb8519e014c1778a86821ca8f912c4c701b9173b0cd986500308fb2231ab50e6b47fe8dc6630f11beef5943d431f730abc831f6385ec375c108ab12924baf4e5b05d885518d380c2a7b6ebccc39baa80f9b8b8bbdc191b86f563890e8056cb3a3cc3f3e10fc5f5d3f85db494f55f2e6c9f3de6ef0c54d30367875ba8d5f156f3706362afba58f90349fe7ab5eef1fb317b321b58d7eac788e23e75c70bfec905aafe925261fb070a472a35259f701ab774b66a037b3500f318d214ed7dde32e52195d6fd40a399f7abf987960863b572509e45f21a1758c51e760915c3535435ba600ed14ff650365536c98ecc3d6337e50e4eac25cafd9c2f0d4fd27d5be288237c17266415a3181037ca9c9a2412b43ee28afd420c24195064739f06405615d49a8795cc787cf93ae1f6c8d3c301c8ca9bb650429512119fd108caf2d8b5c399c04464960ea283cb09d86b8ef9dd5a19747127ef7e33d0b4de000dd6e52d93bafa77ae754a758beefdde2765d4892e6333c38b5c33b1857d14df74d3eeee6f5e720430013992c3081a9a0d3fe5e2199e1acea913927db351dad6c471b1f4c0072ca89ae5e05ebd8ba5c07e902d58de045ae78e9352fb088c9bac86b8ee8760d3baaee7386d76f9e368aa0cc03db27610f66632d19a4efd9dbca2e4d3c1c0091efb5fb53b572ac265cf8222513b9be0c2a090319783b8fec045951695fa878c7499c2fff60bfc8410f2d573caac650d6ddcdc2fbdb62163d38f4f5a19c33e9d41edca89d08d0217b6442b24a9d70638a44c6fc528c91cb29ab806c168985bebf414c3aea71a87ab4ea9fbefd74dfaa68f2613a2553d7c3014dc51208288e5fbea58452c4bb2ef1ffd7e81049316220fe40ccc318bf48a1515311fbf3765981878b8c3317f0c94aea28229900508cf3073c7b1382f1e8b6cb54dcf08304c7b6056bd1261fa80504e3c6231e4116038b1b62638213611fa14829dc2928a020f24d084eff9fc67b02f7b96e2099555bcf1369e544d0f3bcfeb39c037a5bfe2098df523ae1c11b5b2bf85c4170048320a9040c2f97ac5f3dfdb0a4dfe588c312cd8c09553a7d31e3d68c0119fb95c422e8b59fd95163ee1464a78d74787b2a7d470f9ff43a9e10460828110ef458b72e53d0f23a2119209e4ad56359149dc4f7625c21d05830a1883782e2d054455172ed8d2fb93e459e0da8a2d7ca68480df7ac1912ac01c6651ab3d31422b6d10bb5ce0f53b29ac4dba346f343760565f76d73e62999fc16cd62b21f2abfddfc9419a6af580d0d44095bf73004f72ad0afa2921dc9119e4c9905f07067312b2937bbed18062bd41719312f303f3fc3497c0ed399e820a081503ad6cd0d05896f8348097fd3c9d43a427e23a6821b28399851f946029e1ee539bf63b4ec36edf80071c09d20a6b131acb33ba9f9b53ed8c6515e5a33ac009c8b18c69208e64967a3bd81a71277c698fea99208c810dcda96d21f20ba4e721d4253a54cdc4ff2cd9f7388802b5929cb9cce61fe4bc005ebc658636f15332fcb8ba7d0393aa9f8283ee88655100f0164c1619fdbce170525e0ce6c59ddc32c1aa81be51addfff5589aa24fe9cbc340c2fce26c3784d66aafa0b1e2dd326f48a95a28543a1d24b6429909b88c6f4002245d8f0e58a4dac32d2fa45cd5c69ef651c322df0db7d26c44deac6c34412f63d93a7665d76ca02753174941965f17d56d0ea3d655610f8786390c3766a2656c9ad0d752fc0216b4f985be4e30ed184d620d41688d64e46081d65ea881af3516acbd6ed6ff404544913f9c060a9850855781be59057b40be0ed47f4b339ffc060f18c3f2b88d11387ce7759fc016a9a982275046e2584c56b77b2b97650ff86b98b78e9ed0a9208f8729e20923145919eeeaaea2082c81432fe388beab093cf4f846d04bd2e6a59e18a4b357a8725b908f26c1f3b51e4a51c52f437f2e0f772e747ceb37989e4c75015e6d1fde83fd5ecc4c380aaf4cc1bad11373c3fd8bd2fe49e42cd9e8c803fcbd4c45492473dc5f99ffa0af16412e75703bbdc2c0f474dbd31c2e4627ee1d7640f547c02a6cd6c98061c22b6e06951f03d8b31cc08110d64746a6a8f8530a57c85a5dfd855d794e7693b3a575d4f69bd225676375bd75d607165432b832a503401db272d7b14a6f7d94fdf06db799ea2831951e5fe59aad40af74e239634668ed1c5a07971b0204062b225cc799b3ccb8d1bad8d9eb7e895886a72eb1b4d27ee609d6bfaae78243fe1eac3fdc6d657c56622cdcacfdd712392d4c92107e29d9369db80ecbfbb93e6bcf8631c10385826b09cb6e09b3a1dec1d22c6fece8cc616cc92f4077b7403d116325459b7691fdf9b45821ca9d7117c070842e2e0718f640cc146af9c9702d8504a9a352c2c402818d08bff61fa900b70a97c89dda1a0dfbe503d90241a964dcf84ac63a0d3bc5bbeb5110caba5d3384b16a36f773523e0854af3f76f6ec9e208e3fcab6f055944cc0817ae92253529455097184e194af83812197e75f6f56db66870fb7470ce083102c7d017b70bb780a7495f3e9d2a900586cb46cfe15fc793434752165c92cb236bd164a1a37284bef18a453d9005e2259e222892dfff30f3ddb7d358710c2b6594ddaca485c04fb7470544485574f872ddefa8c91ba3ab9aa5d8ca0a91d66a83a175e33cb6af64d68b6d91b2a5aac3bb31d05df498b4e929786462c4ccf19b95388dfc77fb69e48c0e9f93c3ac589c8cf64b63c6bb904b812192fdb510c2ab238e4d5d2cbd790a38aeab2c34b06c2c156f576222da753e3104521b22d8195d7904ba730dfa5284da1d739e9373508ccf7efd6d07b2e967ecf7a72bd8df58a00cc5256b81e4cbf0eda604416f8a5c643ec71e8d6a052321a07d0e218719799a2f1b45966b8e3f21938f0ef1cb9b688564e080bbe1e757bedcb515b6f925b31ddd532c93ecb055530c387c3000fbd280a9b8e84c3ad16cb2ccc8e778e1921e43ad5d5afaca7ce719830a728142559fa695a37f31e8b8c09b9ec39acb8824e603f1563125bc141c92aaa039789ecdc64576be20bf58473d3544ddf81e776d2ea9753fc999bf94502ee418e550c7bb74c6bca94ee123318712dea59e86d2c501a5b7de1ac8a7d806b746b39c1a9506a45ea2ebd846bb07de26259d86a56fdcfb117b569f91bf70038c3b7c5ce11a91b8a955ae3ee495ddfaaea777c54b8d9bb9bf76a32275e0507d872addd0052bdf0335f37f26b82f51d4768ae8ed41e5339c37df0a1eb2710f3ed8be6a966f96700ebaa2286c9df4f8b8d256fff1137c749f486330499f92f4cb0820ccae69c7c0763be26ecc05e60ff5781002f3e65814baed0df7fb085474049d519952299f1a9078f3f41a8668bd4685518b2a278c24e44586ad49570c3fe098d0a8753f875ac78f0762ecaf294eea9c33faafd462edc93a91c7266f6f5639f602082dc530ef69d1d1cf27961b7a0370b1c101be90a7370f92dd31eb754e5567e6fe0e2dd52354f882e24796a8760f1e1f01717b3ba9133acc90fc54455b1791b62931165ecdef4a1a534861912fd682c3385959e1b5ba5baa4e3477489cf787aa890f12da062283d890cbf6d115624f60957946373de48e1711486685f878cf7f198192a1865c27780b3634b07218f8410c8dd8d5192d6d8e92adfa4e6871cf63039e758f000a534840cd59abc5537de58c7cbc53346280e764bba171dadab3cbafc85d7ddec47782f3a593a4bf3b468f3c42ba38bbe2f536c5f7ce7f02eb5b0cb1a7155a8c368ed2c03ee5a4d28fa1de8b10b24ceacd63acbff65c85b7506e1a959ce8a2c736ce06dda9ba04eb586b3fba6ee656bb1dec2bc3f9edd8bbae41e17c80f509cab3f79659b11205a611dea0a5b53047171b064eaf50a0716be1ca598287d592452c3c633537aadaa3b7f00778353916d6a7a418988dcff1921fda9ae4a354597a8aa72d5f6461327d0628cf74645bd48be4b38605721392b39d2b1a4530b6fa66da3e19998c30ca5fb4f3fbbc54ae5b24484fe82cf20d0478dabde527590e8ac1796f84776dde22ef92acd86bb3aa7a901b32218a740d45484bd8c54d0a832705b1ad0fbc7d2cd29744c3ea21e49e326ea60a1f1123c240dbab0225bbb35dbf1078fec022efb6843c9d78437e351318e54dd94139548e765941d59eab6e6213e5988ed43748ef3c476216bbf690a8c6aa05151189de084907a83281d30679ee34f1b45174bef65fc5820a5fc73c8e1e02b762dc5339a35f25e8c267ff3089daad877e5f4c22b29b8bc92786b40cb5c1e97b6e9470da9c279e1f9c97d2a5a4e8c75da324e3febc738e84949e376c91369b93f6bef3f0ba5780e4f8593ad020314d8701a1f2c3e739510242b9de64c72e98060e05ce68abc579a8b1c0f38ea2c68b45c4be9d1e3f5e9c45e77cfe1ccdeccc2728fd6d4be7615f0e4f13415f2a7116cf8fe76eda1f52f3aa7e97a9c0c25852e4988eddc8920bcaf0d86b9d9bd22302fcf8d93753924c4821dea66ed205e8f9eb32dae6dea27ff89f1982679af40378f87e8b18a9645866d41b675ac3703bb82232e29e01a3214b322bc34afcfece5b4d11f2f0d481eb6d597075755501fef1f15b490d496d04004ec94bde0edcf1f61c8d284ffc168593ae40d159f2e736578babd72996cdf6cda0b14afc981c7c4dfbc8ca31a41102e59ac613f6b12ee8e4f7938287fd9bec4e7331db01d45f860fee12f959d73f5c61a779050e78d0618b2f550b2617dff83ad6e997b2e7c60264ceefcdf52e32b4a78ffb77785b2aa6c8bd85cc139e5225768f47bb25b8fbf272fb7e4b9be91fc8a0ee0a2d52616a9eece14d3336ac051bf900a4add9b2bbd1fa8e082d0094888d532e31b1466b7061648e3efe1f95c68b86050e6696d73044e07882c9a3d192b24dc80a88a7d4a4099030333968972b1cf43822e686ccf5db29a2e03114a6dfd49df8c61db3009a3a63a9361f7d19ed4934b217c48a0eca2667cfd27090f1f6fd0d144ac8f21428e113ecc6cb9b3134273dd9f7a3209f6a25204a778ceaaa61ef7d3969424c23a166b046b48471044d68e3b7c6d342b034fc476d8323df20bdb9d5e5126cd15c45622113b8190d7d7ed50a607bcb884bb42458191815a4daf1657e6c4e363034936986cd25f2f7eebf0dd0e07657b6582fd075f83e3007b6a91a9ea778e5c44990d52e5f7a96207b0a93a54ad47e8e4123fdcf0e831b4c65dc73979d7183532cbe7cf4e5fb1b4f566af155e2e498b9d20383daabfbe2bed13464acaa845c690497af884d1ca5a715b32aab0cac38d09fe6876297cb2d5b62dbe7f7bea626d71aa224c446ea9ff98677a75a58190b6e4a96c93f0aee927d7da0dd8883ce44b472666c6dc541484a9e4c83b7b067f23fd907981c66e0cc0ed7e87bb0c46f44d7a9e14102bc83dbbe3582d14a8a56b0eff04ea9a97e68bcdd7b780755de19f8c38ef554d2c9653dc48fd1a3d30f6b57d6fc1882287aea0247776514ff79fc2c36f47e8a05f1713fbd11785ffe74578d049693753f0ae6e196f2ea44a8bdf45653ff9cce0e11a69b39e0eb736db7b6baed200c6b4707ad033a0e8cf8e20b5577ed96bc3db75d0f9fc6ccc9b0e95606588713ccbb52cd914a7fd621a50b12a43ffbe04234591e8c368ad061e01b1b8d3e77a481d06eafe7082c3888875c4fe0fd1759fd8ab1915018489adc42419b251298ad79251973c8e867d8d7a9a291d5fc4e444af7de34653ec173309493774f830b2c2fa4bd5e1de213ec81a27c0cb49657a619614bb25f4bd96240b5686f62c5861ea2f5742f7ae94d93ad1e127a53ae5d500b6051216a520550fce345c3fc218bad2d5b1f2091144b8cc57f53e1ce9b340a34db7a7ea9e214cbacbc9978e798ece04143205e7e61a32d978d3c135283815d969612d87cf199de6c259ad08a2d5ecc500efa281a861d9c91ef31f31074ddac940d4a3fc9a302361657788647d9fa17095880b1e6f73d50cf0a40ad45d739f9eda18e91e1a4c543535b6fbe6b78c9350633f7120f833322101eeee3f689be0cf6e7188da287becee0b6b9676fb2e17c79a970f5636fbf9e0483818b2ffdd379d5915bc31cc8580d5b9077d2630877320d04d16bc617acd43f97982e3d5744c496d44a1ef306c9e10f1e4a20911526f0cb8d2b4621433cd72b84cb7d50f3ce70e9204c8a4fcb5eee20eb489457a1df8ca842dc363234df0860a879fbff5ae4b3b4a194e798c4626292e7dd046b8fcd0bc51bcfc4844ca71d402375612546c86e793e90a68a6a34267f2c4ddf3b8e60245dfb906a52d616c307bb25f740a3e57d3da836a55f61f95fdcd730c2295f5b6dad3181ad136ec3ec1cbcb0a329a907271bb7e6bcfc8362d463f61ff7971b7b2ffd2d3a19326319b4bb7e4b02ef3434704048492680b8df24e89630bd8c3900cb9427614300c64d08a5b9e79815abd9b13c96918104917b1c3705241a5d041974f5f06ee679b46f036bfa15daeef7fa2dab7f130db43674f895b4ffaba5047e0e1a2ef583cb5566dd820457b628067a0cde4b91b0ba6f1f55b53bd1758fc9f3b8897e97319e4e93a13e4e122edff08cc81c4a8e35859c8f101e56e12862a96a8977e2b87c009437c004377071888641592a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
