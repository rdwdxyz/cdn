<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4bb3f1544b2535c97abb7361726042dd14850bfdde20b5942dc5852e730718723ba6e2e9554eba72fb21b2d484d50d36e818aaf6e346736170e9636d70c9df6d0bda888ab863ed3548fa919e66966fffb0ee4401ffcb0a630d7e43abbccb1d9bab7d143067d4fc1de26fc683693e03323b7813c50cea834ead1ae6c162361486dd86dbb7b26f0769edfe67852dfc350859bbddd38991f6fa0a0d889ba5a54fe9552599c1c4fc0acf32ac1a8f067f1c32f0a253199d5642e07844724fc49850aa7b3f890c50c94ac36078f821565592ee78be37e781b54a5d26d4fb8bb3b660655f437167c9ab8a05a81d4b728808b8a6c4b09a539bc07ff4920f4f1343ede5615f1d215d4e6545e2683d8f5a45a2bb176fc3b325767e85d6ed79bc80f574a53feed7437ae22656df5cbaeb99550e60e03d98fdb2c2395fa6b5300027d47c96be586d475322d6e084b04372be456de9b5504a59fdd75011c942bb8aa93ba4cf8173111427986eb07c7ba028205972e01b64800f20aa7b90beb7b60bf395d3d14497a3a05059d80d38579fa0420b43ffb951abb3a56ae1091ea67d7ebef4a9b5a0c93de7b8429878eb550d161f7a48a9ee283f71e05d6012425e19e1914e03ee2d1dcaf59d9a7ef40dbef5bc4f1c5773b519cc9da16e665ebf87261a7bbd4388c9b5b1e96036d71ff0eda834f186d70ed732f50f91b5b34174551001ebc084271481010f04b8978f67639758ce1f890f0fff4962c3c7228474f7e270df9a32a2b5d322ffedc835b66374c1efbfe8d0add9299586433a84fa70418a5f2e5527c633c35d07ff284fef06aed63a0a8376e32f27d05f304195b8633b03b71ed9cf26f8234359dd96029bed7056d34450c485d43232207df6e11c6670c881ef27b1704f6371233438524e4025ccc9c3399f23136e94931b66d3dc3984ef691a3bd42262a5f342c6a90621eb6178ccd816b89bcec1ab1c459a36094bdc5016eb69d390a8680db4dc365b6090fd6e02e2d2162377b514298c72b06579558c61f6f980dc67aafe1a02d335195852991a572f28d9efc02231fd9c61859c0766ee11fcbde24fead0d5e241f930df71ad64414cb47e45ab5e4149e593ca84e09f6cd310d73f8fea24bdb4855b116abdb77975ca69515ffc385881d9e9a75298bf7ae03a194635243a98571061bc0cafc8b798fc4086e58e66f9fc0e9df7a4ba8dcd81bac6b137129ce4e9286b76deef6481e4c02b62df6afc136183d112ac48f8c0510f46d79adfcd3f32f157a4589158bcc206f03e0f5d1d5dc1a46f0242b6c5ca50203cc468e3d6484064b2fa1c8ee249fbef9cc98e11e87fc8c7f12184c5a9a7904afc347a1aed554910d46807cf85291e1dab77e710abc14a453844f2d50bbb21ad74059f56971a4fc575ccd0016259460886e29eefcbc0a21098d556258aa0a9e9a8705e510bebb618eded696ce1a71c71322303e625ab822720928f9feb5ad7ede94718cd9dca2399971cd2d0fc46dc8bf8e5022e917398418c06a5e2b8cb39e0e20cc98382fdf834e855bc23b6d7605fd9209b377aa56c5d32e0009cd23519657ce48e34f5114339d4687465b658d0e8515de5f5b1d8f8b933bd9118d8a27d3071c09b772c6ee2a5a1f360e26556689e6894beca11399b50026f6f3d78c47162ca35e2f94ae82f30021e8507c40e008c2dc969e244f3168656c387ea1f1c4ad8522df8d0ce3a7ca2ce7514686345cef6dfd79be778ed23eaeb338868618ef7dd6b327ad1802c39e7b0c76ca607208676f3e5866912315c3af6b46d649d3bcc50227cbfdde254bbac3fff53f05cb33a1a0be06eb69b78d6375991eeb2b3205d8582dad1061cf55bb35c4d8164cf7adcbcf8f8b526bdbc208bd5402d002d4b2b05a016d555efdb0c8f3b01f2bcaee0308120937eb26437b3546456f194c3de53ac4e257a69f9b1903107eff172d4720c81bdf60a50cf62891116f5ea329e903da50a8b7401e651a41067a28d0a461403cdc4ac26c1578f9bf427a31f26e46c45e6fa4fd47d91b685e2710c9e7be18b9115dc3de86b31b5014f98613d483e52554031c292c5224d1181d187b5756ef9059efa1f932889b09933eda5cae00f7f124152fac3ac06167cdb7f858e5a447e32316572130315c15cc6de27d45a2e533febbad74b22fe9ce1d1972bf8eaa246df1d8a93a8290676c2045eaf1041b01f454b3b40ae903f678fa34cd599733a3bd1cdc94460b57ffbdb06e68c5af7d5ffe7a658b948fd8602cff3e831b9e84d8b20be0bd83b3b790b8b596dd990652c19a998f53643c4c163e22e042ebc804a5c52206469c77ed5616262e1ad2ac5314f7edba0640f6ae1aaf730a8441aedadafc8b7a806812f1d7a433607bd034946137f94344cb431556fd170af303efa4cb6a7b005a6d98597371bf0015b29fbeb511452240bf8f0dfb24ad10950a48593292fbc380accb9b994d3df6168bfa07da29566573ef28696b9fd8c29c9be6de6ce5442563ba3c31d77e0ac3815b59ffa5dabb214edb02aae9aa5128a09f4bfb1227f6ee4de8512e759a4cc587c8fe0dfbca266dbc577e70e783d87e09630f58f95a645e7938b22dd6043bbe263637eec6d2fc163cb8ed4439fb8542fa1b8e499ecf44655a3dbf1f6e5280ba81d7fde99b4937a6ce2a8a67d2ed517088c03fa01a27cbd38593a4da6d3e2f5768d41b943f262b19c72e24dc7040d5010c3bda3670ca43b86beec56a175b7d471ccd5ec2908fbebfc9d73376952f26d2d62cfe01fee323a4c75f1598f5d2d2c2c34629942db39f008597931b12dff04c5f1f91a14441ca76bfe510c1bb477e530e47f5726738d9fcb7667f472f631bf698a093030817eec3c3fc9bbf684bafff3202a72060dea1d95d352b025a2daac07a0109b6fe3eceffe7efdb2a523b0934cbac955d518ee183a6df1cbf6a79a93ca814e76951764d30d949d3263c40b321e190c2c3e46e200c055648d99d591522b7f0e5a32d193552e6cfa5164080851cb969d254d5a13627c66cec2f71c738c806fb0b406ac990e6447d4841953aa23f6372caa00979603256dab6c88b1c5ee4bca637a87593e344e47deb7f429f3765dc55c70b19ab062c7c5dd44891614336db816aa01e8605cb38dd81210db9bab7ca4aafef7322b1d70c067574ccc5dd0f974334dd4b5a09f1b57acdc2a07c299b8ba3485a4ba0ae8a575aaa7aa9a727324addd82cd6f30c3b547cdf7e8c3d10738ea4c8633b483fe88a6e8ad8d72450a22c1f308942f842e6755835e2a2663da43c1dbcd203a289e43060a1758f2f6b9a5bc74f00618dc3c4cf6359aae4b65eb24d6436b1f8324a397922c9810be35528ba9d0e3485a0d1fe459906470af21ee26701bbdb73ac8747c4e1b552d62dc64a81a8e3b29dff6c979ca89537f9a58f413f3e2063dce8763b525953ba6d62f962d00da70d84b76fad164c29182827e92ada7f663468fedf9157a51ecd943c932684cc5eb11c96b1632374c3db057b528a4e2f15b4863a390a3e382c4476170a87806c6ebfb43386cb8104e2ac917ee7aba71df7d26e8ec503e1bae0134ed13a1d2315728fa26640d753f2dbde3e5a87bff3a1c0072ae37e63008066566bb6724fb03a5f75333035af2ead9d64e03be15e75b3db0ac9fd65b3661e8cdd7c9272fa438946a0fba7925bf0b6d11f2fa3256af65799d999774acf8c7b9cc02c87445a21f76b5ebfec1d01a16b9f6e5d533afe04e3db3a347fbcc6cad2871eba6f353c2b547a02d94102b7308fe3c483748cafefe6cc95a571225f6e87cf940041bde90b05706fc06d0b309eb44c1015b210508212845d565f23ba7b072d41ab139a20ca1a95f5bad77a5bc89c8f2bdfbc1407ac2be149ce264b0086f9a1d0446ca0ec3230853fb30b62d16a01765708061c3ccf2fdd5552fb1d7290f0ecbe0a9c25871304e4ba31a6ca9081a96ec93a2b7a2e68222e6c050e3d760e58a7cc6e8cb71d21b7c0daf41f8081bc1578c6e1ea1a8323e7be252eb15020cb2fd349d9476a710c1bca9fd7c5d6c7deec5cfdb43e851afd4e27d8e2e0c5513103ef0c12519b369b85317d73d8b117c69db116d0bee2284c6c9a4e315b601efbe510364cfef7801d3803a4e38beaab9a12965d51b9aba319be649e56a81f5b605b4c0185ffa60e2a9b59a64844d5b4b675cc8f573d279579c8733ee88de254044a0e2739b66a8814c3f22242ad78ba981567fa6a7f58f290cf2b259917a3baad359751cc9a4b0da8ced262e2c26d59a793de3c5f067a88214b27ae9ae096523faf5d0ab5ad273791c391d8be2c42dc0c4ac393931a845bbc3619ccf1c5d87cf21e423105de909115de055385b9c6d38d39fa0765455f5e72d260efcf425ac7692d7bb8a12e3009a2af4899722cb1ba1e42e4223fba3ba57adeef3e3ca27ec500756fd6582c9be74a104e731cef9346f1b9a283e5fa963bd7fb95dda9cad1cc3b4be1a9bfb4be0ad869057b933dca4edc7ee76ff0179a3baf24b193debbd1f4f2d89b5c7a7622b8648dbdb472a7458a141c7342abc3457e726d22c7b376dffd6746c63209c20320683493d42ccdb974bc0ce3a5d34052f7547462c70265fc080bee18e8fe9c57cf2b4db8c96409e357d22e2a342a8224ea7fae975fcf865df685a435f556db9da6790a96135046d63cb9b6a5d957b80caabbc87c4c19123d7becca4b1acf5a7bacc605b745c7565e9887e46bac55bdc5c40982d10d2489bc925934b2a904316b0c0eb21ebac1dd99e4d6fe8c53af76f22c4088414d6d205c0983d0b0a5bf507d39ae965dd0ba0b5e28801f194e33bd4d482ae62c07cb477eba532c58fecc4735ca6a6cf88f419fa1498d55ff72a97d30d1fea90476ad26102e23943b674adb128ebbfccc611002a5ddf3e0bfb6ab1fd1fac2ee11e68eea2bc69ee929da29b2ccdefdf5c6bf250884442ee2515b94a12116778816e30a0ca4faa250d7eb47fa58dd8e3d82b4be8787b9fd509a9d960c8219be1d4b676b80b808d0f883e08b6abd66163a1d8002dbc8885064bc3c98e56293b700cf6f9f15b727e43ca0e9c8e3c94e2113df34bfe979505f23ba8158217ab0994c76f2d4f0a8e340256926961c21e4b8b15a774d5e9e6aefab9282570276c609da693fbf1b18b37124ef1b5920dac4ef0d9cdf677921133d8699c258b3b9b7ee97e45eeb5fb1b407f3f681bc5023f856ae4908fca2c0449ed4bb9c5ad55ec51a030adbbddf8d2cd7a2d54d897474698695ae2d66b0f752cb5a7b65bee2464374593d6a24ea0be84a3db12af8a06ea49d9c628421608f8cb74dcf7a8b7b09421d1d51171ce5d5d58aa5a0a878ae7ddd9cd799764ab7609e8f1a61583b3013b58629720f4add5603da2de17edb15a279a6dbf50434bc53efa264a3038e8538dc4546ad9e2532f200041eeefc18ddfc2137bf035262fc0411068d9023021d64ed584cd19208776e5ac5a0c0bfd74f172d0c3f4851cc644727d927eb9fa267a9fef3b4d33ba44334e02c208f996516b1a2ad320689cf9fc843fb5b019bb817f728919975020c77c8a6f41295233ac92bd4ddcf5bacac6746844a37342beb146a6a521fb1ac549ed4d620d7f2bb6f9247d25061d1dcf2b41f981dbe3f2d637c2731d03dd24ee2bcdd28e334818a450a5b7fa1e719b895cb5daf62c81fbf714d00ad62481f344cdfb7221dd4ca256e907f422ba4653576c332b80c72bd492c4ad08bf454a3516e2209a8c520e8195fab095595759deb836f4029488833bf1c773af7c7b7c4c24be50d3422bfa53db655045d711e9d50ca3f76e938b6c4806bdaa89746719ef6e1a624afe05a64576eb36cb3bd7882ef703aac7fe38f940c706c4f7163bd0c2880d639d5e98210afc77f63693433d2fd98455a8f27281afaa6f3815014019aa1960510b7a572c2b3b7562fc80cc89e3f32530494e7379da6daa6404967f7404b9383b1f8a237329e5b0a0df70e4a64497931109947319c4d4e81ed09ff59acd29dced6d8064e38d49ddc9bb53ef84be48749aae37b828e8ef36644d65f10a34f8fc9c661712bb669500a261a9855f51f47cdab60bfe6f09d30c9cec7eddcd7d0566e8ab0facd092732e6caed61540c25d9f89930b101a97758a6bbd14d7a772bb00846e003dcebc6d2e7a100766d5fb3c2b971235804a08fe95e4f8bc3379c8397be2b32bc0362703b230ccb937decb1284dba996042a2b21bc9369f2a41031db1e6318e51eefc49300e85f371ea4eea1f677507834173765c053e6580b7e1cf0af1310a705f830a8f00d6f7842acf3093c9c51d37690c0003b1d5d6981a0c0c9ddcf490bc9223047de08fce24caf30ab8d26d5b180dac6d0c248627c318453886db02087bee9859b3bd4ebd62af4994c5ae9d0930ca0bdb4a763f691df017ce7d4e4e6614017cab735f8160cbbbd74d432638bb5d6f757814fd77d4f90ca76c7b89a7301fd71726463e16b037e010662a776f84e018d4f81a579d18febbfdad2c8c5a6b0fca3d0b6d47740f2304451256adc9bb3cf75c41ba47bbd76eff648b717f74b9d8a96651cef1e724462fe86e2c286122a50bf5d94e6bdd150278eec92d5916318b7fc6b0535addc78a43cc3377092b0a98cc97e18e8ac97d6401a4c8ab3d88a8794e765330723a63427a5fa6398c991272ec23699c19a7dd9ef7a5ef191cd6ab2c2e6cac601e4f2c480d44c0b48aa5729d4940fae19035432217280143689325c9f57affb5138726a1db423323e24f4db0ad8db9c6a2fbba5f37fb5d362a40fad64c6fe8822e3229cbd83ea7fb5a3d4eac5a8482994acea5a097ee146a18dcfb25b639a6e818c3dc54c9d4e9b004532dc55541caab3739f1f8ee7f2b3bf127d559b528b78162b777de8cb1a341c3f6e75dab379274b5cf2bbb7e92860c7d8791ba245ed1b6cdfe1f5705c9a28ef159e21a68d828164129728c366efba2b611f88711afd52f04be7991ea4ee5ea70b32933cafe6b05fdb951619f02a3e4a33113913f5373539dd1b2e904853200c4a4d1d417323a6c8398f40266038e650c6654ffb5a0ff0d3f975a743c60d79af0e7d745b15c964fc96a6938471afb1f9193ab38d1b2e97269cab024a825134c39125eb89219986fb657911027c3e7e1a15026227673ece3b9dce5ce3bd81d327c483fa71359ad8125939f9078a6a854d6cb853313f41334b0370af8aa98c65d3180c86fcdf0ab70915c2659025c2f38fd443035ab7fb24bf696d756624e2fed1b0f74427eadd843046a7dec66ab3d7d2785bfc079aabc42f1819ee36606c43b2580a5f9a2235fc2da36b5cb5fdb8aa882532640ae01b3fd8c8e4fd7a81f46dacbc6c6660a4005e17fef546cd5cf2a0659ac7540b59582951e2ec552ec331f18f9f74a89563feb1aac0838e642a6eee6dc97ea9508e4c0de02e6cff2129060ef6919d2de6ef560338883f075d8337d795301498c8a2088de9eeeb0129617b910b6fb1de9f7302873983b845c6b1f744c0c106779dbdc1620d733717e897ea7c9a90ebe004f95b73a75ede93fca1640055893beb448ae098df93d41edef6f8ffbcbc2febc0f1735177d36d587d156a1bb74fc792ed2809cd968ddc6ce49e3721ac0e41e9f5aaf3085903ab23bd1686c4e52413aa93f8a903315860c1507ad83fdf340d7d39c326834b74a1f620a9a4e5a0358b2f96de78ba85e5f9a9b9d29a8c1a8e0f8b806f417794d764b8079361c1224ce44ab199c12044b2cf23a55715393020b134ddeea9647ff46d4c34110d480110506e63c19b26d7e3d4c719d897f6df2e0a784ccf010fbe57506a2c87c9e88c828aadf1eebfb6116906bf3afc6fbfe123f4cdbe293f3f67dc5cad7121fa5de60a9adf7f8837778cafb09348c50ed34039befa44c3bfb3cbfbf7fd7622387032ef75f028675ef0723adbecd6277800a45edbf7c460c38d335eff13f47754aa79509f563eae627010a6f280b79d7ba5f16b195f1f588d1b2e7f68db65177da0fd81c4110c435432afc773e4c173a0b5e4f9c61404745447921de6e773506a19fadd282331d26bea0cdf7149e0be41203ba0e924424ca2d2a2024c740e6fb228beee4b50321137c983cf50aba723f41c355f3b9ebd6721bd8cd7a6c70f97e09fe11cfdab3e93c08ea0b56b9d04d3239b3ce7d3f8894cf5dc09d3b7609a41439e1adb5f6c0ba4963decd21c9c4b6fd83977f7d1ac8fc55b3011042b58f9a48160221a6d0d03ea325a663861c8f21e57f8509c4f469218ee2df3fd70ed7a023055386ed197def0fcc6ad72bf2090d589d87eb29eea8499183fe07d252574d33091b0b29249aa907eba68da51b41059024a8529ca8eb894ec11cf99195154c30741cbf30f390a48bbb8ae8e9f18603fb38be543dfb2a9819fcff2f4fe6c6feedfa72144e51dcdd28a0056a1d8c803ea6a28eb3694b7fbb6cfb333a63c264bda5f2a97612ce6e0339987a2ac0b7d562da431f1598cf673aca35077a5ba373d18e750f984d88e70dd5b1cf8e9268bbd6fd1a17a1b62467faa7f84bfd46c972ed5edcc55bc7d9e657425785e87d493a059ee0c0a0686b16999aea167dbe8410ef0974ede71781cd32f91b08ac980497cae327b7ab7dfc7fff603ae4fe3f576ab0cd6880a1e03a6fbe3082e654a75353102e92f68b4d39112b0ab852ed41e2cab1ca86bc53891d6d0f09e8376d31e932a8972ab2200180a19228f5a68c903643871764a27b43f9ebc937f2846d826e4eadd317d7f9e888ae50ddd9f7b01e9e28b16da5000097dc20e73c186b0d2e3546ca3fb8a526a7f641c9aab843d671d126e5344022ff7159c57d5649fc5f386cdfff95b5b383d9f8f113d01e317851e2294613c772268f7108d01748503b5e87a170f323d8cbaf7477b282ef3285bafd4fd998d21bb964856a505aea18d393011c4220b71a5b9d6e8fd29eb5e9502a1c40db03db96890afb4d07b57d2f772dfc28375e249856a96965376092c2a86fbf70976c0aee548175c07abc9fee9ca394acdf153866fccb96a55662995a00e4e5948583edc7f494ede045f89c12f83e4b220e0ca2c6dd2dd401e26c7bd6e485c93b3f966eba6ce03c87a927ee09218889387c9236afa2de6319a1f950a52beda369eba509fcc2241fe2647d18207d6a7ddf544690b2bf771c5cb8cfecbdfe5a9b2da7ca811f5289eff2a52bf1e561e5f97a7693eb11ab593730c8840bdcf6bac12f0d167e2a334116075e16a1f7c22a5b62799f828ee1cc48b3cbe81c49a60000c7401ea1d35f6c583bca8d60c99a08002e888d6f67395ff18a3e74233924e5f1f79ee0e91f9df6cb48d21eabae24591d9b4a9ae78e7d7ef51d586482039e89dfc3a565ff4c786b39c801fdf93c1950c475e46564c2c8f32f7d2c6482af8a31cd56b4e6c01bece51101b1768dae26030f553df86b277ab79fedf767b9d7459d99b16d308128fc5b0dcd30dfdd7a8a02c44a66e404446138edea79488627e5e06953115f1d14ca400913d18795e3e87f98a23466029e17f445951c678d8dd2830dc1bfaca97a8c4e3925c580787c94457405296312c961077b076e9670b3207d3c2f16b034522912c7cf5eac77da9ee2fd6aaeaae4a641eb0e0514fb920801a423ddfb9e8d85101f620945a2cac1a51496b4b8dcba1c094422ff4ef9bcabe6f169348c19bbaab28837327c2445b0344b23da5ed1156cc4021b2653ff507f8aba7354db5ef3802364debaf4af389ce63ea86de05edad5a24ac9d44eacae3b86c80468530f47a5d3d4b97dd58030450433a6a233538e7763b06d78d3db761db1dc65ad0bcbe09cb5578a0d83781fe500a843d36794f2cf7c6ff1999c4f4d0fa8691c6d17cdd3dfcc923a1f6afa7b56b9a1a04bd67682cd945a8a7a8483b3eadb25fd32e8eeccdb39c04134b39ac8a60efb91024057e5cf94b258a8c5ad61e6dcf388ddcfd52b73139c074424a3acb7d68797cfb960fdef4e354b16c6e0f103462a09c37dd8fcb280febe3faaa4efe2541b85e1c363b358f9440fdf475b787f29e35fe52a5b7834ac30f838fee3062811b60496d9dfa2e9c98f31d2e7c6dab2e5df3b779b0cb09e4dd6e0e29871a0ec2d8eaa978a99b2b05609ef998acf25c4ce59a2bf393b0c13d4c875fdc04a98f26019aee11fc91419c5f280ac81af4e557193254de416217fdf9fad3c3fad4053b857895caf13733eceb6ff9acc92d8125929618d7e081b2a125dec4f2c3da265fc53c2ace6a6247965493026ea305a0e848e8853eb20d7871dde7f889e52ab6126e7f02250e8b304092e47800b57ff61bcaf0ea81dc84bddf8b11392d30f7d72ea1093741ebc007e8f5adf53be1f7bc7573b9c21d0c0afe07a178352c34a88dd885f7e2e1cf5379cdaf62b6183d950e6f51be1d57271cb535e29c4deae9a0e643d68c6f7eab352e9157ce729d9af48cce2bdbbb598ec45713d83ad219429d3ed10d2c05d810ccb458db6ad77c8c66922fb4816aba17f51fe502e67d602f6e70469cd93b69d7f2dbf3099090e63bc48c3b85d02309776f89b7d11bd78004c73d895d093d042a97435af12c934af0615494cbea42eff0aca4d232c9fa4d83390d05864529770df751d3f35e00bdcfe03ed9b5e636ff199ded7eed4c8be8f263da3eedb53c40d78c34fa5e6f246c926299a266ac8742dbbf030be6040b995a2ce98524f1b9960f55508ba77e82483c3e1479e469409c7f8b469b9bcde2dac5501dcd8e1cd629c363d6293b3b896b585ef4b1b5ed1dcefd182213882477e2a7cf419464ff00ce26d75ea875dc67f63d00cde84146e21ac6c45be386f08a28df10a26409daf94e72c4c0bce558926e7b18747e6990024bbbbe00909cd53a6308a29de1bbb99b7675ff2867123d5a9b987df02e92f2009452af7f73f61c35680f42724ea4bce0c1ea8b6e42f7b6d48d94dbe53a555a2c6314d592b57f88131581e39d46aa95ca3c10d0909afe43b78a34158d598b898ddf615580b2ac2ac40c3c69fbcfd3ed5ace8da14a1dcec812c71e47440b9ac3571a7d75e6db0b93ead239d86a579172a3aa97866362417e038291ad62094a74baf0612f7a3de0a215d99a630ff0132756c3c118f5446b1c2899bcfe159c27d717db561e539fa7d73ca4ae4b0808c5323db2b60aaf99e3a27d386e9b6326d89b12f53683cfdea4871e601065d6ea700f63f2883c19af98d054c841f8a85bdb2716f3fc45e52ffeecd0aadd5c1861e5c3e4596840a9ce55fdd538edf0758fdd5cd08acf421a820c2839d9fae1364ba9963b9186e5f789bfabda1c5974fc54608ad4d79d06fee73e2972320fce0a73ee6b87bd0d78038f5acb0b735ddd0c0aab737a6f05230a757eb543825198155025c0831f754df43a445ad2921a3e8f5154adb8c869b034050d2507d55f4103f74591eba41b9f32080bfae464d9bf89e7b960ce8946c10a49a6e77858f80a4a8c18b69743827e6f2d3c360aeca0e0957e62717a2ed27e2ad3c41b02d3712943920ad09bcae397da962bcf1eea70993798a3e6796944222593b95aefc87b64ea9b868912fd8b58340895d589958cb233829970f6a302995a330f2be5e50155cb40be33d73dca1b2c943b8fa692e90f087393c1e1fce8ca6f421925f0894c00f06884d04a10bad9039d6bb8eb10c2c90b3e233b69d06704a4b40689c5e12557e935675b1844629d08bf4b93ff5150c7f3dba03bdabd09b459afc2d3c3104117462d304b69d870e396ea61afffb09bd58c28b603c755af331d9c9c8206542154e2c4479b80f55d913111e27b283c9896132aac55c6e6146096c6adc380e535b13c0f1b00774e164fa5c36ae1da29b1c839ed23ec2bffcd8faa9b4f18ee3f2cb62a9ff5d784765229b384afda212b27487f02fc94c6e6b7975ccfbff6fec06d89d6ab49d7acd5d073e7d7083d6c0711fd5081e11c98ebe98b7b9a0b16550d7cd10393746d4befa60b86ec5445aa05e838c72f072a7f131f0e018bc6428af6de285549bce6e9a3024c266c4a51e368b3f789f1d522a8908444858e4aa600377e40f0cedf2f3d854f1e9784c210cc8b80a134833115849c6c60461831ffd80b8f05e6501944083d08f783a0fc173ab18c64655f224588c3ad9ad08f7b498eaf2e542afcdf441526fc5164e25efe90ba0a9d23a7d5729ecbb2b59d0d57873352cf2ffcaf76790be2bf9ac80391e3bc61f81ab9d3cbf52b042db80e8fcc0b2af3f76e1c62a7110f9b68956e105867cbba0cd6da1f81698b66daf78325b415607af59b2cf5cfd902b7db09954fda35238c5acd2fb9b9a2528d3304668fb4b137029f0bb663f6b05a96bea45602f56cec041f77fbe52e8ed8eca1b2f90ce1fc50fa0c8dcccfb2ec858a6c61e1d223b6aae27f9f5c90baf4db8e38b3fe2c97145d249343292285f15bc1486c2f13774e77c78320940bad7f6872b4d72f85c02781913b9f166182ec5f0e01dc933d4c75d7238e1f9279d31f850490933cfaca566efb464cee30d0af370ca24f43f4e1c0fb162268b97bd39fa7cd9b2449d004d0e0e55283374b7efe1c3287d401cca78e3167b5f116a6a1d19b5c10791f43d91c48be8959ba7c04e2e0b157d0494650ace4056aae30c5e1f4b8194ecaa907d702fb3e11430df8929d9c61f557fe0569e66c29016fcc05e3cb97776703228ad7477ba2796992e1c377b4259d57013d218e4d8eeed95d9e57f7035f9e820456ca6e87a91e42f4be72067fc561d1b22ddcd65e19ed753924abf1144429c80429b49dd6b5d37b51b77d5ecbc0f9051e54b53f374b68d0882d1a904e50eaddac7e3d308de8e5be8dce26fc9efb03cb6dc218776602571f90d11d915f12e80d7f8b313728a74d127a9acbe1129e9df2c9a430a5e04fd2d424ebf656d735eaa08baf19e6459f22561d53a74fb53890504ab128fb9b0f7c5852d102597818ca82f814ad61f6c6f49420644101cd50fdbf1a633593b681fae13724dad13a7d59c5285697a5c7736b9aa0ebbb13c9e0ce0b1bd23ffb82a514cba7fb036badfc6415c8797b19a487ee0fcdecffa117040465389df83f026747c66edfbb4541a78990259db17a85a681a424a6afc8588f4e6babec32251efe39c2005279669fff7e0f5d3706a5e29b983cd79f9aecd3a5fce33694d852ce9273cc2c17689df12c82e805014ba3b07396790ab3b8a20c9dc880586945361a6d9ccf061df392a6b79282c97e7ef1be5fb9efb68398577385e397ca39cecf325048cd9d5e3c2f356b7a5053b4672b7aa47cea5cc3b5f6c4d54a3698bf715f51a8a3c93448fe1079e7f5e5893b674ffd6d4eecc2c2eee1327fd8a574295601d9cd5ed4c01dba2d8b2bf9a991514882fb8f9afdc58b3739ea75731c83037c02a43aab3dc61197495b97267c7b2d7de5e47af52df080ba9f753253304b08f8a523096f1d2a7f6b035e236bd7b3713afde960484736b3f6076f4e74c6d3c3fd84a17818c700e63186b1569afcdc0c466effb9fdeab5432f1e75356e4e60816f9947b0cbb6179be577d61d255373528fadaa2c1fbe084a151a59aa0a47ecf76a156978be1e4aebb4a2bb52b10fa00ad33a72746ad7826025e0666785320dba422808de770f5cf492d8218c7507a5a3bbd649b756840d035359e48e351725ad885c6b60c94560daae33f15f1be69f4fb4302084169197025d83b90314ef811dfb7c08a8724a34b967b6f6e7cdb5694c0d9fc0604c26de807286f56188bfeafe80bd504b087e340128753f64084e2ea408ba1bb3afba28c0642790f721e2d7f0fa04b688f1b9bc8c24be23944ae075a892087b8d6ccd35a08f03724a497911da5b6463c0c1ee06b74140940fdb269834ffabf21b091663eb1470fbcfce466bc23f47cb7cd520eb0f386cf9ead43c10d20041d7a0e6f23d642528ea82cc28fc2a52962a13659f5a14ed82d1b50552aa24175aada68018a5a583ea134d371ad0fc21e421b66f173d083c1c7e9f7d84d183d03c42377eaf1cc92b31201ff8fa146b7613d2b415ebfb1087ee4d4cb9d7e1a8aa5e2424ca93b3f1dea53f03d6bf97b71080623676aa49aaadb3a34415f4298c39ef2207e6313078835d7ee5fde0c00e44169566c3b3f8accc20e799c003d799a3bf16758ad21fbc2a6de83d70968916a0294a5b12393906b2185b2e07e82f818a9c3a49f4a657d97b726bb53c20aeafe602a5cbdba20851331e9fde159055a016846d59ca400d04d603596416035e554fe3ffc95bfd930fe42c3af542cd9d3503ff84ce5a78de90deafcd52ec33e0f06594b0c89c905d5a8122a4777b8595ee49ad5a3b6f0fd5b917bc74fdd8d6324659c9e2ccdd34c8d45547f9c3a9054583eeb7adbcef9685d7e13d8255c7c89d6ce2008ef03a0264d1193d9d8b88e7ef9cdcd0ca4cdc2873cd0119637f97f6a593cb4168476e36eefe1b4758f5e6801722e4d1e784d9ba7ddcf5156fc999fceaa2a5aa7073efffb82392aec236cdde877dfbfa76867fb953aa5d63d9126548bd088d363e962f509907973fe311174315669e56c3fccd131651e8795ceb5921f5b521a2b069e4b33a761af2a0c01d3d5a2df0f3c59878eac5f63b0ddd94cddc4881cdedbe7fe9f25e7ff9eb18dc3f1185eea9f5ac780012f521c796857613f260d72d48d59040f02f3c042722f9d3b400a8f78464514ba3296d0da556b7e2dc5821c3824343c9673fe9a049f00c46af9a5411347a6db5337894026c67a83f19b9918f9b128b01fcaa59d4cbd96ce65663d6bc821634cdb666ab478f9af5ea513847b1d46c7345944a555c4f8d06ecd33b95c0d8776b9204060f183b2e14d047628f0cf9bc67e1aae54f5f5d871f9280e49004748ae0fbb1ccca8736bd8c7c03276f24295cecc68bfa4db6c2455fab29548620b3a643d301c122d0a69d0531fa730117d0efbf52b1eca1b4b2984012e7242c468e8c3308fa3c5219f4899406dec45d62a8a07c09824590a5dd14de5c5141904f267d3e9b4643b260e215df54712dc22352e838365afade3c653f42eb5d8022e6a5ab371a71f6bc6da85250467b8f37515fc090a0fa6a4561e1b94727b12390cce84b52db19acc4e1d4a095099e0a48f89f5a29fcaff36f340e5eba862267501aca4db1bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
