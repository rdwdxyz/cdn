<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"495b7fdd55908fb021755370fc6e0135496ccfb5a4facb0f9c6a18d3bb7a70dabce4e0d2e507668fbec926a550ad35bf90526e41d517b94a9147f3af891aa30dee7ac87c7acd913f9f8105275c020a2596f834d373eaf966e8385e8c8f8f4521626511a4f81d21f9f60cd5496c8789a6b2c2143e07a5c68a0ebdfb68b0a027d455d17b724ff9307c6aae19da38dd9dde6f93e77c630432b32f6bad67c3eb2b67c729910dbbc7b3b7d0395864f642cf582084c8fbb9358b98ef7b28611c41222eab15f7c4d3ec6521b0033863c98abf8197c70f32149c8264e2d4b70c507282b7eacb43e4d0471650a597b78ab31cfdb63e2f32942935529610417db5e730524294d99cffed75cc0ea1476753019c715a1aeead1f00698ece3dae00758af4d33edaf1bcd4840b08f7e3023edc05c1348c6dab609f7d3e365d36f64e38d6c0d776b25b5cb266202f69cd5b4ef719c01c94c693b600d4a4770a4dadbf3748146f36d502264760287e4ac07f6d506bcc1dd1a8a12f754ec04d5831830d43670ccaf76c2fdfeff64aafafebab7ab48b2c309be208ad304a0162ceaebd4782cea4490d4935c2e711b758e37ed67dc3a3d21ebb6835de93de90e2eb42a82ef741d44c660e4e25567923d5bee52d566f009ef52cac94038fe05b78a4b4fb0bf7b133b78365714bfd531894ef9299b1f6d15dc121bb95ed01573217526a3bc89376e8b00136ea7d7440473bae87021770b71a484f5acec9f90c234f70f43f681889615c90d914ef3cd5595233451c1c896df4caa8ee3134c685f43f2091dd5e613e69ec893a09e92a19220c3447529adcf1f869df15438f2df250aa3c337a097a1a4e0d23aea3a4aff82afe9fedd20daebabf77a1bf795cee5418856968b817430ffff1d9534e6eca9226dcf53cd23f97b16a7c3d31920047803422ba081b9a68f93207a90d13bdc21a012c07abcba7e1e1db779041f1fa4ce14bb24ba26d6bba29bcb538f81843bad810284828859400f6472e2f3447fb3c765a660eacac387ae3f2a28049514fc2c4100b09ecf1226ca999401637aa535c6f4a1d965f5cc4085394311509922ad20e9808e7d064b0c7d832b21d63be762dc887c1497f1d534ff9eca121e5a6f039588973a8677ddf9ab599181ebcd5978bbe425ef0ce37045589f113eaf21d49b7b6c34908f980b69e5c3f640b46d6023ed8a69d70058617a6e06b125d31534e465b14912b7cf19cc32ef1a85f93f0b5d7e3e3c6ee0dfc56a7e2d8f1eec81967384d796d5351ad512f6fc3fbc3e66139906532950a71f964f10e3c7338703a0d7a27ee95f013d915acd5fed5702acf418077fb6d5ebe7b4ac4142f84709b3f53fd6ddc41fe6b7748b663096f533ed2582c54cfe9a6b6c7817464abef47d3ddf3c6b3852aae042eaab11fa93e31cd3c841566b982d89fd9ca178ae4cf72452e8e9f9da55bdc2c6f3053c2b198db1539a0195929cf6d199b70f79cd53b88078e0f5a7369e783fb26807a4527f8e4c47a6af48ec68670232f945c19afc8c204a6fdac0c74bb8080014563a0335d46c2986b0d0d0530c9c25af045a5bc9bc6860ed7f25b6a9977b953882c443332c51f1571b3f34c4fbedd1742a82a2543c26b391e00affd7a431ecf608e286b941bea6544adc91c0b4bebcdffd99d249ff40e0834d7b096d117f14c4873f9a9677522617d392808218d869266ada4b48cbf7f7f85e2e302b8f35499b81095a395f7d1286b8191b0bfe631a8cf57c98dd36137e2b497890a6b873a8407229c3cb8cc4ee69dae7f7ed45ec0bd72edfabde16cfe735663b0cf3545e0ddbb3324a32327cf43852d305152fc0f86101d8ceecaed56c6fc13ffb78bcb2cc3ece5980c9ee1bef4349da5f35ba96f655c4fcc25f232076cb29e9e9137a4f542160180fb1c92665c85d383d19013ecf7123e120e3cef98028ece39b3cc4bd6ab541058569c359606d2af723f90b8f093ee622a877411f4488eebee6343f252c0ddd12a1da5dcf0e5f49868f4055725305bfd57bc4cb72b72e3402628be17661441094b078167abd19d2c9c2c81d586f285e361f142cb2c56e9fb182126815813b362eac381fd055fad903060234b354bd821d4576228d9c0fc546c036db84145b546f9225bd29e1189670d346712b3314ad6d1080371a38bf203b628340d975c8c691c8c502cfbfe1c024867af68d59a87be1c7fcac54a402050cdbb3be9728172f45a5fa63132b88ef5f45ea3f79d7a117ba9dae04089af815c08c3ccd841a4803c03ff7643b5ac38a6b2889d2d977732c4023e0a5db23dfa80f50b23d29a295b98315186d66e6101e52a7b91dbbe47d715b26e2aae37bf2ea0a50a3a7ef36558fc5b6480216ba4ea08a2b26c2b1c8d81ecacb4f775817fd7b8d6b7a9382e8a34a1c97ab51999c2d33f4b1597b58322643974fd858295db723dc067090261464d8e257f137d18f89914b4d844e66954e3d0c51be4d19ba40ee9dcc568f043a03ebe070bc2f2214e73506aa89e02974be84f5d6db2e50a4747378e601b181ba9d5fa6df88a1d3a8bd92e069f013fe4263495c9061add232322b35358bfb86eae6bb9fc878af4dfc96e5cb38acd448d70c449cde204c41532cbe313ad3eeb4d3a787c13fa190d33b02f1292abb9b5e54c81161b4a4fb00609c1039a4635abd921ffeb3add6bc79824aab82b87e53a6e5ae4d1a62bc4987194db9e6777a7794734cd96c182b809ac3ec0373de184d409b280e40ba5c004f6581c94db51ef66dd7e1bcb8d15c0336b3f86dbf7fe58467effc33d1607332307b13b0a05d4764660fc5cbc31d1e9cfeebdf82f3a7dfb5df20ad49061baee9ad20664052f31d53099a464039bdb3d73a5307a32c3716cd06c0b99e6602bb8226902b7d8162ff658aabdf1054f748f556c49c601fdfda7ab2392ea968f6494709620b5f083572b2d84ece9918d07e13f2b2d2afc35c921cb7f08a2a73d4247a06f9437c5cc7fe2610450a9a10d1f983874b9e288a07dc28e7441d08f79bd2b7f224c81c13ffde2e92a32102cba7966accb6a0769410a0128e88b158bc1e0fff9ce6ed47c14195a7ba8fdff3f277af06da4bd28499bb41a7405e299313fc6aec0a9e45d2c8a548f9029f5c37ddc72dc53a5a8192d28f0c7caa48044b4424f33331df0855bc2c7f71e31d2a7a0f340e038a15cacb9b655e9caae05cca384d43c8eef6e0ff956084a10bcbaddeaf7c072cb0169f98655a97cf06cedc6e376bafccb9e578bb022367b1aa8a55b045d51a63855c37f5178bebf713787abda2e4fa8163cb957ca1477aa3c6a19ec4ce11ce8ad9d4fe8a9c02cefdb68434cefe39eb69f84af351d30d02917856b79d8cfddc487227686e7747921ebc08cb65daf97d9c460d6b834cab6f8c17c45eeeb16df3d0d6a7b0aa414f7749a4835c50ad3028054c23fcf4d46bbe6aeab8aea45f27abba90795a193d086fac556245a077fca7aa1b5fdd5a6403737213e8a2f512fa528173cb7cd5d8cd65eee90930326debc8dd4a8e53da255db0048ff001fbb57e610353f8caeae8f24fa571ea1ed64591a6a119dc6722307b08c00867f7282e22b5fb087c03b05982849ab05dcb90a66d8fbe7daea2d18cff41ee3d3fb41ed6b5dc60f2019b64b1f7c31a13e3ee2c48c5e751b61c1ef647204b94f6389061cd54a046c49944f6a92f60533dd0c89f73530652f2b3cb97b4114f90a24e81e9dbe98263ece278106edb651a7fce77b63fe894257dc1a1c5551a982a4c95b1693a85880e4a540649e58f6b1bc1265f62b366b75935414ffac0dd02db03435c0e39147f056507d5a55151c8e013ddb9e0514c52effdc67c454b13f13f54519750e2bb3337bd32eb903e735bd1cc4055185bf24cf9bc46374c0171c4fbad3297f793a6ac11860249b96be0bad40c7c9978be4e39c8f1ac4bb1819c1ef55d6b111d36245410cde5e027d4f0f9529aadc90f133b387aa909bfc8a13381b0ceed84a7452f6c0267b00c2fc0f7a48aa4de51562323c444891a5853b5e37a912cd1df545f6c6b05314df101d222c3fbe2a74f388a22df0932eecb84fccadeb9b71fe93159dd054d46891616bf1c0e25567680439edb043e7887e2f1b52daf8756d1d1f05caabfd47c05ba0f997aa23ee331834d479aa3003f2a07058fc6ab6fc949f5bcfa1644b54ac8b54fc997c214e67cba83540d14d0d22fb1ad9f069de48f434ef138845c01e2c9d03b28bcfb43f168cf899170403946ff8b8f1a8c349f8033145546aa51f5410c2655c9e419ac3a396cc31cb5d46321d9a3234854aa3428a9f8da372ca6ffd9496d57f86550b36772133c569853228fd0c7c8705e619df0c24f8eaeb04fda5d71a4cc17aa99cd201b74e6eafc63b57f097b0a5867d885aa7914bbc36540536188030f556ddd657ab5848d66801f2940262bdc9bf4840b8fbdfc77749e81674472468376a4d3b27a5b9c712c11859dd3bd6c95287c559fac916b4619b7d46f8778b17a044eb73d2cea5f1c6801c69548e1f1b6d789a05cdd77a27a5f0dd646ef8a754853349e60a0c139d2fc3b6288fbcf0332eb48459cc153b4eb85527ca7a2a6d12bdd451be67d37c3f65b4cee7f5026c00c0bc5eaa87fa3e0a4f04719602027e0aa0cd52970c2fa8af79eda91118eff249de305b972602f186b91f717de1ac2fd645a94072f0fdc8cdd656a1d058dad9afc09ac739d4a87f79b5580b65b62a2b0a930f006602abe2efd5da1449460fa2159e25e9e331fb848718f6b4cf0340bbd95d482361f0ebbd41b280aa589fe7cb927c91976e2e4f242b65c432e521f751ce6569520a707677dfe6e66168e4f6a2ec087f3796eb8c61190b6f5849c849c6bc9fe78aeb486a31ba5f7fbf5343711381fa01ce7c3d00bba47b1655a97bf581a97a3430fa0288a34f9172c43b3bf4ab29745954d10c78e036a1bfa70426c06a536de311d557be285bc1d452d47873dd6bef948dbd67788460dc041d44fd7cff263d6a99254bdca581ec21de64c7c927354b88332d0a52cd51bca3bfaf74220d845984b849a46e7d721ac98dfc45b1d60bc2a8367f4c6cb44024734a6eec3bce162893ea5b5c8d75f5668c9d2b51e907d60c55d19e8f74f2267148288a551df6b3e128a9032ba3d90c19162055c955df85b7c6ec1d5b463e53ba5f170b26a46bbc98ebc02be8cbfd8c4369dcd081f9aea32002464c4ea1d9a8b1c28714cbbc6dd50bdf4480d0b492efeacd633328ad3222b92fff16162bfd9cf81e127dfddd1dc24acf42f469231c933e3c2f8f467a2ea5006f0f058ff20721d353e0f3f1c0c6dbae532f82df65b3b523b696707ca06da7f9d324da3fd2e49a48000f027571c379c10cb6c073b8127fe09d0800d401ac43b3237854503313061015f03f56e37401635cdf28d15bd93eab6449b0a941861dc080714da22e3627118ed01861f743f19b8274fe80e8111c42dca3bd97502006b24fdc8eeb6883d0ff121a0f7bc7bdb210591d2f89e3911bd9eded85b2fb94dc316fb8abd5b81609ea55d7151b52627e477529952a373a9230c5284b32f59703f0116f97fdc801dcb97f43b289ac2b3c55580a9b042d60324f818ff29514f754380d2e96d18c4aaf304943f0657eb94d61b69c3e1e730f0289826495a49a51b675e88fa8c9c2de781339de441bf28b8075f9ca0df258b8e1328bb22e51f4422bec1f09c2cfbb3ee70f8f17c4b77066409b4f627c6dc8430dc2c1347174cb94d2b7bd70368f0ab40aef866a955688e230b28307d61fd33dcdf133143f503ab7c72b735275213b5a48a07824a330ed7cf48ba7305b1a2e43765054c9655e18917ff2d9c9dc7898a013be5f3e80351f7a3e534d8e754e34fbc8922d7ee3b220f2b4640230d6fcee4b18a2d04542ea1a9b2e6a29d011d4477d801c070a3a40c4e5865ff673185d23871a547694d18cc7dd54404bb4188b49317c95567eba8d56e2e2a85b4c8af6c91d3fe6b6602157a474cc3bf0984d4c73e5e337563b0a730b8941bbac3487904e33fea4018d47f34c957129568eb37f45ea3b3d88d6605516bb25aa6c51dcbad18bf74e1863fa446488ae2be0582e3d1b282ed33b9857af8303beb57ba5a6c37a7ac46f25a38861e2b8204730902687e4db40194609a5047e84b7513c93c358d988c713b0dd5201999cd1f2cd64fd4baa8e9f066d9b0179092ef371e3343d688e3704e00d480993d5a6c0ee42e4db2d34d6a79c9a39f1df46cac27638ecc9e5ee9047683e9af87a89bfd83a7ff35812932271e2b453229e9f903634d87f0c8579cee4da945daa079b2a79972e5be6297740998cfc11a12a2f5557f19c12b07a56e340c0e6bcde1b8e4406485e64f310fb00febaa5f7f48f67c699bbd751a1d0e7283b4dd0aa5837f897ebcd0b0aebe5c715b8cd15056e9a4225219b954bdbd5d6b970af2211b1c1779838d9ad00d3ab4fd15f2b15da6da4db183815077af24102b5d9cbbcd18a3deae67658cf40a22542f1b09cfcc97bba66b43389ba62212ccde6471db2fd1d7de294e9193b63a6b67e25331ae2edc72cf122db3d6e6905a3c9802999982ceecf9fc300c382973b4a33ef94a1dc09ddd686d2af2b68bcd018ccbe11f6e0c4cafedc1cdd655efac6b920f5ca619d59dbec0eaea5f2bfe4fdf15a8f976d6867a83f236a663bf2e954a892d3012607101ee8bce842a7ded63ca8009fd320ad6d3942c0df9d991c324f22c8c50896e7f7c545b834c435c8d2d44b4ad07e286d6424dbb4ef35b4f2019f8379be6b928a8ef87b1a602f57851d733c6b3fbef4625c986f3c0a9dd16495fe8190a102b6e82544ec93af2bdb1a880f8247c8333fedb1436db11f0d6d014bc102568e0f4a700c6b5e63b3560d6be60de80f2644dc619e9bf51efe4775fd87b9cea7962ffda6a4ad9a4bd6d39a39cdaa8d54f1047325f456b14ac74911b9114fc43a7adb0c9a140cc993d1116546143df3715c43b63de8f73353d8c8cbb53d21ee106d669286a2bbcf2822ed8cf4fe96fe2681dd6c6075f52b2aac4cbb9fdc318f3f1c1f9cb8c8a34545d6883174f7af62720314a0420dc10a515139223cd14cec1611e6cfc3b71f3d6138a30d1700cb499c95584744e6cd98e46d9eba3ad9632cc0481478878ea5cf0001e45f2759b43ab3d898419d51e24fbc6846e4d82b734a87a7c9b1822216dfcceb15c5e32822921e54224236b9542626f03b081caae35161f9cfb1f9b415e4d499a5a197ee98ad84bf6c1b055a90ea39e604eab4dca26826a48dc189a7fa3dba8f0cd1314e955c481ba45a6f514398cfde1b65d8ffe2da1f97d8d369342108d67a35de8ebed30732bc5c276777403d114802ccdd6e09a1f7f568096e7a1e446dbdb78e731dfd378fd57c0aaacc7895e6d1cc4816c7511f099e4252e3ba6a73379ab6b63dad5e95c6cabe7935cceceb6ae45b9e9604ce0a7071ab1d32860b8ba6483cdee59379413c5bc1cc9b7f20ed0def45cf3d2817459738d68893a556bb421fdd3b9ff6b319d76e6a55fdd1f017c0d217bb91a23112c845d485fc3015fa2d82f3d73fb1673f8ed48896c20eea29578c617f32ad37ae8644402177976312af2fcd0ec62e74d3e8f24969e8578033ed2018bcf17038d78caad7e8c93cd114d89e30baa9c6bdb64663ac1770e6ce31d043fee0fc6b5ccf81932a0786f7fc28462a23d1a281f1c145efcb1719fbe86556e3edb3e686c3face7b0b312038a9fa3dbdaad5c0a56a42aee120df9912a9be7e6bba96bf5e4e33f81e820dc7f95075d7c2734c6412018eb84ebb2e5224df00efd97474f8ca5d3716195d7e9bee0ed6cc67c961a859f10be81d00986a2e4e646ba2fa14744d5dc2fc342029e1e965e297a565cb5021416502f22c25f18d0cad2f5836e6d8f9f3d570086d6b113af108488c2c97332e9d0275d9a1f5d40e8276c6aef314ece463f6eee316c6913e189c8d4640547f0ac241993621e8832cc74b69e43f84d24c91278955d77567035a8028598b9acdebaaa196ad13bd79eb799dc358f04fa66d9995b6902f940b95245cb0d254ce40acc9920abe540781c90f868b9eb3743a8f47cde9658a4b7839d8eb22a76157433cc043caa5fb8eef0caf1d363cf4c2468871e35de825e28baea8be92a5a257635ab53a79f25cfda42a1256117fd05de5758dce7ec5523284edc4eee3ee5a5c1251e04896a731f73af877472cddd05c0bde641cf21a61a00764f6bd2e3c73f22a6e916e9a541426283645da3be46a211a7d1bb9646ec9a30051a48ce39857c26e971212140d2eca5292048ab1a7e9a5e0f0279c103473d15700080248592146b5f3fd4a985d78e25cecc02ce5907b749f4a2218bdf1aacac0d0fa38e896723454cff18c10bc367ad9ce32646bc5016e5c227e461c4d3cbfc07b845b28d4bbb7629b8d8b5ffeb4ec38b025ead0297a0c195e2987caa1161c0baa53ef1ef8837aaa13533aaa8d05b5c4bdec1c96d42a1eed3883e1d685ab583ead85eb49e34f7ec98f6a331aa903a51dcbf68e09db9d7f99f10810c0fb0ce4d65c0d18e7ecc42942af96e894f1c8f909be7c48627b36e20d01acbda574dee08e4a499da709c98f66e248fc8868ee1691b7af0915ca9ae1018785b1c995b73b75393b21ec46b80821a9e7167e0583e0a3a02301431dc2ab138e995d9e419400fa931894af7e07f09dd9ab2e11004b5f7eb7c5c49b1d07e49fab37e549af761974bf8df6d78023520dc367c3eefa2b4bed24a2b7c6097213afee53e321b847b7959076ab890e38927eb42f58cfa8a7bff12a333c6b366a08f71ee7320a41c07803e664d685c4e14b2470fee0415c27e4add31d1e8af0a54b3477cfe4071927b855ac307517170b2741f27796d49e92810e331882819d428a362d9abba7548441467a6ea9bb2e6a7ca46c62df1d52d251c56ffa0b6a9f788ec306b793840600b9a0c3f72d7f843af23f6ce68c2153ae9fb8acba7df3de186c4231ac76789551f1fb44e118cc66db372fe9ffe6f8cfef05fa5cf137acecc35be8c5620fc495c7ef3ff0fba6574af56c2c0ccb4eafd114c83c71a844bd83566ab35ace9ebc1b5cfdafdfff54277599707c949d524af6420ab9eaf8ac78dcf665c5d153d0621b9367d97b17e443dd3dc404757451e94532875eff12c0640b15c8f8b34e7afc61ea8eadfd02da68abd11c73c50e3d63ddb63c20cd145e1fcd76e608bbe3940f00cb6b0015be68b3df05594789e7b4be0e550a67a77497c274e8ed3db3b3b472c03ae7f72814c69a872fb70d2ef1363582de27cb7764e233231fe47f1424d48f5cc008cdcf2cdc70d2f21813fe8febf8512a56ffba8a3b2b7e34a621f75920f214571a5a3a1a593c74c088d396d8921d768d42173de7bc0f5184602c89c844e8f1cd37d8d5272ba21415e371c21bf10042f62c4252f2a00a38b18a9eed20ee7781f923dac7f0e0f250c0fff6cdbfc02d65dbf9b101c04e2daa81d1d0490486316758dc99ad550ae0602a7c5f7bede20ca0ca0081d624bde4c9b4fd8ed4c581c6c909b1b50ac8ee910a61f15dc36ca751afdf420481e0638032e13c09360e569d08d1cefa30c70bcd46961f76d3a562cb448b9ca8d96eda08c7603b2cef4bf23f3406971b15a77c3ce639a9fbddf08874db76dabe9c0e61dad91b7bfbcf3e9f7337faf678ef037ab42dad743ff89634b461f6e3f5d98856404c54399eb23f50941f543fdaec7da5468d21edb2b57e936a0d40bfbd230556e8cd05b722a5ad2a03323d873c4d9e6776d6b8cb71bf64a0023515c0beddfac62f8bab83ec83a7c7dc012afa047abe5067ddcab7c40f6a3e26780623cab4b8661329749f6a9c9f4a4ce424b1496aa7ebe76a26d1699b9206884d71488376c073d0b0bd75070fff2c4475f13187817777337eb9cbe1336ed4aafd9519e494db1cd678d0c5882e215fa7ba6ce8e450e936e4e161b787eba883b7c2ef765b5e61ef175984171d9a46495778757469ee138de7729f72bb237e9b04cc0c26cb9cdc4e3ea5ca69d2c6cc0d3359d3df651a0c082daf2b806823de0bc11627da05e6f308fdc05b413a11a25582c3324e6ad5730c7f5658bf5759ee6468ddea3e5a57a175846f0ca0783d4bc16e293da4db27644c6550e3deb14a3aa35d6e55c30868b03d5e946817868409d69000b9611985c360e53949bae32dc990fa14efa02fc1778ecc87662d772f80ba6be86a6f94833344426e8b7a05123117d77583df26847d954b536125f2218f364d798e12169b8f5b91fa061ccb48573b57154959fc5f5e97fdc55e86c96ce072833c1e8463a3aeccd06aad9be5f014f366d0a39f0835f7e4929eddc4027b95c440ae032e7140d44ad69cec1ea6c380403ca84a18035ecc537ce151b9526ac96eb3f2e3633fd17f63cb65007dc0af5685cf8fdf2ba6e98f6cdf80bcbed2859b5342fd8983c3dd81a569167c77a93cfe6f993f0e6a4108c43227e124ddcbd9c4dc67fd54245f95ed2ec1985423b1d5e610689eb613a61fcc33e0a18e763068dffc134dedac29475a7dd5a78e6489a422a334ff5c571093589b6c94921606cb2b43c971e95b949a65e4c445f184fe6defda6b59aa3bab19ab27540e761884fdc1ff216fdd903707be8d5f719a7b1928ceb99dbe95a8c65a23acb87ddf8f9f63be95dc747837b4607846c48ae8f0cf1160ed6e9f393d84643711785433acb64b8b9350618f71305e64b8452354aa52a28fa359822f894df35a1427b42015f1da2c01c4b1fb247013676e079e4f821a20d4a13209c3e32d34775fde304688f161416f5f5b605b2f9101f570e2faef0beecd7fb6ffa46e832cf70c018405f0ade1213f8ce313fac70365e1ff8a1fa952f7de8a8e821c23975186f6e80883dda0ee616099eb9b668448651dac30ac732cc934b6c49b3a326dddd9cda0a21de6172dd9f7ae6b64b5b6fc3d65d8e0c26f758e10483f05e934e6f64f618dd9d11d93a25caf121f2b03868c008e05325f9ee022feafcef07475b79c7ce45cefdcd0e375eef53969900adce6e3c0eaf3741372c0f2e5a7dd5185727253b1b335c45337dacfc50f325a9586319c2c4bc5f71ef99183241ca4e8dbc61805327c5573d2c38f850365c3fc5fb64549cce3595997fd371674e009631e7b1cfd4dcd59eefb9742abd829b4dba1420d7fb2b51babd9863638b571bbc977fb1ec65f4ed09eb2ef389f778fbd02288d675d245d816351d6891122d6662882804f5bcdc1f2d7912df3451e392ba9b16868d43ad072964ce5b7bfd57bc2bcd2b9a57c8a0fec0f27f601a45efa2f01d2a3e7a483716e7679e97e8c4b8ecf01afbb4e1e350c77a56f62f7c81a7ed4e1f1f25ace4d8be06d26dc3db58a404fec53eea568390749465a3bf9d18a36e267cb97f4837a76931ac411a2c503664201fa7a46e0a1da33b6e5c17b11f04ec35be783162d424febfe4210f446a703de691b009e66ca5f422dab2c871107021a193b03158992962167e4a5d0bc71d80b166b910d8f18ac6fcce149ebddbff531de387a771ae1f8fd266d5151d1b3341143f20443a981e4f198d8398c46c02528044cf320608201dad77f93eab175a8ac8e788f0dc82885786bb038deda0142444a2b0c31b9b45016533c104cf767e78ef8fef5ad6d163f2b1f4b5b78490441eaf865cd56707d9cfeb2651e33eed117f81b6216b79ac70965063ad5260b808c4c6f677d3b9ac74e6829bc3974cf802c1a81ac57481461e08f8c35a4210cf1722274a192772b2529383955a0b8498c294bcab2b488d86888fc35bd33921a7ac60cc174a7881a3e9e48685d9d6144eda4163d6e55b87e854565ab75c7381b6a84464e24de22f014a34f1eefe001a4e6dfc39e175f3f9d8d22d3c4f2bc6ddb50038cb60b82f3b4e2f6fd4e7123b8dab9179525ff80b5dacb720238144605f58eceb94ed5fbcf7268d3a281d2bf8ef1a399e5a0b1299d24140af9418d1503cac1ae19184c49061655a15ce5405d65da9df6341d81d203e48e39a6584f1d065a695dacab4600b1cd145759ebe28aa43b570998d865e5a1742601186ea5bc33e07e0096cba9d2568ba51e4bb00da54e4048ee5a2caabb7c37cc1ac1ed505316f02d603604982fb30f22a7dcb55b6100b7ba940f10d0379de119b55c42d48ae7282341f678f2c45478a5d5e0841c2a0afcba639ba376786d006c64785c7aa684ad96e4a54420c465b4b859a4f85b94e3face81d88128e34ea1f46de3dbe39b6df247e0b07164ef2f02edd7a973e682560a0a2c3416a9d1d0789100eabfab9b88f3b31dfdb32f2a7d6a61f50a126d38f041a4f51ebe25411c17458b936211ed6d011d544c5ec5e1a095aba1b50389fc673991d60b6a3297097ae640227fb4467fd1ba454ea43f0dee2789dbc0545203e01006ab5f42c826cd6f5c7e3f1b8674c13bd49ccfc99968d16843eabf9aefa880a4ba303eed61c72e507fe0ee000831da661d2a48ab696d3a41e6b51d85e15f2c01b7fe1f7fe75a2e3b0b071f16d816e90d83880ce754d40cfbeebf67e54bf0601516d06c382735b23b5fb809d4b35e58cca1a7d214796de2fc41d932b49977e0b1b71da2d6f5548e2ec0de06abc48614bd39c6f6db5efa59a88e33e7ab494fdfeb523881307e1f9334ef18d667f584646dc09a40e0a320d337e38968a06415216fb727f1e509db288a05edeff86c376069550d37af72bc86a5ae1f4aaf096951d5337bda3ea4400742bdf9a5da85e4e64f523fa0056e839e30aa6a33dfe077fef6bec3e9de472eb69e2186b17142995db2f78d59e5d167d1c1fe557527de4959ecd83e0f6456a501e034c9fb7028720d9e9bec6811e93400dac05e8c2d923ef36782fe89ff30c6ec876f309480238e699351e92fa768e71b2b8501bd40040527354f821e44c00b030452f33c419fb32e808f84b03d75842d11ba929bf0798bf7a6fffdf993dd6abac2743c4f334f3762ab1b4cbd28fe8d00fd815a8b5d320a92986beb363dfa86aa2c323616c9ad716ac949905deca07de9ecb4ab82d1a535557bb24fec17fb5cd748f658b8f00753834680239c5c09ca93fbc0fd6f1aa7ff39fc1078d82ec5deadd6314eaa77a18806f941fc2a4d6b069d166d68e78b434524e8f02ef6e13981b3f4c14e9ca6a8bd21d7625f2f4d1078fb46a4feafc3a8728700e8cb258d5f340f9d4586a6b7f133161cd1c66780d904d0e9fae08a2c4f16cbcc94af203465a07d02b2634e9bc9b5584d717d3c196e191267da73ac8ed840c7f86981c5e5b0423844c795aa97686e1f4a4c6dd6a656568c53ed08b64fe0634517d10559e14f4d1bb532acc4b129d73c31e8b1c3e8c1787a9ecdff1f89032dd8e64043f2eaac995c2afbaefe0c340089640915b416985244583b6f6902aff16fbeb2ddc86eb053bafd3ac69d54b5a0f6cbc05ebbcc757d77543bada3257c9bb0b5b44409b97ffc9aa79abebf25cdedd735909450ed05bb4ffcc0a5701d1f6743c96c4cc42d0d826e9677b92fa6a047e24e74e8912117980ca772038bec5a55a40c59b974aa130d4ce4c3c29379c61869a7eaa3e5b83e8900ab878e9f2c9faccd953d36414bccd1c86b165a29b58e5a74c34b487e89b18775137f3e729b3710a5b45f78aeb38fa60d62c4505de1aa661c02c16d955e8066be4eacbb07cad11895ff8ba38118dead30c79eeaa29b3b93853b8e6a93a0a8fe4d95805fe0a4e8af462b7cc37486d5691469c7f13facd6bef2bf6b9b5e1ac2e2e310db515ffd67a288efbb56fbca3a540608734df088481c121aae1ab8f06cb8698d1e370ddde501f0c4d2fc3ba13e800722a6230f3cd7a3cecb2a3c7a8c0c40769043a4c155958432951bc82689e9682a54c0b3e9ff5ace9720ed7f35f317493585c38746a5e4bf88f618120f57eb70a081ce40f5391395cef867683babefd6e531cbbf362ebd4a0aeb31f11127db96de7d9902578b08f4a52a3711d9bc294e8cb723ae6f40452a2cd0f11c3275ad07cc9d33cbc48e4b8906ce47bffdaee86c2f3f123d0bdd6ceb7c346fc9f65dcdcb3a813b87f30bcab9df7254dcabfb9dd35e275e8871a53d17d25ddebd119b9ad0e836b76cf501795c62a901b0808d4316fa7753f0df3fb71b255e6741fd441e34d17fb3bd91c03f5763231990360b3519703f883f23a772fe0be6b58da653b58362952bc5bba6da7a373c86abd4a84bffd428b73b9155d8298cc7825f80cfd83f4dda981431b94e5a4c84462020d2057a3351143c9e2a3f2d658b0f53fbb5cefc86d32ba4fb0d0bbe9d47a5c70c7db2a4fc1398730acb9bbdf154d6b2002fa76f48e1c5e3de79d5b34e786401647545ec495851a5a0ec328be4be26f29e3a7a53169a15cad1a6a31fbeb8dfc2a454f3a45d207c53c8c4663025d4d7f5ac7dbe08625487d8f77e34cb74c1ee95a5b50f48535deb24efcac213d58c4d4f44ff5ba42ce91c8cf1b2ee134b6173a7a8d8c88621cc6270575373fd1b38d17bba7ffa3fa07e511b77b1f367b61db06227de34f85b883cb521e22711ac14fa6adc81146efdc3af0943795637d7149e504a37ea42c08216bbd0dc0700a9e96e296e071da3469fbde410af7d0afa3be37e1b33b8a8d20dfa1f313e4bdd2f1ae526a549dd45d8a0091a7441b030e6d4d8184ef082b5e57b5ed72110ae6630d2ed6c1aad8faa4446f66d2d7dca24b0607500e8f2cc284de1b36db0c4f4007a1a7e4ebcfb3b5d9eefea49efe6bc07c96eb7b2f13703e8116cf51bd4d53b9604c8b973363bf1701ea6a0c4641566fb8d7a5578f6792f4cee0a676df0336714a7d5250c70aa5c53a3412a2926763a309c298289e0955eb65a82767be757b18d8fbec860131e3f7793910cf65c9bf3e9ddadebed6e9b92cef9cd05338ba38c9a89985ca3a29b61422b1ceadaa8fba88638f6e1943bd837b81c093a122ecc0ec9b359b9c78d39c9bde892f911892a934c62b3010d1964cd226d76c8f4aa651a2f4af1b110d0c9f8747f9fa9c94f543c1ef7a2bb2bb58398813625d7eae249f843dba5f1bb21a718a09199b0c32de4049c5a608bdeb2168bf790d3fabf6d98783f6e1b9ea2a8db0a29fbb6d61c85cba94f5deb733405117d13c3de3c0938997c6a731fd514ed3d3329b72baa5c420d774fd81dce028a0cad578348a7aeef8329820f3a0f4b6dbf82014ec6963830d2934381933ef35973126a0705291824f281f80ed7fd42bd5e849ff5817d664088cee98ef35a1dca32db9b50ffc11907dda4302dca5a40e5eec4a4d25955f00affcc459c7bdeb20c575e44ca0ca652b1d6fe7389527b8cb0e0868eaa7359bf68436d17eb0d20cef123dc491dcf86969056044896b1d35713c9f3a7f057dda71c79dfe2ab3e6fe4d485730b12b75af1b312912c5ec9adb85e639de4e3b4b904a44b0b2fbd1e65de457db52087e7dbd249b45646f8860b1504c4ea8a4e4965855c44831c6f8747f6ba6373afdb2e9961973ab6b2eea84bd22c8c1a3b201f555968d64b30cd5677ccb438ae57cdab91cf7709cba53b2ed307e71b3e145e1cf2bafda7b59868cab4189c1852a18dff3ea599c4ca0129f3a55f68c0ad473b53d15243766a0eaed78ced139db4003a823435b2176e814bc065e1dc8214dd4d50f7b910a6ecc3ba233b6e11ab57dd21f14c44bed1e86c5c1e68d8f5240b20b5d92643e6592062bf4b4b1d414958f4438bf600baa07700fece729ca7dea1a43cc553bf2e300980db0c7b3d346fe30e4875fa0059559dae333d73114e2bee4b74b34bed13375d9d4ff0e074cbf7eb52ff32eeeb6e2510dbd334336d4122a95dae25cf484bbf45e5a118101c34b79d18b5b417831c742699e7279ac9feaa0b371a6c0c52d57020bb1adb8391b94d72610e2cc22c58c31e8282273ddc3eb6f78185867d608547875283b332d67e45014f86e980548e814b1cc37697c8c7abada7b7bdf712d7c421f5f368de3542b9b6495b14daca02bba0f99e4d5b2b9297ea4d3bccdca0aa2d827d5f923d48307d2c99dd774ff82d88f3f041ba75467e7d96be7dbcc4155ad85990d5afc8bae7ced504e8a0458218a3e756e53f29ae99b3dc12075135e6676465ac131c82087f26a1072ca19877640c76da30f5864add6ab3c4d375cd22e6bafe258123730d3813a738408c10bf7fb1c223d761ade6ec7fdfde2a7e0bc6cd06fe42c1a02a0898ebc3d1fdce0cd754c00ceca4c2d07e6791bbaf5ca4ba7b3271625afd7f146d849cbec7d7b12aabc75e630cc431f11532a6a3c20f3716abfedc4ffd58f76ca91fbd791f2c3bacebc211213a76b34abf54ac1a7ed2dc3129249da9e6f7b1a57d76e4096cefb2924955aeadfa8d7f583a4972fe7761613bf704e801362e896e1a1a70d5aa2a5823c92ec3020a6eb47ba22f56a779b098f7f34f77bf8bf1c93f24b9e5c38901b2503f656c1850f70f8e76ebea7c716768622f7ec29ae9b46963b8f976f9fe9ad0c8c261b37d88e2b89c739875ab239d86487f7d8be4584d108263b6c5faff24f5609e2e7fafe62cdaa0ecdfbea05bb0966b29102daf66c67e48ff5687ebff72eff1b3c9db7f5789171860d7a76a61d4ffddff48bd14014a18a5f236d6e898b887fcf5106babb9196c8975b801f35bcc273d7c1ef4db02ebd23e48c2763937b1d44a9c24fd5f8710f95befdfa8a9bec9193a156eefa364efc45c60a25b95d558491bc27405243d8aa1e484cd67a6623a54b11be280f95a41445fbb3d576a2d7d9ea3220771d8d4d6fe058b6ff2b6ecff72db4cc6ab28db3f44acee0e643bbea1b5b62a05cb11182c079f1ca195466e3643631c8520766baa3690470f5ac81731e628fcc7a75b0b8baed2f3d4b90329632c4c71a3efd66edef9aac5c2f44ce559884aed2291b202161f91e5891b184bed02c9245799022ec21c8862b74835c11066019ce36788627b3309ff62821660806250e90ce25de82c82a08414dca7bef83615db37f3cb6e4e187d3417808fd87565d58f5ecfa9d77c9575ba405f73b052a419845616150b73dd589bd0b697d2349ae794ad346f0839c02ba210d767de7cffe3d7472ec632a9c9f782e6c65f45f758ccb672b998c5c94b59165b6566b4a3f19f26b7c4ccdbdc77687ac6befd5a240c9e8b44762754dcc167c1b7b403944044ca7b4eb69cd53a1b7d2c39bfae42ac1ceb0d8df56ae8f1cc8b9ad34fa5cf1d6a789e4f678d0d8a1b6d8d202f5dd9be1c6c622c7e04b819df14cd1be7254a1edb1d63253d42b5ca6feaf61f348d57c7c716c54d1b06ad136116978408fd70f3eebbdb9f0b116b7234c7f70d3ad51780bb65f493f4d53dee497b50a9a054d292ca5aefdf0d53af7ac4ad6c17bc502543160f2ad6ce0a786e118bb5d07cd5a1f184cdcf52b25ec555b31f44ac2f3a56bcb222f1f9cb4d7d00ee025b4d1feadccf51d4d553a75e9fa5a51597e953973598e69d76ff5afb98f450e3f3f9de12e8866cc3b2456e449ba5d57cb57b9853ce59a9533d78dc645eaf9aa64d97c23838996241c06a40b81509360493d367ab047e7ed88204a5dc69a0bd10936edbb30d455202d73762c4ddefbd9edd56168fe7d3c809632e9e8989d55ae37abdccd6ae433687a2f3823327c2c5274b5798e96ddf7821651e0e2d4320c513553c01a2617cdece7df12a5101b428cfb7069b437eed72445ea12e3db1745edb2f079cc9179d96869acc339f04737f2a6db7d99821d25cdfc1cc220add1267d09c6afb5e15a92fd9808b945300a330c07d6eb6043f2606e3cbb3f7f8c63f72bf64ed42aa2078f4877e183b700381962d8a67b16d992f588996e1c2255f9bd2abbad953f8afad8ca986259c942ee03a5f61af5efec17df940a6f5323507c72eecc45324012a27810d6983a952c5bf4d73ad7945f6a41899cae1434a18099cc2d8bd128a28e7e0a2dbb235f6df58e07096b3ab64a07fa108b8119a95d8fdabedddebca14688ce5680e0cd3daeb1c36f33f0c6c13a47d4bfed34d29736dbf8e8608b2564380c7f10970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
