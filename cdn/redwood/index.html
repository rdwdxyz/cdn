<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39aac139931fab575f393e26a4c7cbaac0f93a92fe1abc455fddd0599b327e2177cc1e02c44619fc51b19adff9fadb67a826f5da6d37953d6e81b7d77f5343a6e3d01ed3d78502d336e46cf082492db3d3e87f7b04d021bfb13412545447bf76ba33cf1be93f578e61ca2a3db1080c0369c24023d7b8408db78bf46168c3a201460fc6865aad3b9452767b35626ac30dd4128326ff65071bb5d9a80717392bd623ad9bb99541e10d3dd2a68f3bae7c67a274b77cb03f6054e5a28280035d9cc3115955e37a4f07911790c6cbe971e200b8716e1658468c5aa7c94bf94f933519141409f2c7b2ae0eb562d752a2f607b5e36dac63bd82ecc878f55978e7b5aaffc0bb6a7fb850b4b42d541b86f054f74dec465e41450f6d3e2566ef8c94f32e60f43bc5c1bc0442c33a3fbea1480b2acf4e61b1558585093d07813ffbc9f8bc50323ddd2789eb36fc3ace536619e43b7bd71979b9a1326ba3552f818046b9edfc61eec09065c815980eb22333077582129a9873d6ae952079c7bc9ee872b500950ec475445ca8d77db59c3afb8919a520e68782fca745071c0b71cee6b4be6e5e0b8b223afec431a29369ab50367bf37da37aafcfa7a39f5541d7947ac42298ac9fa03190a8107740a595d97060cd4e980ca9fdeda682298449509672783fd336dd4050911fb5a1e14f02e71585265b31e0e46cfaad743f553d922244b40a667af926008156ca96725b5937fee99ef849699db41a6dad49431dfc6930412bae1f341cdc3ac01b1cde853c8b800a0d82fd22494a3f856a4b3fb4e01ed493f231b47d8e4261c03145a8955a0f847e0ecaaad0f7ebfde477afcf0686f5b090473431c658d1ea01b567cff0d6ad009b882c4317946532eed74b77bdd26a097c6ab9285ecf2325abd4ea9d376943aa5fe3edf2ade30d52630bb9d8bb7cdec7ead1b261eebcf8e009846bb5d8b3da6b2ee5188220206210c9752f28c31aee42316638baa4aca752ca424a2dd97700ed9eac45ab7a908e48022ccb3149c4081e2c94802d88e1fc6764086dc4cab40d4a12f823b86245e59c9e89298c440542c97ef3021ddfd53436ac4f852241e1327f62557619491b9a0ded3504ca9a7f7667f555db8448cd4d85711f267b44717ce50c2ab915df47f414234fb397e1d01d3a77f21fa9cf6a1ff84ee265a3356aed35db2879fa5fc0d7a592df9b9a5a3c0614b111df79a0d21c9471a510ecd4866a309020dcb6ed43bc4677711c1485cc400f8d98de99d82d7184110981bb7c4352850f5b83961be13dbbe73dbeb41bd4461a9294298883da6a653f3ba44bfe0ccadcb91f4528918fe135c393291c8ec151ff218d23deb9d3df05bfc2e310a83f4e31d578387cd9ec8e2ac1642c06e0e15e8f6da87d98f67e326dbe3b173f2eab64ea6ce0a8a1154badacd45e8479f6290164b1c565731b2dc389208dfb4f44e2df229e26ad75df5eb57304d980037ebad8e2bbf78c30a2e0ddcc456e04f52fc4d0c69d9d9207a224b45913bf7acc8cbfa700a00de7502e1da1105593850bade82370ef4961bb578d033c0db80dd828d7304f01df7c80b6b5843fc4c2e2f1ef617dc95ab29ff190485a5e558c4400574fa52e08a887fa565e108e9af5d24fe9d7223199cd86b814d74e62562ad52b2d933399d8ed8624bfe7d26aa65655eab3d5025b6a048dcd159d707e678114317d575384cc5aaff18335d9584f03d704dc2ec400c27edce0d916676052a264e84d824a0a84810d0bac68ffe5fa07fde033d46f3c176b1b57fabaae597a5e76f556139d7f29a9428981069bcde0696323596ef428c293d4c2eb71a049cbe41f85a2ec74f4611556202eb9ac0bb7e7973f7204a29f0d6fe54286752048a6b588439e8aa14b4b7e290a4ac86b5df0d6d09b627f1050024fd1570b23b50223d81d9c82d160dc59a03e450b7b4b8bd318a5b7ee018f0cf7f148a633936dcb0402e50ba24fbf6771d3dab1bdec97580a4ba326ec95905e8af5830be4240680ec505f21596ca28a9ff0f5987f5844e6a712f0eabf7d573c8a943a11060f9f1796bfd7101c71298f2b64caceebfc5abba90136ee6a63f199e86e5955824433ee981a828ed5005e12f71b592c4aea8463f7d7802a4fcc87c9af72d4bf427c1ddfba4485b56b024bce1b51f237285aeed3c7947ec94b94ee913fd90bc4c15421f850223869c17674ae643e8891b89cc039db64c694db1b43238591a231f56769bb810a4989d1eb50778019d686b20ef799e19112d3599125d25aee5379f598b27f329e39d97ac5406d9bef2c5aedc1cdbe21d90499c2d8db109403e2f93c8fc212cf4e5daabb336d8e068de1cf594970ff0b0fcb934b37720a3332da168f5d4fce1796c043ec3fcad5a21dbfad999ebde6a1e5120bd6d632bf365504d81a9ae532f8076e0aa60c180bc92c519c2b0b89b3bd2770f1adda80c85811adbf2bf0a0c43b881ae44791ee18f75d165f78ca9ad6eb45671adfdba8564f52833422860fd6225523d7ecf97c9e8feead3f3919a317e940cd7aa7b997f81b8dc31cd3b5c824f610443e82c855a80d22bb667d68efdf42240959120c318212be2004ed6140ffebcf8a13b826d03408501c26fcecbb38f42794afcc6377828908e30cf7a571e7ff95e9a5b30f5c4ab072a311f41f0c046d6251b8c70b3466ad5df273e18841f0a24f8dc72db48041906823fba79cedc8f2771242b58ab34a0ee89081d9a914bfd787116c4bd25e7db7b8d313ccc80afb963584cf8ab7afdcc6d9a45488c1eaad861cabb75b3f3db9cb0dc2f1c9d9df88e62711869a1ca42670b742435373a3c2a6ddf09211753648f9a66ea6981c5cfb3fc78d998afd2672e3444bbd0cd11272b2e2ac362e09f27c65969c15569f6d18618f5beefbf7e28b88ccd754363841b0800b7b838588eff11e4ed2290aadc0cd38ae5cbc1889388b25e0ad34d08766cf8161185531656e059f04545b2dd307568f7df297a6d947af50ef01105d1a14cb758fd43dec19248fc8547097cc829be0deb356824096557796304e1e0ed925cb36742c5f758d971c7ec5fe42223c3bb08e40b739d2273dd96d76ec398206661dcffa5363cd11d9b776c825aaafe783fc78c26b21cf27e45c2715eaed1c644be23d254cb21a9713eed2a813397e99f2622519bcbc40819f15d0aceadf7317d05a1c02ab3109e3160b84399a2f1e253f78ce909116442968f73cccf1e2a8fba163c246d600c757f18aa2522815a67be29231d8a3041f1dd296c11773ad5dc62bd29b0cf906d6d25ab1b24752646fa7ded08598e0fe7f1754de0a51366f65af336ef6a821dad4906f49baff4bf4ea35cdea9b020b657f63e40d2eeb6aeff70e01c50b94faa87c359eee410aeaef1e43997b477da13442a677b667d420dd576bf9d4a377cfcc95be3d5a001fa2e033ceaea825acbaa04fba3b5bfb3d9aa0c60b875d0e60d9faa23e1f049eaea79bb34cbb12306093cfa486144673546d2de8b3276cde2b1eb3011f55e49e50bd637622621563c7bb88c9c8610f375cade121edf8e66bf7b07462a2eceb5e8ab4a3b2d4503e1b070c137faf96af81891ce9b1ef7bf31b0cbb03428057347a676f7382a0e5f974968ea90cc01e6a5ecd3624b3c702b7a6b2f0930d1f77610f28636e1bdd094037b589f4bc29b1eff1669e79a32c3009d2c73b99de6b788f5eedc2e85cc5b215764444ad6395914d1b8efbe7766df5908d02b7b2ffaad10fb00f57903a1954b97a17e73a4ceaee8a55f26b9e979175aa6cfd89c66381ae5ce6b2143c357ab2ab9c11ec2f3317ba84ed7937e27bfcae034a549eaea03fc84ccea19141702e14d05e2e081b59ab2f2dca5d90493168c5cba891c4770662308cf43bc037f371ea06f7f2c6df7e6ce3d93783c6e29586516163fb952cd5f44494f84fdb02081f3e2fb217af0909e9f4e5214800590d18579addb74b09910d072e9bc6572ebf1b8936b1535745f52f8e4eb998f56b90692ece734978c17775690486bba1f00b62f20020fef4b93ae60a04db94fbc04e33d1d3a43e7a6e094398c2e0adfbeb77089d8cbe1651b4c10c2680bf10254e0c0c46b0f1c57d53286318a7988a606f2f5ae375793cb650d6c0cb16d0f242a28da22c585bb8bd6ecf25f466039691a947b8b670276a0174ce9e90fc80b6b77072027770e4f263248f71a1538190d4f9086bc3f98c5737cc5eb0880546817be1df4e8a01615f3a4317718b94a92ad780b957155f54aae506042ede61dd28f4b152b3751a4976a2d7a085293dda63bfa7a907373283763a451c65b2b6e78c8fd1a8894a297afcc23d54cb786cf449e024ea17bf173f7e6b211feb9573868cac138d6bc682cca677f1dc46b019ea9adbf832b71af1b084666f69c8def79c5e30f3f06ea3aba7f69add61d4fc75a3fb76c9e5573d66bacb541b6ab755e35852b03a667497766e99e71ce297c7f8a5250f45ca077fa1288d014ec5846ed39994a17fac92ed8e0cfd9d272676283f7d40bad09145693f54df9b0de75c989d578b2d9b1cf4f4880b244d0ff1bae58fa1f8de0340d61f3125ec700e9cf618e5ff5727139417a5818436e5c0ddf2e49e428c2155f47a7f91f9ba994d8e1a2c3ae9d0226de309e5448da1bef29a4c65682d21ddb32ad00ded9027780b341e32452b0e0cd9e65137ec4375a4a5d25dfb8209cb211f4e2f1d0555954fef47682b8c2f449ab19606e9268904afd1df0eb6c4bb10cac8a12c3f58a469c0ca4783e4baee827d448d9174f8d7094b69b3518c4adf6bf27acc7aaaf3dace727b5631fa4df9dc0031dd4ce40ba58c3d77b6eb0005747d5b4f21ab8b623c74683d8b8a9aae6e55dd8df655936a787b190c4753fffc4eeba4a0fd5045a90d74314d11dba79771d6fa0c1c5434eca1edfe216be0b35f84dadf5ce232aebd61ca53aa6de5104236300c7b51cea5b677ca112248321c7e4e48825b1c41c5a61e8200ef0d6d7c0d868ed14aab542f9af8f84c423fe4aaa181e8f740495d8e565b3f42876c31e66a4fb25fb338fcfd1a17074f9b693e37bb3609cd0e5ae6c6f69b7a60c817af32ab3504e61f9797be45763f865621499aa0d0659b344fe67ae7e0a91826850216e0492e22aaed253c7764a5bd86561f7dd331a31dd5359a51ccf8a86dc1fa681b3a32601af32d72ff18ffb1bd236327355cc18af89866899b353d87872d17d1f8ec6f3e7221a4a384147aa20c12ea05382c59ec68a3eaa6532740574ec856d134fb74da4abc7c76613a0e56ad4b0f076159177658ca8d631541abb520e07568d386b34694d867416fb8bd2da23e5cd895881f2ac9df8a8174db0e18dc6ac40ce2a338d699d1a3defd5300a6be4b7a77362a26f3289112edd308e86b0d72b26616381082bcc21052bb6a4b7aa014863828c62f6cf74899aa35ee84e66474910649835d9d97231d4fea506160f456072cf281f13b634c51a7041127db1f9360fa77cc4a26124b1e4192faa290c9510b197b8ea509b48fff7ae03c4ffd4be2daa10b6e50ea584193e842a29d3167cc6e1ab7ec9d5b6d89cba6d12b212bea58a755684d380a74934d5d5fe702ce9f459253d1295fc3595b0805a6d9593104e68f15dcbf4999a8ec816cadffd9e401a1106aac0373a663cd26e99bb9a8398747e6a91354b480f14d90610f54b4d7bf18489891ea68fea968205ba68fbb3dae65ea3b3f84596b4a8bf17bc76c1fcbf1624ec7d3f3794a9308dbac67ccd0e1b1c11875a37ef28c79d0d4307db4f455d4a84ba0b0d7f616646737f9b4e775db786a0eac91868825ba58715aa7350ba35643bad340f0aa366dae4a916144f113bd52d097765a559307996baacabc8daa2be50a099b7462f8591dce351d56f0b24cf966a6e398d360d6cdf5fbfe873e43c289c2e320a860e5011ad78062b6f01095e7d956928992b2d3122f961d2cd613d1e4e9f71633788063ccea3b8a1b28bf349cd39c6dd30a7dd33552eb25df35ea4d0ec2b11a2416628e66b222b1e6633d58c703a4b696595d477a6938452fb5d00a2c6d04a4b8651e95b30de87a9e64f65484ced306a2bb20d4752857090b5155116657b19474f9704b6ac6c516730a7686f1c1df6ab85bc1a9ffe411f69e71164d683e4e00b65a1a0bac6e32c585f13034fdf7faa1754b4dcc321fba09ea2320682a61bde2fc37079f01297005ee1908784f18b82008209f686db3518a7696e621cf1bc4f9afbc6361786f9108bbce5f8cdca907ce030fa8267136d1e2fae6cb6501afe88932020f90e94681f3c0925605d16632812276607f1605b4879857be3b27c49dd008a04f980fb3a83c8b418c60ee90acd093566f023c2a14c9bfa083b0d0e6a645bda6e80d931f37bd0473cfaf973873feb63f74c0c6a86be95ca6cdcd80646b81838e2f971c89fa9cf6faef527d870cd59c961dc428fcf1f31ef1cdc07b7a6c985e6694fd6b23aed9692184056f70a14b11b47fef56d5f4d49cf6083f58491e336273a249a6c146e1e3bef6950d5c34cbd37fc8b9017370cdc4b98d24cc5140d1e68d88f6a7efb206f80a1c3832525c1ca576acf57c08d4c299660fb105fa705a00f5a31ce63f1511bf20bf5ee21c1b4d7c4e8727df971828320bbfaccf2fabb22d512f1d39423a659127a43f50805056d1fadc38c21f528afff9ab2aa68ef0a094eeb3ad23fa1164852a1bda7b5f0d3c8faf4e809d29293f37a38480768126da7572b696bdf7d76416c97f08737494a6e99a144e719ed83136d600341117ff7d35fefc06cd5de05ee55e5fe2351d3fd0d9220bb597a798fcb1cd4c0128ef21bea9e32c39845189e4675710fc21a5568672172de88cbf505956232cf80f608f48dbbe02519bae93e42bde9ed59aca9087f2d59f87171f4ebc808b8c3574b8e7bad7c330759e0e4dcfe7084252e3d97a377bb970829f6534aa01c59f52c9332ba93e78f5c19d3b7078ba2bdca2dcb01713bb2a342ea11983b264f0d92f87d4c48bb006a69a411718afbd08e8bfb8318492249ea5fadfb0375ffc29913f2432e80b89f8fb47356ae8b35bbf03ec47df9bb9a3b4f80670c9cb91744d8544eff82b342d0434f5aa64bcedf4ecdf900d66bd4e73fb8b6314eb190f5a09d3e32db44557d5992e62b399a945a66c6f7a93d654cf3d4a04f42aeea20dd44070f4c47c7f138a738fc1b71c14f0b14820fc84cad5a17dccd84db2fd224005d908125f79e698a60afc32c1c1341027cd848cca2d43c0c8a7b3033350bbf8792a347ed738b33ca64463b90eb7b8de325d6b271d3e4ffc8ace2049b489b03bc78e0f513091e967218415a10ca68e84e6b17bff03eb0943d2d750539e0b2bdf088c6fc340f5473726bd0a185da73d6ff11e7c088ede44ff26ec2bf1d4977c9024166f925e293e8854d551759876faac6df1ec8b471dcc1f88049ac6e906851af5ae14d47dbfaaef60edd806eb06f7ed6058db0ca59fdf6403c5d60af4a67e9bb8eea4a8643d2f1270f08220ece26aacfc93ef8527b42552e542485010bb3aa10f37f618f1f58640df6f2548f035ea54287a93f1831675f9176bc5d56015fa5cc9d758fe918e718ca0b4b6694294fa5a20e80eca260dfd72cac8720e25f7adbfcf51c8a90ecece1715047f61b17dd89ab1824f47972958f9f3fcec77c6df41806321d888d54bdcb753b66b99ae7eacf74017dc9d3b0cec6bc59c8ed7b325ef751615f137f3e8b6a4273c1648b53682718b4a3b0c5f42cdbe17141d9fdebe947da2054892aebc25d46e6c2e409a9477cda11ba0e284c4d73becf1ae9136e33f1fc5a2aa8dc814b72d302023e3752850879052aa782fa767f68d5740464ddc8dcf50f4c173344f608fc6c243faf5d2a116402435818887f0c32ec624de80f1b7abc93ab371b48ed1d15cea5a41590591877228e670c527b8fa6b4618fb015faefe2e73ba35aec2b83678a6071efa1b89aa8a00efbf1355a4e89c05159e4a7fa4f00cf7c46b3ffce8c87aa69a08e44eda96419c6987f74808138003d022b2f9073fb546bed5e72dca45d0f8108d66fec6bb403ffb6658afa7f78accb356e524ca0cbda798757393c5545fa9acb1f29f2d93931373d8da51af662ecefd87efb9bd2a3ab4910ccd2844ce70669ced856fe1bcbacaab9b5644be265eb305aa3f765cf436a8ed8a60800ae006b75ef52e120f070cef03195498f8263f3078e1693ea8fe887cacad2ab8722a4a8035ad69673cce295945df5cdbb675f8cb49efd4245b37498ea7418481ef99450c166c5f08156ec2378650dcfbe3b1490dbe86510858b97cd137da07dea5c2a185c800646f2865ef9edaa10bb91d9dc2a45cc6142326668372396422e9c7afb3dad802337430f95cbcc280f2d194042f043ee4fbc2f6c0514d41993095cb39c6c8c1dab3953b3fdc19b83977b962ab2b04b73fbe512480daef363d0d689d04ff7169f7f4459d3c55a810a93b89052167a52414eb917978a48026c558f4ea03d5bed5e7b8783660a82da17ef1202551856d49933140bb460f2165eecb45017c26a341f67b12174d2402030b38ef68cf981944435f2f4981c0ceab14416ffd31ebd71d769085d0147494093c8613263e9025cf32db750d380de6f579db7f00de9d106c0af027369eee47523e4ba6c3d26161c49082372e33a6d93a914778c5b21521db44893d884d827904fd85d3b6a895e65d8a1ac907771f4c177914272dff31110625dcb750de7d2396093f67acb1c109c8471c59969b3a0627428b539b359769157ce7bf03a74bb0822e9847499e469b3ac87e54bb35657909353a6d87e55f617b3fb61ca5464698bec7e89e0ceabba10f500d4c61c8f2bd172723291eee55e819434799f50146337007fc500a7e8060a898a06280dbce88fcb3164e9c3f540f0420b6cb99fbf057a9f65874f18850ec72fcdb35c79c24612cfda747c1d6adde279d0afaa594ae805a48e6571806afdbe40af5a34a02f90bb14708724dec8d11bd2c080826877423a80b571c2fa67c2a218a5d372a501c33510a7705c9707cb0387dfaef47e469cf56ed9d0f8dda73ced2e1f6afd363183c821ece3242c8f7e8b8a73a1e11448078aba819cb502a1c4ee5a53ca061b77d637703ac0d673b2c0388107401361aef293f26f0ec4e36ca7468e2712799d78fbbd2cee1d45928d8d7ce5dfccf326d6b97522bf5d31f783b4b56ee21d67eb3116da5aa3f97cfcdcc24e88878d2338ad2b6b7fb279e4263fff13f3ea50c163c5ea1e33f8491528106e033c54c26c21448b1df5d549e4ea028f17fda498a82c22b45d63422840176a4dce8a1e01b8f3c0c13dbb454feaa82fbe44a0b78b73ed323250a23ec4c8e5fb76c05c01a755d36c257f4dc13f87de40192307644dc272aed55e13997e3b4aa640d3ffbcbd52df4dde0bfd7d43734d469cf8bbb94c68352d42fecd21ba89d6598307eb0d2dbad636f5416c738f6bd50c5489eab6b09d26cce012744de8bea406ce2146de402854c6e10188426c7e88314d61e580d4f57f20aa48f9c4d473c2c013d1591bac931c4a6fb317438cc13e9683886616366f6d2f3f00402e523c1f0d40f41675872e7b9269214decd1e2ea3cec5b7ca501a6165d376b07b8199d571a29000cafcbdd444881cc9a87176a519e10f76a86650e58c8dba0f76973a7081130a96bd245b71b7d12c40b593dd9bb058ae96fe4acdff4b3cb1aa49e2ebc30bd07e37eaa6d186f4d499337202084c479366240e9eaf032d2b62f3422d750bbbb289353e143aab0b52e65e9cdfbf5890c83b6df882e8a39dd81ac3b4dbccac0a79a36bdb086eedb7ed6ffac9d985ae03025a5b6550a5ea483e4a5d66f276e277f58889e4db8b5ed0d73c0a94d0819b752206424780f015328b78f7bde2c0d5dc004c8cd140e9f2670ededdacbd2eeb39e7eb113502532849918fc6510df926c9b2262d1388b292a32d9112c443b66181a196216533260d79d590dc9f8fc77465b0413f305dcc4ee4c9ffa3a62df9f770a0d96b321072ed167bc697004fb16ff2cb0359bc706b83e50699958b33d163ce03609a6ee9e37a7274f9f6e18fd383e76a9e3575482ea4c02883a0cd0d8b41a616ecc9e839c76fd68b094373669d69429f71531c9f02740d22ac62ef5f8172ce9c5bf82428e36d4fccffa25d5640d3d094409caf191d228c0cfed0e8065cd313502065b4aa90aadc2f005b0abeebe7f75e6eff098b097fa8a77761bdb683697bcd8e24f5cefa515564026ffe31318143a07ddf34c6d67bc8e9eb3ad7ff73b0ae7d19f028c730199c1ebcb5756f05e6933d3c8bc5c48f39cb221f9d06e7076f44d919e0d8b96aaf89a36d84abf6b1e5fb1f19c17c29998c6d5086be7d108efb126e9d2400e6f4ea618ec4764f6d04b8007c79165b8f74022f82dc2a7daf1922b1053f8dc86239dbcb65d8cb2c359b7e368eeffe78224e1e6c9ae2915bffca23ec7af48f7275301a8dd10d1aa1b049d4edf13a0288cc73f621bad46e2bb9fd2e2ff9f7255fa996b34cf49738bbe71f78408ef3c6b3152f0c1d0d64220f8fb2f88ffc7d483e0a0b08765b353edd56c563ab4ca1fc438bb6f7df80925d54a4b270f4f4f0de2ebdae34731127be077f78b736ebdc3018733b893f3ed1f1c2709567a211c67ca1c7b8edb1b11351b7cfdcd8fd7714b40bedd6965ef1c11cf8adacee7c484379e95480ba7a102a98b275b219298c06cf4198d6204ac4686a49d41ddfea7f06333ce0b5eb05df5a3c3b8fc3a560b7611622ecd25b196914eb79e5ebaaf63b1b6c000f3be5eb9829c1afd348bc6868529c26333efa32abb36e56d4ffc9be247001ef0e6176d2d2cdd4dc77ec8017568ae859537ab4c4e99463171ea7f7f7b1da6583ae1e41408764cf6877f71e6305a754a110aa0d7deebda987feb281fd662658f6d37a9ad9f8a288c7385b765fb35c6ac1c4d45ecd660cc8be012dd03257835de56e99eb3211621d6fef2ae7b2d96062fcfd29840653547018b40a045ae66b658cdbf4cd295689d91cbee7cea73b47b680c7bcc2ca94cc2618ac04a4dc47005062fa91490839897bed0123810a8a1978c97f7c4cec5597b534b89cb1f4a5145feb8df0ca40658c65560df7ca577837ff09081984edcdfb6263ec0b081642d3b371419996d78aec31fa9daff1036c23837e03ec29b260ca6510174fc99d59a3b0f8ff807952ca7e3504bb40f7dceb3924bf123d32f1292b8725684153cea7c98a46d5cfd65d7e624fcf5f9c4b4e42d3fc995a9745b150f802bfc447a708be7467b1b1d29976b1dd9ee648debc85c7c8160111e8823db7a644a0ad2f2461ddc8e6b240d563b3f4002bd5b61437392e697a94216a7fd7bbdfb3989cc4cce79fba904f841e978752cd003f12ce861469810357ebf4a352f9159d160ff51de2d366afca9e6eac1404b45d02eb97b51e06bd84e664d57a16f1117ea668f78f7bd4941660a3385cecb7fff1ab1cfafe6ed2d0b99693550dd1c83e65f238fbcf1664e48884f8a1cf42268269503e810569fc5fcbc83e175f5c2afb2c4267557836d2da0cbc559aeb254d313c0d52ebf4112969a534edb9af9c9638ffaeef4089f85af7d6b4e526d9e644b6bd9c1acce42ab9be00c2c60dde5132536bdc47d49883dea8a092f0ca505b5d80692754a8bce4f3a7f5653e3bc009976ed9b4cf4fe0223bc76de0165d54a12633cf456766fdd46884173a4874f18a7b2791afec8154394de216342c40bdb5da74dd714ae252c39de983bca521df22503680aaf1958253ec4eb11bd3d7102860d9044e5cc9082cab6164b0308349a5e6c73a166e03eedfa46326ad45b91e6f2895a28b79965b5115124b90dd01f97c644e85aa4dab87e52dfdaf3b7a88704f4ab5b2f6de300319fddc4797e4b9d00cf998f7f42ab134d993252d85516a5ba891e6deaa46e603e6cd58564b26e53377f8adbd2ee55d83799412b5d2973f03314fea91367ccc3f0114c5d3c5931fab9bb4320cea190e15d069e083438046bed5313718c056f28fde46b7cf87c1ea553ac8821860112c8e723bb65562532b109f8559f111a1a88d34f418c6417a2fa30c5d857c84c251c8912a014579228752bc0a76900bf76112ad67d7a1a34f08ea70622eab1d2ad3793442ee086ebe629211c2fff77d8e68247451737cf515bd871620ef9b8f4efec62b99202bb32f87460cb39122d7de11e12ff4513ea7ef25c1417a6dfac7c1c552453c879c0d5973fe273d0d818d9e6b76e638fedbfc5d4969ddae655334388a60796024d3f2fe646efc1716a3df111ba00e981920a421587fcbfe2a34db52f56e42a6e659b26f7fa247c4d6f9ce395c11f7424c06a066cd3e866f60afc449ea589ccb242f051cc402e4f900601263080044a79bc98697a90b7542784041a42189518f61d00ce3cae512828eed9d068d58cc27e22134957ae810a912a727f3d7bd1416226657d2149500418ece861675267b0e363d5a38d89276e5eee9a2606e078929a99d9feaa09fae3bf4c53ce6be9b1652304ab32622dce35c4b1ce860c6ae748de22e6fea8a4ba0ec4495e8ef7b45e895eaf1eea6c5f1be935f38f7732a838dc9c6a634703680f04351bc42d9b1b7b7c66cbc06bcc5789d8fba9975e4fd2faf1022913ecbff848df552f973441d83a49a531dbcc5c82354763e46739f8fa02e090e0cdef18cabb62a6e5eed2f2afbefb49e1871c36561217627bc9de9fb4768a1afbd6baeab8bd72dbc27c1936ccc9b8aff9e50c826b48f565c4285cfc09633150ff40c7f14af588967527b2ffa9208004b58cda87f011d48a87bbace78e3828990a9afbd5ecc06783f2b83ecfa92e23e9c949159ebc625152e7a229be9d18315bf7beaf26ed2d7988ad123b1d7b44da74f50170234e165522ffde4edc65afbcd3dd65ea0c32a1f93edf0aad016feb250b3fe220afb84cfbc8450b006b4b1a642fdfebf05825fa2ac8e36dedb5d586a868fc2a8d6cf5956acafcb3d355d50979ffc6d22a8c19cde6ebc8f557fc0631dd641b230a7e5df4e37764bec1027d3c08eab008261b2f12c108fbe49e5f2eaefae9c465e9190efcb04363c07c69cf48a7d6618cf8732a1edd71406e624ab8417f90510413d3e4cb855460e54ae724a9caba186588fae06a0d8e500dd816665d43f79f538c35d8664e003082b96bb9aa1d1712bb89ab0bb9f87a6ae05f71013b455bb4e982d0026fffd026dbd4f9f704020065cf61d2928f4eca97a7263b675eb62a73f1a3ae04790d3f5b5cc32f5f4a74f72aeeeacf50a3522356ea0c2fcc7c7325e8235a1da27a6df89352512490924b9e97fc1a12e8f7a29a7c4c78c60f85e8c07fb235be0d0ef1455acfbabed04d36f65b55329d3d58c2029b49577a0a624d0eec4c661a982281dabc23de5cbc4886bb4bca50b1e88161c5fbca17b7bc31eb437a48932a10ee26f198016f7d5624ef95d6e6934eecd7f4c2baba9c401ad8cc0e1cd262f63950120d1613911429cd0a0f0c8ff9d8f1031856f55cda50305f295c5168a985090cff5b2abcfdc8ef0f2414bf725611a707a9f48503812117ca85c921cc7811c75f626f3f170591106a58f52e7e5bf153ccbf94cee667825fd80bb7a9f6e3cd615f083290c96430794a77d46dc45b13e3103c8ff23b7b9acb52654eb9a0a63dc0ed05c92606100fff786a4082a2b13d756e967b679f3d6d3a59a4a913233024a8bd263da0964974cc7c2530ba6a29910e138348760a059c2cc3c60e7034f92e5f50abdf2b49ecace8c57addff4d7165acecb1d4725441c6ab51d9a4748ded53449176b5e1e98bc220e5291a8e2456cbec21d9e86005dcfe34ca9d7af8fb94947c647b40fe80b22cf610fdef70c3c3b2bce744a9007d40a290100e088688cd1c361d1dc045668f899bcec320ef9b1cf7c781c4d90ac50287d056b710960319c1ce6825718e1d4fc3506909a521d871d9790490466d88137de9b5096517fa5fc796203e745b4979a689ce0db75786a048758dadbfac98de8ae69ae17cfeffd7061adb3c154202994f21652169796787e78998124c3351fc16029fbc298666fc04cedee3e53fb74ab02c27fce3ee3d182faf64c4aa9417f5eac2eec42264f14aa39a59af5e4fb112424abbbb91a2473fade50f00aa4f5fbd30b846aca524f50928f20cf142bbcaef7bc8db81ebc8967153367b9e7c515684dfe10cab44b265f0b7f4af9d49cdc83a84ad5fa666ccf1591fd73f396a88822546e7b3733e59f84e41399ba8145629984807b4d3793c7d07a9eafb649a630792cd08a0b32da329b4619739c073aabb81d2289046284cc46f18b2cb465338e80c261f3cf639a13d50e70799964ec7ab2e4f9f0f1e958bde7dcb35d44cb3710dac8ada289610203f60ea7f05d1aa63062d3e2a3e12e52565f2df4ed23b1801740bc803e33fd108d942910146513ab29892ad35fd8b590fd1645661d676f7c52d0cd938bfcc8ff123cdee16afd241322174598e3bd65c74a864d4387df9532113911a44e5be164fdf129649e8aa498a2751805d6c754ca403073bd59c5c242549b00ddc83b7422300418c910ab10222f255f70d13ccc5b3896b992293624f5ee1fea090739b4ed8bd9b39ed7d8dcce0480005802b441fa01f439d0ba78c7ceadf1437af4d7ecf95900b147596c90022eb8a111fb53cfda1e5d920bfc03311e6831aaa2f95fc0e7fa5039df211c65d07486153c3de01717dd334f495090ec184fe31069e94ffd3756f1cdf65b4ec2a096d71756c68a26b9a113cb987666a90f61f42212fd57b9a8d581f50b66f9337e189687564400e94749286b39db3ade66ed3565f83692227799c58a661922cce9fb098887488980ec98b586204d394dc4d12b5e204d6fa76c790d41697d95813ac665aa92ebbd1a210f7512546ef502f1b0c1a8655641ee7b6eb5bf9dcad640438a672514542b3b2fe65e41a3d82332b14854aefe2980dfd3d34f4290cf4e64fcd4f076d65133eb138ab140a57714b1ced667259866ecf4ef4fbd68380d8dca54364af30b1336db5f6e5dedbf175c7ae3c47f46e0eebf7f6ec4cb7e6f7ef2519f7e0618a23542c1435a2b5fc20859681b6bdf84ae5f0f25e108512792d0ace4b4b04fe2b636897ef70a349b9aacc92533d1a0a490ad6c4db742a0aad0e15e863bf9450d5392d773c7ca238f0162c65de0e71f4b1172b9f278ac71e0383d56f47eaa0ff50a179b270568ff0bf4a3936db6dff5dc94ecad844ac544f9674e81f332b42b29440ade62b0da9fd13743d1c574a383f50e2433a14dcf87679776e975a5a3100061b12a7c6cdc1c57475a342bf0770a21c1de6f1ecab477f12205224533cb6721531147876360d937d97bb77d2bd95042ea0f0a65e1211efd8db0086b270aec37dec3a7ef06dae2a03bfb50e5dd9817853a1fa56ebaaf24c49ebd58351ba6034b9eb6a05a63d97682956be353acc47d299fbc9eeafc960d3344142710f25dd264e3b04bb027a5889adaf81bdf8058152da867104bee614e47fc41dff4c400c6b72ffc0120fca545899f212d8e07a40558f556c4ce1fa07a4d3e8fa738f3a271d79f0b71facc9f5ebbfbdd246b28c690274cc1a7c7f262d662539e8ab570a0a6a6d0441cc59c00ff4a303bcb00c63cb38bff0677cc212756c23412c5d7d50db7cb51a57fe66cb5554c333a7578af55ce8963a68e9bae21dfef0728f8329ee381fed392deac54018bffd275448ac568da745d9926d5d0f978985c835002ef7dac02a2645e93adf4990051f0a2e979f138547344343d86ad9f1835b093ffca000df31e139e6e03fc14e6396a3bb0c117cd832ebae00f1093a32533f3dcd5e6e4c9386d39039625c9bc7d6b14fc06053c6ff3aa9e725063a59d00ef2348a4b3906337e0ab10c37e148ca40500cf919de71921693acfae86eed61671b44ea658e1e54146a15d353fae868a464c492779ff40b7e555c7a168847dcfb55e5f0f35a5cadd297e3d6d73ff925b6e7d44ee98e2e975033189d624514006a1f8c29cd9467b64a56a8c3805e4f89f16cfaa3d67c00e03660c6436e7453dd1c636814050f7a7036527f0673f5f31a81e4b9755bc75db327c333d76e54796983d3b824192afc9a845801b63d185fece421a89fcdbab127f5bbc70e61acc2a30e6b746e3588df1b34cc408e84d9a6a2c11b0f03318463b51e19eb605a8dd5dff15d4ba13c110f62055b3afd127ec65f86732a7d879eb24719a80bdceecaa44980f84f8111bee06f6cdab269a28ecce8de75fd7ffcc70e7abbdf3d7f005567dca9211a482f9ef7d8dad22b6119975292e14b3a0655ee5cb50507e626300d2e3a2b2b21ae1ef1ffb90396c0101ea6f252e630459ac05ec146b24273f3f35fa6ab38ef167beb28e7074e30b01050019315647742681a1055037fb5133f3cb48db1c29b6524bb799bd0bf34685a8969e893c8515abafe22b5e841a2732d5d6311f8729fd387e11b66f1f40eeb482e24f8387e8b2287b37ceb3e6e2f00e9157379535f6889301b4cc93609130a18c210bf62ef0896ecffabe292c39bbbbf0b787ccb7c802c41a9bdbaeaef3327e02e55cb19185b4a0f0f2861915a29cac5ea4dfdc727c8f51f5f2ce18e736a5552b870e04f9fe5e4e4d00bc4e8e5817ae080618ca1fd0d12cd1b9fcc37e5b596452fe1e99a602f94157b17252f6c181d8c299247704b4c9588f5ceb6e18703809b8950ddcd2ba8ef8ed246f87378c8ce5567891138e822fcc53b488ffd62a573e0cb99c3decb1d0d12345103abd37ff127adddc8e37e0ff092ecfdad962a872b7fd3790721d71858542b501d29416448d485fa797544b387cc5c6cc4076b863735fb0550b9d6837efd799892557eaa57be6e895b5ca8eafb73df910363c1c6fd92551e5dc4cd1981162ebf7cc69523622861e2598930970b9edc362ecaac40a58187a7008d9ab82ff71c2a591c7938ada4b669d6ce955977915cdfa05fb8f11b8bac2e342374f55cc7a53316fcef7ee445f18cc1acc0026d9411fa008853297bff846e26302829f384799c1f56a6bcf64832dfe776873c7e9f0247d7bd15e7289d978e0cccb2d82d686b0eb6bc7e8ba6d94e345c98dfe01ced27ee78184d0705c50dafb7a5555b65b2ffb03b53e9e1ea6eaa04268a47d656a68ccc45f4e5cb670225a8b6878ef59af36f37040dd8e122a70821a0961240cd2d9d30548e0687d9895e2375b0285c204726db356b24d9aa9d3ab9324df462dfcfaed1d3177e5a971b1bfeafcc6dd865978cb9e4baade07041eefc34d1629ef75cfbca517236406c41d47242bbe41890a94d1c10112bf0fd1a87789d3ba56952f3ce8c9487e961a768bda8335cf77f72d37124ad8cdf2fe003e7de8a2dab429d7929ce6c0403a1b2e67f56c91be97dee1644687aaec6d7e75a427a636d2c0e024ecf4ca6a67457df4e2f5bec7a8fb6f80b769c9c6259cc2d4b8884dc0d3d4c0a00ea71a0cf7a074156a3ad883a46b940a0dbc404e4fcf63adb96440b439b469af78f8efa039cad9fb82e15ac6a444e093137772491acacfe74a2c4331ceb45877d1f578ef5162e49637cae28c732847ea6ef339bd9c6ef2ab00b57c51b784c47bf49542c83e40595347e42d7e9877db6f726b2517f1b9ab1f42a818245ae49782bf54acf0a63b7c95060a8cfb47f780880b79595fa57c2c5aed988568f46e9f7d817ab1c5dd445f18a2166451bce7768d63cfe7e23d563d665832084f1e192a9ed2d0cbab52629829abec0c464f74c8700e1a264162f79d4402be05d2f89bbfd5a1d0dc353cda7a93a10d3fc809770ddd0428848173d553c043a17360cedafc4e4576f75b56b118f65239fdabc378e02807b80509d9923e5b32efc52d0d716e87a4d23d39861ecb777a42fb85123c4bc91e97dedd3cac766c073cc1fb1b29da1c1454c52137c266cfae4eee8540e39ee9886f71fa06784c4684f2d5b5c61af3f84d91e9d7b90ce7d2ae1c6ac93df1cd3e8b869032066322bc82234211f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
