<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c52552870cd7fb792cd50d46e2783eee5f63fad78fc70aaadd5dd65393a925ff6ca78fb429b8f2683d500d75e7a6462332985724343e67f2ce2425d528fed023066eba723c778ba47515bb830060ae13902abc2e6f87160617a43094c5fb6a85ffaecf2824857be4d4ef15da604d59d639a5806ba81c45c0c5ffe0b078cd3f9a0a8f14ab7d96c11d4e669942e5e1bcc15ec25d320d8cfde43f2a640812f6a2e2572b980268b5fcb8999043e98638a23e7e06a27364065a825770b84c4648689c04e7955e93df749a87b1dc2ff58bb833451eb50e9a28ff99148ff25a039b42753eace8ae8eb2e10e169985c4c21c8352d7e4b6a049f4c1f7df4f187712c05c64e5f5170133f199b8e8831fe9a699bf29805bb5a6e913894a1570d6299329016c5add71a7d59708fa87d221e4282a5a738faf523d4b5d1e7c51eb495a634898eadb016c337dbcb50b85d5bd673a1efc4c6ad637c9613498533077acf5aad20a0a0a4e28d6a7612c3c36822647797f906418334a21bd70756dcb0c330469ce4da7c5b4619022cb4b38df978a1f160ef0aa05c84382118096d0e3108ae810d2d135aefd00405f84ca455b2f98442277bd3c16d4f9f9cb831ade6534a9d83912236fab763c4b78c04e97a8a0fde55dd06b2341552ce5815d04a977a8b43d51be36d0298e195d74551da8ec0d60650ae18b4c154a6463a3f7b19779763b167e0900ce27e30fcb616df266e8104a1524f8cd582cd95003b81c5a4371e1e50e8c4b24cc8b15ba6b68ec934083a0170abb647f56aa115facdbb759474024acaac4a3ab8107b82e75d72bbbf273c4922d881e8c996f81ea940dbfe2ea408692bee786d6a81298e2a19b0ee36e7b854ecbe7e0117eeff388df86dcb36b9faf293dfd227e83cfb94c02d4c783d7d4111b59a0668a94d0208bee19b485ecd53a2e658205a153ccfc34d73fe176142732ad078038a4651719dd18d385d6229a04c751bee57a1722694314ee28537232fe23773a97306bad0bff791be98ce2ca5b591993deb5b1433806ce127af301ef80fbe156ef2ffd28eabc290cb79e7078249ae4ab68c9b1118f5c669aeecbea9fea07606aeb75c608214e7b79324700ba991873b138cd611298d93959727141d182e193fab67b17471d49ee4b3f90c19bde512b8ae5ef5b665b04f46450d6d9d57632e9fac609ce1e86703a55f066ce4a042be65efd71ca9580dcd322069713a6a50bcdac6e4f9dbe2c8b26f1f57570af51a967d84e60c25e85fd9fdc0107d1d9ab2e511bf335991dc644219b6108a77051c2794589bb24c31edcb996ad698e01869ac3a65be3da380cce4046e632a95e0c039800a0acaa63bc16485d1b68e8bf3b2734abf036b17007890b642df2b70de267d9ec2b838d9776cd352445b80c178e072b139a58ee20cecde8e9e9cd1ccbb6286252ee79955b4fc5cda9e3b67be98d63701b8315869795396be83453adde7799b43d3017fa809d1ef78d28328e17e6ac42c2c5810095a69760b303f516ac2f8c714f981b4ddeae13c2ea35266d69a519230cfee4620c15cbc9125f9b7a64b68fd26ab9605d0ea07325e5933c60793babc1916b4d1c6186ed0a591753fb52e459bf38ad7dc39fabf6a7865bc2d5f91ea928f4989139ad071aeb238f2140907f6795776640f87a4733e9131ca9bfce12d539685c3048707d4bdd811719697e679ec9e27bf9b9d7ae19cc2bbd5ba720710b948f611f38ba8a1aefb6c6c4fea3f6d925ca52d5f95816a2f90e5f54196a946172fe5cd51a446fffa231342b9362bc1e9e211495921e54ee9c6b08f417f4b1f6311f0d297f2d5be17a4f1d05e618bd6c8ea4b72492c7703db089b81acfd6361ea5c9f6785ee7db0c89a5d4ceb074886e6867ab6ab56f836a1273b87158069ef8c02ed8838cd83f4563cabf81b7871fc2956343f2a10e84e711d85a4c3bcc66e4ab987e626823bf895c082539a4bfdcac8bf6b3368857fdea2907c8c72fbfebec555d8baad2c5814f3008f9a4c161bc2c2d509ee0b5158e637dc74c16aadab92306659da7babc59ac42a6833a3a12b768ae59f37114296af9ec2096bbef197d092d30b2d9090928cb0fefb54ff822003d353e089e71f9ecb3a08ae3c4a1620346a695b1fa59d8fbdcad249e99fcda1553df4f26698aa7a293b1921b4af979f48a8b583c87ad0af3995758beb9d624a5b077c1848d64a0a720d8e2296be03ffb5abc272d6735e6d5ae29ea7e0d1f18b42c4ba5194e97401d8bae329a325845c37a5e891b1491b0d4835c2d6f5868fca235ee5884f1629a1a2b5a4c23f5f83f7011a063d8e120eb3e8ceca0e0974d512b5c89c4995d102f1f638a1f9017b6fee897054384e9183e6bb360e9b20d33ca51521fbd3b85cb2b1425fd4c812e25733048efa23bc948bd93ed7d9b3dc11fc686dd4db668423d8e4940d13d0c6a720a5209320c3baa41cd6571e6f2c9420ac7268c0ca5c0411857857f2cf33fabd7a65a870ebc09d19af9b8616ba015c863fac186933e536412cfe234ab714bce056a205a67dcdcf93e57cb12af71460749d75a166781e657ed35949f0b74aeebf060ce45e46ac4efc9a3967557ebf4a4d6a3ee3714a06c4acb1bad7d7e8b42c28c4f4b4e813c283fd482c52c7949593e7e7ef3c30b21c6732a34f301c2f4dd1ad1561ccb495be78a60ac2e833bade44a5b4227823740107b80433d1d7187c79df98f13dfaf7f2ec08c1d069a6c99cb0ff8b42f29869589b20f384682ce89a90000780915332dce244906a75c290d4ded0387780e307a4d8085ed7a861e59aaa3587701f64d65c48cc2c2a2e951f78a35fcabd43e7163b42a21c91e62afc341ee9e4532481dec427aa8e8c481139a4f1aeeb358389c09131757f2ae36de38c12a9893c155d8015bee1d9ae972c74b240fcf401c7b1af01640699a6dab1b3e1cb453af7f0f59ffe81aaae8f9d998b5218f374d719a7419310c7c67b4e64f40aa49ab048c0a40ba5bda86e33829f0a3520231ed70b3f502487b3cbf75d55c9a2e35649ad3a33cd888e764c0a0072c30335a7b1ed0fa6c85ad74027ecc3c244f2465d5d94c60fa4531217f96944b6746385a2bf025c07a0e66fa02789bb849b689b3e2a894c92c8f1d9cdbdef02eaf81363d9200d9bc1f8e41ce1a162b8b392a017ec93877bd592bd1ed15a8e26e86e3879d4944e1bc2a495b6452fb298178f2570979e9f05a191932533b48f3399390216d3581649187e0c883fc7055fa7d297f9ffb627acd8b32fcdf0a0e5278edcccbacb1b32d77ebd7b790a5c293167520193b69520994230080a984f509206bf2b718398c636e01035d86ab4e99af6c51364040238414593cb7fce6f4e07fc7221eb95810b9f32c33d9f61fc4e36cbdcbc3e7d73fc14c25800d282c1d278057eb9d1a1a832643f85d53dd53a2a0099ec4a1b9afbde567749e2ebd7df32a42ac957daa9e18538e8066aaf643f19cf1e92827b602ad1cb88f8bc34f4238a375d34f5c12ef3734eeec50511272b8ad5076c79adee5261de1c9f6aae42b838b96e40c511fc237c774cfbc36585a1ab1e8e201b08f3a1d3819aaf2bf433dcbc7a9630f4699cc675a32c867b728bf0cf84568465aadf79669d8f15eab43920b2f0c60ad4086b7cbe4bc4853a802fc7f6c86dfb7b158b0f3902977f265a996c76bafb137ce665af8bc48e2cb7b98f565bc524fcd5d6fb5a4b67eccc4355f5ad8d588b24f4531f4af20e423581752cdff38cc5049d6bf651bdea364df02eadc7168b14d03b5912f3e5e5f39339ccd63c6e3f7175441d1478b039a7ad5ea6ae8ab343072eb90f73b7645d207ca8c8ae012cabd8f6099c68741691464fb0e3784026a8b150da5cb459eba81f9181076fe7a922b9c979af3be5f2d512482a7b4c26137fb64bacb565352ee59c7f495973c13cfe855e4091396300503c7634c8cdb6dbfdf3958d24c199d07128743e82a7551f08a1c216932e283387959ca1fdcec5600cafa418e7da42ca9a5e6975800bdac05e07d8cd9d145245aaf084f8dc23533488062e4ca6a5a961335ccb2dd66facab6a6ada6f059df40eec66627c00ca2b29bce130efca09121351abdbbd0f1e7f99e26d78af21d28aee9a9149e0c71e4ec101d9717a3ffa90f6eb4ada1cadddfef734e152274efb05ffd458a2e0622f9db7155a2ca018ee0110e6abf225561946363ef928faed9590829e9a27642f43e02f95ffece38b8fb998429b7869313fe4f098dc8dfcf643ae83066badb896a0f358a2dec4f528a3e94c2337c362d7b770fa6a740f0e7a6fc25aceb243a8c00fc7f1292b6ca3fbf5a3370f1467afac988dcc8c43fd8c994e8ebf7d50adb29cb67e8964c26e811d047cea715bc6d6edee2fd92a54cffd6e6395d3838c7e176bd8e81b7c371a17661bc127d91b2f5fa84bb783226f175d8978d06210b92b9b44aedad1fd4ceb2f25f0ff1192771350df73d5ec51aea6cdd71bd25525b74603ecb5ee523e74eb1d66633b7bf5d75f781a79f2592d0e3843cdf8798faeae04f544e0cf2ed1c0e229fcbe84d996b9bda65e436801668a5140057633b2aa7ada475c3bee95eb5ea701e78a6f4815b9b9c6c0c04a1c16d699e29ce73481eeb6995e4027d30f2ae34c952ee46962657d2688752394d01e1c847efe9cbc4710d3d9af3c635b0f55eba90735fd8b7b0b286811987c1ef462ce595a86a747a4012b292324d80ef6b957bd8a2d28dd716a0c9fc144c72e5dc67681b74598cb08fbb03e862e094a650310074dd6163d277bd30497f0970cbf7ef659a7e3a5c63f1deff5a426f103ac7a26bba0d0a540de4be4eb20ab01da38f636ee02e1c23ae2927b19a291fdc793b53792a06395c4085063d739b55a653d6f87a852c443b70f1a84a055f11fab8c779817ad11642ce3d1448b7573846a692c8ba11f25c6129109883020811a7ec4e79ee82c756f836bcb6dc78080ce7b81ee6b5b811fc59d92d37d2815f289e88677b85ca013f22aa0be45d50b4d47f8bcc31f5fb689092fff7b94cedeea17c2b36fe59571136d6602dc03e497c72806b843e5e4315e26b7b2cfc9ce3315e4bbeb1162a5a6a2e2259d10845c70290982c3d790bf87751b65967ce4dd4574a1fe0b838eddcbdc73cc284a69fda0136cf8143c3193a3c81c83571adef1e91888ec11eeee382423b5989af5b485cbc6f392722df9f59ac85aac94dee11efce899b109ede04f074c78c896f2c151443035bb32c47de123f661fce0c7aaed2a04f027348e15ba0751d3ddf2d47c4cf239f21e76f89c60413d471746c25554d8197f9c6c3651c0203ec85dd091babe6604dec7680ce84ae493afeac18644ace079d6a1956e6d299c2059a462c287f4ccd211ff387b156a4201e735478fcdcc8110d6800daac70ffc6b27eaf12d9a5c984f56be1d98c4f62a16520504f8795e5e360504585f2c1563aebc9a1e1a0ce071b9bd48aa45d348bc998f1cb08719f4a6aaa8341e1053080c90e3b20e2a372d93fac02364a2cd4cc018954e9a8ff930ab3c08773ef2de6043a9983d6aa4a5f0c4d3118ba903b35430de8b615fa2888e498ba376bd94b67ea8ea4b32261290b272045686bf34764be403de2f3911bc39ef5843fcffd32a252aa09723b4cd5e8218a57dfe02f4f3b62f083374712b22d1db6bf7fea4a9b113c9b0ac30cb258b4b749dfdb65798350045f7b78ebf2ac1cd130d130730f42f7d061d9bfddd790372804eb3f76d7ec6880adddab3fd72ca55a4a85d785aef06ad99e90006e6dddd18a3d9db9f08c99b8a7512c0c25ca925a8ebaffc537e05a89d1e37b8889d2dc85c4a8d3b5e84e4a6f91dc32112ebf72eb9cd48fa53cff576618e0d9db312b1457411e2f806f88eb6ac470505bf0e4dedcfeebdf69db20d234fa5a0ec23546e1d0ac633bffb56db30526745470b3f765af1572bee5802347cac2ba95d0b3b032ade79f2aba31a9e6aa009d515f29e3e7b084b8c9c884c3f939e2354451810c3530ae2c9b52ba25ffad121eac5a43a304587332ab66bbee88ca50e9d2a82f8ea49a7712f109ef3efed2d0e76366fb3512a1669fb4ac562298412f199db82739cc91568774cf73a12e31c1adc01ba141df05ff7c11fc04ed5300e12cd853cc58119739f073e3e802030c0b27d3cc8e68e6e83226e66a05fc9e8edea9a5a964b6bd32269ca3bdaed4ebc5b5e85387fc1e920371425ee50fa1da07191411e49726365dbef53d9b6bdbc736d7bc41cf8e769a044bd30bd5786c905838da6c0fd2159ed13c4e861e73798134cb882b27280989b1714a9fcddccdee96077498798e67e4a2a8a75c31de9613e70f1d3fddea443e5299eae0d7a2ebbddfa3cded67f2f0a9f3e7d2b33c76144c13b6a0aff5b3b223879906059dbfa95d84485bcfcfcd3170a84632fc172201fdae1b945bbbfc249a4f5ebe818f158af658b204b40f7a84fd4181d0611514d1ec19d41cff71fe5ef35e1020b3bcdd42429de60cca089faea67f704957b54aa4103900ebc7e1bf8d4f432b216cdc0b22c8350bcddb2bf8bf95d62c155e996731315ef7d49d880b17a35942f46066ae38caf85e0f10e003a05a9b09397f71d094d988aa40509c2f59eb804296e408317b4ab964e8d552113fbda33032d9017e29cfbc279afe93fa425df9a6586a13ffe1d77a016019e49105c3be83a3a5587a8fa6c248b27289cdad92cb2bd683510110cd0188396280f4e5d246fd10e91f5f581dccb9dd635b0b435d3c0e9e347a7212c97d69ce14b87e1d8915975fab13c4ac7c679c8c20028b6124c89253c7a0981297a6cf87b0c5df897e408a77c58075e9299b60eb2f647ce4b013ba4ac5e2c44ef792bb076c8bb9f82a12101735e91d94f89b206124f218f2bb008ae70d64cf6d5a2d8c92e96f252a2c12cb25821c81f57bc6a395c76a80bf448d17124fa612777b1573fb8c550da74fa7547f48da44886e76d9f9940515fdc4536345ce0eb77672b29475682fa14e8cdb185a032d6035d302c19b995bad55e7540eb77ca5e2d061625c3747da0f7c60d72c44871c0d46c95c34fcccd2c9057c76ac4577b038c4773d60884848bb444c50d95d6b370f814c578bc1e6e16132334c821e74abbf1fad1312d9f19f06630fdd95b99a36194cf7a5535e17b43e7a5994f673d287f3f5e1ca60bc39d3425e984789a8853bbd56492d07495cee4efad69f686692d91fa8780e43ed07e8840032881b7eee725ca9c31e443fecf1c5e4ac708a52a6f21cd778e1b15975866215f7609d23c5412591cb6ee98d33e03effd4a948e30c030589586cc42d5856225e9d94066a7876122a71d5099060d6e999294e305aa3cf42e85404313161c3270ab142c09edf56a4e3c2fd0b1ff2f21b7dbaddc9efc282d11e575b3b7929351daa757b0bcb1be8e1414ea6b4e80a0372943c719b1ccf0c65e227b95adb98bc7d9e03a9a70c97988b871a658f50a5711284b0befb2e75202a8ac16d67040599f84b8e90255673095e28d09ab0c2b16dd1f91bdfbb42cda3fdf86dbc4cd89516dc0fba2bedd1cb665b5f297da31d8dc30a4603991df48fc690a44fb87a26352c907265a5a633950a9e1149fb2e6f7b75ed913c88646d40e85f5ad6466972eb77c5aae86d4d8c6baf777f292603636782d709887a87a547ec90d729aef6785d901007fc4250162c8e6eb5c04abd2446e45fe5058df272282bbcbacdb9e81b04f2420ab6c8f1f6192da81158c33a7593d111092e38b059652b0d325c043c3c5e382802e068f76464b3178d08aaa533b2ef831854815135a6fdb16f3976a4f63c24bde7708b37cdf7d03b1983a76bc6b1cfb1cd62da6839a72d88bfda602e852f7b393c10e8727ca48abd598ad584592588782c328ac28f6706b1b3d1ceac7e889ba00b699b0542c82367002de29f69d9673f6545d64157ffdea8b78649b6ea6a141869cebc049b8370b19fc6d3177a9938b6a1255196791e1b69d5dea6f646ddf53415acd1b1a651fffe01dd19d0fdfc9c7cad3f1417d1148ec268cc826458a62cc1eb98bece7ef0e62adc7176863cd84fdc7e7fcf36c31cb95620eeb19ad8931789c6b0e2d8a64889645cc472d1cbfa0dde9ecc89fc46bdd9ef91c960bdb4fb3729c542f62d34726b5825bc2710c22938cd5093a8dde7038a61cac4b01c49c7e7dc5c5a287aae554a809f110cb7d6b57da5dea4cd3e86f156c80491a5ca75723ca100e05792c8145da1582a1a1511aa427bf7421045abce0827bb99a5279b4c169998c2c4918ead2fb62314bae77e7e9b2e4b9a337219c8c2f64d7a0ce8010e4ca5a6230f2ff13222a9ef59011e4c07f51d85a4080faf43f56413517cea1c541b7c3d1e76d529a74ad143eb525293e81c4391ca270c6ed5d4ef0ff4e157fb213bd81079670a515c0ad13b40c885074118130fc13044e876bc94b524ebdfd85e57e78e21d34c9909a81b63189a22724e25bce6db98b3e2586f87eda677392f818f191d9d7da1320e4a66149965f3baeb50902f4e359664094168255a5d4d6ab3f07a524eb2f3a3aec6f3e829e21c7849272011f337db8de114cd85054e55d1ede2ba59f41dea7797e8fabd92f36f0369be31eca45e77f097c09609402565b0ddb13960fd05bbf710c388b11e18e9448e4a29d66e388291bcb598d0c1532218e3d6036d4e90bb0310266abd6eb818b5c88e313c7d6a84653e15a20b2f8495b42918def52f86a9553b9af803e90e9a328e01689b8b1c7a3c39a546590a53a2cee85643ad1b3ff0cad4673cb39ee5a42ceafbdd2833eb678f447858bbb07c1da20b8ed0862ed0e289c82fa1bbe2545099848e3fbbb29dc701b58bd413b3d2082042e12aa7487db1d3b04852e7cfde751c903b3327e96679eebc690738ad2fb36a1a38ea92dcd1ebed76e76857bbb0f99fa7f51f37165ff308e06cc4fbfa3efea82f3244b688365c334541683da2a65dd888a1d51474ea954dfc5a11f3800c202065b9e6919daa8d48cda579360e2ce83f3dc6753a4f30b32fe9cfb6ffb539415e4b61b2b78daaa055efa7f1db6783489a2ba61ff57b9716d1599da5cf0b7dde2b32c1deff7c9719c90fba9599d7b01a3ba0836710b92c74cfd3231cc55a4f72cdc871e7a087a3432076eb42bde6d1655ab13fac7b4a9f20fc4e78c80afac2bdf6c83fbad11f7eb62b509895eeff07a9dd2958e6dff245a274422e757dea8baa73a8140a2fefc0215cee52363c22fdc7f96bfce4c52e108a19707ffa6a7f90505b2252d9b2d9d7557f9849678900fd69423a85a6f315de24054244b9b25c91a9117592063c2258080d997ea139e11461e8dd2eb33bc814cd1a5ae2c9fecdfd52374257584342cdc070fe7b6cf8793eb694b2e33c46fdef58ac658bf88f366c0c80efc8710c829845bab6ac3e58d0545c1570aebd3e596e4eb605750306bcf4590b1ea33ff01d139ea7396b8a597c62e7bcdd61350d148069009fe10a4cedf6f341efaebc8fc707646e2c69d7694676437f5009fd1b4aa856bd45df91ca9764fcfe63303a679e89f31ac02e1cd694e6cb3351451bdd8b83568ba28588fbc0b1a87d6e90c182397e519863dfcfbe1755ac3d983c0c38058e0cc9f783f4d07188bf4840f308461cbafacb1612bd6a731babfef8a61f38659262d8bc9368bc3cf6747bca6f4a01a490aac38d52228fb08a4b1c05f4d6e4726e25171f29c2426f9915b6d29ed8d2d736502ba31bd6e01d6d0a9e9a15e0480aefa9ea2de9469fac109788eb34aeaa7be6cf2cb6600acb8ef5a360ca266c96572863e815eac455952dbfbb4722bb654b0d272475a843d8ea939ffceb27ccdec1edf11cc77233fe201665cad0fea0da88b3e26b341a0ed0c72e9d85949e42cd6dd0421a4c01e30868116e638acd64bf74d41a013948f519803a15ee54f831d0244c2d818de93d651f30cbe4663d7dceda874084b0b1d8cabfb955ee5e4b796b2db1a363f2a90e505262c91628daa493e9ca6180256f65d1d12ade49063e836e0875b47a64d43df326ad3525756042a09511add5bce48992078e7d5abd3aadfaf6de5b7ddaa0e9cea54e477a52fb04657d5fada68dc504644e93089bf964de83d7b0f4e30b738d2324879238e647f2ca4524703c6ef8561d270e5d873018a0e775dcf6c6a9ccf780c268da08c49a4b42946208f5092d4573d1b5f9dd92793184628c0e641e8c0994380acdbb4752f8d9c295f2f69fa3dbb5c02e88d0d091fde9c712d590d756eb98ba6d41a2ba8686017d730f0506f7979a553769db195d4732e2ca7f16b2b6d32fbf448c03bf9eb98e194d66002920daa481b52185b71f98aaa816f97183db380700c873928c9db42b24aabbc0bc0b7de9e4c5bebf06ba6aa58706b286f2580f8a69068b8f12ca2c78cf974f6aad86bc5b25105c026558af7eebbae4b425cb0c2dc98180a8427bcef5a38b8dc13c8073ce50aba44c51d4fa3b4120b0b12d549ea0ecf4997b9adde07639a12b9d4497034afee4ef59963eb165003b6b528c262101a5c5dfbbb67902a1e6a83c045e27a8acb2c976dbd5c76aef6ccc8aef008f30e580542799019c3f54c60636b7fcebd5505985c8be3af13da49b2402d1f29727a8cd825ce8515ee293a7ebdb35b59df3a9bf242f7a2ad7f322e30fb06d8aad757c474ee8c1e124dca104bd9512242f2ddd86a82898bc3166ac702b932261f67ca7f947a9570389b8d4b8b88c9f84d0acffac15a67f228880e094d2b5a8609f3cbf228e3bf5a6088afa89e83ef179ed08f8a57a8a209840704a58fcc52ad6b0c4479b3b8c0d1a63cf97ba87eb1783157dd7effdfee7071dd6171de70e83c67a5696954295dab6899f2ad37afdaebf35ae907128c618ea9163f9334b4c4c3a0da0e8a61875d2c633b78f539ced0b41117c361205da185d60aa6476a0620ca28290f2e81a0a94218f07094d568c272619a165d9b833e35d79f24fad190f5c3694e66b98ebf8ee1caeb3bcbf90bb46c52dc91ccbd32ebeb1f989d8c271ca257e0c6ae40f53e75634571f9e5d288b91c48938da1ef4d0f709471dedf8ff63f868c82dcc7a4e81159d488bb2e7bd15cedfe598edbb72a6c5891d077941007266f17b4235e3420c88d63f37ece04124bbdd82427b30de7d66480a5852eb1987e8a4ebf2d17aad8a7acd5479f15cff25886d01ebef15910cc14d6cd8082f6b33d7151befa3ea41ac23a58880bc20a0625128b54eb0d4bcf623b01f2d0d01968e24fa19619202e1870d81ba6aeffb73ca4d87b114f8860bdb647a7579ea7a6acf2b00aeb146e81ae311bbeaa11b525fa1910f7dddc5135398610060156f11781a0e43c7d55bac658feffe2298551f45178e5ca2e5da00eb28904b08a21f96f6833d9f393ac726799c12c5ca6eda9cbe951cd6c24b662c6ed4d7e5e633aa4077ed04f883fd1a7f3251ba24f17dd0e100099424c78d803ad163e85a23d8b82786c807a200d0ac0cf365b48eadd107a57fdf7b8dac0df3561da8afef73209e8aff523e50851775d6781912c994ab9121c69c41b740f8b3b2c775f4927130ee97dde3512f32717a27a7aa0a710040dbb9828e1e12e75a3dcf87c03b033815a921bb774418c99fbf02b569b9ea24a42a2fe3a2e443c02daf5aa6cb0ca8639bbea85b34bf2c5e314b5fcafba6e06f84b949bbe17fe4d64f34ed8cfe72929c900676b148f2990d142b65d986f32f80fdf411064fdf88501a9e63aeccfe4505b1005de8040b4565be14cb323f13262bbcdf713cf65181c1acbe042c8403d966b8b02cb3b8a72f1e0aaebad0ad7662431fcd4504cb02edf3896fc6f382351884acfbf57e2ce03747dd3624b75e9ed839a3d0c11a19eb1a8366e46184534ec53fae97546a260f2443576f69c61792f43455cca9d9d63c63b237ef521b7b495768830ad58fbbfd6e381121206ba48e181d7c7dcd1e0ed48389078687430e677c2f9bb18c0c4b54c14206634d97525c059004b0ffce833a9a20f4501aace2f1aa6123d106e1bb50895ee41282dc772483af69143fb99526f7d8aae99528f7784492a34ca859ce5d2e51562fc4748dcbe8c76469d84bb15af1e3669f0f7a0ff107816579f322b9838c48f47d082870b93f7802a1234d0ccedaba0b91d465f740e258a5fa93e0d6b5024183d268318cf41268fb35a33539da9efa857e6f394efd8d58c446593cf8e52475ed8c3591e83f39fc69eec3556c58fc1365bf3f659fc08aa287625f3032ec1e6a3f11139ce44ebab58b68ead38c59f1fb52f4c51fb4c9350fa4f561de9678f2d4015fbd3d38100b1d3a1b7734325e6699a0647b5563b72efda254901425774882485e6af3e19faafc8fd398b71c6ef8c1b4918a11651a9d040fd5e8a64fb828eaecd48b4deec9c19b3ac53fd89eeaacec79b545a5b4039ed1504da65c6482a1064285bb2c0c0de2c5948fa0a30fe7183e48be5c77083431b0b17e5621ebd8a1e1b3ec93db23e5a2c5e375fec02126eea95585e4d17d39a16cf8ef9f6e68f355862d0d06abf46fc4da6b304a48b4b5ddc6c2163a50b75c1cc70f428c6147feb87a9d754a75641ca310d6efbc03de29e59fcc48861519d919327a454a408f47db72aaefa8b1058c585699c6a4f7ba0145672ac3f7c540134b66944b2a3377b9f6ce4e6c718dbf13247dc572ff8047df641246674350d12a8f900173282f87a59b82e6917c8aa8275f7555f4ace18369270061dfbd4b92de2eea90bd42d063666e45c868670ba1cfc517c3149a954ace01ee49aa48790d2c3126aab42ef8db54f392fd8ea4e4a61e9403c1bcdab5c7081eab7af107a50f34a2a183ddcad39b4333981b80d72a495aef7b94b4f14282d0422a6f9ac47aac7171f191674538986e502673033aed983aa294f8e0502e88594aabf14a99d83a6e016011ca247d2accad08d45bf08f5e102eb659de093fd3d032415fe38840be126a5ecb8c0e9bc3bf623b185c14c96854f81b7bd96c73183dc71214914f9f4368301b265498e5a5b0b5e0c41ad4a880f039732a560f56186a8cce75956572e8d212879dfd84516fd60f9736fd819c52863e0cd253fceec02c7390005f93e2c35f10364244204f5761902d4cb7ef52bfd0af8e544d1a6a17ef97da85950d16ee1e45972519a97c8b3d16cfec1bdbb7b25d5e2f46b64987ff7e2f128edf2885a9d8f0b196a33146fca20a27dee084e2e5a7fc2dd5876fe042be8b3030efd261a95ec9b9c4e9aa363be7d3634791279419cbc3431b9bd3f77137204fd41bf1aad5879da005991f503212d163df31b20e2f304340b9bfc19cbaafe4976a2da69e7609a94acde3d92b1ad8e4dc34962770d6dc11238c78a6308d4b92c9fc0f0e4d6a5fd86e56884dd9878b128a7f27ffd2d34e2ef3f30ebf12ac66d4c040af8fc61569aa35b4d8fbc404dd85f0f71ab0f3e8c7dae5de8cbf857adb753be8a008a6d38b7dd06e28bfdcbd41aca289a694c33b82208e3e8fd83099b866abe90330ad9e23e9dbb1e825917730028d8f6c52d33b48a20b64b62103491c9931bafa6610f0611cc20c7761869303b6fde2c55f915cab336911f8aab3f2462bbbf0904ae7cdc6312e391c5e5bcd4dcd1a48be5209663a653d2161c6c0947765f0cadd3f22689b6dc7cdbde013254307df2d62c1ceb53fb6400a65985f5e7a8561b148d8a95d99b86ccb7d2e0ad8311a28bf95c8f9f359a678d4c08787bcf7c2a405c81dd0ec79c74b78008fc680c757a32e6c2344092f83d77668e4a4fbe64905a83f3222d815f1b96e465b51382ed697495f8371308f88f21d0d46cf42d8146a17d2339ebb46673cc83553a4c3bef833d3b14c29c1a7664e32003d4a0bb7b17b653b7de840fc1ab4fad443c59da3600c1481642d8cdef5e5715a46261f833d105bdf27fee44309d6437b40f8b512a4eff2d74775cf49bc4f74a62c19a3870b7515eaf24f9d7e2cc9e1223604a07596e6f3869a13797fce0c5f223de1ff762b554bfc6fa663ea3d35d400468ea408c64949080cc71d6b62bcd08d84a924c1dc1184861d8c76f322ee4b3e2f96f6e99cc8daef5f31db5660dc3f4713e0772d6cfc6303a8d4e2227bfd500ad18ea53bb4d6f835b6715d7bb5a2e93a7c6f47492f36ef5cd435a90a8cbb933fca6c2630df4068e44f236b1f575a6ecf51ae1f187398b86ecfa767fa3423becdc9005430a0c84342246ea4e95123def75132baefee8a82736eb64e71452eaed96afa7774c91e64a37c4c662305f2c82d85caf30ee6a7320cf98377aa8e30a1b98199c3882168e04b1093c0656a1e679575608c8adab8a884b4f7fe28ffe5cb2ffca7ce6b1228d0c945d85d0784b1bc4a34bd304f4e9d8a1fe9ee7597e377719aeac12f3f44615ebac7a37172c2714fb23236971fc6109a3675490b7cc54e0b48e2f98c12e6933ac5f5bf1c692618e4b496243219a891132d204edafb54310c91c5301e4083aa0eb3aa1fe0690590a7fd377099b68386be1b9aaa7c7c054379a4dd06c21bed036e575a0cb021b5a7242ffafe26f16f00f68b6cabab2361891177b0bbff82fdfc2949cdb80a9035f890d40db90d3490a2eb2a6c462006b38fb1368466afe90931d12dc5835d5cb11bda1d5a76d6aed2cffe1b767c9ce26d617101bbfc3b511bdae45ad01512c75ceeadd0124610089709f576517c39fe6f090a39f72c05216b3ffbac120da2c2515613c537d7fc5f325126cd2c44e9212adf8925c8862e89c0991a061165ca8ceefc47bc8aa238611795790b763a4a1fc2500386866fe2b47f75511918a0cd58089fef1712dad20475e7cf8161a25a9dae13fe2560864e3ace2f4083f77bc4dbdd6a64366a8cc836f1b8b4134f8f9e7e4f5a9c5859c81eee56f9ac0bcf61f4887a7328f6f16f18626eddcbcc92029e9b55ed4c922bb39cdf7c906484e2f883b18919a4328efbe3b6c3907f4e43ce516a6c381aa00dfb7d2e0b1d9b8783d82f8a3278b287e0379d871be855e72c68b997b6342901f2a44853e9c58ee92144fcd6c6a4d1042782603d79a78d30b7d64c186efefce93469c6bb0d1a596033f9a418bffdb55cc570270d033ec31f87c4409c0070a445462e0a1acfa26f028582828f959a9cb9a3f1708c37b9cbbf42d856ef5cba449fd9852b37b6d6ea57f159a422564f55f18af4ecea94750274d3e9f05dfd40f210400dff75d498617c441a743ade93f696bc3622fbda2f139b8e67bd11749a7b33e65b5b45bbd1da4f99fe132b62bcefc802d57a657ca8398e108fddcc0b14a0267ac2babb0b514180b1533dfc41a9fee059cb98642832ae617166ffd8203875635291713bb8f251b3fd267b9ec6b068d94294259e76cc114aa31712c363660daa96466b2d61b1ad5144f260eef7e9173e441f5de63240d364b1558837a0b2910e91bcc50792900a7b2b4f5e424a6b17ce98f53c68900f53fb841cd9008b00f1dabe834ee45653f6793037cbddd842a3d2fdb7c5c9b1448f2406020d58937e9cdc354a2c150a9272f7efc1e6283bf1ae8bc04faa376e81fcae1f3c3dd352a0ece58ddabd00f1c2d57adb9b670c7a783cc15e0eadc05aff45af3a50c30cb7af232e4ea64a89b750d01462fd611e407c27166c62e94d8b1169487254da3f85bf580435bb5dbaf8c7731970d565560e376b71dab38193cb46aba970999ae9900a37934bc228c75b398c42dd0a034e1e14ee9a5e60bfd15a63e890636e8a6740336f1e7698b97d07bcc7e61734977593311b3ea7214821efdd76dfc8c4185b4b5b4706ef97061cb599e19643d5435631ef7de258350bfdbe994d7dfe4340e1c447ff3a9bcb246338abb956bef089a4e58904de24d37639bfb7d1b618868701bcf9e85cb5b82ac6c604f387f9ddeafadb2876f7ca306393a1fe3749cee591b46aa6c4e526317607325e59474674b80e952602b254b956dca679c4aaa0e5e7aabc8399588fcf1fec61d67f726233f7c8a16ab5b558c555892b06610354d378bb4c4edd2c9e93d4f15747523d719e593acc26f9240d62ba3d94096b45d3db1d60c8ccaee605ca11636bf894e9618294ff51727cfce946ccdcb4ebf3a11ab27e2093caadf411125322219f55b936c34b1282e211681b8aa8a783be1367e9600b07ed0b3914935dbeacd2963e891739158337160ad55f639dbc475fdcbef2c1bc9b26993d616cd9acedc014e3c89918b2ffdd2beb362303b449a428ea70d120537275f105b765e4e44170b22fc55f9c870cb191c5254c5676a0b1030eff0c468fcd364663b0156abc7ca307a83bf5965e4778087c4d560f1ce62350348d93e5f4347f31de41a53ebec7b9c9a19e38f1da2a6748dbdda8651197fc11044eb4bc8d73a5bc4c87be716ebf2d4994b90eac3e9c6256369d0e3e2bf5707560ad03bc20cac6a1430783b66ec6b449fcba5472f73c0e7df91fe3a2df779ace374bd315a71e2537fb10bccda12d6b2f31da9539880e0a256d1cb991fc9ca93381e7ddc0555b46a53a911936497e267229ff1d9fa426117fd930b95881f03836685dd1aa2ce48734b10365bac17922a8966ead2f07b2c403d7d0095197cf0e98a26650660372a8d1a2b7f43b26130f516b015fcc44dc9b9ecb534c1d3b2fafecca9ab094e80d2776d09ea23a1a3aa7b612aba0ece317fc91d2af570f92f9d2b1b98413b07a1bd0adc2c461bfdd69559c7ce7df52409b2526d9968019af8fa2a9d7e770fde1b16b024ea1e51604448ee8edd79dd920e8b28365ff7843b1b4fc58d277310e25eae28ddb7224efae9d952828250853074a9f97231c48fa31529a6c28e0fa294ca3e53558057b2f2a5612f68e4677d10ffde32e8c2feec47c9128095d11369b5393d5bb7e3eb98687d6ac5520577e9ab665b35e5a892ba9f2b4dd3252e0f777b70c58a6aec5c1c6a10adb0cdf37b85470de4f704a5ef128caa291a888e2de4a3d3315daff63afa24cc502aaf242b776289847019bcf83e79b0875610e0073b12528ec01d72da3ed2d864f1ff419aa9076975f00f958b99338f545f0d272cc1551d5d8dfee5c14c529257ddeabae60f80df14474299210aae6610ab1ef20fd5158667bdb24a485bb2b842ce72e863c0daaf1419b4ad01f30ce45dd7d2bd0baec128d2334ab60215d4ebbb85af7ae4586b167f1a00ffd321dfd7b1ea3eed6015d58a22e7cdcc7c5528d811c3746c1e5c17d937d1b6bd07d0c3a5b7500ede9dd626701b03500b7b6159f222d2afdc7b2121107299bd5159bb0193cced038b3492a0888c78e9dd3b1ace10fbfd5074330176f1e4847c5209fe0c6bb507a9197a0222c8e9727277bd450aada4c4038a5f9614ef4023c5208aa3bb984b48312f8081a4c7b1028896df6a34f41c732546bd393fd44b2e8bf8bd1a72e5d4e2e02ab5d98f44862fd1b152fc951f49500f8ce55be7fa2d4d39d62dd7e20000fbf9c29d11f32f582adeec1dedd6d4dbe456213b01237b774f1f34ea173bab70247363c5f08bb8a74bc1147e64f23f89afd3ed00f0d12e18af506181227c9ea4a288bbffd148c8a737d1eec82eb5f09db7dddbc955877cf090945d2c937fee39b101ab5a146c892072d85e3278dd0539b5e494847ac3718e7c2f3b5afe2189f7703cd491bb1e6b77ea45d73b3be43d2e55888820fdc5e1ce5371ffad3baa5eb12d5ac93ac4d2983051040cf7a0ed64220ac3cc8a8a4a33f78cb484238ea3c7f269d75b2e45f40407884f1ffd62be65390f4b89bc680850d499a6c424a4b0189de02e10cce6272d57d4f48e10fc6ea12fb9c640e095188115e9e94c2ee184aee3446b7ec367c46ab7d852a032aaaf46428c4ef2b2ab103ef9f0837cf493aa67e37c06b543c1865fa88314f76e2af1483712fdf69cb1deff449e2e4c47a17240e017b656a6ee71aa2019c21921095535a73b3034a5cf79096b98812a9b91aa2e2626d1fcf2ad79292cedb32ccc9d06598b20a8cd553898aaa1acdebadf5b63f938709874646dcb918de37f9312b465f7f3e142a3d795807fa16c65379a2856bfb132","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
