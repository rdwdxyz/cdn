<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f85a6af4dae0b9c889e215635e2d25007af950fd716841ddd58a1ba398a6fcaf722a0a9d7c9faf58a75116cd9a404136c7cf2e5a83a79e29ac9441c5d2d6a8336ea1af8bf37449c5d4e47281ab1c349143b281193eb0bed6dfc2c15ded028f18cfe4f2ab9152631c49a0306965093965902911970bb46b05a24d42a03df79fd706f788a461b6a8243e4d1a1dfb56cc117c46c2353a8661e8fea9bed3f9bcdffff93412cef436317d214b5ecd60e57cc538e508587b63285011907b2d4f3bed58d1ffc42db6c6a12531cb02fea8ef9064a0045679bd3ed9024cf68731cf4ec2233c3a8c8eb02c7a639fdaf1af00fd2a857b87bcd226b7595173f0559fff00d28f33858dfc9aadbe05fa9242cad10dd3549757ee6a76482dd36e0efd6708f177eb4c63dcedc070e602fc053d512024094bde3756f56a6a99dab156ce52004a4b586135e69aec365e3bfb0a96b6f76fcca669ba9383b6c5a4d21394a3aeabb4bddc00796f5162d6c942b64c7c62e8cc022fe5c58d934036cb60fbb0d592e1290c02e3f0e2dd50e956f0e4e0363d1bd59cfafb2190b2fadf33dd3f4338beaa866f9d0f79716e3274f36523da7b3ed8cf318e357733f7117c48be598eba3b2d56d0581050930c7546bb6b3e0ce0fee7ed25835f5e71f0223514cc8b804568432dcd1056c8f4b5b1b147b0664ed8334663a9c1a4ec608093d53f268c29efe16faceda6b04f2c78d65ac62c0c6e988281b2beb6e1c7fca379f9547f83bdbb54cdc592ada5d4c2e92426db68ecd3778a584ef156d11bd5f5dae8b3befe72225b12cc13d0ba721822b59198da2d4a0fb9f5150f393665a262660d5f0e6687c0b26d0b4bab739a82a1338bc8b4d30edd2c9ed64745003087032883c8c05e7a68444b3ff0bb8a629585eab9615e13526399d240acf86dfbf057ec7f351e6698107da3e01724a8d03a1cec2773840d3aa32e62278ee31d68eb305b1137cde795c453479a04df1ca56b83581395d1402dc4bffb152b4a9e54b877ae6740546183ead333af750a808640f2d49fb6577f543bfb0f69fbed535578e93819ac522cb90922162ed2a5139af67d1e30a30b8373d7d53baba2d4fed9e26c98dabedbd010a6519c1d8ec054dd6fbb359dabe1203ccaa122eb3dd8e0db4aa0dbf98da10e3560622e4a589abc1c150ad216dfc1c21b35e2bfb6441d08ee8694eecd6d97a8cacb50b1d7bea94deb886accc0673b05d1a53158df2881fdf39d02ce91cb4ed4fd6228212b844dfe306f50d3c0fdb5f1b6335f553f8f2e69b477218f426a54af87610002adcd18ef4e9a4f3cbf4808add1cef69e4975e97d3bd84fbed22550e6a334f309ef6697a1a55b868f41378ecab0c6dfa17fdffc3c776e5ee8f51d527a03fbfdbfc6b5286960aaa9c443a4c4ec194f027d20c819996228f79584b46cb180326b6fa55617de16eb611f9d04035f03cca57f69147f7964e69b6baa90b631dc5bfb2956161999b0cfc26b3b571ba6aecc3a4d06c82eaafeabca55bfa3d31ed222da98940c01df4a61fa908ac7047b3ab4d8e7f426ea17fc233abee63905d7da7fff14e176035ebc8ad72e57c431bc61b820007e99d3db4f7fc216b8ea11f04a8db51906759aa0ce471ee5261564ff868f84fc6f14cd1823ecdd15965f166eb894c061f8fec5c930c9c4b8b675c25623bca1388d33ed2cf0b2ef81e34d4ed232be5b2dc4dad149862ffb5060703057212d081096aae0381cb78df1ea8a956a4aa8392e63719ca19df38f82cc5ecfbd548a98e2321fa0962a591cf79b630cc079ba3f1daf6b9ebe2c05407b1341e8544eef338315145f209df4411c1f4ca3ad6a9b4736c04a2e14385f813505c2278f27726baf16c33eb55a7846c809fa5fd7d92e6dee054e50747d00f5da2c4ddf1095800e35a7eb5d4761a74ca17305908477c5785f269ecfa03b2f22f6fa33e93a2347b8ef5b34ae4d232d287cb370e3d1d43ba83624f5cf4a642e2f10507cd044eec35e7f83032a7942cfe65a346574b534b8c6ea876e579bd425b60f631023da72e7b8721dc4126ee59c5035713df409adf7037ad1b67b02ded170a7140734a6484f30a7204d9bf4b03613b1595fcba0ce88b895d3514287752d97e4adccedc101bc84923a7e0213908ab024abbd37aa59f366aea55278daaf44486c7d3db7091b06cd3785cf6bca77d9b7ffb502d385279a54216ce9ff4b791dc6370761650c101da209cc04ddf15bc5795904879f276f9d613dfd73e4171e137de983e3b0df5617c8b59dce9c0fa1afc074abb13c3926eb5993b84099186c4862edb7f3f49d60a47426da5c98af02ba2291031ce646f54df5105937c3d721acee3612dee0755b63b441a1ff4d4bc93ad598379519e558cd71d8fc0401dca6ec958fbb855c1ca0e0c1403fe8ab2016a2c37cdad7c58e8c295606dedb94be0ef4ed08b823610123220750da60e3e4de0ef8aab7beb9232005629a1afcc9b96c3118d1e277ce7470768469df17be51e50e83faeecee3e5106c9203e07f7d5f699d0ea4eb406a2d733231aa9f824cac434f9372db239795b9085588591da58e1be2ff6eb68ce30942824a77f87011c477011e3fa5d2bfc6a0cd3d83f1c4fa6a45e30eb20c7afdc26b421575a7641d598d058c17f70af6b259876884521abf2e95e75508d3be0461f46e14a49096a557daf60702f8e0150956fa9ddcb23279574c29ac525f18b0da7bf94ec897ef495ecf9e5c21219ff409e39a49b0cf39c41e78b5b4a62772a6cebe2dee41580c737a00f7bf946cd3beebb64fa89a877d7ac0ded14e49b03141015bd7942afcf234cd3c616c57c65b423679e297f0896f8797a1f16378da4b2e5a3323f51aeff7aa9309fc4f70c6551bd41293cee9b3ec57594ce64789ce9b05eb29406223ffee7b13e0a184e98f8f2742c9d7d58805f3f047aad9007d6e25d8f58525cb385ca4aa218810e52b1fa5f46e0f907f52ec0a6b74d3e136e69e6cff2b590c7157d38e11124d245b3daba9920950ff5e17c475b4f08f1f76354ef2cebbfbbb2e7aaf582daa1d25d3de3643143f6378dbdfc1a984d79d9c8796b0add258cab8281b4616351b0d86b9edd1f7174272e53bd533d3f8b4d65dc65fcfd1b1bc5b887ed250ca7bc45a921863848452c07e64394955470720e064acee3ac1b055e0d408af109d6ffeb1906bb1082b621027deaa0879b44a4fd98cf8471139f506fb28d27d93a5a82f01be7173e99faf56ac182e5a3bb6c83645c4b7629a8edd1a41862c19d4d8a8bd6e6ccabcc56b8ea658b97bc30c942b4648f7af55e069a5c3aef0b5e039f7f13e64aae687b528de19d20e2bfc6b70eac3e7878526748ef14e52c26c5e065bb2e3ecaa099dc69a18e31af2fe5d6122e583522439cd91537736c378129668d1a5bda6f71b8aa91751e87eda0bb47a1e992bc3760315252034f4b7c697665a50f97c2a409fd9de5c2a8f84dfee6aa1673e059d47cd27353d6fb45d2bbaae165bdfc1dbe98f911616a112f61096c11a7ea2b4f1d7a0fb158a655ae8b20399ccc05e989741f77e205f723041b4382c84ba3c9851cf215e77114acccfadd9a33fcb9406c2195f259cce0c4c920f6db5d6cad5a798c950888b4bfba576a3aa43581c76c077e4722a9ff330c8e73b1d86d460374d2a758147de28b55dfdf448469c980e7af93bb93de8eaee8e39478bb46a9d813b470b4759887689ba8c18dcd2943cd6bb07dc9ba561b435bbe51ed2e122be919ad7fd5dcb8fe638b76d89a11056b87f0382b6e1b65b91a2fc2b582072125a481c36e89861d738e4df222133aaf976dfca2af0cf98a43d68b565100965950c4721a5d105466501a4a4bdf6f956d4de06ab8c53d04a48b52f6c6cf02b78b1f5bf86cc9b2f90e4e8c8581b7fdb1b42c6078519f914bbba00f6cf9c3e438593d3641662ed7bbaea1c913de2bbc4d9a6a0a63e7ec68993b5e2639ff121facea6b4a779c166499c0f4a1c4c2e4db0568b591a49d8bce8d6074ff2ad67a753d325aa28df5a2945b9d145ebca7e81fbf167be1bddf542ef2c734d3762f7f3aff7752e6283fcaa81236accc9342011947dcd792961d418e6b20518b0c94c95191047efff000694bdbba054bcb681d5d7f921e33288219b21cad2d86f11b139486e28db713d266c36c8dc37ecafffa70aaae6633ae55ecc084927a750d3da59b4ba6d1a80c3b775088cd08af7a542017c5b8a1b14ce627c920c995842b19b0f3dd99585a4ddc9919961d0f0c2615f34b39f46dcb39da125b295de682481504611f87732901a1cc0168f527e8682006ac1252e24a062309110bf177f31dbc99f6af2a75e7eaa22923396629d5fa8a4e7ed446b411dcf14fba8e96594dc5fb8fdeffd69648d5875fc3fd65181094030e58683759e79c487b7099a8217a0e665e4c307c0816526e4ab0e50a2625076cf59d9fbc08ec36857de4866d86e1ac0121900efd4b3dd7576e46217adbf00443b19a506a866cfb60d1b56d0e90e83fa1c48d413f53491b71f65ef7efb9f5a89ed2b0048b1deec882077ac275b446fd5f8287ac2bd3ad24bb5099eebd2b59a2ae6bb4d1126e4c4ab40a431e981b1750b0009fcd2333f24822c5006d6f58a3178e57dafddbb717d73a2ec3647ce66630bb07dad9e9f9969717a2d70bd9c3c38662895a5bcd90eb01a3acb452ad120b422fc5020cf257a988408147048068491729476e46d39898e2087d3f22d3093c4397805987d8fdea16f8c5dfeb6c0707f1f6113e0d0a1f338d80a967a1a7531ea5d69371e260c0e34ef3c4d914fbebe5651cec0c0008993a28a634a17d7b18c923785d5cf41c729b056079e265291f7cb66d2a9e67e6f387068a7e12b3da6fd992ade1d887aab94650043360c1dc6b03c66572fd4dd4feaf3a4f8ae48f439d8b81abe7facfd5fd72c9e471569dc9a697de9e92fe34f60ea819894255865f4fbf58b07a4c4b2ebef33ac62170e2196f7518af741d1f705400b8988c8f6046858b115fe8bcb2a40a4c1e89c22dcee89c9154ce2d6772aec620bfb1b2bdf7355b283aa19b447b0e82580c1bdc7a81c429df4282fcfc6181f857f4660ee592098f45e3b00aa91c3005a500cbfbe78ccbcbfcba72135784701a51dbb9a21ff05b15e010ecd8bbd8e6bc055f17e1eeb33ef884372c19bb3e5e2b45cfddcc7e764afcd3ef5b77a3c695effd4a50b0321ced14b6d048a33cc21659e0965ae720b23a9498b36d4bcc258ef49813e7460d3efdbc868bc342cbda239afaf14b6d3f97bc400b06b04006a4975d29bcc26838d8c45658e8e3a5159d5f1a5cb633f229952188c7ab6170b8af5dc96eb4945c3cd89f95006fd9ef18c9599603986dfb6b90bea52b4a2bf7448c2bf3cbf210fa44760ac24f86c6976a444551bbbebd1d0f8eb869caf3568809e3b57efaebab2385f1767cb618e653d138e5bd501887c09ba03aa9bc7f17d12e75d400075305a023e6e546460f95fefc48d619db8ebca6fb1d41cbace6bccac1bbe936c5465b7f66da2c0932a0755ef44c1a4b860d8c1a944e08b49ddcce9b6341293d23b848c1ad65a64041c809cb745cbb2d435de2b94c9f918ebfd42ca27dc930987468efb2987e34c6d822402b3a091a4e988811088c79562a8f6c0d746aea36a7b917f72d0dd784159bb5f3a5131708902d09bf619cccb6f0d1fcb80b58ca32fcf7f510bb385500d2447bfddc01f66eae1cbf0e17916d27d02f8ae4dfb9cbe2e68c693968b5dc82b00cf39d6b90357e34950dfed1d09c3bed74f20abeff1e1209ab174d3024a95ef8a25952ccedcb91148c22cfae0b0a8c1bee2b1a055583bada9fbf28ba0e3139a3876366900e46d195ea4d47250355bd5d08dac65206f92c43a1eda99d7fb10b0568dc4009fbf3fcdcd9fcbb2d6f0d2ff78558f46997584c4fd282142b692056365727eeb56255b56bc20a4b164ddf866a5065af5503bd6a76fa0b42f5cb81313be88610b84bb397c99db7a6da9dcfecf3bc094221f3717286398428dfaec55c04a54a6b83ca0185bbe3241ba60b3bdc82a0e88a1bf1c42ce5538c4c3380d208d88a487507eeb651560a7dcd0b60f7acf19ffe63e6d0129c0f2a32f329d40b7ba6f813e8cc5d1c6984b42708eabb90e146bf6e7869e0ea195804a46f25759a7c87be7a3f895f8f975cf34751ec56df0e69e0e0dbcd8c2f8d447a38da415158f58cee4dee513bdb9b4cfee6a49a42dae420543785d00b9bb8e0d273e1ea142fc75a46c832ad8931504e5eb4f184c567ca128c3cccd4dba6837942331325f75084e1a49532b7308f884c066fecffacd4a48d50475e93c509f892d0a72632c0b40adfc49c18ab4f53443e51127ea36437104adb5a40138e166f4548c2e7345d18480fe40b778bb2008920b501ac5f3673ecd1de86d5d83adf95790199a158368f800015d66897af85eed16b518609f00c1aca209ba0e5b0a29371b5b12e7526768bc8ac6a679ea3fa0d42f7f2d7fe6fb7869c161345b08962d820b6ded5763898c7ac73381b81151f92c830a26350cb71d415edb5086730d2f1d484b8357a75c3b95ace8d429cf33d757151b97b8abf697d8313b20fd8f19e0d85c67e3b48c9510c0f46d24905d1f39ef60fc6099b595a61ae35d24a78802e381ef2ba5259853202772125c1527c1e3a2464a24893d1e73907fababd0bbeae65f5667cdfc7a8cbd0df0adeebf4e0fcc04aec17b2cc43c087fbb6fbd71f2c5387251555a89916eb54d4b410a866d20d68e4e81dfe0d5c4773a45bb17539494c64d5b56bc1d46fbc7805f8cbe7050c964d210c12dc68213c8bd424b934ab885caf7eba32a7a2401aad49b90e375e8631e00724d693ea2e49a7661956c2d3a6a5ea030d4ced652ab2d1ec8bdf40d08d41c775b65ff6f56b1edd77715df259449c44da338a41981b0ac8ffd506e20ec5a3e6d69a2d86d1df69406382054a3939e4b2896fd18be2320cbc89795a28c21d156aab9c79d3b2208d0c79cd4d132408c9d476c1c9a42bbb17e438b06730d3b118ba3e60a42db63bd2289fdebd1982a3de1bd5fb375014f3de07841f2b6d0808ee433312dee216bd4b5ed1b2ee54cc8bb1800851a377993a906d014dc4a0d21e620bb31d29cc762fdbd6bbd6947212f665edd9f43eb1c809f053c1a229482f5abac7f00427de2586af639f19e248407d9eebdba3e2f53e6eb7eb94a1973fbec7ae15b50954cf07804ef1b8cacc644a90fd4fe64f2ef45cc4ee4619492a7281d79fa017e5cfcabf26c7b9f45f128db16f6871062a2bd747324dda6b74a404abae81d1926b20817f0052764c6f75e14f620e8a26e22f6e9844b2f5cc73372e9419cf441c211b2c411ec6a6bf6f981695c5055b8c35dfcbee85412be66fb566f54ce237ce780b61906ad540ccfe85f689959374f28ca806d195147e91dff5808e9bcbfc4e613ac58ab892838073f8e28b98fa3fe3131efaa4f64efd2a009339a494c87c1e55484ef6b1375932569212d8fb29e3841d80bf5a0a15f6831a33e0e9c59e8f347576f46815ee4fc72411adf2e7b7db4054f94a0d59d7af93c4d69f01cba152335852c8d99ca386a3b4e1a932def8a6df0861ff109ef4b94cf16bed605768c8d61c5001cd329b4842f89ccd060b72072aad2de924405470e8dbd4125e6cd15bf3189f122a572ebaf1c85b69252d336c1c57effe8311aee36a533c0d83f76fedc97180057e1852e5498d58f3e034dea80fcd4e7ed07af2343281222efa9d49b3ba49b68c20828be679cc2455a39147d037824e2f8ca5b49e31cf5aaf62fae983df13ea0b86756f4ac8444fa7860813bca02a3a5c1158467159d8cf24732f78311fb28df1ae3702677df7d646194ebeae6dfcb0ea799f1a05efa465887afad6e4cee238ccf5dfb4e2a7ab479f39e207641ea2261adee07471dd641fe030489e3379752c1f3ed0f5fa9d72cf2608df4468595e7587c3603bcca70e246b864f37824b4bed3d8fb3403c5eccca859adc828be521b8bbea674d97675e1ee4ed397c865d5a79e24f2b203c1bbcc02f1b3b5165778394ed4dd7295f253fc8fc5f296682f7303113fac20aebd0ac2af2895f848bd4cc43e8828455988b326f6a400abec2eb4bbac6956ed8d64de8395980ac984be62fd62e3b71479de2e4015416b7d9f9a7b9a27fb4377aee0173e9d9ce20853176ce44b4eb616ce8092de615a18226e0158cf3ec7612c08f7c0e510a1237612089eb716f074f3a84b7a332b79c259a2db481ef1325f547478ca1b290b10efc9150d2da6195b889ca2793824c148f8aff2146e807df441c80557267ca84211a0b76e947f3e24ffbc52629da89b7085e5ac152edbd2eb459442abaf198f095477691144ddf76fe5020562c45413d13828d113e40b009b0a5dc3e779ddece877e6287eaecf0ade8e8ccc95310a86c9bcf3d53815235e059c5038c9e5f80c5ad629d356eed4a83ca0e7e7878eb744e5d2169e21286a970d4b03ffbf2fbfa847ca821b9dfb1039d4ea7a87be1d2c27cd84886862ddf805c2edeac3fc097b504a0e8af4b50b7ea4fde58458fe00a7352e740a2ea93f4f1e13c2c45049c77f72533c9e10c3777d88de1cb3234f288712bf58bda567357cdd563b2acbc24362a6f0f4eac56066682e4e633e8fd44fb174443448e0e7df8864a18882502e95578e9e771f379f4ec477f4ea32a114890cc7c2377b433520a23d420ff3b372afec599595e7d3109aea4da9f276a36e2789eb13f5df75092c2e0087bbdf8a2467844f1d6bd3a5d3fdcabda5434a4bfdae150d17ebb3c8c4a617bc8f83fb19fe3bb73740ae2ba1890114b00f22998894f1a0ab3bd56f582b01df8e600a0f20233b3271adbc8a616ad4096d893bbd65fecb74be89aaed441d0bee5d03f4be4bd461057522fa0ca2a5a5f7c1e4f209296d7da3dfac7ff072986346abb016c2eed2045fab220487cb2678da180a38e9660e4919698e8c8fe2943e36765cd76810c0ab8346747e97866ab5fb24db0e6873bb342e962dc0135df1e4c615029c23d68888a5984f0b2cc57d2d9e2d99f5942b1cf33515cb962a9c0309620d400d590a73e0c65cfdf66a79a9907145820984fc02d29b0f757ee2c46cc0bf18a5b8119dde5ced53745408000251361c2af0556f619f3681e3770554c6020909370f82a0f7f0ecffea601524d2ceb0f368f877e920f4e0e27e3d813a7ff0c70ab8f8f1ed0cea56255348dd4ad4ad5741ebaa972f600a668f93a9e55ffe0210cd92b7fd329d28bf8848bc199485a0ca16e65fb2f81a3fdd9ab9772a4852bb19fab91b4a96848b166ae22519c169e63ca3e0faf440e97893a620a815567c4f1373ee159b8590a02e66f556ae3adfec9e30a0cb984b53136a958bd89c380abe9c88c1c1bce40fbdc1e82d94d438f3fb2acc9152e6d24425852c0c82152ef22140e1d2350168663374773f026e9e5cb1dca3ed4c2d7c2d9201c27623d1dbc29e86a1b36d110e28c8c265ec079bbfe572e4259dae23c6521590d953ab44b97dd66b3dec10320bd4ad36bbf928e9f5fafd52e3372a8f93b4ce0076a51f8687bd646d44d06e8ffd50063e873b1fda8c7cf74dcf72823d376ea35fd056fcfa47f1adcdf349547733b6cff8f10599a2f5b336fa6de4c2dab2b8e4d32b604ef9654f5b750f9a968f16451dc5bd9a6767d305ae57421446e89e668b953652a565e5046fe28351c2d653c4cd481f54a64a365e80e8d51ce69ac349beb61134997b82ed918b7a8be6fd0bc87752b5013ff2ce124d4200ef412f596b02fb9113129d450150b675d137eb0a77da22c90cc09a8ceb2bf827de3b018dec8d5bdee318a3480bcbf333be9b0b83921fac11488d9a8e855b1902e3905db3e3d87120ac77a2451c7c013a8cdf7b47a2eddccca7233e371cc2ee2797179d7f9bde2b12ddb738230f49110253da431dc4a09da830864a9e45f0b950d4dc3114bd51a5a3e5eab53f8c4bc61e3865d8f2ea7172e27e0a7327a80d644f196d1a35303c410b0c5a71c92a5c64abec98a21fb6bcedb4ca2f8e8660563b140a9fb96f1caf2a2430b6474e16df1efd65718e724eb2f8eac2c7355709c46bc53062ebaec195f31c1034328915df2a74b1dbaa33b1db45b16a3358138d52268c1dba37893c9e1173f4be7d0b0411f5cf8581d768cd97314539b12b6d3c64af08898a543b53e158196c7772b6073ba48c76207fc7104e0ce22a4521ac4e8dbd837596d4e1d84c1281a7df9ba3f543cc43d1611b54a78be977a70a44b603d358a86b123ce6919c02697848e228216342466dae5a3705fbb9fae440bd98356ef272bbfff9883121e48fedafe8cfe1c8f9a307cf72d7d2abcd2a5d2e6f791bb9d36cbe7293aede51f531f975354d5efeb2a6045784035c971a134d8eedde96c1c88c25e58a976dc62e0ce40b5b2771bf6a054889f2d5fa634f0c416e8e345f1501a9710927340ea60bbf13c7e3ec2b00a7eceb5e137a9a9520e42c14276506c618bee1debbc680aa6629f9e4c897a03b8ffb05ffbfcc7138704722e1025aefeeae8b15a79992ced10f22d8416bc1f9fae2468eee93d2b69b79b6407ab496b1239150f6a80487b46ee29d2c9695db34c790360c88cf981035763aa58059193b5a2c2d96440c2c2f35c54151440575cef4ade22769c7769c0eef9e725ef88c7a3bc12ac7dc452138dbc4b64fa1a11d0c2daeb80ef754ce81672d6f039d288aac66a3e6f9d6dbf5e6cf37372a0b36daf0aab6eb993b379856871fd56aa3fee4e09f02e394c60dadef470eafa3de4f846ee33564fe13c933c26985a3da7adb54d2336cc7c7f85ef6057d838b5d5f1cc6d7a4cab566e377eb93ac9407e8714035203820cd11fea197e1d3ec5ebb11ed89154bb062e5507dffec69218e40fa29f41d455f36dd575c29c4a2098c6dc23238ad5e530a298354e63dba0f83ca208df47ffb84626831cca9959ebaf33192ba87901878515e359c8de15f3910ec4e1a34874134de0e6b7de975ab93878a8e773180049a4803cab9c290953d93c165a75f8388edd830de29010537adc60090f726358c09dbd959d6090c750dd08e3e335e26b1f4676fc68275bd8a0ed797b43fa173ca9509778894f5535097fab4122ac135ce2aab948bd92fef2526e6c85bc9c1fd25a9d77ce38077de11a2b5bafec3554095cba93776c5f9207d0681d2174c1fa6213ebb65b28dd8a9f36be7cb3c595f69272893f1b2ed1a2c847955aee007a8687e028932d6c907531d9e8d34cea23b8204f8aca8afe0dbe4790558f2dbb555f9ef0ace7a769c91793f045162296d9d9c19a324c1fb25d5d355e60fd946a3fa979c70d6fd66365834a96c9af5eb5433bbc8330fad1189ebe7dc57868528445eb9a4e804aeac394e2b9d702bb5da722e87e8139d203cc43e436586bb93f46ae87d124d045f1d919b4a56375d4d81d66584c8a2618267135091092e91e80010043dd78b558ffc0a468ffba4f3c4cbd73455224c5a37acce6b33ad228303dbfbc241f0222dc681c9e17751fc73ed95ebe838d346470880f9dc595a8f4bf740c9f0ba7ae9a9c19224370ab4c1cd2b571e5783b08d8e871076b5488ed8d77e21638acd654b710b973cc5418a3bcbb2021dbf5d88ddaecc711e050f09f3e28d18668155afa9b1dd26f1ed11480960fc89f57470cda83813b6d1d87ce7591a685bb5649cdc47b7fbb4484cc49fdd58dfc50b5fd089e748313e3a8d4e99b6a436a372cb5e22fb52ab1b7e23d86c2b54f8039fac0455f9a66ff9a84a391725865d5f3157f612f3c205ac2e276c4c145cba4de30b9dce81a2f70fc517a8f6b66175186feb3c14e408cb5e3c9da0762034b73deff1a1759540441d6855b805eb9c9405d4bea757931fc114e59e138d0cd3324926010fb1879a9739225f8b09d043e38a56adecadadb7626011833af87e555dbef3f49e71111ef2620405502a71007d51ab0d18113cf8868c860601821de41cff959f6ec0bdf4dbcdf16d8d4726000a4f517246385affdbcb07b5e7c4acaf2c351fff430a22af245d4153182ee9f969eaaa480255d6f150843b6121ce15069590ba27e5ba2bfd988c3be0867f98a8fa2edfe23d084ad233da3fdcb462a0360d32b78333eb606ac26849a118cd4b7fbcb9905911840005cb882dbd6f7e9dbfcce5b4f86dfca118ef346070d9f170a459889fe3fc3281516872db8919b1d3b382d89190e4e6e58d368cd4594aff2d0369bbd2a81d99b0dd7761450844a96d906439b6ab7a003d3715b61583aa73514c75fffa0bf6524795e0a7dcdf82b12a84bfe854c1e0cb8c1ad6de8481fd67aa435e175cb46b78e8288f8ea379e305c502123f0d80cf3c893bbaf675320f1d1270058dad5ad2d86ed61a7f7b89e2e239ade6687a89ed1c5e55c54ce7e8e82b718536bfcb7e3f5f1004c44d55186d1c3a4d9936bb86e4cece6d2216da1fd21b83b9e517258510ee6948881f10a37cceb849abad6918958f47a94ebfc34e64b12a41ad5c73236916d8ee89bbc1d049cb15b0bc9a17055ed2fb2a790265668ef213a0900173d13e34ed857e78c8f78995ebefce7c7127b67079f5f985f489c70f03e8361a6a10eab50f27886482fa3ad72e8eb278c051300e9ef663579961865c08c5f46820dc91f9ef9eccbaa20cd5842ab3ecc324d58ae4ad37c5c1d94a77a5e69cd54028618ae1644d709130962fd918b764f085d0ee9a793d15f3f0d50212c44dcd07c77be8b4b91a5f16881f6d5899df5782eee501e17d5b22534f6c8f0f17e2dba4ce81f2b38ee464c68dc321c3d24e95b45455d038e3260529ee9c521dc29f6162b51337ecb17b8cefb6e17193d2e0bcace0d3ed423c8506c3d42e487abbc9aa7bb52a75e1f323b78946f0490cd32c99bf79ec8b6d231fe4309c7f2159841313be234bf113810e148ff5b202e266b52384150c256dc1b3ec90300024ee539543c3e5b9c5c11f91946b4eab181d273eb289751875e0f741140b590837e508e1d65f41d097773f92ecc5b906d52a3f4c26f37d1558fa70eacfb98bd85feec644e6dbf1c4ba9e54855ac5a26c7b4c535f0a0423de6fe4cb811bd4bffc819a03ac078f9869e5ce3163dbaf3295c1b1ab5cd06cf8488028ab69e7db32fb477015bc2461d80d570fc7f0d8bde2412112fba78bcc1377663fca68ff84b7082c1d4ab08f4039f9e5beff63743257dd07fa72b0bfbfd99e4a9d4977ca0b34dc30e42cbaa03b0985d231afbf5db61d7ad88d5bc3b33d51ec02465d035063874c97b6b86fe65dfd89f99a8e9dc1bf4f38438c4b5b17f0909deba64951bce03c1bdd1e5f23cf8c71166a370432fa8c43f974a72ac8b668f5e8ecdb19dbe4ad6b46b6eac74a05ee6d8c665614b365a6dfc4b7d65659b8046d6b681744197292bc99d7748b81a9b6f2103ff892306e0a13905f92e84ea3500ca52cdf6c292c294a83c4c1ca923bcff48c37fa649f6fd65ee230a4ea3f7eb826e1a9c14398faf4f0c01b56c457173b4b07a4a1f44a9949c65866d02c35d6978e361da3ffb8620eebe90a5f8fa24a8952e621549f801956a32373a8257557d17a5fd404b69f525bea632e5144e54368143f776c560aec330cb435dc953a45b6e9bd9901654b117eca0aa6fc7b2809566da8669e7d15fa17032bac2771fde06d8f201cffb4def7d165c08e911b5507982966310c107a9cbcd009d42f9fbe5da7f78882b36590223120e2bc8c372a20329a07360f2d5462de421da04870d8197610b30a8eda5e23dd63aefc3e11ded44121b882bb2a808ce2877b0bb787394be2d5044cd29008fbf8bc3d4db74093204b1da242aaaaf7e6057f0299705b15f3070f58b15b27ef2a3cfce8def834ecaa9323f5dbe20f896c39f6812fc280206913edc1d2beec37c549773377b73823b2c66ee867b03484110043687122a47b711714ce9b4649706441d953c007f86d35c4e8b940d77d76464c3034c8d4f04a26c919798cd12d3d961fbd40968870fec9ede0903e3bf839b457fdf3329a75d3a333e601bf40178591613407358de02feb03d43f8c46198fc79220e7d282ff142d12ea5da415453c237890470ceedd03dc7a77f1ae391cd1f4c476cd8703d67c0cabc8a024a91333c3c8c9af5d5be5aae1e18e903e25b00b52c01261879102b45ba6f1a6f547792cb1b9c129985ffd6ad46cea7fb713d6a5716852b406814ee8f839453d6c72a0d82edfb2cf7a2da33fddf817d0954669a71575f01cc7dd19b9fe8bbce9160f29153d273980cd5ff91d002e9023292940d94019a0e22ba66bbc6370d65609812eca052f53a4b8d58c4598449e6f7ed78bf97ba9573c893f86b8d7ed3168094ba8a2bc26818d8366ea53a7a9e0f0c72500c61857127f4985310aa9000ad793932dca06a31394d2b88c2d515a9f56efdccd9419039573d259e0d5ed7a6f83e2f51bf11eb6c69a45458b85817130f408f51effe8711899bffd1cff326c9df1866e8ffb6409ce28247798011718cbe7ddf70dba4e05f9e0509749371192f31cc260b8b9bab85f44eec1fab013ed7f5c28a23ec8222607dddf638af4342dd0d420c03f0c9eae8ad89698bde0b062c258a97c97b14d0795e4410cf0e3d8d5c2b24fbe7fdc894c8e75a88a027200b5ee9a9f12242235002b64f94364628859991a44de07b1b457444d57059724df8c74d27f19c23762fd8011236a524559460a419508442f43210cafb339b42c59399df894307fbbed51c2bc6baceb8ef2a500b02e4c5c22d6d5c8c2141cbac58ffaf6370728a41f7dbdca16509ed9a2ed145a8e5b3f84e3b7cc855afa0c579b68d55de7c6099a6fce332fe183fa7c0dc7a6da2218fb357ecfc479f73d854d3a3bca77723bbdcbc726a3385a0da9e9559e16994c9e2ec43eeb1a3107e2ea74c53161c4453bde89bd926a4942269f2adba976d3863dd12ff6b40fdfdfcdfd296db147fdfa6f219326267fa9a56117b363b2f2c7b282bd062b0258cfba2214b81f4bf665a5d061f851e7d854783ace40fa4c50a8331a8331172f9a6a0381acdb9a794d10d80013245bfa04aac1d2871f48b163084bbef649631f60efa8add079191ecdae85712c494ddf1edd87326e199348d053f76bb15a9878af0a040ffe93c2474b39fbb1cc960dd94f150b2cc50bac8d1ec9f8319aa9fc599207a71033740d7717490a5e8ea77d98b579f5e5d910e962e8a6062e7f8783eaed0b762fbf04c5df70a9012d57782ffc04be97c60a0fec5b782dc958b4cc77d22a36326357739152a9d1c79e43249634b11f6886ba9b884a95dacc8c4d762d2c5e46d42dafc65ac5c4dcb37b6a111782a7464ec025966052d2f4b334842f764207018e0f7de27ac4e31ba01bc8062e2b50224294c37514c0099153965f006d4f65bacf4c0698bf9133a01172f90ddeaa7bab3706d6d8140170c08fad562a4f4ed1a17cc799a1aa21faef7ed5ab15c200f9842a0700381fdcad2880adc48703df9ad22908b4f5272ee805458d9f94cb97deae2556267644c3be11f7bd53ee900ba48cd028070c5670d393c4580572f21cf68c9c7c8068ed2a44847eb9c4f5804eca5021dee1fa1906c648f4390832158eb9a2605a5b5c3452a32371e17610e9bf4c177120df1025075a68b8c0b071e055a2c1016d44526410b36915d16f4b0cfa01a4774aff4e314af6c083409e9f2eb2e04fa426352a1bbba55a977eea3cd38af8c8708fb74088f9e39431c190033f9f3b4fff41d9bf7239f4142e2aa811b2d8f9c20d8e23387131d4a195c9199b5f01d36f2fc53ba035262c79f93d076dab66ac4a9700a12f45048b79f3ec7e93e55ed7c33c19a33759a22a8d437c8471fe4c39573434cb876358cc55b886bc2c9fc7d3d303edccea8f033e0dc28cbdd49ea197057f753cc95d0ac9dff400ca0069cea657d250477add2ce620b27166847dd6183100c69d2af881e486f3a8d587e9253b7ee790b63c3b9942feef08c36a96448ed00855679c6d6f3256d590b8c55abeca6375a691e0238e09bf54b02389f17b231687493faa46bd610ff612e23d8816f686318754e00348ff2686693a86d19d5c98b0bf6e39b1c258874cb5aac9c2e16434e4c9a967f4122f0c31c909d758026f788692ba80083bc43690b11d180500424dee15d81acd74eeb669f907a5c8511fc5fed47cdd7957c3bd8be9967ee889599e688ee1804030156d9ee39bd585d7c27673ce5c2e94f229de63e74253009d51c1a895e6d5eabc6c546ab79e4baa7b418de0b8813dffbcbab7dfdecceed6226a6bf3ec46507e2629259b7a9e8b260a803ba31cf9b993d8385b5d0a85b8bb942b806a0dd0619ff82c5e51646ab76dd183f590a35b121d76743f387441cc3521ee8e001f43b392e399b5ca1a520908cf01bfc487a8506f21ff47812947ff94ded1ffa0daa75b9d1774b061bd9267d6e78f350627c0ea2355e48937226a04d4da92d0c0ba1188c24459183fddccb3b1b86a3324ce001ace141deec498a2dbf55e90ac1b49858c78231792223c73ba79b906f85e089665870e36af36ba42c4b4f669ce3e8e4e902602ad8b318892f3cc9682a273cb1948244b7506728f8addededc7104a7dc0a713d34c75fc705124b115e677707405e0ceef1d214b6ce852ab985726ed68994d12f151128feaf0b21611ef5e1b4014c4bb324fdfa021dc74c7325812a528951d2e09db958c25b29cadbfb4a50a5bb6533adf85b78565241421eda138063d939d3b84bb6efbc815b039187ba5d0e44934075e1c2379c6e240f337b441d202377b7f5e8f982105860b0f2152a20a6d23156fe22b1b15f2192f5295c37dd9fe9b55f7039898f02ec2a5301d999bd6f6cb8411d1e9535b18bb6df65fcca41da00f5ef9769130ce7a5e5c494676b783e5131b1f1d2b67c1c5d6f58424bc410af522bf2c06d1094588162eec1202e6cb657356075e4f7f584844707b704664d0b734659b1481c6c8959e0c915eace485bdca44577ccd981279e1def996992495ca0e9e543ee54139c12f095353e4ad7e9658b46111e839988c4a11cafce8c2ac3bc85cd2973d0467ca4810923624b5df98079fb0663b3346566b28197ca9a25387c115486411d16d47c637a0bd8f0ae0020208a0160787fe0d30c504beffe96f1377c252ec04611cb5c6a26ad9de3a880293c9f6fa1f2bf5b44c4bd1be1bc6a41a882d1ed9a1768edc89697542045582afb3954170f75fcfcd40681d169b4e0d8fc2e72e69e0a9d76c1aeb2c30295cf8ef5757e49741b2e8c6cb62369d13af3084542a01b2faa1d3f235e00a648f27d1492ef3fd2b5ddb6e464e673362f5e037f4f3cb8c7e33a073f105e4c9b7e147c5b9c4bb6494ebc989c005e5d3f9bcef0631050eaecaddab3b4ba1e8cb6b8b8cc3ea66fa495fb7357b7a69c561bfb3c0623eff8a36290dad6cbce76fb54bcd1cff26d0c373de7136456fc69a3a1003e24bd594314688094fcafa3d04b2c143adaa8a63afdc84ca917e0c0a82314379874be9356854f9da6433e95ce7c91c554efde571cedd997f40d07396ca333460a7a4dbe8184948040658b4f35c80452a8848435aecaf60f4ec3a44c67726f814402f57dc62cb65ae9743aa58947af569f0d0ed4cdf2246af48fccd35d3e804bee10817c4a70e1223cdee02a8b6992c6120452af332eaede201cddcfc25e0e818cb8e541f8420534336cf02c4710a71b341878f33fde5df67300ecfe8e82ca18edec256f212aff6b625b385d52c24a241ebd5de583be8e6c7b42a2ac3278c837d58f0cc90a00f79622c76eb3b6dac0b81bbdfd07fb0ebc0db53f3d72613cf9593b088bc88a472fd2b54c094a2509c0e57cf1ba3c3b0d915b2c8f010e37cab24b9c85f9947a4ed3dfedaac33ad16b036e5d62154b9745b5a8c2244335fb5f0b65a1a8d9f5768e04c2452c5fee2adfb3a7ccb0c7a38bed9ab285a56d27793ce839542fb709cae222776c2439e94a669bb290a064386b2b8a149941914cf982b2498221abaeaba56a587ef349dbb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
