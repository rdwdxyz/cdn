<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9b6640b7e12a7cd79135641da3f254ca01500715ba55b89d2dbfb47d017b27c6b95fe4b7a679a89f901c010274d7049e25d3579f829d6f6c7d70a85635da66ace8623c17d277983c78de2adf082902b7f23f61af2e775d99d5377e91476c263430fc7558b9860762bcb332409e6a28cf0d1ab20d18d49a2237d91c4e90e70acd4e81daba6338771dc9b9e24d6908f586a6fc98c094ff2a33046cc0f44093c11ef1fb7ada187cc9966032c8c7dba6ab4528b3471e3a1287f44dc4588744d6af34d48059f019f70a0a2d22913115d41f0a7be2a245883bb31d8489d64211ce0af34227ac3f7ddf6b981c19fc95352e3a5eeb219ea6830ba800e1722fc657813836db9ac3830366968e5020a577c745eeeb999e62852f539ccba9aa178392cd7d07f5510245dec12614ef0c8a5dcb5669330772e3faff1529e22fbfa81d550fe4993a9d875146529e0f2eb4daa2066bd2ecc6fd1e0b6c176d322ddbe5b2ae09bd2ff2f70062a927f788cfd01412dc1a8a0565a12dc917a94516bd188b220097cd372f277328811b35f9b77c356b02403d0dd6210d48c9bbd69ffdd86d0f7d7897f827c09b8f5fa8a69d23d3d0af5a0c603b4b2eb607dd24cb0f9f0e1538de2a99027ed963e577172fec7be86585378d93e7b33160fdaad43b148cb474175d3c5d688f7e38c85a2f7fc98837bd6bd6c8cf7b6a60b79711b5452360a8ae2df509a3ea82514a4cb0eaf6d878c163adf182155474b2a027aaad4056ddd2dc4cbfac23652d2ccc921006af9b49337b11dbd56fa5c943a58f2a798a200cb6c21a9d0f411b008785f9036d4a9acdf6e7d797ddb257cdba256af8660ddc10a87b01e0039b607ad28adec57538275df14deb97e849c368c76182dc6d7167f3d50f56381cb7cc19f57bafe3079944d4a7d3c93464e982826e924d85e37cdd93374179582ab2c1ad913746dedb6bdd9f085f0af02ba1dca04717fc2f8cf08f56a15d27ee3766d6dc9387906ccc8506752b399ad7498651112380866c2d184cf17bb2f1d3f98c2f624f981ce0ee3c7ade7420fb2db67f0d90da2cd424123b33a81f6ebe2f5bba66cefe1586904ca20ae8aea78764f34573986faccfd5edf435790a3b9aabcaa98a8ed7af43f25cbdf6acbe61bb8d319df357fe7877340e63daa00e46e86435af751c3065ed8fb861d46771656c230d6f06910b5d1ab3c110d7f41aa3bd8a6b6e4fc4cbc074c1c12ecf478362e8265e94a3a95b6c066bcc38e596328198af2a81c5493ca82b3726fe39808a01c99a343799ef5ab4dd2b7daba9fa13ed81420f6226824739465e64efb14a729c8a58177cf3c664cb7f73b7e534b9fc11a11d65454debbc9629d0470137a504b0e6dec1d16455fcb8af49c5075c5a8af66e7bb53a49d97a5b147cf5e43c5de661a2ed27e0d245fd9c81c7e470e5a83de18fdb1736b17488f1f72a6741c1b899422c95e09864dd5c90fa75f3da37013a398fcf8dfade25836633c74b6c1ba4fe7d5be728651ea2968959eb55d9cfa79eb0f4ff82f50dd1f690bf61dc9a18689fb3f2bc3fff90eb40ff41d5f2994d5beb3c7efb3fa4adf96c9c9c57579bcef64ebe791838c6b52fa55d7aa7f816392b6099ca432c82d5c727e04864804e20417f6fa039cc38ff6c7df99c34555422d9b99af3e0d332e543538a8e423560f232b30ef39ea816da77d0079a602c473367581b2213e6950e6890695bd289a2ca3bc02ff8193395e8095662da492c5bb338f433c5d21342e749c4ecd801da72b030cef8fbdf67c13f8aa296dd4bbf1ff22c72a0205442218b87b3d2403578ccec86311d03d4f0afa6b70806054e377aa71dc551666613fa41bf95122a9cfa1b18b6579d43de27434a5526dccf3b3a3a0e341d95847515cf5a594eb2acc515481b5d0bdc279878b20d574450bbe7e5659aeaf15da8047dbb0f3751350965637ecfe95f61777505537bfd9738978df41d708a6861d60e0aa196766c08c6a5c5fdd9ec195d36afa85a40ff66ab0ab92e4c4d28188f0e54ced39f7cb031a55b095b041663a8662a20ffd8edd671bfacd70882186d0c1ba78e6352899e8f1c0d35211508377e220a00b5194e17e8933a30e8e93b0b5358ce1634e4570d4c8caec46e9428810203b16c4341eddd12be94e0612d5088e09d70ef5aeffa53b80a691d6e822493ff14be912c407596fd19f97d383b2c793c8b49d71d8a4a22e35a323400f8dc1cfc3a383cae639bc05c1e1cd4ec72f78dd749032bc2d06e591a82f024407ea5db8f70044a5085fce1d6be96f8939d52df4ad468ccd90a914bb5a72e3bf72344b69c333bb88bb7331430e743295bfc9c91ef31e9f3dc0c1b984f9a68f56439c592cd8355c1ce44d9f8949de14c99da09dd0c16dac8861093cb7c267a5273a64ed57c539a4bddcc80a24ceddf390a2bce6c15758ce2baf715636fcca53eccb74c5b1caceb4f22cf12ef1550048017fc00e7bf1b28b47146f536ea66f592fc634f861d3e0a2f878d3c2b47d1a5b96b653a421d2de7c3f7a4cfe3e14b1c0c2a3293fd8b4118da4aa2d80021a827e8999cbb86f55464ef61e4da7a482b0970a082aceaa6fd5eb31b7c78197099ac893f071563eaaa18f6a6fb0e9922ab962d726345b75828d4e44307b23faf03c950e6204e50bb1e8d8fbfd5c614b7b3ba8089819b640afb628fdd624690c3503e4cea19468527d8cb8fb6dfccbd64edf32d21baf21524958b1cc1a05ca27a8e725b2e1c217b31222dc174640449113dc34ab32a38f8395111dcdfa8c69200b35451518eef1fd3579f701871af4fa15346e84b6bf668b27d2e812df6a0ae820d2cc33ee28664686ad3ac367f513df136a363180b2ad833b358d8c7ee8f5c9d720684d15f57a783bcb7ca124f9e6d8aa65dd8879090a7c0cf0cab8d77cc33a147bae91ffc4822fcf7daa95972fc87facccc2a15e6ea782c2be8407a61fa12f49e15f576db6fc1c4fb84c894cce6e9da0bd8a40c9bf240b24ee452d6c8bca889e9848a151419256b18bd3d21cadb41285e6120070cffe11a694e6e7d008b7c469b2e9fe063c71d724602c0ca5459766935d647780a87213734180d6fd5aa8d9e9e8d9142d24d7f44db9df05587cfb99e4b3d6f1c0fc482f2cb2186dd116f504fccae165091af7b9193373811c046b5b49693066ababe9e412a926beb55dde686f8eeade945f63e83e478864d359b53ee893d0435c45b3683275456c1710d10ecc485bdde63f5d84d5bdd595f57ec4dce8e57e5209f76eeb40f241ca41bd50759872a912608aaf62745aa71a293d968081b202587086b5adfa295115b0cc24f8f686159e25d5f0de08cd4ff1684220be2ff0b87fd181534954d369faccba46711beafa7dbf2a18209c632934e0c4ef25a1588a02151e14a6525aef28c68a7a3c1b657304d273f59d583db07614467961ecbb22d3c413c3e9136442ea25bb07feb0146a05f6e2c602d850a79f617a7bba9f77203f5b723a9da151e3ee3b6bfc276e97d4b49127253626a18caa20657addde18877ec081194494afd0f1902483c1f87f6f32d0980f79766518df3edf8cabdc1ae640073775774fe4200c7cfac789ba6cfc86726c8adfb3052a3713af694f72e6b51103f39e3fa147ced7baf96e512a4e1272c74fd24d95cdfe25a1d27fbfe2553c152781e4c21765de320baead4f57071b9bd21715a8fe5f22f4e6dcef7a2a6c60fd05e1c05f38ff9f967af830477fce7e684d0e6233ac46fff76d9202829d913a16128e16872017e9a36c98fec143d457fa07d340eefefc362959e118dfb8353293737674d2288e77275f7c5cfac771c720d028178daab7f0a3bf73c02c6dbf3c9ad4899354ab4a95c192dcef01bbab73d1398e403aafdd16034e242094c3164162a693f341c3a544885178f51912b3ba27345db0825825df1e73a2094719c73ae172d8e00fe6acf1e90e04d1b5911da20ad3c0c56089be2c8fb7e40b7590e07eafa2982859f8e9b74c94528c2e1a112052f8b1b4b205d32e645e411e0a713e232a5c4839b07f1e4e39f054dfddc3b3eaca3e598ebc6cf423e2ce729766ee873be6aad96e22bc51d6b6625259a9cc3b8c7899d761c60aaeac50b0aa2316866b0ac2c7091188a0ffc58b70080229cff453a96428fbf3ffdcdc535b118e8f44585e9097c6ddb221862b1c5e025969d90bbaf46f009e10ca568379fc8c67100a2bff6a8fce3f58d155b43005ba7eaf12fc0449651b13f8993d4e017715a399fa80954a0a7ec3ead7d811607c1e5e8ebdb68dd133ac4b0c43aa3a9d30878f599c4484553b8b0ca1b83c06b4eda5d4f16d5c25bc950f7bcdad73ea6c7e5878cee3f8ab660ba381a8e47b8f9dab8b5c0ec6bc8da560cbadcaa3cd1979fcf3721f1c1d8c0b8c8d29bba8f1b57b2798efa8a475e10e87f497c9a170a158c714adafa634ef610964c0e6e8fb39622633e0fec923f6e21ce9852f094d57546925aeca68fece993f66aaa19594dc5a2a17cee0f8cf094905fad353218b0389a7550a7c11dfd9f8576688ee32995c5f13195b8d3a808aaba43b05c418da7a9a2b554687559e031ae10f08dce093d9fd2116e5c958b4637bf2062114244415a7419c2eb5389b8e63229efad50dcd9172caf06214c5662529c367d5f37374cabfeb5df13ae38ea6eaf50b6653a03b98db27ea89091bd5f0aebeb98881795be2986aafea90c8144a3e2d7c2f3cc49dab7f28728445673710e46290347f410d9360412aa2504ec897cbff7bbd64c7721c57e58c981107a3a351d5b97b1f053448ffc2251bf4b880bde7bb57b351f38e5741e9b8c0210c2aa2167d04308d41c6c58fe3ce7bece8c792876018621a9fe2540e49fcd57a1c945878d154790344465718627cde7889de46de8c3ca67898640e49ffb2a342eda26b666ed602f12c57dd0c08403052666f280a8e8cf769c6d3928a9100a3e7c9ad038dd5b58055306082498705d991eb2659063a1d4a20cd5c2aa415ee21aa9f0f3e802b3d8f0e6f29cf58960af77833548680a2a477a16e4e4b6b8c5ea4808d3aa03f690b6409985e46f8ed373b6e0d8d96cd71b114c0eb960ce7f4e5af14e56331c855cbbc2af2ece7e19e6b372226f4e377edb3220b95a10035fca9d063ede308ad91a5b4707eb8e99ae1be51b74ced892d4328bba03d4e1de4b3bf2ad303d91f889861b4ba571460dcef9f08385a857ce11166af147d30557fb778867d7227b9659fcd4f947002f4df7b4a673b76f74ddf2f04c54f1c6bbd4d757c2e838b2cdeb8718abb75d9ab462717d2ad53f47a8534d2e773cb60afcc98f27187aa4c77e4e779bb5701ed687c4458d2ee2ef18b252eb259e8d43ec74c08a79039aac358eacb6096a45b0650662a17ab8b9506af0e236be0ec8f59f8e25c602fefbaf93c52b58a8966cfda445dfa3353327e1709072ca22360d7b56788f4c29ac6792e45f48990202bc5ac8cd778cf8ad88275aa61902221db29878ba92e4babf0e3b2d6f30a1d4b4d0fe4197967a0b23233a8ef13ee74c6a4d93cf63ce407f0c01ecf4ea31c30a12c62d114589ce6ba093f9b2ffd3ea16c4b169b9226a9b37e46b4efdf4f14da936b56f5bb9a2bf3d5f23c3d2f717cbe770117461f1bfcccaccfd6ef9114cbd4a22385945856771b451251946c308c4aa9f2975584b04ab67e43c2e0076eb00d12046f3e93f6f4c8862998688127acae4ffac62a0cc3cfba61cce0402bff07040d1d3457cdf6606da4511910dd6a20522a2dea870b09db287101e7319cf0c453913ab674d3c875ccc98b6cbce002bd7844197bb94336a2f258420d307b1ef5ebc91f3418f1dabec80476b8afdcad7603e82fffdb2e86dac77986958d63bda883e32654de3acfa36625678ecd8d94480e587276d823f9887987bcabe76db9cc2ed2f8a97465e828a89744d2b45b1d735d8c80a2d046535d16d4395c042daa58a2a066b152472e50c74ea5c0627c0350faa7885b2303aaff720aaa4cd013005a9b3f89e0f6620bc85b45b6b12e1b6d15df70a1937e6213f5829c24f84e81480bcdea3f0f63f3e76d23956d6a8262a70d3bd6314e96f7fb36c353c918204ce5ab6ef3f5fd87761c0971613809018c7ad9ffdedb5e80f234ab0a862261b362428ec2f67f1ec3baab99b50e44c70664c4b94ac521addf3c7d261dd1c49b107c6366f1b89280f8555deb03c2785b3380bcf66ced28e350efe23518ea6d11f588b37479525fa630c5c4943779423bc1b1a6e7200f84541d25579cf17973fcd1f30eb2b755763745e582837a5b2ebd4a83bc8eb83e58bc57f24a9b0fd07509277a9ec104d964837fa91e66373096db406f6dbaf765880c9c928f16a41987c9ed19076ca5fac780fc213a77c9f0e5eaec9eb50915fb15ffdd1df368ce0704fcc73c9824cbb918c5a4ee83c82f4fa4172de56d81696e566e0f197f78266de193f9ae4d0f5cd5c5eddef1a1257dd32f870ac37b7b64e6c83d19fd1a6daae78d436aab1ae97b775056c91d4bb10242af727ab422440c93e0f924aebf1d39a489a0c33e7770594d0fb960ed77dca60af052939b68c3e0fc35d631e40037b32df8702d30e762d712c6dbd63335aaa15eb64c004691cecc8dd8d06df0bdca9c68254e9a6c3a207e3edde73164d2896f1e0d0a8f1964f78acba4b001cc21bbdb0d783247f4cb9e4e58a5f1a83bfcbeb581854f052cf9d65bdceb68ff434f2c54b4a9efbdd55736fcd38ca51c71aecc254cfe1da1c5c9240a47005275ac0246866f952dac05ead59688760d8eaa5f86bb5cc4c6faa52afa4831e6d6235a5d962d93a6f4a81cccfba23c9b858236e0259e380dac6eab1ffc0a2c5f687d478bbd8bea8729cede7f78efff9c181af4e0d1fd7eea6a97f96b78201e28508c2e49105e2269841b86ecdcc50dcfc16c0c598806710913d06231dfe2653aeb74902e79d6257ea25694a48e6d619d2ef0a349ee521ed29c316f8e4b261f753ad8e32e1b458ba5d9d4af390523c00aac067e2e28969baaa5b4d232fdc567d5abbe407699854d179c2750782e3fc23d26c111434689b7af44cf1bde8c6450131be48298416a4ea7a2731311260b9e519ceb549a5ea9507ad05eea0c0d6000b84a3929ea8288be56eb29948f2b3991778f11a2bb91590d51b57e8c25d78785dc58f127b929bfe0384e42e52952a56ffe8608374eb1d13dc5a3d3ba3db25eb125136de90034ba75989bd442e7142024b257d78ec977edad6707056b4bd721c534209a5692df8632bbb6348f648f812d03c22784224d247c735c0ee294975837dcfecf1857ba3eca7f29c16e739e988c0aa06ee785aec657bf6cb703b48867d208071202ec4ae61f2e90d4d47290d7f3d98b9ee9771b3d3cb0ae3f7b785878efe44d00d7c26b44487dd469db500ffb260bceb2902f11bcfb16e14c440a60b21761a6e5245ccc96102ecfc15a19b5e3a75a05f7737ed9ef4f461fbbb8bf44942fea514c2c6dd6cf9c75069d9389efc40cb6184b664e061446e9d5e70f43c5a6cc5d3c9b44ec505f5452e9eee40385aea94be3d1c6a4c8992860e4313edd9fafca8a2fe7dcd9e9f46a342cd1298b8a15f68f0a4d72cb118e943f1db22f2b849aaec254c125d560e2ee40da537d599aec00cd3796a8f13aa8ebe22f9beaac379e2336f44b87134aaec43edf0768c39d6713ab1e14428497960bbe495a9e06bdda182dda3a7d147f450cfd676bfc356cb06fa50ae870f0235897261483c6d0e82c3f885dfe0fce2059ec28c4c9fceaf3f48e9a7a8ad0bf5d8660b6a4e77b1c00d5221eb1d187628380c892b9540bde78f8b432a90016f828726df57f0440e9260145f94287fd14b5477dc5f827a557256556ada8f4d87e126588b1de5cafef558eadaaf62a75a685473f168c226e53f5a51d1d97a62cd3b5dd579eb3476a009a4a830fa7dc4ae9b7f4eb4db7bf9b9133e088b16b6c813eab807401c70948a669d5788812fc6deffe127e3093a8c4c5468e3180f958a5a5fb635392a15d7be88fa0914f5e9e3cb54e1c979ab23c561614e5c7c215dc242d059b086f65bf0fe2ff9b4fd45c4698aeb81e3ee15dce81f45e4b539b7b1cf46610508b75066f1f8040203f9aff9e44c0a8edcf576d230a17a32c60d3ed17cb2e9e86c5523da4734a0b183407316fdd6ef2cda3426d9484194379f9ae35d1e59a5d1503cc8d9c2cd9344ba19391cbaa912f6728f3e89d6460a5fc295d80f368f14986d13520ab51e82cdbeee1b6d30c62c70f7692ffeb16ffae02b2531d8befceaaa0aea986a22453dfb8e255d6ba59c4e8754d792fa20f76b6b9cfab09d549e31d894bbe7a9bbd439e02e625441b55700aac87ba2aab392ce891e9cf624fcb74fce0f936569d84885ce8f52c3bd343f12b18a7aadae0bdb4e279bd9e4b8b68ed68c2566a3ebab0ebbd1bdd2655133212587e263787c33c467478ff07becb504a1cd588b5a4bc6aec70b2f7c6035aa89588d98acfae2cf41e3de296f6122f2b4702a6f227d4e1505e5b060e46fc6b4715bd9f5378a1d6781ad45466b22070e9e6bcd9f5955349c12fcb7ed041908fad69d08a9d8c3b1135fb818ea8ab64f426139454c1bbdca2b93b956b8f02efd56c76a7f3d23a0e043e39816c6e3db11f3a15a5ccba706e210cc113f8c86f9f1752520508e21860f32910d9afdda2f6b482eefceb2828304a73a2ceb6bf4b80265451a9048e9aa8aca1ace469e73584e6115268ac9a14709bd6e4ebde655c09f11db9454480ac77bd5b718c863b79a90623663a3ba9d3d1e55c886d59bffc443e39800e6658760ac2ce2f8bff6d436e4ed94217ea6eac43cc3c4e05e983bd91d36ef11e2f8eeea8220179ba7e1be7fcf368fe9ec6d7a95430025c520d723e77fc32f3a31ae9db2139a3b74b9175c64208ec7c278c8a9b8db14a8ab563ae2a27e8f6d4fbcce67340c79b04c18624d56497e3760d00e341f0d74249f534bb88bda5275cc1cf9f4aebbbe3c1a4651e088f80dd14c9976b4912b82fc3c7a0983f13dfc584962dd6495f7a38f7a29d5b74347cd48cab0c398a1ae1567687c81007cf14098e61cf9b57b82baacfddaf0e42ea51c0ae8f42b8f5e8bc266a2abccf2b2052b3aad2dc4bee8e199f756d65b679f1df8d38aefeac2838a4d2ada81444fed935cd04c21c2792e681d44dae1334b180b0845d1a99958ec140c243b24f170eca28ead5cf5391221c86127b5a880f8fc3735c0e75cd0a08280b30f9554b42912419ddf44c1237c58ec3832b71e635a7d6637d78c2ad8a9f33a66de565bc31db049fca0a9b147e83400f2980a1019b18c38319b71b71b5a202c33b99fe3bd1939337fc88b2b3317e2f7fb069978abd7813037ab63ae4e349ebeaf12a513f6cc2562faf90944a37a3ce6ad472e11a8370ee2a8a9b2fb94823ac9d504e0e8d1f30826644965b61f77cd274acad7bd63d1bea9baeb34bf2af64434fffa96f342b0cc05a78c0318b4f0f160e718682037c548688ad43026eec885cd0331ec8e6b38903c2f41b2e901a4fb7f55a456674035c342b9ed11506877f5e8bc636a9221e2ff975a1991ecca8a682afb406a66af8872cd15c80aeafb152e3b127c24faf67379483d28d0a94d6583ace1b0c2456a334ef1027fbd790314a14dddb8489f17743b12e8ffa88d3282802ae65fa95f3cc7399d4facbb20c48aea0ba03750e4b112f969633fdb2ea713aa78c04bcf568fcf4e7c04b8cb6ffb13ce1caf16d2feba3af10268396c5051226f585c306a9ed86a84812acfa2aebaec72b0d1d8afe35bf97162628b41dfb3f26db5fd44ce012f911f165ee02c23db470ac2a689dab29de188e19f6a162958ce361dacb2f16216520d6fb33faefa508fab40b122d7fa5ece71235106399c4e2beb70d0b153f04e8db739124a2ab532db2cb1525cc621c299dd686452bf59da29b6b11a5fd68e8d8a415f5e3ac917bcc5c509d44b98e749a5c127432579cdd4407cf9298b49844bd002b92690e0f71e355772089daf75e8fcb48a0971ba2e030dcb49f0a3b1ae0fd7361ba37c1e0398929770e5e05bf8a2dff76787779279012af2a5bf2389fcbf144a8cf334a1ed5561fea3f60f2485357974c537d474e7a2719e9c5241a4005b2dec07bdfc5869ab86d597a8d1fa8f7c16eaeefc8cc189aa68ae12a4e9c2b03a8c549cced27ae159b2dd27e9270e631e3800592def44b86dbea8288677876a49e4acadb117da9f383f6c28bcefe8069eac5c195ef1211dc2992634378148bea525724df1b2592d731f0d8347c7f716acd92a20a917eb81bff0894608510b8fdd89da5cc59886cd3fceaf5e53819f83f80c31ceb74d2287dbe34fa6aa0d899481fb047fa747b177c69571bf7f80a078db9a139a2982c9bd76a534ce3774a5de96b0e24702dac3df86ee62fd558cfb95862d6bec5cc751ea5a8c7f1dd5507fdeaaca3864dce8c8930565576a4d9c6c7593d493fc77725385b69ad98d21d57f6c754aef73edf8791308f5543f1590362a729bc0a9b18abf4b1999b84d4a9b3290c5e99fdb3f1b86a7a8de3cb14e4d1426f97ae4348f965016708bb740c5e28a96c7fcdbdd85d75eff8fea5d11238281588fc3be30b2e04d5daf8177c12844b0ae63b7d31d27a24511c00dc5c3880f3368253d50eee671bca873edf771443a4f32fbdf6ee70b8de10b443e0d5496e082397b614081b797f5268b3325df74b8d09281c2511ce9598159bb1afbe5babd52466a1a361833b798c9354bfc9bff5db1c5ddabb96c282a55a2655aeddf2bf0b12089de15e1905e628bcc8bbd1535d3559b595bb8278de5e1a4a0cd3560a4410099de9290f0c0e3b0e3a285b0142831454227c45290082c920e64a64e1579899d6341aa23200557898595708c780bdb043db218938a5b64f46029a81e8d3b51d6df1cbc3fe8f3b720faf4459aafa76f547acce03f28908a74110791d551eced504c57c420a4d86430c8c1642a3502b81fe6345ad7a894aa5d0109bd2956fb84009e92d80b2107e6475747e5c351e40f5e99c4f414d8618a7e2aca3bb0ab479da41e861bd79fcf95a483adfd181592e0a788b04b3a8a0cefe099f709860d9b76ab505db47fbd582601f35f2caaedb1bf07f733efd9ca70fc4094f89b8d8997164e81b9e783ae23c2578d25d7b78dd6c5a388d688534c17e71f8a63503e117b66fb256d7381a29e734eb6d8d323406040318c7311e10c52083d7ecefb304de7d96695fdca51b4e72f56bbf5b7b497232d3878788e59e07cc9a5bee1c1559569c951a95c0ddd84648165fe7f8f8de69b8db644c47107783ba478a9c62a01f717f375ebe6a26b4ee73eb80cf1a87688577295c997cd7961deec5f397ea16b4d229d37ce322fa45a624cf8440d15b2363179f1b2ca02082c1062a8733df54872eba28cdbff44b1885f4fcc1811c761150f6feabad0480c21cd8e91649c38499e995e8e436ac5d44f6128267e09d31ad9e2865393a61734d81d8e9c0ccfb7b205747824cf123730bd37768416e1e36e33f5bbdb5eb5005b6137af4d9985a28f736ccb1a1429ada58b8ef700096afd1106c43a9df370529706e2b5fb8cfacc9549943832170acd1f9349409f69e07ca6333b3e29aa18e570491ea76df6ef7bca3feafa0c0502e011dbb1460604943299fb0748fa026725bb545f119d5eec69683e76d7dd34a0a0b047e57a8237f5601d06b53a0dc0a155f27f885aef2642ed1087985cd27584bd8bbe41941fdca26adf6a11e1fc09164b2a2b61f05df2e6f8e5024f12bdaf4c27f0282440ffde38712196d5d0d9be3740edd0b41274420a9d20dacd0c69ff520534399343df3ace9c7de86a624d992a44b1243f2ab336f453e6e849f094c94ba7f308982417d89aabd1325ce14ada489f7574617f029bde4b29e96d09dc55e4024756bcf5af018e531a8d275630cd36eca8fc29b4c4e2b1cf8184acb860ea099741bfcb7fb023d0a3e4188fe513994f64a94a5853dd73324dd4aeb78393b4f20acf6e95506023ecdf4807034c34b06504928d5f5ad8eb86747ff79442ad0844aeca87e77c3b8e3acd4158c0920440098dfce4720c137da2c8914bc89c2f09a2878a00665566221b4d8db92e0ecbfa63773d2d77ca3beea6d160744194edc82f092b3a8a77dee9a81119c151b95cdbd4a73d04c32c95b549a5bb2eec5ec3ead49665a1670c1723eb16846d1034e865c71d61e11d0bb14d68242ecf64d229e88dce9d7483b02091a6b9bf7ded7e654134245c35c4501da795ba8d390644e6404b81514c232734bcc58088cd7ec214e0cf05290f0891b9653627faae5a88d20489d301e2ffead9cfa696f1af7a1162e3381411cf1324d5e2f0e6146edf56ff0013a42fdd0af4c359466a7597bbc579dbcf9686f441709311348ea92a62c06fdd07d4806f7875b2364eb8537732f69dc59fec02c79020dc2a80faacdd8bec9479ae46685ebda4e412e202769a19d49b353e6546d53fec58131dad660e5a6d7edc7fb09b8d8f47e097f3e459d664094fb531cc8f69b80d8c31ad9a97beb06ff3d9ad8c3a9f4f8f6fa3f3d49e525dda3752e5e1de25522ec824d6b5e912e70b894e03458b28627323f4a9a115fc68ce705ec34de35dab79a6024c3f18f1e1c7cd5605ca2e652bfe28a12fd5a1b6eb78c5edcf3dc3b0a538e81b43a5bdae8ed6500597feb60919b15a8296056257682f3851fa309379b02b3d20e8057f1e2c304a35ac482afd9b6b4f2cd317ca26e67f6dab421fb9bd355c217c6f1f2446bb47250f97dc24b1f0fd704efe0a9583e0b07c4cb6287303fb3ced2ad692855c1e34bb27e3a88b7ea1c6f1600846c08d23089ac14e0603bf3cdb354aaff97e8d5baf4ef003f47c61f45f524ae1f87b35e2981b8a8fb2ad9a02bb2aa9d0c549461623c293be353fc1ca50e7be9dd0c3953948efd1c1addfd7a7cdbb7773fe1bdb0d83b516bc098a4c8a1189509761b5563f536d2d4d717380ce6c404350c28763dd4ca10d4422c62e830036fa7b50d067a761801fe67c563193a8fb6b9bc9c985bf0aa84529c96f7c69c85284a5b597a9737e7edc6c08d6df0a1b815b9f60bd4e2006ed3b88c11e9262fc02f3cedeaff44c00c7638e9a106af18a617aa5ec00de944d0ba769b7133dfe94698dcd0d6f298d27f44a9c89b0a8a708646a83a603d1e530f2e5addb9d3cc954c551850696ab7a1099c1808013028ecfdebf0b423a9d4111a967b894356e582b4a75e0320a22d7a88a2237c429d0449f10e887f9277ea19005d75e404c222ed0fbd14d68353c97876a83650eb7cb12c813196fc19d7acda07e5f14940fba360212e1acf616dacb9fc4852a22bdf8899268c6c75f9249d92b1ece379643a08f9433b28695e38e03a37850ce94cc6c1d0d07d69c0fc7b0a317a914770606d1d295fa13882602387a57d3985a19f477f61f141cd82202e2b62055d0d4f6f5cea3ac008568ee2e6caf222775de9fc4ce830671aa4ffe15dfc823fce30136ef888cb6ae90b2232115a005f7734266fe1bb2faf942d13977ce1d01b387559346fcf1b255d41d54cbbe77a4bca99ae68d4a151df2006b3659a4febf210da28eb034ad7005b9a0c739f3cfede068fe5040d429e23a7c87d7605334281e5a3f2a3e8c2ad264c68c0861bf8cb3255b951d66521656a2bd49b0264586a7b3f76dae8c4f2460d556b2c8dee0997b9741a9237a5ed30f8b8ed260e634439d132efdf4329eefeba43ff7d91dd68f4c70a2518f4fa482132a158d32ef763c2ec295601fd1f7fbbccc590e983d9fb13d4dff7902d7bf6e2e5fe83569bbfa5efacdae58fa82529373b5cb03d6d6185133f6343cac19b610524e47aa48ccfbdb9931abca5dae299c065ddb681c1a4d7a534fb294cc836a9049915c5250cccd2459473312c07efbeb5954b9304cb74a58168fbf68ea07fbd1b25dce0eac9161aa6b58daa88a326c9332afdb93ddc0bdd1e9c3b316d39249b230447135dfd9e7b0bf031d4be1f61f9fe7ebb888aae08fa425ae4ee5df8cf60cae5d6eec9904d9fd80633604e2a2ff3426b3d12d8f7869e0dfbfecc3a22e94da653db2b09c3bc7010671f22057c2104810b758055d0ff84ab08a836577774e8cc5fd2f63733b4b6339448762a4ba90c235ae129e146414d107381a2f9b34219e2def1f42c7758017e1da6f5c896163f12288c2f6c9950bc550384e899ee20c4a8dc8ee08a17949058556e4527665ccbbfcc68a921520ed77b7847b1d43b21b0b6e64e3a0defcb423b69223431cd96865a639ceb821a3dca8e1fccec980a920f333b92cb4504708aa44257b952e3fc175e7fa4ab20f88e6ba5845729be7ec6b1689051fa6c6670d969912034bb0f90a8ce0f206c3179c87030969b3f1836f4a62431fab8d1e54faab6bcb46130608a6fe41ccdb42d6a9f5420adbf08342b8f310c6e80dfa60526c7da22fdbd9cdb7f75bc2ba5ab476c42c9f40c671f950acc5111c91437b0b3d160f543a5c5145723e34234706d63e7a61834f3b8a0f1133e0c136d22ee9350d945be5fac93d808542884785a4716bd37afcfeae110f0f795e4eab95c7ab526abac144467155423fd7668b2cb73853bcd6d7b402c18ca2aba1b54509db781424da3667c5eee186798047834c9847ee2073ca66846cb1bd364a0ba332b7143fb95ad8d4b3cae5e4a9f95e58a6d8ce3b210d288816e03cfd313cd9972f584691d1a5e2dfab42a4cdcad162012db417147d0e1aba6a63e7c3239aa307c30c3d0306a9968125d15a77812bc3cc5aa0835f4263875c37c26557a526f8a1fc0d61784d0014e82e91d7582e7326a412a12dda70d82829b41d08fcba7c6076510559eac65f93f8b7e61cc4331c55512e9fbef16282bac86a2f225e609b8ae1b71b484f15db8e5433e4b3d14e9ef2aa07957e9764b4469115b48f46ca88f75231baada73e765eb9a08a8869b9da93adfae4ea68c60572a78a7fd6ac8bbb116e811a7f63c7eba56dd86f85692f7eb0370a18515623ea772d1033b84dcac778cb49c4402da95f53987c2bf2ee4ff38598819c2947aad544343b401e1d8dcce909216fa786659819555ad54a9c25dd7e6449dc2b511b3423e4eaff0f9649c609212a7d0107f190f9a3ea6b0842760d88cbff419bae89d8f49c2c4acec477c56e4e84c464e19d31e73257921c6fcce6736026c0a0b4609fc4ddfb1cac6c4dceb6e2a65c366bc199671cc86068ffd0529265407e12a015847bb5486ddf82125e95566d0f67b5a3d0f8edb5720ba34aea644c166c0d029171ee1562996fa322101747ed52747701289d89fe5d64a937e58875f531b7a55504021052ccb382a4377ac24739d9014663249f602b54d713f2c7252a30d55d1a61b382063d9f56aebd0c184ccf8e935ee1dc4bd0b4f72b9a7c5a825968299fc20ba532cae3531eed4473f2e82a57ca37877df48f933cf48d5f8b485b41d1e043bba6f6e90a006cb1c41694460b153007f377dad3be4ad519487293b9fb468233223b17d25c722ca60c5badf55c0ab9ce33b7911b5724c33bcf8844e26d9a4d53ea104e1832e177ae08c56bd76dcbb172d3642bd60df9259ea60c81f00fb09bf16f96db443c0f0c26f24178db2bde549528dd2d4f7140c956b0af137f9133bbc8adbf7d2490fad0a5107822cfdb0f5bf81eff212696327f557c71dc3f19555c04024f138526d715733650cfb6e8b5782fe21b1610941b2ee6f2f58331f81d05476ee7ded12676388d891adab3f743b0891492a76c70283e9217e3b081142cb5435b15f6e46e2ebda624bf46873cf45a90580c1a2f666d291312ee8a4fe06b38c125bd02d19c9f0474ec746501dd0d204c066e6b677d0876f3faadbc8ee60dcc5482f48d423056f43b7b3a0a4bb568e1f6aadd03a30d657b91e4373d62569f69fa5ef33f7a74be4908a58937719ac07b40dba522247a9383aa9f721f7641a7394155b56e98991cb6252828d6ad8d539e2a62ee20f5d40ebb05717f7834b756a5d285f1c271cf1abedfd61a724fa7a526dcd8ebbf41209abd35cdf02f64d5f7866feed09d807e45e1efab201eb783b4267e00890fca0e404e92de932b9e558f24ab656c74a022e26c9755a88826703bfeb8230dff003d9135cecc13725a4bb418c6a01a433463a6432334340c006d079f6ea5617a99c0ee2539bd439fc35ba2142e6987f7a3442c44a3e694b0a50403cda51558d04474a942b68b1a812eafef44a40ec9e2a23ccdd28f8c29d5b4453070b8230127a4f7bd1b5eb6ad4a91138240db299cfb2fa9268883135ce15f8c02aa1fb20febe98c9bae4ef1217c3851dd153b1d281a97800c140a19055c776197dd3852bd763b298a977e59d814f1d0cace4b7fb7d0a4b79528a7b44fb6a3813e63c770bbf360c4036c3dcc2ec8ac91be90a52e154626f321ccb1f8cbc8f6c1e050178d26bc6c702a4d17eeab80f1ed953cb21f79788fd94ccafae65d65a7e1b516a3b12e1648b77815378bc80ff8fde70a0119fac229e8e76fb0d7c1eccfce0c3b51f3bd25cb51844674847bb19dfba6352b2b4b39a2c491bc624ec6b140dffe3615c6e297f5d62534e55d2c631cb3e165b12673963cf406335c28ca48670d3ed89f36dece615561be1d557131e10bdc8406affc4d929feda8598999c245458a66f4bd4c4d322e3c403ed3021a1b11f471b3de04f53f56cfc14e538e91c91fc1e656c81da28d73ebfe89b6afd7b9d0f9a08c5c87e601be5266aa4cea130d3c0441a38d589f8f17e45673ce8abaa347eff2a911e5b078f9dcb9b3fbc9d91bbffb30e82963e7969e28de7d3185384f293aa044921e3abdc81c57069de911826eac73a09efe7b4a28e8057a2b96218eb14c6a274af4f5185dee07c870bec08f59657a56f6f66256bec4eca55526836e68c86b835e1613d82fa65cdac496b2cd9cd5119a94aee929aeba8b279861ef906e0e4a68a7593667c023fcde65305f23b530cf58a44bee89fa31510e62efc51769412b8e617176816c2018691952a3b336c0d1f6117ec88880f640db30aa9188d7df69871aded15c6219fc662b1fd4c4656eab00e9a4fba89adb24e3652e402194b20b9e19633c1a13c57641a298a2002673970aaa28af9277cd959b37167a0e55690c216c61cf575298194d5d2c2b11b73034797fb308a6242971be03407fb0d5a99696c6db4db3d7540d7304d479443c0239e12f5bbe1f42389b4618217897a363d097e2803f598609559a8d207913a7a347fb20e8a2483f5fa5f42e21167cf2652fe66326f5903966b01112539e93e94ee00aa1927ad832d4f4dbd6f93889ccf3992f6d90c7c4a7326de95703a5702ce89fc5405506ace4bab39e8fe09a835c07ba65d096d7fa132f761eb59f05fe017fffbff2ae7a7e51675c050afdf6370c42ef0f6534e49a2892b69ce5de30b7791b7f76dc39bfc4e94bce8a0a0456913c8eaacba2ec0c97990fd776c6d809eeeaa7f8bb39e874d57886baa9bd9faa972153a2148e4c14048249aec56d9de1bda1bfe1bc669ff4685597be5181c19884c6e3fc0f625362acb73047a998c74460d0e9202a52730d0065def0ee722823cc9a7a045e54d2180be02a683569a31df3962c2570ec5c3ee05c195438f676ee2cc8075a588efa0d6168261afe52fad77419786b56f36d898346b4bbd7c407b37bf765dc3c6ffdaba0ae5aa71fc506d4d1f24ac864f2d9e50e225f8b08c48f0f1295b00a8ac5522a4cbb87439becdf7fc90368a898d464482c247d3fc215ec8013f1cfcfb351d025c53218867ede6cecd738c8821fc8252c02f6bea1207a11b8c45fe846c2247980851261a8d069eaa09c00f7f610faec92bdf2fc125d9653dd5ea9653dc5f86a9d75a5bdb51b44aea37fab427ecb91aed703a381c83135ae4bef556bc3980b44510a21be5ec842690b586355a922e0c716c08913362951ac4b0b66b1a9f8c32fe9f470b33d1d31f8c32f21972ee2d3891e9f488bf4bdafec7044303888148dac546b8da232381802a33ad09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
