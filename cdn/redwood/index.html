<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b386a9567ec14d6323dda851a549c90c915c8796baaace85fcc5fa26bdf26d460d93208f9af81d8e4faca343f22ddb4c2a8e120a9a36398e409a2083584fbffe71934d096eef94c9bb60bfc7f08b0600efe883af100f664f5f3a954035d6f8033b350d0f1e5d9dd84ffd6edfc2d41d782350e41e9af72a9f13ffe1ef613e56ee56e8ce8bd596ce6fcef8bbb0ae113501d06fe30ea0354ed234f4d8bd6c5bc4e729211016938c909217a43721b5b515b7f32b1e4ad911de70d38e70318525354c0dff7ae99edfba8e00e39b27bdf047aa2fb30d9013fee14474521f151ce09b2ddee1e3b43f42204599fb0b6b46dc63d6732081d24ddd0ef3dce3bafc9b2890d194359ecddfb0365603913a23ed06dcd71def5e33c03924eba3a7a2dbf6784e375315d2989fc84b893e9569b58228bd0c89daf695a21d7378c1e0b7e9e31e0711d9d4883cdef2f98b88ce52864c718d672ee66db62473d43a0e17a8daee09c9de3eb332ea160005a0a23a1d42a329039489cf31e78aead8b45735abf1896c573c2eba71a5c21357e5ea98643bff76b4b0ebdbc70cf1e55447612649eedb10a576f55cdc910205b7e3e72462a1b772875394cccfadf40657887907fcedcf06ceae3a47f903dcdf84c73f2f875318731870fab620d83aef65c8eb06313a7ec6a6aa406283ae50c28ab8fb704ee988e1ecde3fa44f4ab7d3c275a007f4d012526cb3fe6ec9ab9d66bbd9b0115f64eb45a3faa87148377af176839e651d13c18822b6061b26ce5066cf8058f3cf511ce595421bcba06a6114fe8d96fc10ac421baf220d99ceb463f938218f1f45d8ec58b0c3a4af78791e1fa936c9d7418ebd3bf737942ac622bd6cdfb636d3b02faf3b86238dfe8ae707bc419eaae9b0cfeae91d63a44e3a471e014d01adc84e522628c804fed50ff7db8437eb55de7fd9a10f14a59df9e0e483e000372110153720bec25f585d3400479a1505f0183ee73c58372bfc5a0fe6f9b41bc910a9d2c081a50bc4431bebae538145b16ba9454319873d82a98d555967fbb49e0252b6a37d58f010a8faa696b317d53ae5ad983808f9c76f47222d0839e0746f84d780081b031ca29cc285e980d3c4ab33345e4ae4a5185a0d18ab15ecc04c1baf6c16d09f52bcf9f47b7d62224d4ddfc41cbba98afd150be2893d5eefc096e929632c69603d0c6a568b7ec6a0b0f7b535b192b11026bef63c353781418c204408a03b9247bdfcce3ee8d54bfca2a8ccb7456de726059328c99f78e8c2a5c9d6b5552f902c0ef7309250234a59aca452b9490db398af38167990d13d6f8a1b08ccf126de980603c9d8f2e755aabd046f058021d0b7498de44b812b91d1a57ebd815823dfad393207db720885d69a0547591bf0cc352b3272b343a18cb8a3a363bdb3dcf4a56cd56311a7e618e069750ea54d8e07c9ebb02d7d3d324195021646582e2e45f5344a340e5178eef3bd94d317a0ba47f66ca69d7bdd61999263e5b68860c9237f36922bf337af1da8af5bc02321a70797883a3a2ec066bbdd1a09c00a00a5596ee4aa7aab30282f6ff901036e45c5676abb31bc7cc8cf1dd605d22b84d0193b5549fbf6c46293817cd718a927f48e93b567af4f943e25e43d06bdb9898d4fd650c00ded4d52a60281e7a51545eb074e586ab09e891486c2f6e49f5f47ae83c956c12954cb49ba45627e96649abc8b02c39e9df783cc0cc63a1ee0091039fec1f4946a232567fe21368a2a314683ef04addf039ca1221f2c41770c695954f7aa8ae249295551a1dd2f2bc23841ffafb7edf09b66e2d3c76a808b2988c9a76eb970d1c67def012bf22656ce4c420da5d5d38eca76e334f174818dffd521cffa60631aaa4f8c79dce207fb0142447e5291bd04e2d0140424a01ccabf2c2ac3c6f8663f78ccdc105ef0fd34bb40720febb88e4049bb6f16394625fb16b16b8d452ee62d3136b98dc8f918032e86e4029f685279912aee29853697b741bfb6e5bfe2ee8d5bcddc26b091c10d3cc86e77d7b6c8ce74764f1c199b38aafcac853a3b88774b6c378b4fd75a3872788d78fb04258ffc91f7236cb197b81e10f4d656f7a5593f841733a0b5dfc72c8f5195dd68adef720bce6a978902a1c47c9d4f657ff91e236f41813245a99907512e1e6200fe25ff4ed522991f15fa29a7429105e44e30ca2d4c9eabec63827de1ec3e6393ad4fcb60e46a300ad468d200fd5c5abf8f3ebdc69972fe30674b7466ba68af1a2dfa2b796d7b18797541f7f9fb8282b028ba515587018aee9885250c6236cbf3cadbcf8807241433c0b420f998561f143a51e92d56b6e1a457f114d6348312a5c63514bb06bea5c3e1fd7dada62acb98ec83f81932ff29e7100dba84f588cb439b0722c64829037b346a65d816fac69c1f939828ef24db4a8eac3cd3e64bebf88ea3819cf161e69f72873b0953f20ae1f6fc0e11982cb14f5b0b391e484e249cc098a438f178a23954aee2ae242513a3ea5e8b61cf6bac5e46baa48b8eb54c41fa6d96e6618a85331a0b2b8c4ab7df29185c1b1e4117326f474fac5a6907523d6a75eb9d2f47363bdeea73c15a275e8fc18dbb59edf4811ad501873df10b009b98f4d702551aaff79bcee39443fb913dcc2b011a9fbecce8b1293ab55cb9dc0271389db760433aa900ea5cab5ee20bda63d30be35684f7a1d75a939226172c142362338e42ae8198a5fd948367b24003d665a1eb150c31a3570884962c1aae7125d72f592c5fe25752feaf9d51b9431402308bfccf3deffb719b295a09d16f57bdb007ca3e9e4de504c749e53f4717e674461785bf52c0d8bccca68e86b161b72350b1529ffe0c8331e007ea4c262b65e148956de076f4048e8866eb495b7bd8bd902374df02a1d3badd132428b89f10011a2d746c6458ccf97e68349e4d4841da757ab32c0e7c6f3660254ed8a4716b160e646b9efd2814f38d371c690735a8aae3fc253db8220879abdc12425305d7ce347bbf0686a3c750087da6b0ae9a02b92c4c37a7c995fe0da9290f6755604a6112a5e256cf0e6ba6b4df805f32eb789310f2d08459a5de5530559de9178000b691dc6d35ea8dc062c8663d74098f2a4e1548adc1bc84bff2fa82565a5244e63efa513cfe04f01fd5b9d3c88140ebd0d70c6b4a24ec997a7962f7fc5297645f5d7dbaafc6330cbe03a812fb617501f66591cd89567d842c24cc9bb4d543233a26799761d178a3ff9e3c58276a8a6964ed655b02c8fd33c0c9f3e73d6cf55c14f410e295f909904dd4196654a87d141173fda215c8aa1e078a8c35dd4657cdabe8aa2a2c2b18164984780290fc27f59b16fedd5aa22a31dea427245eb80445d83c7f59ef86309f7e64e5d25e7e668b52343ae31c68216912411df7a5c3747dccc677d489d06c96597290809a5f116d3b05d1f9ed7b7e5fb0ef8d6cfda183cccee9070d60bebcd642414b37d7445069b032e6ceee6b5b5a0b96f44cc78721403f7534b820d53d827ba830f099159ca60166b0819993026475461bc3916be4a6b99955c611d368ee6ca244f5d368c971ea2e6cef8245d399ef4612ff0d565de4a2f1163f9ed7f63168711690a93025813a98573deffef145c31cf50ae7a851f6d42bd8d17e3d0e100c89659cdbbc0eff1a6f217a5fd245f125cc9e5b9afeac2527e890a6722ee06e6fce798dd3591eee89f2d3d63dd3eb47d4d20f2d19f5518023886c58e8a95a2e80a78aeec133cde703593cc3c502c1ec882749c8fac06cec1c1d8155ecb7808217afd369df09d3ab37056037451d7638fa199ddfe31ac70807402c0decc8ace3c9371f5342e97600dccb7ce8a9882e2f237dfccc7543a6de42f4fed567a7ebd6e3fb582707d12d70aa078d73daf6f86ea0ab8f15d18a9eb8ba37fc8ba768e13131c231a0b42687f8e8526966f73925e8c40ebc9e3819e60a59361d69a974e736278c65bfd58c7c1dd82a7607d445a8208f103f89661c3bc926b877b1097fdbbf9fb2cbdf2c2f33ec4c0fd683421b2ee4776a6c39da01f3d7dc554e3ef083e1282f2146003acd5278632b0e3ee6a0524ac5c1e0a51cf826cae2784120786af0a58ef0e4c2a70024979d5f326db7df63ee385720c2b70a2a83459bfb6ce19acf2d5efd0f9e1380e239c50834478bdc648d00cfc77b2b3ef152987b1e1ad74800c97a15237968fe78c7c209db08b2f3524cf260171b867fac6494829d941ceef9743c81a92b85dc7024b02228d0be226bfeb10ff302628df65ee7ac7ecb3ed378f39c7946e8825ad9bd602b998d84e98f115b3b9bd1ce7ec31d91d09126f5d8871d2e2811a5f7864b6de14d11109227ee253ef8d53fbdde2d52c7db95f5fae016250f2b50940cc659df2e548717a14c149404c7dd59c389567498ffbf3964b1dc74ae5e7eb4aefdf5c29ba4e1168062762b537091472b5d1f4cf2fe17c3b4ad6a8b48cca28bd22e5523f067604d3974aa99e6a6684e666ba171ef4521138fa1c0136dfebfbb49494974d8bc26b40162ee99d25a31211dceefccdc35920e8aa8629e46b0ba8ec889a781392ec77d70c541ec35a653419e1aa8d4c4fba2ec38be7d81026ad7655daefec31cb9fa78f55558854c718ceea556ab74632ee9141e2bc4a82a29d5bd46d71f3b78d55a9d75e8d3d134c9c3054fc9cd700270e7aa8382fccc3f944939c2a2151eda0976d18722b92e2cc5bdf0af74ff1a6355cae3c50e5d4122cd545f712e8f5e249fbe58c6d4442bc99cf6c31c48c1e6d4438995c2eafe6da66e24c0092d6e15720d6cca2125b2f519e4df4d59a2163bcb74b9240376b74b8913bf0cea2f715f91d8a52896a6cfd64cf32dae69bbd4250ab4b32b5a38c4953404affdd533152c07ec06bd45c5e214a3ea91b23f5fcb63108682993bf55d448a994f4652c190df062ccfc21c20f5dcc87ecb032c072288a8c83c339c02ed063a3eb01421590ca06e033793b1210c3ff74330deb7522ebcff2fb7b92dc6e5f9e7a92293c3795f33a3642dbe555e2e507e6e960cb03186da407c45c00c993b29d7d4b8e2cadf4f618ed5c621a136af233df6edd7ef1c2db9fe3c36b51f4166a39ae0537398bb77f34bc59780dc20ed020bbe1dbc01fcb58c0ad5302bbb1465b21280c9e57bd7a988b76012b88547e0a4e59f2af0815d3742098c0cc399b68aeab285ead2ced16d5a51b4d14279276340e596dec4e4383d24116a127d4d9427445b8bd8c7fb1ab69b179ee2a4dec139db7b2b9a0ab4566824328e5c5460b45a3fb45e50b4e1a6184006bd028459d876a5d2ebfca7164190db1ea022460fb208c0beaf28b71fda67ea6821f13a17f6494db206812ddf7cba0a819947a66dfac6d7c1336f09f3975a15deb1809ad6463940b8fe22e63102729a92bfffbbe722c65391fc732b09a1229aec6bf38d149ef85f51102f7a039aa8385021ee1a3563c066e5a9e3a2252153fab136f131691b12cfbcbd9eb063f3d7f01d069b4cec506bf424f4bd72ce2d73902e8e9ea26a2312381a0b4a35d8bd8aa90535eca236842e1941c7f428099c90dc308863e1dd923216cac1018c991c9f3a61d9bcb023571afc8562e7e8de890d19cfef869c8828b07c6b63a5c2e319c599a4cb63c69969f3944e398ade7d8fecb1cc0969db25beaa54b5ebe077e57915dd488e4bcbcb2c1c0fd93b8dcdbfab273d85612697b0456ccab5d06e1b2c910a74ed7df867b30f21cfd27113a3251b116ed7f2f292321dc7aa11a8cac57bcf8250ce3590cdcc6a57f2834671165e04d8a47dc30a44c6b7df1826085a7512b16a1f424f47ddbbcb9758d15197bd1afb2a4e3de24ff60b5115a465d95012e84b7b95f60a2f8c573f6df55dcfb0da07c8c9eff57c58bccd0d989637c13a9dbcbce73efa594d5a66f8bef36259bf9e03de686ca7cbe59c15e2498db7afd6d2bff3ade01bb341a70e92430ea5532bb529ca42d4bfbf2ef63384cee03e681da7613e75ec41617a73ce5e709ed1bedd8f2640f6fa95e45f2d151214140bcd9f4af1b3f986d894b4e784069a60397df09bd2faf0671f9c7be19f64c58f7b89946db3143aff92e712f00329fc8ac25476c9d5e9e30beab06b857ea67997aaa486fa8d48867e86a90ad8f44fba678021a13f9a65358503541b8e36c6fbd024fffe81f995f66ab7d5afd82e9f246b446d72855eda78061fd87f2745174d3273ab9861eb6f5db5d6adcc8f3a368674766b38d73c1d611387fbe85141a7ef9fb1c0f853e27f2153b6dfd63dd0725c523df379ddece526b5e69d05b5ddbed26c5d37b1b3d28c2ad7313e0e43f452200b50cc993cd325f0cfc1a33c8678f590af5ddb94a687f657a4a86703bed27343781f653d71371b74737d459b70c89053ea123ba22047c9fb7428dc17a7ec82a774409d21182f5bfcb8376f36d9c99de55bc53283cc0ccc4465a215dcb832bcac987d05d57fbd17cb74ec1f2cd524eb63e8a8c64b1ff87d727b996b81cc5129ff7d002e23e0e5a86411e73dd7eeb76db16fb0ebf9ea4eb69598c67b64a552251d73fd1c7f32cfa64aa657e7afa66a4bf238dd50b19665107dda317c23737012d0641c8a730a521dac8bb1e9064092fca766fe3c9cad58ce9036fb73ec0011533b4e514b738e6b1f67caad96f4c50a6c4b64d5b2ef7e6252f87d628136952322adc426cd34fa37915cf7d0660cb2c4912ed5daa62230822037ec6c85f8d0e0fadc76cf9c2b0a78a79f441c74d4ec58471b3f225b2c3b653531227f19a9692baf0e73a00f8e1d7ca71d03be6214eef18701f122fafbb00c462127c82a08419a7e7121a70222746dd524643892ab5418dcf6d13bc8032919072614cba113588cfcd5badc0a78f43b46dde016b54d5bced23f5091fa20a760b5076b9193154d72739c9ab1e672b0b9b67d28bb4c6ddbdb1822216fcefbf6434e54f267d610ec9b4563d5384c7f8253775e291a440db2c2daaa162913596387e4febc2b47bfd9c71f88e99c01968468b0bb6d00f874b3207584425bd5ec2e956268b2b16d303c8394286efef1dca622fe8ac47732a9a995631168eeb7d6724179e5dcbc9c7fcd53436589a8567843e3de1f7f26c65d8aa3c7e01b0f0ed01aa8988027dffa609b93458e65fefb2fd2f66c71c172b0bac81d171a2c4f1e6a71648d8e49e8f00a7045145945e5edfe4b69ec1e46183b6b76f16b37f03717a127a29a3c0b53f16fe131d9b7d0ebe21b97357ccd5ecc9a8900a846b34199b6b750085b9518d4153303dcf1388e78aa36539cc6f4a74a2a1c65705cb8b80e59f07e3974b07c1ba9fe85f295151ce68a8c6f008c0a0d91d54913f249a7f46a79240306c6e12e510e10fc922349f14291b17c808697a360701e48142bb9a32d70745611c4334f4226727a0056450dadf227bc66218bf3cb810e5e92c41d9df2f7edbde3945d5b794cd87c580e63d5bfe763fafbcb722100221d33a256a349be638ff2db92a579940aee330d076bd146f79b75f697df6ae81000de05b8726e84eaf39667f61da5c10e02f5c789bc03b46fd4c1ecf03a93528b4bafb83286d8259964060148b40529d78a2fb9d1f1bf3b4e92036fe061aed381f3337e59aec2b5de5d68dd32b84f257eaa16f4a0ef1993f109cd999df3e2902cd946dba53322b2777ab8f485e819e5e42ea92d169f4709ba6b259859b6e60dac30148382529fb46ca16652514a1838fc3a750482f22a2081d473aa5d34639f7bd6999c47e1de39cbcb201fe0e8eac7535d86bcff62bbac9db4fbd33e659f24eecf6a10aaab3cb041d1e06149799decfc76b9d6d26e73a8d3d6d8a7ea1bc68ca422e94d4e41675a28499defc7981b3ecd3fab65509306e22ab47607372035856cdacc78c2a693659452a1711cbca89b7a33d1b9355432376fed8723f13c80830fe7cd4997a7ca270cb76706d1fa2db6bcc3dcfc10effcb2abbc25aa4c6ef9f5b989fc1969e0d14a5a3f90222ee87ed502876999c3e9e41b2c9f0590888be50222a31baf7815c940da6e045b30aee012d3284166c43fa7a42159227d2fd22e01dafcbaf5f1a7612baff214e693e5cc304ad3328af0b8f7f3d83d4cae00efe6c7da82027d75d9fc71edf0e0fa5ff840b77fbd91a7bfdf4b7363ba0321aa142a5ae37b2892cc1b4171f9a24863a0007b4457b179eabfe268e1d44d1c4a008cbe439c4f67443d7683fc94289f17855b08bc8d98a63240a8935234259886332b1364ef6be6cb0bd97a7a484bec0af3d2e0c318e247ea69f7a285c8ec6778ccb13e5267a346310ce1ac91b2e77050b46761de9c95e7b3865677f8ca6b3db0d43c5668253f8b97163ac90d9c7c2b2074e8e694985fbcc17781bcf0e99fb1a2667718befed6c8320ae22ad42ea57f33ccc54ce02be72e8b7bf94d30dc71bb22aac5e0d4a4a9f1a11925e004bd6737b5884d0f3dbc5fe9c6073403ddc870420e1f6a46e8664680c8f4559b14844bf3dcdad73c8ba669e22e316fe0532994106bfd05ee041ccbe479ad38ce42365f017f73193068e78879356a736a069e3f19682780b1f5e178424824e5c0f4795749f619483b6349cb3eca1cafc2a735b5309b49dc1f86da6e87d78799ad5498d71deb2dcdb2a9f40687b1b1e757a854f486b76b3ac4cd8fa83fb4d818220785a5dfe768add2dc532279ac2d7f92cca4860514fbde04097c950da00864fb314f84daeca974f4321fc694e4104a759d5e88e9e06edcddd21284c88e538fb788c62c8d9ddeabbb3238c845a69e3bba1b580362866bd562c0fa5beb883e97dbd60b07fd7d815cc843a9faa0fa952a4c575e5a37199af9082d8bf5834770976f35ce55c3e443407ecfc962a37cbebba84aaa47c45f44443462143cd1c942662b41f293136ac54e5940e45c1375c02d75110635ff32fe1ccad08c1e082d9011ecf41ad84ada56fed68bad02929294601389629875904f523fe9a0ae50343a3ff4cd53424a8c209b8d0e3347bd3bd39283852a14d9b8987eab9e99c5667388038dc67c6096917a4ab7254a649bf209354cff94dd9f31e2cc051f702fb5b3c0c41c057c666c802ef8fc653be3cfbe4056644a21e8ac2791be3785a48510d20ebfcdd88801da741ca4eccc24eb6ade1b72d6eecc97c3a2104a348355583212ec43d2e5b7083ec8dd144d99f4a08f0abe536b765bd41e0a0fad7c9bb65c1cdb43b619160c1fe23ec94664437884e4c7a8f0eb3aeb751d3fdfe7b6cbf677ae792d2c79d1094955dd3ffc3b7de37eee926cc8a938de7366d938a1a445577fd57b60fc939e7070fdac4a1178350112b1d42c9624179655b7fb82c3c1493df92daf6488b71853446c8381e55bd4cd1effe1d04d0b03feb96cf9ec1f13d4e677bbdee2603a6070c8cef31a3580752d8f974c0206e186f329d8456e4550863a86ec31ea357af97cd5aedc9bcff00c6896ba5971f7b5881196a5a975ba525a5cf36cae50c31b2390a301e2190eff6d704da3574b1db648ec4865a98d40161986438735cd337bae7dd65a25a31f805526fcbca98d140cdfb0e5d431ae4fe71688ef59f12e5713b2b03d6ceb2e76e6d02f98f5d2cd1a16cb65bf1128e4bcc997255661008295e98582119fa798836b7247e27e6f731a952b1ccec30a8831c43fb659b60708dc806e4bfb78fa1fc0172742dbe633c7a00142b8d6cb393f65e166dad82a17bbf7b0c2fc402006df3d4f4a8b2e2bea6592599826dd5e18c7c1a1d15f607a929a53b733df03306ef687f7bf9ca089051bace9e3f3884cc42fd8a2f01fd94dd26b30cec6368e34395ac33f61f9604007c09334b98c8ff8a21873484a4feb06d555d4254e585dd36920efe7aa8540b9418552e149c9055a0dc02ab4924331147bb80b89f950133071e8cae4a21cc3599eb05672239094383fd731b2ce47a574f0f758c02399b9c8be47e0f28aaaa1fdf230062026ee791d61d4bec112841025ecdf2efa425ad927f437543d171466211ed70d10634e704d09874e3ac5fd1309474581ed3706bad390d1bf5d3c34a192f7b5e105a08e4b858fb0c5d1a57343da47f54d0d779fb7d5f7d3117ae1a77b1cc64b180dd6bf073307d96609b7b279fe13c734230a2fce7a1ba6c7cbf2f084c2b346a8a17717bfc8cfeae14f86c8c5cbd0c4402260af1004f617ec407e9cd81b313501353281cb74c402fd02ff675a27d5323cc3b4138df3e7e7768d7dbc31dde7bdac54c3626d18b483df788027187211ee8162173172d52659712c502229ff42499300ea0eb237f8bba7d575c614ac361ee871650b78ebc3221e1b18710d8a70f6f0038242aa834d77bcadad40977c41da5d0f45760f9fce75f134507014849030a07c1b0ce1f8e72b9c3120f5a0a796c97eddacff3cbd9f30450257f197306a0fb8f9cb86f5476bcad7db9e750969a4d57ff110aa48fd8e52ef6993aefdbba75253a33a511206c08c23bbed578cd7feefe21a0531d0bb77ed9c8c41ca8ab06ee34afff581ec0bad8bb7f081cd4bc7834ccf1d97acd5d44bff53a43846be50dfcd1aa494c4e044d74caefded804c6fe8356c70152bdf996e0785eae39f66fc3b18606ee897f2b6fd331c3af97d75e3bb3556a0d4563082bc7e273a8a753222ee6f974bbed0f58de159b2a5f2d10c4e0ec324c671474d6ea766b6ffca62b29efa1c367bf5c5c927857d79a15c9df73e45348c9c9419dc47d1fe3766f4b3701425f2bf3b1fab6cd0637e31e7075d210f4077984b7d0466e333e6157f1a06e22770d6d52b4822364342077b9507355c15d3a26cccca7446a0df03bacc5df8530a15ca23e26186614b8e8d53f8dd2f337b2f801f4cef16a87b9b88720d284b4b646c102eb7cbd642ddac322d2d2550d714d4ed63426ee3cbb60a86e4705e6774ca73863d6ec89f454b39107b051fda020e429604bd96f4ac363b18622e8270f87c9af531e7cf2aee299e592e6282dae55dcedef497038692e3e83519faf2ba4ebdb7273a43e6e51748a29b9c41c8a10dcd7b2fa2f52f73186f457f54e9f7fa1255f8bf0986e6938047f20b7c5494370e9bd0848b9b6cdc1a798d98736519ac2df941e8a1d4d60f53cc061de226836a5a0adde785bed909ca9bf97590bfe6cdec88c8b669906402d81b4075a815e1b567b636cb2832b0abb0a01c9da34ef596c0e99a4ebd6119ee842fe2ff96ca135605c0c9bab184f43fdbb757042e33c70e01c44a67ed56fdefe7aeb6cd774d343d1a721ae41f445028719f5c217df48883a975460e1437e21c4e674ccf4c4b0f0ed046736e0debaad356ce82eca8f44ae1337347d78efa3037e2e07a429636ead799368ca9d01cf7a6d7cd56b5e5c34518d176c076cff50d48b9ea6520d2cdeff6ccb78c25f692cfb2fb58dba81e92f8b3ce52243795f12f452899da83cbcdd2387253b7ef137df487cdcfb4c610407baf38402a8b84386cb4186beb655993cc47a1826658919fe60811d801fe9a30129a38735a2e5aff002e01613ae880874264a9b31d0923b7def34bd0d460e34b78e09bf3acd4d0f56eb32f5b991caf68fedb79b240275a9bae5adec8d9f53aa46f4a85390680fead45adc452079df6c81f87dc9cf445e1e3c927341ef9f033cd3433b8f89eddcec2a769bba42965680628a75156bde59550876914ffcc4ad45622177e42e02eb2b651fe80d567b78869ddb51c985f60f2824adca005e2d6cf89c8285c7a85895e761ba86596f960df01eb47f3dc167b944f8697de303510f2d3f094d870f6caa0daa7fcaebecff8efb12e29ae455019da89b060b35fbdcba8dccf09cfd5df10d5d9d597460db28101d24961522b0525616882a5c6fcd180fc23a9372db569c6ebe6b88f4e9bdbed624b3aba69941cbe13e47f9beccffb28be2d0edd4273b628b7539066d5f5b18c82f11ff5205f8e8ac6e57ac3850a31121ffcc13c72b2f56d90a34eccb701a1bde7c390503df9160e8de114aef68cbe43628da2680ecf257edb3d0be093be54e1224f02ee605ad499af1183a802a83f88ff9dbe192460420e304be5691db8815efd8b76ef3e2c7b048874d9964aef7e7c296ecf8a2a712f70b97b951893c89bbe246d4ed8d833aa549ffb7379bf85c260e627c515ed4ca79f572044311955f24392410606e71bdcb074e0ceac795d8ea065fd8e90a0c435cdde2c2d1861065c518a76595826639feda795d2a978d02f1531419bbbd7dbae467dffce133c99f53ff94b8bb025961e1acba4fe738fbeeb71db63260afe5e2b10b61a005b0aa624eb848e567deae62f328ba93cd0e639b269ac30f14b452a68712f351dc4663cae74865094a3960711ada21dc9936839bb089d1e3b2c2b62a930e1c71f66cffa53f7c6755ed0a60110c19f355515107a02d9cf98851f51d1a6aa89f2794e4a96d96d8692b93f44b6ae4118fe9c6ade423dc08f393d072d868922fbf42f9fead6fcb65741a63d878deafd032f60652894129936d419b569f9458e058377a2024dd22cc29147db061e45bd4cd6ac3667dce9bbd90eba59157e520e5b6ba41b872325d8ba9eff67f49cec4d9f485750280127a6681414cd1c446ad528364cff383d5a85f142afbc3d34fc228b95a9a8af49a534138fb43dadc4ac0606e2e1d8870d6d6d369f2eec8fd674cb230b716392557572d56fe5ea40b8f894b6ce28fc6511bef2e2c1a9b0aef8f6a99a9fa40052b47c1acaac9e33dd4168dfd4dee3beb4dc15f9978dc29d4323c89449379582f9d6affc222148a60ab60bac9ad1b7383d364b0bcdc208d48081ecb16f2becb9403d0419843b8c3568aa03c50e7fda50bcdfa1ef43d4ba9a81e726bbf8071749ea6aa6e5f38af5c66a9ef669332ab79bbcebb474606d8b8af134816ea6b5f6755a8db7d367e60f13910deeb831a1268d88caa550b62c655a4ee629bc7d23e162297194565a742289062796d11f2d96a44d738034576c9771f6fad6a2599719742d6220cfd39f184c655444100e0fa4a96e9e96fb3f965b2383fed0b29419734f4f13278addb5cf97d8d72d44cf7dca09d1e2a35d81f2e80f4a3a8f20cc875be34da19742ddef9ada8f958de2eb0b77baa7f92aa5e5c1aec076802958b07debb843b3322455fb6e06457cd0b4acc9cb53ad86e9672bcbde750ae9d80032116f08477d85e496ebac56ea534c5f78a509e8b1b7251cd066b6bd4545ed91cf7227a6170ec0bdae736a9571ebfa54d390ec5885cc8d7205e76b4f51e30794675fa71f7a79aa35113ecfde2d77480302de13bcbce45cbab5ba8fd8550337d753f44f4f8adbc6ecc7d450ce99a83add4bf9490cebb7a42ad94a0c60f4c8d0b5f6e87aa61298880767e1da72dad6e0aa774c5326b923e674d95e7b1f6d5d0e9a6707678ba2d9f5bc8d2c00a6328411e44061c07d1ad0b35665a868ff51a1a63859d7a793b470cf920eaeca06e240ad9f18a3cab5f01180401e8fa10263ed731c39753791f11dac9c1e42621413b04ab27d2dfc42991afc9940f3dd8a9049abe72196500cb9af4ccd648c5b3f26e539c95fcfdbc7c0810f2dae6aa4a22e476c9dd6abd500dcc7f82efade7267d115fd0fe9b494eb4cb5d5c40fe817a1c53579c009b41b3168dbd0fb92a7364dfedfd7ff03b86edd482c4908ef357f12ca8102a78c7df5fb8194ad1479b2fd4c548da33806337022387133b4dad4df65ef3e90cd68cb1d93b333c9d0b6e764ae7de7e7461c7f98c92e10a696f253527571f281bf605848f0704b60bb524d88568c78f47cdd230cee5c965198735da7b90621ab6734c7b1c714ad1523622734a547be74a76b16b605285077871ec75230bec5bdc2ccfcfd335d1e681ffe4f06751907ad3373655a599bdb79ff441d937ef08e3591e27afaf36e5d20e3d6015b9bfbc93501be35d85fc3a507c3ccdafdd19b6d56bb4e10a80ced5d5e8f316c039d789604f92f40d2eb80c6db442f50c189c9f93b6aaca3d0052d92c461ac09fa9ccbd34d5cdde6b87573e631e0ebda1a94a12d42e7d20f3c0f8e161cce33d849908ab8fb9f6e15b3f9bb85ab6dfcccb946117707dc14f5e467a46a2715400017ab73f94f6f3db926f0bd1fb2f4261d3e355308b2a79a451f5287d17e30553a94df8b9de7d44acc0b88e8e917e31fe9f3ba53a9a1e447dfb65e9b28d2596691976c25f3d583e83075021c8c1b893267090390f5f510ac98414db423737f815d8d98cd89e8106500e57bc5426fd57af15e77b4d12be0dba63b33ded8ee4c2650c19440266bb8458a1c9cbbdbb36d0a786b5d21fd15b227546bd914a8125f440f14d8e0151290118dc2fa8216f38f7c53223c3c4f981563d9e41b729a73aff26dcbea426eb0a3533f3765c9b95e527d1f27aab39fc0d3da0cf5979c20a141dfdd92b8c4610aff76e12f8b4b417e6f3252cc5cda9003b302932a812a5521c9eb981ad0b122648eb61dbd08a56ce9c318fe3824b0a0f35493ac1f5eb47cf26141525170b127fa63b5ff8884f9bc352e425fff43967c0df4e444ab2f2e4a034671e70a4aeccdefbe834469fa28436f3297f033d5453dde6517aa741eac1df1cf418cfa94c944da4f0ddc9b85d1cb3cdea9b66af34f5a6e66f4f5fba9622b0e844abe214e812f8860c3f172f598d35f7c9cc192274c91649a46bf7d3bc87c1eac054530af5f011621eab83f0523a27eb0697aa96ba253c9972e94432eeb49ae3b4a244e9e89d549e617d5a26cc8fb27dfed7e262c4626bfb2f0b611ee1b6c083660f32b6fc4803e22edc0a87c7137bf4c4533295297fdd9cc186a28810d560eda8c181937592e017ce61fecef61dcbcf8891fd41b20b43c00c9fb551c86e8dad6f87a5f0e6285514cec483247392d655ebfcbc8fbff14861ddc8191c4399c129903bccb9bb5d53293f6d25ce1d43b1435cee6be342182be434d7e5639f7b207c7b0c58d07e3922c7d58520e4c26126498b7193f8e5d057309c7f39aa7959c505963fec8d63908aa0d27429681f719462476f1b482bdf914dbb7d9d90ee9356c11552ef069c9198b9f735b315a9df5cb07e7266e844a52ce5ce2e62cad1ae348fbc0e6baadabbac0fbb07e52e100c3db071ea24caaf34f3d3b0058934343a81e8e4aea5b37754eb1fb6026195fb4c560f788fc6d4b92b68371480bf8e5e6bff6d5108c6aeadc2f1318aa018d2f78eae04854a8e5b4eec77ebf8f18bd9d32b2400a861d098ec8c6a0dfc6a52cf1321dc914fd8b442c2925805b556fba923f851816aa2633cd0343444c2147b427d79ce4eae3fbc278f4b5d0b07d4ff9a58b1ca1127cef19aaca3b5cd98bf396a41101c0cb24787db8522907df6853be0b735a1d84862a9d01cd7a99bf98bd0e0feacacc942b9b31811888ab3c156035141ec491c0b2959b97271dd627c5dc77ba31961f84afcb7e49fc0310797e8865e8dcebd340c0f87ca178b91949e38ff81a0df38a6ca616ff396ca655927e52615b1fd30d909a32996ae4c89b46d142cd7f2f702102885e57b5144bb16f4ddeafc5ac5dee8b19eef4ab899b28b4e1dce4fad04d4287d22969520f119b3055adb67d7ba29e087616942366b94eae26f0e9a80d7007e748dc84a2b1c6220372bb75c61c5b89067b947941aa20f0dfdc882b0c53bf1474de736aa531bb30ee82bf13724463c79e20a6fb831b37454e75c5eb3e085509ffff9bf71f636fb3a51050bddab8d7cfbed8e778b6893fbb0d5c4b4c66fd772f9e12a2604cbae96b237e6bcb5cfc2e942ba458b7fe3458ee825595ad28eadebc9428ea4e9b7d600829a924a1d62f6a6ab99751b49985730e9877e78f682bcf3a02d4be948bc305cf85f06a4a38d1f0ff6f85920d8f54a962af95881080430c2a44f5812fcdbe6094c9a80c57068b636ffb8c8e08eda2938dee425d02d28b11e92bc3793356effa0a6b0725d349a1f2e75fb55f24b04b654431792469d41f9fb93dcb56175dab64c67f7c52f668aa1cc1f66c140db3fbbfb567be8d2666e5e478474e806de1bc57adac595f636629d0c11120a5f2141056cb9aca5c7bbb8880bc2a547d4e0a1d5392ed772102b4fecade6ecc1df587620b8a6ff4712536a2ae6216a7c5488a5a7a586d41dc463700788be4a9c909ba3737122fa4384385a373d51386fa2d3a6e63df0554d786123c1bf64f47513358aa3d4f14f8a304bd37d92a490d57d814ccd932b326c91a195c8ea6ca28bf94887e1b072a5f32e1525eb6e52f9de51cbaf1eb429245ea005b1b3273c1b2c29097c800bc2a271b03ea305e438bfe3184576c23123964bb6b9035a52dd52a93f449f1b9b72a145a8ae15bba7dc9dfac4a7015aedb61aa43b6c604f16e0df57ce9ec27c547288e1b8578ee87bc3972b68d7c153692d28465ec2ca8a084e7b0c676cc5c1c544aef8fd687fd7e762eb97dbdc082b2d9a445d6ee251c9ad67aa9d2d3da6c85c9df69abc17417be36d7a48c695bc13b23832d8cee0263db32d0f9b4e899106ba9a3e0341ad539f5b0c910492951db2b74c7a834b61ee2f6a0f20b24e0f55001ef55d12146f245979c059ff0b1b87c78e0c8aa91b669bb73bca08621ffa71d8c9f0588a982580f648a86e60c6a62e2e470d23f00d9e50f5dd519dbf12ae972ca485e6871cbf23ced8b9e204cb84278e9eb95639f517a320566de4c18d34b6c6dc4c4b190976d458229114185d40f7a8c68b2e8c98d54b50edefefa8b42ce949a76f15e036e672461b0a2c31edceafeeb9cdeaf0d7ae241ace4b23067399dc848ebb381876d57dd3682d11dbbe04a891b7aa2a80ff1e6826b1277105451347d2d26cb63dd3ad822b510fa853a770e5a584ed8692d79de5deb7423aa9559e7ae2c38475135a83cb8e4a4bddb6113a8e64d2912d2abb7806ea66ec63e692228523ef2b4c48605ada2039f8457a9d68634823293ac8bdab56fbd69b85bdf3cca0857ca7c3f11829ac32c0ead1be3e663e78c1056ed13f7893b1eaae12cfb97d4eaafc179892214d8747d840d020fc5a84333393acd155a064074126a0068cb387d4354a27c376e2ceed66eb9d93b8daa4748074f5b1bc34fe49beeb1eb6e33c7564de1e68d4c7f7d6297845da9e240cd03a656aabca607c78cf52c9ac4604cd5d391c9bd3bb4a3d14bdb271db957ecccdad2554d7719831ab8d7e483fc9767ab81090ad3a5a37d03614daf83d83f84cdf06d465070686ce03c1d10baeaf4023f1277a9ec7db8ace630037af34bfa0b85cb18aee2908d8ed52e386a0a11ee853afa85fbac389b54bf9ebf4549a537615e52bb214ebc25e13c91811e6788e179d54c704f281a389685b90bdc4a79d725089e3dc3ade526be7f9a41644b4a155b258d7de0108b469ac6a1740ed111196f79e0e3f6239ac2587090cd6f79cd1197676919709bafe9667f796fedf022539d637fad1599de443e90d8048ac28514b9d5c376758f3bd0cb8c38bed084e82e604bd4ab229d6fba995597d9c4aaaef786365c6096503efb955a07d393380ccf413e00d4f0afe3e055e4a5893d87285326444f88a0f59329e7ad8bc77abc6f4b048be79dc2f65c04c2b34b5f3dc6aab5a3b6c3fb784c824991a9633e0b69181fd26b67aaf90267dc315ff21a89b756a3f2c0e7143b711921f1bd9b89a0aacc1b5fce9a4d93196a0df93bbfe720bbfc546891e578f9ff8251fd312d2ca53943e10133c55f41180a2de7817a4b5046ceab1249d04c9158085e3bf8a759653faf6a1a66dff918dc4542eaee7e8e69e3587afbe595f361c1eb6369ac173af4d7ce312eb744606af7ed84f909e8bc50a8eff70ec448e01decf14612a104d97b15f5e211f279d5e9b5b7dbef0c81614838df54fb9e5b7b7614ce4da54eb28745f026e1518491f174cb1b564accb0a8be4ddb11c12e497f42ad8536ebc68de3b25b8cdf120a8a67bacb230bb6030686b09c5d8d06aa2b1ee5761540a42e1eb3e0c2e3f91e8fb8727bb5e662f8afe9d2ffcc3f9561c42d04926fee27113660c5d918ac265eb7039e546f1159b149d3762a61ee66ab49bbb1ffe5fbbc2c7dedfe03b9bf4d017a43581b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
