<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"119a71d0ca07c2fa8a26fece225b5fe4d739a850484b75fcc1d3d5a295f0248ae149e84160988d5c5c769f5b48f7106cffd3d9d6605164ff218d104a630ba10b1dd83c2ebf9dec04105761992dc6efb22ec0309bbc70c74ea10749078c35de7460f85fa9340c6d3c545905b21ac6f0369c46b8ac8c68dff7a570bb6b4e4a6ecfc1659f36da52bd58da3ac6dd3be6755508d78ee5ed3b82a144baa3c383e1ff3c2a9cc3be14ab54fe796f8205d63016127827f4441e7e55ff4a0ab041c2a6ae83544cba82c85088e9b5a11f7e314410454e3e6a7db0761173a6f4845342220c9efcc67ce58f178ba4ceffbb4718bfaa37b2a01c0b7b678426c8250d04d97a5e0bda6826748c57538fe5c6298c435162dbcc8a3b6f11ee256dc0e76c3dadf48e603b1f49684228a492f7449d67632c8f757cd9e5086ee5368c7594acf1f782857b3a54854add3354d06456ec60362e6df119af6f3d6b2b00dea65445e6a3d331565ca3e311ada68cdd96a91233f41aab339c5fb9bc8494ffca180de276ed78b61b9ec52132dc4197ad8e10e5e9edf0716ff09ed636c02b5ffe8612a11223a14d669537156ac9fbbb99e9d4139177c2577b156ae5db6b3489812366c5720ab79eec72c43041e6023b6eea2000922cc68f86b50e9931f5abde49de0436c4b939596ba57b852fbf543f984e45dc1e34fde52d5d41d9a8c826d134a018619eb046de90f2f35a6f591804ee3fa5421627cd1a797fd4101488311fa9d687ba2bc9a0c9ff98ac4b38971d8acd2394043197501a2f5e89b7c746513b82ff600af05eddc857373976149f393935f0c0e94aafca90e7147ba28e443ca49f9b2a2bfdf6cd55de8578ee60ea74690c8021ec2631e0038d7c2bbc20b0120e8d8ee8735c3bf2f6c692906043ff4c1d74c32fa3b2b6aee6a1dc4d3a37d0b4b8b6265bf47dcee0901d097b4fc0c22c87de8195197a063c5629cdbe18b44c4be9b928d2b97653db0dd289f257b5e0b3acc8b13f9c996b7f5be17a514bedf465f33e1605a7dda8b85193fda127932cd1507a137cb299b3d90f555d745a9c5ba5931c9487f42495a1b805e140f09a669c992ce7a8680115d021b8bf411ea58629c730d56f7d11b93792394df9ba5d623f8a8e483963b39b408ee0dc8e08993963ff9240cdf1adc0493a0790e0ae5d1997f60cda16e54e1e06089bd430487c58c311bd2827199bc8d65cd8ed6d5fbe6ba42ed7c2e8617112fcb90ac12ad5caa81c3963a3faeba6fadd71898a2461a7efed102baaa5c3f6d86f486fb098dd8073dde755e179ed0ef35dcff72c44d33e050560426e529a60acd756224d791fa083eb84c32e016f1339f0ac2a54cc931e86170e3f246e607314bbb000139f59f5ee0d8b641fa89ab1a285642af318c7db636bda0e111b973717c5e05176f85a1b5f3b9b3b6a8647e4b383dfcf06fabbf42882254802248aff7216e83e85995802d69d0bf0f954e546cd783242a92eefd5764bc58a3493277fea94ef1b72e1baf143be6444d38a864417c2bd38af652f13a0d290930943e65f74782fb2c8a5f65fe5808addbaadbec90daa2c4e7ea7284d3b582fff53da65c7319cb1449e9818581f22535f451faec2b2c58381dea8ade1b50310dd2ffe764e0c4fae7b0f96ca76704638022ab9b6449af619e8b5801c3fc3f1cb240428deee9d81e7982dcefcfb74bb33798946daea9b6b511c5f6b80f369d3744da37acd0065d17b96271523641d0f6516b866180c973f9db34c43c5286d3efdac41c29709ffa80b3f4108e7dfc0ef0490d5a54b7eca78a3574d5291e1b67b906e6534a3d562c47da8eccd8a4d64e00d57ed6dc85525a524289d374ca771ce8467ff4d9c206182b01b4fde6e3587638250f5e3d46731e08d017511b54a821d5947805ec6ea92bfeecb24c7b9165625504286bdb8758a8d5397d2d73215fee62b33bc03c1310861e0d0b870aeab14e8086f13c715d60fb6c7799edaf607a145fd83c3f0b71c044f4903ef7acfdffe927b2375a622f4a3f4b0deefb2a8fba62cf54a4373ee91decc08b893252ad32c7f6ba2a00095ee620a318287fcd2fbab441b843749cd806530ca735b8d4c0f263194047929ce0ef816d3155e3e950ac41bd4e4f89d8eebd05b6c151533fcb5623386e3ce0d463cfc6df440fdf604cd4dd1c56233eaaeefeae7aa07f0a8f4445d23a0f044a9cac81785b72c0aedf680dcf08833f78847c90f05007d6bc0cdc700c9c1bdd9dfd816ca0609ee20637e87ff73ed3b285e8bab4fa648ac98bead28b29515363a2f217c7ba7830a4a28b299e472f860b9fffd2039707ab1eca9d14234b2507d3f0fc3c9183a6c1d83701013ef15fd5ecd3bdda9f16f8580bc9706cb8f78b01b44243c4489a16a6da6ca81f7c6fef4944861f6b242c735964cfa2691e93f0254f19f664c7f86e13b2f0f195d5e49d3ab0567260f34ad2082188be81710d67ace716b6ddbb857a992bc28001c63194a27cc180f9598f8ed928066ba9d31bb67c5febda5a95af13c6c2d544027cf294419cd1c5676bbc5b1a534570d006e1cbfc8ae275df92e6500e8ffb7302b8548e82e16ad014977db0159cedb127328478d8e537dc2b60f5c972b0d95bd7f91e6491dc048aecb2eb72ec21c8c49f2bb06cb4f3647d1639b5036a0fbbfe579bae87d9243f4f249eaa716d3735c46eb3061e461d2d32b786c7c8aed8cc38a54f934ce070c9ab87d802e97b9de74a7158cf49b76f4ca78b9909494b7ebc289f0dae8e6ed2c4148f4e0374f737f5c40d70405d859d6d61e9960060073db51cc7e174165a99a8819744d0a0af0a3ea470623f7da7f5b4438e782b30702e675766816f2112e059efbc928eaa3b7d3d990afa04d9725d16cf1651dea7b97f8d9d3810ffe06d94e3538456eb5189177414401c5b395fb3e2a8e9e7eadf9cc254329958aa84a63430947713993c1fc72e101afe1a4bfa595144ee9d9413f50f089dca3a72650d0b94d2eaf2797cf6aa68cee4725894f60d64deddd14630c1a35ebf6ed5098eff64d30338110cd9ae1d86f0c70a50a5beca538736f7b9b2a8d440ac5762641247ad6daa0756a9d5b0b20ca3f536ef4974f0b030e2a5b995d93540e6666904d752754d7a0766273d53d45aeda77955e270db3d3d3f0da5b875afe29abce2783da4723f8f2055db6dc0d4c4ecda95dc78e4df07dc44c73921d873d4439b771170f3eb0a520526c94dd802429e95b065dcde3cd777e4a433cfdb148b0fa784aa6cae2072826b85f7f01152e955674072fa8f83b7ee01538a55887a898420b5973c7a081fc9de106a0a10c6ddad15df1cea3e711c180fcdd7176e066c37aa74cf2b922667109f831ca01b67099c31642b16d33ea6c34255445b1e44c3f742a24fc3e186527ae19aa76f7e1bdbd2356ef74e7c98ecf4d67c12c778f83e92a43bfb59bfb7f563ae0791bad16492ee41889776ecc8c9348a10d255dad1ec4c09490293050e5bb3cd7f50168a629c813bd92d826751ac3b0a876b52341cdc77e2798d73dd02ddee9594c7f670759532215f92956942e3dcb73a46ede743f50a35182c5635674d5fdbfd8dfacf8c72cf51e94c27884303ec3c088d77c460a2554b3f19253456bb0ce77a7cc0320515a6e9c1d61ae5db33c8d0458d0da52edd76586b5a8ba77d1b53ba5af3ad07eb90d5b5fc85b2bee9a42b12770fe59ee1e12cf057bfe55088abded0d512fa7c23bb372d64b0b932e6369b24e8b87652cdb44b910029d1245968108a6f1f1aaa07362cb96e79b7d13073f73a2672e979822f7e451a92a573a4c982be46b1a4e81002f60139edf1e62fcd411022c7b7054a407b397733f83f82ed35c6dc0cffa98c831929d1714de053c29124e36d26a7759a12154b46a8c4e57b93d51f3cccff64c452cd8f4ab1dfb6ddca167cfa55be08cb5c1b5fed0055dc235df0efaa18f67d768a09b0cd621d99e44be1c6369fa66c859ed906b3a94b327ce52a89607adac46253022676ebaca5844c4f6ef8f8ef29d234df0ee5daddef5659766e8dd7600b22d00a320f97cdfa4095c54ffdee076a9e6367b778d886da3ee4d47f29b5ed5a3d146d149e6e4205a5f8b381a4ea85ca523d7fc776f110380c028007740ef5b0fe75fb47bd1e11439fd3184b6b79f7651c326a917693d4a72f4d3efc723a8bad20c26dc39f0ff13c8b1b9491564137698c655180012d7901d6062fd5daf580e464b81dd6af6f1470dae671b8d9445b5ce3e8b547d8ac7ccdf544299251aa8a72ac95dfeb0500729a600e30ebccccfcbdc2fbb3f05d8935047feb8882dcace705be8504b3c30dccf26ae758f2bbaf8b94f230b894bb98b806e449768cb41e37620d8f53a1598c16e2f11d0f18834eb86552a84b22b8cb79012c49ebebd81f39e15514fe3a6e3f9fb779b6f114a98cdefd3c0b937639fbbeb6e5da4dc598338231aabcf2a0ef35656972b0eb9d18682de038d13bf834c3cd6461f51f85530ff9310cc9c52d098c5e6c4c256982c7a73d71b52c919dc36559d7c9c8f8787ad1bb448c448d8a8efb03e46b693902c15feab0f41f30ddbf46f64abc50540ccafe080255dab5989beb6e01adeba00350820e6eeb1d54ad5b4b02d63f7c12930cd7335ffc776771e6a4a5fe8a6a0b7319bdd4f4c77711e0ae5b72beb978f01b90fa2975e36aef3b3ceaa393e229e278a74fc17be81585262bbdd7cf682e32f83b3982216c88dbf6c3633f8589f38d937df07dabca9ffa9b5027fd1d67101970e5396abe2ee326b789ee462b2dd5c66ad7937cac129e8fbefe30ff982c112bc664892595bfaa1256e60fb81ffd76261303714690909a25ed7ec50e730dc5b96479bb220a8672fd2c8f674a1300d978f15f9f8623992434dcd22f67c0f3d4e36a2abb400f647a6a91662f118f14a37601764081dbc0ab88fd97e661a1195aaaace2e701b20c5b4b1e0bb465e96a72490c68ced44e42e8479a567ebf7d86255f4c59e6637733f2ff15a36064b68c16a31e7cb4722840557bc3874424da50c12289bf8634c090d09708edec3c67863591e50f23508f7f3d3dc5650fa0286a564f2270fb5c5e896de8c9bec7760b4cb09bd65d840dec04f444b734808355361244f00028f60d6d65dfa7a487470c4a693920dca5bb8dc2bc945dff4820afdfc81a598f0cb80db3fe81163c49556c12c60d74548b82d2dbd0c290aadc8e2bcaf526adcc6a1d72a63d645623ea521fd12656a14dd73e5bc83cf838139f2793799b59766b768f115a8c8baa6ad87811501c423db4c7a08d152b18e4c4037b008e658166bbe88d11992bd13637e087fd401e2430795cdb2b4d69bd24df6c45f4c49165282cf2dc66ff74bed22f96f362c274729de3e8ce3ad9f29a6743a01240dce8e8ee0adf6ae6728e5ff74f2b413755b93b251144fdfbce7f55d82fc928b93a5b24b357d8d2469ecde3565aa46f4a23fb7d6aa30db09c39ce2607346ad8aa85594e73fe01d5c65690ec1c61b98f4c29e7e1b84a494b269a50a117ec6bd3c181f163f7fe1047ee0e80bfb6f7ed5b85d53f5da6ded91eb0232a425fee4d5a294ab6bb572d0b23fb4f37522ccfb5e543fb2fb74729753d148b2c7e259b3ec4273bbaa02725c4c838ec9350b22f29fd473f94b8ca1a2d169a95d521631b12ff9c487289cffe2fe9a66fc30b9e8c97e1c9843094cb3490a0001f0ad799c28b285016a02e51229e185ad4e42bb9393f5dcd758034261f09b94be6e9da06e6760a95e41c66e8b3486c734a7a271c8f1d67c8ef6bd68286526614964b3b00759649509a513bec4261124e845b2beacab1ea1dbd4fe9ac5683ee67c2b2fb79e7e308bc7f6984552dd08694f333374722e0643c86d83a90840c53909478c65df6bc7bbab48a41ef1d099e54cce2e2a5299961a4716c5149d17d86fef0f20eb28c11a5b2be037c9d18d66687f2131828b792fd93544d8edfdefbdca1371337bddba5be3dffb96d125e257a17f75faf3608e93083a66bbdd901e3d72094cffa8bd0d0c0c4f84fdacfa0df7c30dddc9d92a174ae2e309d518ed164453005d7a8c693a09c34b2e8ce0eb487ff41307c19469cdae7433e7a1b4f3ae272d9582742903f9464b53280b76fdb3dcf5a4c649fb6dab340a0523fe5790e8628f858e7f4cf9e7daf612f65a919191520ad4de17c828ba076c63e5d41850cf5ce595e68c13a74e0fb2344cd3c041efe2aedc1b1348e5fd2ac0bac671dd05a2ba2d59c681c02627a5617b0cfde3c9755f0e2619e72127eb7a45f1789c52656b90a1bd881d6f52d71a7d570e5053da1ec3d92edf0dcd133f0a7f78f5f74cbbcf87997b28457a352eb888ecd1df681f74f8a8218d24b286c628e564c7594bfa486fae89c564b20c63b35ae2a57a14f1e244eeb0a4982ff73d9fd99eb97a03a674d84bbb926d9f8a153a9ebd9c914323b2199e6a8723e9fbe7f6a9d93ea1921af13711cfe694715992a5f2db48c727d0c14e5371e64302c233f73c9a530af550d9ee829a3f0de071565b3177fff4494ad1053b6b2494287d475ecfdb74b3f4d018ee150231635e7208b2ac1b71c10e7d4abd7827a5bf445ef4d7eda3b743ccc4a5366a08eb78837a8ee83f0eec382d667f63a43c13d686f16becbaadd68cf1c46afcc8e18c5a11f17bb7ba2165bfc22d0c2b83a4b71c4534499e8b5d17ace880a749910b7e42296eb75e0d6ba83e663a5ba3039c7f0f21e1803d6449b3e9dc2f94c499434def3fc461669343a9d7a7c6007ad7905894f6dd683ae8cf98935341f45cfb685a4df957818b38516e78df5e4844a39077ff401b28b07eea799734d994160d1711c8e679b6b7c0dda29c08b205344f3d6613bfc1592d28df64e0cc571d167bcc4c4d3e366bdb9b6afbadfc26af818efe60eb1ffc63833d02830280f3e089f7c0c70dc8a874ebf84e80a78540ce7ce72bea2b21fa49c17578c4f89efb88fc66ace84f8fa8539e1c14a7028f79911408061d5fa716e18c12c51299c910bb47af1163331ca26f889f78d02c4f8dbe628a022bbaf9641fbed017cdc69cbe345f8c8ea224bf4a40b87498ed7701095698496539dd20f26f0d5e983b27cd697f5a3527548eec6a0559881030bc3447076b3f215b48dbf5126d1f05e387e9228cec24d7797e51e4125c2a3ba80b73d55d6b74870b6f56d43436689d0939a80df2f2a54a3520641629b16225e648f866ed84c3c7a79cdd5d50bb21f8dc8f411d3e8cca0f8653685d3d6548191362243e90a3ae3ead927e9a720f59d852755f242927ac9d8879f3c4ab0a83993f4181bdb0fd9d5dbc18532ed4b16da8d2d94a8fac0d871c0cf96a228179da3dc837d416d41d12ee58d6a605b1c182b7ab1f464b9d02cd455ae9b0ff2c3362605309ba769a7624384bcf4f2cca33e512796c43538c0bdb0f084678b4f7a7baabbac0086e544c488f8ec19f0586bb833c4561fea3729db30e7c840042b66d8a2a6cbdb39a00df360c555aef77c45caf8d570925132939ae896da0e2d06f2c5916e239962339e2ff2cb20164e418e82dac2102e3e0bc98f44d4ccde07dc21d6f43f07f195582260f2b86fe4fb73ab2967329a49a31e34c1121ceba2b37aa3c4d3e0a446ffc70beb08bacdc976d59ae93aa4adcae6386298402de3f79de7fa9a7a6bd6d0c8101d780a3faa328124154d58cde087e990ea8bb646db453d8705f7f343a6f1bbe40e8c17e63df0f68bd63573e70b30d77f7f81554005bfabce514f2ec516e50743f00e49f3973d187df4b1e8c05984fb1079c5e47bf0165349634e44a4358b544287efc4d29bee63318740e81354d838fecf86af00879541105f17ce3f2e956f197d48f35c4ca21078d83f7e092aa0ab2f7e22124201b644e52093a96c47ed647773a08b4ddca20d2470c99cbfb30e73d7e1eabb9bae8c0c7010a3573f33b4abd0b3dac0ce307e98dc70fedf959bd73d321ca99a3e63ac9b0dabb15b9c44af87c038686923d28ba7e95f59e89c25256416f17adf03496862eedb73c3a26528f179de1564353765c03f51427cbe4310828df19d449b5d167846aaaaaff418480f46528318cc2b59848b1002c94de5edd2f4c9c18ac110b1e65b59a923f0ecc2a33b6e1ca90e40da3ac3da0b67d1d9364571e6c4a872c097019faa8c2e81adfa4f389d9c0fe9a3e34e52772a68f1e0cb649b528281ab5a7d592b02b654e841e37f85696efb9cd87ee41d517f5ba1fe4d5a93a205b31abb85e3ef754388c7e810ca5ce4deda9f2916ae9e845130ae5aa586562ec2cdad4bb25f2e0bc6782e2967d33ae14bc4ffdc59c4e4cd6280e94a260992ec8730b406ed914a5eaa569329d6998c23ca2d53d7de09d72b15906b4b698cdc259bb8db9274cd37e0b98f6b6881e5a25c0cd8a4fd1ca91026ed2dbe866841f2d010e6669e546ddcdc713519556ddfd46b7583152de3bed5df902648dc1e20adbc914440c13177f399ee5e9e3741e4239556a4b2585aba7fdc4fb69756ca2cbc032ba06f29aa80f6ba46a345610756b3655c798c55de67b494e951cccf5db7a78b60b02529666bbcd40d0619ad4a3071f3e1406b8a03681b3f8d980f5f7f7c85f5dca4c2f3154015bd1f273f905c5f6438d2df3bc533096c18c5fb976e0cf0608de2dfaebecd99067e90f81761adc6543b92d28406b06274d64524f7320f45c38586fb4c5b412c14c0d7937dc79768ce03105c22e5396cb7996084d66fce9f22adcad025605707f6187c4b3d5e840a8bfd8563cc0c03084458c7a5a2e55143a7369ce7da005c9b2734682b253748da5ab632383fc9e66fdb72051100b6fa045e7dc0c8d10c0e06ff8af1bcac4114ce2c09e6d38fcec48db63dcb119b213bb339960a16a79ea34519c86174ac86e1e58ef6aeeff1d865378248357de4086798ccc72705e9fe67edbe9fabf7c448128220c4240784f1a05b2f10cc7159d7f6f5ef7106b792e95f59cd6f61ca2364b7add9e163100e5f6244f9b40406f5db1c280f4dc0335110d4fd40b88ce01fc7f7a9d2aef315a6108c2126c2942b391d8d4da8b448884bea27f3fb14071393670652cb68faba1f0fc101716f70455750e0c87fc91d9c0f67c316a90771b8c3ac880e7bb05363cdb0ca33823c433b5559b02defa81266e5d3ca890485c0a215b416f1f496f82e4646bada82cd6776de78bb743a13b038f5040449ab2e098eddb4005cc3a25e474abed2ef6fb6f803ca5276272817c5dc7cdfbc8df933ec34e014fda7e4cc45168a2b1fd7211cac6d227c6c37a16a3576db3bb15e3b5f6da68d2cf3ca846b626bb965a88d6dd88d924be68f8c845d7f017b06430b72d67d284af4538c41ac7cca185579cb58fe4be8e1829b7fbb8ac02873159143c65d9c96bcd02e78f85531d026ca89ffc5ee2a2cd99972a86e439bda5ccc96a3aa816c7b664599a7c1b0128e7dd067cfb7d8f48ff57d83c5d3d05b48ce5a5297865616d0b76309f0f9f19c4278065efa695c9c6556afb050a130325dd0dd2d49b667ca776f7a1fe92a704cd23c9b71b4ca15913fbe9321b7c38f40d87a4f7c70e7489000faaba657262fd4383936fe7eb4086a50fcbc047de24ba4730d2b34f484f26f739f5ee1dccc963d56fe88b58cd72c0817fba119faa5a77b07c7b7e635064ca58dcb8893f34c98cd854ee96aa220c9a19cdfc95ea1e9544e257fc034302675473e1b3cd5f7086df7428a8726aff73042c2cd228d3dfa2b45083ff6559e67a5a5ebb20da60c83cb8e01a035edb1ca4047344d2933f8428b687d519898bcc364eaf2d57c5877e543a9d42a0e31570051cb8bf879bcac0a9eaf42b3a5dd7fe508b7bf5421ce4babacab8c34a979fab742a659185139c6670a5a7e4b57431d000005ef9170e0ba316211d33c2b24ac2ca7ed6716bdf03de7d19ff5e00f160a881a54b7eafbbc8159bf21e2b2643a6b7eb8e8553e449ce1d48fe076515ef719cdb99afe609150d1092fe74277ff8332ecccd31cb3069e84f91c7e8232b97dccfbeac1edd223323caffdc9c5bf33b762a0b09635988759a108706a2ecdce653fafac441746209a8b68773b209b8d579460919dc7f936ce971081a0408bae2e5f52bf8e666b545987c95759536b92081e1f28c364b81d940b27864dd2fb782d168dd54118bfd8486f2bd08d1538029750d04e0dfe9da6e8141b4846507bf84e94bb95f148687efe7d2bdd24838ee75f086e454295467243db3ce383ac7c9e32de3b50e6b482cfa54bc9d9ed6904448ec4de20d7372201e30ec54a4a4a859b8db31b2965d0c0700e726c2984eda6b9674cff2234c6dba306cdf80787071669fc2d859563fdd52434c7bbbcbf11fcbd6043a1d2e425c174b35c18b03de0de7e5bf2b9cb76cbd15a786616fe566b6dbc56745a29c6d284ff3bd53c6724d5712cd1ce22b85ef58cd631c3376b1ee30aad8aa9323cd458a0cd9f86015af4f0d0f7c66e2bc13ee88dfccdf2c1603d1856b0cb5da8e84881d0c51740d53f4868b0359d885b0d8300e9112f8b1ab17d1de6491131a7c283765b58b9f8ed08028186f98532e36115d7dbf5f2c9683ed413f8b3c02e890e3d1226e5602b8b5ef16ff68c3a1cea8c1ebc72033f5fc4d2e35e6bb6b2954361241f47df50ed26578e09910181f8fdf8e1e151afc66983c48d6b6458ca3eecbcd5138ab1cef0d91aa05348f24239921124bbe994f6abfbf9949742902e2c5295aec45767e5dbcee01ff420d73175a8e5e0dbad266b1f1c8771f45bcb4581faf457c06dd90b97b146412152d4fd800901d1dc2918c94982f33f352167709b37618473492f422612bfec5cd6bab26dcd19b6332957b139c5211f864f0e35c3508a5918dcfdfdaf0866c8bb44a0c35041e0e53f1e6798e07a8b82174e1cddb9d8112e6daf2273503e8f5f13fcfe15b8df6535aadd489181126d5f17148307ec82efc6bd836a6ab0f4d9f12a9ece8361335fee0922add631e52600e96cc0e3d48c61304d93a7ad3d05088a660971182f03278119043744acce4c11056bde84dfb36cbbc0c113a903788594105d240a87d21dcaf9314fcb5f43462928d1a70b3c610a2eb109d7a64de8c1007277ef8f36a0c8738852b69a88ce866e028b57418a370bc8f4c64c97d2242a04daba970003cb223f44f6d05fe237f433e03c6d2c5a386ba7c24e60f0207ee360f4199f738137a674a2462d5e854965ba92da1df44aed35aa12f03b76f595c4907b71c99a3c650b305f166e256e91c1019fa430be1d00d682755e46a67bf883e62809c81caeba9ff83b5eff1d5e581cd7a006c8b1acdbc09646f601d07bd4f9e2204f5af36bf101c1850f4f43a17a43e17beece753b59cbdb3df4c40467b811be5cbf8e01c22bba5bdee160ae9f2134d6b6dd6a55bc3dfedfdeceae7e04c7220dab8aa455657799a82432a665ab459fdba4e4aa6bc858d61c36bec1abf6c364d40604285df7365e071d0852e4d7c92cd76ce5b034d3020ecbf652ab72194f2ac2708065289d2040ca5321efc81db33c89f41427a64634db1b7a5e5373f823371e839dfebfbc4b5b82b15b97732bcdb2450f76aa9cb1afdc07de80817e991ac76f1c4a07efa74459622507b884a0dc8fc1917da68b06b3bed3f7fef82d1d93b4ef2251b88194dba55c5a203d67132fec5124d60959852271e9a15d22f4e673eea46ab7883689d0ad7c54771cc8db713d9e969a464355fd78940bc52195ab4a1ccab8e5cd0163aae0feb5e7b60f211bb3d2da04f01191565c336de43db45791840116de0e7c6a5dda673f2f63be4d76fa42c18d89b8af86b60727ff1f7678197896954f0fe605a948c064d6d6394fd7a3643f0654efe75d2cc90a0c16e6d2b3e49ff20a09c35e85de7a1da19db354ef3a934d083b1342db881ae96657e8d30fe0c5550570dca98546ef60bde58ffd8b04c911747b4b569f8e265dc78bc430d811d9d1942890825915290d789b5c9c064f36e1894254f9e559042edf71f1b2f7f149da551bc56f33ed60064787978616c4153897667bc58aa2fec4a7f255ed6ae349332d2cab9914c3555a6815010e8ac35997ddad044d0b22e7de0424ab314cd68cd6b5064375d0d5bcd2fc04a22573a3c568bff27d55104a63e1572184a889037250ee81c560515f29bbc49b5fa448455af58a805b19d472e4685b0fa7b61274b0475b3aacb89f8bc25d54988740fabc05017a5057410d0ba4676be7a36587f4740be6cec1ffec074a7961f092e217345bd1b5a3228ad4749056b6863b0fc6326e3c8f329307437699ebfc28beae196806f124e983f5de23ffc47840e278b0c7774dac6e7098457e615dd172a316501b4af8e8be56077f20aac31c690ae1fcb2c343dc22c2e34546a829a192a613e74ed44bbaa87761d8840cdc498c431ecce76e2d08a96a943d27f2e04cb4a0d13930778e6d2760f62eb2a094f08032f46eafc0235353754a9aa8a29d76d03097acc99da75f77a619246a82a3521260493564245d1ced0783c9b2ccebf7053ce8971e0dbad88abd105c6876642c284e9cbfde49c1fc322674ca518bb9c6491f8ad61f680b1e032f1cb1e660f6034051c38acbfc7e2bcd2e1c73bf68cbe293dd88d585b71ff710bc45711174d9aaf0a85c73d21f566601dd7e64c8ae8aeb865516175343f4264ddde68adcd4d86b71d6c6e6cdf9a306ad52e395d2964a95f3761556d942be8ccb09f803714b465cea92db43d4845a134699188a85cf6f4daeaaeb8341558ef812834219ca6fe25152b42f88b0605dd489da564fcf65b2a497a150899d8ff4e25d1ff4aa84d969a0c1a092469c5bc1d77df3c3a4ab59eeac25d0fb0d70923ed33c6018867f04fa9c4dd2cc4a9cb18720f09a3881f1f0fd4f8d695b9ba03e060f74b67195140ee7d851131d40abad7cd9f1e8e0f6a98173c32908dac9cd2d858421c418cfb5dbcebd6aa65cff5bbe1c5d656b907c5e358f058e1335d6aa0cd0d7fc5497e0195b374e02f99ccea9937b76a42e5ca762ab2f57142669402d0cb0332c84fdd698d08e544a756f142705cad1ec3744b520f1adfd73f7f441b066641c5d391e6cbd3c7a56c5ed4f7825cc765efe6f3c4617e989f138befd5ba5a72e4c3a5d9c5e33e48bb9ce43edce45319b73ae6fcea71e3a91d68e4b47afd3dfa6fbce7315734ef80a8899adb0aa27c2e82cd03e232272297bcdc1651ffe4eff1ba27910be8b6b410e5e92c7064b7db1433845a75a3a2ce4ce0e2f30e42bc3cb3348de502697d198d06f74a3c6b19516cb9db7bf9d4b69bcbd9dee593db724ee4b8dbc9f1ad8bfb944bc18a628a9145dfdbdf79c101bc6e40017934b3f83a5363a9872cc15579dc7c915b9f58bd0489cd4c65ea138d8f93cb20eb27548089d5a87b7bc755c2e54d666d5608f4846846477d17483a90e169e550284d17cb7280ee2ae529cd013d7fb4aee2766cc85c7309f95239dc8e19e74df2faa799977aaebcc779678f52378ed742b262b13022cf1584ea6b1b7ab02db0f5435fb440a33f9435f88dd60f17fb159ff41c0f814658edd6071e9fd8fa7d27cbdc52cf0ba34e68d38eb46216338019cc4a33436d4a0d7cf4467257ab96da49cdc3408797eabd8207667a9f492c09d68c5321c7dc9c74347c532fccc18c36bfb8efecc126188293aee9434eb9803ee01c5ab63fe268cd11e1e6550b28d561b4ad1c2027845d081863c03593ed555547a5198e7d91132900fa1ae3d9c02eb19a8d51f436dfede97be15691268900b6984b7926a1c61fa2c608122cddce6b8644992b052bfb9827d89dad1d44b7bcd426e1e43cb76fc79294ab952385688ed1309218eb263ac6e6489d60d61943ed5142662cfee4306ced4dab1767b64348afe7e161e6ad64495b45f155d96af4a18e5f450d358c401e33905a9a6c1f48cd67a21c4a6c71ea52e42692284bd63d4b5981ec4eeda38f279d37a4db7697d5e243bce1bc380143ee7237fa36d4b15ea37e02a7937915d847c0bafff8b88068aa715ef5120b2b6c6531853d02574721170dcec91a29fdf516f33f22094f22679be2d49fafc5e8ac32035ef22849d8d381a6982a10ffd9db24ac565498504f1993fe9ff0cd0a1ff0cb4f394904f14e7f4fd86aed40063a294f5ed8a1d6a9db16f8dcfa4fb1e574f867aa2f837e4569c22cf1303e03ac7f8cfb987712e6d58c0d713b556457f9e5f22f8171ffbd6440e3a8809272959abf752c20f0905efb2a229fd9368178dc548eb22d5447a859d41d03d3c3f3de92d278dbdf77f60b1de743c2fca0e1c54936d8e3ab59dc6685b6906c8ad635908db6031a4d7a9e1fa500b8ed5478424c1e69c946c1478649be55c73b5f5d04c15463b11456ea0833d41dd45c7f389bc5e06aec1efe7ad0c5706a6c9fc6730c4b3e11ac0b36096c27dc075d029817c638cdbe73742b8cae335e97b8804526dd616403af5c9154d067da96e514eb8a924ec20faeea965fa58aeb71a8b0d597556ff7f4bb11bef970ce25fabab0387c929a6f2a8806ee1adab82c27cd18b0225b24be5020fa6ab24c1588c235c2db720811ecee752698fd305f7a1c20ea6e1fcb5d2934526c28d35b698afb67eb7a9ae0fe70c0c5ece31d15afaa74f286858d4db271a343b708477b1703b9929caf5f8922ab0b31f77cff95afd1a7d40d02d7fe2ac62e79f5ea60ceb9cc150453eb48cccd551b34003c6732383ad56335048af6f2b2a137041b1e5b32905a95ef49ce34c3d8cd3ad5d3d6fae11529f266c9365f32948735979439a380200731b6b75ead9411fc975db423aaa80b0fba6dfcf452f1e77f51003fb55c6dad3888f216f3dfc0d0915fbaf403e39e2464384d992255edb8928b9ce7d0b0763f353fc35571fc5fced422b20ddeb8a24d0f16bd77ea36f81c34f80614ddfa84f56e6d9f4f0fcfa2c51eb250c86a5afa7ac281bb38b8398dff022366c817d61fbbcdc8ed3304606284aef7d9b544cdd292503183c9576adeb5677f1f057405f2a9d1d38fc8da0772c99b31710198bb701ecf72c4ace318e45c73ba11c1b99059302b410325c5e5a44f1ee8239c11cfa0c16b58cced5cdafe2d62303235fe56c03b2cbf448d265f2e347256e36c916ceb5c99fac8bcae5ccfcf155ee5dc4d1d3a1f5d0d4f95afb35862410c5400020fe6c188d7bd831d44aad191ee71c903169b82be5867ee75a8d418af5f075bbd613db68d03141875c0e23992c6ff7f18ab6cccd39e552078db2097c8613c81c6230d75d85ae425255457dd6b6d28aa9bb37068d728ce9523052e485d4f7728fbecf8a66ca619b5d1272309a5dc80c74f4185b1d3d7e441ef0fdf85e4353366988b28c623da8f4752c6f1ae70fd6782cff4423a69cf985381d6b5734f465bcc1b3a1eb31a4a182d5f8f46c3962a294f53f767724186db839b796bc68085b1123bc9421e52a57cab59ed24722cdf78a77abc0e56d93ad681533f008325fc37904a48e51a11bd2002e2133c36fde4a190f023bb14b1cff3dbe6c70088513f0c84cb9d1aa02455cf3e1766e40d4a32bd3678ff9887f3c461a1a9e35eca64a64336070701332125c1071feb5edc89b0ac0bbe86cb0e9852c6794652427829fc6fd9ccd0c62b9e6ce3838052daefaec95ab5696821ee9abf5384c45bfbc87198616fb3b079813f45c48a48fefde74eb2e5ccd0362d4bf33c89ce8cca8e38a581f04bc6ac0c71cfeca5e36c2cbdfd920a1fba32e35794cb17692ac4904e973fad8a1e3e47160fb34bed85b93402b5861df5e5ae325ff83f7088d665ea9896c026a321670912398a5c2fb29281616077104cd88fbd7b58f8c17afb1a4a3569dd6401506a5ee062bcdc9c5dfe9ec4de21af7aec7b11497c0a6a98e04e6756c6794d20ae24413411db5f6043c3296441917c9c105c192458d5f5f07de80b71f4f445cd6d478f55afb3cbb2ca8659cf90547cff708d1d480560d0700bbfdbce02b8277c18950eba4a8cc137686f05f0640bf6024fbc85ab3fc50bb0fffec25e52fd9c301785763f7d3bb7042df4aaf4cb017db6aa235cd87143b6973c4deaf6fc10d92500a05d5580826cb608a90ad48a090d0576b1b6a99bc1baa61ef6ee671de3f20fa37000b59ae0599f2e17beb1f96dde41703f413cddafb81d8ea9fc4e105e1523257850e95e5ebb5962d2e035418e52f1813e4d6b85e50417a6b9034fa1f0d8c00f1fcb1f1f93342320a3cee783df6d839d406123f5d60f6ecae890d74d3a7af4e6cede01f6baa36d4fde974f1436b4ad3d316166d3b0f28effa9da3ab5317331bdffe337ce0ad926b870d6c87091b2522d81928cdc4f8c02219ddbf12e3e32e10798b1dc949e6422fcebab78bd95ff7ed88d5bd4a78b520ef94c695be5ed7623dcc7aa20faf200b72288abad32a2bd6d49a6467330ea26e9435795e81bb48e3fc840b16d02972343513b62fae3cff1e3a0cd24ae6d308733a1e92a20070bcbe8a034b7236d0c9f8a93eec7bca0062839dff6f2ff06ff56a27a8f453dcd6cafa5d5179784619ba409244251d9eb5765381b69d2a16b13eace84e7176fd26df38796ea954a3db716e771ae02162b61150383d17f0b65219778653b7f67eb0bdd94b3a004caa3db0942e4e390c9e6b441dd52ecb0bfe55680a17fbc1206bef4f138fae6012d8460c9dbc85f70627261ab74bdf8befc246b7b5a8a8fd0f9c6374d656d6cd44e1f9165a41b82a0ee5dcdf63ba36a36a44c29882bd46b00f60306f181500440f23393e07502d75e13a7e078a350f276323a4c836c307368db8d7a4e7400b398382f7f7cc550ce2fd94874e45916404e47739c6010c5423bc3966f02b5cb126744224e516d11e1c3104b78af41081f172225d458ec13497eaaa71136b7026e74c6b50ee09ed8443629fe3b271e62f591a6c8f4480f6a11c3a16eac45af872c149657c64d0b090114ed04198b440925d4f6e0c66242c17ca8d30c67ec3173b36bff01206d4255879844c41dd7279eb349b1d515ebacb4bb3702d539119ba7fb0ef135d261cce3e2e444784fbce49e4a737c156178c4be0a2fa68c119736d5ba4b8157ba9c5b9809d35ca1269377c32df8c4ca682a4a722cb898b75900d71deb946d73a2478215a1245c5f19f664d1cb52838a5df9a21b55d9768b59b2fa84bd4bc1c15b9fd3f1e25d615a5ba4334b0efa865dfe3b14124b29818326ae2bef5d7e64bb6dc9f7961cf98bd251864b4ae827b4bbc071493c1484f4164f6065e8ab17cc7c66a2744af2e1437e0dde4f131faa9f4bec1a342863176a79436401a845941737d19b2671ce9c7477bbf923339dbc6317090815928f8dd2aa72fd601878c961701b9e3869e4c81c05ccb48ef36b100f215e07ae30cc4f64e6b446a9df6a3fbbd3f3776f93ba30dd322481c06414006884248f9bbd8162e12a2dd4e2cd882cb3a327e3f555cbc1d5b5bd9d9bad7d179ab7a411dd0397c47dc68c6d8efe091947d96b236a987618245bd49c04e31788e8473f383aff612f2c8c73c8f1b36e5f7e566a132c24fcb7242212356e3e7ca00670f81ddb50a89c178d2e76db24f24993b34a26921320b7f40b21a472492697d200a3a5acdc83e05076bb5189fcee3294db2653fe4a5c7f5356da4494c9b287a85c51ae82ddf17fcf62067ef913a9019a733dbdbc3182501232ee959886eae62ae6116b4f1f9d235f53a978a405e393ed3f9717dba356c4cd537299c668b32cc28c990512adf1b189881c34522f1f80a317669ef1e9b1adc1a585633403a8afc127614983b96c50d7a74436203eb7fb66efeb75edf98ed369ea2431e8ec2945ba07d148d402284917dad7e2598076310b28fc0b7962783db023cbb3f7e459618c8cf41f0d98102099c9fb7eeb741e509b571706088af33e98a145e6fc25b74db15327d2adcc7c9ec55e57367bd8cc476a6afd2ea7553e296f7d3e77873114a9ffe6049c01aa328f5a10048fca32e089602c810a60baa6193c5fa4834e2963df5803faa8685691a121ca809c465a4143bbba1710ecac98d9e44b383cbe52f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
