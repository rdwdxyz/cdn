<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"543d9a14c3b617ff1b5d5bcd4eabd5f5a06d0e56a216783e48f9c226e6124964c0e3eef18e606c92162a332a33678395d86294415f3122342f8ed6880f3144b25fa7d7d48539c8e8cc892e9c2a5ec84e94124bf641305c525ef6dbbcd4ffd9574a8d9ea52d96c7287f10257784d6e87985d91a222d9ccb5c6cce56979b03c4baa2d4a26976767d830ac687c0f5aa5cc59fb1e970be11e107e722d0379b5baf917bcc133999e46822f21bc9ad34a35699e2cffe85f19e839a2d1ddbc031e2a4ef9f5fb2151d98298a88b0cde9eb842300796741a63fc555372c24f0fd21ea5f4b08f809628454408817296f75fb7aa4dff130e7bf36e802b85a8d25c01e53efe411ec153e3d1a414a6341fdb4674ff2c9670909c6fe456393cae417265bd279f7c1d8f2d68d8bbadb3f36843debe16bd324aec9117b6b698bbcca5b3646df85ce6b4f89837c79ee147307a995ccc7fbbbf5651066a739489f25601504bbddb949ea1e0e399d6bc04890a3389766a99ad87ce7330e1cab1adab82a83c452760d59190e9d09bac3f68bc70c74793aa9f12133da2215dd90c26fbcd4b8180fc8acb8fb625131fc4726b80968a2e37bf1c31a60772b920bd1cb3d8aac03ef3ba77ebde6d0e93a1a95f5b241f9ecd02fe57e826e4144261a9bd828b619506b6e2bf1acd440e19b1bf14d44683287c46acc18ad5ba70edc94f5f43868d135dac44caa1948b3e8ff22b36d6b47eb3ddededa47e932799611c745349275e05a61309c020be53250c5d06da1229937ea66e846febbb43cf2eba9602369e41ab356b48e0a2b4cb937066fcbf93a2a532c14a820c4c43cddae6e865ddb280058204291ee12283e57057b3f5d2aae0f7e7dd4c6c21b2990e28a6af72d41754108fe57808ee6e454dcac76cdcd3ee0f7f5760bb28f6d538d680aad1debc51ba9e54cb074dccb068ca939cd1911b0f6d8da7b192a1ef9b0dcd0600d2585694e62ee3698b0894ec887004793e4313508a49c2d09673341cd933e6852bcede567981fdc7908b4e3e387c4199a3f05fbff8b18840817b5cb1db1af6ca85211ff5517357ead10e66ccaca3a3b6b879b8154ba411581471e614c137f371eb593991daa3c482d509639b43cda21e8c66576fc14004d0d3b0d11e7f239103169f3260bd4dfa6360c45b5f1302835e7a3e7e6a2702564ea577f350bc0abb739e25bf4a65f5f89a23d429afb07df3291133cfe04b710c26173e968c3b25afd2aa3b99212b740e9b7df5fe188abd27c383d11af30eab0ff16f17aad67dcc3ef70b9a32580d031a933cfe44724ce91c9366b0dc7edaada5c090baac67aac9f740fabed10549f3641333c39e7edc607590015519aefaf66a2300d970939d97db04db34430085bd9d25ae7d323b9049150b26223aac558cd2efb399c0b7b8d49ce35525f9cef6950524ece3858ec62760c213a7f0a7126733eb9072de5d0167aac6f81e8452d5d133efc72db4f9ef2681b8d972128154a67548bfefb57f363d2bb227f826c2ac78749e68ba23fc6aaf12bf0e8a5e424062c11f520e5b3d016f7dced390866d0717f3da2d7007b25ec7dee49e4ce7a1a926a4cd86fa03cb279656b1a976f080f544958e19172f196a61fe2cb77d0f8854f50004f5c0a6b07a38d5cc5ae70ea981069a63f53e3cadb5268beb433130968bcb038553b359d7013e5e7fef7688eca873526a22f6ad380e5830872a861a68142d33f8fad6221972c75c4476734ae0ab8fe3393b6b534c00e8589026df3a1fb396dfb537bb0b7a909327cea2201cc2f2894f2feca5702effff3ce3f3dcfd285dcf20d0ea09a84dfc9e5ba986dd946e9f8c0e9849f37fc83836b221f7387a1513c423eb3c8926b66555094c07a725ee985066b605775d8b12444b74786ebd065944d4111c36a0b2c13dbe832592f233d481afa03517559cc0ef1eb9b839058b0fc873d37d937e5174b33ed27b81acb6a3f5a19913f8c03c719e7c7aee254607d710ebdfdb4ff83856825d36565e35e009d717b3067a878a861bd4dbe6fc24096595e213bbd387b03f806308e94813a675a5a883c58c6764b542fe5ff7d1e99ecb514103158a07811f1a173dfa99d9d3c1abfd802b565603de4f661a95e124ff66b766618fea996046307f80a15bd3cc02adad2028f269fab3ef327f548202ed88ff3a7cd7db61446b2dc067fbaf7a99a916fd3be0ba13ea4498239c9bcd1188f25d3b1e6058cc953b69cda2f58b1660fc404ad169c55e2621d5fe288ac6b337dbaad341f98562ea34aa684978fbeeaac85699bf23832eb146afe674994f22f3d34082b8139dbfa8637346d7930a5bcbc1b7c03181b1da592a9480801d6e7713e6ab743b09135777633fc6db46b870730e2e54e617c6baba7c01f63cdb157c4782a927de6c78bb4649255b9d5eff222d69347688fe45eea881ae4c394361b79987f72fafffc9a0d67989d2b20e77eaa7ec3ceaaf5824f40242d6c707905be45f77c434396344d5c65f6dabc4d9a3bf6c5f53db1745a52ea8ab1d2459334a55ebe1f4c768506c7db143533fa70c1d567196d1090766aad7f11371e625f12fcb641a4cc30e033a4259b8ef5220beb1b9c7f76475896d4cefdfe7d72a4e10c8a8288734329589f3c8c50d05d961375a53164c6394f352bfb5e7e9995d45cf2961a7350a5a8b9fb428ea61971033185676ef793df3381aee51e019d7d7675c7dc3ac653a0c140f809575fd6b18b2000c608cf317fd413a4f6207614c498b044c87efea56662e0ae6fed0c60428b0b6e79849c858b3a4d6e974ec0d7c250be6342135bacdc02c7ff6dcf9cca6cb700fbd5d3176412bca883004d5c76fc1d0a2403343db05b97bfbf32c583bf25b0bd53ba10704afef9035da2bf50875bd093a49813bf8f96c71b5e8041227e68712feb3c11e4d7eb50fceb5426342a456a0fe2c51a134e8ee0707767e284a4974c817a65bcff77026871590cc225fbbc3b3da381f93b2f1be8555a427018ecdd925f297a28e689c7f2a550ce77c515b5013898feb9947e433c2ef0b93d6ad9d17a37fc8be053ca119f2b0f94f8137c4b1d0f125d9eb52919d1d9ffb9768269307c28d939d380452d9e861e4a68884fd1046c51de72f4ceee430468760ac645fcfd1c48d58a3dc91c743b228d63bb9eabbd7fb524f0b109a82e931da60632676b89ad1c4dbcd02b416fa1850c52f35d2e7e1a0250c7ddfe2bf39814d9c5bf8503ba95ad6db94cc405a2b3ccced17b554ad2ec2b6960133ec133413b9718d4f221f4448ae7feaba6e87dd0429bfd758e5942cf7e6eb8d9fb2aaf6157086dd89debc2a015dbb95bdcca5a8e519a44f91c4134d8b94b61abaa543a8d093950a7aa5f23245c7050817c201224f9edc19d207ed7600c46c02862214ec4bb5da84c925b831dd8d85cb7fe26117281e7f3a90f53f7149367a0d7ab1bd8ec0c36d9e45d801b7ee325ad67b78fdba95b38b3ea8c0c28bd67c42266d5468488fb269d1531c0360f17b25268131b93230cb681f85107d9a2097a93914d7f790d7b220b2c34fbd8c30de5de9996a3de1a5220c2a3aeeff3a67f9e0dddb248b5464574a58329a82606540b42f9300f10a0a72403d2331b92f16f5774e98b3a0c4a93bcb84893b11e1dfad117fa9ae9cf3427ed3801048e583f4e988b64d25cd3fc98345021fe994baac6d90d6f486cd5ae8663a2d8bb75a7a428e6df254022ccf261ecb89b496ebf11d3e2861bac23f276e87a5f1b9732622a11b34fcc712bfbec0a24329d7412f1ac39522d5ac24f9a477bece784239672c4f2320251730539c025b8904a0d022bdda429f84c1558351b6bbc560725f258346e02a6743f0f0988e129863c1df7c7b2e2900e95321990cc5a6c41bc2c9efbe8ba28a36dae5e6b99e99972917933956fb355b1103ac0fc519fb3b470d6d5e3569c6953a220b7b969e2a9c6092f490c978661cece94390ed0324a3d8eb0f99a62349d928723c59434d7dce804b47c73193bc30a3dce09153c3a9060e1760f991d37de0db21d42c10c9b22df575301c7cff46ecb6999bc0cbc6f27757f03bc2f626c4a685124b7a0caa6dd00d200e1863564eefa1269b2e52cb9cea64aceca80c98086c84fd405c04e3fabd984fca6c4c25d6fde3a62b8d5020b4e55446b8754267d850ca9c11f76a6b135541272064731101baa807f73abc937e1b007c7d449a39c43f2537526ba49356fc0cc5c7ee1d9d637b5d67a6ee2310ce50116a42f5aeb3c5634fcb970b1a95693c548d0a8163a7f7b6561d87032794a8d8c799f15fe11d79de453dca585e4250f69b6190fcf6171cf5220fd887cbbbb46442c05d29275b40da55bea384c2182c951ae865e3d131ccb0e7cfd87bad589405c8bc5d030dfd286a5b95ee965b39a51b0059c663974be420916f955ae87f4d59e5a64b40cb93512c25d698ac82db18ca3ca98c42fe0aeaee8cff8ef499b2806b2bdadce58fa44ee1f8d51d724119d794e6b10520bf436ddf17c3db2c480aac99c1eec6e1d13f2514bfaa6df412154ef7e02e65ea563884745c0ed20df40aaf07f37a7178bee687ee91fe0f230dd911675b42189fcf38749cc6c3142d82413b56052214532fa6f5a508ce4c942bb3516d2248cd3c38e7f43fd918322982db9e66a0272d8694f2c3344248694acb338f1e1f5a62658eb0a80e97d4fa29b0ccc1bb3846f98c7cc085ef9ffad2d8c2c0bcb986d67178a452330002574ca1b46f1ba75dcf1180fb9a4e3bcaa986fda6deca86d5e3ec9037d1f02ea16d401a40aca6b627427af9c30b184b83d2ee3b30dc9603ee4a73a44d3565e44ba93a0fc4ed8f94f29dbb691efae452acb1760df2d472c356d90fa8a8333e105a6f46a2cf612d3e39c99517046a9a7c201b6aa929665a0b7abb673c430bc950c80da89ac3bb307fd8d19fabb042ed587cc5e2490ea865b94ab9c07db986d77d0438ab14318b8c4c82f7b81586ed50632629573cb8419bc2426797869baa859ee47d5b777b3e2908fe03c02ea892eeca00df5722720edbd0f54dbb4e0bed5f31bc31b9f097ae972f0d1fa215df6868e9167cad1fb91760c3cb75fb0bce158bc28e31d3fc85fd5b1a61ba68df17d1729b71237fcdef830b04b2c892743254b046ffe9cba2fdb2a9ffa63a2020aa7e7f32177b52140c4e924e7ee3fcfd7fc7127229ef097a533604fe0ca3d2704df20c9ae6a54f8c73bdba57fcd53a9fba816c8f4c2ab1d22658f15b324cc20569aad39c01bc4004f63257a801f5c8b9c0cfa305b71e38386d2c093af5c9942e2e92b005a34c4e3ed90c4692bb0185447a8a120d1fe4d6c69c5c79b446b0d66a7c9f1bf2ad77f8e21e2864eb7f069ad94037fe844f61e8efad66ab48830767a50344e1d132c28f3a06f37a129f48f5cd7d66f8d587e015ab81b8eb1d8f5c609c90ddddd45bf7c4d80c2a982cda1a1b321069c3e0c9554e3bfb52407cdcd436bb18fb47d8fee9f000ab7abf98bd32cd3e360da12feb1681fef0f90923ec7922c2cdfe988e37c6f178a63518ca8c92faca92fc18acbf7a326106ba576b64255359bb691931b2357096f92d855034a11e8c56c93abe1737b26725b238eef5f759e8ff3f046e7481aae3a044dac22b39a8dc0a91bb7edddda5fc5399757738af43190a863a915c5659e48a760cf067b8a581fd68ad10fc5ecc860e5b5d28be3b91ccd7767a1a9fad73de52951c5c0ddfa83ddfc5fea3f1cad6a61ae5681fda329a1b05e24d92bb3ad660602bb9a295dc5459fe5f1f6a2facbf59775b3b56ac021d40facae89f8c3b540c7e825dc2fe9673aa3d1667bbd32099d22a309545d39a09f5252f31cdb01ad3051d72b9daeccbe760faeefba1e7b2c02b66ecbc75ddb69c6cc195e186d8118c3d47be94d430d9d7c4013136af537d53e96861398365508c23ea495e2ecc46043261c1b0cae3720cb5d47159f1628b8eea194ce823533d566c1ab80c9b0bdcad86aaae6423ef7afc4c663fb8e632750ff6ad4059cecea61d08fb5fbc385dd2399f26bf225864d27cffb175528b3565898355cf4ea3b097e4519cd0c2ea6e9c7bbae2bd09f734952f0ebd909b268e18819e51cebe8c481b5685f92e8c75b5a7b8ee43f9f47bcf393ce78fe87c2bcda57ebf649d8d2de49b483d896ff80dc17f87e6592dc4793731b153fa45258fcb14c8f3073a84c0ee338ff8641eeac8a73c8977c99b6488dc7bf7ffaab2b8ca9e2433e861228501458a67e205e40fdc443363695a209b338ab01b555798a5ec271c3db5d1eb45ed51ddb9a4d162884edd856c57b1feadd96efcd69bae62d87e2e17459585a666e40e3d80cbd4b571e2bfb77ccc9a2d457489bfaacff703993ced67fcb9bb81237ef0ee78e62fab94173e4e5a71fcb4fbc7c8bd881a28a4ef3d91dccde62fad860f572fc993c8ea92973ef4daa23b37a1871a2ad743a057d84962ceb25b093f018b0022ff0418577178026b06a0678e95db7c42fe12800eec7acd0d52f60f3309b3f0ea931c45ebc1211d6be3cc3c14b6a5537dc90871fd9ff84c5b38b73ad9595761103fd3ae23585f7c75e36d5f5de088cf3452b2e75f2fb9903d746be05ce5260072ff55d2b1582ca5792d28c71dfc36d1646a99d40c805613123a05710493944d6ff700581ae731ef3ee52559246788611da48d2ff8ca924ab1a2684e9247d5208d7cfd33ebfd68e3f70a3744b3e8eeedf1951b4bcd6d14be772a20d5bd332ad515c07357e35a1a5cb55384a086fe12e94cff53c0d2d9b2e628b87cffb77e0bc12fb572c4cb1ed8d9bf375c235625b0b596f9fd0bd92449b0fb988aa012263ea1b8aace75e631f83c1c7892515d971d2e06eb808f9f4cde3069aab7541d8fb1c47cdc178c3a75a223e82f775ea551fefd1e39f3b644699f79604c0953bd7c3133f5500984c721cd807e2b692cc85194fe2197209ece22ca9c403905437e77d60171f611fea5c7725975b8f5a2c03ba79388400cc5a54fc82c5840bfb11dc3ced03d6163d032d35786ba66535c11e2ee3a74e6ff442b7c0a0bcd44bc10f538abc1cb8c8e731e8945cf113203b1f011143099e0c8f3a22b607e2347e239bdaaefd8b0fff04ba153c0f5c9889bfa53e70be5d4fb5b6455a322a12fd370fe7aae3bf6bebd4aa759269b8e34a070bc3694ef5e1a89434a1f20baba88f12f97fa8ad2172009f1d7046deb3dbad8616d42e368c2dcdbc234d3ee4fd7be1518257ac04b851e0059021671543a555f33dd29d6466492aa137fcf285e69a26b712a708b4426a54639a3fb86ed659cb662b39eb529d7b10530334db4d3bb5167f9b32aee15a32b7b5290e1bdf3d1fec4e4f3371e2a126e08409f10e3c8d53e723cd13e04e771b18730e87e5f10aab3d0168816f74b83de4fee20efb0b0941e721037af40d0629bde14a8f91e6bc2b02745905e5f0c5fa022b0c1bf4f982317389b767c789aa06fafab19594724879cf9d50dffc6afef5048ab1a4e0c4234503a7652c9de8d9088060df8b27704cf5c0af03cdbae1720052f59d86ff8f01f0d1ba309fc100b931d80c1d812fb25834b7035ebb6cd5fcde0d5c9e7a109261151181912d79c70b93fa2bc92b1039307e1637a738620e0fcd4baa1255baac045a9d7ddda334c87354bbef4c2ed365063fea6a6576e455a892c2e09f08837b375a96fb4c875263c85ec8cbc0168f4aec18ade60710d741a1f199d4343c892c23a559d50c429321c894246297ac2ce5f7831e83f9e34b0117ec399d570bb8ca73e550e4717cb35e3115ba2e101cc13e7030d11ca0dd2b72c9ec319087c17a6c8c1a3bc486bcb6a804864562eb605ece185416179f629985b1b4e255520b36fbcc261c95901e8ab61b0290845148f866f318657a3200ea17a06290165e54e2f133bacf075b80a89824c5362f26a3fc21aa7706d475a3219c971bc0809ac5a4f4e95d711b113d92b4822745445918091cf5a2a38c1bbc6447898b60790ef4efed8222252d7e746a99bdbe90b74ca40902bfafbd6904bc0744883cebec1ddb7a56975bdf14c9f1bf608461c668ab19b7430d00b49cc6b8d40789ffa4c98a8ede632d75706b7911fd460e6c64a66d12cd26e1a7a75bcf76b1e2fbb4284ef7b93fb062e2f016d0ef602db1a5143f5c8368a1ac7b29a3b35cc651135df1db3ff58c2f71d28df1466eb117390b342aa0779adf79c08c6cf01b6cf4efc9a8a9d55def4474cda82cea89587db22fb18e42bd60307e665a00cf977a894e540c623f74c4a2a397d1cd917f0529f334b9c24b197a0a857ccd3235c8cd4573ac6ae8ceb376339fc0d5c306ac64763519acf52795ab3c5136fcbe5230395fb6dceb78bc111ccea54b61fbed746a6aa2d341d62e377429345bea168f4883ad9582167a35949ba052c05c62776d2bfa1b00b07a3cfa3f29264e0df62d443df7f0c505612a1f5729d4d6a9f86dafd0e79b1aa920c61732b30bda9f1d083efc5cb0386c50f092509da8c3888a51e9ebb8577d253cfe6eceeac6d1b5c1968200c2ccce798b899e898e26e423d5a45bbe2bb128080a2964ae51cc97287bb166f8a6e8a63778392f5135ae6baf0e5554d19ed67b25d8b7cd88ccc7344c6df28b6fe808b5b97352d4424e9727b496aa0bbd83327bd96371e6c1d0554eba6167847076dd1b4d13b5c915f5602045cd30815f16aae6c3998bb39dcd9334906c29c98a515a3f598fb747b87fa5a11f0cb9f08d21cb295c8f13b45079369a8a841f14305786bce507a4e7f498cdaf5a251835ffe2e4f0f806d71add23b7d5d3319f3a4ff1410a5ab522b313d81a2c5f2348509c6a67429818c14b43477bb83706dffff0e43148479e857f764d8eb388dda08557b98149e268a9df299949b2c0d49af2070a48294c24ac6e38924c8d93c2fc753fd1c6afb87a43746d99697a94061dd3aace2c54b2559d9359aa9f1db67a1e7f12c8dd741bafa569072bbc2c3e5b3489f75d8628429def06661a82271449b2d5085af7e2c112581dec12033af5dc80792e3a93ab3e82599195c7c085b959960d6ce8675a08e39661176cb7516b88582db11f32f2f2d78bb66775149dcb0eb8b7b9750d4389ab709b72001d027ec19e9c6b173623fb3c70a3fb32a4cc6cc3ea7aa02cbe2be26e556d2e824d582b3b66f3230227764d9c85a01d3896ea537174f02b8c6965067ec90545d81a64570d51dea3124fdf3eee35990c383210510acae9f2069ea2ab7a57031b2dc689925beb4b937f74288735e9d249b34148a369625691382132d44fc23ab78ebd4beaeacad92f91279470d7fcdc8faf5931a076fca7ea0c138f3fbb2a375914bef02d0ff7946abedf058800f7aaecb87e1b94c9b1bf02b4104e95a75d5f35a86e59c1d3c07d83f24d9ffcc830298b88692b7d4ddf133f0c124f06c201ac30dc6c3434a1e5e2071074bb5dbf1dd8ecc9eb19b78caa2805f0d6ee87b6eb8d1042af6434390c38cadaa122c9b9a39b2d9b6a27733fbc831a4ad3fb15e42f7b84b5725e9c08e0d160bd519aafe7d1a9623a1d77a39841e2008e9fc98c7b0c8645f62e28d107dde2693ffee88f796ca6c8fb9cbbcd1dd8332bab0263ee115f544232ecf3bcad148d53e29c6bd40075447fda752071b771caff743f5d84a52986892276af894c79f206a708a1b15761bbb17fb84acbaedb3eb72f99de906c928f5f42d00c7ee1ac7cf622a87c5f81402a6791dc6dd89c40c00ba334ee10b7f5984c5fb6278a8aaf579ed5428b200c9e4f3af7f794522f2f29254e6b1590d35a79ccbf11f7d487b11f62368814b47e8914e42328b07f07ff6e0ae51f9a4808f8b42307f04086d84df49508493bb6939db1f64b59c9e2de9ea47fcda78b03ca1cb76480ad7df279a29fe5316442a28372ab53a1f3cac1a82b3c1d8ae13d74a21195bbb19efa22fceb3e70a96682b900fcefd68068340158b3ca3cba873b83a4a7063bb09684ae374008fa3011d74224e1f11b32479025bd5bd971ff27fbadb8d3e9bcb5dfe4bfc7b05bb1d282cbce7420a5bbd7de8f535ff11c18fe8376a1c36b4057b103b427267803ec19878b25905a6019167b05fc433ae2a7c7c3532b9fbe75fd6a6f251e10334741a69065a74b63011f03f5d1f8407c2b2329143dfb4c31b79fa64cc98cb235655be2aa86ee1e3c787521371fc36cbbf632dbc07cebc9f24f7bdbcb35c736530a6897a3d862d06be553b5bac030eeac86b52526c1d390d56c8b073e619daf2f3178e172f9348e63ab19f6dcc1aeb7685152f1651f44a850a83bf55f8aae3143cbdbaa31afc460a48d0044513f90b4295dba728caeeefd5a3e4c81504b331fe8037a0bb89fe209dcbaa39e4534423344c199b8a5c87d9a1800b59eec29e6abda31bab0983fb2e476f087c5869ab52eaac2a24483cc258970de45ca2696cf103e94d76fa70866e96edbd9c029de7859b30957f4ea32a0613049b190831a9a28959ecb7c7742b3e2045b41777ee1aacb946f9e93f9bf4cfcedc9d6847b930b19a6c9cd5c3af9564e9ed5ff316a2e81cc26dd99a5fbd0d3762aad0a4c8e0c5b10c1e252b79f0befcc7d4dadcf93f4422347c5b76d39091065826d46a5382a59ec86f8b19b61d9805182f23e10bdfc07d35049344ff206044cfa8259e3e54d7bd107377f03055693fa0f2c7ee9784e0291bb36b6cb4b0f989845b769115f8c4efed0ae886fbb8061e3e4c2cc33a976d66fe705b0f50a7ede8b365fa43cd79420a4b55db2565538cbb3dc2bf7e1f8d3c050d929581059d8ffa9af0b29be5699791cba60ef991c89803c08c3e93c7cd2a2ae0de7254e575f5cc470708171a0961afd8e7c944c3d4162bc514981db81edae72fcf7670b12476c2731c23de6aff849db16142e168a0cc4341bfd65018b5b677a54abf97afe25f5da5b73d73442a60596f9d5ede277a86d7f56e58b6922f5672197e11bf5dbc91e0aa1a8efbf79bdec63747baad63fa8aff3357d4032c5034cc73cdbfdca32bd0df1e396854afd962a5abf058a05a88753a5bab0dc85339458a890f6ee6316840dff1001b853bd9ff68f7749c7038fef30594a5850b3092847ede9837476c2524b12ec5df6863da92677ed40dcd5a7b3e06b4822819b3f6623ce8a9d126d22682ea42660714cc532daa7d8dd9b6c2d19e430a6d38e7791788e47e3a098f1840e3eedd721e0061e0194b134c3a810bec3561863c97e36e8ae2e989d6dd8853fef2cd19f6ae8683370a1c1bd62a7ecfbbbee82a43265995e2a4d0a8903f93ebe036b7165d10ba8565235d330a33ccfcfac9086f36f5aa205e4112bf3bf75fbdc11d948829a1329723ebcc33bfbbb7b44ec53c99344056ad7620b433f3bc7d690da85328af734fcad6daffbcbe2fa6fa212328bdbffc9ab71c2d3266a38c1ad792ddf6cc2289c10d588f1ac105816b26abe4a1c34eed6901447f536f93032bd702e8bdefa6c3d8157554c13af7a1a95cb59150ea32ec23e4655251fa37286272beffbdb64986dd603b268319ef1f6d9c82dc26549d4d5133468451ed339249cce32bcb07df9349678518c21875765dd7fdf568c00cc450f2b4c15d46fb5c67f24ccf35926ef3b1b789eb57a89fabdbc6cb51ba59f7c9424451d773368a14186240766093aae0b5d790882802d0c34e8e5a863db2d0ebaec943095237e06e759ff5627af1e9063107cb28c0be0bed1d639fae848be6f50b8099949dd90fc181e330ffa4f82daa655a55978604fc3ec63c1f69df2aafc10d77128d171841f849f3f7f397d01ad80255a41da893f438a2a2a5b8eeddac2776e819731cc0dd4adda5b2dd095c31c6de6f48234c55b6793d247bd8ad595c9968729ecc777ccf45454fc72860288f60c6bdef1d6bcd8e7de7d4c7c155edd958e4e878edc31df7fd1a2f1af16582d90d22f680e354f8eb6564ac69d6c2e99cd4d1016704c6bb295137503f9851e006bfb8017b8d0575d3194043e0838150a5a4b6c63e1989b0e297af559fbbf8006fb4d9985f03adcb31f9e96ea9ef1e9fb5396dfc81655f28402be061ab82228871f9773057bb2574cbaf837ef35c882ad053de895c08a60b6f44d6d14e8c56845505c9f0275956fddd8b16b3e671736180d9f8ada136c4f3a3fd3efba45a2b924d98b5f6d9484751a80534fe2cb2130160c34b212a3d071362f5c23c11b99ed298844524dd930052faef8a8f68192650367ba8381f0f6441de8200a3f064fb1db8f0a8d26c0b295db78e28c8c6bd366010a2aec587cda92fb9bec7fa711c17718b4215d8d61e3ceec99df95e09d18159401abfe99e7789176543229d469f08d39218bc20ae9c758cb1423ab41a3fae81808e931302bae8d4dad2a3a774355d68ef8530a1c1d61189902dae26ccc90f6678e1fd59669228ec112fb0153304d061eab63f3192d49cd6093deb1e6c0cd5a3515d3b8023571f93748f64ad0aa89bf19e7e0cfd7a60d9388cad309e818d255a82372cde93f9dbe029af9367787c8bb8e1f395b1c9489546d5ace6fefcc9c04fb2787b1fccbbb93395f22e494cec89da25dbf96ffe42dd43fd655fd31ea5ea9a57853a17c5d5cd25bfeb1846ad750d34bfd67ba30c5864a2a567ccf32ecb46a2aeb80d3f50653fb29bd3c3c61153696ff60e082869b594b744574bea7410360ebd2530ffd55680ee41b2e30b7a8483886dae150a10bcad26d4cd8ce2636b7c0c5a9b6352f6f8502f962151274709764984502614db16c3bb3c3663f142f2a1e0d3293589f9b9d03af144089c493e74ec8d212b3761b08a056705529952c88e4f1c8aba68373d0397c80831aa40c815faa3e13d931d6de131645d5dfd5a8eb620d9247ccb63c25d188da733fb107d5861bed94c6f930e57aa49987b1a2e09fce0c961d13c9b5a88466556189d9e7d08a2150db1643c8c8c33b4dcf5782a1fe981c3db506d9e07ed4c25a2a710f38af7b0b6380dea8b6041c80eb369efb99abf3b56925d6205424054a0655bc327fdb4619dbd35e0c9aed1991719539c638f9e1a80182cfaa2c4fe0c56b71335bd212ea68a2312b049e3f5fad9cfaa43f71d18512e08ac11a62e5c89927fadc2035ab8388b08aebf31022c04cfe55a6709a14515c6583ad076ff0af38306089fabd4044dccebb58d4e36f4a9571cf371632363d9a5cc224f27283df38074ad0aa51e3fe467535967a2b1c2ca9385ed040f0963db6aa7216b7b916f256c7f6889e406f636de20499fe56fb83501aff5e3584651f1cb1d8897d5797f2eefe8b0722af94f8c521dc3376cdf6f202d898e1601bb8510b4190d9dd96bf4509803f1eee3cf88b4b0c6ab707b72b0d60ab48920df319208be040b1197d3653f9576e56ee31fe83233ae3ba2265b7421f257dbcd9b38171ac8f9e61f32bd6065d3c44230558d4beaaa0eb2c2415c2f773cf3eb30ba8e44dd8aa48fecf14b0de4150ed2452e5aef6b26bdebc238d98e5e4f2090600d8bcaee0a5ead9a4276545547ea878c8ce854a9eea8fc951541667ee819298b2faf59b3c0d323cfd859bbb69c4757f7af65b6a677652a36e394a640b907a14e3f5d2c96d6238e9945340151393c609057799dda49ae7ab7c54f5c123995ce7ad861e19aeaa19f24ede16259a4a82f1df72f6dd5d1a3f2aa12194113918d86b353e1b734233ba4c35fcba6a7259816c221c4dd5784dd2173dfe58a889373382e034c1b00a4011ce996f68aad61bd7aa0a89ec5008baccd61a446461caea0ae78f39c3f502483e81429dbd687e101990d5a9442665c76197a5b49d7198fd47ae74747719ac22dfe260a415413ab4e9aedca9c8f1f24f8eecf337b5b5cfdf00663fdabe75a48140332e5781694085c4cf7462576bccfeb2d1e979dabcafcb98545479bc301c03341bbcb3f8e94edcf6e221adce2a317173ab9606c09ee78657a7fb4416d64a4ff5566ea239abc106e427b532f4507cf6ef3f8940a7d254fe9ba50793d129df9eac4862ae4246e04d785af6895ba939d11ed42421add232dd084bf0d5597e9082fffaa7db65e17cb7205dbccf48f918b381ab32131a4b1c3098cccf9a9487569d29e963883141217905d7621313ab7d77a1bb88e984b3873ccacf072c4c51ffeb91a1c4c6e5af3ecfaec0843ea29dcdacf7b886d110866658d76ec95f0c8827c188d5a36f8079a3bc4e419756eefad9e0b2d9095ac6429b9d484f294f63b9d31b7b629a5cee7f5972f8ff0c0decb927e610532ea8cfc0f3dfeee8998533e819fd62704df108323d79881353b86e4505c1015657cb306ffa772daf4a9d2a2ba9899aa5d5aafbc7ba7c2e7e4a82396d06dbd356ca7520523db17c8915ab610330b7bed4717ab31b3da5b3e1256247b16eb7825a0328beae3f67ce9df5a24f7ef589d1f69d93077273cb0b3256e4548aa7106ca5bfe277c94da6cf2f4866f0276337795c44809d143bbf2ca87856b251fccd115dddb6c08c9a20168eb8ab22f1cef426be0063d5fc30473fbdb3c8525631fb8c4aaf6969036cc1b6b887fb8e8aaa5d69befd87c5c8b6f2c841dcca5d6ecaeef466d04c4f282d7774132973e6783a6c162368ea50e2a34057a854194963085c921399ae8605012170254580b23dccbb2b7ce4929adc8b91d70e723823c0cde25c8981fb485555abb1941da7525f8d10ee910c5477601d9de2104cba3b6fe9bbdb8633b57533a7b503724e65f7597eaf6dd95e1f0e2335214d28480d2dac0066b96114483447cbaa45ef9753d006677bab5a0f7da5c89dc0884910a11772588d482b180623c2cbd38765868257ceeba617d2b349cc928f902dcb041f8263dd7bfce6ac0a9069ef50b15df5250279e42d55ef00d4081ff3d4a912080e6dd0f3739492900d8c15fae97db42967ffe25d08297658ef18cef9e1d58dcb56a27e03f08445036e4599a13b58d2281cbcd275a8b590436e49532692aeda6e84f60e93510501eae45c2cfa481111fd97d108abbf2cde622dbceda0ebc87be68d89a7b0f2c47d8025ad68485ed6dbddb77534feea95d03a28e63659fd509e24fa68799cad7e5d86909d7ebf4b6857bf80a056cdeeb4c1e7cf5a5c68e3f2d12e45e342df1dd62ad10ff7466e255fbb79f50713803ddc3b23a9e6138ac39a4001b67b57a87cbb173d60f71f349110f7ee8646c1eeb03f9ed6481240813c30981ec9e25127ffbcd2b6678cf9bee08b12fe501c3d4af4503ff77e623538459fe26c56bf6d3f1710ce7c15a65e326b630663ce06c9b2bc4a9521dd6adee28df914ba36c9e08845d24a58b846b69495c58d66a90883bc99300d76891b3f315c52f290a0a429c9ff4c2f1c11d99c9a440d94e26043cccd1c88c0950a8c39ae5b28163b80e35351c4a4ef7f1169ec48c90edd5d064ce0e34110b39b48cbacac62dedc4ce488ed6dc9ec79af66653d0125171a54af160134c0485cdf771c50be35c493113f2f4d2c4a1042e916e2cc50d1a4ca7ae9244f8dd6e3c99cea3a08dc5265becb087ab82b1a8ac04d43d84fb848a5d50bad0cef1073a9c99dac872dcb46c3e824f7ea2249088f773318cde49990afa3ddc3e44bb69386a324a673448fc87ced32fa2c4e6a3b8160869b50d53e3776fe4a383d32b2f32f320363e71d583bd6918ee4abb8d711d1595732897d08683ed6d5d7c1d50676440aa0d99b7e57601817b068f93e335d46bc6228ab056526c29023770b8c133a2a7c8d206bdbd94f1749fa0d30e22ecea3d321417f7d7781a40bef673b034dd8dfe0043361f91a8f848a9424a3d5240ee14f8913e268bd8ec4128362444d260e0c57829a8fe2eb140664f4d25b15e9419afbabc217553c98793918fb5913e6a6868eaf0c1e1b1b7ddfe9b77226ed52cf9b2751370ee663bf1444f3b10ef2bf4dde1818b10cbf6bd8110a4aedbd5de9f27d44bc036e5061d9b3cebce21dbc3336cfdb079d15c5e1f8da8df040a528f350238bb9dc8ae0f8a8fa7f8eb0c115a72c54db9fca42fed19dab905c8241fd305e6b30502ddb210c9442d73be685bb053506cbfbc6accd79c76e40f4f304f7b0fe74effc972702107d82b2d0f34e9222c32685291efa4952d00276bcbd759114b1fdf5e7f2a1957413a0bd079d6f9aef649b3f61128a8568e0f7298dee50dd5269c775320b644f7ee809df3ca63115cbf7bf18d4363d5e75584062881583858f2664628f26893c55fe6709df2a9ee1102c570395634ef65b99508e94ade26c21302078e92d31c33476769d759a732796740dc5a8d6f22bde06e3b1d6665cffe16123fae2dcfda7dd0773f5648d1850d565e919af089d935775ee041f7b890f16b29996f41c1f7db2868f4626fbbcf1997b7a85ab2bc4b2146d311c635624214d0a9e2357f5fe37b68895f3830db7143218bebc62e0d826646cf3286b82626018431e83f4f3c2816d67067064f40856ea27ff7ecd635aa0c986c6de657e305a778ff4a63516b03da883592f4f0e03368c7f71955a6c01b7da3a2edd428d7d171110dc57f7b86e25a1b7d580de03aa4b5a51a51392e0521ffa49af15eea8c4d1da6069dd60e0aa29a4345c3d89e9fb7e26efbf119ef66a74d450b8677d1dd8231628e7d59ad47819cecf0a35462759ea57bbfa64a671288f364f335aa4399aa48d39d2e3634f3c999df2c4e31081dd7d751408371b86505f9cd57eae3de26d27c7da52a3650ad8fdb399b55f8122b8f96decb6a7b296ce961ff27566336bfc3fd9f9ef07af6df0a271a7fd3d60f6fd71a42f72538da2be3503f5b4b824fe0d5dd307f7a290b920b93fc4b0bd066deb5b93f9f4696400240fb290792def28d580d5c3b9c036574b784b6b3ef0166dc9a065a57dad8ab3e4b42e136b7a5c5a930a4206ffa8af30c67411e01ba6c9f334087b8e1df6c89057660b02e6ef409c0447f321bcc26735ae0a3c78229f628365464db2e1a10e451e872232f217b9a8840ce42f787369ce1217d6943c78e4ba001fc34ffad1aafd26162bcf7f9b3dcd0371a9a6a761215f3be5a60d3230a097d9ea8d88b3b3e849e386a69a43eec0be09ad5137ed028b86cca3dfc3a328a4c4624bceba70823e378403d90f8174b955186df8676953a5458bd17be9dbc340ec79e96a024068c544bcf447aa57703cca70e97eba313aa8e04c8074c90f40f3729f7ee84e852f268cd165e5f3ba4aabe73df0aaaa1f101eab8b1e6110d016252220289371ed4aa1805aed8c05f388a1d0da8407b2d0891bd171457de64cf47f6d3e06b86d88808efc49b71ee3efce397c9fe4247720c2e3151f479539add9896a732f63588794a4d25ced4f9e67cfa5dde0c12919944c3d71a4f5b87911aa6f971dc07f47a8c9ea5e61e2621caa7f7703683c96b545afea9bdd55722943303decf5b26a6f19ea0c5df090123f3b0e402311ccba102cb75810e7b85abc53595ebaa7fada08e9558cede0dd9c413593f2c7ccde8b1d03c7bbaff7f816de189ccb2208f7a0b8b91aeea14815071583967e6109bdd8648a1a801632bc9ec19d154b4f59e33222741f50735f6f8255593b12a27263740759126fbb05146090b2e723814d635b5597a81bb3ac228c15ddac7cb1cafd70fb1b960fff87366bd438f7c72d0d7ff1195e1dfe346b56307d9cd9bfcab21ff42ea7763a3a768eea336c01266f556ac5315857016629fbfd60a296bd5b8d7776fbc51ad74a58a539e851ba511f89bcbc465e09f9e779450a42a94f6aa9d553141049022a45b652d15c92720eb87c379de773380b7cebe195cb9acf9171830919d1aaa4bbc46e3997e0923025cfe4fa7aac07eae53a4207616e0df72cc5bceb362a05795a8457681e4d6c64225f984878a34dda5873edd47d253ff25e444eb954a6673b929181bc9c94019dac43a207aed0fdfa404a0e5c69231d46872a1137d365e89b0bdb075d165d337296e69b6fb19e9835717e8a69c194a14342e17f87cc9cefffd694195d5760a798c38e063aa7f1dfa040a0e9c2bc98db5b868815048cc11e84a3234753a8376e1c30b308a26b64c774741bb9a77d0bfe642ce7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
