<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8754336c9ba8d5b7970413ea0bb4771d8d563189a4092d074377e4e4f93dd5fda7b5f23180fb5cf4d3e809f1c0fdc5d19c8056780a152cf0240b6701b6a62f39c1a4573a95d1befba25df1fe9fbb5b2c31eb51a639c445084383e9030d50035a0c51cb8d42754987ac66efe2c5a2f74c6e1136ed5d12c428aa7b5adf4581bc6d63948cf5f713a6191b344194a975ce1a0749f9ffa05ed940d74a38aea205ece5ac8b5caa740ce71465f1ee3acd05561e97a80b598e608b51897115bb7244e46512544bec0e985a96be1bd56caffc3f31f3c02caef41418c56373111b082a7005e1b57a3e41751a6147e4df2fd9f40ef187bb8b3a74acf4868fd26aa45f14a1540f4488da014f03d151d394d96b0846a2c4a25a40370a82d96d0ba07e9a69d28d259e8756154e2e92b993206de6c1825cb7d4b57e2fd7cfbcbceac80a372c705942fb9f9600bd222eebb76c65a218067a4e3b012bdba18b24b496f7017f5767563d55e54543a4df6aa6bce9f70b5b8be1d50fcc2ca651c995501ebba612a998a925f66d67c14549b2333de22b7be2032ad8527003386807c77607da8b4807a9f4b8faa4844489313a585a18282ab9bd4a7153607624844150294a74acd0ffcfd8f27162f122c631a49a6a17471eb69556ecce619f0ceb77c143b2706981b2fc8f44d35b56a6e4456c1f6e77658c588c447104cefaf4ec9be11871933d287d44851b333881f6c8974625d93b95c7c53325aa5054f288cbf6724b3786aacc8a043e814fba834d79c19c92b79b551c43bbef49deb2bfd2ec7a2f3b88371d028143ad01c7eb38d39920b11683f10b4551dd84036b4ea3421a7086d0345a66df118e6012171ad2eef29eb7fdd4e85c779a5f310c077909ba207d8e0b4c4602fb192046d24a1898e60701b30b3643a2b1906120965045077e8252330fc38ebde5a1505b8e88467fc4c7f4a7bd57520978d9752b99f6cb07a259f539b8ed6352431d4e5ab61c289a5f5a8252241cb3b0f7091b7e2ef719f4d43eeff8ff4f01222a2f3e0821d65b7771e75292152a5fe547d99f188ee3a760aa34224e1912427ea7a44d3033f216490b5478d5cc4da904499115463e3ebfaf3f7fff509c2966c754bfe40d01639353b5236b24baf4fa9cb1207f01d28a0d56cb34026303f3e49daa58738ab03faf6f925a56e9b02fc0443f55645469d80c3167bbd048b09445557a288190da8e70e25b662b39716e2335b05fa382bfa944f9242f3819611767e45d848f0d125cc8f9b39229f53161d27395767480b20abcc8c9f53c453cf304ed3b15a752a90f7af58e6474d41e4203da6f6b86f80d33368518fb925c2684d7c2f842a87f685625541cdcd39d793af1c633a291eac31daab77a91f481d925f8efc9c57790f7048f33448b96840a5a830fc9362e48f63559d5ef01fdeacc81e41dde63ae10197da6ecb6a4db26c7b8d65c90d2fab6b61885937423ba10528efaa752c0757bcfb7bb8ba0cf67ed681697122f848daaac901275b689fa366777ae69c1e79fecad2991e4c0496cb2bb18327c74d93bff5dab8ae5bfb2f2ab422f418aabfdd274a91337a9d5bad2aefa4a65061c267a55eb3bf68d2eda5d6e4b1e9e7aeed101bc7f0d18fc1e865c03b286908182b2cb6a41d222bb7320fe5c850fe48a65da3cd91536c649e123e7f15057f3fee295e7daec427e6c13401da3aeaefcf4a7802998fe1f053b7fd7373bebcd1068d50bcbc517d1fb6c40f044c3a5a6b2d971163e3319b5780b96aec21e0d1a8eb028bfede2e83f8f6a983ad0949869cd1581c8f899e74de9149780a9d3e21a3ab3644ffac3779c99c1bb2b38122d3cbba00d5d6b75554f0f6fc1f5427d3c2013093b3be6d9021e181533910ff05902aaaa2082f561aed918af69480373f105c1e845f2c7cd8dc946c19b0227bf1a7a7ce39645113343ce571aa7df507e24353e1a8ede5b908622ff3cbcfb368a72aab47c48c96fb7e4809491493feabf81d11416e948c81ff7259cff315dba1c96dd082fb715b658f518214814e8c31904a72213b07ce8a35c91c94e1abe8ddc2ec4e03e859b9e6c5a26e5d6e61b111af73030cb8ab545ba9632d860f6270d5e3badbbb8f81ab87a07a3bb4e4604616fcc15c2034552d16a4c43f22f09c8efc2d73859eb2cab1425680c385ef58d256a6772d303f617268c90a6c12d6ff15883ae17f21097888b94afb4175858a57ae8965d2b8c6a59ce056a5a33175f61ef1140e256e13c6d7cbb9e55ce81783f61f76bfb18e66756948f8550871ccbf0862bbe05426e4a12060724b3f96e21b3f88fd36ebe716be4b6c17253bd7130f144e5a585715e1820ccfdad32912a65bd095680e078dd98293255e2e3b12415b40f01031bbe3195f679f88abb857112c2266ab71a1d7e0162d0e1b723217eb0b649e0aad38ed91dc8ba511697a6bcaf7cc067cb19189dc3f16b2e802362b6c67707003199a96ed198bc38739d35767b8b7c674dfdc54fad65dbb2d4288e1c88c6c3a34ae1942d7b09cc9c50ce572808c82262cf615b777a2c2b0cfd04b5d3b558182bf88c12a11d4dfe0600ed1351b001fac62c0a0a3d4f5b02cbef3d321dad6e7673197773f62fe760ab9c05f56d03b3efd66b6100c1998dc0d4f1d6529dd597c45bf0e7b2b4d69d0656358c7fd9cc2ac80340b8dd43f3e65dc82c65fe7104123ea01c4579b7ebf57e37a1135eca85dc10116fc57314d4404a04c69deb92c5b6f9b098600afa5971954f2e7ea55fe0f3eaf9b42ee9e0efe58dcfd6e268529907df597218269c8b97517c5f52fa21a58335c806cbebd0d0b13c5b4ea4fda6f149266ce4d77968f54c41746868eb3b112eab60a9ae0752c6da23419acfeb2fb91bd0a291b2a2ed29debcbff09b0ab8780116492547120c4e70187ce05a4fa9ce568c036184330ccada26ca664e70de1e05034e4df8984916d69c5ea24729b824a2043b7d5e16eb85c937184b5d1d7d01b68e1c67c2f7b04fe1ae98d17dbaf9d102e67a47ffc58579ec0bbf09763c98aadb1296beb393d785ae980ed519bee7ac78fa07d647cabecf6aad1be573903930b80f42450a4de66edeb754cc85628c681b4789e7d9c4825fd93c029c5e25e50fc5a96212ef060b0357e54e9e40138f33cae1a528ebb81a2d926f4f899eb83beb2ee0787850bd14f79ec24a04c09d567f63e563e7af2fa8212ab6a8fb1d3e75edfb71c38ca151cbc467b487566ab46a1614772a3329a15c2d9b86cbf26dfcdae88ec777471fff4b9513e79780c78c0433bb4708910dc87b143d81dbc5285e2cd2b582e2e76e4cfcf4cec30041cf3530dd5880a076decbe8a4a2f1824185d58bd2e3f199c44c96f40c3a6e97eade34899d0c56388759e68059f8b874e0c6867f91603f1ea72b65cf04b7aea64ec98aefb871fbab55a91a6a6952e65f9b593c12081f838b056c13db7c6926e4ee826fddbdf806e16989361a930e2d91dc2cf3c2a616002a1f9e3c0bee72d8608b7e223f2533459f3754129d87aacd520a4b9c4c75fd53bf0b359b9cd7fd60a5d3f44923c87e5a8edf8abfadbdd45456736bf1815c7516acececc8831ecb2b7948ccdb3dcee2fccd91783c57325b13b8fcccbb212e1c715edfabae9bdfc6a74b4cea234a5f807a094524972e9966ee77b25461be897cf26aaf08bf46a689722831a80dbd6e0af8ecf7dc1a4ae648e1ca3ced7f6271d861d79c76749e0cd37dbbbeea09fe4fcec4961080e135b56d39bb3d21d23b9ba82898ad3f5d2143e8c9274cc83abc2f2f881cae1ff79d13ecaa06f25bfdc93e49220b78c2fa1434bfe12b2b49d425cb70af242b7e6bc35b8a8f04bc90c5c117899e51d0327425b5d6676bad6b70d6164af48346d2338092e2042b7599d7e95c8bf8122414193ae7a262995384105bd04120263f449166278492bdda6a54c0c79beeb6a13cead7e8c5959457c3c15d209af0475e3153987d3dfb23c10590755fae08187845da4239cff5041e9da85d4bc4fc0cb5de6fe1a0a85f44e64599958a29efd7e3bb53029612c303c1f9bfdfb77ea27677fd5665643b2092a9134d2c6e1a221d14d5d12da1148ca4cfe309313ad97e1dbd599007e55123e7fcf3e1f0409485f1cf83320a60731fcaa3131a8363a3bc43cc01925dd5b9af1dc388e67a970727f41158fe1379c0a812d918c2e1fcc94040c16d5d164f923a0b1157b5524a63a775ba30fd4f706e158c27de8eaae11d529cb14bc9b322477575e8ba6f2b7f40af5ce8ea8b593ca2961b4f8a8dd58ed5b3f03622878bcaea991624f6d3a781cb43444d1e4c7086e8433fd74c156dc4d27cd72d9bb0b2ea72c7e0e97b5aabb2c04fb0a8139d33cce28b8c2572e30445d40258c60b023687ff1685657a9005f3c82a975f870505080391b97cc8c486850dc7c4d114a9991c242b4e80cd56487dd2ddfe7b842ddd77bb3cc240c611ed5b69181ebadd8b6805b200c54c01e1c5884329a61938c354e47ca6bef4609f525d44ef887b9d03b1847c8eb0c7813a853195f693627385e7bd6f54028cb6f38dcfe5740060a78a3beb42ef718af8e4f0059edcea31c50debe3080f86454ac6f3d324fdd6baa804e8fa7eff8a017b73c31d0490bf8a3e5b93f46558c7ef7cbb9c04a96ce617b1cdb953886a49f54156d8509a871afe64938d89e4b9b2d1d8ff3b32d4256a66d0d94e93c13252146c335f9e205c9fb509dd9897c545eed817a6f9c3a3f4a7b6a639db41004ab9bffa76d5e7560324db4b201c94f9f82dd1fad00f381e1e91fe67e192342d13e4212ac25528e3f0dd4c14e0b09f66e70f79e4110e59ccbcdd47acf46ba7b944810228034b3d0bcc4e812a32cb12e57b3cc76d9ee5e3beb49bbce812a8bbbd67d574985696289f921cbbe49a7c1f4874b543c3c2978980b4c75433c3fea25e875efc23fd5871ddadc26abc413f0238ba917fab8efd28e49901ddb1945c25a64dfc74642dea709543027204cd4b4e079df1a2b6a8cbef6ac4af3b0ac166f7be4a14b66a8f64c5be3cff02acb4fe024e5252c80dcee35126baad600aed8fa003abf7e17c74c4fa0ebf9b168a3b02fbb3fb049b2d406113f5646b141ade2f8747ebb5c40ea48c6b3093ab13e88c1a066dcf67733f6f522ae9e69bbf1a73d853a3c53f5cd99d5d4d21b3505e8e7c996f5febc267f1b3fe81ae29fb542d7692b741bb15e5708a505e58189fd4f83ee4ae1ee47b16d99fa80b4721d54dbcd5b037f16a869b3109edb5c49850bff789d36d703d373de008cb2e422fc9b3717e925874c72c320a6054ff8d4d596c96a4190956d772599e1f2db4cb304313f8808ec9c0f482f599ac17f106d1092609c063ad8ae30dcf687993ba4255dd8447dd825509b6d3bc4b336b1477f7ee5a18c123c2bb01ebb5d71207d8388284e178c0a1bd2784579f8e2920edf2926a87a13874da19bae5f850148a903a3bcd72b2637a98af1eeb5bd3373906c6ef9e0fc140b840ee52ccd0b8ced89c44881ae7f0189133764027b45fc3732f6e8078be393182a94b40dbfb0e970a260078c30f6d27a6dac821490a450b7c4d127d6028b4f35f90f2585c01e1ea7e6dd91a235396cbbe9027141adf1f6260ddc687a435d66381ac79d522952f30e5cb3dfd76a09744b61b6e7db1f9d39b4bbe97df3639df47e9f80a71597ee8fdee4c5df88f82ddfb7ae2e0972898fff7fa2f7c73fc4ad06bc232790e6ca1fd5bbe4af478dfbc5b912e358eb47179ec4f68647c2b9e2bb2b6453c9b1b34fbcfc76ac8c74dc14b17ab3852313cced2afb62abcea7d6b8469778388054d637436ac19d796d8af588e23872e3ae4afa34175966f91722bfdb213e75f0da7583d51f3e741dc9d98683141ca7c7721fbb5a82b82f7a53ba0dfc6cc36188ab5182ab5d5f2fff8ce57e7c58bc19121b9c8f5adc23069b6c3acb9b15536ac921e16f202ae694fceaf6133bca7fb43eee7484595808c93c6b6483f154c9e25ba38c14e099d88a5bc2f1ae71b1fa8af9ac706effded4ea431dea48e2fb4af0f3058a4316f3374865941507e45fcb2db624d35bf801f9c62d1dd6e92a79e0e1a977a7d54bab4f8457cc6491aa20afbf5d6d4cd42d0e6641e7ebabb848bbfd3582f5d3f59c9834a4ca7a27899c6813494b7e55fffd7fa7537417fe30c224ecfbdb03b8c95c80a09cef5801b2b297b542381efbdd342ac085efb065bc4e4dbd2adf76376049f4461b84a7c0e4913ad2e593c0cc7c122fd75b071de1a7e82a7fb198428d4f25e4ff1f75b1454f9921955be5cbed37981a79bf8085d600e9bbaa709ea3660ce38762ef1e06e9cdcca5e875497e0b3b17ad61d7e03b40e47ca0ef249febb6b60ffad37a2f6570b77fb62f090bd354e084dcab3c995ecf52b347e6b4338739b434dae659a3e6b4dfc36a434de40b5118731dd7ebc0a9b7eff6d29875dcc0c4a7050243615fef2b4cae24462a399ea0967ba53f07fd9b6a1b0cb5127af9446da72d5e78249f26fbc8065b9dc6ebd92b13363434e619e3ec5e81a2d5987b691fd47854dba5ad011e292843a531480469be18efc70888413b7792ed1a5410dfc0dae577e15c6d790ca002977337a3090783141e63004a162c6c334ac71a44c0e19cf3df57becba3851eae1dcb493568cc460da0386791054a2eccd9694adf9892311edfbda14d71ac13131d04fccdea0161c1bb918aed7f532924e0af809a9ae8d58b7142bdc92938c3fcfc0fce43b6dc154d05790bbc78ae6567f7f891eef9ab2864966a749d400e232b723e165d7716252abcf19c4b0e7785b83eefed1ac2601f6167738edefa19f10a391d068599021b7db550e1621484bd39e0751f8ea129761fc783dd7aa92f20dda21fc39dbb6e60e0ff17958b05c029469486d2bb4927f6a88e51deb5651752f5feb8e331c728f54682a9b6926e2acbabe563c17ea9564115971ffe5cdc5cb4cdc1239859cbabaa5efd5b7ebee4a6677124a18a4333a7a077db18bbdeec9799e3d79f20e119f8f1bb6457482aef4e07a99155d6c6598b1a5a01723f758639055b530c7383f461c727e1dbde9cf01494b14c5131216dee15377c5a14916094bc3f183cbf15faa4a83cba20cbe1c9a93698b286b3b268359c0a34b186391057b328ee854c60226e3d12d5ee410c2d0b91e1693972b98612899d062f702e6f69ef385c28b7c5fd5b6c14578ff89075f35b8423ba0aa6facc1c845e074f0334f0577128dbb97e215104f1faa8fd6264620696eb92f6967fd955f9a7bba2b6ea412668343aa106b0bb7b1ed6c507c2b2e6c33c5096372bba9fcd85c1998c0e8afbf606cb94a42a9571bc1862e44549b5ff5e3a939838a9231a4336a687ffa55cd1780db98dffb3f2146d7d3559cbd84a74f4d9997114ae034c9ebe4fb15290cfe9974c135ca46834e5009018e5f9e4e218d7c42de23694fd58001a8afe6df9df2f9f11d009df75a8b6dc6c74999eaf95aece591b7898f35a4630abdfb17ad03dc3b930ebd8f1681db47fc9051a5c6a37be3c97bfe739d69003ca6248754792cd094b7002f8618e2fdbf166a54624f2be294dc7101850b8249ecfa042d0383f8454b4bc165ba804527202441b9fbdbc9ce8ef011899ea6a63dd3efdb2d4cab20e4dc5b3f05a8a574475632726c7a3f379abba0170047ce8d4e80dbea28d53afe5d4d2e5b34e7d6032d2f9e9fe4fb0277b0fe4d5742c3806801e1d8efc8d74b8409667c1605d20e68999a6c419433e95b33ff1542f8b6bf82b8b71e54c8fce112600cea211ba8f41955501ec7ebec06683be3feb34baf89c77863525ec4496da46ec23d462c7269b91c0ddcf4b3b9317861ca1c1748daf0d8e47040d5001e26a3575c4456b950e3f7126abc4acfd7bc486b1256b53fe9ccc854f11bfc96689eacd0deaa848e35f7d0992a1473b4a832adf2ba07d48d6f556c3fea47a4c40ca4fe7617752cefc4d2c9fbb0256957e556e23d5570ec7cc18f2072980220c4f3c5cb93b802bc3c9d0d58a2cd14e8775a2fd74e098b55904a92d24f617e537837c19527616998477464a4f03b442779cc8d911dc9332893a70a52d17c6637cf9abe16102958fe4645c1ebeb95cd4a18f6d995a2b3e779573b65d023900aa505cdac0ffdd5d49a3e8d9338ba02c2784b9e654fd0872756543385d2487b6948fc78db98d7b92da853ec9fcd6f60e41f3eec8d620b20f09975075b887ad643e3c3b7ecb50efd9c0c5e451d858f9b593ee97be29b04925be9e5f8712b09d20fd9157f0d633b8dd0797a0272a73c5eef2e1e1a68fdb342ac8fc39f8f7ad53a6fdd4ca5fecbe583910c758cafbf982d303ded484b9accecb76d9db6bdae41b48b427fb7e9fcea2cfb6c61359ad12723ac559767b709bb08eb122e8abe68f9141669f8fbd62976ae2118e6ed1067309ce16eebc685d44252410b1276fa1b7399786edc679309c354852848661ff010602ff7b74b4a1daa8379a1f1577c452c6c2b4f26b0a942a82963bbcb94fafef586f0366bfddedf5f733e61a0362558abe6d375af027154275447122b1530f296f4b0d49d1e9dfbf7c06615a4e839c2d942c7c9085bafe9b46f9f1004f1bcf5cce1b6e8faa58e82630b1c293c43a1edcb28c083ea6479a6aafa7937a42335e606263afaccfa7ffcc5ed644325b99d967230563e2b513df77685f2dcb0ea31a7591d9e624dc5257945718a85e419adc37dbc1f5e88eddd41ad27f151bac5295577f20931daed7e945b09581d9c70fd7eb970ef421e13e284eab4d5e9b0e7b18624c18139bba88daf4bf8c727c26b52f50a68f7b67bf01ac2ffdddb126f4c4f6e1031dcabe0cb015d2e778244a9d1d93e2db15dd8ed110671511bc5b5367cd07a66765c8da61895b9e57ce54e4d3f3ab719d95fe49c323ec83b7001c2104a44ddcfa2d00d7354f1926dbd67df9272b4bd2a83367beada4dcc9d42162bc42f0f84aeb57d501765c7c0a3a246bd48b3f661cc3bcfff8a826fd6122e0e86f7fda06e47130d608ab9a7fb9cedb4554a0163e86500970ecc8ae722ed0aebf3d6718cf64cb720a2cb54809b5df463d2ddfcf0f149c1705c0290931f760694347d653a00352f39b60cae4fd397edad84f5109e05a679d8e0fc77b4ccbf4feaf047f1301611fadfaa47162124b4f78b7f49e2c9947024f9663c2e5e4fe44052faabc202461eb97ce90626143a6bbbb587e3b130c592e82042a370b652470b32ad6cc6c9ba4659b91b959897a64754ffbb026e98a5da169690f18ab549fde9f25f5ace8a980e290ed15f765d87dcf19613c5e3f2a5ffbb14d3cc1565103b062ba31e1a2f55b659fa04d310fdd1da9edac1e27fa69342fdeded7b86c8fb791f56ee580e079b9ce6689f4f5097629ca16875ea6a1435b794c615a53b0225d893d54b2355acb78de09b7c73fdfd30a2bf7562b2d57e2a6b565ddad797e8e3cdefdf19504ad141087d302b539e2635ef963fad30c9d14e43dbe50095c68f255d768a73c1ada44d243afdf8ca1690af7282e85ab2b365b1d19d9af8280177498526e18e2b876c3341d14a055b02d2825fddff63df7bb02859a901295358d62da9b373971a381f66eef0604f10e772c225b3287825772363f1614f8935f1aeb2ac9d86c56ec57919c72ae390c82b0f5a9010eb0987b2488c4a5dd7e822e7968e612a1e9591bdb8eaafef20e6d73d251b7f7e4d05d990e4a2e43e9a120c0359a8ba778d901ba51fffe163c57e36268446246e8038414497ce3bf6efb150a908824bd47ce3648c56bac2cb35b1f6ead260cac300125cd4f15a6f8a25e7c5a1d4203fec83653cba0f23ea68a1b705ad64d168ab85c88abe1bf1838859f477e245eb5ec582b47d03da5fb278e5e3264396f80ae0c28177c9865d081fbc54422406548adad9eb8fc1208fac1bb453aff95a185d5b13a36ea5be59937f277f7826ec34a2bc47b0d3e9ad825b61f3ee0a09bf30959bf3fc0d2daaed7c73cd95c1e4343833e5176a34a673ce0e50159437eb83ddf094532cf3676200e35f9a577c5818b467b41c744f6e686c728de00ed8ef415e7f0043aaa4b7d452be5f56e3730562de6961143ee0d29a192d294ef531c17a6c0cd390a132e4ff14ec8c65d2fca4fc1d87166b1f35c0f622a4e2dad752554f70ec81c9243eba90607fe764638f5f2eafee51b8e13494a03d31926e8b4ab7ccc9435cdaf3532e16f9ecdf74e7c5e17dec10549ec424f27df4157330032959abb953f5e63db7c5377beb1b83a45a0c471a98834925de7312aa3264dd9440494ac7834e4f1d30857d12b48428a1c7572fe11db5fb29d3373d165fdba28137ed5b5fae058b8e1f9325d8426aea005ccd7c97caeeefd10f264e0092ac8bd2ab3e3e9bf7123e5b6f7e47fd64590a38f2a3a8e8438ff7aa341f40fc8fe4b3042c5594884799e500f7636d652a8427881a2d87f5fdf9ce175b8c2ec2915a5eeef750aed9d3de612f8c68b510efc6173c9cfa74f0628ac7db705ffdc92e96e912e7435f65252540c4a45c7d6411bfcf133db42ebcb001df59fa70c33761fde875cb90c41f6a0a60649512a3e847bfa7474123e50accb342d2233c4b0bf4af2fa7ca04faeb82beb1c5f94165049568667fcfb8f1a0404b92353af39f14045809703fe1fea6d1673252c011a723a598275e8a96c231f217493b56c26ae4f1c03ec19814ed616520b3ea35f69a87560a59c85cf1a3285d7a2aa1ca3d45ebd5f7a8c5677bbef208317f3039803f0dc45f06ca6879abc405111809ebd4b7c11555767abd0de9c8ce329a3c5cd766eef43dcfe88957a07e8636f21275842ec661585bcd3e9a1f2b369cf53d5248e0286c1cfb8b4e0b24a0958f48e6f53cea6e5bc4acd6afc5e0b5588d8e852429afa45170f2ad49a114f1e456c8c5aec14b3539a206f9295422eb7b78b6093779822947d29f936b6a625fac1b3aa84fda2228693a300e0717a162b029215168a1ccea1b4b729808fe74122cbfc9d58883cac3498c725c94d1aef22f18e0b279bb86514c04ec1f306b134ca95aea0f084372b245c566ac8a0b8c851cf286b6a0a83e8ab8ff232d0ef2a036217dc734f2dcaf799de736ff1fb1a02469a6462ea2b00632cf2a3ff3c1ad3236060f5f8a4f6a9c55448724a50ccb187ba7cc38c3005bb2a209929eb32c77a04bb79e4846b550b5e2f5e601a7426c5050ff3c9d64cddc57c799a9b407af8234ca7f01bcc9ebf83c63f582e8f8fc026f8fd8640bdad278a4218ddeb50744a3fa9b719e7669fc3c5f505875cd7e19e1ecbe01527b49618d6b1cd01ac1c50430dfd4dcc1502a76530b1c76b99f6926417371fab064d0e694baf5043a291e3ea7f544d0a10970c2a2b025e8470ef5748367c0e33336fa6e1b1d5609197290f7d0aeeb01b8b0cde7052118fa6776656d9e52f0bf234bc6cbd055fc12c0a412d2d8f9a9e747be071a9bc4392a5f6b8ee66af13915957239acfdce958e8fad11ccdcde8718a8647e7d2e6e43b0a6ac58eda25ef1ed9d1797111aadf52a38d284183280eaa402255a01578e4bd1df12934b8998fd72a0ed9e227b771fafee45013c785b7459a6422b3d1bcaeed9666137c21d6bcbdd017d0ee7994de73d560c20ccf49f111cec8b0c0c29e22f778b3f9cc66c7bdf5ad63f48b391c3cc00077635dcd21e45fa2371fdbd84d4c169a93b22a1b2fe3804e638e837f822d2fba6dc192ec83e463f7cc192bfdd4117449b5538a09ba1da23711a4509e3245c401781280e00be028a8c774f4a9a257a1d800c547dc59f315fd9d22bd61fbe8590d4039f140822565d8c47b8d5c72f634c41338b475719d2daaf126de82432a26a7a7c42113259f10956272f4e2b1403a70ddeebff5ff375baa4f6d19a9e110e6cf8489c10c9dcab1d6f0b95468f9690bae505ba6b3608767196663f6b5d9e368986d40d015e6ac7b7ec673fd348157f89ff7c8ed29af4446d19409117cb87ef8880632a20edaa515602e7e65b925b4b4d006eb7414472a34e614461586a7410ea9f8d95ba7bac90f7aa41c0addbdaf689cc74a2156656890fb105389d7b48d968177dc3cd4bad0035d2ef48c53b18187d99abcb7bd14ca2ac4b9a81ae84af4dcb7359e96b469b3301937c5881c47532c6d6010ad7acf14cd9cd9a24d84e505daf4498b2327a8ab0c7544fd1fb836aebc80cae41f422ea49dbf9c2a48e84f219e1a72d17e7035cb4ef40f492b97a12bb6e4e5ead37fda6a6025d81b643eda84e7e1a678454845e56e32057d6f5c8ce325e56e65a011d82e7d35ecfa450f8ccbd850a8ac7605289d3659a7965612244224a01f2581fa2a25d093324c3c25586671ce4ea07c4bfac98a24bb375b52d7929a54c2d5e0cc108d013b140d01eaec50a48c22382759dadbc00ccc346c2fce717ab333e57b467c6f5455a6b30e1a3a3fd4961c8bb901331e9bcc2dd93a8aee6f15f88a383616ff9b9eb26f9504d561816074c3af9ee55575b647036d851b17cbf341a1a004be3e5d22737e32390c5bb9c72ccdd784dce050854f9494ebcd50104a687f8dbcde951fafd76d2af61c78a78d5edfafe784a181d6ea7b96c4d08e209b1baf1b15dcca92ea448dfa5808e1c7fce01639e01616511376ebaf19a6b7de4629d3ffe189dfe9034535d2551091f48e0b6eb883a5c8f138e75e48d7292d5c653941e8bb295a9578808d41675ee3f97156e0ae2420ef0e07846ae00e2a1a4f3a0a497a43834403f2bf5426530389cc7504e684bbe83fb74682bc34106267e30d6448dda10ace718fbd0717879f1e4aef6327375b2aaa41f922c570e6e818ef40c6d86fb9442aa88df99206256254c31b91f0ddb44fc0348c72483c13a7ac52f1c2a2de71e42db42d6151f6185f1d7a5da8ada4da9e1a07aa0ab51e6b450a35f2ffe1e6fa763f05876d50c1d93754cfbbb9b714f4e2742003c2fa546c72653bfd729f9cefc2ed81f0329e84dfcb4a350fad3462059fddfb53323a051c3998f110ec2f06c29ad7ccce2568ea31633e848cf85d85460a4c6cf459e735c2ef97d496b6d5fa67f7b6ded5c659725f3c38beb814293ca7b2ad54a50e94b3068a4ef6df325fac981965f42b785b0947c5fedb70381a27ad1027ffbb295c9bdffbb859b822dbf6b532d8c1a4bf30a373eb08a35acc32596cbb5595e303121a47f8d9bf8d4d69e6adc025f2a331cb4b4a2b522613d41e6bfa607ed356ca0969ad907e7413006c59366bc58dba81eda4cc14c4a0b8c5635988fe82d68ba800999fb668f7cea7dc45970d7e8a8f5c4517b4870b5a543e003d22b5046e7003770a6d444b50569ac3f350e8903519e7a99b06c2cc76a199f88ca1092d7eba2b38ffbec8cf88fe2c08db8927f6c6593236350a24b4b01ec15559eb14cdfc9411afea726c4febea597b2f8ccd69badb3b067edf4f8c0b454cac2767ea734d9cf542d4ec9dfc310c7d4bf488dbc72f0ae9047b431657a98b43de7fbd1b06cd4effca1a472ec06da7e6b71d404c40ccffae11eb7ca757b02fdfdefe92ea63db4f1dabd40e6badb94fc09c6cd67b3cd553c194d00029a836334e72e1d959526793c6892b15aea5730fcee67d364056640c8ff0c058a11599a4f534dd7704612ff488727b20a91110f9d5720d8f2e19224ce82aa0bb64126e76e313522926651f815a75200095c9efa77a2d3fae068b7b063865505e640f628cd77d2955f5e472c7d9bc35a908f8358b1423f38178b5dc8d4268a5681c02540fdec20b392fffc2eb8dda55df9d20d8990217f7f0628a7c64eac4fe4b13c903bc813e795e512213f5dc73f59b960e6858723f8234750bdf7ddae145a5f38c2a3037acbbe6b9942106738d3a48543aa73e07a7a16ade9728df57d647cc20b7dc88232c10ac7ae7b74da8e655a6e5697193d7f777e8617f796ebfa0333a9f539e18959167a0eab55265a4487875b7ae5b92c36ad8441e461572105e6030aaa1ab89b57b52ec9e2f00de3bb7b335f49bf0739bd827e486f2d4a9da83ca5b9f105e3cb080edd2b4216dfa2f754722c02fa09e5c10d97ad4b506634a404f53f9b15e49964a8ff491306380d599e4e7118233359b722419b00ba1c3de43813ac91827ef874534b54a0037f1386a6e4c94207e1a5ab4d85598ca8a9cf90dbdb683f896d3b0aca2dca71e55b77310ee14f15b6c8c53eb4bbbd331bf450d78484a488af5e7d82f1f4a8b21af569daec7202f3bd6ea459c66844bb8746da6d6bde206b7c363dc846b77f7f288c2f9f4573155610fa9c91bced5d2f81b08842e3e7945c37ca5d42c8ec17aa9846587d2c918c747e1d50da8904f96940ad1a414f69e37a71659d68802de18dca216c33eacd740ae6164e505c957f8a6b51474850c3b8a133e610f95573558640e48b2633b3131df1eaee0e2c959f898713b4e7b09695b03397998fd03f8604950f9fc905081c7b0397d853908550eb1c2eb992cf46f8c37aee6b24a4c9bbda67af06f66c1e9ba5c2659396779bd65583282f34bd2ab6c751874b4ec37a79dc5584f9aa0a99f6cadac458201c9be0332419de490e6a6b1622204f1e7ac7540dacc40d2a52f664fecca73af2375249c831f77f9d4c55d6db4195da5263d66d62567d379f06120584b56d8cff224ab3d80f6f3964a00473cfed677c2165df02e11625c302b138f6313e2af580ccf6f5d6305802f92b69a94ad059e3f01e956d3eef4d93cf2e987d714fb75cc7aff87c7f7f808d5ca39e201b88d45e521a0e19c68c0627d3d7c6c3423ca10ec5ebe51859c1acc07cb9e0013715955fc0576ce6d338e6e9932ca819ddbd9b001d98d7f40c62f118ef112f064ede493d2e6cac1239f3e7315a97dc4f462c4edcd4e268981649d722f0c667c2925befaa5dd3fd50207e7b474bb39c923b2b44d72729da1d3e3078c8d6a7adfbdb2632ace980c228cafdf7a0f6c20b2d198f49abb4612129411ee82811c06443f9f67f81cf11c8944c82d90be5ae4a82bbc29375ed90f3053ec160d52fddb7e469b704d54f8bcd1b6049bed8ef004eb2eeb0139201105495735a2b5c3b6c09fe87840af2a86e37defb22a4636d82b7e859ab02ded4630818894e7525587c4ec40ff73691d9a1934b4883d220c6a6064ec88b6fff9bcc0e39805826ff5040ecea8aef0a6b9ea93419604a746b8b38def391db26677c795495bd8782a0f645e7bd1cae60cba09ebb864a61352a05a98f5c9457609cfedef4e6b720dd2195c04837c4933c046596d631cf201e34ea50dfdf42af73ebea9290d916f3db9f6f8b93bbb10c58745d2388585887e1d92f578a8032c83c07cb9ad6093325e1c5f9398f78e6cadbee65f3c33913e298938519a0d7f34d73b9c5800d4b563ba640073ca86d2ceddaedb9a1bd435d3dd03af4867213029359b6308de3a95f5f102c40372ce146af3e5aa1b8aab8132cc29b37277135afc37cc6113d367fec674e1cea3b20456a6f631780058f219b39bcc5dfe07d09be364bd80ff1c4747ebf5f781681b5ffdda05d765d624d0b2b260ef92df54b6aaf763162b8759d50bb048fbc23d5bc54733cdf9992a4b9e56053dfd4f4bb8cd337d4ecf23d483f7ab65c145ee37d869ecb4845772ded2d75726c2039e44900fcd583c902f75c8ae826e14a42bb3c517c3d8ffd48ac4c1e9bbfc0bb3ede529ea7f8ea9cb79996d6f3b02577d05419da861782f90e51fed1aa46b2a3e73746b86d7100be4181bcfa2e29a6613fd593faec846f2d7510872fb0a3b97f219252425388bb675fe64356b4fe4784f20cc68d6ee08cb2527b1097af34c7dad56e3df944bc3da489f7733fab52112622d38c3ac6f70724c7b3f9e5c1f51550a6b27e622590b34f44cc7fb8bcfc7a14c3ea38484811277707fc90b20b3510c323927472fb87afd1e84d6c28c84e77cbc78f44ba26e747df5121d7d2bee492de7a7f2802e9deab1ca957421edc14c8ecae7bbcfd8c97f9c9b0c1f4ad6eb56f64e67a442eccc242316df7630c1327d85f0200476265022e319395afd3b1c5bd3298c035fd7595ce86e86d697431d8dbff92dc4dedc7bba93ce95731d634000ade47027be8f32327daa695ae454b50331188bae35dd2c93dae494aaaca84258d69ef7787fe6dc61118e870c8005215e0c746a2a5e398e6048aada160eb5149d5cda23e962182b2f8cb04a65adce856eaad8605a622c09bba4a0a1f191cbacda4cca82b41bc34a842491e95460cb9eabefd5ce6a1ffe5be14135cdc4f8cab7734ef0dfb003021f1ca132c2c839ca9d950c697cf357429fe33e6b3a8f72a37cff837f24ada556e958cb6abec27ec845431f1073296287c9c5d35d4cc40dafab819f5cb7c74e4e1801ac0a6a5f5ba012caa05026abd1b5b5077ed5acd9dda3cc9d37dfb15f1a0200aef1746d8022b94943260c19d1f2a3a216e5455de19ae3780cbc20cad25292a77a29d48f3b7268d9cddca16dd37703ceb310197de0f71083be056b5a9bcbcfcc726ebadc58ee4507d6d30b2bacb4bcc6a27685537713050348ab6a3474fddd9ece64a2020f09751c4351fdb5362ef4d1ab3eac572fb31b1a46aedc5b28e686979f354f185ac6243e30c382312ea39c577558c1a2d83a3c2cd07572da343fc831015afa1cba3b3d5c52a527b985a546b9b43504e8fd8100d107ac88ca8e6d172340a59a30c349c475e08996d9dbace7808d2b3d41acf18d7f2bf297dee5b69f9fa583f24f9a5d12cbb3231f01314be6cfaf13ece4b5e207ddb586d9e826a911effa8674b65a8aca4fa409ea99c0feb89c115c9abae5c132cec92ef45ebb3ead47a8bb8b9e862f321708393000c9c03ddcfecd088cc13fe1abb90a027973febc72b87df7a9c5632d16fc152d154603e8939fb9fd4511a1f7001e6349b4bd3f6b3e2c04ba520f62879a417c61f0bf2ae8925e37115390f2241c4187bb88f11c9a50bb0c0e5eaf40b30cc450a723d286f576ba606ac97cd46483c0445ec9581f5cdb60006035c257ef77c22e1e5f0b418856877b2ac5f550fb8085393bfb454cfbe164a39181958b47592ca70be34e8df32e33ae380963b9250c3ccb3dc8632bbc22eb51b9abc206e4d890d767a44c4060097bb26e78a1d28a2e1567bae0ade3afa6e2b8ce5130f58c35aaac62af7f753d1bfe1492238714f16322874d1d3a1ca6a6b5b93d36eac91d42aa0c3662f86f04fd627c53f9a41a3547fdbbcba1f63bf26d398b173b7ff3ea81fab67c91d121f8470668b2023af5144e60f29904426732c4e291a27843a5b73c336de05d7f3b18dbd0ff8ee2695e77473c1f48bd01d898fbfde2f2b50565745bd04243447db2d8857f4e05a755f41b51a38b51631f4f1f75467c9b2ff212dc745b52b4e8852f48cd5777d1a7869f8a8aff6aaea290c6b4c90122a6997d41095d9a5d8771fa9a61ff8f0f891e0efdc908f55388d6bc5d3f4fda1fd568a7889fb9ab18cac4dc439fae601c2831b2dacd8cef4a63cd4303e9f379d54225b9067e562aa17cf93f97aed1b97fa8a2dbe16db30b3128394913e37920c10a9a83288eba3253345c608952f5dae50273e3c31e9e224a51a54fcf4050d1083a1299034d1853aa2fbee9b117183126a3493c1ee813de5487d37582b6a3eda1f0d9d8f92dc76d35d401c6450603354456f5f680ba7e756165aa838a2c6a7b7bea4af80573771f8b0ffdf9904c52624722bef951ce61160e4e5112abe745bb2c3f78956fdd53bff18a3fa82cf0a3d1dc333767e715cb8a5dd3847d7c03d44647d2e23cf37208a2e4334401be8326c80c59148269d0e9751f7e6c94409ef50fc20812ad44e07fee28b7cf5199303d4b247a65c1d0a9e45bd1044dc9d57940173a8d291c2d454a882596899e64b930d6b3feabec299d1477e6c1b0b8aa344d92c9f68e440645a0d734d31debeb06717fa28e1b2dfa1fd9af8c1fd66a9ecabbfb91aae01d105259c38428fb66a5745fb4d37a7b7d42e232602399bf745ce7dc515d3b40d589459a1681a0ff1825652ebdc91b289fb4765e513b9ced591e5f68f0fcd0b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
