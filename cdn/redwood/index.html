<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c83c8f76c2ee8708e08fe852a149cc32ba966a8a44fa004917a13fed09df5c0d39759667d55d7066121cda24bae397fc99147a0a4baf2ee0e0ec653ef81533e7e0dc1cad1adb432bb77f245f9df33e7cbbe59f2ea6011979c2070ec3bc3da4e72111237230e229363aaebaa27aee8c84dc822227e7c96d0378d19a277acf52c20de4138cb26f806fe4494623e87c98d702253a7d1dc7d90ca3e19be40f90625a866cdc986293e902e5f45409900081e6ae7088fc90dbb449df57b433230e07e78fc684a45dc4cdb9ed43682abdd4f1b4203d2b044ebcbf1b5f1deb61a0fdb8ce6705ba34bcc8c8c4bfc598cd4420e96f1d85942a3e9057bd25df8834f8c76d77ac9553ce828a43c1ca9af07e3079c34f419e695f0a75bdaa64edb32e0b013b91cdb64fd7d987f39ad5ae0af8db0dbb9f8c3452c3df6939997ed6433a94987df07c181ba05c350bc1403d2c8c1f6bc37be8c565dc94b90000d98f7375e8f8253f7baca29adc3ecfc18af9ac4fe44caca9dd0c22f76d9318b0b7fda6d13a85257dab8fc2dacf2b5b8546d8c2688916b8b7b0d10f8e5bfca31b02195fe14a314fe295f7300de6a2782669161a35f5c08f2e6e78bbd148cf4cf620979436a81797677db3d89e266ecb2a4f6080a2953a17358d535044e54d7e24568422b624dc2418f143d27d50e4b41fde35f8bc8f5a0a12972076d8828c4b8e83e8bde959ac48f9a6fd9f4eeda60c73ced816f4d37a69062c16e454498fbebfe3d9ecc3ebe17d007b37b0c8f9cefe4247866ca6ab62e2d65f952bd05e5c8ce71cedc1e17982fda7eedbfbe3d29cd17f98755dd6c7889988c3774069fc05f3fbe66c7e9aa3ecd27930185564fa2c98cd4bb7001ce5175b679bb265dd9ec93c0c561fdc3611622c733fe7c2c6b67d95138e46c67d23b720c80d56a22ed5bd790100d4f8e6e89d0ff6725aad2858cfeb707143eb961d2969049975cdb51c651f516aa5d8999217bfb50324f32664d4c6e524894282735e528b5041f4a7812faa4261d7f2e12d1bfb652d77ae99cd01b8af2be60d6a769a663ffd2189479cf174d6b6119dfd2c5932db8bed25e6756219a3a9c1c2903bba88bc469db6fc8cb85da7cafb69b085c845ce17371a96777a1fc4a8ef0716f1bd7b2db4fe39b576e79b65d1bbd4ea2dafe9b2be2bc599f39d355ae950d97b9a63cc2f35118b73dc9abde2ce8fcd5b80b09d5a662199e7e04967f347e21cad490b8decc0dff624f60fe82aab9b8fff1431ee90863c80cba5ce5cc4381e36b4e8cd87cd9cca2c704dac8eea7ba92a119a0658191399261561493067562d3a50e63f98df9f350344a15f08712e212151a3d6671611219e5ddf10430240885e7d25c8073958f16ac81b2f39a3702796f5480b3d08ca481590d584caec2e22135aeeb87af70c250427566232faddbae2e0bf30c5a1b466f3da8a4a2db0088901e1de7e442a1fdecf52f26fdb67162327064071602e2690a6a8c9e7ff1690f3833dc8ea70e104f8246835b5de336f7fed01ca561da94a1c7db1a7cbbcaffaa3d349d011a7bed6a02bebba36237c14086c6f5557341ee33829459d7e3f009975872737cec3cbc2556f1db40001726a0f7ca3db65ad0f2721e896e15daf902221e140241c88aca81e7f158819bbaa19f339274867733f0c6391ab48bfd36b7b7c38106bfe402442008c0c23248626133a87b086c4eb6b8e063633c254586ef7925ee1cb8277c824aefa4af7b9cfba4229b01ca38013e173ecc36db398df58d00a4486a00b2a13b3c3d3d17d2951114ca8f57a5548f3480ad771a48ce599573cd0adb9b92c7e4de191e11a3877e52a80ea59de20f35b50b845e0c46acd6a872e5b86a021c6f6e2e5dba6c75ba7da95d083230e56435cf7974aeac33995111d3feb42c7226804cdcbd0db60724859515946c3b62c43fcdf8d41477090c303046649068ca6948b474b886ce7aff7c0ed044d5112317a4714d31a2fbf19f4713076d423d1c4fb93cd91736c0c1ef727e305b14149b7ab94aa4110363b0aa9aaf46e7110a3778391449e57cba1086598231e1d992e1c06f0d68e0637187696ae82eed258abdd6b44ea52062f321d6ef1610c4fa4bfdbfab5023129fc1bd8170a7e88dd989ec6a3cd1ee0295689e8454c5b610cc9924c07cea571362e6e6ec5e7152bd26720d1acea2f932aeba2ec238d2292aee6ee3f9157647bf0063ca4a50706689e90a90fd5810f7b887f0e9380d83dcf22d6e391b7131c35d0234e70954aa48294c7e45bf3bcac96e32cb3881322e3de6ceb3c25c4aa0011df0b5ae6804a440ed0fb449b5f7bd4d59d642575ac29541553cd21c0dafdcdbf720594a152d933438d049692de09e97085702435b52250e97dd12865ffa92b391366020218ed7386cf3fbfa88a7eba2fd35c2f6427f4c4f85e0204397705e1302783fa78dfcb977ab034af1de7c3a537c84564decccf0618b0f5a23490a2746942e7a8c77b434605efda4b9554df7855269090b765075cb36b2c5b51f68a86504dd5c07c3248cddf6f44eae98790449c47db6bbc9ad2edb4e96440d5ad71916b4b580d3e09c5985ab9db48231564b926c11c01ccad25969abaf98f067df7e8c91b68a1e3d4821740869d2ae827c62663a62071f9d47fd4740f0dceaac39a6ae373cb40a7ff42182deb2162dea84542d01f83c5ad9ea95729b87b0df80d2a112d76f7083abf9a2b481eebe08fd01fffa8a7f1dbf0104313de7d7d370f003616b68b6b37536c3b71f463409653e06797e89afd99fa764ae2eb511bb98e0c11905c38fb73a57d9befdad0033620bd5a5384539ce26ed02ac9e3b3bc7defa438b6243221d33700e90461a2bea96a72129d7700d8a86af12586a263b2d56d50abf78574af6b9f47e5e5c48f493191cfbee5905578e3b8c25d4c8e1f2bd65c4696e1dc1ef63eaedf2f2ce309b74970147325263b9c51b5c20debc096a4ba10ccc375f0e6175e27937eb77dcaa61a0c9505ad417788efed527f45c72844e122ea033b26bccdf6e6e0c69a323c686f08afe23aaadb37e9055be97f5afa3db565978f9d104a76192204298ef45eb797f4df83811bc11a1ffec5ab7657baf21acd1a391a35ad46d24814d5a91f3c16a492d46d19b2f1675a22c2980d87f9fd8cbc0c67c9b6acc4fd7482392ebe8c1c12491a07ac1616995b931e30e492d88946693fad8d412b3555281307256dbcf04a925bb03aaa9235141b9d866c4553f6b5dbe0323d036e9817c84fe5eb8a1584798b6d236fc5913a67f55d12acdbe41cd55449bb530c969b25ff8aeb88f79ce15883373437875bf9ee0ae0c51b398ac9a367c9defcb04bffbc54ec2cb8f7bc65ec2cc2c3bc4c7b0b439c2a1f03fa907b5495e278886efabdba105d85c613df70f0e6883348dab285454ed59331a35196aa98df7b0a360e3568b2b53d833bc92a7fa1112903d4d175fa8758329397f19e906f6157ed0b43a1dba3ff24bafc0e261d533a172cf2afb59e2165a5234d2f66ada3a5a8d7564ae28c3d952c4f5d93ed02642059d65781e120f9bb7eceb56f97d2930320fcea26b6fa6358def2ce676da6a931ca9835e6feafe5f7e91d1d229c1c12f49395e6bdf73b5a017cc1a9166218288f58f416c90cde6a5aca94e71893834bc8ca28139691be2a3bde6fd1f0313d179782200e4b842f05727a633a938073143acf2297070f24f6d4353631aebc6898f1dbf929da12f7095145392f4398f5b050aafd80882791a0ff513acdb31adf51586164ff3f837584ab807aae59a47e6247855246a388195b23f2e1d5e404b2aa5d37e9afca429fd6932bb7e73d313c899ebed616a87c464c013d057fd6c22db70a7d7e96f40449c98a5390499aec070204a4e882b8432bb8c3fb57b08253ad0eebf90c35272846be900ee6f666ef109059d268ce82bed53a860c605ab7aeffe0f4986d55c4c6763519582be5d437d7202091ef3bd284536d1cfbb3b1290e6470f723597fd9f508f8f08c846fef6d5839c487ac7c0eeab36c31299f850aa9cadc41f1570bca9d0c1e9dd13d41e835f3d5258eae369db1449d961c8dbcd0641a70a86848c0f0fb0270bc52e5b924e6152aa9b6cb34afd84f0cabd6c2bc91f3328d9f989e17a4a7741067cf9a3ab3d42556af1cead1ea6b2cf3be75e2afaed723a9e7e2c8028cdec386d17a08a2e7381744e797d641a5475279ed93467ba8e8e371fd319b2dad0ca8cf4284177a5616635e477490a5ea85cba22dc72b9d2c16ac2b14861c32e00cbcec8033ba9ceb61142c16127bac6aa3feb8b6e92f4d01154d3b328a50653458db1cf8fc7cdec64792f86e8e7a10bf105a68d5ea6eb24355a8d10efcae0caf488d4cebf192a5c90779c876629aac2becb8f9054a6058da2d3747b40a02dc504f979ac2957e534505d418b66fd0b00eb626d21b36ddabc8172a61245094b30f9b1b4be09fe6eed5b0129a3a99443d7624da93fe0139ea7cc4aee914631d05071e4f8160cb65b470fbc9b091b4c176155af89afc85257b08d4c98793b1081202c14b2b0756f4525efbfa480ad7845c8db6efb3fdfd235b9a5796e09b875a5a996ae2c0e9ec62f24e8ed5aedd28bd6f8f766cc9396a8129dd8a16cd44af6d50dcc33313914ca04496c4eecc79c6d84a32d703c6f5ccdcb02546ecc9fb9a5f8fb49af969a808b3cd2618ada8a4a6f14f19e30c6bdcb32dd14f7ad19bb13a692e7744b288b87d7834213526f8e4273b60a6dfffab5ad62505b0770e4b16759cc3df95aa074e14726463f19ce0184514f6e8ddb1746ba7b4a7ba7a023a1fb1fbf27e5c3cc31777c605813c6dfd088fbb94164e0d762f16c75e74576e215985bd7e86ecb12099dd29611cffd7ab6c44d3ac988b3f8a52f697ebaf492ac72970c10e7fee60fa531d4ba2c8692470bee061c81db127549da7e5d2e491a5c03ab0171bc1327bc5a8565cf3e1eafa71d2e0c3e33098327ce119594ec1bb18f964a482ab0faec89178ddae47dfc740da7e62f467a153ae3a552798ef94269ef594f89f6f71dd3fb84377dee53bb9db983e4964f76c7457696ff4f80611877119d1a70f60276a820fca45299ccb6453de6ce6fe21f7a5878deb7f68f8c5e141f7455d63ae32602d11eb2e1dc6fb391ca268d19e9320f61c2aaab1a4ee2394c214ce3751947500fb5bc17a4618e29fbd8da3a6805d81736ca7b0d83071a2cbf89fa09c243e8f6d45c47dbb7d9191ce25a489e9fd5e0718f0292bc92273c6862b30994c1b8bf7068c096172f9f44e660adc019bb5d9288f0e1f238d4038bc01b5556dbc5fad91dacb1b4d9968bc271290dba61c1d7661b54bbfd71f3588c5f463511a9c81d9897f5d0a2bca567baeeaa477535d926f30006d931cb7ff4db91d7ede15d238242703c6922893d2aa5432a7544c37663255a0415f22ef543c5b9dcdf26047e2f48a1fb7e7a5c3552f6bba14762813721a912593c67195a0cb9c7d0be6026838e83bf84c5516646848cb96b96d604be246dd622e8521ae914428f0f19839546eab2e734d3c590dff369fc83bb06a58e34b06e1bb74d17c77f96ce1c5968120a884069307a190bb45bcc97e1ae6b8b5528e900326c06525964978f6d89d11aeb3560c3f67a5207035044011a9377f81ec21f2306ac471622b692040cf0b50d86acc4145e953f5ed43494427dae42ec5be98242f884e23aeb4003774e3c53fc3dcc0772d59d2cf8581dffe40a0a3dfdbe5a35a0b5648a2cee1c24d69a11a740e35ea900bf6eadfe2ae1f35e695e5b3b4f9f274f0f2b9ed7d957601e0334f1814a2437182c0321655bda31c150ec2bf527357d17371e07237404ab1481b2572692621e1eea68c658aecbade376e3f25ad5944276dbf79f0e8a0cf60f6ba1e9ddb306b5b85f82023548190ef8d184bec50488177be01a179af1ce0191cfc9cc83fac3ac4fb4d696d2bbacf1042a792d48b32f91c2f545cee579015d391539c6e3fe731c43d1840949c7820f301b01625f6fbadd7694d94b6514a75b937f4a7f6eea0f4b5c9e944a7e5e512aed0c5746411e20db191a06d2ef113c889f162af7865d0c68761e339df242fdbddada0d13cbeec68c937735cf7cf1e2c4f8c4be9d2fe8c5b9348f51030927c2eef59314f2f1991ad9a441ced986facee352c3b2b5fbcfa3c3953c2b24f69f2a2575a40a19f27ae9f1a5e184ceeffe5d55f66499c5d12962c31925db748dcc97615bb10fbc111ec8dca2597082166645d4b01d8ba822a8979e977439922274ec785e81321232f53f6f3c6cfe1034cff3c9854ebb3172f45b28ebd8aef726f1de530a13db34fd1a231d1e92737c366976072aa079144f5b9ecbf4994261a076fd4976251c6c8b912c310c6ee7025e7fee0aa758a9a5a9aa0734c7d7adbaee7096580677326f2739779cb60cee22fbff4315d8967dabc03223ccf3c588f8fba0d098e754e22d2496b486385b6548da18e0c52b4d7a7ab38ed3ef2a69610a59172678a9bc58edbbb217ba33f17711aea1b6b2e366533f645e9291ff537b52edb5136d9ffaea36bf9fa795ee9b0cfe96ac61caf018ca47e96d0c7303b903344466bf61e9fb4d4d89cf013078b4e484b30c23ff4860a1ec35a55db6eab8dfbeb64b33febf3964c3cb8a95bfc428ab4be182e598f47b1645c9068a5568a722b41a408473f2be34c409cc56cac1157b8a3193c2eabf4081ad96e0b15251e60dce967fd99c84047d22272f5e81b59493c67da99035ae5e12084ca8b91c2fd9048c7940d90f6c32432d59903d527ab1b08bfeb9870dafb007315d40ae05aea7c30d20b87188c9e5a8ca1cd383f68463d591836f8ed461e1378ba1ad8e28bad63bf80e2bc1553ed96c03d7b2459cde714e4341f0051601f5637f29215d7b242ffc829475d4c5597d783b87e10251a37f35b2dd751a006abe2d62bb34c9874e40f7d7ff67175b7963a3dc89c96347f0f2a2cacc98dbef64690902a0edfed8d1cf1b2c9d56aa4d12fadc54abc454a4aea0c0ba09a41548c4c661a816063cfd9ba8541611a370b2cc8a45a67cbc76b37337ef987b300c181131531a67752ceb53966a14da26e4ee1df63d013b5879fdc3cdc5d5b8a6806b150e83204472967c1b302188dc9254106fbf08ef002401c007ba58c76d53959e69a4bd8cb00665092268eb54d72b7271d34aa6265a2461c51c5a89f37becaf27fd8d881706bebcbf5043ccf58d8aadcfd4db4ce6bfcfb2405498ff98b79cf8b38fa3817c1a4348b2a0cd3861f600b4a6d803efc19eecd185a043f0e1dedbfb2a29397929f46a9ade367edee1cf6172715ca06345fdeeb88d69d55c8867dd701e51bcd308cc7746b1b7b357091ca0c6f3881d4a4e1e2ffef2542030ed4acf9b3b3b2e9ec5c2a10822737aedf17f2532bd2634852d20f55576cca494ff6a67729eb49cce9de7b746c1de1c409e1b06b91733f1653d72ff64f52cc4abecefd3a00b06811a5c71f311f3ea8542698d7e5b5b3d0698193c88b2cf1c9363ddd8becb9e215cd2a3efc64caaa54b263a883e0ceb391bbc0f8c30c55c1daaf11e19c7ecf8d55be1b07f24f9ecc026316f48654928742767e9451ba8af33b0d62c311453540eac7fbe86dfd76649e65dd69d9c5d65fb6949a7a1661358cfea751dfa49b7b8176fd68a9d70811a6c2b97bf826cc8c212c344f85c69084e5c109618257c693ae87d4e5e000af46feb97f709a445baf0aba27c3815fa09df852d898c2cc05273c6dfaaf30dcb08110dfc70dd61519610f1d0424b3b7143466423e47db63a72b09cf882dceb448b5939f00db47eb62a6f9e0405457b5af59bb2ec739abd4e6ed91e6dfb676748f445b5a09fdddb50f635edffca07e7a6bfcdfb4163330613c913c0f9c3b2401deafdf8fd8300a5a4659120a2cd9343a03b6fc6fb8e7dc9d39b9db593702cdaf82da3a13999d8bcab2dca916e6b133adac39ef766976500f4c4e852e1b05885d308a0e6a20c1c4b8b35f2d8f188e363ce82eb9048832f39244034183b8ef5c4617434dbf9d1a3cb8b08e2109cf85afc44e0fda5c75d1cdb7e67982cb05bd9ff008c3e0605fb55463cecbddd7375abd395dc0b4dcc48d5e8a39ad61389c0a4d2828448fa55aeeacb2a1bf541a790d463a3308290ea931e0a2487ed006cdc1d8ebc93605f35047ba0a5d7fe4a6c8e4e03fcbf17a45107944b536b6468c1bb36ddb52ca18b8f31e8aeebdb2a442da1d5f1c506b3ddfbd749fee2fa7c6d99c8a7a6dc78885cfebcadc836a3ad76bb2b6ddd714a920fabac2bd76d253bbd0d82aa9587d6930ca1d907e4115dc37dbaebe79693b7320596686f50997e811cccf83354734455606ac2a0f11e1e98f8c9f7c6b4b7945cb70b4399ae9319547bb95edd4498bdbcc4a08c6b73b098611c515da336a99f6d041bcce784ff27423c4db8fa43b4675024bcb3cce2f2d68f1bdcb41de42d25f17f4c99379c00db660376c7201d8c729042e9f00966a196cca3c73b6213916b27869d650e07b5364adc453f251fd02ff0257f38b31a3dfe0e6b5c14293b535e93e3b348dbcd382358f23b34cde5c380857f097e7eb671539d19a5866e1b8abedbfb6b119e7a1ff1cf0a1720c811600440db7f8c14ee960a64857f5fb5a38743a599712c95985d72e472c733df3647f8740d1670c847d79990f9b8a09813c198e28a1c7dae49394a56880984fb7645a4f71f6a0a241d4db7f3556bf8a55fc51d38831cb4e8675bc14a55a9f3403c81507ceb24d21d34a5554578cff839e662c24cbf7c2faa1f4930c1f4c8d345d7badec73d78d8af97a7e8b70ed1bd21869fe19ce5a8fe1fef67fc0b196c5ce6eeb32da721fdd12ea785122e95becc2b6d67c0a5f082be77cd17cbd256c7a77373ecbbcb01a34cd59f6994f4db85231b456abe2ab218c8f4bdbe0c0e9e50a1d2536865518999198c5c1e25fc391fc8483514491ccae6bbda78aaf193bc5edf9da435a1160678f6184ac0a1fdb82d253b06f513f535317c571c8ab34f03842e9fda9df71fbaca0f2d730065bc6c0a50bbb96d318fd3be53365f6fa125335d8c6c1b41ca321e5e2069f3f384034da0ce0c0a1deb3eada5248b8f9ba006201b093111f7e91d3bb639e718ce56ce020dbeb3773c2d27ebae8dbe3b44c67114959ed6a7dcb94a8fcbef359c27a6e0b1644f0dafe166dde110054d0f81eb0acc76b4292e2b57767ce35f39cc2965e008bad8cbc49cbb45afc94382e08527f4c0d4a9eadf73cc36bd56446583cc9388750b4fa5ad3b07d33b77dd40b7edbce5237a7fc36d269e98e65fcb7cb50dde37da21aff36295adb22e0a2fd1226d871d34773eef8bb85944b334578b080432d6e50a1433d01ee0686a79f08af0a526dfc4a5d7aa97cd5f2c9b87c05a1a7f57ee15aa4008343013f0e221c51c5da013b2bba204698d7ef8f188841cac922b91247f60623a4eb60547e77019ef822673c663cc64944c39437a80fae9ed64a8b7a721b31ecfd609e4a48db2791d4114c04c91bf8633f4c7458aed4548f8c0f8f5e2a18e1887840617e7e846d2b7fcba7b2bdcb5eccd74e4a9524405f542c8bd332b1d6d290d35debe2a90391bb75614ea1c4bdd89b4ce44a43c4ac786886d886a3e0b00eaffc7c74f78229cf00179a4b456e88b849b5a25c2e30c0b1ea9497668fa79003b7f331f427befc4dea0c27844b44dc4223ca6b41ed78762f1b10695191ba6f81cb73b643fb3c35062827121eb4a416b7fd741e49b49174b170b0107ac3598a30589bcc6eba4e00aa6654cc3bed89ae0e27e438c7e89b45fca1341457e9896e3bba170e624efe403d2523a6da0718ec560e1432c96d6302eb1845ba7fc6cbe34d46c9c7e76b217b0ce4d52c7e20cf9fa8ef7458b59dc3d85d2f562119b13ed4c6f07599b2f613391b9b7702b6824d644a1cd6fa8dbb3abd4b33eb1643732ca9f5605416a35be362cfed7a6a2d94a2ad295c9fcb78d7fe97363bff1df7b56b7aec6688a17a477773e7ab15a0ec8448f60a43b6be631c20ac6a0b1cf2993c18be3ac139f5a26dba28afb091c0a03b408fc34e0001e5fe89e5dfbe074e6d0aea67e2d22c080fc3962e67d1d6a52ff196fd3022165977a74fd845bee2a9eb688278f84b91db63fbc5666694f5be76b8c767d68f72ff77826499e8d0bc6029748f3876ba79ba8e43abf072376b2227471f0e3a4d2cc653f7620310eca2bc7e587b43222ddc1d72579ee0e6bd7861d3a24b93be1b3b1ee4d6dcfea911849ae87f379900709dfcd6fc89b4c5d51988766fc9dd9e55ac3addd2bb5c125a7427c44015700a8a4245027ef19a2621066a6afa4d1fa6595e952865b42ddca5cfa9ab95f7c5ffab64cedae99957ed0ddce344290c8f64224974fce95b6e64d4097041116a4cdb43f848f7eab3facbb6a56c49fd06bb49747baf238e46910c41cd6df1916282971bee1d0ef37d5454a2b7c37a3fbf5eb391e45f1578041684e8ab1aec9824e173af5c7059dcfa78e5faff77ca1fda561da686a2538ef5ba805717904a8a58452a7e3e5d46ac3622b01e60287ee78753f15ba9fb1f96c4e79da4a76998a45f48da9d06d7c7797ffd86f152adde72365fe512b8125528056c4231bce3b4ed3d66648c4dd93211c83757a9b02afb600e7f7dcde1717c9eeb3d0b99f1c59a803bca999099829e1c41aec29e7976b5c90f3ed9e001d2890b19ebe8a0a378d6f9faa2c5fe5f52989ebfc4437bf00a41b2e4eb93477fa1eacdfdf4a175c74f0d9976cc5de19b84818df30920dcb6914aa7212317b7dc83c8b503091fed257b42eafbe0912c0f24323a144223ccda8d63dc845b69fc814d89a6198385962ce435727a34a37cb4bbcaf1a1d8195acfc548790e9d96a61f6077bbf06c3f203fee30cacbb184f7bffc750f95b8e486e9d0b1147b875e56b4fac4a8bdbdc8f5322420a877084335c5b33efaa3fee219884fa7d1cddf3ca1923f5120df376229db1ea9bd5b0257d3a3fcaffecfa0786722d34973fe634fd853c2c488e52d47ac67bf62f0e5f9e32e19e697d1fd262d19be795eeabdc3f473bb013f0dc627ef32e03577244ffe7ff177f97079d8b5e53ae167822b4006a1e6a472a00224a90e2e74b4b651d9ec779aa070de791e557eeef40d6d2712531f74988a16e007e13394da1f412182b5c858d5c298d122d9246bcb92170583c1aecd088c1158b62cf45e21b97fb7a9a45a87acd6006cbf2901ad8563fafd7cc6923f664b73b74b1b761e4cbebde6940c9b8afc97ee9bb404b6e258f4a7e2d44815454eea489bac051053b3f00c7c9a4019f5fc6664e8196e2f573e75ff9eb6cd4b0488f94ce350a7f4c82f2de1070053959f00d0560e1da893058725f516dcece329a979f1a660cf91d7755ec88bbf0fee69a95970cc2bc439986e9800e02c6c14be5a1178c6304d88f46c9d0d35be53e8be0c2919a5ef03a3b3dd0ffe2dfe8b097bde874c6b155b38de300401d77dd1c1bd7d4d27fc6b36636873cb4d817f69701b25daee517312e5ec271cb1d469ecd052f7165e74aef2d1c85665d59cc89eed6a5dae4cf4413f97f186d250d4ce600f1f5d5de072e6ae2d1218ed8666dab32f6344467c8a1a8e0666d6e7e89e0143ea420ef179e4f5b2ba23fcb21632d0431ee3e16bc791586fa2543d6d464c628718a9594546acb38ab5a77cc12d4d3272308d3b159855743341e1466f89d59e893c62a4d0a8f5c2a75f241147b2e9215ba00966214019dab9afaed359204fa32c2ba8aac7952a784aa556ec585e43e791b32011ac08659662bd03ddde11951a037265de204beb7d06e2c8ac5d0d248eea3a5057bf25b2688c9777b90deb67d8f0333940fe21561548ceb0cdc47cb13caf7d2ad7bb6474d6886a347c092b5ad3854862f54b1838edbef0391bf1507a7bae67014cd78960013dc60167830ae13d5d7e98bb714175568885c4d5c00849a977d208673f3cc804e2e2ed31b678e493393ff393c739305bd4c8fa53392f782a6258369d3bdba501f8f988245eb43b607f26aa89f16902e3ac5481da58d34cddcde22f6966b18619c3923d8d4ac7cde9998c0b93248a4a19a75514dc513eb923bedb627a0d25f75d6b0b193647398a68d0f933bf6a52f2fe77bfa5114c04fd1f70b6bed627da38a3e94100434f1779e9d9a5da3bf4e5160d5df8b617aa02f9a4473fdbe77b7d7766e24dfe7721891aeaec8649e3f505747209515cf42df2fe779a14d560782eb0a4490031bbfff84596601a092487a37b2e7ae278a4050ca6df213e7e3f4a4e78772b71b39c3d6afa77ea1ec8434fdf70245027673f74b0a7988d6e4238dbea71c311ee494ad0f8475754d2d5b85e75fd9bb63bcbf0f82434116f4b46932f618f884dbbe5050a52b0f9a37cb1d7991cd75fdc54e2f938e051349a4b3199e9e62e5005d733c8edffd5f2d8eab51564d22a524bfd1fb1069ed4a5eb9d5871718218b048ef252c65845328fb6c570ca6cb5613e6fff4e0ad0728a902f4dce20a5c7e7f2a656ab8da0a04f833c647f39ce4cbf75c969450b2fcd29f974d00da1a78321a5e458cc123c9b53114577150ca58684fb2979adc13aac6be44126f7520ea951a97dee86e4d621139a098244171a544ba3543bd3da4be67a88230d80bd37d7a6eeb78a7b80f173edec6fa5c27825b82afc43c741932b327ec5422d28777a4469d7d98344fcfcc3eea0aa96c46e02645e2c3d0df8b105f97458dd2e8a745fdccf4febb68fdc58b719a7da765374190a266bb45f85fe3def629a8814bb691e706b93b265a2aeaa7e744d769dd297fcf20e557a86cc78ae790f11326a5dc6526129689f4dda734315609a3af725c962a44a5152210a704ba577a0419224d9f0dfa34e2d97ec21dd84928b3cfd8b6bc38ad474d4f03b6a281d7e7d0c1860db96422a9849a81fff4f6c55adafc7f56630fc15033776e1a5522da0e90a25aa1e9e43fd421463b864cb1a555d104d7e81e1c5561edfaf2df11ed4c76998abe2b7d6e5d60f20464eb538918a774fe7b1733a012e07961d206cbb9f97b97d144163bed60f0adaec76bc9ba7da94efc9e39573344eef0a5c7865f3e69bd96fc340f38e2c57f2bfcf6307df3b3c4b7622fe2d36d6bcb85e54d332cfd4298969c0dce52f668f191888a5e33765e9285c0e4c862c657c299e26b575c1b2d6ffc44328c7d4f2fd2a0caf243e67f9bcb3bf333515ba18830949d29b8b9e30ca1bba17fbd4484ec1685721c5a3d5bc2e3c265a7644ed27b6f2e0fd5b70fe5762ab88949d92c2344b2fa449c6660b073058d4b22b474cdb6b60ada17edc56438cfecc7db1979a2b4b424dc02e425c4d06490f27172fe048c8110d76e4d666007b763f2ac29229126f9dcc12e812b481a6181c26304de2752c2f9c11adee1bdf9f5fee4c183baba91eebe93614338b92286d5c0d865c135732fb0f43dcb657febcf8b180be0bb5756103fa0fc8701421d801047c45f5eca5865235e23e9f8d27e601a01253b4bbd556b5c7142ce3714c38956da7c32cea0705b0c15f0b81463ec7a06f717c59f245e5618ee3fb00866105b6dd7509ee1eaec6d053a1ae0520bcc58bef6490c20f1e03fbec1f6ebec4f67d347846edbafbf61af1eb64c56c475445f7884c560aae14aaaeed5f97b1fc0de1768f18e3891ff0f32ecc12031f679fd6f83a06700980ecb3fc83e3029d0329bb1a1dc2eadf942cbef1f1007c02033123463333e6fdb6bd2080358c16f1fff67ad69178a98026289eb8a9ceee09de0913ec62eb07f3ac4737519ef669a8bbd6194eb27e74a88a5ef8aa272d67e4d17a9398fb2fc41909da64d33d4a1072ff6dc3a63588a5f3ae47f68134bc1327fc6032253872496e4adb27b624f1029bca58b1d857fb512d538f549762999c60bc72f57a9bce16adcc0cbb4c015f576ac7577fb6a843c2a045669c31cd76180b042d3613bbc0968a9abaa81bffa67a3e610b389afed91f131b64fb807cae51e9d27f399bc767e678eca2c470033eb73227fd064077f69864182695847151e4793d2e1815b1b4722b1e7bf1a8a37ecb20a5ade410d7baec8838509fd8a282a6d21344969cf0f4f0bfd8dc9478754308720ccc3c4e1d83595c82a3af75d8967b1cae52413eb69d601da44bc88a9f6c18602ad1bd5f136ae045344b8e77fe6178605a7df8e4816c59d16785c2388aa5dc4c89ce8faf588fa787841dab94119f26d22b042560b6b40801952253d959caa6a77e01f0e1ae5ea4ca41733b82db686dba72fa34424994b72c69e84dcf9944c0d5414a5171eb5db4c660245fc6d0ba1c1e6b688fbeb47094e303e4b7c4d96fba0df2d8696797ba5ca67b4560c4b111d8595ca966a422250e8f93622bc2ecec379f86ce73bb18d00a4d28dbb9556aed1401372598c759511ead216c029c07f43ce8ce25497030abfa4d64201452f00077480e5b9ccd3994cc41c760b5f2cecc44f08b93f27a2eab2140608918cc5439a277fbfac9850d60301de3c2bf8d41868246f9e1fae656a0db7bc6889c79b195acbc2b2502f07ab5648dff3a6ec064c16b573c9cda8ebf589ddf733905bdf601583d408a75ff6f5eb95a86b46001cd2f2f833ae7b64cc7e211046a223a3e4af8b845f8295491a9ede80d1d94941d27a3cfbc8f2012a376c65895acf9610b383674bcd9cff75abb57892e4fe143648d0c8be2c9275c283f05fe51deefe4b4878694fd0cc2f58ea2ed130cfdf33b1fefc067a8297215d532e83d86f7f361a6dee19b001ddc2e521c4cd67f7752100fc499282f7ea49cc9bfa4eeb88eea5b3abb53bcb15c42fbd86a47856216b6b17ef9c70582025307b10deb56fb210d31ea606768312a6bff903818e7423d4abe36eb57325463824248f7687412338ba35da0c5599adc2449a2ba0d0ddeaa7f11e474712ee1c7f1db1425eec033c799bcc8e8d331e390904b6d5f9025e0bf4d78edebd8196a7d1bce07b34830100acd55642a479c68472139024a9f810b84dd3208d3a1ff9fd1ae11e28ac234f9c13e3cf1c5dca32505b3e5968315022a95e0bb51f0e74d0df6d5fca2526516d0dc35e7d344bcefc82dc1465001f0c10c4d5c24da25810b57ab31fccc8a074e98404a08aa9149425279aded1733e0a3b7065d7dd09f2992088ca7b1f394b931a573a23fc944687f9001e7f0262311dfc20d6ca9733040cb2d57c1f908addeb2e5e5e7f951f4ac9db11a1276d20d6b406f2a2692647dc6b1cb8f329a4a4d6b36dd1fa9578f82db6249d8019ba74de247c7505a6058ac2f9334a22c7348f6be31cfd29a14712429a70d5d6a7e6c9a841b464ed59d76d49af32317365601f3d3285c6a168a239dce15f6fc4080e61793d7a005a371246b842b491480a4b0345feac180b0798154a87a903f1f4151888f64c12657e24b55955b5306b892f99b065d2217b3f7e3dcd80270fce2f9e97e61652bfc0346e9d37536f8c4a15f48e770c0a09cceba66e1cf3708b1df83b1e28abfb2fb5d262870ad7a5f4e2205f8b81306bb8d3a3a42b97ef4aee58c58b110c415b6a91fbfa7ced057180465e445a12f44a323ee5ab2cc0c042912a542e3ba3118ac161044c8a8e9b51744b66117eded672f8b2a1c4399194d13eff98e37cdce6f28dd27ed0131e780a7d86883e7df52e069eb8b4e0c6a8f46f9af4ae9726b3d3d01e1046ae2800a6c93c544acd6e9beb8df0c7ccbdf4f1cf16eff0e4adc89efc5bbdbcadb642f9aab4c4e505efaaeb79cfe937285ea7ed387d5948ed18e24ad9e077b3c8e31ed153ee5431f7406a4922ff1a800e2cffdc150e41a75a2cbf79fd1aed9bb9f075774616ded6d9d99c1c60efc47130195e5f738b69e9d489482702da9677389e3aa24d6fb76fbf30cd6afea3904d734406d8bb5fb32d61d74ba108cf3740cad2791ee50582dc1ebe3caa70907943ef1be9261e72283404562e9b47667be5226034a2e94ca4a9d98e31a9f15fd3676ab1d501ba25794e12411b6ea40aed69ab8582d941a3925ebb15d16d553a8933621b798e323efc64431ea9f881bf954d7b44b1cfda84aff8e9d0aaa6aa992494692c68cad772b5f2972938538fa8a556308272b32fc9627cdb5debb7dd4a02090f07c5859351a35ae2f65684536dcac34e0ba89a84b0bd473123f116964ffcce3529c72d9217c870ea74805bf39fbe7c77ca0240bf4604d698cb04ab2ac0c8b038da8838cd9770baef6adf121f32b69a5f1aeeeaffbc1c0f7e662698bd24be6bf284295e8d2fc58cf5651ff571a5d736c01c3d3031a184a3a24049f2bd4eeedc0b1c0df91a3fb98db4338ed8220ae794956e72cd7d210a295b88caf7632be00b3bb9397a3844afe019513e3d03a0d0818071aab46d10b19c8f47b7d3da26654f14405054d8ace7ad740d8e297dd356d12018a221951b6495e6a98c2cc743f0b1899ef98007b8464855e819fda53bb7f86d69f5a6cced8e478b909ed4be8190634d984b4e31ef7a2fb7d28216ed4e982eee432a99731f9bae2a559e11e4f2cbc3f0458d8e565e39ded62aced45aa2b45ea706b90d7e00f6b77e3a0d4ac920741a3b730b4e6668294581cb74b180bbde0ee29df3525c2eddec2e680d8fd7c0014713da359fd22258e50303fbe855db8a4a2392a3054e9cf82f48993a001998c68cf5f8b123f19445921c43c55813a42363800a80713a1e511085dbef4e88c26d8e6dcd345a6f449edcc9ccbda6a3ca9a9c91767b0913e98ceb9609ab0317eaaef7d1cec5730b3282e95d0bd7f68d79c5edc029fb7c2c83326cc9999f28693eb5b3aa1785db00a715ccd23842d91cde7ba00d118011660ee55d08f83b0e2c760c8c1893950ee8061253946057448da9ca45e48cfc2e80523132822e525fba39518ed4b7e12813976fdab5174049f6f399dabe72d9f5e1dae6c4a80faa5b57610f427d78ee742a2c86b30f8ecbd132cab4d5e28b2288ef516646c4179d5d327d112e6cc06d3bd61bce397e577771abe12dede4d219a9873079f49449f30066a6770956052237abd1b6ffaf49a768d7eea3d074e3e2c238361a910d9adb2a2d7eb8ca54b9151f98c66bd60814da7d57677f2298d093af1adc4cd69a142146aaee4830c2a1e11026227684c43cf64e334ea44900455cd8ba0bb81db93e4fcb5e1d37b859824812a8ce8c2a5e3963fc01e5d5bdd8ba4ff1260c6c8a2812a6faa1a8e03ab95794dcaaa5a0993ba483fd24806c8a580f9a1f26c17c357e34be7c0be7d130491398fd1d06cf354e0a509e31751a5b6b76d5cfb57d2ba32c6cc9373ea5351beb92532909e5f97c65569ba3ba5fd4a0953587c0a484917190d7868be149d5ca3f66eb8b0f75427c9e93817ed47b507b984c9a627d7c8634f105039519386cfffab61d3413b34814c743b23b0524149ee799f36fd1ced4f5e80e7fa23e1ee6110bb524a03e6d6d6e2c62f1192d84b818b97a33fda0fb3234330e59e279d89c2b34fee9b1252ba8ac8da022c3a3b54b6a2a9bb9940a8f39be5456b3c4c374d36347cd74ca2e483c229fde1be250740c2b6c053510e8a0fe9a4cd21fe3b818c80afc2f4cef41f07192a611446a807a0d25c69f0135507b5189fd4a24af6404aca9f21630ab91821438f4950e8edb3f865007919f67e1bc124f67cb04550eb39e45fa412910d9bfc2349458f680472b6d688c60388bdeacb088d35289c577af4e59168427ec66a47c5cb8dc67b3b4b81e0c46cf2207be52358b48567bdcd734da74160ce8585e4181ca2324b262f91e0a68ffaa6136a319601cb0c71e0f7cc88be044450fcc01db02e94dc316878c939da6515da8fa13d82de021cd76bb51b7a4951c50acaec74da94f5aa7b2763d433e1f9f1629bf316c025b372782936f424aeed9c00123e4aa339d09833862670cb2ec5fd91d4e8d7873f580266827b263f2a63b9ca1ef24a49801d8cbd1b0ed0404fcb21d2fc6b5a66d595ebaa8f43d100116442547620d803ee00e390e67ae1d7c4cd0f24ba8d065d212af7f89845147756e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
