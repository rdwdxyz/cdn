<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34ef76a8182b0fc4f4417b590a4df2aa46c80fc7642a461878203752f5dc699792133712cefeafa8349677814ca83cef032b110915dd18b375f312f7a2b82f063fe6f69cbda5722e65ba25250c23cc6edfa202692f0965a7ff5442834f1abc1b2a7cb30736913ea89cdacd8231cc390b8f4e25d6b2e232bbc1e9d4c424b045d6e9d165dc0fa8bccd5d8cbaa82eeabbb89fb84c8c2360e85137dbd3091e6f096d7c1c4e204155998e42753c1640dbc49b5ba7066270acb3645e1c3c307c195ff84c19e2ac28b69c934e84c57d034005302f07251723d81be45b7960ad25eb72023f88e1b6855cee39a4ac07bf48da97e88e05573084f0c111874796113c4ea244a16bd75de7c6e3a880695a4157c13cb633d09c33bd4b0b5f25587739d2a23f46fe3eab087dc9940bc8bfcd8ee8c8bd18129182ad92437b73162d0c2e2053c900840766526b032403efbdecbd7dc8c4c88f7558b006c8aac2fd08ab1f6a2b6f1ddf3c96c1e7b0cc03689aaac00702f87056b62db9124a3b9fdd5e5e5613d1a19b74cc2f6e7dfceb9351e34fe242128d6491cdb667dabbf4fd9e56dc0597da70a55985da1fcaddb803086515087716420fdef4b33ad9256e7f7ab4debfc56b223358ce9306f41af53b2b93020599fb471b32b001312a2e49b4619ab18a7f327454eed77aadbcb1fdbfc6b6fd9030c65b21aa2b9ceb87d69488859568f6cbb9e5aea2f707a438a1ed7ae666cc782cce63b913198ddc69cddcecd0303472a53aed20f83d8057be45b8e06b4b65d2c974e7afdf92d7eb59a2f9d02f04a08edc5ed7f23cf51c63164f92fabea12e8c1084105672949a27f970a4103270252359fc3c0fe839633f0f1e619be2e36de1d4b557ed4bf8e0eca99d2a836b126ca374d5bf6d3ee0d85a32adec52bc8722d0683df4cde99fbd549b9cc2c30148c2e81bfe32edc324aeac74dc88c86512a9988a43fb156a1c25971a74e9bfa60ef3a4aebb767eb492a77aec702895e582ea684124019c419cd7fec19e1cff9b2e88c3525fc3bdc17f8a8ed7f39bd71d9f2e1551b46b66899a78d211fb5f6ec268b0090da9a6e334baa0e02215c53b5e4d3083a209816f495d5606e98dd41950d3ef200b081764b3f1ebee2da254946401beb1ef2782fa89da1a2734e50e603dfd2c442824f95420fbc88b0d888677d8c45f2f0575e32513836a01c88591e78280b1ca2d37fddb065ad7f95475c8bfa6e846162967df04e0a35dcf713c4876ab9ab8cf4967e5356a8eacb9230273834640b8587d6d36c9e143685259ef81ab0ca3a8b4fe9a55681c723549a05d3f40611419e4b071b76dc43d15c737bad7d6fc7bbce1d072b4d8074a322b60d4d659ee1ed90dd645f264b59869897890427d28fed307d68c6bc3ddcd50b531b1a21cfeff083926884ca3fba6ec4254b22b7bdfd33179a003a1039706652d770f948672422a49e3bde0f45b457adaedae4ea5cc52ed7341e343abb75820cfc27cf9955692533130e4acbcff5e6ca031d134595af710201eed7fb30a6a6d04b91ca5e43b1aaaf12994c764aa38a415820e91e20aea62560509971232d0927f826de9ab7704d601582bb23b4c0957d2f39ad3e4dfa97f354bc701c3b50b8c147f3f5857ce03ace080c44574d8b0facbeabbc73ba978f0aa9c06399a935f7c6df0814387fe088329afe539fa6facba04ea1577abeb9b8b90c4edc989eb8936c81abed790a62fc9b48c1166e3b302538ac93b949b7f1336ee332bc554220c1f71375f1ee334595c188f5995ad4dd040aa7aafae3c78b2797b42f22632f1bffb203e493710f506d8343c1760c596ef8d86fe7c98a1ec52dd354f5309de4ee81651404c10282333864493018bdc0fb6469c6c2d479c46a345b62c5d2ee541c877b53c02c55e6c1f75dfaf54a37f6e43a92691368c827be1b19d67e4b6fe84e1452b1a738c171d682a5636d1b3f62eab21442a347821244adbeb7dfc64afcb27108ace6f082ea14e495b2ace6b94a398efa65cf132c4ebc370c6972a9206ef94630d72b39660832ccab8556e50c7099e0f54acee28e4e7cb1924d95f7c8081243f31b1ffc63855b371c1ba392a005c4c3135a58dc5148a0d5cff3f8f384a26961c6f42a33ddbbcd6758353307190ac79810d75ec0e48ffdbfccee36a319e4c2680370797ea5bc33390f93f13d24583e6134f55a1879872ad2c1d9f1a93bf827134ed67916162ae2fdbb02739cfd0f0a252154381ddb3ce7e5a0a98371ba4647e1807de266b2d44c87b597c0a8b0f4c3594007e1ebee88ac7abd893bb4d6e896be526c833dc7894f41f89ebb21dd2277e5208d9d40d8fd9e9132816286e5cac84facbd30daf0f31f9cbba136d8176b6173454d7ae1f7cf17becafa03330150eab889fd9eca57ecbb2038934307666f831fe7cafc4dff72d62af5e97431a03d74fb9b98f122085258fa8ff646a09cbc38c06847c47f816bb10b7314de949b8956ac3562361634c87789ee0e7fea2477c92dbcadba172dc2e0accb47a5407890b03ee278669d780eebeaa8688179f793234858510950c611ce280b3d9e19286c437ec0b3e75b1e15f17f114835ec943604648bde042073b8f2c5956b875c5bbea18a786f147ab6426bcb543a831c29c1870164079d3760d2f20d2642d5f9263f5b07fec5ec0b622aff152a39d5b820572e34e88d64435c536f487d5b3deb0061dc4ceaceefbe57cf92182433b4866f3bba06b37704e39876cd551dcf05f6787baa217859ccd04369bf0025be87cb1a57cb6175cb165d0d14a2f46dea0d8bcd3072ce802e763059ce219aa2adcdef18be8a071174a141870e7bfd60588a70bc6c6ea051fa6148e800146326d76660a7793840283d6728ba1d7d45de6c536c987f53036209a0ca8a8241d6c9f892c7f114cd503b754ab30391bbb318b62a56f8f552247b2d05c0ac4ac7b958b3bba1b5fd17fc85ad2b676b5619b9baa678074210eb983b3a6432c714d3d2ea656a8f5fc0b7e617407ca7e05bdbfe34b72d657193936427cd430e2f444be12a5c1b38d0eb89043457e400617206d1eee6be5dc178f8444a9635373bfcb906975e9dee0b39b9d65e24d17eb8c7f3d793fdb635ad4b7d21b92b9f915ea18fd981828534f09c9276f16ecbe6973dd7ccd4405308ba4e4d7f1ab4ee3313c3823c567ec48f4cfd65c560f694f9455ec6ba3b5534deffc8de926d80e33cfb627b1a3095d5dbdfd866d1d216ca42b7c2a7f8e6c87f0ef75d57ef9565227b92571b19f3ff4d889ec34be5ade608803304d218467094e43a2bde59dc0bb8c2991934e7404984f67054cc0c41e7d00373ebc95b414b55ced3f6cf4eeceb401a678d65c219f708f7af2c76fc4382a29a6e88b7c06cc4b19c95b71bea4854189042c537e1e26766807d0dc793a618a14c61e575528e2002aa03ba4c3136631b1e199d4fddfc2cfce6589ebc6efe8f6d980bfba719a0ff7f85f2b3ed7f1f70251440935433bc988408cb0cdbd3f51abaa2f2d7eb9cd35a8e79588130750d7c2b63d5058315d1577abf2dc993cf9650a4f6d0de09e3e23313bcb6f1392fa02a9ecb2dd5c87c53af2461cd961f0e06035ed854aecc80e15b1b13358c2201c2ea47502dd6945d3bdb42bf4946979353afd00114ed39a4852676f544f0193c45a956076548b6d599aebebd775bf619b31760ff9965dffab0082c2996f1300599230e3dc3c459e6be8f70a85fc3c758d45414973ce0d82f43a01a650a6f3d3638d82c15b6061b9d3982e2c46b722f02b60d582b4663c87663d0fa906a08074c1ecc197c5a427eb855b9b8a45b00ad5126a5308e2603bed7a617d5be72cb695e85205e6ac46456692516b376c08ce74b7946f1af2b1d489c8cba236effe3a7a8b78054b640adf2783b9c7c6b4bd5f384b5c296466ea9245ab99fd44ce0c507ac1bd8c6dd7bac2e01994b71cd79f902992dd04fcd940b4ee486d22901e6728139c244a2807c2754c818d97da22d2d9fff056230d199966814c39fe72abc85d0609ad515e765eeb7c6fce7f312c452640039bfc7c4ec92434cbc816e55c9ae521bfaae22b29e4085443efdb640b18a3547d7ab10f232e621de6adaec4efda8fb87b90b93cf7c49cb417bf9e738b6442543c60ea5e798770719e8a80c93b7558efa99132e368d27c77b5b17de03b869ad60042a69cbf7324af8578a71bfab141b0b5f342ca707365711c211a5a82822c9c23f0b28278ec865ac1cf8efe523ebed89d41bdbd2dc4b363b395973bc28149687dfed0e63caee05127712a743c7676732e01a78770cf8e3e11f50605f73ce2afcd51db77286b73a2c88c4b7f7f3cb10ed961cf6773b125287878ee9acf1fc71888ff2cdce46d502cf91e36320d499dc37e6fd1e71589d1a3555111b7cf04ac28e899a9ea3da983c244a6482098d664e773d1c1558b9b8e26512d9b62faa8f7b0fb35e5db37468e38de84d505ef3c6d1e2d21126bd6ec058829880521a50f5c860fb4239a313ae5fba0bcbc03a66e2d99e0b621efaf2fb09da2a0e215c8681e7563595c4f7699e611468108200cf391df0faafecedcc8778f3acc88140e2a83fa1877db9a99bf770e129a0818c36ad4902aeed0820fe1bbb78af6d66428b49ea06941ed5e5edb85dd3afde8c07d1346aef5c3d92d64f11af1073d167ff866ddea9c01061e63857b81f0746c99593cac221a16582142f476fffa42ba710cde20ad2a64c218ee9cb0dffbdbb2bbeac350bc1d52b0664cc6d213efc2599d754ac2fbcdcbcd8ec75c2ce47635227c800e94f937371d0e9cdb70e9e9f88a40dc1d8b1c62783d3e69801d7d766d5f835980a9f90b58f0ef91a741b512fe5c4fdeb4d944ad2c95d048138ddb9ad32054811ff6a31b8656ee86a3dc5039c56b59939b6ee81e1506649dd5f8a2b1d7a58a393e84257448872e3bc7b119b95fce223325d5828dc422c1efb74ec4d8905ad1f3b407278ddd9e6cd1443684409c0d2bfcc8d4ed40aed8d6829d81128e4b6b3a4026eba1576a313cc841e48dad0247abc9e5bc4bb12865cb93c2c37c6cf099eaa94d3fb6345252c3a5dcb4cb5a07f8130827d0f020e12e3deba1b772aa084bf7195b92e4b543723187640a161cbc9bc3342bc5b9062193e500d772d0805bf0c42eb342c4f6e55b029f25ae8316581a001db87007905e4978ed5f29e8c168b41cf92cc20f99593acb77d736da22080e3cf842fbc60d8df017db98df996a6cf97cfff75e6420ce1e8fd9b5fce675d45b112592be7c79a820701515ee17264a462d01404c5c3195ce1c93aca4460f730cbbd8c301d9dc6c681f7c402771d2acd3bc0afd5d28b1e1ebb03ac5451f1cf163740f4168f09599703a5d13fd7c71212a034423aca1b9bb5d1113eb440453655a62585db3eaaa3193fb7e7efbbfbb7c7fae0db9e080156852bccddeb3ea65e99a39aa738abe89704ce17e2f753f992e23a1b276f3abdff1aafdb7ef7aa9ab17db80e2fb4b6272353d30172edcc550f73a1ea2f6172ec457d3aab93da7ae814bb46c7f6a57037a696485909b72485cd3a16c450c2a9b1f7773c195cb51dbb6a5d37c829c29f926050a6e451c653253634ce73c9a53633ff70bb4aee43c548e7bbbe55df08a54f0cb894a916798ccfea0fc12d47e01c0739410b307ae69a9ab3da6795ce4f1ea1f3ee554ac56b53d67792d822efd0dcfaedfe97a24ce59242d6725fcd611d83db51e2f5b07e0fed3f0ce21ac0d39edf040d08a6e9bce08bf49f5bd9bdd35bfd51362a9a07c815b3e22661b643b2301eb6dd95a3a5bc9c11efc5332354b973dc60d89a22cd319bbd95ddac4bbab82db3b702f3dd8012c79cdce49648a53e67dddd93e25312119f0d5694cc5bf4c112c921e5c6c6b1ea2be7dcede87a39877bd77604124326b795d110b8a9b234aeff7370901fb21eb9bbb5b00f0d78e90b2882890ddbbfa27eb721d3526dd3442dc0b223ded7f379e1a7296d1a2c0728a108191a598c95da9ed5243402c1783a0e7326637c085550d1fe3c8caef10c7eed9dcda8c5afa0b84f3484bc456b1b057faad9fb2e8a8e2549e76cda465979ca7bb6cbfc1cb768a0e2e120c7744141254922ad3909786a562229e8bc17e7846bea6fd8af2edce178585f78aed970a43af3819f251dca7518b76dfd36704449637a4910183352a0d5c306e934fbcddf0e282ec6cf4eae071d305825630b671e63be6ae1d3b67480591dbc60689dfad41ba3a7f7faba4a89da32fa58280b1d2a435e191e2595b34b385087bf9dcdbe7badb0731db9a4a30db3cf268d8ee78d4938d47c7ad5a4e82cfb8897becdb12a4960e1da0f103bfd4ccfc903a011c23abc49a962fca28be3b8ed129361e738e18878ff2424805feff5f0a8eb75b42b5759187e046c4f0ccb56de1c7c3cefd8dea8ae29979c548f492cb826917cc9c6d5f6e02ea64ed0713f7cbc59a8190fcee65b1deb4cc65197860dcc994b9cd00d5e973c4df454431a63169e6dfbdce8e0f09b824b41034a3cd165782a8d91514ab9d63308d581fabf436fb01324edcd10c005750ddc02b3cd5a08e0ad1cb0aab0807e7ed900291e810f069a43a5569d9bbbc081ce7826c27fb952ada1e48e902ab8399c4ecc89d14b5a841613428c16d82f0195c9c8156667b342b03be37d921c0fb4bf9eb5dd3f04e36465566f503ad27124c928c74e881dfd96d2910e7d02cc1cb549a804b4373ff91694c6dde3a9e28759eaf5a5c2b6106b1043a94b47f89bbb77cc665c9114199bb04bd8aa451cd10928ec6d1ebdf3a3e5f8f27dfb6d07e21af4cf11cc07d13e7fb4a378b4eb856c9b4afdd2eec0b99fabe1ec28dcad74d32f4de764d319bf750c51ad5aa7c8102b580a4a275ae11d51f2cd4d3efb844f51b42a14c3ba4d07a8c1c5eddbeb62c1a7e0e51d8530b8dc528184999b9a7bcac2c88389f450b749dc0e8250118e0488253c6f463c658638956920ff5df8c6e0867428a7374aff7a7509942cc46df5720512b7d5b58d6b5d0821c525ebd6e6ccfa7082349d094f9c9e20cd4ac4ff4761bd5575fa868a195ccd91ec08ebee9fe88da65c7698afa29487b25a78004b35f86e755fba5751109e596d9e4593e2d322c18c63a890119f33cdcf46d15783d9d05031fbb289185f4ae34b8b165aecf15216649219094d612c604109e1d191e3c757c355d501b4a482534486b1983f69ace2b79afc372de06bbf00d77edde3697f3b114da8bef188409e67ace0da715cca6bfc9856dbeefb3788003522e2d5599fc46a4eb9393f903ab44efd8023731039173b7b8bafb14b81e00e2544fd3f90f8c079175769f4f55f8446ed4f52fd74512b4acd86a79662a03103069c553926a53625180d05c9b9672b6f88d19d1aa6fba4d4bb23d14c0de626f0f38688da95a732e410278ea133c667c5e0453abc76e6d22bd8a2d153159c5b4125a38e740f329c5f0a2ed3edab5943c799bc2cd7202730bcf76edc4c44889ee5faebf646f35e5e8c243d1e086be3f4b2c133f454d71021e3d9da23c34cffe4b117f203848a1b30ea79f16c557422ece7960a102ed1aa3f4a486dc7f091a0f1427b2c88f2a3e02df81cd450d679e733af7706564c22f8099c0de698f2830d6fa37f8189e3b1a18fbcc7a23909a049304acc5bbbeb814d4702f90ecd9f0a93a9978f2c546d841b3d4680939f7ae5376e6ca0977191dde3cf2750d37e6d90689243f3ee65186cea996d902bfb76dfab6e27aae17e6021369d8d52a141458e40976bf7878c7129725bd4eb77ec899174349159df50f79e167a7c3612adbf8b6a1a0fd17b271d47dc79e78ac7000a2d43d0eb9e29d506bd27e0ab9d74cd92a2b5ee79b9c15f02e44bcb6f6e82ec3efe9a9130a1a4e44eac014c977e75619a1493c05ceea1e57fe8a3154c6903cf0eabad3cef983e12e83b4f9ec531d481b2b57cd8a66f5f6a7f209d5072fac99296ee01861974e35e57862c601c881075d609a417d94d9178ceb6ae27e157f6305fcb46c066410872e29a350e0d3cb4b887765c1893137e4ecb20ddfd1c6e83fe8507a153dc662f66c1ff1e5e254863751eeef06c4922a52d508be19213f7dbef174543a5ddb3bc72ae039e525a15b03972eee55a5554d63dd75a42b5c945f5fe13567f808f9544a01cd9c07e8eeccc7f91a3f1e6e07da315c3c99f03493be3f10215bfd5496b0751aa6fbefcd864be92cb478172b929ecf568f35ff86e04fff8f487e21c87f45b6fd2c0d00ce3dd845ef851dc78c3f4acc4b8811bd10b070db1f048fb9989a26b7b9aead459d43a65c253863190a7c1259b1e6d2412e0f2b4e6f0eb3c5e941beb9d16ee054b802dc60cb5ff64381eb993343ae6e491fedb495c4fe123aab051f5ca25097af71ff0d78f7dc37debcc77c9687cd73912980c8ee2efee74e42340a1fa49966fe3a39b223ee9aaff9fb2bc927f4b76c6b9ab536c5a17e0583a3bff7cf116f112230c046b052ea8520eb1066650f87f823573c7dddc03a05a4c09668076b4a5a5c93f0a8fa423e0482a77734a22a39898176beeb913b6ac238ebfb2f9c939038e7b941d15cda3729db80b819ad1478c4752532ffa0f9c86c5a3240704c08aa0348092f95cfd3bb34f94c0c51ae68ccc6d232868e9ac64d8ebd481dca87d30ddd36c48aa1c0a15afd247e4d618dab45f1248fc6cda6c9770cca52c155c71aa554c5ca4fe207eabb9dedf47eb9dc470dcd9227aea28aa4d406b64ce4bb8100373723a9a26e41fdcad4b66053b8b9afb016b361d8a540b7e4a095842a3776a79983c670d922a5a9d2030e8e01a12e39315774c8e359cfff4317561eff8f31472d0552b796a5de6caf7dccf2dda442679622ee08df8027aec0aba82d21ff1ab85051cf464eb09c95e2f8c70565550c12758a384285044db56cd95cc594e0700fee762d06a1ff22c03862774f83e69243c5ff7080e780ca856b8ddacf44c8701266357cc4570df640062c20b5ba0f33f828ddfc1008444e377492915d884b65dc98521f6e6fa40127aa4c7b01f44749bc41dcb130b55eb64dbadde2f06786f5fd5d620bc58f1c50cfb04d5cf3f49fbf26dbdd7a06f39bf1eaf9fcf126ddb1cbf99ad2db85a8248490bd6c245c8998d04fa3c03ab529545d8a4b27ced8116b2b7751c5324b1ceb8a1b5304a50d90fa2b0a862903a483793f946021a4b44a560661d6adca6cc0ef653848de8f350b83dfdcda76320cfc6a813f2b5817b8679815b98f0672ab1e37ca2f22e4fcb8d0433c328993f2c87d5e358111ae248f48d2d8a67700a63c99c1038e9220a938ccc429cdcdec08f86312d7fa548d8526b07acca8cb12969fca8ee3af5acb71c39276ebb22b96b011a9b41fef6ac900e7ab0e749b13bcb54258c381fcc09d7a5d5d9c90f1d65ac6c6686b52277ced6859f5edc19543c14c2a77b4ebc34f2463faa91d46468f69c6b39847ec9340782c318276db7ecc5256e659e219538901ae0ca912e8d7e6b6310b0307591108f2bd05fcf22562bf9dc9f584b59598b38cafebd62fb1840d4047a7d0b9603c986d34af11cab5228cc18ef9647656832938ff07f39802f8cc3503f36f2c33e241f38c7f6c0c832c7d03a9d79ca1cf37b4726c46c90355cba7d47d98a062203ec2c122bbdfe40c15af4e632df6639dce81afb1119ec2d164d3173d154b0b1f318a1a90d13b58a5657d6bb2782b0688e0c5034dcbb35395e6376c9813121ba03ef0704852012f79e71fe5f1763966ecf2974e2fad572c84de557eed717f1da43e28310a3b4e5db81accdd1869f1d5240a6c08052f9f84a84fee6189788733e69c96e2364799f04fd4d7611e885c1a9a4aeed1b83a217838524bd6396eb3363f58d3124bb16409e470467769d1ec5e0c3346943e717c4423df27b6668ed1f0d924f819fc810a8d934b3384354293384fc4ccfe1d948084361806191efcc13e47e6f42fe1513b4fc2ef883a7e13f6097104f207c4a2578804ba953eaf3c18c0ebac3e86e06587241a6c7a9aff919923f05c3c36af2c2d1bf514add2878a727e96c0a1669aa3a0abb24f049152398a575ee4d84829724ec210bac98a4ad170f80477ca4a1a47d73eea5b9fc4a51d98475a324135489750a71dfe7add627c518103fa02112ea7bd8d055f9c6e34d6bdc38f70b0e42869c212e955ac7d2a2db146b8c04549c630f3dc68f23680bc26950399d75e2dd732d60110ae1cff176131ecea9ebe836a054230da9dc91a5373e278ca87809c1134603f59118810ffff42617b0e1fc243385ae95c0011e69cda3c84fffeafed0e46739d1d7e9548d73e8a0de7373ecdf8fd9481560e8e5da6a778d4d221ce9db59d43dec3a9d8bfcde92449fff13cedeed018be51b9afff91aaa4b982dbbf8756ae90e52681f2cccbf9480a5c43c909a6b72c13624f9a9f094dcffd816f479dc1113d9721c5ca11b58f2a264f5d91fda24976b325b99067b027572e1f6ee5e9845456263ab3a408496a5771db75f10bbc5ee09713d65a99390e0f6c71b404fb2d4654c108384e3b0526f28c37fd7135d9bbe99ae39b92d543c0ed638d0d558a892ed422637d3a1313d7cc5c97e037fd3279e44a445ac454a9300efb6e6ec6bf8b3b965393d1d9946f5291f7215dfd03e9bf5547f10c9e5188350f0e209bcfcd3f418755c7060024da4e01ca04dab3222c02a68850d61f5659b1f196710b8f6d0ae3d95736f73e67f8b1c2cfef1b1c5a24ac97b36ca544afdf82b6e038147fb546c7545675b9f41b483d15f527ab76f72f89c4ecc2c3ef089b7f6b3e0dd28742de8449b785a0672cc013717b5614cabced7e5ac53127c658ed58197a32b77e0962644888825d17bef65d338b90705c30ae97e6f1c55abe7f0df7c71107b6ae1d62f9f2b0f8d0b1d6512305a05feaa20a5219662fb460dda58518c539631e5dec55ea3f5121f1c8741a5fc382df133e518ee634a163b54abd41419c5e42a5d01d6f1342bb7bebf6938dff147fe4bde683cab9eeeb2dc63f043cf5b12ff8fb39a5c8092dbb25ef213d7d3442dfbf30c805a2cb35eb123919414ae3e3ad4045960a5f5311bd8afd063babf67d2eec2401f5bdf6ed62b70749a92fad54b62865c7084cd40c649d0af7be2d51a1f2c8140e8ad7db7a075cc5bfb0dfb3b494f88472405c8cf9cccb054ad0d90ffabfef01901395999524ab5296afd6f08ff6b5e3481734b027afa0cc1aea68ddea6b292b05d92df471838d226bcbac02143f573369ae97a067c1defda3a803fbdd05d1ff7c6896aa65c226bffe7cd0a6623d88e3737007c420430bd1c0769d6dcb21cfabf36541d2b030ba4f723c86547870edf8e7dd39626a7eae95a0d07324ac68cc6af46be904487af887f4ef13cc7b1e963b67bd5a04a60be13347ef8b8f2c17cee745a381e76a3c2cdf0e6d682cd7cd68b81b4033c396e8d2245e8b9516a3e9cbf675e8c6486817ec39578daf8077b056d7780a0a626056c446d64c19e5e1b8be3d5c485a9c234faf0eb85357c8592d015bc7d354edb3ab9b6d7a97eb4ce9e8cdad1767a75bb9a8fb8ccf8c2999db012098c85ccd5c3fb6c95814e5f1c54ca1c10ed3c93eec0383a747af09ca2d6e8a0af76457aee59383e8fcdbc695cadb4eca96bff305bf0220b788c1845ccfa5ec4252da722197010d18af333ac8b2f5fc1439c8437b1018b5bb59a0dcb359847661f43b850e657dbdaf89d79de0e59e9c73b025d3439dd6b53e4d4ce4e386e26cf16befcc42b8dabf5a987eb442852b35bb43071e301550d0cdb4090cad77f1921bf51946a652bd5627ff2bc9bd6391165f709808f29db502ee585d913138f85804d3e6187719ca2ad5ed36a98517f0885cc25525f0b541d26f9f1c322ce9eeb3940288964916251e995e5c1583fdd5b1ada68bf4421a30de9a2e1f3b8b12b00e4e2eb4309caa0c04c24004fbdac54686cd234d22faaa0af0edf4152c8b6e614c072a0f7deed3a53171e4adc53997b54b2de3ad203a5365c16bc87c25f534074d85276450870f89c82900ef1aab47ba0290373ba9ac570de2e3e9d0c54c632ddf9ca4a0392708e37bac926e5d8bda83bb1c7fcde2612c92b277b5a279cefa46290cb215732f41931fb52c35c3ff2e7a1bdf7de318cf52f05fc7a425b39e69cf99a92282a55a96c9707620fd81193f7194179b47770dec17de2932badbb6a812eafe91a2b4a6044baa0decabf1ca77d4a8742c307ce9435cdebd19fcf2e0ef7fb6af141215b6830c65f36316f86725c6f45428b6edca90e8d5e063f8e706ae6bb4faa551a2e47333894c235c39ed39ef63eac117bc5177eb752354a31079e07719cce6e52e066e03c3067977f3dcac60f34ff51998a9336a6482cac8c57afcbb3c1c844c70a8651e0b9b0f532989be6f2e5124de83700d2c7aebbecf3f7a668cfc0fbdad7c758f00da668eb93ffd640e6c6c4eb48f5932a26b79bb0e4a06388776b91dc2b3539db254297f74a1493e498cd7f74981ec615f05b2fae7c005cf5abc05540adb50e5ae8e37372e06248b6467461166c222bb07214f3a5c7b315ad994ae7f3120e689b26f37795891bffbfde62b04bab6d362ca5990a230977d70a8920811969fb0d1cb9655f78391935fa4b44d355806d1c370cf34d51a75fd78cd58ef8679f44c97c972544846435d8afa6eb741a9a9ce5c2d8a0cdbc2891e3a70bc9e7bd19b1d0a5e4b5d52b4bb3d85c4a6dc0905524aedc8fd781152519f0f48ec67aa14cba17aef07f10ac5d5a380508fa41c024930136b6bf802bf7abb359d1d6f2e219b2427680598cb40e6658d9ff3b3d80cbbbb8538574805e2fe3f48fac2c68d5b52e4da4b9e839bf95494e4454a0903d4d16d63a6eaae8346261e2a8aaf96e1b09acae7af7c3cbb240e715a945a161141549a7ee835d28dbf23ff115888de7999f0280a0935ebbccbdc410611cb0333d0c674a00aed0270d566ae08745ed61b102d20d1655570f776564a7319aa10530b1e5b9f35fb6935c6ec2a023329a6e6ff249cdb801d3f072454664c61bd2eb80989ec85e55238697d287cdd67013bbc993a081baf2207fd9ac8f859295db7d3e04b5f47c687e584541f1dfa40f4c16518cbd20bfa7ca3fbbf94776d053eaeb803def57d0f1ec03a912103a44d7b4288ee9e732811f579fae8778128580d3a0b03dd5ad37b371fd6cb506f1d84e82161ed31dab08ea2ff0b9ecf2f2b38607ba7b55a4882058bfe104811f623d1c9936955da9711144731843fa262147660d54fa3d605f0a210da7668576d9609eff0114b22e485254a741387ff564f9aacb4ffe8c16dbdc075375dd798ad9dd41ce3175d643735aa4d5945e4499c0b0e70102f3b41d662c82754f74239a734d2b84c3b753ce9b6739351546c732db37c3cae16cb5e6f37e3ac2edf246143c9019a7921f50d59e8e90f66be8a27d909ccf0b866d072e2bebb499ec72b48809e28c8065e5edc90c6876295e326486ec05a642dc229bf2f854814bbd74f960d7e513e75ef3ed9c1977129473bc9414831f0334d78bb8615785ceac931fb5404145450cca33b3322ae7b1024f9de9fcc32bbc3dd0b0abf3fb37acbca069f878d8daa9f2365cc89aac916cb7e5dea21d6af0277f79644cbaf3d85ffcc930e85600feee6555c07f7de90590684309a0685c00d3b034d2a38bb12149a40e5460860ef7ea2fdf2a328c5a3cee8bfa07a1edbe176b3c5f418f987d9df379c50213a1ea06cbc39c55f0eca711d825b1f8986a4e81cba99fc0297bb33bc1f3f84ef5fda7532615dca90166c252a3860f44ceeb9d50ca2cec2041cb774f8663da927d65504a445b25c40a9d237f510aac7264f6f56f5edb75b6f80b528ced837d93de9520aec48023f146860ad0489ad6ed9de1b85c26f9d47b73232a768cb2115d23b6f9d4d1d113d5626a1460c3166e953a5c5dae2b228993ca4dcf05a8e5e0dff7b1f1aad7da4da7973e19078923b23b09021c2fc2e47c14dff6bd629ca387785f94bc968967c101752f0ec7e9f75094481b0bc5d921c4923c8271f2ec257bb01e33e003c4542e88b2375f64f6afc8778855ff3778d984f44c1f075735a020d04a3381b1795d71024916bbc50f03ec0a161b88a2775432d508f93f79e4c3b3b76348b9f4490903c5ee07d1b684546f7a4e9f44dd8ff5732c59c1c083d612fbb77f9dc92a1ef5ab7a9cf76705310e5bbf332c79bda48e208e706dcd1f99d9d0e61b63cc0d2bdcd355eedfa1e39fcae3b72e335e5e9516f8ecc26809544a79a5cf07f9a04239fb361588a50cd768aa905a13174faec7d01f98f557443066be77c95250634e1111c39512e1f987d12486216dee9bf478d0c1f67105033307a9437525d50f4d39c4c129400da9cd4cfc435885d5d71c9f60f5e34a09f9b88d47af745b9db512458cb98d7e60d5cb769760ae015ee7c48fd80956788a7a93d06f84fbb00698fb213d5d9ef2d67789abe7ee9f84716488bfc556b3b3cea3eb9415e4e8cb237f2081b3f2e2dc945a2579c039d7c9df3ed39d0b5bfd8441b6906fc8c5b7cc2cb36b6a8d132ba6a1e8f0de00a7f80e1224aad3d79215784e14dd8cc4dc9629e999fcb409f9ee3a2168a5b5d1deb8fc3f15c1aeebd86cf457d791c2919792e038fb444b13c14085fd2c4724961b1b5df6216ccce7a7de1c1b11a9f555600ddd5c8172fec402ade684b5b1c2f32a23a36366a9bd273bdfadaee141a42c0cbc6788157854ab11e1a5ac018c79ab9e0f9305d99cf762a388436b35917f7ab28e1f38c3ad5d2933ddd724aa2ed079b025b74c055a87c614fd0363e38551ed528da159340fcbb3543fd846b6c2ae8cf85be762751a6f83d437dfcc2bc106b77ff41f38f1ee6a811d97e7c1c8b138d7c1b5062010f2c8e64e42dd8c722bfbdb0595c68288655c765f5043d5b85d88aff1f567aea08bac51db273feea4667dba7bc7f524b093dac6d653461db272b280a7b7eac7ec5c94b5a0f0caa1f1e6ce2eed0092bd5ba3e8ae1ac1e5a7a6710f61b71c454434a26855c36b05111e640ccc42db4c89a3833b0165cffa94b84cf565fb632d230d18333bce7a5fc2a05bcbaffa90b9994dd0fea2c660186cf26a456b67af53a969e0c3626b5b0220ae4900e32893d169716fd2e20934d6b17d66b2136f5d1be3e27de753e0b85a418b8acf0803d74e9eb49bc9188e0aa7e540c677329c59628d15839b5424e95f2ecebf3c7f8c3c97594c13df390ddea154e2b94de09d7f9f18503c8e1b09643e96cd765b619769545a0b1c01e11de39ca04b23f83f90e00b6f4184a3afb61a87af560640b3e48a34c96ccd0136a7d5d32f5e23cf9d3dbc3dbe224070adfaa07ed0fced95329d1d75cdb9f329de63b48bb02dea782da504e5e801fa204cd44358400733951182a59b7465af7ea3448a20ceb02fbc60181b48b5d7291171c6c801e6536cd4cd6bd5eb71515a9460eff6713623005a97263a3d4dd15a7f273f486c09e84b740f4c18433ed86ec8559232803ccb0f379bdb6f5fc65fbf7bc8ec59f0bbc549f0d7fa010905ef25805f83f8155271a0904c15513940bc9627fd08d3dede0f70815988a086fc984e9195aeb9c677f509fee2eb869802bf16268df0975a5667b83709aba145dcffab656ad4dd427854c6ae790b4292b1669adb45fc76393657b4c37fc16049287c933542b0eb92b9fc34291c21fdb1581db3264e60a754efba4f023fb6dcb80fea2b3fe6b8d3b9b22a974d590428f76d66a8ff0cc80d776e5e80d1270fd29a6219bc906d5e787046ffe1bb0791646c06643cd3989cdbe70367eeb98974745e9c634098d86e36732d08038138f06c3afbf40753c26d633acb34125f23511158890a04a7846f669a326971aca49bc16b429e753ca00fb1d67eb4b583097d88ca5e116cac9cff444d3182a10e701c7aa6fffccadd79a60ef5363ad7e9b532be2cc1fdfbc812f5c27c6728ee2b95d410e1b279ed60ec5b0e02d55f15ac19fa23d2dec3b75c46d42e37d392edea48455e580546e1b40fe77887949da8fb60477a0204372a9ed9fea6ea7eaf24cfec80b620f8e91276a2502285bbd77325e10b41ba93d2bd56751fb6aefae5635bece4f4e293c92dfadfc5dda3716643a00fe6f2acf7ccdde20a0796ed71abbf167e4612d00517549c6b3c8d7d5ecfbb4693de722df885bab5b8e865406625b0dad1c01d0b5671374f1c9baf7f9ca0d83ccc40daa5d4fbe6d82f976ce82ba0f5e94713a617ae7f31f4313951c98884469064c93ffdc8b838a94a9145a9a5e601a392574c46a8db478676e373e4dd6057b0a6a851234eb4272fa54c415209a199b9c3fdcd01a27eea0b104ef0f0f22a5367afee328a2d681d2560b17b62290e081bca8fed92c11166c5488992d9b3150e32101f17f0f97d9ab4f2d84cc6025ea3a6865197613153b061e899d05b7b6f7c88d7ba38055f96c5005634db45193d220d54e2a40afc4311dacc3d1ed8b224d12eede637b8711e4e07433f1521c491218c702c7d533f41e57784ae0dd3c0a05ed12082ccc5156258c9efa5be0eed525fd8acf3dadbec803e8979d5cddf07af47852d0c46184d4ac7454fe8802a811825b2be838ac35c5a0fca1f73ba965efeffb19660022f55cc67443d092666af91e4dd21a070b55128eb264c3df403f4ba4c884eec5da9164f69fd6609509b95dd790d78d02aaded1e6153374f390fa13b9c0fb99405d1fc04ee1b119589b2b028b27714609497499284d348d75e4dc6a0cd4f118e0993b55b5c55410618b87fe98afa29d45dc6d846f8ae2eb7601b01ed490fd8ebba10fc368ee6a6e80850e43834221f584690c69e935835cd421665bdd520c73d691ffbe68deb7382724f68ea84663e64d75832c14a0db9f19d853881bad3ce748e08291ca6f2869ebc614cd4aa1ef5cdec574462ab7070e20278a5ce6bdc9ebb3017d6d05b6a9ea324170f95ef51351e61b33036575af16132cd7cdbcf689b4ebb7c547e22b393a490820975a86f65d623a8558a73cff5d85a2990b74a8c850b4aa2d8db5d93c5d67b154fdfcd32fbf3556d8ac04e4ec5fe76bb3cd7a1cdd1f7dde9e5d3fc3fa59b225393c8277e056868c88089dc5deb1284206ef845032cdda73971585db56b14dd78c5538b17ca59f5ee2965febefe7da93d877fda204e3b6aae97fe2fdf3826c08fcc775956e7dcb5d0f15c87b9077f0fb6bc5712974056388f4cfca98547417e1718b8442f155e96b95cae933afdd4c0e6b4758f4a33295a6e6f6a22a0ae24549f7f730e3293e853a63983c07b2343af2021bce0fa0f8a8f1c54937b9676aeb31015b0f4a258bbb87eb10016b6eff8234db5e2e71dab279067a183b4a0ee4bb9b8874aca481b083c49f3f5c41cc6feb5d609b8e593c4914829c23f96de258327f8c29faa67a62cd071dcfd051b7c20bf8117c14c942fffdc85c77dcf5766b2a517fb9ea85c4ddbfec6101a15cc6ce3ef6d4b66d466945b7e89c5bafdb4deeec85d03cb46cd4cd6fc1a0e2255515e95b4435e94e6af0c4026df164acbe61cfdfa04af025a0e447aeadfa36c0c0f0223b26a72ff45cc2718a762cd94fb64f3f69622fc2bd47a43fda90662649a20dc8d5e278f9864dc6f3772803777e3303352d66e9bda8560861cfa143ceb3ad4bacafcc87dce1960463bf88913917fbcfa0d0bb84ba6c791a1daf765b0de549cda56bc06d08de5a02ca8b28813bb52f8e650e0eae055ef6d2626f715eb9d8479b657fac4e424d24c84307ecff17b2324492e34bed0f342c27694cbb54344026021c180a40e0967b627efd6ecaa223b2a36f539af6db9eb41a7ca140ad2d7c561ed8344b56dc1941efce26ed1fb91b06dfc196259e5da9492a3e51a22608033a910db9853c412edb1f4fa11136a59a3a80e9e30813e5296209138345347e8a5e2b064752d682ae74cf42309299ad62039c74b66288faf77f725e7ee9bc459b3f34ce6214614ce6209cfb5ff6b7ba1f153704d300c0856f2cb27359b87f9b2388d07918","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
