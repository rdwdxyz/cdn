<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2ef5c1561529a6e9269338c3b0c5711da848bc03ae63b4807d726e4cd07e7d4a5c060ddab38203685a84573250c56b5b2c43055a554a46a235e9dda8206c84fef92a60674dc67d0f2c431b569a8b1ea6a99f7bc4436f98a1602f286a39a9a21ad446e17d15b894d1ef19face7f73b6ba60d93a39236b8150729dea31e23b111ab04fab1b06b7d4a0f327292f91e896adf4ded76cef93e774e0d3eb0f712e879c25777dbe4059d007ea04d5eb6ae4e8bc07f78cfa4349007d8987d509e80a3af269921c0641bde380db9f5a44e06b3887dfc74eaff173642b18ff073e63d9e0aa9f9f695ef34336f26b12545f1f0f820ae91b57ccd311c016bb7031239a9a2dbcceb20b3c02139aa14ffe74b90565b16bdd24630ff0cc5f53fb1037855959d7b19462a5d76784d9edafa9428706ed957859265b1d555721e215fee6d3ebc9841ea5b5b73eda695ea90017f8faeacb93fb342311084bd92c76ff9fd526766d634ce96be3aaae1c0b66486182a40496a00aa12a0b2d43d9eaa8522ef45222279ff97687d97a439afb1a9e527425b83668c8e8eb8e8bc3f77fb888b803533e24a3345bea36ee880b05632970cfd928e0a2517fbb97897e80f350071785d6f8498fe2f4cc6899487ec2a27d0cbd4be9f72a090402104e2d3a2873bac37ecdc700f50faaaa0447de33baf5fc6950242e255438ba5138dfa51cf7cc99635ab65fee04f11668da1abc01a1f54330e8511b49f43269442f7d92b22c14da700b3aa2e0af41e54cd67c05c749e0c6fb27f6e95157dc0ba544e132449403e0ed753da8c5e90ce1d857c82c40f1705871d3df417a0fc7c9a3298ce9cc0912d94fca97ef1af4b0f72de2b9b9b6994ebbcd4ab48ffec8dc6dd7da5f819519021c11694f597362b72331873a85c52b6447097b680fe03d3e0913326e35ee270383afae2faf7e622eeb12d686aa76b4b9924b5e0d3b5e72563ac1a5eb723d9a5b299f970f7e17e72bfbe3cbb62f3be7129157ccc699aa28267ff545876e934f744fd54fd27d63ab5dd5ea0ad37935090426b66a046c265df16e4ffb89bb4796f2bd4f50ae5c1424afbd51d0ab3759160f906242e43509eb22d07f33c6ba8248ad81082d756208d863cecb9cb032c8068075659e3cc58656583e3e60b458cbcd94be563cef8781bdedd9ec24cb70ba229a07efda9406f00b5db2a4471f1bebddb10ed06404a14340836090b175850ab3642f2a1db7c6cd3048dc75e38bf268ef802a5388d5d99757779a4e0a7bc8cf2e076ca54e8f5279ae1d17246b342b2daa595cb757c7de7828e16964e5d9028651602aa5655750e61068d49ba767f39e5b10452f368a3ce4e3eb306a96f3d9251abbd657d4bbbfa9ae4703500842a57fec5db2d02be3d7211b04cd1ffb29327c3ca3c68c04fd5d3ceb6682ff2b6aecb13d5bc6c61d06e1cf6aa8852f484c62614d8ed3a52516bf85edc6d1a4440562de002a05e321c8a7c87c64cefa82b1d98d69e0c0acf2a3382fb0f4783aa7ac8400b1f45bf9d2b974f130bc9971ce703647f8da00405bfa61aebf161a83a78a9b1251355620ae33028504c2cb78939b9c72324a2860dcd4eab3aa1b90eae59fb3a4213041df65c8e65047513a4ed360e07eaba853aab8a6fd4c66af310c2ff84227e5c517f8c9b8f02c41a5e2de549f724f8df21cee20f1ef9589b4fd6bc70442f30e1ff8881178398419c68fc3165909ba4d9555c2e7eb2c245302e9036a8fea833539b9f9dba6f6cdba41c457f0022799cb428c86bbab5a1db60d73f5eb1e5928a1b149fede0b3d94dd934b6e48131836f6464cab0bd24af2aab1f1ebbb894630a5338dacd2a6f65404df081067c59e7ff02c29ae5142faa4680c2e6fb19643ec16844f05952175a17908ab548f865645a777145e07f39dc3a4dc02207a12ccecc572ad5e052639abda198fbf1246ebd99301bdfde1783698c473d5cd6b9a67c5a189a6643e9ffc0b104830ac6c66731b84c4223d64880329cba814fb9a561b884c3b4eba1872ed72d46c19060fc4be439b331c7547671c7172d8668550698d790a72e22c259c94f9487483c4098f79aeb75fe1966f954b2258ab3337fce4b7ef8fe596309bb73187a89607c8909daea15f9b85ea631c7f4c71e8b613c050abb6040624c86cb469c963b40e3394a6aef3a36530ab4a58b830a01e79c102906b9f6014ea21e0504de076b40bc0e4f558e9f5edbe5e1c6f631a20566b1a9147f2dbb3e45d28e0f4bcd7f7d95705738a3f80d5090ca06d47696e17ec4489f8b6fd8b586d9a60ce4f23d8be5a826594f98f4eb019385af36976809d043dc0d4fd30a0ba5cc582a60dfc9de9b21c265703e9e85f3c89c9103de6f832e9e426b4a70a9185f39772945a05d37d85600cc3d21346892c5b7369cf7314601dbc1c0c91ef4f7c06a8e3bfadcff26b50649bbd93bcd5272027a0975c9320babb85140e5711e56fbd64bca70e3e4cc65821331222ab6b462eee983e66fefff13b1aeb8f5835a40a1f3820c39d6a3f1536cc4670563d1393f3408cae9ee67b7102dfb73964767a4b9001902735f669421842499fb7fc9fdd2bf90abed79fe72a050337c03a63395be904faee2b4adbbd63301b813cc60e790ef20d047e00d8c59688b31beae9aeed0fc3059a1cf2e400a732731f210f7fc23339ef4618a3ab3eb1e5b5fad90ee4233f54481af672aa5bb469f1260914682602c3ecb0db7f8d0b4925d987ccd34fb6a29f8a612c1d764bf87ec53fcc6dd6dad05d7faa4c1006113b2bfc4066a9d8a41d3f39b66d537f51a08d4529390d976328edd464a80c99a8b5014da77ae27389d5c7374f861ffc9dc39d1adb84fc5f2832bbadf8cf5c4e3f7ad772b8dd6201a64c3d3973fff28801dba3334e9a44239c0e8b910d454b8937c9b9384dcbe45b80206e5427f01b94210b3ead4f2bed3716f4e839d7b8889f0ad1ef8eccdd23e0d1e819f528814f6adfabf734a89f2da1e5b1f7620f4f5bf2ebc4591bc7e5aa0ce9e0545e86633ad1c8d76534d36e1a3d537e2a791b291c2d462386d278f6d8cbb0bfce078c7b8f4983e230feff7ad15cc9fb0c3382b48ad94f0d57d96f16f9a4ed44050a1fb3d1c1820b1ca1357b42281f181c7d52806cd0874f71c98f620239b80782d317d9f23795adb4ec36663e6968bc82eb10adb3154f61b45c380561426a61d12e01204e5caf5dd25b021e1a2db3ee4619d50d4549292f4f7d82ae160453ff6a164b4bf2b6ba11d25e6bdcac8b60aef419480ecd45de1104e963f90e0b5ec45eab0c474136560c13ddbe680c1ad3626db4e29f645d8fb17597f1a418c016ac60cfa66c9a427e6871b7e66e84d55dfadb2725e6ed58e79a7db9f42d7b44e04c50ad9f054e8b35dae8bcc1f0e9113d8ac1dd699b64e5f6154cdca55edc5eb8cd5597136cc8d52391500f69b78b4eb2a7fa71cd550a2d3ff2abf37d48279d9fefc3f19ac36aca616124ac3e96825a14d9b06381e5ed6623722905d5f2c228e236874d026db9777154b3acd97a14b97f32ca5d75ec97f29926b5851706fbb79dca82a10a006a0a966f5e0a38bae6a4ec7f432407dc308280fb8654046f1081191dd04350ffb50a59f50f86a8d844a3ea1eeeb5ec264cf57c2ac18d4c87e3aefc3dfe63250e93a7a937aac2a1941bd8ed70eb1835b8f8fab30e6a35bffa2fa9825906eeb34b1422cea128719361677b3f5b001dceadd8af70270d84575e252a097b8cd13f75647ed9db62698530d527386b8aa5219ab30723d8b4edbf83d3e2b37d034024df2bf0f98ac99c5fc81ee946be300759d1db82ee8037438ee9c8495aa3f53a26b326b369d689aba5a9c5d5701b3151c177a009737eef6628a594b7f29e79b07116e0dd2f5d3206ff45224e42362747a74ce0989dc273d79ec4cb6af1d2e542f953fac7118e4c94066c3b0a7fe502614027a78fde37a8f9a06500affa3a0b2dedeb930f8e3efbe79dc192b0e7248a050c40fab14d03a5830a68f77bf60e20c5f99937cc06031fe924880634203d6f7cdb58da107fca94b63d9d3640af6d4a3d83f227a99c00431dc9d5196ebfdd6bb89a1cfd415c54233479eb0a05f4f6bc76bc8dad8547a9505c9313cecbf6df2d53a57fb07434a1a5b745a547938e884fff2e2ab81a0d75bc4dc6c4c8f33eeed792e1950404aba878cccce33a3da0dd787b1fb72874cd1e088943c3331520e3391ae64ed9cf064e60766ae45fcff9441cbb3810bbf3d7efd353e69a9d8f4bfed7580b1b400d0c618868fc742cd9ef09d40fd8e40ffd79dfdd56201dd68b78f942816d080847dbb3cd51e773e1a8d28751036b09c0a548fdb7893447aef87014dd178c8c96607e30a86608d8871cda4af24dfa948626f5fb7fcf4b7be8f9f5689ca263bf3a77a8dc24027b1ac9779c92739d57aa559447ccb6d3465a315afb5e54acc7843d46d2d9167ffd8f2ec903ace0044d78fc1eccde9728053ced61b30e57318e1a677409fa40d1de30c3fe9adedf9ae8b56eeee02aa00a787905c483490e5c9dc5ae4fde397056d4d697365084c0169154e3c414e190350a91853ee1e63e3503feb5420b28d64b48fe1ea8290c1703026f6c8ec2e2bdf75a8fac418935695acfe749ef5256dac583ccfee51740422f00d77b8055744a2b69ab950148c165178bde3c21e3e4c67c1a17f16b5aec79c656a65d69a0aa7fa759cb944ce99b3e764adc20fc030b037fff5d657d6bdaaa541580abf21ffd9e492d8f647fcbd67c7120826ad0493aef3f0e82b56c7ea00937c94db247cec566ed13820c029c9494e3a87c19d7ddaac3db9bfa1dab14d2663c54e9cbc0c3561fe8cc7f22ba0c27e461124db2b932ba08a72e324c1b95998031832bb85f45df8ebafb05e4fe1286ff1291295fb5f5ce226873ed217dfc530fc34e72b08df833ccb008e2c8e9821e9fd0595e6418eca22601478492bbeb852113f4e5fcb3ac75a4abd7c5b465996c50995f5bbbf39bd88672caa9a8400926d228d139394ada979a2e53d1eafd753b619737bf800bec013892f0a85aad21c529014540086f31215626c7893c5ebb9552965c03177b1666c733ec3eb72117c5bf057a7ada26b9b29c119e6cadf17451359743e7cb142ec8fd1576284a352d9022c599843272d55afd098b8bdd5c7a7e7bdb3b07d6e99dd2fe3188afd2365b95476e6d0f2638cb097fa80cb7c69433b84780e3d46aed0cd43f50f9f052d74ccd9bb4c0eb96d210823b5cf3f0575c9e2990a05a58694ea74ac7f521874b7f1850099be4097ca8a178af091a9ce6d737dae33588615d1bbfc7078ac35309149b9a6392846a81c30e4e395dfcd989bd1598c081138e07f1572e784a9563f57e60c68b168e3132bec469e3b4aba2f7226894220b3042e9f44d8c96dc351f7acc4c6a8fc1808c731f21a432c73ec4cf47ad76f66bcdbc1f82a65624b326a1aeb6e293d861b92d1e447eefdc55dbd3577b64366aaf4aac5270773b75f53c0ccbab7a67817ae3e7f5e8ac4335f25531e40c582918e91c3fdae6554ad67edd86b255ea9d3f882ceef69b330e3c01a3d2f9bb981017ad8b246477cf7aabd140b39cee3fbedf5d53c0b85a1b38946d5469cc52d9213a6c10de1c7c5bc5ddefef67a104563751b042a4a993cd4476a304c111e74a0c981d69731213e2b2186953cbb6b3ec75531d4c37634daa3c6d0dbfeae91b1af89d694080d5149fc42d2fdfb3507e63cb139a36c61fa1f967ee62adb3255098cff82dee02a8567ea0fc2ca2bdbd9435b705e71912eef7e8d206cb63cd16411d188e399e2ffe887585bea892e46cad1af896e8c5677e22b8759ff2d38c33fc2eb3bdfce40f1d8e90e7275d72a7cd6330e66ef223b1d70810b3168258bf2ac16dde73cb3a6195933ef4b781bb01ae64f49d6b2f3a7220410404a40da959b6362591ac107b590c4ffe284bca4649f5b069f8857bd206ce9bc3bf70c70cd7af73553905d31e450afb92746850395e5ab3770bc67a30b9d4a91d4fc84ddc9245f71917d06d1f044474a4efab48683ebd7d3f2b8ae5caa9444f0b902c14a0d6691250a00cc2505d88c255f44a644f52fb9a3a0b2bb4d1009467cf871291ec7eddcca58ef5267884a0471a00f12cdcaadfb612ef8ae9c81b71a06a3ad8fdeda28d4e27df6861789d6795fee198f317ab9fb321561bfa91f27eb898c1b27289f940198d0227ed5cda0dbab2fc49e9f6444e74856f2e6f54829728d299f1007fa52fdaa16a85eadf1cf3284f782997d6ed741b5d8b3e0ddb58801c0409142b53a754dd3ca89e92e9af2a27878997756674c46223f7b1de24b8fb58fe6bb1616d49b21d239c61251cb2269394429186890b62fc6104b9124cc8254cad1415af041b2a027026bffdfcaddad782b6fa1937213084a2748ad0dbbd8fdee667ce0b64513bc614ff759deadade7751fbd10fcaa2e2f8da620b9433d252572a237b957ccb8a90913c89199765624a2100c1792e35598499df7073cb75437a2a5a6866db57674dbc5d67f149bcbf0f485b6b58c5f19033b2783c989969ff366026e24f5ef94bdb17dd0eb4ac28140d9f1af17d440c88c9384c3784c82bddec2401d7196a77dec8b82515623083f2286b1fb661c2a5549707323227bdfa7d71883e70ccd6f1cd340ce2c8e66bb11457b3da949032f4d5b18b924098af93ebb98ddb609365f9e5fa7a4afbc575c6be3421b7733df81fe69ec3fcc2c4a79f6e23593f79a5262348ba2e7486705dcdea1114bce48d098c28d0742a62b28dd23f904abd378dca9ae9758eae4404a9399d7c1cebcd03c356f38d9a1c31d391072f5b33332351bdad6794bff6b85f98bbae154f9b91ce9edaf86b7b7bf302923c764304a9a9f044a2081f0065005ea1e0b0362b99b7ad8ee1bfe8fb85ac2a3ed1dfa3c61c45c3d215bf2a424bc5835d6b97905c9ffce3960964a9876086a1186fc7bc78e6ca4c6bcb897f3ec3bd3cefda5bae0030eb32cc3f75fc14b48bc9ef728f6f0e52a4a1ad990e1c632d3671a4c9e0663cb5daeb6d8310079aa31f541fcf95a54ce84180d41e0a30b523f309a30d89acace099a52c91168ff968ac0e81067f7d8158cfcf19697edd9cdc16051f6df2cd803c5aae579b1e0e07f610a0c31f5c6d793c70f3ce7e2bc26829b96863022922f2ecca6563ea0319b6a90434e375a75351b294c13884a9a5b87d61c23822c515b0dbcefb68df65e4961d196ba95316ca058213a39ca60fedd5f683cbb0d6f9d1633c542404694290ad6df525ee7612569576832049d47d283ef44af70c88aea0f3545df6aeec9454f9d1d3d63a85ceb567fd83626a0e1ba362c1931ecadd147558fb91d42fc5a2c01d430d7a415a237a7567a862840318665fcf792838abfe18d4132fb0385e909a02f3559615a3def32c71e085c5c533e010dffa321ee9d0e91330063173dc68650bc9b05c97d4f5bbc408a32f2426d554b293007c4b4581ea20521b993b6685345d3fd5194b5c1c573a7985ad9e17d9b7ab1a2ed4a2f48ca2d6dfed5fd056079f3c05037f0682eddb1e85217857bda94e63d546e8137c6d3f5b0bbd316a5842a44cf6c7f1d7c836cbf9462d70d196074a8f78d91ff8793a823f7ea5bc467fbea605279ae0de891e829dd249fc1d8caf4f1d21c6d5303ad90b05d8ef88e3450802c1775d7b02024c113fd727b77bea69b9864efe1514372af11a3ae3cdd42508ff3c19fd6b166ad5b298752e1e8c3db39d6f243781e2e4d4203baecc5a3a7c2c897b322504aaf723d51f515ac89ce14b817dd47df6d70124106725f25d5b5f9b006383d3c73fbd91f63e7a204a4206709949cd6a56520400e104c4844188afbf6b7cb7b184f7ece1af755feba7436b9906bd308da9558eea0e20c68ff9b64f81fb6c8a513c32cea9eefd8c703a9f8a8316096204058da50465818743f90e061a807289058f36c7e8a3b6ee2b2c2fa73aad1bcfb7571f826a36a8092c26c9d6b13ce5eed2fa0390d5ba7a523776b32e10e6b8ea6c9358ff9b3e79c8028d905c0367f7a711afcac618f1d9e74f4049e8bc148474e9678b980da9d5fdaf12329d88de85d89a715e9b862f3539a46a45395a782eec51d3275333a649da93d134df780eba2a56528b1fb8466a558883a08fbe6505d3db1d90063e038fadd6fe67fe7bd476e772589cfab6ba6c6a3d79b765dea796e34410a837e27ec2ef2e34a0a6c3280c76fe3ce4860dad610fb0c3471d5e8a33ab1f620b0aaf6346884bf7e18f46a111b31dadc08ebaddf6668bee7723036a9cf9f6af714a9bfb5ee7978911dd568838e6cff7899aa54715ac225398687a9407cc283a4e1a95424c94b9ed16d67c99d49cdde7321fb2ad26e8ad2ef8d7f9077544e330e65c4718eb0259b944dee2294eda2f625e56ca74fcac0763018e78d4e87eb4a986e954daa3a608fcd9e87d1933adc45cb293fcda6572606a71cdd83729bf446de2b3e4363a750de81c3765d3a05c25d565fedfc313b912f6118324da4d3600a0f2307b3fd292c3d43a7524735d378aaaff504bd7984233bf8e5bb692024b824b4d5fb79c7c51b63bdc6cfc54bb20e97add53e43122f55aa3bb1b367bc5aceb6d9e7a2245b56de80e32c5dc119183f93a8a488d7e051039ea7099f934d46172cdd995830f5e2ec75d799920ebd121ba2c8b17b9526e6506977013a46533c834552aaef71187854f68503757b3ec27f7448034ecee2227762a5c6d9f2cf9aa5525d23e95fa272313633f238adb795d1696ee65c03c02aeef0a19cb837e561c03b7e35bb242a1a38f2dd5beb068159e3a7f615f624bec9c73a9fa225d5d1e0f995e4c3a49ec90fe0e530d09f93538e5d345f298a2ec5b168f04b1b8043adebafe10ebcaacb777d86738f7636056ce862f8c90fbd3da3d2de63c08a3da9337c50ca41e0cbf8b641b7cb1fcb0bd39ed2644d69f91273854624ac57046ecb846e370bb35a7551360ecd7ae87d0a4cba4fbd01296c1628d0355695a9c110a18ea39f5eaa9f81ea4074158344328ebe9f5e93384591a51734d64e821cf8b19767b203a0e1b0a700d71a0a7da385683a8c4ef7b42d30566cb55e0feaadc4a49c067f1bb6e2fa45ec84f1b086f189e4b6d358910ec9fcc4bc2f61606ce15d803ef60ac6f33d9915103ce3f4fcddccbff0fd02964e70979f4f3c86e8a06fc880536f6f85a824270682f815bf2cc1ed79af484bdb1d48ae63c973a3baa799b2f372c0ee29e98fbfa5b08ea47f2c3fe7eb78f7768d04203ef337741633aa4bc4c3166a6466425216d43fd5cad81c99343d695bf1943ec39d7a5b4d97479ea89ee377fa3ffad41dc2b0d63f7762040a3011ab961795d70700309d3a6871ae3cf0ebef4d4be22fd513356538e2c11a15d70480e9f05dc5b17bd2b53b47e409eb3f21a57efacff9d8960fac8de32e39e8d689d59034d9b74e4687a5807f1b0513a8227b85e4a8e798b6b7e1c114635ee8326c1f8a032b9192d1460e018386af83be6d34ece7f634a8b31d3076c34b4f403e7b2e48f0a42ba277c31a6c6cf13802521c30a1eb4d854f5d70f4239e11c8b8b3521d56075c1b5d5e2da1ea7171de8e3c734dd0c930a13275dbfffe29a948f097b906b24bd6d6557f669286fcde3554e363f96b6d16dca4c4c6e0fb95a5c8cb5227af2a90bab175afabbd1601cebc0e669db9dfa5f206a3f8174017f2114e047bad3a7b6ec6c23af57d0850a348365849f3c603b4e4e07848b3e30c88efb11d6a6ced43fcd0e41237e6257195926ab7e4dfa8fa097076a0d2241af2c48bb076fa02c68749d3849827653c6dea2f0b685d930f70968cd052853841f033cf5b5578469a4d951363a96e6cb1f3149bc59cc778f2d699c55bd3848c35bfeb9202964707a479b5e26f41167dc5cc74508add1528f1d1741334d5cb7c86b1fcf0f3866231eaf7d93a5ba0c41f08b5e3194e0fabd85f618141f186dc3c0593d4e004be5939fd99a5e20094f047e4ee23433c789fe12228c44c9985debc89cbbaefca75ffaa3eab9d312e4c18b400b323bf44e6f96123d20ab49aa8446e2b3a47e2b66c3791fe8e815bed367c1409dc00b9abb92236e96f3204bc2cbe4bc54de0380a7bdac1ea70fdb16c65c265771ab5a0c84ac83797918268d726ed6f2758a742bb148852d3cc1ae2c121abcf14dda514fde8f78f9a8cc4d19948748ab8e9b537644da2af4705b20da1d26330e68f26518b9b44522439219b65f64e4076b1e47cd080b21f9e0842eb8bd1b0e3fbef5dfccdcaf557bf0c43967c3ca48d5d3253d44e36d41ba62c0e39f8315f95214aaf52e5ad3a2438817556dbf47542c8cd3c9b71bd1f077ded69aca1d98849ba022fc13071ab21e729b6486313dd584a9b25398ca2ee1e7b69ebe1c901b2cb6461bb7ad7fdfc899aa61f015e27e1b7709267bc93e08182b60016e3920c58fb030b2af0829ade5ad9db0a2afd13fba0e76ee0b716d550505d3c31f72de3e1c29638e9223f305dee11749a879add70d2ab1cbf58832a288523ac7e4154905f75943a37d579e7b8af152b3f518596ab9705c3c01bcc4c809630d9f48a4c653cd3543585fb62dafbc29b62a55c6344209eb16467b79ae16c5ae0a9815584ffdcfb53e363de5fe6f29a32ccc19aca2cc98773cd09e5a04ea9b85119de4e1a9ce3142a7d965d74662f8a9dbaaa6cd9af6fbe756d1fc132412c194d063dc512f9f9bf930384ed3f1c08195fe1613d77760f340115f622d6cc0067853ee24c8eec519f91c588dca45284e27ef01a0c8e7d8a80d89dcb62dba4f60487d666c4c5a2a79b1c05ea92b9a2ce0adabdbf2c1b60968df4e718f61c9a877931a0e94271b91b44f0e24e2163388cb39c249ea016124490cd1ebbdd4fdd7a2b6db1269e927249cd916a56fdf98238e8e3aed4cf17c728c6a9cf89b7b1110e1425919bbb8a5103925671d08f6f82be06102dc2b7435c107d8d3dafc7031e130cd6f8dd13e7b6201aac33d9e3c683107c431c1493be8385ed97c95fb29271ddfef9ef76bb249de03971af7421e6888c7e90c086596b97d5eaa78158be913bf5548193423f07939695689c98b3356decc6f093f924cb6656c45dc6e3faf07f224a67fd342a05315e70445e1f55462bb79339c723d7af9b3c7db68d70b05ec945fd9469aea64febe8fd274b63c0b9deae94328a30931d92095d6cc227b9a4302242470fa524c7226d58ce7d1d049746f330579e498adcae5347a89bfd1a5b39aee74af4575627e1bc559c10bcb0a8c1c8758933bc2ee219cb1b43a35ee9322a8badb8fdc0905eef97461f2fa469096caa3a8b7ed683325f796d2d482d3664553b1d80d7f7b9a999637844fcc79d69fe2d5ae5234cfa9591babb3d08e8fe32d8212a11449c9e93b31d50e1c75696ab1644357acea15d97815baf0808b5bddffa2a374c279dae03bc1f1da0e5a95120541d9f1868d40c788627d6c05da8dfb0c4584e2d57c3b557789c0a05ed7b91065dc28d75ce4af563628da5009c5c5078d135e3d3efade8853dfe6c9861d9aa752f5d51411044adc404b4b9799781c7b7ef4c5396bfb39d7631883e82c5e58e972f37ebaf991836b2cd61529a777acce95b1efee8a2ca5c98e48abaa74172ef3f01cd58b7781979dd7fe4a952371f5514f60e03aa982de0e03b2c85dbb1324f9313d5d50c454df8eb4d076d3c4f6a0e29afd1a38761c6a479c593eef52eb3c6d3a8884c5ed37d1acbfa48aa73161d2d9a172d732bda787b6b24c1d1dd85d7c6eb7fb80c70980833078cbf25be5cf1ad14e62037990c8f66bffc1b660f77dbc59497d9d0eb76cad1424b8be60cc803dfd2b6c6ccf60a1504c9d65ddabc37f49d5d6960f23a404fe26944f8db66299e6d64d3af8d81601b1c2ef76037bdfe71ac2926740375c6dcd4a8f536c7921bb87cf5ae3e353c42889c2bfdb4e27845617ef9b297e43884e4d83c69ce3863a1ec0e9735e985aa930db3e3f44f3ae3588577dd72ab0448953c41134460199a93aea10b6bc46543d7a817b20315ccf1f5b5caea7f3e025b26762c37376bd296c5eaad6791e84a1511aad8cbdb9797374c2243d75b8ea398662de7445e1387ef623983a1495e1c2ebd1ecc2f36c030697a8ac3ed2660f9ef7b707e1018850f6e14842f730c2ef792b9b40ac3c5ffa20664b4a8876d46e8a1d57437a265a847ed5fd44d788ac624b86cccd8b032809cc205119a03d93da29e15bb5dcf179c6a3ba65c1d5fd11bb8e5f7091682099c6c9696cded338a1bf36e0b8ea8a6f9eeacce8df64edfd982209eb14f9441b3eacc330cfc84610a1142452f7e5511e6b19c00d4a53b223d8ce40107c08fe220e03ab10543ea8d489c6568cfaf5416023fe192fa94c5fc4f001f3c4344c151359c063d421bcdd6bef8668d930363f65323395c885f61e3ab2a348a5a33af209e94da3c8ee55cd7269b78dca21c736da94bdaa7ebb041731465493926f0b554f09520c230f5bf7a304687c90bbb95dbd80d402265f0e8887da3b8fa122bc0fd08a4ad3a20173335d378fcec8238e303f2846f3fc04f300f58c28297f3e9cef99482f96d8b4bc80282df3872cc5f8633ac694dc345e350eda7e720872329de3fa865851ba925014926000160ee843fe38a9769d8acf14daf70b20c9698211d560363be94149f9d0cbb3d90cc6469841831f85c30058bf0b5b238aee69fdbb6ae5fc38a7304d5e07f088299bca0ec800af40b84738ae952afe012698f4f954ebbef652861640b4b5bf61dbee6f4debbce2674b63322afa69a696b302b2a334ab5626ed64d9fc01e0a36b51d5a031ff685e917302936071fe70026f12caf863939a5b39a8a2a7cbc037018572d5224db4be493ab0068cbed740698224bf70fdb899bf05b29ca70d1f03661f65fce5a228ee1d9e5b678e7adcaf0747d11bf1e219da8958a6d5b1446226ebfb39b2701d03fb6dec3e16db3918b501e1afbbe1839df645c86778142be19948a8ae43974dbbbd801928ffc659d4efc6fee6aa75c5829107330b34ce053f2259abad3440f8f4a7273d57269b34c0fafe2fa1ad1648a009ccb91333e62b558beedef62a673d2acaaa39d54eaee8000cad4019fbad1c830867ed19d5d191772786ebb1a78a47c3dcfcf405ccc1bb725f5789534580f7851518640f0d38dd0884cbee1bb8193fded819ed1d53a6decf9bff6efea6f5d01010e12cae28de71a051aef64712169dd61077ca27bceac5967027cb870e28ccc06cf634d32cdf45769bdc409e4a9707d9e2c20e26815fcf2bd1c9602b7cb7cc0883fc731651b34b482641ef8cd303df005a6f02270dd825624d632cf1f9abcdba21403ae889e2ef2407b0015b6d7bffd1e6dd0bb8e96031488e59a786271cadd80c26154210dfb200d0135c4a202db32516513d112a5e25a368b8913e1c0b9913c83f2cbb4014935e34adc604192961ba7d0d8076b8a44e8ee2cce4ba4a480a79c869e1c48e80838cb22b7789469513cc440e13c8f8c0289a82507ec3aea7fa6b5f1834ea5be07da03c27db580338588c0fcde9ebc7234725cdb381f8e177134b6893e569d943cb99c4ccc8b908c776948d7d226e6b8e2ce559dd65de9254742081612951fc0cf1f041c59343dac955074c5ed3d14183c0bdff8b5cf11c91cf2fa85495411707d3c13503fd76828de9c95e27f1b9b0c873e3c1650cb3dc7abecf2e94149b9319f02bf26e879c735898cd0c9a1e1db2b914942e9885cd1e2a6692d7a684dfbb4c01f7503c2c5538f634008a33e8bfc1ddf5ba1e10b2a1a6b235b6fd694f2074d3a6d3e240a731f6aafa6446471312ffe16fbe42883519b21b3564facc934ec9d8572fa7deda5edcd5864b4b97a4c7e6d3efbfeee03355fdb6040ce41dd47f857692743976611eeb6fc211d0916c2a9f1bd628fe3ebe38c947385ac066a965a3a4bb4245d1d5cd0704357f73348f08a5a1740dc35b2f86fb0a6187e9c83b4c28e36fd64f2287c341fc178e91ce667d3743839f0b3ecb697f52f0b7d3df306bb4e958574727666b68c9a768f53ac5b9fe505d82c8315e41679104703b374c19149088b7482edb46aa3ff17b82ee38f4d4bca136bb465398cb200deda9d9b3ea86d91ce105fc80e3daab7059acb08caaccc70cf08193c91f3bfb89fbe9ebd6a62d9b44938033787fd58a3fce76080e6a7107a7517397defa43d197c5c1e236ae95c697de203bb9afe5497ffb7de6a2a6d79cc3c202ae3f3bdc7e658cc2379f89267dc6152993b966963dafcb4b3f6dfb0626611d14dfe0b5a0b10d735834cc4c924ec38b0b4dcb1f616e036bf1fb556acb1c782c08abe3528216682db93d7f3d5dc726f9b41fe83ab30e2b78e58786b3f8e2a6dab06b7216217292d9ce23787b4f165b3c9e758104ae72298a1b6f4ff0b99701435932b629b476f140a8fab2bc56192c4bf64877918b50b412c4e3f2137fee0acbbf04de1978b8822a861421d8c537055b37ad03b83298ea0edc00af0ffeb86f80323d308c77c8724ebdcde3b42c96f6a7c99bd9a5eeeaa7225112d0643285d1538ae5bb62b34d9b6f05ecf25085722fd82a98126e6b7eb86721d2dfb51717b7d4ff4c9f3f57edb8ba7df353c5a68ed5fdb8a1df415ab015069e18c2263a5407455492a3082bd83da48d485def7590c22d31ab569534418a8b043dc9dea2cb74bf2df201a4a00d8e6477d33c955e230f2548a92a6987154b45a4295541c0007442ef052c8445d03035ecd967130ad60829567c1e7445524a77715f0f77ac1dfac8271b56fcab81cb2fb25ccd037e5790a995a26698a1bbf28fc11431a6c44b25eeb6d9055eaa06bd4831536e4424dc5975ca2fd9950e9bed7e54c5696edfb2e994108dfb980000af86adcb7725a4d3f0e437b5fa3eddd9068723635684df51a23284978a5e70f52f32730b0d7676fd614d0b6092592bd8dad2e11bb56bf9b17e3420d77180c0ba774dc95cb849089e90c7a6feae82d73097be73dbe0833bba5007e45a5863ed34fd6ffcdb0c8232d5b9d469097cc77abce994c6c2736f27f90dadea4630c8cce0ee7fcd3301938daa51890cec4f7a3669a50419e95744298aa919a9d71e1545124dc36b8f532851b3f87e6dc83d4dbdb8d6a9fc056e5ee3d9db4032d8764b2651c409930e0b27bfafe49ae7be09c4885819b1e3ff1fe0f48e03521b3474558919f7a2242fcbff2d905cde7ef3a9030a9c87202e66c68577c8e45e54ca1bbff589be75493c4871f0d8ae15286482571cec29a30d23a0e68a9845e8e541c21ed583b2e164fdd762bae8cd1191b5bf02c2a454f0cd54bf890547b430d9a315aa33d6fa0b8fe5931b07e7566240b76c381e3dd40a79d806d39740f61e2697b3e052be6158c82144ce7a2f0dba6e1fa11e817ced835315258e5fe6894343684b621c23e72f68950c7fb3e06051ba191227547d08a4adaa305fc91367f2eea9f4bc3e0c2bc7fad5dac8c728fe8ee66f3f925177642403201af9977626e7e671ca85db9164c93641be155245ccf788db2ed4ef0a3ed2e1f988d1c59a41969996eb5af360063c15ad2d66aa3b6eaaf19b373d675a511faf1d4fb50c6a33e47d724102760f990c7c25e33802484d4e0c828c18156dd42a728cbaba8f8ec0c77be55dda456877b8af0aadaf27413646c96af413312675a58a6f602c14d8c3b2ffa493abbc27d6d3692d3ac5b7b2e19bb7de38f96341fe354f1d320fabf73b7e0ce6d056618cb9869b63b3868a96e06d4a14c97ee23e85377f9e5211edb70f83cdc5737d068fe2224d8acd39cb9e9364147512fb974133378239009d5e04d0db654a571f7ab54ddf540b7be74e42e2abc2b77df28e93020830e83c1b587c988d71bcefb80d6ceafd9d59af0dc58ed3a73ae8211b85cf4541f8431fbb27bc736d117af8c1be91bbd3095c88db5ec97266fb36573749b416e26e33f5c9b4059e05fe3c073152d2951b388845689359aacc40a7555dbe5f75916683df74edf501e6ab552dbd3177886eec892d43efbfc67c9ed46b7d0dcaec69d4ebb5b759d61ba304deebae922a79c439d2fa874bbf749010ca0ee02d61664bf6f178288c7594ee88a053f9aa55f4728c99d027e8c8f991acc6be34761f47f46923efcb349b230747a628ab434ece52abe48c2eabf16a4f65b912ce9ffa8976069542ca20ba241f352285db6cced70bce1e92a103b964c95ad319425dd0f6598d8edc3ff1be361dbd1990c0283ac34c6292f4e108b588e2da68db2b825fdb4f9f78cc965d2807e2eb564cc8c3070cd344ec1f814bf9d37ca349ee8efacfa3165ac24a7d3d4dc48eafc5bbcdd3b89a27fe7904ea5319fff8ea62535735f8c19165c7abcd8ed69f6337977282a35cd2713ff6a3ade8cca658664532cf20670d651670ec2aa1f331678a311083e6e6c373dcffb25f2e0615dc525945734dd189972257afff6e5da052dc092b208b5a50b568b029a60e00d7ae32dd13968fd672a40c76e666e2857192d4b5f7ab7b1a0b99fb0205354c4b26cd2b5a0a1e2abd2a3ac2e8e0b74f759c75fc66c49d71c6d4d4823125cc114ac88fda3681fb03ab46994004faa0e1001c465d5218625333685184b7f35b127f2891effa127d414ad9071785c25d7b7e2f84e30d043e2eb53757baebf6b8093ed44ec11e5e34300a6c3ebeed3e9d8e83c549b3acf5bb4395b15d34d7ea9136a8c74b131d6782158cbf1ba9b788b5ca3acee3258b4527abeca5f7c598a66cf7e83be090e0787f7d7e491899846e1d8e44cf7c07b3598ab9ba15932975902391c08e6666d547bfcc6f6791e6a62247f26f3b08588d36540385239c5fb360f68e12b5d733a6e4bf33286d0c0dc41edb9e6f47a759817576959867cc7de008ef990e71e674a08d3c7c9d5345af8456c730ab32f8fd3edba48125613709ee2acc337ebdc3f9db66e2eaae85fc3490480d5c420f5d6a57cd39dad7f147369d52539ddfddbd676fb229c287d902b1c559194f54b0eaf661cac7b0c28f573b4d213646ad354af15f339504224c87d8170e41ad39b83a7e99d11a1fd74a77af737d09fed38bdbd68b2d89a36a1c78e40f5d3da339d275ff2860cc5074b85c601ec31fa7fd46e24b85c41f4239bc33355bba22e5b885bb408f256a8a30d447b905693cf65baf5c25a3521f12bc5a1ff2582788d1e5a29f1f8f73e11512290bbbe421acc088bdf646cbb3b91d80c6da515064b70bd154c2a2a6c48b409ee9ee3c0f7add271d866a298df011c169b07c02b9d623d7c188915f5e553407702ae6bea63f301b71d8d38e000e1a7f625cac513186eaf2529263b6b6a73298af652d1d1dca66c3a82d597c4bbb2bd23d83aeab83e718dd1dc30be3e81429beb89660c7e7fdb3ce752872063511471aeb08686ff002070da693008ae964b1f1e330d287bfa92b9a75a4f575e362457d23d0ab1873ca47bae235a45efff0571866aceab6487ae804a790356e8d95cac987bc5180be4e9c5d9040434a45a360eb23d66fa5a423fcd646b39ceb30437f0b5aa038cbdc8c2160cc083e6538b7e76d645c4d3e846a92713136ded7715ff1dcd1d92b762be356412dc341c7887c01fd11df93602a6977d08533feaac876073387760fc0bb0811a78812619c960b936894d06ecf434d69a82fca13fdbb1aab8a4b59b88673ae6296955315fdd22c18d2394ae96679c26444f49f2fb3a14c69ccf47d315664cffa03a9cb7e83453b4b0ef2e4d74be08cee7439dfb9c73fd2858da8f6540b9e92c9466fb8fca0893faf0f8dfe6d3d6139d6aea9e6428635d4988af035d0156119ef9ceffe739f2c5df464aaf38c123dd531bde7461731e8848ceee50cd36d12b22305c43826031a40862a28e0a4e26bb0a769fd47fe68ab2a099fb60ec372bf50af97f3f3124fc1ad685b996b1d1f23783601522a235be618694ea9eb2059fb36cb0a75140f5f14b38e86a6608ed2bcbadf3e75b2e9e2d936d74070e2f0340faf4e316c29f7e3d4bce868f4f1a64f6096e097aae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
