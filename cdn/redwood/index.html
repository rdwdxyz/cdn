<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92a316df1bfe3dc22e546c1476680759573eb4f670e90c3ca040dfa880dd0f1abb849e6036e74438d72db202b1e5c68d19a630bb57e5fe78e73d5c910c2eb3116ad548f6ae253ba4a93d8734b0fc26dc7c808171a110e76b37494ce2e8a553b573e087259f5bae4b834d4c0a391f5985b4217782bc5eabd9507edf94e38af647705bb745b386695dbc62cc1c7def6e6aa5c13a599b43be59e547b431da5f798c7343056ad702ae663d8c046943cf5cadbc42b58e7398859e816962820aab4460af488ef39b37ee54c1899108119f5acb1b83819099b335a999fe39e309f9ee6686a522d799dcd689385dd7b2f8761aed3b4db5702c14738325feee080c67caa83e170ff6af195b47e2e2ee5049e5a4e2104dac1b82ac9ca75e0af5b025ae3d93c6bdaba84b9878d7578cd3d6985a1eb23ed9bc010b6f79056ca1c8516992b660b9ddb0f169ad4e05abc217a166f1bb105005327e53b7aa60b1e2f3f8db886054a5d72206146d2b6edc67e8f9a25bd105bc2eabc408c99c7b39d6a7fc7ecfcb135c58b8115b4f184433f0d9b9517af5bc19ed7b5b36425f2ea4bfcbeca282fe8c4c236e04fe823eaa21eb824095bb33724795a62b0806f6f09b08e17b87f0d675dcc8c395218a3736b04e7445c572bf62ebb0391732fd9b090a55f9faa073c25bff1402589cc004c3ad9df9cf3243b0404382d17b4ebf0a3f13d7aedd04d39fd2f9a5f2de93b980cb18ffaa4bbe66c06cf9837b65217ddb767719ea082f15a8a400e6c4fc3946bcb19d7002d3e385a150dc91c6cd8d1ce6168f3df226dc5fd5d642dedb0121e32f4e8f89d92736190b852603db81b5521dab8b82168adde622df9f678697c943abe466b9816b937369e5393d15a83d5d937bd0f526cea381e8abcc2904c7496a50a80bb33087d834b27fdba14bc52e9e78fed90aa40300844ecab17c1bd416a8f67889782c8b2a521286363d6668cd9bfb9c94493d5b2e7e058da4f71aac807c9c0a4172930a365a02c27ff6fd294c1b0673cf8253222504c94cac231b44b72e61262bbf00d8ee73a58b8690a01d0e389e23359eb16691cc002a40a80630c41b3daa4ffb905c0a12d5c748872b4c9dfcaa4377c4618a140199138e678ed338231e036c15e89f1eeea0f16f3ca78df64c9b7f17e5ef70ae08d1800825a75845b1f0e3794c09fbee4c8a0f9eb122d4f599080bcda502378863761337999673a0448fdeab5557434fd9037f4020288d433f4cb874fb0b14b2e9b6115b079b1eba10dd83e063f83bafac087d079a25f74af1f0c30f5ee6f79ad762340475e4ee4b80e871e4d41bc4a72b6f63cff60f368ce17f6bc4573a2fe3a43c7292779f3edf2e9f3e36482e5c0a53677e2860575b9012378caedba81b25b58389dbbbdf33439f69f5920385ea0e784ad2e195e9abb733431bdba7694fdba1b9edd0c5e601c034464f3fec4f959477733fa9f25045a0a420bbd4be141411a26c08a655f6cef5a359d5b262173fede302ed26e78d5aa6e883820e9d070d25b4783e8c3eee0deebeae5f0a95cb5181729c7dea202ea1bcc16f4d3ffd04a5656ac6285e76d5df5b38edc00e00ff74bae35884d56f2944bd7a159b1ea982222727a39febda6926d0f39c0e152e47e558b0afba5a853d952ca4ff0886e71aa2d43fb011f06cf9acaf3dbf5d08fab9dda7a60dbf06209b942dc1642d328738cd2e9037ceb480de3409a76f1b0508dddd061f19433500448f3d363aab0996426f87c2673078f1ddafd0320fead2bb681f4a3cdb18412f12db54b67de9c98a2021072849ada18d62549e01cc3404ac74631f54498cd1c202bcaf56fbc20a050eac4af41fec78dff9cccf7b91d91f37be7c78bbeb595cdd8216774a1e7b51349b840e023bb23a2034c6800f1fb6c0d35a433092ab51808d34aa0fc97c9264dffa0c010cde05123160b96b4386b292d5c60738e09241367688739c03bbe794e4dc86ab82787cf8ff870a95bef5bd60a67de69866ca7976d2a30a3db4927da73ad7b9177e1c7a9c4fe87d8cf9e9b9b29d3dad310b009a4ac0ea0e45779c0e7bc5b79bf15ffcc502c82cfd81b1915f4f88c592bc626034d857ae9f651a4aebc1f328f12d6dc7a852f473e3d745d8392e2f2d30b44c83262665dd6960e3f71206362dba576f786d4a846022d537a2c9c30d0aed5ea6b3f731fcf00d36cafe9880e756c6bcada6593f11df473143b79a67e9f79a4978c81f2c0770219db5fda362529aa4aabecf03a67295b9cfc35ac7eca63c56ec860da4b4f8c7bdf75edd41a12efde1f3d0e072a86edc19aa8d64cf54984086ffb0d308ec64d8fd7bf6fd603136622045d652b148d8762d31661304243c69dca5c5c923b50b942b8a479f2766e52968533dee945ecd15e9117d598df515fb50c8a6196a151ad7b222185b99254883bccdc149b7a460b1dd425aff97802c879bca058d61fae6f31906d999b8899254051c9ef9c59cd677ec001c7ab66d7d1d1793a88de998707af431afff1e18d0546201df83e47f45a5d84f1f10ea9e2bda7bba3fc4925197944acff8e0526b1099fb4d7d224d375b2618cafcd597181a987e1dddcabbda9af7330a7679ba4d112d8db8e586078058d1848f9e2e60ae5a19411a94010db167adfa2321db8464b912930a81cc060118bff9b8bdd0561f24c31f0386887fb44191bd50cdc28aae64590c81e1d0e782280304308c0b0e897a4559fcd04f344511d676ce637f73768bd956755f7ba4bd2db7b7c2eb334a4bd9b56003841adbdc200256e217e4be2291d2f7c2cc4ff320376c44b3db5cbbc4e8e863a7b53955529dabae276e8488722949de40632d7a670e9a820270fea7f64d2f2bdc3caa3884d31dc2680faa0ddd8d5634f26cbe1f63dcddec37f586a9fc961ad376068b521eb85948b0bf29a8af21b1a3de10333ffec92ff13f289a458de865136d3e620b4b696f79c2c71b679d91de29ac8cf367b20f48e0b90bed45e903e7c9ab52284c41906d52a8a283c5fc073efda873c439fb6ea6b5df404b62b8f3e83d2af05df22e54960321c5e21fd670f03742a0a7bc824a1e4637e5bd56f5858ca5fd2e5c620b51c203039d977a1182d1170ec704f9dd407e402a9b3203d27fa6abf9ec007555a2d6de0336c53499b1606e4b4a93c8a6c0640335809e0c98f0757445bd2b858b031ed33eaca7a9ff722d98a1a91b286a1d1f40d094e991876bd2b44d2cfa35b3d1f0aa7749db8a7263e82bcabee8c03a492fd410b9d5bdcfd548f18af1080ae4ccf7fdbf764e00a4cf92c181d14ceb7e4d7b561163f15fdd390bc8a960f5ce97d9fb914bcd09806d58f01cfac22e6381217e2974835e3d7a99df71b2d4e758c40a94562b3e2cf95953149eeff75614c7e38e5c83c1e87bad7e3d09c93d480f4bd2b8ea3c9eedaecfd22f16c6b8cf78ab5b5eeaeb171b8685d8086ca844dc868c6c3ec5147d7382ab79308f0a0fac60c7354e053972cb4eb545b3bcb2b3d4d5c845bd8bcf6391bce9afb51272b7a9e74a803a4ac7c312a138ca1ff3033ff8f07d9ab693758079804e56967178af97ccafaf941651025ce5262f53d30ba61e030f70c380fee0082914bfe65e2fdba0611a73d170704de7770707d474813e284ad19106550efef36d5f3cb540b6a74d7a5cfddde9da8b09c05a43b04c952ad31e6d1b992d3c60cd63f3f20d28428ef127402456a8bc3a5148c29ca009aa015a1e5b19a140aba66aaa4dbbfe40647ff2c0badd61686e1c922846009e7375aaf51469fe1a15a23e6a7e63e0744a26ce013bdb91b78057ae36aa7f2cfdc35c733012dbd173b8937894f4a6b798b72fa2fc6eaf3bac8667bcda10f15d62c54341eacf46f2303635fba8c0f20cb92aa2a50e0c926751b94e4aa32272641659ffc1eb0cb787c2e52b0a272775bc2429b26d037a09b8d6a038ce2a083c882d005a769e300ad485feb581f03e2606237be565fc28bf68e1589e985ff7f302a50972e68779a8d6ad503ffa0bb5e2dd48a2d81fc7ccdcedc2a9339a914ceb07ad9fbe9b0eb68c88ab739358bf8c03961fa1c423bb6e381039a94d1dcb108211c4e96d87061b85828d25c84a365dedd18d8892d49a197b70687f4aebb2d44344add1d6a457393124a8e9c025b53442a2e62509e6b883ed24d85ca2e18e31ecbde396992dcb0ee3f90127c3f9b0e7962a48cb4d41b320a5d627e6e089465d1ba3f5088c5bb005d16ebdeb7e8021725118c53f879f715276d27d35eaf41128005699385faf0b091f79ca244981542628bf3fc30445f8d89565bbda3363b0e2e2df6715301a875d40b90b3ad38550edc25ebe9ee1357b0e775554dabc627b58038b61d24220ecb237287eb73f20d945b9e7a9de9b2ba4d4744940c4f7d5b2ad97de0b973f14e2ee54a0e6df6d7f836d4b90b05f3defcdc9af6652e032c31c62bd29a8593bd2959dac61679ba0fee078d74209fa454e068ff2a71353f569c33c98fdca77257332d10568dede82b1c52df02de7f3fdf6642732f71b010bf01474d0928c2afeb4bb04a3d7cbe7d4203ff11122e0db8814458a5d60a1e32e401995443d76fcb23ad5f4cbb3a044d3a9fdb008273562c073d7e296dab17de3fb504afeadb009c06d5987b01612c93b0b371665de8cda29683ec5d365c282f60c88431eb47f1d065ead97a205268bcc0971a72313b2cdb3e9887783e2da9dab9b667073544be34434cdfaa89ad6635779aaf8478a8b7a579d49bbc71bb3da894a65f952ef057bd83587e5138aae4b917c23717c6386016fbca654c413fe38d3bde352d4cb09cf006239b47be757caf8661a80987eda5701eb5fc2405c67d7cda758150f2d8dfbd50bc8c4617cd0939aa87a9bad77a8ef6093b8b87d9ca0b0f3dde1a38c6ea7f2324d23c0997f377de9f6d4777c3e21e40026e47e7b5ee99d87dda4fc4c29597afbc5ea3f495a4de6252aa1622d3a036c8386a8fcd9a5dab1720211537b56224238a2f9196c8629748148704279da989f31334ed1bb65bde66ccb7f63f4bf75ecf1ca4f1f3ec476a2bb5e514137700c18d7441ff90313c24620a8fdc4742609c6f45d65da7f95db9fed540085516ee26313f2f7f50bed06bcd7a8edef7a5805ed431251236210d4f00c8987f2e328d54d342bdee5211a1d67010865287bb7c8de10941f4e0acca68d78c1dfb21dc021a672242e3caced93c194dbb6cae175211c29427a641054bfd6a89af4cc380ee55e56d1e00d2af25048e06ffa79bf3dc8d3fd149dbc1c9b3f5242bf3bc070217ecbff77b08a6427e888662a56ed212ace16f9f93553bfd2d9b81688a0ca47075d4bec43c9f66f8c96bf76fe27b421eb64c59d8f1f2eb80ac8409b202b035bed0ae5f0f4e76c35cde0d5f27f6777340338c41f4e9a95342327f733054b90ecad24437bfe946c8db43f3587e792abb70a3143ece1ce886a61a42e03eaa623a80f529f4a45712080e399163f41005bd72eb3243992aa55fc80362d01493f55f987becd2abdd9b8be639a41bb0b42dcdc87b5fd6b63a3486d112adf5a722c45262e178a4173d8c50342bfbd9189d8dda9325c2f4cb5bc61791273c21a6df7ebe5c4a12f608b430be156431df31f4302ee93647271e44c39ce75aed00bab1584afb15594964fbb89a3a44db6b3ba10bb697162fe4a51b35a46af7ea19f668256acc449561ac956f8510f3c78f7c764bceba5c94e61cb143d448a747d02a504cc0112f99f9bbec9e270532486d3f80e0990e677a9e1e08da05578ad092250ed2ad3a914a054229b37fd0dd3e7c3df2a17210aae83f48ba48bf3dbf6051323dc01e67321b2eaf435afa0611f80b2b1bedc050b90f7910a32c68fa781d0dbc0acf6e9311004fe0cd5e3878be6c60bbbdecbe9c46a0bd441c53557b2797dccc4088b81c55a4403940453e1f0a2acc85abab5839c1622cd1901e5868f8d5244abb548c1d7ac278554ecb1da9ac791d960001839ba1c12d6bb5a71064382213ec29114e531ec33e63b7d8c351a4918d13342aac848325da0e9971a6cadacc985d4795b6a01ec61ba10e86021560d89b69266a3669c71345a75fff6a7ae647b3da00171c3298f3aa18af6f12037aa400cf9446def93c70fb74475b2307f3944ffa90bebdecff4fe34480141074645e5c9ae8d0c49a17c4ad94ea3edf7c3d88272bde6b5003cf12ab088d5c43a0505f37b1b79939eb17307df9adc6e6d3ef85726d05b05d382879e9f5bc1f7230c09e4afd9bd25ad7b6af46dbec88e43881cba64b9b2325796e5b45707cd2de83bd7db32344e77d06492d9cdf3923c9e256325d186af5d1f3b39e2d96a34d4f84b7f86f180c72a415483ffd9d66bd76540ef10de99f542257f020cf6c0e5ebc7c78afa718f7def7f12151796418a1edf3dec5a68c371df58d420d59cd16d70a2e92223a9e689cfacda5605845b01e847692661cc7ee306bb548ee8a7db48dccd7ac615c3b74b2377776ddf2fe41743b14191826433436276fc8179711f8b20c8337e1cbab7f28f48fb713892825e708be540c28184dfb8f800ab780d4a38e0ba82351f521f5210b43099d8f62055378d7488e40eabe0242e285fb486acd33176c3b6893ac95c46dcc59f6362b0a00eb0ed2764373cab78e8880c436a93b6b94ef7cad5d1f2fc7793f883302d5e619844547a0e98d00fc4c84c8c5fe2bf6af999a0415d29a212f247df9aa3983c1ea4cf169bc7b1fb68f3dfa6426cdaaed48bf80cac755bf8df6b530d7d789671cd28936a031b1789b3ba1839a7ba770c25583ad11f99b3b5718b61e0ed4fc6eeedb7306afcbbe21c326415abd4db82edba1e8c56141dc4ec80c0b0f3acb7a91a815d1490f3c7c6e71e2b64de27df27d0dfe65a890d02ea138fef313bef6170c45266b66651886d31c06b218fe8266f6977a02593474f36b2c8f6d2c12bdfb5c4223c6cd255613e5e9640995595c5d24118298eddc4eff8d87c2a080814d9ecb0dc418fc27c510341d2c10d5077311ca46f4e3abfc93384c52ebf6764a966c1606b65190726565330f32dc3342184db6309f214f03eddbe7255cdd639676d79b23dc933e24690e15daf711232f70dc18abe1ddfe1028f265765b99354cff3de7f761cb84b5100df84020b7e4768df6a4a00e83ad87297be1a746188f4d2c4534a887b0fd3e80879895b6cc138721491c114f814af0e49246ae31537a4800328d4ed36bdb3080225b7cb236104b8bdd323c2ec1204b662ae68b94a54a0d09bd7ee8bf93ddd50b654871b36eb44be878696392c5f16d4348977870255f54d459d3c92b5a814fc47b2dc03679d66aa6ef6121a96140ff91b1e6e1c57b6fe2f268b5802d97e7f8eb8a13c1de5589274fb76faffe1d746f3aa896a59c3ea172656402842631b9c5904ccbd1e6c49f850107170eef1c0edd76f77adceb02b8e87585b332a92b84eecfb578e5d8ef7ce0573b33c7b35de4b8fbca4abd79892389f1900f58e98694fee8a44f94152c57553773c81a578ccbd85321d86711df9c9f6900396c58c66a95c05238bcb56f997f5f559cae1e379fc843b62477fcc570e9def24dc21eeee5205389f174e431753325a956d29f4f3ffdc050b8a14d0e3e2337e4fbd1af2b0962fd59dea5244bb38441a9f3b0113bb55e8ac776d4222549c0b538586af7c7229807308de6ef285fd4070fb3a9594701b1d3931eab11d281f0bbbf7c3edc12d46c05fda72cda7fdd2ab9d5c5f67405e62ccab5e1eb1e51671e105f9f1263789a883811d584bdd22dd6ea49048910d474e37a1fd473f14d3c1067a8276092fd2321c25259df364c9bebfe44fb2b5ffd066a9d9d2eabe1e916307d7cb8a8a8e114cd60394665e89649bc0518ed50ffecc743ded605e488a4a7b2faee6d20283b8b5d94898381211d1beb228b7e268b437329d3ef980452ffdcfcc0f10c8087e942b61429a34aed628677def27aac0d71f0f8a85966e43568ed949d9ad89bfcbc4e82d1fc88575916d06acab2bc22eb14daf8a7012318e1db6921497c778026d297a87f3021f182a5340b3d23078f2a6812325f49e646ce60268458f0542659a5de661429107ee4d2504c0de778f7701eec7da66968761cc2102f6557a44649697af40668e51cfca1c30d5687fb3046398678bb7069aa7d4b20b47224563cab2a9210a2c3560560220126f93ac0dde2074973a5f99a69ca95f7a74fce3dd504e2787018289c2d195e67f7da4e3e888d51b44accc43787ef2dd8c6d950414c791996de60110fd4cc58962042ff73c9f5d28bb021462c061a7d25027222f0cd9c00b880be13cd045825b864fe89e86537db8645b6787be0dc0c636f6932b46452417656448fd68335e4579360dc9fd3a70a29e895994a6a835494392a21bcbf5995fe4a2d3125c613dfb7a040a355fd75594696a0d64de579ecedebfae069dd2a66d41f34cc6aa3347227f7e827207654d4cbe92c5669f689b3efce08733cf7c49a0d3d062604a98bbb4116e73e155da484cfde6192526850982633a5eb3afb0c889b70cf7d73bd4bec246f373a13b9d23a922147f7eaeecca25e033c86349f08d3163c8f565257eb6f2ffc4358c11ab7c6bad4fbf2c8436c561e4b83253b76e3a42c06a6afbbb4ab6ac0f6875401fdb84cbd139d8bd9bf8b672ebf446f9c5a7320ed535781b0d87c8b230bc432851743e528e7834fa85efd55ebaef21c9a4eff9acb0ca6a8893dc6f9ad12797da11bdb4904ee7a0cc7a1314fcbcd573ee66ce3dcaa1d6dbfbdcf81d80841935ad5a89f206747239c6fd4318a14a26b35f401d36ec663d8c2df8f5187d46527ee935d3fe429079ed4dfa96a4f2c5e92f858da001ad2ccc4473ae3d4e53a8fc247819ded10e85abb042f4ccef550a816ff397f8ad97f41dcea2635fb503fc8d1430c1b737740270ac191999fa3eb62236d5c6ca318ed1b63e3ed86c6d0e257ec5ff8108e867ad25ecd4c2af26fd0fc5b3f15dce05d41c883c4e8ae3b51dd002f500861259d4baf9067c6a918dc617d0577a4051d83b8db761736ca33441a20630103cabad370a63a3d64440f2432af1934dd5b533fa342d98fe8f8e3c58ce27949e9e09fa92158fdd82371a64a28cb17cdead89f570c996bb2a3fef079a872f6c08ce37d1b733de866f68995df9dbf2cec03bc0fcede561109ce7e72a0f1ca1b9111d3ee4b3740faaec73b85e0e589376347bc4434da88080879185a2e3cb47529b41c347045dea7505e79bf75361a1462810dc9d23d9f43841bdea68e2b14a372fcd0393fa6baeb960f0c70ddf25dfaf11f06b60f1749dd4e0d8c52c6c7ac4113fda43e66869756c31ae48287ec26c05e05ab37849dee55610acf0ce2c8fa9cb9a73aacb65e969569f34ab97b12309a56b4f634994b64455d6660c556ad2651c7ad65b5992901271af4c20ef3fad36d95f1a039f9eb598e61eac18651a4d67b9d76481b0a2cb0fee2d04e88c05d68c0d4dd5fc78127db9b09841c11f979cbcd362a129c2940de143aafd72f562e8f847c31daac72e8469a11e945e804de22f45454f47d583f6f8339d9db7422e2882e0afb0911b89f17cb513fefa1a98a5d5a386900bc3f5885895d40a2ed0915ed840f5f71015995baf583bc301b9033ea01f56beeeb021bd75e118a0294d35f8deae0ea9e78ddc78e25fd171251104a1ad6b512245c7f3452bc65fad8461d9598a6e48d450830451b4c3834b707c2dd0cd63898fc5db41b2551cb413b1f16094450c5a6e4cef7ff5b44821f7f1ccaf5d003882fe9d7d4daf726a5c1ec36903cebb94450238f0aea084a9b16db1789091279cc04160e4523941f15f81d0a124d20ec10d68c610f7806e454f9bcf2c4dae9777e89c6a91d09072de6519cb124026300d0528365a1aa372142a0af9700c65f0e46d3c30d517d8dadccb30a08292ca06a8bd794505cbb8a0dac80b325fa3c486dfb8fee03b2ca799e4af012788e470a53060ed0811eeffb14efd7e5cce210420b606c77df606526ea732ecd501a8315e5e7dd49093f660b1f89c2f1188196f6970c91c6c4ff48abcb6d237750fb7376dd2566007e9a67a4924f13a276dce856832dc7bed3d5be1587280b15f90c4c9f1e53dafca7e50e04440d06d0651cfdee6e720a4a12184b0176dfbd2a423acf5e6d7e97c479b05c5b9d19a9bb6879b3e054d84791773651e540fd09466cae31c8e5b8acc7a595c4f2c3a8cb3cd15a50f3b31b35dd2fa7c119ae6ce23014f1e92da6d129e3584dd8d895a23f8369b92475e4f3b817d4d7bba0ec78d4ba5c1b302bfc920620b363348508050e27aebe7f11a95903e64b409c54bf04f76d2140ed1feda1a266816c22724ab2d4b7bd8fe620bf06c18400f9a59288f7d3775cf66a5bfe81fe5aabc71d7116f170243380606690edc7eb9c77c6072abc1d6e34b0fc1a783bb0177c7bb55a064976cdfc2a2826c0b83b212ee4ee40b90c4ff930be0a3ec4d58b51d3f285f01c1b069acef039a1f8abac9843eac70e37e213f537ae2c2c5dff51f6dbfddea4731e2dcc841c7f563d7c2d1bd71f1221daf7810cc5310567b6b845960429572cda200ee70118c4a337001ed874395e4c540da02b33885d6c6a337fe4003636811e51ea16aff12ab0cda609b0a2750d4fe458151d6776328da96947f2f634ac419a6a94572c9f12622cae459d861c33c7149a48a35969be32e69880f85effb86bba10d2105254d7858bd538d6c376ff7604231af819c445a8613b80f9c300cc3e67c05e8d44b427d77343e50ee4c38496b5f2a3eae24d9d7d660832cdb28cec950f70a6b9897ecc2a3d387fbb7cc17f37128a425ad2e986c7ebb5395d99772c10af283640eb816f801b44bc27cf750fb245f6cd8fa712bb9e0cab65452c3fb70d67d196530d3666555c4d30ef9de2820c828055cb2189e35ce8aad5eaf3bcd6e3e26b89eba34f409842fb8c4e94b4aa3de8261b4e287888a7276af61345980f002fb71b64fc7e58da3fd0e3abc813e954f2bac3a0536ec6ab70fe02078b5699e050a7e15742ee2226be56e70e0d46c9b93212d95fe3cec0bfb0f4c8acb1c5894c498c4225a085e6ae232f8636ced1756f89210d689885239a69c38e1463cbd185d0a72719b1b1805435e186d313223a6463dce4f6185dcd1c646a5c3b96e411a477d13d2b07604d01d482800bc40cd39714548d89fc4b8d37045ea133285f9c30952a3e8fe8381fec3f79a21cd08e1e7130c5c5e987681feb88a41aa0c9dfaacf4ff8550e29bfec7c98bd457a406160ae3eeeb4262843119b3a80e4991baf257a5cf0636f2272de951acd2895036997e4d653c912d8149fd1127395434a838641977938438a09f4947366ccd7fcc3c449b7736cae9a0078fde456a9ddd9d720ee9b368ad27a5c17ccef18349da16c99cb192dccf16e73570f076873413216b8c53caec382d677fd6ff6b558ba4f75073c2f440eb691659490c6e92be558942238801ff7be3bfb08c2c28337f7cb0ac24aa3865a3a9a1a37940ae602611f4bd94a6b074f556b87bdf05f18ae66e7d4d1b93c50dff5d3354a6738460c2db198d1fac9c6518b111a8b0cc60f7d95fd090f067c155b604a7f40a7c21d2148b1054b4e1a6d304c8db56ab4240d5861b45b95a941baac5a6b29a458ddc6a22267ddd4c5a11a3bdfd94df196390a2048af2d7095c16f64d44fb7743c95c77029c99b8b7835b080bffd3d6be654a953801ea4535636b06abf57cbb5678bae53ee4f750dec4ccb1d0b5ac8d45f44390fd5380a3323d599aa98f09b97086b9b86385ca1a2423cf409e79aafd213e4fef88d53e735448bd1cb2c0c1b6d68de28f8b75f8d3c0d333423b2d3ad3d26c21ee35537fc8a3e6b64175a64571e5cb77fec932b663cf6e5ac97c2664a226ff45e1127f745b8da5737b2dd8d0a07cfafff3792e89a357bfb41d4536fbd6ba98f3c348c42d71e174d4b91f431580a9323cdfd5e21adb88ebbd3d32ef035a98d4bb9921625c4e4e7350f5c8a42852d6cacc438a58ecec23b87c64dc042161d609cd8d4398181cfde78f497f515387b52eeda5854ad7cf55bde23a85d388fbad3d0e491dd6001285430d50a0486d117a32fe38de613e0d2aab1245a7dd0b0b11fa757404251bacefc9ba84e14207d04f531751394f50838bfbcea1a4748ada6680a19c1d5a7f29d040b27cd343cd90366d530380319cb0a41e3b5c1ae8a13b0b01f4c237fb1f58ddf6ad00d291bb4107a5a1781ea0360605d5864bd221d19005c4e8ac5da453dfc1f5c58789b47d6d9f7971dd6c12ff650d17df2d24d5e9c0e74e02791067b57ae10b4389cf4922bdbc013c2e0586b0edfee62020223a0029b0bf9e165c40599351707e3ecab97a084e58ba84382f59d2afa4884e2948139d65949d687305ab217af7866d9636d2b7cb74da36bb1551fbdd277365313f94814bb9f33786bdf7f101c1edbbf1d43ba82db41ac953af59553e339bba92641c2da4c89ddc2c89f5c0151ca30e0a50ad591d981a113618bab405b5b2805d2327a7d19811193decc77cbeb515bc2b3485782674c8bd31a023221e7a96f1a0bbb3885679e2a7ecd9e368c74cb9f2bd04d9ff615886520cac326565f23b0a07fda83348ee8afefe2e4bbcb804b095528f96982357a64f67a0aed3d96662646f7e8d3a9759212a01ab2aa3a6e4e39ae8ebbebdd0019f6684fe3239e927973069ffe4d482512c07fb7e5e7b44f797f5968d8d7c676609bb5999ac19fd284df696a22d8cf98aedb18b6852f7a92234f98c3e771d48d32c7d73a69667e135e5c67c9c11fcfe615cec78fe101a3f959ddfb6f8311d9989e6e9ec35c60c7cb3eb80690c78b92dc6d504d330f60d28cf1caf9540f57e014d95bc73c973934b25338f21a14323d7de270a9db7c9f0c8f5f7e910af88547bdb4163a2ac970785af97c531e2fd2d7a262b816dbde9b7b5fd4a69f2597f1bf5ce4bc8afcc05636142fd0f795c2c2c97ce93121dd0079b0def467c3cff70223c2f6ed1daea86e7455eecfe14075eb1d4be5ce32dc4ddc156bc4263befb06cee11447cf8e140a4abfbee28e89dff0425bee8e8cf32b8462d899cdc0905e49b69e5721d9c1ea4f531c8fa97078e8d19aa5318e2882626ee8b5e7cbd07dab33779af24df50eb0f806c80a5722ccdda61b1aeba323b1c812ac20d45d90bded0ae0dfec46380c956369e4cb54f17ab59f2a15c4e5e4ccf7f53e206f1dedeb5bb11077ad23faef4a12858b62f07cc0bb28c39612cd999f027b4ccf10600074a7c21a658dc3b3f26d35c3d2785aa11bf047dd106c93bd971a9183575172952ce694435c6516f940008f52cc9ed784a45bd37837fced38ac921a58c1b898ad3a93b60d5774b16d242657ad0794344823642ea81ce5e1868d9f5b3ffc1b611d26fd98dae820b084edc8643b3d0657b7620c75c4e5cc1963587d191c306a7716b2ff8ee6ace6168b29a78c5d5a29ab761c673d9802609748d7539008fe3f144cd6018e2995c24df819cf0c196659013a902e1b60709727f6dacedcec542ae52fa813792818bae566b305b845ec6393485e8d022931eed21db235a773f7d7caf7488880ad93106d3ae6bc9d9fc21b62d4cf558e231e52bede195e10410c3155b272bf57a478c9b45554f2bfc6976333386fecf31585b48e3c7b79c34a9889ebd6f9a83b6fb69e506a52fdc7464d665573876f423c4a904046780c9da66b68b92d2b0069e3abaa2eca00adc48acf109cdbc15826f9adf75ec45c2cae06ccc5d02c988ff10d8b34dcad37ec87d2c9954ba571dec6b7f0d4aa6d7f4b9dd9211d7257520747a93a4346e5a5ce3478107c6ff1c5913dc05bc89eec6c45e1d98cf3f50a22969097d86ae54e1003eeb240195a019b09ce9833f1fe3afa436f31da1c435384726e196c61af230269d605b08f92fdd0bfbe902971ea38df054a4101eb4acd93f58cfb936b2bfa82daeff974f34b677fb62a91bc416ee6cf5ac25d40bde7037085c7fcb2c46ce93018b7a1b64dc640fcdc8b6fd5f5ebc506c530596e43e63e5959728b0b6bed5ba24214a91e44cb78bf1f48c9687ccc798f44307f06c116b735e66ea75694d434684ba6aa3c1e311e42370ac7a900e02ad572742e91515703c941f2935e07301bc47151d5f41d6f3a906eba59c5e1f55ad521ef392b69f1de8daeca5e12264283c3a74c55a877c060bfbbb320c08309d5892d822e30f04fbfe869b96b611976ac913ed4ccc71dab6b1a445966964000e402baab5985bbc36eb8172662aa543fa67657f92c7c00c592f69f9ce612b11cf0cb4ba3591bc6d750612ac985cd2030d62121f2a036f97b64e993516bc6d6701e67dc895f66ac6107b67055fc9b42dc432dfa4020e472451f4cfa022eed790dc26affc025fe5ad9475f90aedf9957c879562696d52cdca081d5928b053b2aec30ba66f7fb1566d80478fc0e05db427b1d3aab0ba93dcd9dab041b9d74b11d41720e5708f5ecab9c5b8c8a8aec92dad22d29a377614f1237e21a079608847df6a761b5424a35aa85ff06c2796d95d73314fd7b0a68fc8a172cf83b5bfd82f757f2336ef162f80b2259c514706c983eca41054df293fa8ffeb4049b347d22ee0a6084042955294367c220cd63a1d336521aa2cad5b806e92a3fd3e5ed7388fcdc19f541f7b0400207b9ae82d9af6bcacda43f185203046fbb0d73da83fcfa949766580dac51627b8ef4687dc3fa725e4834dba479d67cdda0f88e843066381b6177c697bb54bcb5877894f471c1eb013a2ba8c4afcf2313e5d74c1badd9291ba0eddd4ed31c1328c346105b7bc6334d836cce59a2ec0bea41e353559abe2515e8eeec016f7b02520d37c0c5879825430c3f02a5065123ba0907975e8597f7b01ab5d1f4c3b88e484e6ba4b4c4821dbc891153428199638451ee960155f27e8f8e9e4890ca1ffde592f954b55c4b6c6bc6be9d044e03896d53b3d54cb241c71e6457f2fd7a6a358e52b1d17df9e2313f4cac2ac6ce829bc53d8b957e37507dbb0c6905ba15e1084ef07c61dd7b5747459dfd0c5d17b4bb2f38fd121df8dacffcf6ab2acc86eba11fadc195f717e197763980dec6c660a6f64e80c9ee1076a00b1860ecc2002d5fb312b0add106628e5c4853cb3cf411f177c1e741d5099dbffd46789ca32aecdff648d1a7956d31ebbf8a5c8f6b08ea5d464235a3cee79a36d70527171c939da2c630b1727e34b24df9de06992fedcfac263c0ca7515dc76a52f3fdc30905d274011f780b2f44049c12aef146c2470dce88aa4d2015bb0eb0d4f0ae053f293e20207e3e89b41c330135dd35f6756d5db350529d5b46ea676eda337eb4b86c0322d960c50d5f0d5d2295142312ecb7135c8c25a94048e8a6cc06b4eb0380d049cbf23e9f75f37df2fe7cca6ec90f4ff57e46573b84f41099a6e972434cc8a9a516a3ce684b819d7926b298a802421f233aa4073be7580c3937e2d0f40c760025da30efd79fc9591a6790eea387f06c1f7524bbce49784794733643786f5ddc65b008396ee3e230fee752fb5031de9cbd409893e0c0a16c3de9cbc6dbb6b1c7a132c7683d7d4b0e5b25ee0e296363cc2a4faf71b88dbbe2d5e8f5e07ff0f38dce7fb88c34a885e04dd574b1d0e2fce90e7a2383b4b6cc37a318d532a9db5d562639414bd3b21df7943e9862d0322b66d42a99fcda505daa20a55b451e220b86f3a23f5317d96283d110bed568094e1297fda5973e9bbc0c6f9d27ce6c5c6bead8017402a6a9889f5d91a7109aafd27fc64bd48bfb34ffa2b53d15aefaeba255bd26220944a96eb83ceba79f3be6947c33e082a7d77f7474c27d7593ef21a3c7e2f3d6bb5532dd3bb7be213adc2f63d57571a464071942e8eb3107a46fb5a5cbffec46419e0185f818412d37ff930386fbacd6bdc52889e545724d9b8cdd09a01608bb8fcb92e736e46fed73c0bf9a5f1c1fd87f75854b6f45e03ed37945800d06fe5bfe96f79359ccadec6612b429abe774abf03fac413687d71240699537016a42c45cd443d183574719c0548241f8bfd3669fd411340f23751fab5a1ee71536de8bc056907c02dc9914007c6260f62f22a6fe77b5d163b8d481774ce76b69558343db6cb1b0e8fe734cc0b179c762439fd86735d30649fd4686098a4b6e0493db0f761b1dd3ca856137b897039276f9edf2f40990b1d573c6818869434cb3f7e53e4618ff8523547d76d9a950eef50f14d1204a1088ed629e999e3fdcc26af7e6e53ae078b83d76da483f8246fef3ea85183c9b442acc5cc17e93e3cf1d321d64cddb840aecd66acde12af5abd0176c5cadfa6087728800e6316fceabebc0a7dd780d97d057c58e8d3ea1334a38127d1edc205efb48360198cb17a6715523c643cb17e9e70d11f45372521b8642e5ff96a6629a3fdb44a5bf7ab262b47a7e0ed789e1ece4d3d8062ea94009b6b7c94a527bd610e6a010ddd48a5b4a6bbd11b5957f47bbf2349c4b7a7fc9fe8e319cbabe40765a1c84d8068c4a2366a28d8a5b311cc5d8640666bb4e529e08287394583bff57adeccc60dd4ab4eb814ba22549edcc2e02724904c44eaa7c77b3f166008d14129dbfa8d16b5155ef0ab0cdc9bfb125873b8241756294017fe056590d91f7b215c868213e515e363128d5d19693c7778dd83e95cf019cbec2017443526a9d4c423cc37b39603fef28ceeb3c49a5ffc72924d82e7faa098eb8754e163a768a0de563f2ef0579659bf9d7d465cf0fb8c5b68d59d93f358a403ea7bd2c7e2ba3d62872c79c8b41c9832e0fa3a92507c21d2c2957d0f14092562ef0b1ad502b9d273d694585a3fd92f9192574bc0e54ba2d5c998866b5a19442d585ed93b8b6ffeb4299f230470775a668ea25445ed6e5208fe78a89a5b80013e8f780da50e264b06fc5637e4ae584c639a71c42ef894bf7ed1600f3e493fdc9cd229450616edeebc89ffa6517fc06dfd3fb8783e0c8f922474d9959b89d7f02b55a42ebd98f62964e5e7905ca09e4b3c5a5db763c44364c7bb1b9d519243e70e4f49dda4fd2be375ce711121768369fbc6052a9229509d38ba34fe650888d04cc38553ac9e7b6d905c14f879700bc0c92db12c859489bc495cf4bc83b662c32bcc92925ec8b659a4cdbf51c6264b91a95c2025f599400d6815a3efc6f428e99b39ec4ac1718a29ba01f840689fb2fcbe9af46ca03a03e44f11e66c19040f1c0f955b60f7fc2ce2346bdeaac2c2e85033cb65dd8f9b1ba5cc80c2dcce4e22610a4b0c67c9de742841b539e01e799b10ad383be340c44f00fb94024afdfa038ea9d0f17bee6f415a2ecbf91b8cb1abeba72c1e7798a3ad8f45ca11f7806aab7e3a6e5d2552904b7d3eab802766067596cd13dc94253156c863a262b1645a943d3a44314cfbcddc5bf6f3191179fba4fbd2696260056ca2feb413e9806aadb90846eda334be16308eaf5cfde16477405c0c7bdc3f21ec5e6a5518c7e49286ba712bef13812e4bf475b9a2dbfe589b3ed5ec8fc9ec59d5a92d6e030a7aa59bbc16b2ec5996c3f89ce5c880d781a8a49229d86b42a6ae844a3b1a06c4572b7fcafd20fb3aa879470cfd3f08c9ebbbb71b097fdb8656ee07b4843d6178e974cd1c60ce8f7ea923173b77c689fe5bb9f8767429c2ef0ed4a5035a978d54133a268caeaef1f073fa664f840c514df3bd52776d1a26bc3a3a00f2f245d4ddcd23121f4de24b9e5c6660bc31403627df7d21df27d6a3861d2acb97e303361c59e201560fd2a2694a9ee4315280420be4ee07913511a3187919017ed27e473cfdfeda6dd446ee63814e46dbf0f01d249888ccfa51120348f562ca843595d11697d7da9351016206cd7a69ddc11a50391ff5582bc5f851c219aa80d483247bcecdc7cf4b6d440a1ba4821facc82252be22ae44951619e51e71a58cffae818f9efd34584118cd468d7697458dcacbbf05e4e02cec8fe487778c51819f3a706b96d3c668ddd24bd38fd129d4d9ad017f4d4313d1512390c4e860925","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
