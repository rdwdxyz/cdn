<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a31641aa6e8af9f1a66bf3651d948572beb0136d6a88bb56feba28d0c67ffd3a8bd49be495923cffe7d28c3c2a653f8a6218ec1ce315be91315187c1e9960bbaa0c2b15e59b1f2e5f3fe9f000a511d7a19274ed952f3bb5c68e4fb4d74f9560d5c6f8a86ea27845c15e6788be7ad510a9c0f3ec43dd912f440fe4ead0995b7876616c38805584132d8e49b93d65c1f7f3321b9d92bc28b7cea6cc24f157bebaee0004ac658c2e6a186da8d9d6f378233a2816d5a46136b84361cd1fdb1172fe060fa0f0dfd2c30c843a36e60690991249ca72955a19121a86fbb5cefafe036d90f4b9aacfe52b6d3ddd99a7b1ad0b236929c344746ecdccb983e47be2537e83f5a9d25b5a45dea276b4f34160a6ee6c5faf0f199cd8119d29864f22b375382e2fc8307fe52e42c1c0f8a532a048d969c338ffcca7c320fd59f6aa49433c31ed0e015a77b7dcc3256b575de39978628a4df484cfda72e42574df40e170644102668c2e5a557cea801d41576878b3add83882d8ab841722fca1dab0f6556a043d68c88b97a8e8bad36b519f08276d7aaa4b9daaff59921743398d6bcb3028ac41294e057b88c734abb0ffc20f115bc1d49f0f28fc1ea77e6dc4fcea01336067c1b7d7cd00325e7b8bae4b379485366e17e158633772e1803065c18d8bbe607b146e4bdf356f3f5a42c4d3012a3eb4605c3ab6e43024953acb933638c59ea003e030172be08ad832ca098074098fd940f27375a10f6eca1bdc20cb26fc2ffdb6725333aeaff8fe76239151a580d33883b637d789dda2e7f4150969bcc7fc015ee75457a3daafe50a7396f1d973d422554efe1b9893c5905d5257938ba590063e958e37c0018a9898ed0ec06718891ad26704c2b39151219833ae6d8a5b024866b693343e557eb6967ce7e9ec7213a0899c4d2e65ae1e9385fc9531e53d9fb50908ea94ef8ea3cc71708822f35f46d91354470b1eef249a637e0d53664a9c7bc8c1931545b5d2f9a9d2180099745c359886ecb202c3b4b592ea3c89dc4a0721382f857900ecb05d63f91a9dd593ec537fab4814a80da925ad507b308ca19e183bf0dfb3220fd49e54b2faa229780348738bfb31329874dabb544361d158466fd2ef11fb7cc196ec46725b8d8c2fef38f9922434f05164572ed07c77da7506b734830169ffef2653073e4bb8192c13951c4ebac54c6018e0ff371a5d989d60a7d6a2944cefa57ad61f6c1dcdf6f6929fdf995312ba960891e56fb0ba5b945a98afd2ac77a93d6ada5fd55deaf62d325dd960221c5708d0eba4ea248b4c7251620d812e96d1d5571272e79c98d3a7fa71128338672e105a778392b16df11a82d8ca8f2acbabfb406c85c1441e6b13638b31d0d9c42d94a67baa8a58194219998881f9aaf12d73b27ed928d29a4f7cbd17a079a0fa37c59c226737329a8ab544a006377b4b7d099459f73556f77a2985c1091c0a3626f84b5740b2b807b1f06b408f53e82c6c7e12d1873679c2bbf7bef5bf68a1d46f023422e9755a1e10ebbe5d9e2e69d963a3d4afc9749381383a7e6f5823e0593e5f7df9b84b8bc109e47d84d5ae68fdc693b5f45bec9ad791e055bd6117909a8db2bc53d44e0174a178a78f73a83cd0e3028de38e4cfc7ebe1d73904f3db80aa0a0d8e62baa73ea136a38407b45dd43ee799fa60ad9c9b0d6420593dbc575225ed7b7346847c479cf83c715e24ecd78553f8432b03727b0d5f489c77c58632568400341cd7ea88e548de4b617520094e1a490094bcadc5f2cbc43d7e1c43dfeabc074eb685a0e5dbd18f0dedbe92d028760f4426b21a994c669b2a3951f7639683563a7361bc55984e7f05f5312639db59fca7040c1198ed482a8ce7d7e86165a936bfefe4fb7f6b8593e9b85445462fc0b9c7b8674cafb2140909708b788b8a903dda9743da8f94b5f55678a292c5d7866c95edd79bdf85c0150b17083ece3182ed1e27b07684efaa255681d2d777f395f731cc9db0dc3c155b8871b565405d23be9453f39f370a00467b147427fffd9b84efb986bc2c46e8bfb430333277a4d26d12020cef3bdcb1e3bb31b830253ff0b7b26e78f64c65cbef4b8b0847afbb4335dac743a7be7be193050cdd526a72eb3809361f93b251627a90db9db1ac6f8f829b85551f0402781f50af1e32e9e52f53f8b1c186d93d361fe443e1ca396825b9d080a4286b0e4c115c045a2d032ad8f7b09f37cc4850846fe9739ebfee7a0af2b3297b2288a24ccd9e7edadea66cc840025b2b8b615740cea78681328f9412e05c631f423571d264861fd3442de2235ca8d512ff3b8ee2e10f9852ba10f263c006df06d0ee36b9879d61d686258b03503f48287a1a0ac19f6bcd5b73aaf7693e3e0fdb907a8648041b1a9879124a3186ad43267b3d6badf58145479b9d6d1cd776eb92efe71958ac79bb29a40dbfd39085353c819b95e2f6757ad1db2d08ea8be8e8f5d35e4973e99e5e07dbc60d344e213938e1061c1dde7b1c8c881e16ed201e9146b104f1bcbb99a60c8c1550ca33e2ab440a6f679e099563557b5a903c3b10e690303da4763d17e5add33dbab3a413ade85ca73389320c9ebe12aa3f7b281e46bf253a9183e7e26ddf0ed9203c4b65ae4a02046888bcd5bd44523d460654c2b27f47ec1cbad0a5e151de11be440728189cdcdd096ea47297f27bac5cdad200a0de977cdb925ab187aa25ec5baded4d3ffdc8faca4711c5371950a45ac181a0bf3e1ab394438202820b81ce6b4dd9f44f3453cc8acfb61250437292769b66f6e8798682cbd79e10e39aa02239ae352c1e8aba78add6b3f40a25b4626032fcfb2f0688b6fc8698a2f3c99109a22ebaf3f5ee81dbda3f5755e86697719a42905f32c457c334d8b7dfc1e78d197e50037cb36d4a0a458ae708572ee3197de586d0cc3227c611642cfa17d3b578c6a56f221409c3a1ed0dc4205874a05e995eb2172dc3eac536369a207cdef401414bd44315beae4bcc5ee9b5bbd16ee80a4c259b8de943027dd370ca26bb5d44a656a1b058cd6ac398fdb9a702f2d4bf94ac66be0472bb6c9109ff4bba171dfeb315a7f20e32e6fcb3f46d712d5773f1402113e1751c7cacc0bb3cdd2e4ea63149393ebd329a423310c3d1716c3b74f843c6bbb65f5b1729393139d4751bb3e8a4d56f44c93899ee8451297c4efec408115e5957e210f07ddb8fb88d32ff249cfc35859d3c263fa01f74b8c730035d9f2ac958e169be0ea45e8a736718d5ffd6246b3af9adb4c7eaefa15f7ba86f908f7f91783dd79653cfaec065620821494d5a41736bcc1f6cae47825440cdd3d050f21469a9eb0d5cfb574eef67f4c5c8298ba5f0ae78d956dfbd06ae4346bb36c98d926880ffda1d9d3b30f4ef8c32063da2e9ed90ccc115d9312981a7b71bd921baa0e0a0f7240909083cd81f391aea030975a133132a6f04eb54470e007229dda7d28b6ce6ed3decceae9f14a03bd96293ce62f3bc96e6acfa396cf5fcf3a593b70734f3d54c3d1af6fb3f5fa01cd2d3967278f39dae18cb6715f3b32549294f7248fa039e804703bcf549e1889acd420b68435f5374f8c8f006cd8625251eaaff57a7951ab589ecf104af2f73c4469eae461a63cf134f8d3e0983f1f4955f7000e5327f435988f5d698de39b174d55ebc33577aa925721e26d95883288e75f747508a326ff63efdf1d41fab5bb9aa1ed4b042216dc7b91ed4efe9f8ac41f5f166ce927e46e2b3fee2c95f0350f7ffe80c23764b6b28f0729b74494d350d6dc43922a6fd08954da204014f1d0677a465629050045301aec67949fad6dab5165b50599d5b8748cd24b64f924206f0bda0325b2ae6a4e87a44fc8b4911ac033aa09f96fb06b09b4e072c14414c88a4537ee253983ce3a223e95800e84b84b83de4dd0b57e29f4c174df4280140aaba8129f3a9c2d7246587e5c1e8e70bbd9956cfd5261e33baef8d3b8485c61fba480866b172241577196337b88a5ed2b079a15c3f6a0d2b433c10257e10d8fca052ce8b757845c5892ac3ef2ec6cd91c5d91e555178d8bafd45590a47e304306025b7d0b38761c7bbb8bc5a3130bb5600838af4b09b843409bfadbf052e0195a7fecce82e7ad9368eb060ee537bd5b7669794dda4b078c4194e53c6481a2171a3a15e145cfb58d94d38566d78fdf9b12336d8d20f4deb0c907b42da2abb01fc5eefe6a8cc6b9ae2feacc836510836ed25a35f775931ff1de5a776640a917cb2693caabea50bb77d97d399222a185cd7de2b7eacedde776a8fd70167acb9e40b2929853ce17cc3f13dc8b38f0f5f9d87291cd85341842dd61ea94f9a5a665ffb4e328adfd635ef382692f75e8ec98c8918a99e239ee55de2a680b4dac3583e5f33db1c2aef4f7d3d764709363fec829e3d37a8f22d4827774fa636740e80a730d9bc20d65a7fdb20406a1b81031be0d5962b28fe75c4bb9dde8c02c2cf0af263ffe1e89c56cbf87fe9cb378c924c252c17f591782fb30ab157e242bd2253c545444ca2b5be068ebbf1d3137dabf5bbf3a4277da86a8402223213bbd5a305106bca8f7f696177213594b046357266863e192be69ba76db9f8881062bf878060868a921ae892f288a4d79d8b6f1a35403645e7b58a0db4cb1c3995113d866dad559ecedbd4ac36764a5230d15052a1d30f579e807f6e698805b22166d82688ecd790341ecb45d6b86f9dc415dc3e62e1a6b8bbf5d9b6c3043941e7505c0d644907de617fbceaddfed0f5a5be057085fc153faa36273e71b178daeaf879a4959cc99313242e3c25fd64f3a5ba8333f1856397e815b702c5ec4896349481071fa59fda89e91aea2b15a4fa72b829f392fc4732a2a4d4b7a01c9fcb4dad2a4c6079875b8c0b16f16af3e9ce8be4ea3b92c5cf4cfb8ac302d97c44b8345d49a4c8d862f9a913ac60890c01e8eb7e3f5aab8247cdd98033b58971fa5abce2f7ea0b8212ec13c38ed16376c6fe4806492df5a53aa7b06dd4bc320220c0c5bfc820e4140ea00de3c48e32d85d05ef3b308219b1ec114cbb09ead45e89dfe01cb33fcda9c87326b4aa015af5aa1d1fb9161c7106c1e17c92af1dad18ef6eef7a8a7508bdc601e808502d79efd852aff3b0f44e8f1bc62152fb0021c5b69633c21c7aea3446fd8e48b26d1193a3f329e70b1c50f624a6896d5da545288a27b4f10a74c3f9019855d8f2dad5695ae90a19622b09266227439a0c9b24d3656e0df3cc45f2e4f0cb101532bc0ad9cbc91dc668e621a4eecc2233ab04f28bfc0220354ffe9c676a2246c99cb9baca37d24bb6d3c01917c73782d7fe32188656d2e32992dca6e6fda32d7a889cd3612b6b75695a0f676fcba4dece3d3115ca3a23f7d763e2d0595139462f9afde1f954ef1408c78969c03172cbd330658f6196226b09d5cc8d88ee3e945ee4257df3d63832b55c3658a0ba70837b1c09543ea8cd3d6f2d41bfda12e166e9305684795fe77c9746a10a8c3c75192bcf8f4672f1c9d54578e03ea97a49d12c7a2b66482933643257c56fd0e9eea4f24a2e8f1d1b5e25a71ea924e95010f5eaa47217c8b28e9c4216d39c279a4fc10226838f6a8c6cd0dc2662aa5ca3e7aff30ad67fc14e99dbfeefd23e22b856b26773e424f82ca13bfe074ea11d3ca5a8d3bee7344c74ca368670743bb353036145b608ba08dfab285f2d8d3b225bc87f5afa1f5bbcddee092388460ee29eb488924840c64adda84ad8b2f3ccf936740da22d8e85345940af81f5e3feff0bef178d998906bf33f63ff4bb3977f6c7bb540da09fe2f5304a13faa3b168fc790d043ba4dc17268bf41dd297a36cb105655148cedeea446365ee69886dacefebda2cffc575a997a0d4502c62643772cd6fd03d6e238e89a9cdf15e0138398c49ddbf501026c9863dc36c4c50309e88c0db7f64b85f0cecaeba2a56dd1c720e98bc167187ee187e5dcdbfc3deb4219e99be14a6f478128315779dd745a9bb993dd919781fd45b192c8635752dbc233ea10f797fa45c0921a7c12a8f23c3c25922daa078c2d712ee8f0ef2aaccbecb33dd3fbe7a28489f41bb0867b1a0e479e2107c9fb6c6ce0e282a0553b41d5993a2f688b702c2c54c68e59ee09d89251093c260cfbc2959d7a7b2cf498e71d4b4ea05d094878eeb30ba302b192827f423e76aaf3096f0d3980c3187c1edd60d22f344cc6a61f5ee9a9d2547e1eb52b847232a52f57b27f4d88c0d3d77a783533307e7578cb0b2d777a2749fb16a09f4fba5999e6037525a28356892ec48cfda15fe3ca0c7cb7222a235b2a7320f6469569b633801f3a2e51524f60ff7178166084eb0db249ac39a1c1eef57beb933ad651d41ba5bfa10d98e76895d806092285fb0b4cfb804bd83c06e1492a4b73b18d0b096af4b4b493196f6cdb448a57ab31c5184777be4fc95e48f3f3b763baf7e501265aba2e10c0f84c0e6ede490398635c584f37c0fefbec1d89f88cf727c99681790f27af52b2dfdf0a003ea594bdc529c4d79761117bbf32b0667e38766ed2d43e8f29c1cd55e157018d55f9402cc7028d0ac8621cef3852ba0d7f17012e68ad23d08e50f12667eff2f47a1906b3b4ed879e8499a5aa66a6c3e87bf9f1af8eb164a8c60a81819dc40e3c3375e7205076813a42003762c06e7aadaf777ed0bbaf8fa6c6d94bdd7f73eb59b0575eb6cb4f6f722896edb0ed8bef9efec7e6bb125c7dbbc7aa7413782c593365c40bd09c73998a760b3c040bc5d6dcc5ec6874ecbe856becdeb9addc889da1657304f13efac93ea2e356695d7fdc52a1e01d2c9628c9795540728e05245a04a5b1f7be62b05929203642d079f28f2e5245b02f0f6565cf06e0a621461e318a68e277f1017c56e3fc0aacf58c36f9600ff32e5889652c6fc567933a5712a355e2680093b12afe8c7372dea36b89c89373e7df37565b87ad9436b8e2a191abaa33c5a483669f1645f543f3762da90bcc98920ff896e713754499ef8e11fe2ea6dcbc4ed7734673a89e1df381e7b1f534aed8f1a3311bd326471da842c9e3888c4cd47b1f58ac87166d138ce8ad9a13417869e256b54493aefecf2b5c18f44b5da8498a2e879a5687c96afbbe8f3b6a67595bfc479b6790647f9952e527555c62d9c0efc874a70fd275d7ce4c5998561146b6e4513819dd93c3626f0d93e8e2e5a4f68a6c2e6558f6b88632656a9fa91a2fafe1f7c97b94fb77ae9c617d49bc3e298c2499f89883b4b61d077508a09757cddbaf9cf31094b16dc632ab8d00f2bcd671bc7566ed71c9222064d16f281c78a1d219d09742f17cb49f8dbae4142c45d2c1b205cd8218953744929d9ac9cce96d7177a8627a0c3c599e793e24f8476541af477d475795d5ccb2e4014ad965b76c3065ca34ff4e85e5534e2661ec8f7c8f11265b7b6e5c2362ae8f8bcd5945990545b510e7d8451d8cf22f67b5afad866ed612e9a6b991020b5c0de6a66443ab02f61e39d53abc118063dad62262b56e303c9867501509627c823f8753cfa99b93a9a14c3eab81811767074196d32f8426e4b4bcf0af023113bcbbd6533f57bd04f5ef50aebc1327cc704ff04ba8995f7a09d7a4c086d0a5c9658ff41e638603dc5d2a7b56c9df5884bed4e0a07a24fbd98c4c898964f82d49f4f0f95c5ce629788755ea0e8933434945475d3984b957607503ad438b42c28b365a0c3db7e99b9c1bd019a9fca76a6f63bec1d7ba59b885c993782d4b961fb9dc6d8343b5361d3b62f7bcdff4ee5f97d26c2b0a5ad06e9ae2348c38ea9606540b70e4d6d90f0ebf63a9200bf37e01ffc26baad544cdca8382ccc779a6f858e148d20262aeed2c9af4c0a0b04e5e212bd9081dd070353c30904d15433b02b26c6daf29d3c6e8fdf2b48dd721423ad39aea6da599f66ae61d116393df9fe880bf80feb4eba4034568b16be1d1b2d22581654d4547a127d7f586c982b0e476434345d4aee93c74bf804c0a09380bfa0e963cad5d97bc6c59149b4b346253128ad8de31b72c655a9339f78894e8093b99aff306144abbcfa5113940a18c246b1611f837c83af1a0b295b6dfeb96bae45f6656e24505c8667fb57b0b45baa7d58159cebd8d69244e79ef129fcf680952920e1938830a260fac608fefa2fd532fe8d2f6f9c2e41cadae0643a674419eda31b922ec0e705b26582951b8660cb51961780946b242862ca2815e6b892742f12668db57a7196bd19d4e4e1e55b54adbe8ee449a94156c1c97a28ee7b98b546f7f6352751f1795f854d3af94a09e981c6b8c35e44703410b5fe276a5ebe361362b0743f6e38744e16541dfc1f0f4bd04b7e3d6a8978639dbdf929e4184d76e7276d6a50f0fd329c6a615ed8022df528d5a3bd09711166ee2630c7504d848d6f810510022f1b8610f5e2123784b4e0c86a427b5ed6ea402cf61e133f263384fdde749453692c63163ded1c709efc3d930e3869c24f4146b3334bd0694351769a66a35b3fec22d6d698fdc9a02b76a799846d67100b0c7b7ea1b2f424dbfbf68706ddefe7c98a10cdc00a66c6f4e84388ed04accae3b13c8d80b29a3074a805e4f61e4ec0077822e41159e79b1de2f9fc38f8977b8bb489ae8c02f5e7d8d59d9e7b2e6d90f62a096af7a3dbc00a7fed6e5e19be22b8546cf5e2cc4347313a34025b79fa382c3e685db6b6592a32e8de597a7de1e6dba277b1c3ed963b4032807c82c0e4c9d092075fb94e591588681a7a666f7da49d0e5f246487fff5e58c6739c71074bd81133b7a769060dfa34ef82a449617e9e83d4cdce3a91a90ae29018208ce2360324513d5d8bf7429ab5581c4abdc87ae9d86af345b3cc0f2512e3c4d0bbfe73392e44e5ea0ab214bb4abee276da7c2ff3c3e66ce852d2d069cede1438600922f2cfb586b4948a0f41c3292cd95c465ab01bbb82ab40c080a4b444eb5da90ea7e42a2b6130e9adb112b2942b7c0f0115e5da08132d2dd572c48209bc4b0fbacf33bd5c95b6ed5d7d2189e4300cda5256bb6ec5eb8a15015e1dc8364e5107bf170320511c43e0758573d0cefba896aa9badaf5c46af14fd102f2f0cfa5eb18683dde87bfc031110df1b654c345e92acacccd0cedf9edb134204500ff14cb22aef42bf044607170d9f75211b0dfff8bbcce314ec579a450a74db40f048c8d4df85544d28b73698b15d600d3396fd20372301b38c46f5e9d0eccaf335da8c324954a621695054540247802c21708ab0bf6cc69e9f98bbaa65d5723e48625798ecf129a1f6c87761e427ac94f4438b6db57a148fac7d7573fac89d45b052be9e1753f43233f8d7ab397c58ffb83302378e4ed6f8b66607f2825bfda75a52e7986dcaa121ba50c0c74cd65d5a0603378ad9c66c8bbd128076fb42c555726fdedd15af6fdc3f8c5d68bf31c5141bd460b47e64511e9f562f12bfa8b9d0556518bdfebc23b488a350a460032467d8acd866256724d70c0da6470c55db410753114c6acff8677861544d78c87367e3ebaa14beae2aa9b5e0dc3738bf4b602da6f58e52b6f2d5a269dae7d73bcce9104e78181c2047a9da0d01ea360df6f722f7794e0f0b51fb0798efc71630a9e1da4ae5ec8133640a9faf1b2203c5dba44de01f4820e73864aaa29b59a964b45fd8ec293fec3d5a82a97f8b7404da247937caf374badbd26fdc542b6a37cc2c1c7579c349bbba202ff0599206467fffb65e76a1ffd7adf6fcfaf1071fe34a30ea007274b8d6723d3ddfda9b18eaeadbee77d47697ef61ade65c792513ec9f5a1cc42b363199aa2c197d07876cc2e2b60752230685ed8dfd408196d579b7afacf92be4edac3bf14906f7288fdc0a769fe9cc86990676e2e704bb82f6c28a06a8ef2be3527d0d67fd6d3a94ce1b43fd466b39288dc4b35b3e951ca10874382aab1588b85f10c31479c5b7da84782c6eb398c3c80bf384253386204cd55a87b0dbb76c75b3381ee0e62cc205fcd63dc015838b53b724c768b219f5361657b22858b1dc9b1231459d708c976c8282420389dabff63db433975f464822be997bf28a0b641315571f9a4e64007d6373cfeb9b2d3bc6858463e5106a803000c3315a4020dfc63389dceade39e42c90c84ad4c6c2c690414e6123d3ddbde9d9298edcb1b263f53862f58fab2ad45145469a8bff9856277fa311b3442a3b52aa347a98d24144fae61007ff5e706df5a0c02fc093e6123f1a19b36ce54d9e6e4efafdf24065354ce247c143a14642de0b67177d4cf6334d5b9df42828bef26a29ce9093aaf4938b0a99e45c8e95d85d6ec3f7e810714743768480108b7617e283844d6565c2cac20f2f7d4b026cfb00b0472379a71195193e8b65ec604c3ef9f81650ea884d36d06419f952658f7a4bd2ffb805df1cdc6c80bbf5b1f4aa211c7b4c013de398ecf83d226b72fb8bf8a080ff8ffcff3004b3094ce1c8bdac9dffbd45bfcebb0df27d2c9768751cc65734366e73cb426e0c5e307e357badda591779ec49718aa4778a0b643f5329320b5d183a1f557cbabbb7fa5c0ab956df1e805284bf83a750730c296a54dc0f97f4d18dbf38f591d706343afe73fb824f538a061c4b43e20991ac26ad29021cbfde4134b5a8b382ed5718e79d76f5040332bc85402c94706a18412c98607ab82e08684171b9600dcfda3149d878fb7e8291e7862f212d31e86ceb2bab7bf1ff6905e94d7ec0486addda003e46fe693dd320b6c5f19b2df7bf488c039cb69e14e4960a00bfb0efb46eac067a5a1bc8bc16b0be92f4ba1646cf058df218bdc401a2ed8d4264e262b178988c2126b97cdc838893f852570b95a8f23899133a23ad993eb76ca1759a56005abd18f71e1ede51f14057351774fcc3a1246f8b2dd9824b14cc43c178af8dfeb79b97e3f7f8f757b774dce7bc0d0f00ec7270ab71e441246899fcdd7575b99206c76facd2421db111e113e606c43db627953ff50c6be3b79fdde754e620a4fda5716796b276b2b761f51c473527725ee8d59291df7be298721ea52e475b2fc007957a22c92451418b54beb5a5ff5caa444e86fb3ffb9c43eb0ac3d5f2096ad1564ee1a6ed9a2169e7cb846d1f864b638d52fc755ee52ea5bf0c8a87e55d09333be5c89d5e52b7e1ca85d2e59a91bcc83a388f3fd1d369071ba210e7604a4a8bcd80e0ff89911d103aa3145b04f1d7734226cec7ea75136b3b4f9dc9cc881a9a722c160c1e8bc6fc7e1b46a5d58978ff82e450602881e9e5b3ad84b2a21fb13cb3377dd548c6c2bd927f56d6e3632d1a5d7c001a34742f07ce9127c20e0acfd42d79e2c43ecd7f5b081e91514df925627ec914afd3b56ec0e310b613bc2dcebf1a63b90033a6ad3e964041968198d77dde1b1eebb05514cc2c02644077565c8d5a5227daf15e91d986cc5da4ba4e2adc549b0b73569c81384d61f729cf725f25ea383aa0b793df10d6d82e7a723b82cb8e7ff515571963ea36b873df07713179b5b0cad959c1017e0b4d1a8c110195e714ab1d4054c0e4943f27a8ce351877bdb150fd1cfaa32d333c81b043c44edc4d42c76e43718fa336417cda61c93490c7f655bd48a3c736cc7d27838cc53ac5686cc360b912cfd613da38ed07d0470f8e15495e850e65d0c0db71ac80d67f9d77becc8f9c507f45012e0c1481ef700f813b9c4fd1fec6b658b99c8016ba1186298431996ff4d73ee5dd6b69d8ef8d3cda7c2d02df400cd4793510f4d4ac13292f117a4f55003880c6203aa0143a75f1e81536fbd6d88118c008d362294e62aa8f63b1020c6e755b0095dc90490d683b8e4c933c9db5d99bbe5c1c034e29a112a25fe9570c068d25500356c094f2208139224a30d55985b29511d4506dc770ffcf12d9ef14ca85d67db7ee59aabbcb238e5f29427b9b1c9b9d198a67ea5efa1ce06d04611f48607b2c28285e7de37699ddbcd39b542c3acffe9a2790bf457b80bfb4f70805abd02dba714be17a7ae6c94da4506b8a7c34625ff5f5cdb22166371d38f77e138fd948dc5de122ed63b10cf8491c765909e709166219cb2294aa34127d97e190782c3e5ccb37ab09cd4919c8a203947f072c6e83be31ebade395da9b2b4d66e046566690cfae00e0720dcdb9ee378d157d80ac5c386a0487d30f4911b9405749cd377d0ce0fb746cd02d5698bf91a623576106907c51ba5df9c42cdee3afbdab95f807e6844f3d8543860ecdef3c799402000a2de0120f24c8afd774af4f0e2f85cffcd1faaa35124158f5686bc305e20f5c67a4c57f925e54a628bbd4b16eceeb4f5a6554e4443138365a8bf3e0833485103b1712725dd538020fbe28bef9f028050e8fca124066f94ba302532e39b64e77a70e51f3a366676a8b4ecc0dd299c71dcab63f37292759710139b8a98302ccd7678e6ff40ebd5e65ea2f61338f2cb72f4c0e4315a976da9d250bd678f5ce790421ce94ecd223db3ea1da98ff39ffc8883de93c3a713ec67fdca00109ab708188b35a84572c3f176d1fd0de5e6a5dfd2661614224c8c48d215a6051b151e166103b4d986c90922880ef61eacb27c13755c3dbf06ac2ebc6b97ae10d177894b8ad8f3739e3287efb222281e2650580305c9ebe1988f4fce2c58f0e1fbae76604efd699e21385dce77a6a4cb19c434d325b61a124f838ca30e7b741c7682b7da99a4d54d62bab414fa6152cae63073ea181d782c3f99d8ce6720390ea0c3cdce69d15ff236dddf57b27d32013a15df7ee303c6f61cc7542786fde45522dcf2dab567bb58fa0aab83ac2dfbacadd380d469ad5fe459c703dbf108cbde61ac85cb5f392594b7fd6969325bab5e1fb8afe976898cbbacb0153937c52dcaff31d4fa4920fab6da0b1aebdb4df48ec56dbf8c8caabf204d0e51ab4ce9556e430a9eb116c8df8f63c78b9a604ed7fb81f56e127d9effb605c06c8aca99ba3a4adce003f7c5ea7e4dc24b69c545cb83a3cbc092aa88afbc568852e31adcfd36afbe2988946e9e746d5d3d50801f2203ce9d0583c151b696996ad5dc6657f503d1cdf61ad3da1a8efe46628557da79164a1607ab525facfb4f03dd0400a7104807a4f8d192d10d24c507bc72d116cc90ade568589008507524d5b8f46edc4714d147d95790e4323b576ddf391615d46eb197ab2f8c9ee2598fb8b9e32557e6dfdd8df6fcddb322b8380303a971d9d75f29ea08b75b0804eebd9d03b264aef58f5720633e869db8488e9ace9a3fa307f41a47e0690ef85c13b830bdd8fdf47ef2d83ee6c99ae57fd1f572206cc8c9a1913a18163d8d466a9bbee39d96ab05524a1d8f60140b572483047d4b7ead0e8e177c43abddfb5b9cc29adfc3e91f1aa3346e6f58a0da35d76c862e0ee31d5537bfde243e5649916fddfe2a8bdb96b2e1769414357ae6d1f0f6a6b66d5df13b416fbaa66e06157c3c785e2aa01c15b0a5cf72947902befdf7a1d663bbaeea03c069480847d0aad71d8a3848054874c48a9a17e08072faac26d1e414e4dbd835e50fdc82cbe0351df0234f4064662a3711be6827a4fad3e886508e4ac8f76eecd42cd0bd1376ce5973d954ef442590c987b6e051924d62856cbb25c76125fda1f77a2d40df08d2ea18b2d4cf2b205f323c52e124e97a46b2d46a0154ea100bf3e7c68d5f2faf3c9dd67fd8f70b33406f7df096e094558381073e89a5c1b3f6fa01c803a81677b3e8ddf131ccbbb6dc341c5de5ab03566b33357417ed865a44f691f70186c29cf88418ff7abb7bdef6a8c5489583d07fc313b56590bb5d9e2f2f089c75b438e44cca923d0ac76546b2793064604a5802d77ff61a048b0219b6903de0404ea49cbc8c55d9404313ca7bf591d3b20cbde4311814af0999ac8bdfe62f5d2ed875469f4dcbd861b345808fb0578e0d260c3d59db086353408fe5d730d4cc1dee5bee764978e38b2c562bf30a5b84e6b869b69b27ff062bbc51508c507852a6fbff741b6fbd996ca3166b00fe180ebfe82a521799071c046e7bfd20bcee2b7a259c799bd06fe1ff6a53592ef3661f99f18bbae0dc2ad85c3b661a7584bb5238d8c5d44c6c36a1a6ccf25d37917337adf08c29234a7faac3edd6dbdaf5f8b37abce867614cc41920a8af20215673cca99e6ac9f4f69a1984c6dafdbc7ed8fcb9839afcab0cf32675f60566466ae944da6787b6618d07efedbb953a04a4cad567af0f8236374bc0f2ff48bc52f53eb0b83748da34f6829d3f78bc9add4850508c1e5a2ec4ddb4811b94c5d19c2e126e9eb37951c3c2b7eb0e2eaa7f2008344661782618abf33300983a6531c0e2011cad06aa61772d622e75b0fff514434bc4426a7ecf67d099489dfd6154febbe1c6e2db125c7114119f076cd7515336f961d3039c6da81b7dd6b7a17526136d77247459f80b14b3b93c7510e8e622a63511f000f5118c56aeb20c198a8b7060fcea840cf138c4ff3265bc720814d4b2c9fe45de536d30e092c8be5b9fe814459d4e1b3280d2eb81cab218c1ee8270d83806d033ee17b251914e4123e247d028c28b91fe613f997cca1fe2236e4306e1b530a6ca600732307e05240fe6057022306a8623e51d811b6a6278a2e7db5da6f91a305cc3ed32f2a1e0bb88d7a9a97148e0a54beb0d62e77632692ffa20fea770304390c4c8479e52d36a62f5ea5f7631049316cb51d00d65c3ab5cfb420ed584da4ea56bb8f8ae1a4e8e199e3870da92e822d11edecd1693ecc988c0db00eceed04dc3c76c46b60b12a627cff2bf716b713017611e7a9af146263976fa36b701becbfcd5488526cb1129dd1551a0614e2d19b435a0d992ae2047da2d312ff9f86a585b689757d10243b1d1e8888d8b5011dd82e62b2fd093a55a1747efe47a9428e8df11005ec04563772731161093bfa8201f0715934371e5a4d6d7f1fe32f36dfac82ed965470f62e3f47211bbb933fbb809bd38d42906c2de2eef7991b10595f05089a5d309472f49002be381bf5528aa4f1d670295b14280cd8609048f4027e4f5e39b40a75abc9fc00c1c986d17611a2a87500f0d579e35f6b992aa2a751ee822aec02efd9ca4311987e4c4874e0469f8b669cfa6ba178063e03bb02a6d40fda951664c444f3fec8807f159f8f1e7d04dbef6756","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
