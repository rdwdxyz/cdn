<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12a2a1501db7386add40593bbe061503d69b7b398ba17821f684cc571bd4ff8ce2bc026de05513a3a03207548c965f7c6f2deff73bacfb7752d01cf9f4ec9117ebd3e176fc0b02d8d2e63f6b88c1fea7b7090ed319cae38c3cf5026ac5234b3e0b77318baefb4c3223b952253ae50d292f5049042a6eb28dbdba0f7eef1bb30c43482ad95be8e600d5b51c0a8180a288025c9044dc9fce201662421420499ca0a3c5a838d1bbbe8040ade221e9a18129a0766c5c74bec146e48c6096eca35e36c02955c53c2b62d56705af294bd53ef6215835733fc4b2a07813c8ce1f279dae74c33d80b5fc7dc4fc50d593377c916bfe46631bf6c86060a0a1cb2c917257f4f8d9428077cb39f1382871dffe610808130e0e7ea7b9c3e9c7355861a5f31d50761c021c5063deefc88f01bd32c4c43015d8c8f70c45cd162ed7d5a1c4cd9584ce8118e46f6fb4b223767637b77486ec8ae68de9477de5a8af739106adca88c1ecb8ca531d6611e8196abb50c7a0dabb72f0ccfe870b150a9bd6478ba7e9a115ae8b8115e4c5c6f62ba4f01e74b40198391184e15881570ba5b5aa1d6f66dfb1e7487c842bd1dd0ed1a1101cf3c74619b09b4ba83a17966312a4bacdca48e0c1b93ebe06c0e14130e47b884dc8b541e8b836c665c990150eed4f211f8c30bf03880677e027e22b83a6375738e761316834222892c16e07e116a8aea6325e73129701744d3edf99afc8d343ad84664e9f6efb9ab36d85f87d4ab1dd188ff01b8ac47722142a47af46b90f5bf7220d60cb63dc795d1ee559da27703a327e05d9486ebb16657d4376be9ea237f3c0229558f4e55991ae36c2efc2cd124f2da08a652b0a79ab2379df01f798ac03feef3e099a3be77f756d9e8a14f8c963005bfa537d47d13c29fdd871461912023c95b64e3c4f0a4e13af0bb2933fa28254644f270684165599d8ac849776902f23e1e29f9f29d855abd55f969a0158c249bafab5b42f072f059ef18abb2d09216c6f3ef845d609e9fe11c3e66358d9561991b8e93318d8f013f33e6821ef985ad7f176c4c2bb8393a4fbec92272f404f9fd8808700643fc5fb11f266e96b83dfebc8481f48178330db2dd39b59d001e51b17d9ab04e13c6f8651d824bebfd990a776c84d409958e088e55938336a41286d3ff20314fa43cb84efec7a7b0ea28bc76cdc1642eec52efdf6bcee031916f3c6465289d97f7118b2ad6c4777c4ff9b803df55dceacaacfc05dcc732d2f8d42e05aaf2c2e9a4ac8e026889e22a905b046a41f11a6f76a1d5584afb492f2d13661a5aa65d5f5d36a8f1a4fcb8473f384f00bf4cd69cafa045e0a549bfc255e50a1ca4c9de0baf4df024ce6592dc2cf90c4e1b63e7152795a4581b542b8327b8e8e15ae2ba97929fdf11732756579524f2ced616bde4bbff76127374bff98c22f20466b0167443da8624be110314c2fc60e4500d03a70c79f6abd45521dd81abd29372e8e95572ae36020effead5465bc1667b4d90c88992caef2e8e99ed36241239a1dfeac74dbfc5fb212b0894ee8ba0699b7530813e62ca094107e84c5f3af8e5bd8a4dbe45f2ec93f6afd07e570b9a32f9a767424dd9efde97fb2c3a4c19a8005f1126631be2f0bd4d7473d63dfb00054d14879b256945b0cf0c1ee39cdc7bd86aa227105c571c40f7dbdd67ae955bca30399337742df446708aed013f82f5623f063c2294303e48d4a31ff678ad6608a6d015bc91b81536bf37a484535623d631bf320583a77f3e7976ed3629b19c59fc20c9e268949a1d328a2540c5be1c22920589b20da263a6f12121cd34ead97c5e2718456e64f260e218d61b4547627c48bf9f2f33e65c779dd39c9a813e4f96f3c7ddb506f715cd3b25ab5c8385380f30c3ea4ff27ddeb96de136afb9068d5d9acde81602ccdc25ebafe772931a1d9eb27a5e45e51f2574a8b241fd0ba34d3415b63e413362bc2023b4ea0078bc38bbf7d7ac62af8d9ce6d7e330865e843f089eb53aea0e531ce95a49b9c6d5399af8353ecbc9f2778b597d190e449ec556174aee68fd15a271e7926f6402708d74cd93d94933e1412707876e5a7ca287f25c8dc7e22131d2ed7d4d085415ea8dc2a00dd1b482ef1fd3729063e1c6fb28236952966f1e24540bed098d382b35bda4672076655df83a75654d6ddbdcb4fd5b72d3abf9881c1fa5f1ba07decf74252dc506e7dcce93d1d9c0cb6fcc2c77469ee9fbb7d98011ce00a1c379f04e29b35a04f4a79f246b797fc0bd5ae7a6adecc30dad194b55fcc916bc8bbbcbf9e82fc8a3755c7110657e37c359600d5ac449847e4afece0c95448f27582788d1e6297b67da40df26d14841e1ce43348764ef1eebef3793de753e128cdc1363709c55bb8010c5eb449a196f89e69fda240977dc9b3aecfd505cbcf6b21a5d512c17c10b44850e0b227a91cd58030bd5b9e1cff03b3074464864166b89d99b83e1c3af9724f77af2b77e1d97b548041d6216cfbb9ce46113e3ee5545a32268802818f46d61762cdbaaa807c49e4379b0a33fb417b5ce915f4b8a8ede03cafb0388df1d0f1a04d07d2973b8e99b6eab545488b35cf069fd928bbd506b65da0a47ee5154e550fec4190e62132f88aa958262d1f71381dc01f4a5bff75fdbf4a4a6addd78430515d0e992c50f12532edeb0f7395ae078873354be933a85cf6e6f1ab9a4b5c5fa61fda4557fd080fe0af3974a5f90f5294b75d218ae5dbcc9b4be37ebbed3dc8eab1d9d181925aeb46f4961e0b13f568cf24ec7cdaed1ebe547f9b3524f81b9af080808d13404d8d6bba974c73ea9e2205021570f0b7fad74856cbbf9e2cc8073476491f96d831ad138d0e949e833ecc56ec0caecaa6e822ac93deb785d5e46c957fdbf348ea01d43b19971a49e29a2dd803e964801a46a7231691d8cb799a673d1d03c755880b707c03531bd3334205e4e75625acf409a87bc36908b1990a0472345d5d360c71a2fd87701489792b431057b84383be6b22b3d179c45ab783ee10c745969e0ff99c6259fee2fc576df6e2c4bb58d79d2f20478cff16bc7d7115b9954b6376f08c8eecba1a6aa2c0721268fe21613fcffcc004025df8978d978dcbc6ab67104acda754f8033f7ed0d8c0fa48d919d46de3b3ca5ad9377b809f0506e68334f7a5d4689fe4777625c62810872ea6aaf19aadc524b4b4b421cb8ecc35e94547bf1db3c24e637e192252d1b5dde7563ac7d2b8cd2273d7f30d7210901726b6e883bb3266caec235ac6cc75d6dab19af17e52d7467c365fe01eedbd4ebd4d1535e83bc50579d4b828892711c7868587559439e65dca835027071fdb25eb928cf97a9da8197965610ba182c7f401eb896485ff1460e911a30f72bc326755d6cc2f52f5c16fd570ee3b8e91bef9c3ef98458e83e73c6f2aee11b27f6f0ac6adc8392e614b10fd04a4d5dccc23a8aafa03052c072e101a7cf0c63a57da083a9295afc85a38496ac6fff382a62d2d991abd58261c78249913ddfe1fd46a63852dff2c9b56e032049bb6752d856fb8d45f9d3d8f4900663adc9d13af7368ca786da19ba4e5e14750bdff57bede79d6eee0c348c36682059567b081530285eff594b05f11ec415c76313a1950ce3b1f89cf599fa3d48865be59e1c23564da23c5ca8889b5905112805dbc56ce5131dcc620abb2e5b2e459157a4703099fa3cd0429d0000fd8730c2a2114d2c83105214a9028b39f7f67c98c4fde13e378104059210b58d67127a9f4ec07b35eb5ee7c2efd3257f81f1cada719b8066205dc57f527a9c0dda09933eaa3295e8e9ce8b57a4357d0fdb69d47af0c3b36a0a3e3056056639965a4b007c9e5a5049884e568cd86b51b6a694c61c7a7e5f30479768a4a67756dd76b091478119d31e31b9d7efd400a300d966642bfd67c77020d36e346896c253892ac500eeaf1d83a1f64db106167914a66fc7b1fdab902ebeeb4a0c7fe061f2da684a317d2ae8782e52a09f52173de9a649340316ccc54d8a8805ce4659d523cabddc98627bbbbd7790a02dbb488195830ba79ad36549aef5a20555220435c1642f014fbe0c207ff80991dfd890b88905fd1e340f880e0953353aeb88ce17758aededa9b81d8240c58040bd231ec93da1186d5b0551a11f3fee45ae06466e6bc2cd66bced0b590bc0e8049fbc08bc06c2489480b9f7ad882e829d8df29146562de1b38da54d1e12ca59b7542f3fc46f2b95d5f401b4c08804898a80a02addc4ca8fae63d171b44d5091f3e62cf80a8e9605d8c7c24fbd76f08c875c89d89ceea50233b9f8ceb557fe6e42427324243ec12763b1959aa1f9294275579a70ca04cfa6ae794eeb50e2629f86c71fe603874ffad221c2fd6ae2066d56b32cea885339c7686eef5bf6da29e78cb00ac2166b9d02697b7a49ac2eb67f5168d8a1f53a7ce39e85b736e728644e92bbc0a227bf344d2784b6e4d48459e1cd16389486838818bea30384de71e19dc20abe7ea8f21b033e8e849e58f222957f47e386b961628f99a9f90a673f2f1649337ee4d15374c27b95434a6942d17fba9acc292b84ef72aa04f5451252a502df26760e581df75b47c491e9193bbd5843add5c6513c4015471199d3ef0ab3d8930e6fe7e915f7c5726cb85b85eb20b0a9a37575c5efe27c5f8c026b684254756f5b5566fab3174abc2f9270bf574f455fd1b8dd6302050de24f49f0b4a215f99d12cd47bdc25cdd184808010b9d5785a16c7f3a1311541d768f5f636881dbe0b53324739071e4138b174995b8d8da3a45b9bda3080069bfee2b56498c339881061e4f22c0aeafd7fab323cd3defaa5855aa871fa6bb4e35a807844fb1c28ed3673f16b4c672e6e2f0e2e621d06bdcbbc901a2128eab8e3115e23976b5694deb030f5849623293fea079d0949dc92c045ef7a25a78c26bef00e5ef0bd49ef2472cf57261e1a014fd102ed6ec82e215880000417730c1182197088b758850815a6470a04aa2dc63468ef61d0b7b5718e9b94a43a0d5017e908a0f089988fbf1c5b2a6016b135dfee689d87474311b1497ffae1e8051f323b06ffc02d1b286f3eb4fb4b14b50619c75dd5012bc0d39c223c593458985c1fa61ec9c585bab28e0160ad21484e095954859c269639d037b12398070da42ef0acbe440f2182c59e0f6f43d79ddbbe04dd1d10fb83b9c5bb295baf058f891bc5480be80a4c6d8a0c640a1903d8eb0508c1f7ca90b247c6199b3a452ae7be8f9c5085f6ab975129dfac3d9d99d9bac4d90078020dc337616ddf9d9d042ee9c71527d1d3ba618bf58578796c83db4af1e6cbef244287ae3c7ba6994ffae403b77342b8e14e3469bff4c611c46d4faf7b89fe08d32a002c7d47b9ee6dfb357a81731ed993ab8cf7a4690bc68b07dc64d3f8bbf580253113cc1c0b62b9a195a91016324fb1e54362b542e41b3905457ac97d5f9ec5207be2a1923e4de59dd43be761dc6511033ea9c1b1ba1193deb8d2fd24077d83e59777d3c0932463bf1fa6820dc937104e336744f23bbacd42564ab4f068114f853c44ebb0c6a4ff2f725dde9d1ab5a653614c6edca7bd3aef8c240d805732e903e058cc3b94df070a66a225ef6e8a73d557a803dae813df5f0fcdb58d3c90e2f11c3d41ee768c2ab707cc28d9b2358e061adc4b366adadf14eff360f2d1184020726b19b67b6248b520ff299fce4846f6986899fbe20068086ef82b707b38c70873c0b4d164294c5b2527320ce15d133fffa8f9948f988b8c5fb6a80970272f0918f6f0687c6997849bb7f6b4b8a2939e0f5c679fac15d17225cfd30a14a564c3794151435a93dd96092ecbf358660375a266b63eb14eebd402a228e5e792d8209f1b2a71820237a3be489e5a56eb7ddbf0ba85139f98f551a870fc98b8ff583162e0e21149ce9cb42dab68dd6263d3b56fcb2db17d86698c5aae208cd0bf099ef2ccc691676cec248d4250af3331b2fe43b19b51a67bb644464f74c18fccef8045f6409d4d58f57b690e20af3d46cbb358316605115f5b947030c8150173566c38856ede5d19fcb950ea5174e99f4780bc62da8a0f6c45ff6c49d028e05145953189ce90262210cf799fa8c085907dca09e8864d57a67ae33ea24ce3b344d58ce1fca4b5832e3e852afeaf375c1e02622687af811efece37b9373c1747306e0c675f3b63c0f0aae720ca19ffd33fc35cc749be16d377f3d9862ed45c475128870cbe5ad156427b4dbf4689705eb4e57fe1f9fba4498ec24b722a9a9580498626f02cd6c36aacb18fe80417298a46e454779df8656c2e992d01f51640d53492f63a54974c4862ac347c935c46181162183a4c1d27767b1958d35f5993ecced34551685abbf001b315bddffb2cb270f5f3131fc6fbec646ecf904d58f052a579256cada4f1401a3d555f55d95f4049e718935e95ce84876fc71dfc7c258a3b520e0e1225817594b2de2c1284107ac8452dacaedebaa58ea47ae0cd19015c2e97962443a422de8990ecd6252cd652a0d417aecf64be5180977ea9c4a5c6f219b5cabe1052befd9947037e1f71b2a29570b4199a04d65d924354e0a7d417a143f21ff9613ad8a248a8099170d60dd4b4f94fd1afca908a02dfcdabf242783c95f8371a158320d6bd6b906d536d4c85297615c22f4e3324f75f71315358380027dcb53c63c783e9d0e4288ffa6b8d8e5c6a22a9d447ccd9db3f1fb385635a57d7facadb360508e0da672b1a24cf58f8c35eb6a1284d0306a1dddcdb0fbc46a72bc301a4d5afd524e6fbf507ca0e7b5ca1921cf7b54966f607c52afdfd9b33f6e936a3c675f80918277d429588d4c0a78de283805c2a70bc60cce2f08170841258d993d0f96b0e2406eb36134fb4723fa3435181bb32a920d196815dc71e82ad171e7163a4f14855d61d8d9deebc1b26090423c1542554ef0489e5563db176ba2de550c26b6515454998852ecaa7bec04cec4be5d307010c943fde32099a1987b6e09fc18a7b441ec821f50821a5b8cd40b61b3bf84e1d27f5a7b1161cb5ad9b71469df0a72e368d5057bc8fde74b4d4e7dea258ece0c3ced3faa63a8e0564fc6189c50dc62c7af69b746b28256ae0644564a9c158d80727af7e29f80a85b13dc4f19debab752dcb74b71a5f2dd0e9727b0108a6db59fddd2c7f45380aab59a1dc7a2e02bb81395d5e952e8a1713f547cc10929f25640eb59dc0fb4d02fa8e878b251f80760bf72014152def79b4cedec530c76a89eb9da70c3e63c77ed45cf916af2834da401681136c76de558d30a8262b22919b97ab22ec60a67898754f12bf2a6be3b817074be68318b99e926aa5a095290c6d24534c9efadabea962a4af21327b43e61e401d48ba1df1588c613b07cced65dde46579ff90946bf0f067278966096ff38919b6b28d378efe9a880b0526eb5e7ee16e5a513b6cf5c222b8ea6d3be6bdebd694480b32e2a44c5de21e8a6905f02d17f9e86e9398ee44a0f1557a39397e8b9981eaf22ae9f8630004f3e9443cc8aed62bed823b1b1fcf363847a96162bc193441ba961602d828123abde563b812f70643be9c2e683b2fd6d6fa5b536990767a90e433bc3deee5773a5c6f01e05f2bb88661cc2ed946e75f0a7ca0988b36c2d00c46548fe68d830ad3753ab278872d5a6a504f880603947a2f41abd5385d12f95b2d1b7bc6ef544b9033c179dd9c15c3ea94439ce600070292b34450df758f14489a37ba3c129fe0fcacff2e32e872c10bc2538db3be04a044265a7e5f666772c943ceef47e77bc14bfd95470c59c259c38d2be7bcff2792b0fffa41937ba1d04715f3520559b40223ee4286817072ddd649ec59b53581d39dc221f21ad7c32adc6d0ad0a30e7d5049acbc86efd2a59d1d0262f4730aef59f97b1caabe8811d057fb296a83089fddb2b28591d0603d56af3b08b051f3681c720dd0dda6b172ee1054224879d5ce3faac1cedc9c984bcc425f4e86ac3e19c052ebbb271dc7ad64973782422dbf962a3aea49e86847cfc4549ec73d839c8b40c1a5bfd063d636b4699ccf5bdcd9cdec2497e8bf6e5f232a45c47dc5a4df90ec78e52668b4ab29957e6f96c2daf96abf92dda0a037be58609924e221bf460cf1607957cbf4fbc5149edd45a97c07e528233a352316f581d24eb496cecafc887c308986655e26dadd3be4ec1b23b240284b3580e36dc7fbde27c19749a9a6e3a1af4e40717445f33dc018dcd664ec98d952aeea7f965a144ba6bd50278c73e034c41c0bbcb15e64c4c00ef5584bcfaf612b0816d9d395c6b2dcb06fdd6b33280df060e3ff02302358acb1eb5d30cc9948467a0ebe1b2c9d90c737b49a94c3ad2a66dd702bac8d7c4d7ed868113840034566edebe1591d1671f9bc966e402e7cb0b94dde0717197debc73b885613ca8686ce3c7fd0514a8bbb6385f13bce72da6a6d5fd18741e71626589ae8e8683cc5604517621fde431d142aed93d84d35300e6039959a305a109df7bfbf79660c168da4a8f9e25b78fc7b4a15cea256cb595c91d8b7bca04079d710b21a3889be045fe22c50108db4b04c7c6b36a1ffb83eed472dd6ed60568cb824a202e68aa18b1d41376d51f87dc443c6d4c364ee71f02ca0592649e6e29725c61fcd0cf2da803f2a45052cbbd4f8bcf5c2193cd1e2a4052b5b767c58f685cb80752a9804fec0adaea0ca9c5963a627cf4130ebd25c32ec4dcdd740a9a9c5efdcbb1e38212738242ae8ecfabfd0e484d3dd3990ad566817d1124aa87d3b693a6cd7733e13e556ac45bb56a9e744f119eef269cc826d6344ad6e7a7e450d237d51a54be75a3332e94bb23d6a95cde367f2bc5734964800e1abd6d27451746f6913b183181b33c1feeadc0860c3e267180d79add7e08b45bbe26706e9f8acf53e2822e22a90650e8b5120c43a7a364eb02e433757491ff8192e14b168df3236e18beb0a6b124556ac9b3f6544e24e2d9d7eb0f8e6127a438c43cd94f8fcccfd0d1491f89f601e5349308544813b44caa4fbf43a16ac6992baaf55e35ed31f36232a5525a524331539ce0e1173ca946a9fa2240bc1fd24efccfe8a7546f394d2d81c8ea8fe71ae794fce0331026205edec27a00c8f31ac83406f5facc8626e9df9d8ffd7dc78c3b1155779520930631aa24c80de0f1d1e73cbcc9c3cd9b1c0cc88b7b6d7290d9630be5b96830b74f98b61d9bed510ef5c0e601937fe1856170dfaa6a7f2d79448c9b11468ffa56b5896fbbcad887f03907981070c1d5054ca2a7b78e2faadbbd12e5430dbf2ef1e657312f920cba68d0effb108a6286887cad4de97b1d25c816209bf78753d8dd00e04c72b00f24f63693ffc318dcdd596a2bafd210fbe304370f8a737b00b54fdb2a545cfb73c9fd1eb1e0f58b3dfb7816141bdc3b87fc41e6da3ad76d6d25d372abb2b62604ef977329da339c8f08995a0f92b26042a26f70156d690e97a26118572ea7b07998bbd05574fcb57dc80f2d93a8c26972fe42f9507a81d5cb39e6d495e0451cdf4935f1523ffad5afbe1ee9686a8c000f45a855d89cffa3d20125ea09bc75ce73b4ed50f908967226ce9af021e0098da7fd543cea0e394659cc60355c8f8904b47432258914511c86baa40b113a654ad75d280c1731bdd32f955ff8e82bea258dd41643f5be401553b18aeb5c59a7e4db1c2d13c522479dcfd08c1d3714fefc52b663a2424460ec4745107c91e15b6d3c68f4a4d576be1da59e49ec7c2f8f9031122e8ca4775818eec464e6f0dc13b347b82661a85419622ce2f997d35b4d29dcaab3a7181689f650ae66386a88aa6ee4019a76f2016175c133276a96142664640dad4cfa9f5e3b645e6f7636ca883922f31d989ce49583211df8d0c7dd6e5b3b3f0d634f4e13be322459d89143331d4f8c3230d45465e955fc155051ed326527fd647c5d283ee6d592e06901ab8c1229827e7c010085f8ea64a8fd11bf140252358365e7b54e767e505249bb4b75877035815be5d31fab7ca8f6ceac925dc57aefc5f4ec4eaef08212f76ffd3230cb76879deb7eaa5c959a645cd176b10903c1f3f93fe18fa97208fe912d07ce9b92e58c0245ddb53e2ea675f6eaa6ec1fa39d03f3cebfd487a2af6292091b061d273c4c6f9fd7ad2e149a08b75bfadf7c787ec81790c6d6aac4d4cad7fc8899dc6fcb39a8de87d18230071772dd2a04a3472129f7a80f0fceb59fb2d17bf29a3d44481975c75d1c8f6280a84eafcc7b579a018802f929874c7a2242ae80bc5b88de55739b50ccd3833467f422c44456b343e788afee710b58e2178776b7ed054c402e25d0c75dc05114bb8fa54c42fd2dba375569a15255f9232a7468cb0e696766ead152aa0ac7d182664eb4e9f1b7a0d5e8326063622dac5f8916257765a58aafd3fc2e5bfa7efe394fe23ffbdcf5aef64cfa3383273282b429bbe01412e11809a7531df54fafd5a9ba986c6bea50b370dd199d24ab68ee9e8c32703c517fb2820b506183059190f6ec9eaabd4cae27438ce923974149e3867ff06c241fb8021d63e3bd3f2802908fc6848f44780d8974df19a24722fe1f9cb9f594f3d13c15e338e23c8a9e9c9b009de8b0488eefcf2bc3b1863315b5b761c38d1acb0654932ab37876960085b7bddd769a48173beb56b692867d18ed3efadb2377f4ba1ce6d9108b85e563968921c7b6953086302c504f5f0d547b706daa0d2a3b520b33cfab7e02ddb6c6215cd70ae120fa96bfe8965cc2ac4368f0996e5fc16f97c72c41d6b89c7686fe4fd5d5e6bb73e5887884ca20c7ffb63d2c15e5b7543e30e6dd3b5ca0d9d1b06edb75d40b9fe5beedcc343fa78e82e5d718de5bd533eb6392411f975a9b6f945aed0c3a84ddeef831c2322f4ab944fc864587b3f15ed91ce1f95ba095dd9e9aa53ef25d7acc1ad7612b8a82d4138a37de33fe379573f4561633d1a9070917d5bb7edc572827eb55256fdfef5e427e5fab45acb3e3e411c7ecbed67f231ae59c8cf70789377ad911db29b0975e9856fd4210858eb15513e28e688844854440f3c480821e0671a59b8ac32ab183c401f04c1ec4a37c7a3ac191e4859c9fa510b565124fc28e6765de070ddeae1d15bfd62dffda1db90f68efd6e3a81c34ddecfbee7d49ca179226ad2bc6995ff53853e0773d48a0281ee2a405165a5c450d3db7989d02aa3e30e78def0a3ed0909a68f48f037ad33a25644c06365a80bd302adc5e23b660ccafb5d914af0e7dc18cbec7985b514bc060f12e753ccdad2ef56073799759cb5be658e86dac93321c8208c350cabc60b84916a3ad764817dbbba61941ab0eeafe0ffbeaa57489035c88d4c0ec497373f6dd8427e26892c8412b83da2f546a97095559c82272afd1e36da453b7919e620da1519b2cec1a7296287889ed342ccd0717999cd1c6f1f5d9d38b55234c2317394f8525f62430031d221808e5847e290b9721770821411672762b769dbef5c35db48528a961a8358ea27c53b6280d25aeb1045bef3cb31bb46b1df62b48bb6161f12973c38caab6851efb6def1c0ef2b913915b7ffcf757dea63b51e1a8c54e3c35ffa6abcbfa55b896f2fe535fec10c2f21bbd14d2b0ad70750cb808862087637a1e9abbf618c00ab7cbbbeca2863c7c8128510e177903d13bb612011ce2a7fde118dbec9abe5a197468ea5a05945eeb5f32cb13f335bde0d444dee5a8be4f206926ba7c9cf66d06a01ce2e8d5509cb40a2013082c0b4807e567e17e35b55081fce98d3cbb77737119024915347dc4bb95540c3662630cd59a01de7523c319601398419082307770ab05d9bdc8a321f7634b176e67e466fbfd066a43b9106421687258604407752c1c226725b74fd682ad01939a657f1e7dbcfe3e830437dd66f00db499a3edde05dbb63a5145aa092f1e0143c32bfdf693d8f7100a7c908f44600f3bfb1702f855cd021bd5c527981c01b5e5ccd26f39d6200efec9b7e0e0027f0b487f26242c1bf09c7296697f9b8cab7fd6d4647d1dfa21409917337f2f911990d9af84088f7dbf5d406c8b312706bb008aea77f518ca809e6ba708dc45740a5e5498295cf6ca49e908c7ab30838d53bbee8650fb749ce0230ea764498f2af4147dbfa4b73c4389e81189c009f0a07492d96863ca249f820a938443cf842f2aa68aa683ef9a2882d907c039c3cb1a71c19ba330662d2bdc170f54ff494e35b4887c3a0437356108468dd7a9aa346a019e6442523b181ccf80ead90881dbe4624aed70860531adb0bf0d1ba569cd5931482c4cd5a69f44be81221c2e6aaccd158c79e24b1e6890d6dbecf08ee0d70fdd8761fdde829281e046857026c2fc0b3e22ed3b870e2b23745ed5e7e832c5708a8e84ff82587198b10e98d023780789e831b95d70075df0ea80bf81a72841703d2b07779f5d8b6f18eb043d7ba82877b528a003da219182809d12fd702f618c3a99e54cbc665487374bc6b7d6ff91776f153974ab7b0eaeb394d076ab2004137923dc2fe13f59371968f8e97e74cf3e045fa96750eb90d6db56d5f0069bff08ecc94221a07c8e6137c0354911e1f2e1254a8c85277d5d1e05fdb9f106b8352b6a047c2e49ea47481957a341fc131c3f712380b8005357ad15f7b7a54d689184e7dd507ffba6394395e7492aed48aeca29b4ddb9af26698861aee08d604fabdea9390c00f363dea7c4b5432b02cc99fc8546bbcbe554fd7dc3bcce8645e812e0cc6aa496518539abbef306b152a3d0a5da1a8dae1321a2b438ac047c303382f13455bf922a31da20b898c2f823a14d93cabafbdd30c97f3485ab1abd55e1de3616cae3a6ff24d2c7f84c6d2f481cdf763bb6d87e90282a9aa930d9a542b42b63569cec6ad4618cf739707f0c605dd3ab647bd74cb8206bbfb6ef16712f213cc12d32e8726a25b8a45ab25a150493da37a20826cba342dc2710ee70025533128056a9d1167939b919f13b6ada2e989a72a635666df63fe3f8ca4bd11287e30a36b9952e115da211ea14e54268b829bffa82413481d360a1c248b9ffcbc1c9c34f4b38ac49be5d5cf2f88b21b23ac831d305fb849c726fdec7b8857812bee14e62ff9359a2b00fa57cd9e1bacaddcbfc795810b72f36b1f7f63783abeee3dd3556ba8c738691bce8db776d7429b64d40e5d17defb36b13276da71838ea5eec5a692b6c89cf88d367bb00e77479655b3f124bf41fba7757be2ec8c200908991697861d521db12f380ba1ff62f2d8857f6f215e9952846687b806d3fc26518c8b8e01857bc86d599ed0d50fb34a4f696cbe7ed78603a3ec0ea29b7da03d38dc5061516a8c0b4931c2689223ff0f876a9d2f1bae2724670040b84b4a9f698ceb5748951e778a50dd908e86243c524cc176d4b7c2f80485af1956bd079d7a725b01f9d5614cb522af82beb1a9ecb891086b506516c04078b0dc6d60af4360e9d5fb2ce56660ec64571658d0d1c450643f412d33e0c1ce39a473bfdf2689fe224baf42532e66f73670f2cf7cf6064bc345d420f77482d467449716c7bc4849aa5a3a4a6dbd5ade2bb5b3fbd9fb5c6d378c9cb446b158de48142138a922059865dab4b02174f51c0c1f09e353d531e6a88c55784ffc278c45b54b7de1bc0b08df23ed6a7be6a44a51325c018a57601e0431aa3cb7d5d7182d3d95417067b77efc31e14740ee893c9a6b9cd4d8a2de68753e73d5936f7a1775ac259a26aa731fdde10c0867ecf20a6fdd3228ffc00a5bf9532b8ab84cbe5709ed837d1a93d217b2e3dfa459598e7055602f2ee5924d00847314933fa64c546b4f5b35181502bd1b64ce7948b158dcc79eecf83eb5c797b2775cfd1663cdf23a235cc6a07146e91ba4a1605eb98af11fdd403d9ae5e5907f399649e15a0ca001c961898163effc1903b7768feeacde590e5ba7594a26618a3abd454d7081415f06412040ecb073e2cf86fa5dfc904cb52923aa841063ecd92c0135f96b294bed577ab6564a66b2b0f73653014c8da9ec6845df742b4636a3ea77a76e8f20d0d15f8af50e5eb0db1c200e59793900f4745e8a7f0e97a8554da87b571fdfb152850da1f68f5ccd97f6fb0028c79c287852af9f4c71aff505dfbed69fe1ad6345d24669329be78b7f98926d830a8b90920063bdf5bf15a72a96e5b9b046902bf43f1db682d9546316d0a1376220c807bfed65c4099d2ba6f80c5b2b5f423b534fe126e8df8d0c92ae8a5592bfead732263d8e924c53b46fff25edf4700bbc2bd69acd4fe667e424deef3b1747d997c19c7c7131a7486c76cacc69ad6b48feb2560110c974ff64551dc5d4a662575a2db6c7d39357af5ebf0f2c4a0a6d1fe3eef4890dca341025007ed17206412ba07ef4d3b1182e575769ba362f507b95ae4ec8ed5ffdc7ccc271b8b9d560f440fa0db770778809394a088eb1fa7cea8c4c427d7ca6f772cab9599a0ff308489554b469f3171137b1ba27265971c716d319b8bfa54a0fd7e5a27a61c3b9cb2c85653f3080d65f2965093c6ead0dfedcafc7cce90cefdda3e1fb5968dc78be2213fd0cf0cf5953f0c9e6fdfffe8623d002406e2c799608fe7b4f30ed302d6372087a86905af30862c563a42742d62a8df2105cf72ffc0183cf3c48841eb9bfff1dde1f13962ea99f4d0a54635b50dc6b3a47476b9419698fe781727f05c55b18f86d435b4b8b61305591a324b9e6557023fe5d956afe9290885fa86547d258dee965138b2149d52013505f359b2eaa409417d47f27f672309bbff9b717efc18dbe746dbb5e61d77b5d60bbd2a69dc04db0032d83213c5614450e4da8a83086e0bf8b9342c2ddddace9cccba3c6b35b57e6acefab57d1f9eb2cdf84922924b1a82f174d095ea5bf6351cfe3d970a65a61b764a0added11ffea40bf687096ca98882f4b92eee49e964d5776cb9438af6a584e57268e87730254f3f4c483b9c8d529472a8f8d2204c7849f93a01d390667b8232e383944df54b85485c8b6ac5fa32b304c59fdb88007c5fd3d3298763715a8fcdacdae3e5c78813a8a2d5232df20f1a3d86ab1e6a563361cb968690adb5a8f1f546735761d28ab6a788cadf7f14644eb5ceb2020da8f019aa7ca0bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
