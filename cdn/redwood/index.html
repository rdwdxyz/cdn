<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5450af1267c6c47f560c8da62d49289bb34e0929775651a52a4062731963e73001763222c5056aa60ce5bc5482ca5ed6974c977bceb39b4f917df50324f810ff2bac62dcd84717aa8573b0e5601b5b08ab510469fc73ee24632ed63f2d0a4381ba1ececcf670ffc6eb47713ba9807d7a4da3cd2264fe45138035db1ad581a8375da8772f904a50ce2635b87917c470457d335326879db5296adc22605b528af906396928cd6357a739b9638fb5ca6c88d7e71b14522868821d99b70175a10afa960650d25b62b246cdeb13a5366299d0b7892a9821729cfcf7c4b04e72073ca104e132629b8df6c2fbfe8ae2cc74f9fdedfc60acc0a01b9c88f373c94de80f32e994ed412df95f9cceb42586ab5e0e7dd739b28c7a46bd5b9066beff461faffc136356fb5c82eaa8572bbfeb0ff07644d8afeb54831bfe5743db23ceeff61606d73add1d3f55f618e7ba439ee1cf391dc4a643ce8595444da53d1a1f90c0665e3ad71a00ed07217893d4a949d7f65d8942b7e663e2fd87152c14829f87d00d786fa3fb9e1cfcfb7860123aac81189869c1ebc59b415c50f3aa7802115b57fa27f4a4ed2c03fc5be26b235f176c6cacb3d5016d1173bb4df8593d9edb42049c42567ab1db7ea5946e86cad15edac11eabdaf3042289cf20a2c6a01baa73c328970f418b1fd69c4353d713e49fa1f7e7e6a71f71c91ff3749c36326f28c866c102f1f33a58ac5af1840bdbe35d4aeb3fc2d6c47a25d39e38cc0da10c2dd6040aec0daa7acf167e6e5cccf99b2e58fb3c6da4a8d8cd84a24ca90780ef3371fb22302e6ffa7f0944c4a000d1890b7246945e1a5ff9f89a7cbd13d69b74de62da1fc3361996139a49eece5022ac644fc09840a982b3a10ef1cee01991ee5bb2745a23e809385fe0e68cac0eb50448122ebc1a4facffe1036efd062c582af6fec557b2c678f0bb1d0a3a2ef32b76c57863b14a18880de9de4e78464e4348d400d1062c9c5283e3b8e1f958d7fe2bc290867357e62d65e2447a584b3eb759c4caeb7a4e636903d91ea13c12d3bbefed18b59bf88f6559cb8058a36539b07de43f2b31e9a3a2c469254dc9799375a3894d4173fe2edf91a43865cb41a323e28dc3034ec8ea3691ad321c5a448d6b90e9531503097461ac4d1c613bab6fb37d71234c1384ff36a488c55edd8ca661f4138aa655bef14b80176203978277e8abf8053e3ff151a15fa88be45dc2f3f2aa0b9d24131ee97a7fde7f77940cc164d3bab0cd2da81a8cd50d31ab1d4ca4f926f7f7c80e057a823ec6cbdba9619b70ee0fb1457485445d14ab9daf9b3c0caf0cffa95c1867926f0e4d83eeea0358e600e7f4a87db081040d472fbd797fddeb7733ed6d38bd1f3a5ad7c8ed183584c579da30178df6cb71487f183b45c4ab6825376a2285c3b0e9fea9987dcb9d7f5e121e0c52436b278d11d38d1721b34a3b302636b73b3cffe1239520b02a706dab5739e0a07e165caa780715413e7f4db951a33547d18e26461d3c7af1869e39e53aba8192f1de448c8e75f6cd8a1160c5b23300da9a4ad086587b42c073a5cf27d11591e476d2cd9863da9e1fa911d279522511fcbe2be172c397502af20086cd1239f4bae653e9da02cdc7e71de6cb6228ccc170bcb5ff444937933d17769efa77a275a09aa57e2598217f25288b48ce2aef9e299bc8f7d8d9a9a740b03c83ab883c2cf8128bf8cd4a74d41290964c2ed6432224d8aa05a0ef7131439c1967fe7d49242f55d1bd0d0c7f30a74bb0f245bfa048f012aaa836cc84b3b841b4aeb51548a68891563da8c8527675ef12904bc41c69816b8f4221557d0b5dd8141a4814d8261641157902af9867cb2cc251270e8d13cda9014fa51c32ce77a380e27ae9691e2e2d2bb68a7443ae76ccd0b25b15184ac6e543b00826d8aba658884f5a1a2b6bd5204147b53911d1277cd83253717f5361abae29a5dbf5e426a7928a235bf2d8bd3e9b2aaf6c2b3481306f73589ef69c203de96b6879335613184d05d196214567fde82ac3a6c43991337e6d56c05e068400e845da341812b17376aa3019b4e0877893c8541810944a59bf12e7f456555a59658303fce68f9bfaf8e9edee50367ad75f0fcb0a7b5d1ccef9067481eb64d70a72371be0e419fc2a5082e210c771877d75d364804caa384c2c1e4370929993ceefae29d63322c6e131714cd70e6056d59d45e2b41019ee6f6a79fb6ea93d005c6553abbbcc5accbb27b640fa277f86e709198bd399d568597339589c516ac43b010de762d174042c8b3f25b8f3062d2122cd24c6b86834a6178677da84adb8c3a0b4a86269e9c6a22daa4ea3deb54a02d393d4a76052373bef9e523091b3830fb356a4abb8c69c1baf408f5b13432b730143a1d3fdad9a5b58cbca926fc6955483c275cce18c66d62116be7d476149f67a31b02b234db617286dcd1f541dba40679cf048cbcc4e5b59ff7796e16dad0df1e3f5e078c10bd76f2971805d312bdc28a50d9cc60ef2a68d42aeb676a89c9017d369731d91fab65caa5f7e093db71872f81b603a410faa4cfd90990764388e1fb96ee5cffe24c9d92061357b7ca3178c62c1847c59e681d8da36141306a4c204bc55125385369b085ef5d31cdabbbce01d48af80d99712be3e84ccbd6edd4ff62a6a1087a8f3549b5cdb0a6649ea96c6793d894097a0e1cc93be4c1960af305799d7b7bd542af45b3c92a72e556de868ede31ad3f2cce93a2adf078bffd44469d4fc7936f1b99f2acef8aa513bad00b9e25c65f69bf0878376cbe3dde3c7a414d7ea3167235bc7d3cd733097e88af9f3ba7eb081d12a825d09aa703c9897b2d8d07bdaa809e3cec83b1bf387d74c269d49d9827de678d65e445f2a07c6527223fcaaa662abe34aa5743a67ab272b03179da2cc40d0179b99ffdcdbc8f1b3a79e8c56e10d86ccfbc1bd974345cb10bf5550ac3d9871ef457beb5ceceb778c41f78aa1ebaa91a9c05dfe2b76b319c7f719c606f4da5e0b4c3c9244cc1c7a4947a63f267bd639b8d78d0a6c73c4a22abb8165f107dc697be549ce2f5631a44f70deac71c3e56063e5ff763a572be3d39de9becc1d4a0e07a17da780b77c53c21b3195ad97721a9d0816feaa6eee7e065a45d76b50062a9b1641bcfa09b2413a1bc19cbc9d444b043b213241a833291d2343c517d185a5ee60c83f33bc5577bdc99e86bfeb7dc6d337f3dbaa52c631a1470929f0b1e77fa69e27281d337c120a0ca0e67c7c921d39d0c0bc8756dfbfd8bb9e0b8c0d5bd90d19f5eb35eda7bb91e0e76a2716c2a95b3797ebf75e0cf6d4deb7d0d598de899bde3028958d90dcc385c7e587aecccf67a3de20ec76da20209b23d43935100ad361414d916e1aa8d20311ce86379cf0cd8bc29d0563b8d36b49221e063170c51c6ef2029a5b8f12258576305f2f67ca6c6134444a21287f47a967d7858536a53c554fb2810fd56d16af8057c704b25e097113a4596887173273f3b693a835c6506ac6d07601904c0dc3057eefc9a813df245ace377abac8c9fa442a89adee3c0ce9502d953b8e8c187d8800bdcc95e6f06abfcd9e08feb936659b70b1a44a3a2a72fc3b931fcf81f137cd2ae6842f9c3850ede9a54bbffa96ab05069068acd84821e289f05c9492e602e479480e71634721aad26e4819b3bcbf360ef927960063ce7365b8b5bccf7401ad45a04f84f3a9c3584799b6e2fa73c7ca46af7c5a0f38eeca07803d45b5c91b46f651cf6c72990d6558c13bf91e0848807be8b68b52d14166b0e5a0fc50f570bbba5d283484f9f75f5b1a868b3d8dbf8c3cd374c74e174380570ab297cabd78de49ce86445090fc9188c816a4cfc6ca1c684c73d5b26c9b50cb457d70a0700d251b6fb0210787df3bf25f3a64a3f501101f2b45f88db70f9806438a84efed89435b22109ff87147a29cee72ab12ac19ba03087222d2974b8b54d0fa476d4949da4095f52c408f11130228d62971de8adbffd118346005291c6213084da6ac17a30abc1c88a2f38deee5982c87a0e835de2450784ec7d35a0b5c199fcc103e41cc15d251a5ffe07f951d1c9ec51d3ae508a706f97e167e6b07628be97d039ccb75dadf22f5a0792889bf9599bcb576c354c4e3225d356fb9bd914104172aa357fd3e442c9f3958b79483b3d3157110e1b414b2289279e83ca7fec3dcf021a12b2fec951fccac24dff428e47de0cfe21e3ae2030dc92554280ec1988e1e2635b1b207a0d4c010911f8e478aeb1e85ab96781c7d8be9ebe4e3e1e82db776c1cb85abc093a779fd94c5c55051c293c78bef424ed3960db03de211ee2d1304a15df91e1956b551b19ca5b8b171dd968d5a647c4b54ebc1d66851432e00894e7a80fdad0504c7bc0639259c5f3539ed75caa524a79e86e0cd0bff0a492934ef751769b36469c874d75100efa8daa8f91679d75baca2d4f53af24e245593c8e2000cbc1d315bbf7a59c9cc15a0721ad48d95d8760698ec7c8fc973dbbe20ecbbe9767c7fc68a80fa2f40b1fbd9e61efece5d70cf228006cdda760a58f731691e060b1292a5f53ed2c02b5b0e3108fd8c603dfeb6ab7191b1308679672dadf8e59362807d331edf2f959e50f73be236f620b7de8517b89b669105f555a03abb4e6e2eae46797dedb7bb8c4d95a6c71e2cba28115dc2a1833eb659ae707c250344c57ae39e641ac18148776753a8f3ece810f1924c262cb31b6ba649c8610572f68576352a7155b3cec9dd980952ef8f3b6510e9f313e1d15d1cf01b97bbd967c7dd0cdcbd67be642c9576f3e8bc8a8548bbf006495d220079a5b1e0bc10463872595bac49868f3a835abe4600f871675bcb38cac942d9cecfb3b4fcb537d6210e8dab0554686e9f731f2dfac4f8f5ccfa77c520d8ac578afa55ccace2ddfb1ebabfe13bb31673ee3195ecf72703b9091f861ce999b14e7969f90ee6b27352f0cc2090501bfacdf1f1e04fb6ea07820a88619bc8d8855c064f0981023e5a60111a06bd3c7dc91052e601544e9e9b3bb3e22c37899bdd806f58d632f5a57356a1887b47ee9cbb2172c9ab2da6a2edfa0b59da6d9caa615aca3787dfb68eb154dcdfc6ccabe3bb6d11a3893b8a0b54ef5492b473bd61f2956ffc894d52fe8e124c65d93ef09a59dbb0a9ed9d863fa49cf0c40ae6ccd6dcb1e530bd95324835a4ddc4986b23492a3fcf7f3c5bfac6ad207f8711164e0b47042259362014a5218861806637f3b90487eb697a90681fd3bda076868fa05a2b8ea2317955223219efe256af47ed57ab9e0cf95ff015c032016877f8c22ff9457a1c80c17073d89ac30216cd105ff679d3b774e35cc3606018a425121b2f708383ada181134184def2ed31bef5ca75d40ffd743bd60021119af96097b24022e23c2b382ca372414f5824af78f52f8cc4e37c8f8496e880eb39813a95fd01159209c447cee2786b57c51747498525f8c8dcc61f5625dc859198af8077c2ff8751199bbf0a70273890dca63addc3724a716c834546d4e3804b89b3a167782d54c28fab5098b82578597a1db58caff0aa17a08349e8c94033930e1b1797258f8105746b3809f9dcc555d4e726837887ce43b109280c022cc64f65f053b4f0c6af0a64e6824d16a97eaf135b50a2dff54b31caf6561c6667414441e111e708106db6d2f0ea217f41ec7718f6d4fbed05e512f6583354790ca7bc1839ecdf5a2d815b035709475b624c6ab6560c7d4ff39c8f24beeaf17dba205ef60c9019ca62053045f9787c85552257caddad0baad0fe6787748bf7257a8e62a47220d0bfbba9239057900f6a5bd8a9ad0f4adffaaef88bab4e7ffdb43509ca6a2cc007c7c87feff9d8d791f854f10e3191630d1c7d1286e5a28e546bb6f40d8ae63a532ab5512c859e13491567ec1212bde1e71d2914588b8771e8e99047cf4bcdbd4a373a45d870c4b9644b32666f6688642737d0ae09c599afb0c39fd627209fa880e1e5a238f9ba648064860854509cef92d9c1653c92742284ca497f06b16ab99d6732eb2f4dbe0f6cae11523eb72b1efb2b58b8a6e44ec45bfdfc98769998b1853ccf6a088c6c60119593e9010a12fe52f16d26a9d6d274c665e9dddd23a05a215d27b8c3dca9b6330aedbba00c0dddbf92450153d0cbc466843576417aa2f9cab17a339989eef76619fb9be0e28fc510760834a385f614b50ff7a26af4050da872c97c6c7b0b71739161ada0720b3db110d8ed11fb1a65d0170c46514df9991a8fec6740425d7456c19445539aa046cb5d92ecb3e5dddbb963ce5fc7cbf30f6114af6120b10485e429277a55e55ba6d84e55d3308b148a1f9bf1a311d2108828db89853382c0e9f06907118150774eae0de217c9f2acc4c277b69953023e8793e23da0a07a8acc6e543223cd9e722685cbb727bd4125e0a659ff7542a75386c5bb9488fc49b194823184e4781c01e92db9d56a8342dc5ab818f284e088a95b0ecc4217d25ae16f3fbea86c2dbb833f63ad7f2eeba981706fd60b817a9f6fd6828ba8afe034e0b926613bb4fe0ea3a5fc6b6881b7b2328a5477ebcaa8826574edcded21b0bd208bc19fd42f8c3b50f815b6036a37627f0c9b5e5c0f7b0d3ee14f1838b04c172064fb52fd57ff7e3e056a18e5b8c6b46f73553b28e853370fc836eae02297fb457725b5803f62d1e9ef389e2430ebe64abc3962e844ddbae4a326195e016cd8e869cf83214242abaa3c848556fe68e02442cd500d9351a88456ac9590361162c4f93d95c7e78961263795ea456d227770d6bbdd98a1b9bbd60a652f0d03c842f4f8ff14ecee5f93e17d2888b8932821c417b1aea782496b7aebd777cbb62e5d66a4fb4520e585fb2faef3e7de78fe9aae8b9d14e531d530aa7b7a7930d74838da7c455114264591cb26e14759207f4de3ba525bc690bcf5991e519b870abff7a77070120eac60c42f97cd6d31a95f09c8c09cd627f28219896e63363d11b9b086360712f916ada06f04f5f221c76e935b93970536eccbf7566264e1e09257bbe2bc8543b12cb7caaa7cb3e42ffebd7bbba90a774d6882e34186531b4fa4a0f27f0cd8270e3044c216399110fb70dfe0d34150b5125d062f58b6447e74e7d82af7aea1606ff7229dd2e1c89d6b0891b2d7d4cb68cb0dcbad15bc64a62c8457acd925504d2c1457c362010cd818fab19378c8f7bf96127d5f417a52db8297bce8b4e6971efda6367abd4063f7d00e5668fc2775ce0aab64e616eb3e1726b0f8596005093f5e96ec3d6fec995566a7c858929cda038ae5c9788cc267182fbf529b014aac37ab0c0220e6c810aacacd85f3b01b412c0e8d9efc180b3c8921dc1477cece3f22e05d4885b627414cc742878009cfa395307f17ba2c5fff125086899c0a6afcb7b6c8d88c11b846f279e7c8ccebcd1590aa9143810a6cea1fc02cc88f0ff2622605152222d6dacaa301c6f4908dcc118a594e0c539360b690a7fc40ac658674d59a44104edeb9aa108a6f135bbc677befe7d284f51b38189cb8f95e71e25e656bf992212674fdf721c81ee3731957e3667c17d914dc26355ec047f5aa9585e6e671c7621a00b575bbd20d20b9a19ed9ebb70e48460e984cd24ecc571d15b7789e612e40cf17b691b56e19f7940ea9ac6429b44cbc1ea0d9c7fe2933b06434bf223f86ed2a73f7242288da23d8169d4312aaf1d150a4aa2d8d3da857a5b677c2c30f8409beb768d3c1113ba26afb014e397daddace54a52ff1439f8fa28d4317569457124dca5eec648326048112566876791b8b4ecde9ff38f9448136a0e75e77dd30265f4cbac8200e740dd41d69766c533434f025a692679dc493046c45ab04eb58567c879bd8e0c747e03babbaa8a851680153970d57289332f18a8a57f2bef5670b477ff05103b8f9c4bfb3aa2e7d5b7d0b84b5fad81f51121789b8a3a86b03b320a93e440b1a92251fb49eb7881a574e34ab27733285a32677fc60803bfee06835ab1abdc4f16fb3728cdc21ef308945ad71b03fdf950c1dd6e5cc2421f39f705aa9252033af6c9dc769dcfee9d2871fd0666697be74cafc32df7d3eb6b40c76daee116fae213263d9bc0adfc6eefd45d92ed24d824ebe8c572f69733190247aeebf56ef1655032778e8069cb4c91d48b755c9dada3350687f609639d63dae02ad6e3f137a6bc1af74222fcefddf88bfc36cb51861085d91bcb669ea7b41f4fade6d33585579068623dda2bc3aa2b59ca0f2d12a8510abf848127879ea417491a24179c8358fef0340fd08739ceb9cd83f8d035477d92d57d752917683f124ed1d5b7c79ce3093da773c013f92b5412726f2b65ed968f76df13e0901839f8980deba20f2b0d13bb5e094d256eea9ba6b81b371f3c1c199b191d7d0ed137afab0bbc1ea39719cb7359f66ae7ae3013c2277ded7dc313989d1fe17ee450aee8091b0d0d6c9d0efd99ab8bd61d674c4e7f5544e4e455a537beaa0ac564c34c1d9b148759b55b52c71fb364c4e3b8449e24d5bd3806d40a6e01f56e623e126064bdd4b3cc4d9ea9004bc7fac14cb5c77930bd00b9109436783ecb0882bdddddcfdd985431e3a408beecaf4b80da3e0cfc8d3dd117a7d065fc82e0d92316a1b2e4d6bdbc70683a9a87a7dbbb2875a8d91a6c9a88f55fe2af5c874cc7638d510610a717dcd50195b51ba55ee72f14c374e6cde5403ea95bb9826054dcdd1e9efa722e8fe37aa6f1b633d7c04161996a29a6f7b3dfa503b6b0824020131fdf66c3adb49de2b364a3cca9445b3fe3e2d57c8917d3a6d84d8e78cc156cec0551a63264b47c76d881b66adaded09a280af4ed09897424fb94f029fc1a64078968df076268da79ebb62a098e7f9ccc87fc695555faf293d0507ae2b0275dcee8439995b0242850f7cc1784490521347a37968f8897c5e35816ac233037767b35fb6a16730e4f376acb737c6d95f1807aaf2e92b6f15f884be35aeaf0b49e529ea425db45b22a133a4620e189894aeb7bb3d4579fe00722de4e2538aab43cf63d9c3c60233086f7397ed78214e02d520812bee45731a6591f52de851116b52274ad92a6dc677d1c78a23839580d0a9374d61de8fce11ff73b193daa8df8d2c7e6e488d74c0a364ddeb03ad22fb144fe53327074367f0c475a74482b6787f88a981cd1cf0272f491f1468af04db6dd51dd688209b75bd90976b60f059d5b6abc80a2835e0b6402c3f54648bd5a8e06194e20fb12d1cbf3f1e07a607325d4c543a76b96107a4e6cf1536c0fa9bff7bd158688ec28adbf4951720a83a1bc303929aec1f04bd5b7be1e7cb48a9bf357f1d9448955c98399656dfb335ab0c1683df28d448e2f5f17d0af9ef6e4e8053c0bb52e8f4146bdc7c3a6922dfa335d101b5db2acc034bf8b7185fe9999e85e5ab2b4ba1ffb157b405adfe050744bfc01ef0596d9ff8400045c16245e32c36ab8c74bae9448f8dec8f7e0fdf938e0446f0b343376db28e7a83d1f771bb86c0872d4caf693dbd2721a99dc8a5d7efdf4d05ca00492bab08d92ff5db5c6decd492d5b7c32a73f299f7264cfa6e855c2d8a7fd0bc7c7d3ba867758d6833a9490835e9861be04b23581727586d14fda4426300975e9da8494ee39b1253255bac70be5751c5650c6ac385171bb98bbab4e4833172149bfbb462d14c0f17a47dd7ce9dac571e0a4017856f6b6f431158b7d07a1d3f9a9373401e2b62108aecf72acdda731d366703976036e57e7505db7fd2c3247694a02df1b6310ba82221259f3fb7ecb058a9b4dd532f6f7c439ea8c329867606e16f995c9860447399e153f9efb8abb936c73ec10b49040836ce77ba7da2e14833471e0c8a594c15b46852542328cfbfd0c4055d91804fd8e5bb860ee183f869ca7d0beec8ba7726d29fbe6e0d0ca5fd71a6bdd89d0f3f9109657936cbed504d8ed2608291940f25fecb270db2ca11d3718aba605aeb2eda7943c299f668e3e216023ddc95f161b5c4ae11b02bbd60e4325d8fab2f9fa3e9f8bf01a92473a7faf5a8d636a91ff6944f080785e262a13799cc9d91ffa0cb94c2a908c0fc101a813661f8f91978449bf20ebc97c4739c61cf7f040e581c00b06d5c7778cfeaf17210216bbfd6a185fb620ed1ce548c528f823d50a6b41b8cc695f2b0f83071fb882d7ed512488878f195d1003205c6e9863fe1c2943bb4886526f5a7741a4f56cabc0c177422745d748540e210e083296635832ba677bb8ae54c31ba2e01141a03aff76ce357611ca967201777b2367aa98089453ebd5a691889434bf94070fa61923b4c6ac35937f2cdd5002db45961c924c0669a0d564d5beae3cd6d96d6eb20a4386b2ba60d87f427de6453e0df230f8ec522fc836ae5d59bdeacd96bcb8cbc3bd6ba009e213b39924c50af4ff773234b20202ed5d88dd796b55173aaf93e9093cecd340b17a53786e612bbc6c6cee1997da45a560eb5501bc78f054324630a1958016bc1b5f8033c89ce5130ca0dbdabca5cea0f56ef56b06737bfa9172962601f1ae3704f57af7b6c3edc281d7e6d79d9c5bf1c61a022fb088c83c855a73c51bc0eb3ca4d12c79739d3c057a05146703f0913cb2838651169683285779f6c1fc4e661d7c43432267f2f32365bcc063dc21aef2c3d390b98675e2939e0a9abd7b1bd802d1c62e6de4f21c8dd186d1676a11e49c065d2338f94c60866907ac818cdcb5fdc0026e7735c33652f4bef16688ae7d44a7df826e09e664f9a0bd301b565a9cd27b398c15827cbeb9785d537d1902f66d435d28fd2faedeb2c72e95c2ae12bdbc8f0e0ad46c6f69830ad9898ce4f2386d53491fc7450eecc30e4ca9c5fc74bc8eaa14822e6f6b02bdc4a1021bcd613d75049b78ffaabbbe7320abf4e21341147e146f8a65ef8e2b3ce22ca2e4288a3f162c0a6794664d67bc8595da7b334cd3350d880f125b988d752a7770efd9b23ed4c2e598d6f71f8fa7371ddc40cb1115104587848d34f297e21a971ddc1adae4c87e0445bba2fcb41739b6e91d68ba7dfef08af4bbaf82535b7c7b8cda669e80ca964504babc1afbf72d12df355673d3913fec2e25fd53b7fa730917b7f8d5074525737ee0149c587c90a2207f4ae3845dc2c73c4e46963d2447c874f929425a5bf788b08696dd04f166adf6c9a97b96ccba2d87f4a77d17728c067d3bd6085db83e9eeb4fa90a66952f37d2f47495fd5285b726767c7f4a89ea0c4f6ebc14cdc52748b6f7c7c454bbd5cc261c6a775d06e10d803a644ac654aaa0f50ea700546d285d2eb319ee092bc1c242a05bdf722fbdda23844b3a41ea61cfaea0c849c52abc2b87a45d63c270c7c6152cb762b75c9155553e50b7a5aaa21a3644bbdea26171bf9e256843e05f596498b62cb34f4be9c8821493cb4840cac1b1a593156c2172b856668425d3d606ebab0ebd2909279a7a04d7c1ce4c0a17227ba3a806be79d577fdb7639483755c63c37b7b2b358958b622c4e355cf462b316d92271f73f1363a2ace4c6a41b6c7fff54265ed1faca6f332b6f8f7eaa83a1c0a31d48d6738d3b79b1eeecd841e218327b2e88c76e12768604e0eedcd543fc433a74acd8b3661313b2a8e7d7a7958eebb06aaef44f1c91bca78908f604dec279d451991b12d707710b9319093eb3ce40010a2aef5d1224ac849b36d74fc15247f6f271437076c6c57387c119246d486eb7195084ea865e3ab1b858553a05d7544a7760e51660ad856ecea3878c8cbe2a614aeb6f310366bda77f0ea906d63ef3ed75f5068be7a17361cfa425ebf612b1b90d314ef5eb128d14798c88c3ab2d096e9640aef8e1e3c806d541e5a30b7d5b3145d3ffbd48d62bff717781ad61e9c02e1ae3905a9dd06eb693f69a9fb3b4b591286f198b2e6848d669119b7d6f81e392f1b0f02e05e7511fa2b6a0f9e473bbf6fd1ea09144daae508e82b2f2fa3b49d53fc47f0e4c88b4f79b17bbf2f5b7cf8241674235d8a1cbd0ee79e5ed9661fc84e50889551ec737b349320e6f685a2eea82efb56cac4825fcc701b7e6f2a9825e5e54a13f8f9efccc0306f00367f5e8e2aa101e38358e6a8ebcc182b44518344ef4afa04c149d9fc682cafc8fae96fec29e24b1b4ceda07648fddb07e93f609ad846b8400f14f4f0aeb10eab447e3ee6a4844ee9f58c43a681029f60004d862feee12f741054f86f5788f603456026a4eac8e701f443258da9fb6a5fd1f08f2008020bcbb62782696dd56279f75f4a4d800e64cdef19d2f01282726cbdff6f55011a885c36ced5111ed277b920cebf9f6f020672434c4930ece148d9f566091480b9639f041a9c492eaf25c4575f01b5cf27109bc5991d8cff307d9ccc466e8caa543c18e65bc30dd42324320dc617b3dfea7c75069e6a7bba326efb202828f04955500193a1764c822ea94c3541743eed391bd787c58bb4ae421b72ce88f6c1be450bba2d3245b89c0a43f4e5b0e25b9c5d32ea96172c57fb8272bfebad0035a4d982ffa7fb557e5ce88ea0a645637c83afc209d0ed710c270a99fc887b991654647d6090ef1f95caae7b92d15f496f8f15e41d2dcb73963a7c4f76fc13296545faa5981342901533a7ce9b51358db9e87b33082c532de11fd7a89615e4bd136462c58e4d644533e9bf3cb68eabc179ab33ff11b34dd4c0a55288d4bad6f9cbaa37eb8f0cb15b326da30ffabf8bfc1ae1535e67ad823b9c187f75004a380dc75a1fc3eca51889a9585509a4d7081e3376bb135eebfe92c7e05006771c61ccf1adf06ce55eca687569c69997fc42a53abd07ded8ac137b8f4bfdd6202d1c1f33c594fb45828c44fa5e72aab123d7873ceb29e0c50e73f6264f24e9f8c2cc0c465882aed4afcb9423763bad36b0e00da5b5d266393cdb899eaf9eb3c8b76b16164be0243ff4155cbbd30541c6c207b83f0633659d02134d248267cf76c3729654af5d4fcabf63b2a1ada29e020e32fefb4a5851b52e4b431254d3d956d94afffdc7dbe9c3402934d22905f654cbe3f391fc17f8f6aad2f8ba6e3d0b1c62aaa45454e75a52aa9c953c35d332ee7754cdf7a4f5476f95d431e0b61b85884f783a0b705d0bad5c5bc97bac498c144b266240f09231381dcb709d90f1ddd6a409a5ef1bbd8ed7a4904f498572f745eea201eae14d70eea8ce8421bb11389a2fecf0fbe7490c03f264e60ecaf88e10b9c7b4d5057f50768265ca16e3b8f89e7ff5fdc52ccb8ed7bdcfa7a4f615635ce6a8d2aa273c368e7031be1e6615907ff044f1a27f538f284f17a2ee19457aba6db37f04327e75658019bbdc723bcda329103f60959dbc3cf859a80685469ac1d6d832eed638eda9b9f590cd9e99ba7a33f8805a96e197312e1356f6cb628c91fca63bb698489739b5bc54d115c3fdc3f7c52085d47f72186c43ecc9e8fbd74e156205dcbf088e82cd468e4dbfc7c95b2409ed4612302d77192db4c7ddba7881b62ace92930157d074f0830936793d3063c803ed6ce25c250630ca79133cfc39640dcf71a6562d1df8ee7f7527e1e650c495a3d494c7b665f713050a42f50d2b4ab0df60aeb256be6d0f6c5b7cd20148db4ce0bc70887128640866aab8d3c388db149f07c6955021623dfceb3bf8f6cf65964606065fb123f9a193d1deabd7d1c1c5b02efb99835c8b68bef2431b98e6eca47b2a41978bde23baee896f3c9229d878493b6080d557ddd6a8f5f2900dd12e2b8b5d337aa3469f2ee85847f341b9b65c233652670abcfe27fc6bb7f4a7f77f903cdc46ca81f2c46724a829831c7bc7720e73e8ebef51e6e64849c6f930cbdb7109fd6c1d056bf17b1c861e60d80173951d84a258d801f4ed129f3f5e4165c7ee265b704ad0bf7caba4402dbec4dc5293f604c04f745569b0e7841cad25985af387b1a61e976d01646f53e884b5c6ace327a96ef0f82b19ee53fb1b4f21c4799a006278b85be9e5239a47840e7901d3c00c00fee21c5d5e6fe8e3465a3159aaa1ab36442833bf23a15d437c87e3decec7e09b694f12ba1aea2cb73c8d686c10cc4807f16a3aa48bba02dfc899d56f8e18c86d39d4ceab4a626f50121beb43481da1512783bd1987f4d8a00280bb548d0aba609e01317361ac22aac893e5c789af97c44e3edf7442f98f666ce8cc8c26318e7226c1bc351a7f89c62033d16659b75102e18f43a092d23093f8dda579bf56d4f3d2c8e9ea1d9041825e784534b29449bfe6e9d637d0b836c981ed13da8582b17d977fe4380dccebd4195ad76d8c204b5b65e2f20ad91eb1b96d193e959c41aeb1b0ffa2f8423ac60bf11e4a0ea2b943f967cde0b3edd173ebbb18a340c0e55279b545e2143001419f4da2297ff20222cf2807f37d856de5a99584cda01feb0a3b07d8c2db8ac02356b311626d8f29ddc97cebf0f102978a2c15341020d61e95a825b98357600ba0622589720225053bb131424a2d7dcb9f7bb3d0ce6c1fad3bd94999d8e8c416557a0cf0cc466b338eeecb52cbd3ee45f7675cfbb6792f1c715de83e803397bfc04fe69c4a7ccbd9cf6d194cce7b5d6f8ef81a9d67862a32688ed8697b1a653b865136635fa089f728ea6f013084a52d7bfde0a172821088ea9fd6f249ad5a1b98afdb7636453e5f3defcd7aa81116b4a15a24b852850dfea9fde36b5d47f9f02a7f77aa9fb1d770669dd2ea97e20aad3a62354fdf02b681dd24b7774882e16ee429c9be1f17c70cc67bd902da89a86caeb1c2cbbd6e902ca5634ddb5f63aef4e7506475ab436e8a8b70bf536875dde5df6f6ccff842c5a2099854084854aef3fc81a482af149da78bd9c90298fa3091ced4efc5816ce22d5c82eca74e6a7d617fd62275e68f2a2c535334e7b51934e2779d7c014759a9574ce23adae37a19b4ad89137106b9553a1d2fcb1f0050d94000dee674b39b51af7520dfbddbbf2e869b514b6b4efaef536f9704e663b4e0033f878c51f8807ebe313179fce4b69e7d88a234f34f29451c9f5c106f22ef558f432f229dd4375858e9421598acc052b5c21c893fc0ff8ac981148029896fb736c664c9452b7a15dcd81fb2a494eb07f560fd773f5012849a2fe6f4e9178203a58aa5cc3d45d25aa5a5aa806bb6912b242c0a08461e6d6591502524b339899cdd9177faf295c673309be54877f44ab95e1f683b3df8777b20ccd429771c42934e1a2cc9a2a8cc02b84fdd687c0d49f2e7b0d12ae945fa4dcf6b0dd496451819be48169b5b5d4fca390ad5635085a546cf759c1ba3d8e38edad6de2ab2c0cc238a73e53ddb4ef5d0bdd0e67bae5d65bd76f9a2275df759e0605a50bb24035ba248623bcca1963bd988e3cf7d46dfefd9678053ce6b39b11f8807a4e6f2e45c8e5e18a466dc1deea1e100cd18dcab302d671215ef441cb4eb6550b4d03a33e1cfd109270878347cce30ba2ed513d0fb83638f6266311a6e97d88d9438985f72c44a1314535c5de116beb328ba56bf84825eb3c563ee92410db2d2cb4ba15a8490667e8a7e59c792572ac7d9460404f6d586da529b82484e067e695b8c69d4ef80d2e86441152fa94b66c0a7f6d7fc73d0750733e7a6f7c8606f4803ef76de9357641ad3dcfe951d81a75ea1894e88f04aecfe4c18f218eefa1ec17ddb054229676b918b2f36fe1805b5d208f595a26febceacc63fdb6af9043861035582ea8afc98f77c49cd66b3d9e4fde2a8d7ee8fa633de67afc737abdaade519bf5203472543149840b43a783b2838e12d7faaa08d52dad3134e9ff948c13926b2688a51c4f86ba370d0a0ef19587bf3f42f015ca1ffc587eabe6d2849375f6fe60e8888e28e014429823a8ff6776317a6209b81719669162d0a7524a6f5527b7e88a3e35bc28031828da1fee8cc1f44f54dad94fa96faed7f88adb35bd5f3f0f68e406e933f92b2b5382a2a001bae161ae0f684eff003050bab09eba5c8b85555f91d80709ee0ca9946471a8d2a53f34d5cb32543a9dd6b49a7064b4aaa70669de1f41a5fb852e00572b260149efb7dfd125b11f74306dea1083c0effeeb55833dc520d8dd561d71069b63be8b66cdb4d9457dc4bf82b2ff83ef0dbaa7f25556ba37fa7a46061189a80889519122c36ba98a3602ea81c470adecfc9bdee49003197cf7145749723dd4f12dbc8741da55668efd73d3c5f91238029832a7af8c90059d7ca1f6d576f84625514ecfa791dbacc3bfeb3d47176995dc1b613f8ee8495cdd9055ed1c50f30fe854128ce848c98765a28b09d2e43b3d4e84bee5291ece9549670bf028515a979d2829ac5bb9b8030cec1034540399cde6fe3c9cb7c1a244c5ca56e7d1db67d90b3afc49460ee8648308673aa89abfa6c63a6681c41b9337277611aa188bc1f220149959dc00c4b40ab9a9878db5f11e7d5f18574384d66488540d23a1d03de5ef43720576f839b102d1d323c3995e004d004084338796822321b04211de7e130f35dbe87c489ef9df7b0757e0b9a2201630a703a63dc3ec871481aca260312b4ad1e8df56cbf0a6e74d9287d215d33a714066ae5e375ea8231153bb4b51fbbe4520efb4d12d9545c79b13b7d2f46b59bec4502500f95b3afdef5d332fe3405d2db92338301263321bb6967cbd457046efe6102e7897cb097b5c8464fd35419312853d6e9515e8e722607ab5bd15748f7fd84eeae4b1daf36462c06a5591364941f5d77f1fdf0e860e4a125394ea5f41adf5e495ce6eccd10d68ea3995915ebfde4f5bb0573d74901d1169b86daa019d6daf2a0b30c3f16726585649ec632b4bacf1bc6bcf7b9d7c34a307c5882af6f9b743754b2a254ecef6ad29d5fed03c900c6914b37b3ec1018b310192ffc27650fcf1411e9e5a62f5d13e3b1c9f7a254daa1ce82a591fcaba2edad6dddac81ef0c6504ecb6514c6866837d239e3396469783a2dbdb9e5ef67a04a69d894483479fba0fc99958b11829c8eff4328a489cd77b20ed28ac821cf736cf87a00fada667f88eedc0b785dcbe66aeceaabfa472c0e80e3e14f277fd86999b0f45039191860d371694be3fec3acac20f23074f8257da04a73add810d212958c76dd54ff08f4429519efc73fc18c699cb4cae968d734b008cea4cc77dfad48d24a833c5b99d68a34754ff23bdee468609f418e7ffd06b0098b1e9193b74393964bf3ee4e7b64aa7077a4b7ca208e6df51f8d483e06af41f11bd21d378947f502f61f498c6ceee57ced724993d022ba370c1921d6ce3b851e2ab665e6de3aad9d81af23c65c08326c48295acf0c6373f8dd587b38f480561feb01a8c2f576894f595a78cd003ba080352a4e10211bb612d643d10835ebb169672c15e0285dc4794c720d114c11ba7d22c48b7083a77cf753c2cf837777c6620ae38b04581baf60be020788f12a4b264e077242d18d335a45d72635106d901bebc5884a6fe51dc196be54da94c25c89773ba69f6cc76b47a84b184722bb17f43aab4222a72934c0c78dcb0e7c0f68ca161493134511ac6fc92251d573596dc3c8daa55a184cc0179d9c1978dcf17b5cd191462725c03f1e74f5121335a4c9404cb4d60556abc18e4e62f19a6aa6d067864938f7491eb75acabec155bc7fc34c031b90aef778461734934615aa1cba183f7e9872e73bcf25952b2ec71007ccd939ea77021d20165df37d262e7ca207dec4cd8c4d4828722f4fd02d4353b764b207a7d8483487ebd64264d4f427605629bbd2ffe080b07cecc488a222abf71d043e9f04d77d4661364c8570723af4e57e6c1025508f5753221c8ad56ff0fe1eedb890a7fafcc2d5a680e0878e79ed78db72097d1f08fdc73e6a478312a022b78284dffb0a8d80580748ac3e39b4c679b505e42edb35cdfd9d4e26b9ad6cdcbd452cc30dbd9ea27bccc096716006447dc50b36dcbe6b6c5da47a951ca9c218b493943fa088a7427fef339ab4fd41a7e436c4e186285a35d30d85ec83b84275bf574d9479bf7845564a844ae35b398d7182c7f773671e58f0cee2a8432a2290fca7996b894892c64f66ce8f818dbd868fd3b1c584","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
