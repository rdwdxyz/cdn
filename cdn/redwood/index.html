<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42a0f6142b76df433d9043bad0131eafd73eb1b77291a3c5c3ee04593d1f86ffc0aac85221513d43542026ae4d60c0df05709023d9cb06c2b1552e4b3906b973bd3e4f0982fe5d1d7b48198c8faaf6153c170fcc0a6b2c9a44ef5c4177f44733dd2b86660b6377b6adec416ca9bc5651367bae52287d6d3d6245d3fa9d1bde86547eb585b17b1178eb65d11495e87ad186c731cfb0e1f83d4bb7d88a3aad3054304506b5e2dc37104eeade09925370aec5d0c7f3105f715e4a4890414185a769e7219167db3887696ed56e9c53fd8b418d7a59a12e1effdfca3b231f2c6feeba3fed30ceca94bd5d52584f8ff4820ca40d5dcdfeae1443ae0e6f9eae368bbc6eac73542c3378a5ab2302612d36b617c999c111842c186b10fd98e1963b7ae85dc83f41bbddd04c80b6e33aaab3bde8e5fc26bcc999071f630fcbf9638433b16ebe7028d9377e1229c155c601e2b5de5c45c9d466fda041418bf20c5948bea89fdd6e4dd49705de757c45c636ef383dcccbe376e09998307e42ddefc46b6c1153dfeeed6ebd244c961ece6bc2eeda7aa51eb4d875472b67a40c06c60a9f873f3e7e2d2abb9abe4a661184d8fe54c981225a9d93736cd4af734b07caaad9fcb1e280d51aab793e3030421fe337b9769ec7c3307c0540f3682d92ff67e86a83b4c5ad899a4030bf9253e82f5c2e9d73d0390274c7e4a06969515c39cc65e42844f2aef2ad4dcc750640f88f2f4383ba0dbd761b21de1babe5a779a9487f617088f92577263142329c665a2812d59503ebc2d6a5d445d91c803f6c0b612f7347bdf017da400507d8e713ffe8ed0b6e1ff9a9bf2e35b977969d806fb180bab6208d584d60d323d90b63b4b07774df4026df1a1943bf8c764f8e3822ae35037b7604da92a633d9deae56afa76d0e0e5a32cc734ca521aa3906118c17726f9610deeb025df6b185c8191ed8c2ff7e13ac65c5f4b2883e0cbb6e7b9b0ed149aa2dd0fc3d188ac92b023893f4c4b9955d00d5ff5ebb726374d0b56c30a428b9d8f9a31036d1657fb59da5b040ec550daad1d74a73c82e7f0ed66d55c51a77287adcbf877846b804a3f58e4755d1ad05af3283ed75b8d3b65eee1b3b924a26650651cf8160c91b0260cad6c21712688913bda1a70abc9b90db003a8db1c21f7146e1fc4db426f7deeb3cd6deba1f7828a4a987e5c8eb765df6de94498d54a1288c883799a3acdaf7c81fecb5aeb407e90c4c2037da9157c5eb719c6124b9850dd098a06e0aed35a1ce1848ef88fc49c0f5bbbfcc45c9e7368642ed61ba0dd4308aefa2320de0cfbacab691e13efb00b2956f82885b0c88640e6231edbb8951d7a84bda33f328143d366f1f52cdde6194338cac2dd637432f6e42c95c59ab3c3b69880cc3b7ef3fe911aad0920d75c608151447fd2f90327c8825e04fd4777380d0267839972fa662206d0e486974e1293114fa0b806c75b6d95dc746740b05016d57d5189c4f44df345acc2008edff4e2cc8f163e2d2dfa6c03bd8064f7139032168dde8a434745c055ed96aa58a448eac5842e758f7e27fcc33e2a16994880524f1a7fae203436636c5d023e57e1373f6279dc8aec1bf737d63f73c41bf10ecb51d2daa07b62d61f1f3433cde5d2fbe4edb3083402b0f4a4d335e3f8ee593f0723972bae9a0423a51ad14df27fcfd504e14ce44e7cf7330d84a258db88f26530323caa8de05761e808b1b0c58eb3f5b2deee61fdfe98bba8cf49545dc8faa7d60252f84b93570c9112300c17504b6841c53a0e6e35bb19613dbc79d84c9f77869938ede8d6f0888c4f2662cc48e435782ba39c371ed5ee1cafc69633fe58894e901dbd605c81411817a004e1c14e088124cb7c1505be725bc4253e9535971e732ef3bf4c1f22ee81a0b9fa903de0f31c8fe11caa6bd55040ef88f6028348992c94d77f3b68459a4fd48125bc4a2748f7ca7c1013421a3ecee550b5e7e98223381df83c0ab7d0a6b8fdd369a8f4d2cbab0429ad128dffaa24d04eac10cc5244d4aed58d5116672246f418aae2f35613b42d9dad524b587dc433bf156c8dbfaa671a093c07c8713a1ca4cee0ef1da916802971f911ff3504deb3f4e82b6bd2965329722c9e187c735e28ea3238a353cb0e4afa1236060cd709572c23df61ce0ad4c47ede78336c528e5415f6828d66d9e9e3dcffa7d5123666ab865cd59be4c617a5c50f126589d6ce9c89e37e076ea04776ab8e6adeecf8897fab22a57c240cc09f83ba03352318aecbd00a1e7d568529c41e4d237afc274342d8f58d1c49defa626b72d14734cb226c05366d3714dea86f5ef3764a072a29ea56352fd0e4630c9e74942ac5369e2d7cb9008dfd2b0704d3f5eb0e939836c5954a03c8f0b100e00948b874683180b4db16dc0a7881c90a0ff95729d9972a947ce348e13215775f97e00293fbe4d84ee044ebb56ce285b249bbc5ee5fdb2aea0d48b668091e76cc569aab0d88a5a4f811bc5c6458493dafa2a3533bb2626736f3cd07779c18ac5535b3a0c6095da533338d9abb3b480797d4d22c81ae03150e05b5406c07fffcfcc2a6c0df51648ebfd691bd6fc4581ce0a04fcb2d0e7e7bdd29f0cad818f51158f8d21e1b5ff728a377b6070a9a54d35eeb7161e329b8673aabe48ae4a5e7eea3e0386a5aa2e5346cf2776dbf49cfb45c6cef5b39880c5149505f7eb551992e18e4b6c9526adbd19dde62f9ca8eab10bdbdcf9cd09bad905d4c4835074c95923945136b86ac6e3b187df2ca2ac78c8d1f10d8bd4b87551ff346cddfa22fd2a044a7bbabe8ecd919a8379820d1ae5da920879f07ecd4e5b2390d18ee38aa1eadea76d22a4d848c1d9dcd979dd4206a5e7e59a4aba887d8bba75645b0d2aa873b7f39e0ca99d59a1a44336ac457cdd6cb4a8981bba83c5f82c4fb071488c60dd15f420775ba54e600602589d36b4ef05ec64fabcb09861c26f3de0e7615ef459769e33fa87a26dfe037c366a312a54bbdc6672cdccecc33f8ad8f157b81ad150371de931bfd081b11ec20ac2456c96aec9a589c7a7ab4fb830fea7b101d25f71ec8ea8189db4a5244eb0ea6a4aed3d4b47bf4b6483f887c9207919a84d8bee4c2c68b3fe3cd566d1ed527f76941b4b9fa63d2f7aebe0df3e98572f2b7708a47dd3b52d7613af7d72ff83be4d5ec772bc0d46e8cfc4775d1b49d28e2fc38a01a97749fad9ccdc0849a16a7eea5a5f1e2db26ea902f53781141c05727ff06525643811403aa9ca65fc2ea764d834f23de9d48bf4c1e7fb5046f829a554196806002fd4fa2e14cf31f33c702a399c3ba20f0379b1a7f5b315eb9b156cc2251f040d95d205aac95c249d5ed5115a219ea3de87e928a74a80247fcecf895cc3035c3f47f84e87ce24dbb8d508c70ccbe59d8d6d64324830a698c73e882efb70da24f665a99eac271c1f7b15cbc61f79c72849ce611c38c187417ac68d50004f2bae456b36b6329c949927ebafd4cd90969be009b4958ba75927259fb695bc067eea434a1cd7b9658dd21ae1b911ae7575ce49a1f11c51137040a763df438ffc73062c48534711a12710f9043e46c2b4037ad9cd8808896ac8e49ed3e53174d3e499e34e8950f31f8f6bbd62fab45ac401b34a08f5aaad85918d0cfa5f13db5d0ee27b93e3518a98fbba8bf9ff03f286dad02a70dfe980a41a745bba571215536dd717ef72bfe5eaeff2505f4e99e3a5c442d6a800e0db4908c8b5ec7479d8a19d90acead26d815a408e885565b65eb94feda760da03ad712c766295768909bd6593d6bd7a17a7999a58775b5399189cf28ec20f21d16c19f944ec054d91298daecc0de97212fe693f2303c0975f64d3a6d3ab37d0564561b8d28dd6be518909d542497c9bca62b25059b952a753a03f1274b6f51d6c10075f7ab061bb41c93b7107e16513ab87fa25873a2e8ad4d15db6d2b52c29de7ceed212eb44a78135d3a4889c3e0e1b85a7cb670698a7e3a92cc59c3f8e2c9ac3a31bec3df520e07a02a7a9d3ae0074155d66190a45475fed43fe646ecc81796cc4768bf9f261f6cd0a77b1bfca82786a6cbcb3fd6cc9843413c834c674525717fd16382e50786e93a69f22e87c562f4ca1f598fd6b67246baef79e4524ebb6ff0494a6e3bd26d1e87c80e2d10c112bf2252943bbac617fa83be60f05460e6bedb771f533c56e3e10b50cd85690b616181b8fbff72856ca4fd48909909d57c46efd3120acf18e5f37bd0cf3e793bf08d74baadef424a0804f10f1f7129d4d0c69750045170a1a89dc155a970bdabde0f1e4a3cc0887f4befb32fff0f86b0e9a72711ede4f2de7e5334e2e8eb01e146f5b2fbcd6fdc21c377f93cfc63360abb74810880b63bc1211a6f70ffb5fb484e3ec0958d0a8998442720954646c6f05ad230e5b8c82d474f061a146716cfc6955c2f2a682ae1b1f9617591db8f8754a0b443c5fee51920debdaf8d0431767611f5ee82b544b0717cf3d7b201fac3c7965f09293024a30f2b79ba63a4dd26007e3e482e49730da936157f834e9a1ef2319be47b5973585c0069f299a714f99c063d07fdef2ac160284c2bc19398edc43527074e58d3bbbbe8a2cbe72d781d3f15db704a97d0ed61704c120b2c554790ebd5a3197a9bc5b1617cb8782bf220a3c962d5329a0ff943ee7a25165cec265eed8bff06ee78b9b95bad3737816d49e8b7f600d0494d1509971688db761e4fb3fc786266b8cec73d5a4f8021151dd822a2ecffcf59fa06f1f5b81006505fa44f0d45d16dba03319a08235bf697a40bc86551b36c86fb61cf064b8905f0546425f22c5f07edd111d290d55203284e8ec42ccfac3e9606bae76ffa31c91554cd71127c4a4d02499d715ae6bf68123143db0712ba25c84b9f9daba02df6e31549950493671815527a9ac35f9d359285edea1b12908f38f81f124b755db17b23fa06cc4bb31312c367f7deac49c50e76b98d3b64ccbfd16cae5fcddf3f1e1fbc1f0ba73b57f74a996f9a983a40a8ed900ee03bfdd5a893c6b99d41f431ac7db27100852182158f4b1a5951f4a58b0f89377f2af14310e33f5c2d31fb6406df1851d4db0e5184001bbed5fdef510a9fe0e7b700f16c2da11f6ed6c642eae874c715551a45cac74c2de13286d62b3ca1aa3a3c6bd040915d14603f9720ead1fb57b8a873d6042dee3f852735d3626b762bef827b79911591a753ce05b0d0f0aeb67814b1954524ee73fd544a0c4811966ea526d1f6482d0d539dd103306f30759ac07dd6a2c55b826f96480bd7ff9865598d742f15547ae788183f9e731af1b6f6f634d93216f58b7f2a714e1adb4c9eddd841915654344021307f3ecf79d2e5ad88b89bf00d9fb9cdbb2339593c108486943ccfcea3b707e03b17afb5f0a85f53a2b091ac1bad521531b32275ca80fa6d82103a7af8bed4332034ee826386ea4e4fb311698c863d522162c9353011ee1b12cb05816866801a7299aee67b513ac634a3156ce152279f6ddb8183d653bf48c9506484f99b88e42a696bf0b27a833a3f0df0c79940bfd0d525b27f351674c1e03849479d86a55bad12a3357961cece0fe5bc99ce06db58b850d73b2a0aa500e885815d6401af9b2400cf8dd9b6a7db2da5d6fefe96e056331d30f0847ce97fece7518da5aa4e2528215580af0c5aaa58cffb2d5679a17f2aa312d572e5e642fa6884eb0480eabdcf09fedcde570029a36379098f4aa96c66c427fecfe4103872f73ff548d802d563129236ab9ad476204b707943a68dd20545910117c10f9af7f98316c99a14fbd919231075bde14aa8b94e4318ed990439245bdeba64fd7e84009d95f1f6766dd64962a60d6cc680ab6f8612473de70033f7ad307cf97150f334d43dd7b52935d5cc5c2c804fc7785caf2ed5110ca233683273578667cf2bcc4e36698467847be1179666af0a7482db45935aa5c9a07e0a8560bc90dfd374e9cde3d3071087c27a2d93db1eb8d06c375bc471091fd38b48efa83c9b58c0ca9a9f5f4e468bb8880eb25b1adec35d1c598019c95e99c10a5a57b5729bb9b220f9aee8dd000159708be1603e985c35451a11d484bad5703685f02d03c79013f34633fc46fe4b153e6853e11a6727b41e26d10cb177584d782f13be4c5e694c7b027ade10ac095ac4849a2876af7ae570aaab34f442499dbbc6a2928e1b02380f24bac9de4d7282a91d92678212c9cfab75be58d5d2081f6daf21b79b4fe445b7ddf14110d6edc422af5aa6fcf9c7ac5d841ec7d5adb7f38302f03f82977f8365a67b76394f185aa4bf7407e04d3979e80fc4963ed07067d461d82fd3ddc56b5afca639702a25e37b9ff783d4069dbca003a3410ace2473decc6fa02470db4b8aae00bf90daa531f89a2b66496628582183677193f3bfa378ff00fb91c47fc52b019d7a88af63aa7701cecaed6f606bdc7a51fea3c715ed15d8912281748d78122804fe45d4d70a12c1ff173348de6c316389eb98a2f1c92d00867c427fd68f3a3b9a8a6aefa6102c3ffe375026d3f08f78c2bb3d86094e18b6a2340167c21abbc6e0f8bb7885d47ab9dd9f24e4b281cf5b8bd65c65bcf1c0b57bfbd763c6b93fb504f91e2bc69ea6f016f3b73d72ba8421ab27ac7d3bf22c78935ada4e78cb8b119ce116d405ea3245cc80695244158f89c4aa10120236ad4070b0a0b8015ef53929bbf530c22cd30b7375274b09ccbba267642fa7a3306eb66cb22ca2c4f5a6aad07da4b26d79421dde28b3eea946fbff8a7795c71068a5af47ae63319bf017f24b8ce69e73d41d5c56e29b8c5a919f9841b4661b5dfb27f9afc7633dc9be0112a70322517283f9b5229d91e1994ff813cf99800c46d293082940b1ba80af1ede6346c0d89dcdb4d71ebd5d7ced21d021939cd424c70bbc847f2d923f5e5efc1f6afdb0b8ea1b9f025c0ce7cff0d9b23d74b01bc69942ea124209e134b868fe3fd95e91c5b7ee8925f3ef902586636cd11940840402481946b06c1abb7ba35195a639d5ad241b9e6c0409c040b2d20466b41a2bab02af9e1bc16fdfe23da01bb7bb2c346eca54152c536dd7aa431f0e22a0593250d865c1eea03bd59d993fcafa38fbf7d9b2e1379043445a9178f535286e8ba43ec3a8d426c8edbc408ccfb7b15b90ef83c5c4663e19d7cd562f812294e837c3a0693e2578b7bb40f9b543a38564908a4ec49de3731a3cd53a783063840e80cf2e9839d0b09240bc4a6a9c4315a0193b4fe1a3098f5a82a6b5e7bc27ffdd608942a1de56811b3bab10f232ab3e16720d66bdc7045f6fee28df3cc731c1c3aba35ab411ad0311fbf8a92259cf031fa4fd47ae18caf50eba3da95c094280debaaa78e8fb98a7a3abbdc38cdbe5a87ff0a5bf97e6629534cca08891d7fd687df6c239f509b94468db547e8a5c0910516e1253253316348b6c74215b6f89c05ba670eecf6c11490836749ccc7e6989dd77e395cae801f353c02b8dddb63dd9bfc50d129811d86326a1336cf7f705d2224cf565df1ed2f795b89fe3d05ee8265dff50aa6e26413301b2beff08b8b282d88e47fcfc518d5550c2de30e37052398919d4b517b671e5e46f5048a2427fd71bd1324e6ae48718f3d217982e1fe358bd7fcc277707a97f43b43b8ac5dbd466adcd21ea367133c5129ddc268f6abb40ec938338ff6de852fb0c2c769ac9db8355e67f3452354c6c4b58b971ebe3b7f477964102695e3c439ae57006fc50d620e61d7c7a59f0a6c0d561cfe6aa0ef43ceab1a76572a6c7b492a189e2713fa9c4853778518c19d9ce616a10ee237c47fb43210442ca0c604ebf3a73f059844ef14b1936d9e1f3f4f5ef339c73232a8cbd578f500915c78cc94eadcb4bcfc0544834dbd4cb5ac182a71ea35434bd4c2df92910de01a7f42b09dd45a1fb5e768342431758e1360b84b0be0f7adc406e1a8d7185daf725563f3ae9c52c5efe7cc4b1a2ff3f357e99a6b0f35a157e15aa4ea6bd13835b98da9dab367c8e1aa720d2393b4f507c91d0f7f232d7911077157522887396bdeda0903198e210a914eacd78b380b3c916d2b9a7592b3ef01b44b6b1451459bca3111dcc63efc532677dcfa63eafb1b8310a707a032475d7d90c7db5f771128a0173f23b59b324ddc7f8208562579db69ed1f419588026681785b74cc94c3568ce61138bd55ede9e7cf970f956dba3e9ff2adcfa702d95ba4c6cfb5cf0c839c8386fa55bb0ec5dbd60eb0633ce52220c90861d8b5d65c7a1cb111ecab98c3e8bbda45ed5fdf6963fc13756775426ccaf9d05df810705bdb6328f310b029ee2dc38a19517f46d71784315c2bd552df74f828620c9ccc8baf546726feb9a5a45c1c746239bc660fd13b79272f1c0311e0413c1bce10ecf4ddf48fea17dd53d7fe4879806077d9a8aead62d7e7671ad385d05312a51179e9a86e3605c6ae1d6d11f72d8e2ff6f9b8b06f083487847fed572f6cf86c67b2d11ff1059868b064022473f1072d38f63ad7d4307cf194533f707b19014c0514f53704ed6222029390f8b566da3a85af53cd81bdc644495c4edab8b213ba3eff5c72df22aecd4bf49e7ae103a72b011910ef226cdb2e14852b500eb9325f937d64111a4380254e7aa2add7fe7708e42d6c61f76974896036f67221f24df494309b050190466db9d9781efe9dd05151fc046d92636ce10c726167593fdfcfd35f762d89b04e448cc30f194c8b022980f5125dd99ae5c9f52b23dd7623a8959c7001611d3f79502b2581d4d686fb928a23724870d6fdec27ab121799261903bcf1335f40aac66d13e4af1da832e9bdc30c2473768919f9145c5fbc81e8f5d43eb3b41a38e1ddd0d83d74d3d58e8792a8002cabe83d49de0a2fecafd118d8ed73a8aeafbda6967cb31842d2abd97fac1062d45c7b06cca198cb016b7f7b5a64d9325691cf02e2f70b163f621bfd67640cca07d3d430aa0704d7d7eea7c5a1261b4ae4b52a8e0dbfe873871c30543343435aec6ae5fd54663f4001df4a2c9b7619a037d85722e368f8efd5ea446b9680e34e307aa325deb1febe97c3b6867e3dbd2a42cc6c5bdb2c752cc3db90cf484d5670e699ef03d65e0c19cd29e2a558ccc32590c7404a1f441d816c09666cf972305bc1de90fd14b9b3bb0a9d7af3e0f73e8540b5fbbc5fc77bcaaf2fab71dbf952c22e59a9bf66f044a48a615c1df7cbbb03609a60a0d2a8a2efe6e534f9ef4385653ec36b30b47b0c04ba55299a950c1992a9fd6c2be4ef2077c772cf10e56c1bb662679de8f3e7ac1f7057dd7fb58b1407b52abf0aa9a415c0f8ecb84fbdcda80b84e01a3c40b817a29a302930565a3139f3092fc37e1469b017ddab208927587465161fce7ecd788fc292a50b587e8bc7f7d3d5bc4d91019255d49e4ff4cbab358fd25850b98d4120a0e6c6c6c859424a43193433f271f1fe75405d21e3347bb79da435e048820171054bdf2d11f7d8b08bceddbcf0e37e009382e940d1ffea9d5795b169b7c815fb070771f18269fc42a1554896bb6cf7c4f4e3df17a76eaa7e4e218a54c7356cb3f11264077555b38de171da432759bb2ab1db899466f0eec24e54fe75c7ba224077fdca454babbc35e48ef6b7ef951ca90f27b65cf0a07fabda03526f1fe0a8058a5a3ee54319fbe0f204dfdad867a81080dd113732c855e3514f87292bbf754e86f34d069fb15d9a5107b27c36fa1aac4e59d8d565c66190ed749edacb7077e284055c02bf5bb63118bdf487cb4e4e8f4bb27ae55de5321052b277055474a9829604e3949a6260ee69088cf148229daba31dbb277534f30a30ccb9d37f6d1eba3fa2d6eeb306753957033a3079e4c80bc6193be8793c31c8c49c41b8a7ddfe321d0b9a9f96090bc16c75fe3b6a4852f687cb991763929dd7c174f7d762457e9722f9c6121bffcb066f99f0ab1b3d36fc519aaa2a6f9f990d0c8da63baba126749546a522f8d3086d632d2f0e94cea593ee9c41771d4abdec99e7bbc22cf7b464c2db8cb81c7c3e6beb7cc700c222bf638794dd1508043122c219e3e93dd4ec9c70e0b9fb53bff43d0925a8c426e44edf7ef48a9ef49988d41c8b5aabb1c7e438fae9f6eb2252c075ffb4fc709e93ab69e94d1d02e2ac5090f8bf55c08c5940624ce99525c3a463556a86efdeb1baa2e6dbb2d54b38fa097d7ef9024fc87eed392e70d45522d1798d5772e13d6e173dd0e506284758e7a4a176433f49d0d1ad36c1d476f223016045d1b12ae148fb57fd3b682d28a4f32f6b9c7afd0ec1b9859c23bd153b94f63075ace461071c64357c2c047b6a1b67c98baa48c5fd4cc3e6a6105de88117824763e37c9d4fb0ee787417a7f477818d92a11146a95f6b851ada73bce01505982727d7a73870ef6d680b1feee3ad2796d19fda65f6d1d413343892b5dbfab8576e3971c3a9ae774d48083cf58974e53a1dca9e37c649861897cce3451a39b85c1a1565dfeb467cf6ac591f2501126cc2a5b3d33df8a3461a3f511e5a8c8760a94a1e71802f98315127a26e3992d80e3d35cd459455d8181960569169126b6002aaacedf09c2b335cb78fa7bf0a4bad59cfc81c8d802c46846a33fb70adcbbefa1483c8ddaea6eea32bdb583fcf79cc4f47f3ee401e3105eaf320499cecda03a8eb567b0db6f567774158ef94dc87c2354f89a57d8cfee7e11cd670bc143f54f2a00e71665e9fc183d9b2fd604dced78e5adeee9c90484131993605393e484fc2c6200ab7c2cdfc068a6ae205365a92c048c9bddb707d9a735b26fad8fa42c48b217f017e63a482ccb4e922b5227818f09e119616c2889adc4630769b40458125dcc5d73805892f8e31978d05605696cba4fc9a7ee479ac0b83545da7ba7ffcdb9573990fb26f5de2237f9f1b77a9355e1416ddca923a6a1e7ae3cea01c2491ed2e9ba82c7b97924861d58b9db38cdea30a62938fabd332ea36d6b3aa4cc24c1e9c25a3115b79e0c5c0d0e667b474fbda5e6d9fcd9a7f8c51d677d9ec113dbc1de421bc42365c9b63f9a6c8089b6d50e208055bb0ea6da1ba09547dc5f0827e8417d9980af6469bceb0996e21e3b2599e3ceef5ca816db563a58bfef0d6c4d9b8e0e5ec35a73637a57ce8fb70c3f62027106e535613417de64829ac5cfbf1c68a1de828f08d3ead1771c06df78fa1a3db0438567238464b720b18115d49bc840ae3d1eef80bfb75db6570e8a632a8336e96a1824c16dc504df5cd3bf9a9749f3d73999a470f8c24eca72ef06c818df2838b3aac593a2aaca1777edfc31818c68a5b1650feac744ed98898084304d574fdc399dc6dacc01ca6758ea396d744420f207e2ec8525c7b6558278109dff9d2ae2b9c207be858fbb803ab2e772ec468bc9f261f4b2c926d595310c28259907d60262fbab88c0fafe6ddfecdd0ba05f5b7357326773c7b2f5f5e364461f9569eb42d6e8dc857a29a3edd682aee0cf73a1241c04c82bc81bea73a41ffc711486a0e25160557e1039fd013b23416d2636515e57e0337a47171deb1d09e9d2b79bc011c110186cd7d342cfa443a348fb2d95bd6f26f575dd8a5d5c0f5b178a830aa47cadb7a1180c605c00824c4d0da478917a6a04f403f86d5732f4e98dac0ee2fa25f45000e179f8bb4644eae8efb9c5837cb87b72dad7fdf7713fdd52fb0b3eb0d501d87be86db6e08445f1fb88a51091e3be06b382e665c6585569af843034ae4efb48a2eebaeaed560020561b3c17e380cd85be48f3dc0e694dfa576a1d7aaebd4f5deb99c1746c5cf02c8f828d2763292d7ae9fdafb8e7b22f08923a0fb49c596beef025d9cc3e9181f02357a793a2068cfc08064c999c8b2ffa190b97143f03a13b77372094bca8710100b392c98be0bda8c2eca5d398722aeeeaef2c7d82a1f7de70639033f15b72ad00d9ee6201aa31e8c22de6e2b819c7f55727a48f7d64a93e076cbdf547e532bf241a230c43f184f45e0dd76641c1db80efe02650ef03a87a1091547a7cb03d1f0b26f07d84d0158d241a11409e8c0d5cfcf81db5ffec9642b01a08deb7087be88d2c9327c90db20d33cfd5a6d3a17678c8e5ea36c14db5cc73e27d67619b4802b4abcef3a081294580fb1bcfb1dd16bcb3a5631d013e846d128a34ac8fd7402d4293daeaff966e8df3b51a7f25c670b369a7e0b2da0ef14992fdbf3a61980dada402c7bdde2331d7b658e68687886563eedee4d611da96d3bcbc2844989273e1f7a200842c27757cbce0bafab50a54c2474ab0f08258c92393c0a3b8a3b51a3c9c9c483aaf30c43ff6b11bafa589e7e8a19fbc8f602b2ca4cedd8d5da5cd35b81eb06c2ca6ac1c38917c1e043045dbb8e8f31d05c71b8910d6b61eacfad8bb0171b89cd107f756bbaa84b867e89783a8d4fcce574ae85fa5fab6856e351a88a6ae1aa5ca7823f5450d1b20c12031d6db5d8fddf53ec119b0c1bdde50fae22b450c4d3874ca3bcea08471d3f0b804b8b612eede1d741df75882f6c20e27e03a8567490e9b1add3a29fc7ce3a3833fae3648dfe718648979c224b6aa2c487c9463061cc9e9ca0f65e5648846045357b90d84398082be62307449d2d08ec63ffb7849ccf7a6e68fdfdf3aa2de568e543f8868689900dca3a3a46e0da921e31f5a9e06551def3812513a976a892f07ebfc925ea794290847af3da2dd2c7764c7a31b7781d7d32119a1442967c136671b1a2eb57b5241e3635c523280a7ed813599676940b7ba4d43276fab960fa0b0d779c660ad0bca9ac66e67b17873ab45b48b374f61c5c12ed075a1e82c3f8e7412c016615d3f4033cc661125856eaa87d14c0b5fd8a4f1ad4f20394950165b05d7b8cf6572b8ad2dd8767f21defd9cda0c1502bc7d4861281de38c819d2743bf70ccc679e2f0b1e2727970d757580a76feef18fee3d048dfa3de00ff21eb4ff34fe2c6ec619a9ec9d6b4d4f3845c4d53bd95f5789fd88001a9dfc6090dc7c181cbf2d19d90924c3dc120c91a2f772a9b8d8d6ad82be066ff58ba221e43daed63cb82d109a9cebb8417f3480d939c8c73517a87a017d68f554e8eeee6777ea7856ef2d4005bdee62941ecec8f4caa5ec65e9e3e229a332d55e82e835921c4461626f23ec89ce0fc1ce942fcd7575a9c4fff5ee3ba914750e0d9263c90f120f384b88ff0b3348ecbf0e4beded00d56d79b9abdbcce55846a6ff5aab6440094f08c1340ac2717e9e101eb715e50d48350fcb5500dae5570b37c66d2583534708c34d4450b6af6283c5299824116e2fe1c3c8c9000bd8baf4782528234f79c0908a9945bb7971d7655deaf6640d15f8c18946641c7424c2c2e4f8d1a7656e700cfdab17dd114dca43dec770855cb7876572c9f8e6e8ce8d416bba0525e96263beb9558f6228364401bbae8fc99e484356f9d37f31c562812cf274db8e6749c9495ceceb0e170b01b73394b2b75e4e8956eead3184b203268b1921117f53c91a1b218077b3d8eec295e04d209c9ed8367262c920dd4d41e17466cf0a938c03b9e38921156bcfa6db304648232bad6961f498e9f339f7b30c30762e2af34c54421ac8e4822aba13f898d9d091e6a5b09544be292e3e5949f9a7aacf740f7ee66660962ba9f0650dbf3467b44ed8fe4427b8ed64fea306d4fc334e9521418d18d1bcb246860cdc92624beb2427f8e7c009becee624d98b7bcbd02a5a649a8adcd9f4488b4d914a9306316e6a42d44a41ba102bf181e78e3d7d686a6fd9f2425e6a4e1eca54a44a035cbe541989e669e108b815c0772ca53aec197715980a1834864743e9ce5d13302844ae9de64d301a49182c826d0dbb1767921b35dfa47a8d7e04a414cb3db89ec222b84a4a1c797c078c6789875b6b8d7a538ef38aa907a52d13204ae9d4afeec1ba3a8b1dae5d3c620ab8f95a57754ecbffb8fd3cd9fa33bef9dcb212388e792561bdfa19b8f8e1a743203e47714c4a0d0f03c1a95895936fa4d4d1cdf2cf258fe7fd6e61b4d8711d3ad511c4e7e0e227eb18faebb26daae88af2fdd46f7f5aa59eaf7a48ca4deec0bf2cf193fcba40e1e007d3d8ff4545b244d5933da084d23040967fbeb38a3fe5cd0439ff9fa662e878e5c386af34ecfe99f77245e4a95d8796622178f8aaef2a49709f86c5294643af8e4d3b8f418ffa430c255d26a9572d279ae52470bc02327002069173bde8ae7e0b84f8924f522338ff937adc969bbb7af6e4ff1137dd7391e96939999b093a2a0c6be27f1f2c76fac902c6767c8f8daf9cb25dbaa1bf6e43a59bc31b9c3514795963ee2b6acad95ed97ad2fd7164e1de324dd6e5c57aa1ec7a04f838d7f8c7ffebb0e733c9c80b48ccf691f051ff907b8443af47c7a8e0811deb3fb7a0621c5ef3d34e09e515f301166325971080876f3477430f4b6f75e8d43683c246e446dec40523222ea548b7f0240b198a9b431c68507180a6ce0b657508b1faf2eda4b94feb5aadb76fe78537fd87b3e163cf63a16133c63c9cad9d23029e6b779519d4e192092f450f7d0effd02b022e7828f92de2f346ad0e3f54aa9bb658325d71e251bc440e28f0cf95912276b2dd8dae6a7daf4bb8044ac72395304dec9a5ad39f6e185380bf364609625c756b21b0c62d62926c1f16d6045608ba9d2d061827c7178dc629edc1d34b9718aa928813195222f15f1b36f505f738a96522ebbe980edbbf78df5353ba77c4c0f8cbee5096cd9f9b67d8218f51dbe4d884588b1f14655dcde15957a73aea9c84e862a3c0e716d9d877d97fa0c7a85fa5d688b7825db0578fe0dde6194070207814531150c090bc1162702abad277e45709307d7eee52046cc0190920630504285c456189e59d0d3776b89eecac3783db4e845ab90fb049e332777800ec31cce6da5933b04d6afeae86e451b4f143e0ee2ed289a3998d8c73e7a75e220f3cde3c3b2ecc7713952eb1a32c352ddb9fbc2c55d9eb5a9cd732a1620e19a75515afd1523164717b67e4e467bf8a9056eab36ef67668d54667c023e8da01fd38bc361e5160b916027ffe945903475fe7374d4fc0cf75498af61f7451f662af53cab9a511c633d5cce78b63bc4f2221b72dc79a855e00b03f3bee5b41b0832ebd60482fc7f4e218658f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
