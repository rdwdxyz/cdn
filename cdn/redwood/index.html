<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c361dc708618441c5a8fa1efb343940a6f8dce1ac5f63446eb29e6c70beef0f34d599a20e8608f550155590f0b4634ab4d67745792a51a587b67f67286d58cb54d5995cb67e93e54adf42b3bd75c019591b2f316beac569c70bdc4b908a92721ee4adf71663e1913b9c1d5652bade47017b88af15efae11eb203403ae7c2a63b371e052a6dc175dced376fc2859ce4e247efe7b3946357e232279201a705bdeacd4be568c26b245171127d335b7c1d2f3a40a1a66046bcad158e96639b34405a709d450ad6dcd472e3db0d6eb0e287c4136451d8905228279bfa6ed750d58a2b2df19d824208e43f986b86b7ae1fae8370f0e05b4e50e70a99e2a58ccedcb035a1b12ffdff7cda94174981b736ff83165fec1a257a48de34a81033e4340fb55d5812bfca64e5601715cbca1134df7ad19517dd2385a65ee1cce388f5d0fb60d6afe69cc334f91425c35bf3aae2a4b31b4e655f79167d3c62403b77792e433f1669415f4c66f32ed2d574412a2d3750440a9bd780c0a748aa946c49e330eba4a329ed77b08a1211c7db9289f0ae9395ebb5de3bfad82c9706889b91a4948eaaa694a5165e06bab4b98f19f1e78895625846a9105dddb3fb39953b4f644be626b66b699b9b52539a02d395d528ed596c11af7987be0129cc96afaecd5da8af852e76f548eb1b780bafa60cd541cfb231de6382807fa5a535dd9ce4a84ff9bf5755581e4d4a3e19d8334e47d3816cfdc392e686c9153da4af62413940f7f10f73b7fe80a7d30f8b24adc4c9ade03ba40518781e9715d0790ffda2e9b65ef1792fafefed839e4db23f27ab57d81d904c916c6dd63e162c99a94b34b87c35891834923a6411e4b53133174d1bb3aff60a9cac3e695eca55b1715f84d9e57a2d344bc1dff8c14e845a27685b70483eeccc8a91701c4a7393518698fff0de113cb744a93b8e92286338b1fe94be9353ff8cddac35e412b879c9fbec79268c225cae628b5d1500c8ac6adf58eb33b0a6a85d0661958bc914ee0f608fc0667bc10983f492dffaea90af4e870f7b2a59952b44e40cd255f26786cff1ef10670d4b053d15ed3175e37d9f8c82f0a94562e20388a6febb96e915b62cea4763b6b3aee9e9829964e2e7f1b75a2294025e4e2429c193c3fce1e9583320eebdc614b1556bb6baeb1f3055bb8e60d10cf72458fc5b3e797680be3b5526ddc6dde7127868a9da3d890c95de4750f2eccd6da150f000e3f01a53b0987cf5d4dd310f1b2fd248a161785b0facdeba62703330e67d5d5a0df085e75d3ddbef0029901b8dd1b823ec6a85fb51d13f0764e2bfc7e95bd218a51e856b1aa1a204974cd5ce836e69e34fa4965fd3f1da9af01320645c4b3d3deb9359fbf73a1ecddad971fbe2e49b6b3121b08aa4c969bb92ef6332da1fae9926e783182903c92229ecf402914153172656763e1647e6f8d83c6dec00faeb05c9e081786baebf3cd8d2f416e3bdc13014e0782592bbf28071aa7adacdf7f13a56f1fa4c77b817d3af23773542ff557d08cd9df49769d35a4b2d00780975ce418eb54f7417b6346b3ed3e84597dbaba01f21c60421d43064d2a3c1ca912340c70b96a433a5f6d8b87a55c52b799c429a7c82879d899853c30f6fede929f02f9b009b93b55395332e65918bcf7b8e8b51feb79f1f8e5ef485ef3135f335ee38b7a29b9d294d7b436e6c9f836a88a499fc0c998f8bb93d65a95e2d934a347a183b755b2c2c8b277d3d76ef31a2805d561e50c52e620d11575fc4257f82b6fa44e8831cc28407dbcd282f755cad6bfbfe43c821c180d5340bdb85ca5983a7dfc0eecb87b7e98d416f2e1963916a03f4ca8b7208ced238111464f4184f8881083d8f5238817ed1b39f1a26b9fe33fc77e34ba209df1ed9de28b252e2643581cb0ff55319139988da8a4889caf7e08b4defdb19b3e98af42c428e03dcc078e96530c669673b796692ff229ac46a618d46555e400d90f2686ebdb5307b0b7c385163ecdf7b1747a0a6395f95330903f879dc3e2e6164339c12591194342ed0b035cfde2f071cb17f7f354f4f929733049d04e7d293e598161318d796db8c103e484971bf837ca331718b9a40503a14345083cfd37c346d8ef8fd810df5d0fa452844b3ca6dbffc7a3ba77397c0afeccd4de8f9ef368784d2c7fbbd40b31b0f38dceef7b00746484f85a1e48e9979083c982171c4170a854b8fa55f433fe83b043091836ec30480a5a21d1be38405e19a5a2599c08820dfd8a9a3cb3b22b061ea996d341167c20292ece8b5b79b1d7477b0bad94e412725a355bca95919e6e13cd579549d12489d7bebb7e84319c36bc279dd0a4f432641ae80c2d6a0b1a40e9c95a685278522a0fa2951833d30bebb1706b229b94e6c0638041c5bfb6755b8b581543a9ea6a8cb694c2f1f435fde2d05a242586935cafd664f8ea24dca1315d412fba16b288e60b2b566032a5c231b41d5fbfad1dfe7f43434461d4cab78a2fc1c45206caf723898f07a86f89042ab73dce184f6a094fad9f5910aec82f34aa373c4aecb3ee3be47b35506617f6ed847892e33d7db99844e24cce0f7c326985f7b6d0796f637c3b62093bc8dde41250e850aae0362ad4a04ffccf0cfdd410be1fa13afc544f7c4eae8e622dea58c30f1c98e0ea841d34292b323229d6f32f6ca7818107437f99fc079a3a664456eda5d04878f11cc25061240c0b26e6e5f751c460ac83dbf020ba3b6334d258aec6ca118487ae9d3967236ec88b3dfe7c1cae3fa4806030269f5786d147b26afe6f332aa8dc4124e5088fb4901ea2b422082193f5300b03586b2a0e457e68c9c16ff9e94eaf8e23a7bd87241eb66864505553dea9a5c00b909f45dbac63aca1f9191bc0d0db9a201ffa799d79e906e04a99af08b3b64c4c9928e910801f33a84f1311d7a566048e20a1a521a75552edb8748445334610143a3ae611d6af3fdaf3ac83ddead2d277cca8b55da28572adeefc01abe9dc7e961f13ac76c4d5378f04c4232e0c07a3f2521e3335c837e5fcbd12c014f8066be21ab801d04bfc175c18b853c0bed2ae252ca8c3cef6991c957a13da06ba687a0a5bc82c0c1f93b3c4efe36bd62609d6ab94c901ca88a4c5be9795ef6c716279ee27576767cbd79194fa960aa005f35750ce5188ae20ce97a6eb58b4eda1e5ae6437719ad780faefd1163f249ebec6cae0b30e1170274830403449036bb49d311ad9e5f412b2a2ec7575bb463b283f6fd01539f1c9c8fa9cb41c6483c6dd37e3f244394682004e5d399c1a38dbf775cb759a978e0fac958dd2bc35afc1922f5e83acfa20c6fa0c47db69b482635d1fc2260ffbcdd14132dc43d66a76905caac06ec0203955a4bea48a901ef7affbd22daf850700870572e969eb3acb527608969c8d9d2440dd25e0c53123827382601ee1afced0c3edae43620e5797044f1d41488465a1621baae05e3f562954be118ca7c1a12a9872742d70bd74d9b592a52625432f8443457aa7a66ffbcff29c675f5b051b11ed14171ae1988bec4542235dae779139e7717f1fa4aff48703628ad32abb3dd792d07c577c02c1d0f984949b86af74b8c54a69240087105d823be4407cfc25766e569efc2232c5aa3eb2f5a2b1571d1811babe9d8d1423597a70bd6b9b44c932ce234c86f0b72baf766029fece913ca2688c1f7d723352a9eff7ef5f894f00ae8fc4aa03fdc36c427ab7bdd3457f595308c2ba5adc6fd7f9b35167fbda05f7c49b21ead3211a33a17b5b77c7b69509db248e0252e7cb3624eff5555c1686da090f56eb90df527518fddd337280285700d7fb166abf6eb204fb280fa8f1a91d5ecc80086b4979dd7b455ec787365310e1c8379cf559f7bfc4a9266dc9c1ad61f11c9eb44b31b04cd8c61a31e6fd52d7c7f1ee00280569be95cb73ee4aae0d752fa3626b00a6f0e5faae573aac0069b99ec9b6bb254d31ff5d88bc8b940c6e89cd4fa197599c0375f523a9f5b752d0e424f0edd86d13e8dac8a993a20f5db74ff781c561d0795e2608529bd0d00baf655b8c1c3d400c60d9ce4011d70f453cf10b3ab856dcff302e64acb5fbfde30aa8e7938545a5a8636043ed4a53d8913463369264d33ff2c1792852e5aa556df510d30e6d9a64e67fe44b7543a7a18af4115c257673332908b82aa5e20fbaa82d6cc3669ab6a874b56bf3c59326e52300d2fb9df026899dc2f3ba630704b3cd5208a02153abc1e896a381d80b1f57e611db9c56cbb48851853f222c53b0334e7c43651e8cc96d9b9d3b8bee057079d1b4e82edc296cc9d0007efde59d0ca02c8f843789e7388f4537a683085515134d789415059a768c54202dd623a7998cb59faeef25318d6952c43ab42219f5e22d98a97720565ba15a4e5b8c2d2ac964ccf333201b21df30473f75c0fbad290e6d31f7d5d9f098b0820671ae1b48bac39971a7b7c03f8895b242f45e617a9cd643e2702878fe63d3845c2ff8d6d49b8638ab24732067480deee41b82b29aedaa7452c93e8496b8bf4fead9f52979d4fb9959868c9ef973553d0e0b6b1761aafcaf69b6fc7bbf63700e734e84a45989d0aebdb3ab9f6e4ff185c0ac5865966cd3e4b1c2db797b03264cd6aa38da17a5856831623420c7d1fbc91868d84e650a05ef234271d20da94dfc59c7dfd0d82652abdf8f8e3e5f0e460bc8df09917575f35b56649748d741dc7626043e5a32fbfd38dcae4144d476a934655e4dd94f4bf3c3a6299141807caf5a47bac780f78f440380158d78369b5fb327d5f33e99f3a989d20def72b21577f3445c36ab1a3b7ab371fe07b260ebcfdafc75ffe3a80dcb675eff63261f958ea1119bd9ea4cf8d52f624e3c65b4b64c9ca474e895d852abc89c7e33e13a1683ca4152ea79979a5374fbb8130328d456e3928ba1f49095b852dd8b185b665059f49560d3feac5bfd4f1b652b1776e6ac02bb07cee66f6daf12db319f4cef46dc45f58507df8feba5212196067b17a1c096ff977917c3591a26b348f93aee82716da3a9b3d1786d41ac5bbae5cdea5512bd22115fa5f0053ddd76b172139cb1cf8969a009e3b6ed9b02e59d2471b0dcbd64ab73a57b695320fa569b8487762a86fd92cc1dc38077f5bab059786b8bbbcce7f5c3e369bcca1a612a4b1b232debc99ced8512d21ac29a757ce0b2c781704884c8ea9c41157e424c89fa0b4ed03fb38d93c8a77463a275d9727b0aef0d6f68036a95e8d95823242eb153e7dc5f29a75855d89e19e94a09a8a12832f771b3f6cb999a74fa97496c73ae9f2c66cdfff1e84197979f86c8deb12999a781fce56bd20db009af60499b3056f3a644d565e611d65410b98f28ef5e366fd48d5ef5c0a3ed16c9792a7018e4e85fb5f82b00d82122af3009dd3e2b058b419611aa6b97db1564cd2084fc2f22bdb06fd908a204c5820358f2e1098fefd2ac9c7d7ea3eca543e0ad25fe9f2cbc9585b67a969475de339a086b3674f3d4b9a577487ff4bfa7fb661916dda0054ee69be3d5b2a804c4b7ad7297ac05826c62f369cef6e77faebdd8d0984c5b2a81f6b567a43c20be3910053f615ac519323f4554ee814fec61412adb4bcc99f41c0f3aff8bbed52347ef22057735d4763f8aa1764b69bba4ec8018c17bfb70bddeaf2771d03020be00c5476c001902e742a6c2536aa88bd51a2303315a36f502e01eb2cf6966bbbf23cdcbb8c1a37f0972c2942267f7d98fedd671de3be28241e356ef18605102755eb6437861c0cc8e8603350d88c15c8fd7dff8928409990591c19ea8bc3d8ce4c59886a4691bb375e8ffbe47e5a8050b1fb59ee7c3039691e053de03632e61e373574e33989fe35e10a8002b539b52e71a669ad1070ec23e5d5e7d6c49fd3c7f74e98bbfc20e1b2426ca30bc6971da8b2e7504fc7ced4ff0e0b824665a4b31e24732cf762d299713330b6cfda88fba7342387db97823a56e7892b61201f796ce86cb6a914834af2c1ec5a2256d310e0125032b2cabe2f6a93dbbf5a5c207a06632f0b2af458a8bcd085c28c972c0e9be2ccea3b787f9c316fb93537984c9b321fb45387aaf05f770d2e32515d96a40f8bca4977d2cf5e178f36e6ffba37263ef9fa98ec5e1b7844faeac5fb852998aeee648fa8c46bf5244c655cac4eff4fd0efc1e49d297fa417ec6a2a5b3069628ef571b51dd794db27d1665b3f0674242739a037507da3a4f93125a7d346eda50a82b4dc47da98027babd2830fcca92800b48f22dd9ba13a2442669c3d8f4b1ebef5d75a88282035ff8c1642b98ec9c4064e5e6243f12a93dd01b055a5aab6fc1b0708cecfa578109927744b6fdccdb026e04c749e6cf67a1a216a12c30f7c5b317c0df514e96cffcbeb8bbfd7d44d577efe052f34bb1e399e71fa5681cf90060b47a641d35333bf71776bbb98346e21e471bc8e66b2495630e945dc0ba32f2df545f3409deff1e39314f67091b94a0933206a89343812aaba3a26a618d6a9ef0a0359202f266fd1f960b2c073b36f13f6418cf5eed6942bf0eaf0c4a457815116d42345c913c1374e4c0aa9141131f2e2ef69eec017d64273c21412052700e5658b0233e49219cd7107a704cbe31e9b65e246c8d605fff86c0e1dcd40d8fcee67715d6ea32f2cfe8a8fcae12cc4f4ed918e86ed96c3a4daff92667d538bdefea2f136eb9cd83173071212586f14ce1a8d2d94711d25256077548dc5d67c5d1e3ed2cf7fc2eb6f9bd3869b0fbfdec156508a8d8aedfebaba855dd157b6555c5658ccd578f1c48376d67f89fcf9fd84bac03c7a0d05cc580625b0f31b69d389a82257226721f3b5f3c4b37ef6631e03e885f5b371c35bfee461ce50dfea2205eed745e239ee7b309d9f4804158513ed86397562825e6fc74379bb1085ed7a7fe72e1d986a19956feb0dce903d89b4128bd586bf7404dab887922c99327c94781a31b3fa30b962f319531604264700d287248dd95353473fb7199557cb2476f4ce6bc6e3a9175930e50d80ed4ae281fb6dbb118583a3f0697f093d7402f3c931f01e2654864ad6ba3998fa7945dcb12014c3da7357c58a467376ffefd074981fca4aa0fd38d72345e4f5f7cddf80780efd960f890a079e354784f68a00e8da627572a18d49544a3ae28398e8d9e14307f0901fff04ffb2a5cee404a166bf64de4b78d71a4abb3ecc6bed2a3b4464d96cfa18ae19d16131248530701f627da77828a60affc0245d78081e8dca8eb571c400de7981bbe33ed1c1ae57ffc6c9fc6bf99ab979f7907798b04e212dca0b0ce7af38b055a17a87523470e6bc69d2ac711f5af8ce812ea3f9d183b58e12aeb0183a0a72969faa17622c2f8bea2327ff22b446d04771372cdcb3b2a78938b2216a80cb461984b37f073a06f2b65b276f9f66c7a39ea05fdedc405cdfbc353d567dd1e9cf13c3c8d935a2c69292e1fd736ad150bf251f55c9b46f722cbc729773ab8cb78bfb5b447ac3d2b12e2982d0a0794c8adf1dccf5028db8a103cda8a84df0bbe31048acc02482f782fa2608dd2c4cfeeda434fc6cd18770770edd80061ea49daa3b1465a7db6f7682782f7db42f6c0d4711f0f8ee56ca0b482fc54d5c4427e4d7233ca8433128355846ccc659f75bc689871965a027a46992916b4089bf8d17ae87964db8e3f2e8243ec98da6512b9967a15c41a1438367cd5012a4a320b94061f03caab1a8cbb5aa8132ac75edef9d55340514a8588dd3cd88159457523a40414abef770e251c83e4e523cc40e8c1bf8ddd5cda0156ced66f7a374b37f7715ea448d36f9e54a76d31a2d146861d7220fd66ee8d23bc3dc76fcd6ad792e3dc9e22a0326fcb864f61a27a1ca6421dd9037d0a2715099b0e9a03acd2be7d39afb882b00d143c9491b70b3373ca21710ed6882ad39c4e85d486760486456dece09d0a0d5e73cf376ff4636e384b3787754886bae5c8ff279041eda8fff27db15edf949707fd1a8e24808d6651e8c69bfa5066a3201940b99b81b0f0094a4590c9bd0abddf9425b4534563cf287a875e04d7e39961766414bc2cc206c9fcbf6f71428a8bf20da24d83f0aef64ccf00bf00e15a7e1046bf2b567a30b8e958549d3553e9c8a610d5478f2995ef57a0d171ee52e3d82e4b58bd04a7bfadd0c441f947cb468ed4a2c56837043ec59fb83e597fce8a28dafe1074ac7ab4cdf69b461607c187cf1d98a79da34afd436dfe04cea21a27a0e1f0d9f23ed176397e9c1796d19b34aeec870472a154a9a145e29afa3306e8f5f61b8230de4b4b71b2389e00bca0c780540fd6295e416e23fb7c1ee3bedd0e67039c36f565dc01ecf9ed0faec201d1007fe57d3e37737aa2d7484916f9bb1e429acb0ecbf23f6e51427939427aaba9457a6cad2b28ea6339c11617ae4159ed1d0993fd58178ca2fc958569aa32632ff338e3e92ce5c39a13b7138876e0fea42c0eff768a3b1f119d8b4fffae7d0f892543c08671ad75461f6619079c299a8fbd086511a858bae095d2527e124aabf57a51c3732ce84655c8535fa84fa7a4504c4195bec04f43e633eb48a459d683844dcedf2e9f99786e5f4d2d57d5c9d40ba91b9df6fd24cbdbf4fbc6896154406edb4c8cf7c918340d4fb55019be89596fe6a3f5eddae2721edb6163f3b84033dc2bf644964878fd6495c709405e74a38f6578930ae1716ad2a395f37008da63629031dbb8704d550a54e1952a2040cee8bdba82728d30bffb24360858edec46153c6ba7c7e5f355d0484746014a1feb51b9f8a1b0981dc66633527e0cec07655b9d59fad7e560612267006aea7bce9137a49551f9998d59458c3cd0e7cc6f04379c28d0add27b5067dc33cefb3812c84b24d394f517b7b0422bae8cc9d4f592527c351404bec036c9052187ebe9371e3a7e328ec2254a81ebc9d9fc6f696aa00d122c78a463d924fbce8af499c28208f71d66a6366977f43f519e0d5d3dbc4096b9aaa4a20e033da6bb878bdf40528fb6a4f8022ad08d946e5ec3a084d949d608220c4f6cac7f635acd26a11fe55491d5bcc1fe740baa510bd299b649aa0739eb6165013c5527a97eb81f5531a0b558b5405d81a30fcbef2eb8e65a410bd85d745556e64ca6beebed2103fb52f53eb266ba6408e3c9da04e088453800d411d0a15bfabd97a02bcb78aeda382ab8faf5b532d82972d965640396fd96cd625e5514f19eb38f2ef0c06eeb4d5b47835a26f42ad4dbe55c25117df664d7a7bc76d986f8ec4ce7efef4a19e45697216599e454d4e4a8cf88a1521a8cd9bcadd2bb180f32734a50a6f11cf705fef6199ab036fe7190ef186780999d25faa3ac0896a6b1fbb3b8625408291c7a6db4c879b13b38fb56372b414c21f57900b40a3ca9e99e0296a228b986bc05f7661c9311fadc1360e04a21a222eb99ef10338cbcb1a32801a7ef7b803f69554cc377260e4e3c8c665c024a7ec1faed6209d1738dc9c919f73c2e328fa6238645b1002d2bcc362abbd1f657751679c8e72594f23996a438381df2699fd85faa7e6017c009d7e806e77879c2af5a03298dd3b8f34791473429a6c2b4c8ccb8c52b32241d50b388ad519939f84594eb33eaf45b791b0a379769a0af9d150390ff3d54ed6762086dc7ad60e1845bc3969317527447bf9c4db458d26f26666101955b0fc21d82b56446652458b8c19a0c73e3e5a454856c3e2495d67a4facb7d1498745f57bcf6ac95e1d5845931983ac127949a57817e610424056755a4ecd6352b7e8a0eccfa6032a08fbb8ffbc534afc4480fe678ebcbd446e76a1d43a8491474681a81097fd1e1367271d6664dfcc2ce25d39e79a5954b3f20bc46f1b688032e881cf12bd95eb7a895ca82aa20aa345a85a08f9744d5541f8f098927b96c1becfa8c49d720157c9eac74407e6cbd6ec219459eb78032825896f4a5e2fe698068ec7295c32ab45ac4fbbe31d9e8baf5fcebcb51280c5efa8792c6645796a537085552aaa02ff7bdb6e613aee8a17674d34f9571589ca11a498f865035cbe7128821cbe37792393973c930c81560b82c56a794eead9d126e48d4aed63f70266a1708e1aaf5b97a55eb29a6d67a13a0490f390d9bf242f51dc838af4d3dbf845cf340fc8a96acd3353ff4c427a0bbd956f7c05b9e31ab1f5d9e840cae2f707d35ccfd49b72fb9963f52481def458eb6aff6cf6cff83126ab1f6f347789db4694d1cf1ba989d4c5bbe404f403d489b6381411f215c0bb27883ec3649da573efca99944c9e9c51e2f3e6db06eabdbb4169a57a868520f942f29013b83d21b22b1872c86a5c6ff1a65bac0b747c8a103e8bb53c38f3fe990484aa1687143d3f2ea95a8b38d5addf74ce0dabafbda4001e942a55c1e955383697b127f09d663c026569a74ddc892ea2c9e948dfe2114ac283c6a2d349242493638b4fbb2916b54ef6cc7dad944a7ddf161ce491a70c39019a0a0c307b594212e438edb7dee0b03280a005aee76cbb5477bb16fea5693c453a15ab367efe2c3e19d7a68dda8f0ba626928e8d65be19ef1cef776585397c54715a40c32224cac57be061f327f613b49e5997f65d40755b84b61c131d459a8a0affdb2af772a7ca1173273aebe0bf9c3e7f67fd8397adec2eade75963512a1151b59667b8dcf694689ad3b122b8956875f06e35fd99875b30f153c2631d5c4f372bf02c81e364174fac8d90b18b6f8740c77dd708579c7a50b2717fa2f0cbb213d57e4d96c0e395d788301551fed709e861841db706b5870c7e69fd997d87e63d251e46e19f35f204e527a05562ce402fc945899906229015c6cf221a3015b3b3005dc417b59cf9b7db2eda2332e7d287eb4aee806ae6ebaaed5308aa79ece7ab5cf55db835cff5af00b82f92fc654732bbad6c9fce284b90472eacf625051553376fc8af447a8610acbb53958c0b835eb0cde7656f7fc3d10178a80298cb9c469cd6041812b0b8b48fae686d0f26e2600f9804553ef4f99c005d2200a1b18b98b8093b1742e595feb624c7dc32f3832b731ea0840ad8a6f2c1eda29f334ab1e40bf67a66a3acee24e444e789178f2d03096c2a852bb2bb8b7080ede1c9212a5a74311b58db975462b29acd7aef970f2e06871056f0768ddb390675e2122e758414e67798efc5b56f71acc39d481f6c7c232be38a0bfa7014a51be3fc78a92179e2963deade3d60c8e274b4f819ed40f10982657b2f775c0a0294479cdd66cafff44a2b94646fe87c3a09722af813082b6f8931a36095778b1f7b756e013d6fc536e293b9f0f475365cedf40639adcc2a8981c710aede765da65098fcf1b43de40e92607b8ebdc3bbdd7af4169dccb106e8b5ca3ed272e278fb30462658b47768ad645b67a197fb6c38b4df2166c46b4fbbfb9bf3054cc97108a057b4c8dfa58a6ec76de46238f576cfc4d28d2b686aed88a22d14d209ce9cba95b054b217f4e80401ef060870db774dae07e7ce64457c87b6ab87e730c729b0d2bcc7fa135ec89849abc21f64dead3a44408449151f77c468e94a097e12cfbf729a0616885a00cf2fd06f4ae9c5da1314a175ef178a7b980e0b8d0920e3ab317fd7770b1892627272fd9f5b1ff49583c7805eb0e54bd380a3bdecb70fa09abe5cdb48f1a519367b523f0c908f23248162aa88f473127cb62fed090f482c9b0ca7cbc6cfde588acd2b73c466d835c38a2e3d6936d555121b8ecc614979bfdac4d22f687c2acfc90848a008fec414ebda76b6e8b32a05b013024bb270011c5bcaa1fc3ce505390bbc61dc3a6160c1c7b12b37d378952ddb7b4e8f39c586b9d00988ec2ad5e9e52494e52a9276563bb07e13123a4d4ab36c31e665ddeea20ea109faf4e7984a6fefe4bfab30d21a4d200dc6b5dc2d900e695c8f6902d9bbfb575c8f86abd1bc0e7afa6ca089cd93afebf079728c6cff966d570e29d4ed532c55eac8d48f68dc46e7ffd2997c0146a8422e4e74bcb5a003669b3e9cbceba3ebadf1aabfe71c070e10e6139232f9c03cb00595f85707a19f33ad26023d5ca112bb22f3577a2c6106a9d588863070c9b798b267fb20e7080c8c3ad1aa89b541afa71557f98e94873ce9dcf787cec18e08b46acc6a57e3cf42a5e1614f391145d728c267dd3b4eb9ba7c457787b4e137ce2f21ddcbae6065e58df18da59ab281b80bea38a7ff1172c8e7a895fa0cc6285630d8f780814832a2e8fe65fbe9247b3e5260d69bdc04b55787ba98c02f6e3ab90d5751bdadb0612f1a3b9249307db94a92adb17b572ca5d43797e97e3dbf94489217b316cbe3fa2c65772a7cafd25c6172ed1551d995af18298a4cf5117bedaae71aa2d2e43b3a6a0be3e63c76b80b0250c29f89a782851d25c96f4fdfbd8fb2c8bf1f34874d04b6b51ffda06186be281f8f3e97de4701b819dcc2227b9456a9631aaf027fa6844011904e07e0e25a6ab5194d71d72e73d33e39fed148f9fdcf341bc229e00907fcdfe942a2b81dc29211fc35a6a16507c771f1f4848c77647cd0043a17fec65aa05a3943647437b5006d74f61c3f0f426cf2022aa38cc4381ca9a98d2b0581cebb72d5725df3d716964a8f2d9b54f2c232bd00a9feb5079b7e3c85c36bd25a1308b653f59da62c3f8e19bc368bccf4ac5f205a612aebee6645bd504e0df6dad91795e18e181789768b8a2f9a847320ae08e5837205e1777e53b45a8a50ff1ab0bf2be02fd0f436fdefad30718f8c9bd07dc8763d790b7d63601456395c3cd5063e3b23b1fb43249407d741414591613547c1e3954d3474775718d8a8150c9f9fc2674a73ad801df3809db47e90717bedecce1e3821b6b619edd79391cf4063d079d2d0a80b42993f43a6864ddd30b4337f0ca64ae233c33c8749edaacf368b5379ccf8edf150091fb4a974a8f277904e1317d3d9eeac93885d9da66898011f33ddd981ef00dce2b4a73e9dc98d3bca60d32a114058e0a181745bbf9bb300540dc07d93dacd97df0f1bd1f8e9cf851a00876ffd229df73f9e898a4372ccaa3c0a92abf0174a2b5fe439374230c84e868bb0416cbe94be55b42225d3dfd63912f422fb9ded8b0ac8b3e40d7f0b24c16c58b70317bd5b9c9135a8ffb3e8c215c24e64251f84bfe424ca1624df7b1f18ac4bfb32e10928f34794fd8c6612bac355fc151c73d96853053b9969bc84536891b5eeed95c66f5006fe8c7f405b39c5500ca879faee50552d28cd5972b081f021c0e7a181e3f74b7d9ff001be704474d294f33e7569d376edb9f23accbf823e78b08041d5c133511f71970f2dd2f4ea4d47d8b50384685f21d7e01ec86887dc93bbcf1127c7a1d2e305477f374272247d8ac171f4273db2201d59bc60a061ebcd77540c93dff8bceb05fd82e6d89ba3ee36d9c8b354b42c69427df5015cd31863e1e22ab63977d2dfd573101d67f94f728d81a570f9f7f21549020a45cb40608b32459b759b87457a82a29e81bd59e74c9f9047c8fd52258cb2a5a45a4012a356bc64b036b1a297e0eba8f86329bcef300f9ecf68021d85d2fadc9c0363dafa89b2d6340f36bd968b6c13bdedc4a5e8da2fc96b2a3b37f581b3e0536b43bbf0fe9275dc7a8362f0c48df23bafe2ef2484333b588147caeda2ff98357dfd10243fe3376655d84d6065880a33ae087658ca56f1b9beb8a2b6a369205794c38e504dec18b6659e667d4989f438dd2fd6c06ce2fa5ebfa2382be0eb4639ed2c10335d212d29933804dd24ccc29b7be4b75721d6e6220c3624d3595db0cf9d6ae848b39a559360e7ef817c50deb70f18c5d42933177dab0479db5a83bba0169ce3b51b537326dca67a3006b84b451108e10d37ee8e44674b261dbc31d4a5ce71632293fbd03b8076e1818655ff7a98521e6c4e32af248555b9f40a81e15609e66a150fb4999307f7cc81d1e6eb4c0052dde32de3236a3aa03a51323a298c7c09ac280d2653109f1212ba9360261ffd31e5a94d71e3270cf9c9ee599f2b30c686d518b1b52a8c8eb7501773c7f6b43af4e82a0ccef9bec84c92f5f46baae4affcecea5f03d18969d0e0452f03556981976b1714700ade535aa7f5f9c014a8dc83fb2276413a04de38246d798a0152506bc4cb4af2cb961b8043eb594f86129c977ac07519c9c5b37f07a71cbd596d44566607a748675c871f416280e006b67e0ffa6252c0044b9b4e188c355eca9fc8837d2f7cdd4cca3cc6bc7e143bd2c5d14357f0b3c34405f24129ce6444c249ff79a9944001c8bc822ac8b30b186ee074c0f5edfcd9967a02323db7a2975afb5fac40436adf9827adae88d3e6babb2e152cff33fdc36c0ba24ed3166a3bd2c404317e999c3b6bbc995370d9d63b1771883f5c24cc05f54c9ac80e8710d863d4ac4008508825dbf1b2b6ea662b689487f5b25f77e4f80086221d81dc1d52e787aa3ad6f50dbd0902f9729cf3b6ac4721d92944510b423b9539eb2161be3d7c48194b149d8459a55f9d955c5edc9d3c78d1655cf1d606d4f4a7314a0826791681ff7c1c1e853e66cf6eb987a695a45bb2474598d9a91738c1c0adf99f8b97bc30624b5bb1bdf62d806bd09933794b6536b0302c70e0715abeb01a49b96f494375d11bd3bbf740f8f6288abd7d993f248ba617292d6fe247a21dadcc7b70561f2b6f1a7437b1ead286e889137b81f690d25d76c299bc08c1383fd0f71e0eae8b37ed3370488876388d8257690aece2869db0f164c534f9d09303d8c5d7a7f3085771488825d8cff26e01dacc6f7e583b83801dc820468a608b6fbff2cd66387fb8a067e88364df0d5942eda9bc19bdb43d42319381aaa9a4e10b1f4215f8500775d9e8f005f77ac068295752370919e26e7fdc4c9ee9b846d10fb5cc2034688acf20b1695575e12c4481f7d8f2720e34aaefe236aec7fceffaac343ba6e689c718a95ed6042e13460f214fed185debafb9faac4a52b3b1c063ec117cc2b0bfb1d6fff7c9b4b6302371d34e3ced156c8c76cb847e250ce2a33834572d93ed37563d5e7c4c0a9c10dacf0d8884b7ce1569c97befbc0afd3342e5b8cd70a5a99c0e187d86fa6bf6e41022737dd1e5b09c5b35bf42c6dd5b94f5eb66fb42b6b7a71b4668fade58f49209c1c8f974f8429cc3a674cfbd6f6f351c8a43bf28ca305cfcde7cf2b13056ec387920f73a1b5d9fa8658633619ac5aefcfeb4467c11803470947cb912f603bc524f4b06106c03606f2e95b828ef70840115d91caeb3b6da41c197cae9d3992a225a0e39aa40512011653da9f2e01013bda652cbd6e726b6fd0e8b6c0d94c4f91da62c5c6a8fa9c10db8eba147e899ebb1f7095a2309fbb748b6b4c8bc2316fd9b556a7997b353b07e8b4175ca0616e4868d01e29eb7c7f880ddff97348f44a8f682ff764ddf8dee74e1747ddc0bf3e98086459a20141e5a2609d9bfe15682c1c97bb775bf4e35e0c53829d0cf4de25be096972a911dcde92143e1e14fb2cfbc4f3232572719edc1704031db61232f0a215be5f287d19b3764327d0815bd268105c3552270f79c036fcfb84b4401021975c09b3eadc2f646d902d5a3009285fb455bf88b94e9671763b8caa8aa288cd86912420d2a9c542f9e30e3d4771d8a73ae8833b7225822739f6443fe06b858954b5e4a04afb387aa8ff00c398b43039d51752762f4a4c1fad2b20e2119a859704956ad1aaaf9464a5659f31790683d185a4d68c6e97e2973d1a5bdc5657d6c60a8bf43c08c685244c1a0ca683d36a58a7837961dfd519b74c497043429c723a07afc6d9ad160d8e8ac114a7fd573919dfa7819ee4e8f878cb92a3cfc7faf183ecc1a772bec615149aadc6cebf372c5bcaa3df84cdb1d578b30305b4d14a1bcdf639e08f64273326c3841cf3a5cbe17f055528a6d935890c9b2c724f6ecda34d36bda5f76aed6556ae641145ff2b21082051cf2663a1d11c96f3b5e73513178d9c6ac093b08491c76412e7fbca2cfae93b04d6fe6e6bfcb054d49a490aa339fe3c7e13b1b48c81a3e54df3e7e12cb92056d0c6e8d4bfe46b2cca28724cadbe8321fab8140021c2be9fb7f76ab099593f659c427a3ce1484a5895ac3f28e42cdbda264c38eaf0d69d71afaf56da04ae8391ec5f66c2f908530c87c594c2df2c4e8656a6820bc9cb13585d7889552befa7f7a4856805dea97d93d08c1d96faa6c3f653e751f3c52be3e8fdf6c0bb6272f304cecafe3e32c4a76fca1947ce6b8564e361d32f9c45f9d13aeb15c8c53bc5aac1cf0f304294c2195c8306956753994d400422a205e27846f3b9bd471319c7a3d58bbd70891b2b5ab4336c7de8dbf0315eb7be3f314732a316a3bfcecc08621d4b6ffb9e4abf6d109259ed54447818203025aac7e02749c5ceafdaf711dad50a5046daaaf746d7aae5504eeb6127748dfbfc9dba5100d7ce171b76e5d8c5e560fa1c6239949fe9388f57bc2626ae7f33299420d203ceb2ea969f4914576093cee24a656be40c6e459a9fa5eebc1a29628225aab6cf45aafcc1de2ec073f69839d983134a18268a7b13d472d98001e80e03694ae4f0546545947df63243d237dcceb379e2fb4ab3a2e3999b4d8dedefb9e2e8848a3a42de1bedd6d0c2cfd1eeba0ed6b79109e0c2057023291f0e5a599eb714cb20d8b706ed903ee2b278956d19e5f3c712c2857d5dbae713de807aa23c7f5298b38200ee5aeec8d6015764fbdfc1d9d0bc5658f24a3482c3df1a96336dc3793d67509cbfbf3b1d8c63e91b2d0b6ea7d2e83963e7a78aa66dbd5e8f6b05d67a058bde749d50f44c2a38c76f0ea809dfc7747b4c98a573adf14a800d29524c7a3f017af92e5f197af30184cf411a6b57bc5b349e8fdede723fa5716fe99762dbae3adced9599d1167028ab4215d50b30190766025b5aaa6defa3b9125959a27fd9999a82e33e489489a89109dd0b3ca1baa685d4911702c95de4a1fdae923d77b5aa2115de385eda4a1d937cc34d0e4bd2c65212d18905e56c1d79a6e0b1af35b9ba1b5ee2ebae82a8e547a47d5692b6c1af8dfdb007715dd67eef5ae8f492399fa8f5dc2da6021599fdefdd5e82233abd1add693ab7f283b7c9145adb900d36c6ca58eeb8ce14e15f94f992d9b29cf6a448a88807a9060af82104d711dad2a9c2d5eebde0404d0fcdc048788950d5bb37da18b7ac12834e97e4213bd2d279ecba2c58fc816a7cd6d7703a9166b1942d97469c6082fd33cf4b8767600369519938add051bb343465f688efe6bc727b945e438cb7d2ea2d8150b5072d3235940fef56791f9e8be626a06f6f3964de8a8d1555ceb286e84df04ab99db5051bce94f5682f2fc2e2c0989d8043507d1fb6fb33b2604d7eaadc8439e5cd7d21d9990f92dc0d4fdf65ae6d5b40a74994edd14272a8a09953da52206631e6cbceab2099a6d234ec78b42ccce0bb1aeeac95e8f720b8ca70f727fb5ab45784efe22f0374b99c63b525068e4a1fa18523a8370907423f47483b4d1d841bfdae3d0cc871ee817782bc42de34bd7e696f25811ec869ee8d3ccd8414f30ebec79a0786c674d04475020fca81d779db8baa03782b7a866bdfc319639e9dcf64042cf3cd4665f858dee0fc6463d32d8087f0fbc44a36da9714be1f70d53302e91f8981e3e05fc066c48b1c0da941bee40981de7c9b9a816fe05fddb0943b7845267d37f60963316684892ff1d5280b27a3d98c9c712436bc2e30b51e7720d89b0b09a40faabeec1692f08e68f370fd069a4f86a2a9317736c1e465c6f7899c4ea8e00c96bd06f148caa0b73436f7e746b0b79f577768fb2e3609c80ab0789a15997a27203e5d340ab545c5325fbce974a85adbbd2e8ca8723db8b08e4d05fb4edd9074b4701e04b51fc69af3bcc50fa120bd03b7df754fd070d5c7b5633f02fc983e8a3d49e901cb2454cd4d02115ab2cc3f78400bcba95b45f7379f40626915fd3e5b9bcd4ab6d8ba996159df89d0adfa075ef99a70c0a77eae6250b766d77312a5572993cd793a2146cad04eba41ca5bbd67502b455d81f1e41fba940b7606efd948cd6e777883fc4ca2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
