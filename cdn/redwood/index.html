<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e59a9016e405513a054440cc1bcc1d31585063174f81d28bdae01bced6cc4c5d105d813d1cef0de48963b5c9bfc843d4864ff8b7dec645af00f9b486815796b682095a9ddd258f5638cbd0ab70e833d29a88c314bb8fc3caf2774e68686fd159a89c878e825e9cc163a181a70d1a0228cf6dc22546e4c171e869dd244c06259da462992c0cf0a448a9fc1a1a3d03241747cb03eeb4b9997aadfd3c34a9d0c066c19dad60739fcbe0afda44bcfd3562767d2f0a2ab9f9f6223df95df327a7abe71a37054ea0b1f1b41b50f01b560ffd31e84c6e2be7ff46477107bd73efd000fba6aa4ab7e0373ca7003cb37bf348c0eaaf1a0f6b7c35b0a1a0c0050a722ad51ea7a4aa8225a0f0fcf3f1e9b68aefe3a24943dc796da491a8fb3317eeec10330330913c2512cafe5ed6680f23eef9c10157f4950e4823657e8ba31fcd8a1ca85489e3cf0baa1d206cfa799920eca6ba9d1deb40d97a197080da64ee724020e61f14d92766bab1392568f6cf20eefd36f52672a440904ff9989c0a4fb79badb875de7284564c7c7fbb462020e3a14f52f1e82066aaafd315621043ae3322dcf13c5c317eec25f49ccf1773221090852bb2c530f3963cd71001f5115c96ff076abe08a1acf5e0fed8847e44c12503e9112935d0e13e92c588045fd218cdb86893a410b54605af4c47304b73ac74b7401eaa7f2ba3d7b09e1cf189bd3fb51dd2a402fb79470b09c48c4268b056ba1151f9002786630da1bc7de5d7cbede409923ba0bd1c4e8cfc2fe3b90582adad870f2a0ff5389a81aea54e526e09e4d1c1fa99f6786922ea780737a5a4dddece19082ffc38db27b2656802b597e8974d7d6f3af974c1c5fa5e77eeefa225746cc3936e77b65b5566a25fa4270147726b7a142efb09f633c0e8c8bd8ff6d1024084f941e8cea823a7c7973ef00e6c7a37bf023773a7392602d2fec9493e84d6ad9b91c06b64d76e128ffdeff2f0a5b60c9767a22aa6387c092218af309da610accd9d3227005635b3f96c35b0ad55135991b129a66a5ddbdcf9dcb9ebd1f1d57db7f2ab4c94c8349ca3085648df2d5a7e93d8a26369d0ba515ed18aa766d30d8528605ba62f8cdadfc0df33285852131b25315c1ba0c3c03e95c66c5f46f1258529317b9e414ae0ccd13ef0cc8e7ed040be6cbd774623ec1f5a1179e19bb08c615a686f05134927cd069cdce2b2b21426f2bed7a3efe70c98995591356eccb78fff8a0ed0ca83161d4e05b06a31725079e4f18cd296e9ab22044354fe9dd8f00de320f698cb573250abf45dbde8870bff029170edd6c7f49659d4e9f3d4aabe73564fdf93f66898cacfb20025f1e1f9399ab240df67e099808feacc9a20036426d5cc408c105e1a1fb5cb5066d173e63241ee42ff1e965994c58fdeb812647df7f4774ec8c4091349f56e678c4eb9ac4465de96602ae8795784c9800322fb965de2240b28bb7e284ae1bc91fc407da41c8f95d5463a79b31d95d5cd3fe1c86b2ffa550a177d15655e55472d57fd41965d3187135442974fe95e2d86b09d6a611de7ad602cbafd5c642cdb2aa928313692ca876a671011fe94003560a4caab559ea7f1826d32cbf9dca5aa1be2a769b566a9fd48c96804a632c670f4480b4b55e089c44d8d3ce5ba1a5607f3952ce0ed4c1511a6843ae4dba17a21a068da4a9ea5fdef3889432d1192903da585610a2c64a82c99638147de9aea05e46826849c9457a06f783d36d27c6d9fed0b029c2ef82755ffaa42fd6c1dbc207b573b84d9ba4f2b0d0e29abdc9627f61488b2f8015c7aa2a9ded8e2d5f2ab23fbf7fca4301fb4d492ccd4deab4e66eb93aee92942b5dfc134f534c81a207dd9fa84edca1c8093c98d36f5764e440e0aef81f59cd5fcf02daa153068c2076d777c573bcaacebfa3cb4be2d58333b8b38187099c26afdaa0a545ece5c97b3ca2015486d845db74b4792a303f76491ae7b017583b394f37bfbdd935e2d55168f5d160ef4ed1480606ba869ec7da7ee60e964ef26bb3996926ac7dd3f2d1ebb5c8e521ba354a03aca6830d283a7f697f4c0b7b9fd774a87dfc24df8953e2b921c58ee6410e73e6ab7cf6a59a1e08837888eaecde2263427aa8c7b09ea0485fea9c67c04965cdf214aa966465af48e93ea29b4176f152215bedab3a2d544fe3f3041eafbae375d768a2955ce911ad464e230b25a70ab644391a5be015b0311a0fb7b54c33a98f13ba38585628ec42e6193e5f7091c6babebfbfd7f98f6111627329f684d99840b81a961f9dbb522948145a30f38cd06a1ccc6bf6192180d574a773f5569354e0f8e32fcf0926d58c2a613301ee2a1e7b627e195706d163e0d77a1c2fa0bb3b67069c9d18d1e18b079ccfbaa7ee553c72978dc40838dbeec4dd1a834cdd40afd7330b30b05f510966f03b2df6e983f53c1ae185c22189d334e96a565c6f3bf9611c20859de0acc4271f57d09c20c9ad8307ce4b6b9897806b845d39eb9f82e28af7c596a04b4220ecd23ab03ee058c9dc46df30d8c32152e44342f47710a8b27240a7acd19f148edfcde662e22d3196cd2ec3a2f4b925f315eb2c962dfc5a20d04f4312c625ab4c4652df1696286609675400945583ecbd40506746d9259bf35f5b2058b79d49c1adcce74712095fad66e52360ab0cd6c3e08a24f60fbdc650e572d38aa3063c179a172f545262dd179434064e07f7e9162d4382136fd173359cc75dc05132cfa5114170f5397f58f8f7469243d9555441e48a85a5812f6d1ea6dbaa05e254b0866f1365b795e90bae59579472750c4e1391e163b067c50c9e36832685a7376ca88a047fedcbfa9961ec78625a68e1affb595e4eb3860733f059f8e71e389be6c34ae128ddcba06d0b4fba21347875fae8a096f7227623886e6a15d767931eca850f38cb3a1d23fd4b2b6bc46d9072230e073084fb41e40e1092594bd56da1d5c493024b7924d7016ceef48581646bc0a37a1a71e9587f2f547d4568bf783071c0befedb7428e4a63888e52b9177e88cb3063ceee625756fe8fba974fa6d49cde1eaef4c16052214da3c4b7eb435859a425938904b6abc080f7cc466344148178336ca05950cfd216f286640e1ffa7c4d99d8bb6f67fcfc2d285bd6dc1c22ce64fb96dab98c477ce18d65922e2d489f83147d63bd0a4ecba375de4e1a92d7f522b79747a01fc60e5d07a92480035f474faaa13ca06eea97fd86d6141e0c29921609ed0deeb66bc0cb7236563d2c67f2e04702b8affe5203e955dfe4f9fc12b7f6d8c2f63761944337e5f0623a990ab6f64131418c598c93739dbe099ae302fe374aded0b9ef0dba2876a40c33352f0c4e7025ed648ada600ff7f6be93d5be3f15c8b023565a66b9ce6314c31e1e4ce7984f6f4f17beb99ace4b7d05ef094917e78815636b0400b622703a1b1a782bca70749c20221fbaa8639d4afd61a428eb9b675edeebba589ebf5ba58ba26c380dff06426784f58472b09580a7eee95d1336a094324236a3a4e2989d9483919b4147668054a629173617af754965172843eab4c80b1d8c103f097537b875e8e7839b1a35ebddff4fb77bdcbead6a11dc15c3ba1b870b80b27c63b70989fe67d38fd2070a561d54b0b4ff7c26b4c3382a70d1a63efdf748f2e547ed68746860a3fef9490ef5f0b2e8a2ce8206ff27d2165943cdc16ab280b883af30d6fce9431563bfa417e1a906788126c60149a9daf72398c8118d734deb441994a2cab56bb9280c9d4ebc1fa4a0b369c63da7f7bb576bf6e2284dd891f54390f298940918a3bceaaca96f1cea2215a9c66b580b38b558506f39b4d406f3803ed050132f140b2d59d31c25d426dea8b444d774ccea548b6626341ceed99d478cdcd68043d5eefa6b1fe42a0953d65f65440135566df4e6091c9525637645ecaad56c90e171226554b58c1762a4a24dfd3c6479c1e4e229dea2392061657d40a1d31fb8e8ae03014e409a2824b2a8200c17a6e81ad75b00a45123b308abf77877ff315688e2df8751a338d17880654342872386bf7a55c8355fda71998512b2b755a7edfcc32d14378aee49966c2d1ed09347c369d3b74df13f025b56b519b54766c7cde48c8b5f3aca1cd3eeba5745da1e85b58313b10783589b0a4a95320e461e0ac443f571dbe7bcadb01616c426b7177b2aa2eaab3679408adc3d9e1a820acca0ab1d917016aad82eb5a7645bd90150a2be052da8f93a7b75b80c0a956584da671d2b7ea8146e95ee7295d3ec7c06d141eb4f68eeef9a9edc2fa9277979bfb07b0e9a222232c35edc756dddc7723e4e143d8f069e98d2dd2572e776428a95df365a71d1437633d5273e2ca42597222c160025bdf1bae614f0b29b3abda37864e0d13689536f77f0a1de9666d6d0a0cfb132c93df47c307606bbb02b048764b2b13a2b3c38d41a3396fa7eb4a44ac1d1c15c5b522b61e73541b7a1fc9181de3716d3bd2dc6fe526563558c4418ada2b6a4f867ac51861e457442fd2725a1bf0d6eed6e7942529384f9f4d43841bcbb63c6fdb6264bf5522079c943aae24e0294c10b3f5326dd4c008522866ba735b299d044fb4984825c8209047d750008f0753ce9e81e985c9e48eca1aa91d3b1b1fd81186d16e1d232e230aa2796e01ec5bab6fec907bac769491f9318153248e7070867988579666ef3d411cceb0c7a045e5b21e1a296b623032051bcfe9f01c64014b0ada086782ba98163e479c7385dc5dfa8d2d33186b5d168a3e1cb2b8ace2faa5f9b7b47f25ffa73827599f9e46bc7d05e5cfd87f3696d13f790e8f60ef5b07ed708ee64c3d581b794d3c26ab9d63b21f4b84465832ea72cf9fdd4603af7048205e8ef288cadcbc38ddc7240c83e00f821833fd8bdefe1079a2038ed37b284216d2ee4c73c67321f6471265aa4851f2eecfd36e106858191182d9c5c1f00efc9322b51d086f306898f7e2171522c08f66b17d2d83e98d8ea4ad5df037c94bc7d9914adbf1c6aebb164c03f2c6e0cbe78de437447974ce2ae5f69974053dd5bb831a47cb8dca14f7ef65f3f449ebecffab5a3ff3f4ee16fd4b78572e5a19629482161f05efd9c3880da94b2daf8f328dc96c3d53685ef5fe0f0a9baa30751044448dd3ce697ad0feee8a0d5af4e3e608db0a7fcbf55490d53254543035c4b8de03e1618051d492a1b17fae08288d1c44031e7f80b5a06cafaa029b91cb6547a93df7f1e696a31cfc6a2e80470b49294e8eb9aa135fc09e31324dd9542fb78caa0dc49d39637c2f99ec0ecf65d7fb1c9209a550f5690d3a2d5617e54ad3acaf7a8db3eb279a6e416717b618379b7781766c13ae9a2341b918fca2fcef54dd9c9b8303c997a45d2a16847b399507e5527a119f3745ea598161bdccf0b17590d17d2e6b2f5f9e1b2363c7e0cc9a05f120af87afd726ee575fab9d3e0020e375c606f1484fff7771bf642dd63ef1dbf86c6d26a250bed9811fbca6b51f92ac8f24a8438d16b8ead44d6b2dfadf913bcb1b8031f5941975c53516aecd9bb332a454fd7e187d46344ece7158af9c7ffa2a0ba8eca7024eac6610d5458364564e3796dbd95d5ab87284c4b5bd947079eb9b8e75fa0a91497fd431a40f142434f8ad0663154b6508062ea0458d172f3c240885298e1d03eed801b803711ed24df331d70fb651ebdf1959155078a98451be2d17311bc77220de1363b85e2ce771d838e0d68ed5636a42b87ad3ffdbcdf819d75423cda9b689479c002ad347a0ca969fe3ac71c1155679ddfb3aa9a215dbe6a5369f96da12fbb8c4eeacf1f3d2380370f0014f9bd993b69fef2e9091dcad900f7c0f053495a02604b7201242d0924ccb54160e061498e0e5296a5198e9dffcdfe6d5d1663f7d98aece8a5d81f1999098e9351e05547d44108e0579d63f5a215a5c7b2836dba4df8708ac3cd61660dacca8bc0976792914dbe819d5b9020ad33ebb659ca0b2c6a1af3228d88a256b8dd9f1b2f6bb36801a34d3f74ba577ed94422b38280a3a37ca8136cd32be75730618b1ccf7d14588f90030abadd1f0334c21a6c1ff520feecce8f6c0e504f070693d3771aa2365a59bfb10393de2ca537457add6e8fc44b6ecbefe5e46b17f9d47991a8f46f903786e1ff4347dfb48c742ca97be069aeebdad0e281af17d5e4bbec52f4a92edd4715c2e8c2d9eb98b9d557dc145a6cb5910d71c025fc2ce28db9ae0a7ee6241b386fad77efb98b096b200daba93d6192b2259474fcfbf1b6f47df51e21fb15d4450bce281d069ff510b224a1ed2a3e1c2fe3bb2b4383a9efa61e64859bc3f0babe11a006e0a9973968a35abe20cf0e78989d096b76eef73da03c4139017023a80accd51947184b81e8f64fdb46b10274e166857776a961e02ee3d3a46d53324be97356f47857fc68f3c4d14d88362049e60145d923cbfbad2641efc02584a3177fa24836bd11b254a4a92a7e0d97badafefe8f5a1ff44ea79b42e077a709786e16e16a3a61467fda1a1e0e38718f5394d5e976bb85762b3edf51d07d776c053b43153a5c89e2efa9d70ea2ca2449b205700f39cc96d07dc9c24d5cdfaea6dfa2e3c59032d584a30ca241eaa9be03d0d29f80a5d232bc477adb7779079e291ef2a0b2269c80aafb54ae04aa9024101d5fe847f9c0cec016788de1dbe272340324735f9e8836246dcb90c7374f56f4a3c14d9f8ca31ed0db87e602e39a298d3ae3b7e947ec71dc33863cfdc56518c590ef508133f41d461c44aa977f6a202eee8fb8551e246309d150b9d4e167b67b642c33735a6147ca8d0db4cdf5dde0b954bb6108fc670d99e79dd3d886d263418e47cc97743394895cc1b2a441b18f5887227f4f3542496c7f9c5835b9299c366a2d29207ad6ff65ee0d2d28c2ab10a9bd3859a6307b3c2baecacc3c7f7947830ebdac432d7630bab0360cb3d7e183f925f4ce5abbfcaf739e2a1613784e6e087ce3305b4f69f96fb98c893d78b38896a5b759fa914061efef46caef721bb2d79988461bf670bb23aeed2424c2b7e35b2650b081a6994d99e05e03709175deeb178d7c3e3bd6a3c0c1ead6c6c1b91e51f2c2cf7fc07bedbac9d3ce5a8bf694879b897cb5c91f2d9f21507054f5f0b61d36056242f0e2c0ea8cee7a4afcbb8ab82cfa6b42f90b522aaa1c3bb58fb07ef17b338f83033d02eafef406835025a89a3c279f1bae9a26f777f1e0d1595006583c6b990f135beb6ba7cc812a895dc1b76603691f4350a55a25559d1c5fd6bd155109bee8aee8171bc4bfe25eed6e2a42f52bb8dab809b9c1fedc97304613b9b734534e82981691366f9d8b99cb7945ed64e85391a6d59bd769a10a02fa034f8f656af76c75d0dfbd3d42531c9f3afd935a4c39825bb2b29e8994da4f2bc4a529558472ba6ecbbf218520a1e8f3b94311602507da633156ae36da3feaf42fdffd578446b43142c0ca8a035fd11c9b24461524c62892a500fa701f7ff1651b79d4a65d729e2acbb9dff8d339d114fadb3c1c22d77e04703d01e1b2784859a7d7c482a7bf190b05eaed43b7468114667d90a609810a181cb89514f54036b2e6865a741a41eb48a1afd8eaf204233650f937286e0d205cecb41e237d1494b5ff8ab5bfaf45fbf5131471a8043027310b605ec2eb3092d61b7d8369396885d9ee851ab98dbe5aff4d946483251c5ae411773e1e1e24ab5fe354e781f66c51a1577d2513cf69391e0c2cc24f17d8efece817625c94c06b3ed331406505777747b1680170ca5fdc1aa1d706e26acc84466e64e22e944a419710fd3f6f62bfec8d54006407f420a4c77badff25eb9e355523bb6a2125c7ea588327083d187645c0d31c896d44bb78ff30485ca8b1d6c27babada07d2c97c0ea59181e093e30ddc56f534a4ab1c5b0da548e301337ebd06472eaf2b38c957b7de9d1bc8bf6cfd5dab9de4aa8c0e5025f8b7baa714f492076a5a9bda5200c8f0f42ed2f503279b8f70b2aeb5f49bdefa7e91742e8ee4966d0a308e10188775117b79ea6b0decc5e2c95cb71610f636a462643fb8131254d1381cb2ac7921d8fc3ad2854bb1ed9fcafd963772299d44467387bfb2a775622b9a6bcc5a3ab0d3d2573d04b450d6d291a08a5eb12de1fd6617fdad69da11d8afd31b5c154e3a73434937475980b66e62230aeafb3c828cb688483b0a341d1751c720b857602ecca885a4dd97336b57a4ff22b7f9c2003c8d70c6e332f575c63fcc722cc2c811ecf2af9949fc76cef88e18f5bf7d669f0179b35b0a850145f46cc4f8e8dee56d65c48991ab2ea56632c4fd013f7877df5957ecd33e9ab67106a3e79d81f207cde04d82641a8aacfec5f230cb0c03836cdad4e236733483c8c6a31f325b2681a0a396ae3d8fc0c1a26ea7fdc1c6a75e5403b53b8c45a195ffe89c656eede92e6434ff4efc3f45a6f24c9b9053ed486636cc64be04f39f3d413f5b067c79a2736818bc948ce7c7987de6e2a36669be44bfa6084c034ef4562f1e85c2ad7c3baa982b67d91fb91d88b047c592610765dceb0f1b2cda29e05bafa9f75694ff1301f8f4baab4e87790268704ef7a135cfb66d22e071696de664e676c78316adf3760ba5d10575a750a1e38da1b31a06ed5d823268398ab4ec4a6039903cb215ad3cebd79af55d99263f1c3891de8023ac1fad223457494c1479234c71b548c5b658fe9cf6bdde7a24815eba687258498158f54bc340049f84e9a148b334935e2474ced70dea8935d6a53de8fc98f7f873fcb37fdfb616ed330ebadb3cfb912c95536a01a5eed18e158109dcffb2c3486cbe05a744689d4ec578450941a23778fcce94ca0238684b47049a8d04972df99d50643bae41fa41bd53a09cd3f963888038c5b7665aa71cbb0aa89fdec1d667ed615b661842ea525e632fc61cd1654fa6bc6f91b461e75e306171dca42588c26edef07de64b6ff5597e0e4ff537d88653d41743b79f465a4a2cbe2f706fefada70f8fc12b2e5d8885b62f81ca4997281c4e55125cd2f86bdcb5bb7328079481cd682be966ca99a73fdb34ff8f99d00d06d06a6168797ce1bd90c7dbe91711c9e75c934cc0498794ad9b15c126c8f5ab4d7f34b46df3fcf4dd17a0c19b79d4e9b55f673690f05abdd9a4e5a26392a38034cf8beade996ee53dd53fafad23a097bc7b2532f0d1c220d271aa0a36ab44aa98075dcae7f1db11675ed1443ddcf16835109dc6dd0bfc18cec7cfeaaabe3f2bd93acbf22ef6f0954731555cdea1c2b7ca682e64400182d9c733a9a35dc1d59457db0444f756e3304941614d6fb1e07514c68aad3ac0e042dde233f2a4143a681b2a831ae747f305fa7594333e3b00ba337b78291041d8d209d97eb38b44556ebb8fbafaefaae09b61834da880eb1276884e10dfafeea84929acb731435337c42f2bdf4d762678d9d3dcc7c4f61fcc78b4a28d36ef150b8d6f49e3a8b74de4add9f8c8f78a91d2aa8dcc789b5ebf93b61decfd934e0a48f251aab98de4acc10ec2591c52736b23c566a362d2ab5dc8fe34ece806a287f377bec8a492f8e1f99da2a4d9a5eee66ed573c958998d90291b8a55926884cdfdd73c724af33ebb7102214c05ba550fce01bb470554b64bdc30c93f1057a55a4ac3c6397fa693ba07e5e57bfb3cecd0b1fd048e7884a2fab502c1a189254c5bed5ed4ef5212224a8864423e3391715c6de38e2430c914f4dc6de9275501a3257dce4c53e90887934317fd060f42a3f692b3add0784ca06fb6c29de8b3378407ce5795db109dd5c024e4b8d59b4392d8fd876b127798ee8a2516494ccdff17f9271011dd7e85c309814ee6d54d00f7d4f8f71131eedcd5585b984a09943b512a3ec4191bb42f58dffe8e3977f42d50ca47996fa0f49724c8d2867672ccb4f77d2b69ed7e6270cc7f26b53841bc8fb37c8776fc30cb3e7946c9c95d0b7872d1183cefb241d114f8a2f557ec2cd76e59d14c5a2b99a9c53241b532fa7e722e996d5885116f6ffb013fd253f9931b6da51a24e897d357a64bfe996303352553c20294e6290fc52f3565bd0bf93c45872c0cbd83224ea664c4791da3f583a1e556472b5e0afd6893263e55be4ff050185e989667581791041e2580a5f937020252a7de66d80a9ccf1364067dbb3e57e36f7e3e41911bc418fbf21994f6b82679286505b6412f258b16a8fce493cb7c0e90f7873969ddf6f0823c65c74260aaf75e01952a0c80d12b46cca0fba68ec118d08867b21c51b5dd288af1ad5100034e25d0757c081b851b7ec021ded1113d829964554accc7ac67c52a694f87d1d8c481d5f71d41e0327323132e466e33a63ac76d85097ef2f84108fb26bd92d5fb2c2b7d6a69b7c835bc27a5cce0e6781b067f4b27ac325d767c59b29936177ca7f29a42d3364028249c45d1c2b9e7943110829157026cead195ea15f19d801698bca6a8e8f210a87464bb5c59c8d0b2803ceba2897af1a1a712708f1411e24977c72b0489a7a4289f8dd2887b9692b0bb6e33c9e48416f5ee4e97cff92cfb9db3aa703ab5ac6df92f83ee3efcf83202089ea878e9b13089351e63247f02bb4ce0087e594cc3bd71952352ab8512e25dcc1c7749c24bfa999b66f70e777ee1ddf6422c938a727bbbe7afd8860cbba50badcf5eba1648eef6811de3cf22a8ee28736fe2997842ccf1ca5cdcb029469121eb2d125914b43fd500da78c49788061d52106b096c4817735dc8a0863d467f5ec4ce47fbab10caf74edbe3f5efd32e4b83834d6f810caaea11c62d33348bb2e4307a941d161a88f7db302cd77e5cd451b732b7583b763d0d72743bfec31e3264018b10efb0513c02cd517faa64c6293e756527068c0d1d735bf2f7f5b19f25a034ec70f3745902f61eef635c3ea7e78c85caa215b5874a4dfe7a22ed97ca20b860a5fc9e152fd5474e33059fae3bbe4dece66e34c37608080a8567f37632b6a17f30cb08f077646f92290369b1d963fa1bbe991ff507534bd202260cf442f7910dd2b1b04666de235005b8276ebec7b9666c19171ae00c00671f64751b3613219f0d5ff8b1a976e8aa2179298f4b6f2a70ae594191a6be771400e18d8e7a5baf9aa14c8fbce37bd60938354cfd84df45197a6dffae761f3b24d4473b67400b2b1e1a91b75af445dab6cadcf329332a4d6f6c7b3444feb72b4b5c15a08b321ca84350ea700992fec5079786586c10dafe124a894e5f15e9b9f972d175fd974c763636d0148c5c448eef9019c2028c1a6444c536a5166e653ed429ceff00f6a789f92c3e321b6b3f75a0954b7dd9e766d6a92ad58f32e12ecfe4798e7f0156cad849b2a87584fce074d9a48835bc13686302cf19ebb3afde80549e44fbca75210b286f41b32488111e74155ad3042e5f545c57ad627de8151cf545373f6546160ed36d17da9bbccbacda87e9f81b0cfcac7b08d3f8979d72820fdb317052b235249212fdf3d50a8be13d1cddb258d3cd3c07addd855d3537980c8c50f0f99edfee7aba85888fc8e28702d0380d71bf662213f32aac81623ff10c243a76cb825ecc826069332e65973a62cedf36cb6c6ba9a4921a1e5afa7c3af33802e9e0e29344711c1f29bfc9d87556c38dae2d4343385b1006f4643af1c3ff8fc865803036032582ac80dc695abf000e8d798e830705c0826c940dda9e46618fef85a27ef9f1da21231a1e7349fe32f440b68c5a6d1ef8b12e7c2203c6961e235bc7be315e2a92b38a7d2ab69cd705b4b6e4fdd80c4b1ba9d66f06982c852abdace34b8e3fac892cb6a59d1acdbb2920751c7c4f4fbef21d40040e8ecbc586af6f025ff9c25f662729937adea8a8aa0a956ec5975ac00bd462dbdde705947906c4dae3cd8c6fa5106395d0a2b7f5adb718a520fa411eb2f097aab0b01e7d73e2598c8b7c48cd0e32d70c241cc4998b5bb2f2431699543b0b111c9951cbe79b885d5403d3a98fe8fc4c01a3719854b3693d7a01ac5290519a30cacdab9951757170a8b46527c47f4b82d8c4a313ee1f60398e80ea27f01b275eda33efae27857a8e6284b335de2f269976e695e2671f9f979b38fef7a3cb172253ec461b7857181db3397bd8481971beec91e0dabed8c04829e3bbefd1d9f10f951b4771ff1f3da6d1582335d4b88491ccc2c10b40b124cfb7a043fe2e3fe9eb19bf73525400206007dab1527229bd2c3175b9339ce51593704500976d219c9f7ed425a9b1d29175f3e9a245e332cdd24b4008029c5f0e074869619d724fd95a7f940f7d349cbe4f4cd6a89f34f8181dcbfc330e7126bfca57da70ad269d70b46a1c39a3e3e1e4bcc3672ab9c7071c438a2f393cdd62e7295e044052dc774a4c15aa31d8bceaa9bb7e2cdd10edb107191249141147d005d01c57827bf6748906f723293229179f19590191eec90f06e5f3eac2b6ac20fde86a96877b0207b2189fc439941cb1670004f2315f88a9e08aecd4599d1a48194cb26ef4eccd97b510a6026c7ff2a99f8961a520e50bdf299a511307dc545faade793932cc1fd164baa196f90259f2f5f83c2c62fd164c29ecafd1af00859c03bceabbf5ccef49bbc33351d20a0ff8af1b31e0db881594de766d1814c0866977c18ce12682e0b0ae163fe007a8f8912a5302c47b49643a5b69f97324002c124cfdf87fab1d0e7a5702a9b615bb039e8649389cc412496ea5c46606165d05f90cbaf5094c9acb77eaa343ab55a50b83b8a0c1060c0ee0aaa50e75b8b5807eeb46cdb3849caded6f804b10a0b157e546183de201224f313bb7d07488d29910dcec6392b7919a3ee158f4359a22db0ab32a3bf0186d1b1083db644c1de0c0ff17cfc1ee8ee464af3f3e8e6bbe27b4ecb4c12fa0c7d11de842706095fc4b9649ddb80498fda2f858ffd72393be39d1a43f9e438d4751a047943c45fb5796a26d17369c60aec303a2d5a329e026a2b48e2d55576197295c1f29bce30c2fb7d24c3137a9081c65f26a2d2dad8d4ea53643e578021d2057758c4d2a56728eee4e6b6b0c49e85fce55ebd7dd1122f8c07e1f835f735c4e88ce7aa4187e15b99c0e1af4efd7b1ee396c5631c4b2b9f937fde0f587fb9e59cdc366ed05d22fd9e2f77d6d3828bc0a92f314d2081d3724cf14947d29bf85ca661d12b4a2fdb196c7c86ff007b3818d1ca2090208650cb3182e825d1c40f48eb79ebadae296e39d535aa822fad35256b1ee0406e18fcd99a965faee69e3f5e47a66cbabddf1bf6d2765e653477a8e872f05c34df3fce22a59159141ba43216e80e3d7ae21c4f6002fbe5caf333294755401f9737e0f1ee78ef87f1cbc86091607191e96f1e6fef8dcd95133562375ed4139e0867ac547868556e3c3975bb29ca526f593eee32da98e6538e27fa2e9e2a5fdbc1b0a2c1d94e38e2f70a3330f6550c92ab2ca35859c697217e8555e23efdd404b144943ab7cadb8efce5c185d3688ce9cf3cb8adf9d23af233b7962a173ab3056c5ec08aecb1b681f92ee37ab720d6e98ecb73e87fff32e86575473db5c0bd7105ef18fc9de64d62d2bf238e2d07b9ab03b7041169771b7ae02e52fcd16c57e80dbf1f255322002e80ae907c971c6df421886f066f45f50d3259780a40d2e152ac9074f3a91a1dbcb6ad1c26d05e7a84d8f3e2fd40b53536ff98de80e329a6f2cb7006039c6eb5b3b2910c749f01f20688f363366b4e2d4802ece2a84d5c168547f0742454c3123f9bfb28424d9623ae81b0075b2fa67bca6e36afecb9556033234f12de6271318dc4e221ec24e72f2f9431b5ab83a9b43df6b87d0d6fcf11116406599a7f06db63d12051da812a13458a92cef9d50bcd62002b224b5559bdc60ac1a437cbb2d8ea70e7df5b4aa90b8bfcf0d299c6359eb256341a22819b06701e9fe3e8ee108569b802c5c8385640fe521408bdc7092bf7422982cc1938e3adee281cfebd8a4c444dff6a9938d770e6d21c0661a7406908be4915b524b45150be170e3cb8598c67d484f0f5bcbde2d7cea478229cb2655809248a08aff2929508d855915261ca08c9ba0364ec3e99f44a6cd896e5c161ea1666623354d83a38b30f260e053721c2eb93d1060b1f80486178d0bef6329d9cab8eeaae672049f8464386a3b976be5085e052a20373b0f6935220dd7018f743e9cba53229956af07e168ed43960bf10b65edfd1fa9f889ecbe0108ce9febbc054e6e05fe73648f396f9f46ea901bdc1015f0cab4a9100fe537a5605764f9fb0a891e66a5d3881a215f44f7e313a98e9ea5eac428f4f5ad0430c9d539305eb9d7ed2481530fccdea8af446c84881daaeb32896bfdb733c597ff8a84a915822c0088dedf94657d7fce0c29d745ded226f32679f4280b9a23a3b4295dccea2fee46430ac2bca32d29b018646c94c40003c21158a05f0f5d2744f773e6b1baeed7a5e384d48c5d060306dd71e279fcddfce9aa792d37f41be91ec2302b5ffba1efce9a1a64403c0dcb5b7b0d598c664be442bc3fdd33a3cb2ecc77a02cb6a0f5aba066fc1799a0df7416a5b40090205723b3bb50cb58c306ddbe20c386f6d4820b6069c440848fa489193454e3ae4c2aaa6e7206cf79123af88af43b4cacc3ab82c2fccfdb8208ff69cff0a5017683ed42e39a46727b8db521a070cf069e101a8f08c29f456f28815f44832ffc7211898f50361083effe6a5381908894e2212ccc0e4ee92db8158030567f0fc42e0edc67186a844542e631abb5eca2ba025482429ea8ddea06ded5d2eb79a40e3ed1fd7b7cbd2a412eeecf1804bcc8f145456ec52488edab1168a186ecd4b4e18bedceb99e2ac6240be31912d3edc01d79be78ebdd87f10ed8af3858b21a0611931dc61ff231ec9318593008cb462de15de088de384d91d2ed20b1b79abda8bbfa34203007e4a7cb795a647ea5f36da7b1461591056ebb11d2c33b2f4a82a3e5fa057126aec624bcec147da96029e46edce3014437f5da4b9fc7fd3e2aab1149cd3088c6631fd9886a58a7e690afb78ccae8e04d72a4fe434d2975251620ee66672036270f86311cbdba0c597d780697e68c08cd49ebe2f179e8fe61c7a24639908c6d5586430e953b21a63bd6f951aeeadc93127c669be397b805188545ae1ecf3c1e03407d3dfc9177a792e4d9b8595204a0e959995abbe4c6af8026baed290dbefb2173868e0eee94e08c2f2877936e88f6296c10909f7f787c079b277e59e42fbbdf40b1429bc861caed08d1243d6fc6212dc32c8674be4eb94d32aedad01a36e63decdaa0a89b84c47926986db90e235539734f35b1db64e9ae99101704524d7bb2d383691a9a316c0b6a252e5ddab2b5c880541439f9438d01c811eee22d1ff0f81d139fbbdc2331e737de6b579d14ac0ba63b4b4f3624dca157fbea1cb07ac9b658805543b108645b2ac4d5434c0c71723fa58648480dcaee067fcd38793c8a0f5e0c5b8523259caa23f885d20be844012e09d2ba0dbe59902676bddf9a0edd64244441debefcf2d298d9454c07ce87d42ac85aaebe9727ef729fb01cf1d936de900ab728ba5a929d79a064f12da8860b9bdd3ecfc248e0872ab98efb9b534659611ce6798869f0084dddef022a389a9b9c1826d7cc67a1e21587e9de687c3f6aeac9200f81d96987c26ef4ea3c8c578c57e8efd173f73daa5a422ae29d3991e1b80de306915929244511da450f7f1b321a7c798632f41f008a660dd4c3200157441a9dc9477e760771d59fac42eec54284d1b46f709070f0891beefcea8e81c8819f2d85ea41c05a1434d3aa12a91409c850a267d476afabc665eabb13cd513696ecfa551f3477ffe83c95459d55759a8549694d1e672f2cbca05b8d3a68e10868921db9f0c570b35f335f447be56a33a61f8b534b022df26429135b5af49c165b6941b2b716f0ffdddd3e672da994e9629921a5b91a753bd7f308a434c6225b2d74dc13f3c05044cfa1553662d5e977289d5d2d8120a90fc418997f5407089a03f97cfadfc19c92e22d98f6dd0301bb6fd47975c60eca5697e37a6da8bfe424814fcaab4b34ec1252440cda18a7d1dea9154df4fe76fff1f0ed563aefe1b80f58c1e28d0d8d8ba1d1a183d91529fb533343f5bf81d8477ce35f80b3c260756d07451fa755335e4f036f74864b3c3b821688e55b91c8e23f6e675034b5424e6ca36badf1edd3dbcefa5f5db8f1134cac1045d0ca58f6de2092ac8ca375e8ed12941fda2fe1a9949d58e77dc9f980a6cbf7752d624ccbb72fa0ae911ceb8a83bcc322907283f238dfbccf755675e2a92fb13df79edf55ca3bffbcff384d2806bb8b0aaee49dd3a38f80273f618245089b1547bff837997f85636d8f9e1f0417abc42db93de7003ce8ed43d98b99f49e67d2e2019709bc9c131a037461ee5b00bfa6a17fa33f3f58170464459863fbbff8241ab01e511526c9526014c47793fa2e7c3cc3ceadb05740d72c6a7bc2c5837bd9cf47b17e9e6ae1668dd17d2da9c35aaf63444580bf17e7ed69eb78a2416d9ad5ca363d89d44016f2996059a0c7f51b4ff3027a28852ab5b2699d04d946cbd8cfcab7ebc5ce2f9480530e1d037b91d9bfd3af3fc55bcccd89f606841f820ae4865258e7c18dc61252318fcedfebc02bec3103f7c2aa3fdc492013347df7e1fb56dd64bd890714b28e7d42c72a184d260268d70bd3824df555f1f0fa7fba226d9b90664e455de53f3ff220ce5fea2efc13bc6059a36d3e8510df6c60b1b3ba43d7738eeaa982c5605de5cca859b25c3ba1f58c6f95636520852d965281d658e3a49279fffeaa22f4d2bd0391f0d8181b8f5704a8a3d22525ac4975c271cf33e505ffd4409d1a066255b22607d29256f5e6cc4d54a88ebec6a567762e13373c69b667cf40816873926724e1bab3d99ded422e457e642044a6e6257b893e6429bb426a726b76fbf9e3099971251e6743615dda14b143c56b4d5a1d486c7edd8a2287f906c854921663d3444d4c29641049b0fa5af195a6d22deb0d4813f2788d8d17ead1160575232f06accffd721531e65a1d95551b34f63c6732e8b62f736c92d1a0af69a8b82bd9ee8cf2913f70c20b6cacc48a08beaae04f4976c3fd261a3888f2a3a05f217c23f79602eae50ba3818f04aa2c04966c380e0343c48cf8db9c6a0677a026b881b40576d607cf99be411038fae099e32c911f85652ddd6751d4db52fbbe2bb2b27fe398ba40de01d96f9dee38417a1adc0dc2db2785c6565fbd17b0206ce564b238396f4fb2a7ff3dc84ce8107c9e0ac7faa8285c7757d3af309fd9b7123f205cc430fc177588f5383ef045735e1b43b1f674c25bed018b4dfa6556cf578b25a77abc09c11a3dac7239733fecce3a14c9db29b806c8049a6c94bb4247cf5908e58f59e377bff99fb4a3ab5ed55ac5409e73da98b0efba9834e95c96d7cd7072e27317336e468d34c07e927bd2c8be25fd7c989c4e1d8192b1f800c286e8389d3fdd133dd2cc870a147dded1fd6d9096a0b35dc68abd0a6464903a64e51591a3dfe18a26d583814dd684acb0fae7412485c9adfd8ba4f5934534efe60622e997e5db4c902819065c3736d8fc69b96397e639531a95c1586b7398c788c87f3e877a74bae621b70e1a49219df235f55ab94f323f147607e3eb3f36f9cf88338c2815f06b85dd66e247b5b22f3001dd72efe0c881feb3875449ed6aacaad11260f96da53479ecea39846954fb74306c52b968498ab28ef348805f520c4519b1f7e46153289c8d598463b2adfeda12be1a9cd8cf688811f0a1e441bdea7db19ee01e145bfdd7a49436c365defa20b76af8ccbaffa1f763931e4f3033a42abe5692295a2553f10a45c96ef0a6974013a5971847dbb0e455f4aa3f37e82583d89b44991a0fd8c87b632c5387d7a32337f6a617bb93cdffb88617f54953a6fa1226356021f4b0ae4634d0339a8d6d1e22b84f1f155a3950778ad89e59d47677e240cfce5c2bb32a2b130de490631119c715cc58bd314717b092ad3abdbed9bad19df37ebc5bdf5f8aee5b3242d4694823833d33192bb20074ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
