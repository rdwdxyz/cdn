<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd5da12c54859ff0aaf70c39890427b93c7442d70fcf449559588e27481c7fe5a9e86fd49fee72235af044c125d22cd0fe8553007395d7d32f3e339e9b26bd6181642999fe45e1f5a0be7187c3bc696bc9a919a838b5f3973ec91107ca223b6ee55627fa55b36cf935295616fead8ce05f6a411e5693d30697e64d2952d631f4935af505781c2afd6a5186dbc1b22c71dcaa3aa3ac251fc148e7e361e6347222d26d926eb51ba35229a72aed641c3a6a3975b2781f81829334040738173769c07d4b9e0986683f31c3f64915586b673b0b72558100adf6ad2aaf46b40c4c998db04a6a562473a0c192263c7edd089cd18d10bae7017773107540bbe87c16c108500458474864531b6d0a672922166ac5e3bd637a8a5ab2cd64ce61ae4dca3d6761bc4243c5070c8999ba167569824403e7ce82de816cdb31e04c077b083e365f11305d1dce06030ee9505a99377b32e05985d1c0d31d4c597df818569168fcb59278a5efbfd81b2268a3621aba85f3de08b0472c09989e4d56dbb6f08a945eed3fe856d2a721df4ddf579ab5ec4cd4bb5ce94107cba2a551a756623b269e0f5a9fffa0ca561f716a6db86ed035260b511858984b5b414be378e9b7c57d5536221db2860026aeafa5ce856106981220b2208b67d86734c3efb8ad0d62a52b55634ba82811a52a240fc74377403aad8520db359110a6379e05630da8f0ff2e749cd2b6999cea04808d4fd1155609845583ed2ef59cafcb77e12e3d6884ac5cef2c852de335b0d80cac2283fd31783a7a110b3fbcc053ced855bb579bdee5cc7337b1623b11727c46cc10321deac8581c0f199fd9bb49664bb846db98be4a3132cc71ee301263913c61f9619a0529b431b573d41cf6cd5b924ee05a41ba3d6541674270dd23ca419b9a8b75f9cbb6925748b695ff8ca3e9c3635b089d63f7a3007966666ea09cdfcc4aab044828b64c777c7f6c5324d5969c5bd88bab47943d32abf3244d11588712e545ab0a2b600c3216df6fb66c189697e6092b45ec7398ce30e022fd97acbe094e1e45938de486a59489ccfd2065de3a4c60aa3b79aea6445d266c58824ad0205022268fe216fd86abdfae5de694b59fffaae6b3bac66552d471c095a0dc4a90c798d30fa8fc521286353869351635f8531e9b59e2b698eac1882f2d381c9a19903a06124def2857d1f60baa7c6823f9904bb15bf84971876c9dba3011e155655dff0dd9e830fc9c8eaf6e41ff5a854381cc3c9f313ecff7a9675bb3f3a027a4b5a4e7c400616cc7005e16d427c440125e25d8bdea9c28a996fe378c64aad65622fedcaab7b6facf5d37ef892a2809dc52b97c0317ebcedb9a39ec3aa785f9f93f626344e725f508ec1d1aa056a2a5eff1617477dfed46663af3de861b1bf280dbc2c2838790fcb073c6d0582cae388248a8c2eb0630814483e5b0c355d7c13bfef008997eb18fb63ce7022677d24f571bdff46432e345f175f59667073a09554d6d9d5d01914bb8cd493b699d6bd6302bed71a90ee3ee783da964dba166f366a84d7eb45d96a0d207dcdc02e9a5bca773414b4b52aec5dc5ecadcd422f6009b7e4f0b5bbe90b389b69b4aae4306516d2bd163d8cfa21605311176e85c182b99e83876a1df9feb6952f5187ecf662c5464aa768b44febe73cc4b664750909600d396ab9c089ae6590b9ec65f7e3964cc408f05f568d2448811412b5eeedbd62b28adec303566b41a350bc0e7b052cf9df804a1854e5f902d8424c41b3a3b95ac1090c5f5de80e0667badff2701fca73384f9c109bdcd7a444e053cdbd95863b5b60547a8a054710220ffe9c2c667a272697fda83bf4557ce7fe1cebd2c24af62828ee48255f9dbe01a9d4eff596891471d3ba045c8c80c0ea8ca1197d9edf073902911f925fa1371badf4073e2b6b54c763adbbb5341b6a38f8c2bf568257c9a8cab5992667fe5c3951f233186538dea698bcad9a2e26349c713010182e98682c8895cd92379c5958035f291988d031315d1fe6d0341ec829105a7169aa834f46e15237b5346d6a7f8d4070cabe88535ff1c35c18d908a9a40845b143e6c098b70ec75d0ecafa5e68b93b48b0fe46ec1fb66db422d71d777be89cf0f5948e29163e9d15097db4bc90a5dbc36c8d6221173d80c5bf0a5d44dd411435d6bf07d7d775896628ec10c4f6899a6391088eaca2dfe4a65637deca1f909fe3027ee1e31d3635d3f31ae4643dd74ad86655ec00b4662cfd5d08031f3895c900244322408cdc1613a2f8602b1e83c8dd91dc6b16df108e5338a0a916d5db231922ba202dbacd1e2213b286216e98da2fd8daa6ed769ae8d309ce8630c6a391c222f95584bf0992fa21850cd6c3967886fb6c8e634cbca802d990d2635112de8e265b429dbc8c19ee58ce6691f19f3b1639526bfe7b03883711089ac773f7cce42a3d04383cab38924d7db26a52b0e44915f4484dead2abd800eb50a434057087cd80e6c2421587f1409889eb54651039cab61260190e76828488515b2b71ca6c023b9a9e1f7d6ac67f45acc24721d323ae731a0560b287b1c578e9cb3f2257bade29518b6e9324b10a7e8a2b0cea0da62f597c6902e26cb12a542e6da470dcb206f48b1eb6980b07cdf0c80aa64e2e6b80a4e87cd0b9d3cd8abc45927fa22566cf59d481efdea25c05115d230430e8c0848a3c7019a076f5e295e69e34107e6049ffb857513fdd6d602fd8f5d573f616592f9f250ee8fcef35f39ca13b1ab5797e3d97448bc0ab59b89ff731d8ed5f1d4efbebce111f8be1ff0afc7b6e1b3abc12703f8c65bbdac5862e809cf4bb25a90690aa23d2524e7dd81c6b8da4f00598cbe41d32d28fe635295b690c55798199aa350378977d606bf5ac166eacf11c44b884d5da5c646f4c43d07b69533609ca02fcb9dc47fc548c8627847ab2cbd0c8d9bf2845c741197bb1d2ad833d218b498251ca4db950dbb0bcc4f874fb523d6283bbb701a71f8fc9384ab9c5f71594c72b76e6192afeb871954a2bd31592bf558dbbe986b510a976aabc13fe8b17cbce34db39493cb3cc9276520446a19866ff4a3a95be30b173d312a10db39a15b7ca9b73db773e6a66086fa762cf98d59338912450c0139fe0b38df7eaca79248d0aad7226e74a2b3a2df893194164d2512b063f918e0ff2edd19ee26046b0f3d47a56a3471478e7355cb2c33643589331e54e63bfc027cb6f94cc3719da9f01e689b0bfc87ee70489f7781f8113ecf670ca1624c9716563155bb85bf43acdc3c520d417f6d34b2d3b8b4946d53433bd1e9d8b5f67a3ab6fd641631972e43018858af95c7c40afc9dd6d171d4b10cd875cfa41536f835f94f0c6b263d4ba2506325acc74c54333d83a1662c65bd60c15ad49056a5e6534d725e9817c529c535c4edfc0f0ecfce89eaa0edca3b7e2abe1944049c255eccdd65922e870ec78de6ecf9ab8a432d5cc46330631433b6fc58962ea9839788f59b57035c7f14077dfbf872b8c98e1aaf1be1bb4a65ee3564012464f6ad983d7832a093f0f6e169d60fd9a7d511ae1e9baaaf1e8ed4946fdf0628116036b5228a2bcb9e32d6d9005707883c0a6a856018b572e6ead973023ca3e55ce3de2afa4bfb822185418908165e58b9bf65caac3aea3bc973b8781349e8e46b094375f66f8bf9c05bf7b17b4f4a9e54f62b196b87b6f328e188dbfccc90e213e47dc5a1d819c1061550aed33b98ca39ce68c595990345f8c5a461966a69a6d81a278e0e6081db4f1614ffda0599982fb5def80737410939003a2a62f00d4f1ae0c754988a46f03c73d8f9440e053632df7ce9ca83a7ec7a9f32cd46ff52786202f8d245ba84466b3604ba77ab14a98488bb723d2d6fa6686fde545a76d4fb614e9917f25a2bf053dae662a650f1ea62c573d349a021a66400314893b22402d3f04dcc95ef70a42e83cb95b3da9637439dd52e337924cf1f49a4e09543c33c19881bf096c8d9956737078cd1ba3c420bace6abbabe362cbf9719d79710cc9254a218263059bbf94b38107ef9f19e81bf98c54c430b80b2023488c849291058d97ad8b2d475f037c3c6f95dbe0c9fd91c3275acd2d64d5653bbedb2e59ad3d18e929ac1d3fa6258f545c9b9311f6f4b5d2b007c0ace8492c81a2065baad32ffcaf88b63cef0bceb0e27be28b88166cec97c49589de49d8eedbc09e86a078593329ee42878e0d36a8bb8203aebb0c0212f5bb463b5b66c68b0d89f1525930a285914536cf46d4cc080b7057a0e3d80aa1b34d0dc5fb49853523033f19504b07451af7819c40d23be499b46b2862b7e2e1a36bf9d80b2ef57a2f302c89ecdaea8d7c6c848a6e57fef499b5b93a7afec6b7ef24ffe0b257593263cf87c48bf508fca24bbd6133bf32f321a58f2c8801e62e60059c694f374cee9686b0015055f36f5e72f112c6a78842f9ad739abf36a1fd9939b8634b27722eecd190ad8fd73427f228e7223a3f1403fe7c409f2d6e76c2d95cccc0fc57c4eb9a6d33cfac7b2cd7213b20f770241ecdbf45cfce586d4d9df6506c2203dacd3b1336d71f9d19794f8f9003d63476fb05a600eec5abd5b6f785b3c64f312a2a70f005bb65e339e1b6ac623447f5a7a0dc0b15ee9bc9b5861ce8394793c87266ecd0e1b66191efb856d6ce329ee4fe82267b5054d3bae6432be349502eed3c35ada17608b591fd2d14a3774725c427f8bf390768f2113e3351d29bb10725627353e7fef59038e3304a42ce345bf07969a47f4e5a2fa5ec0a8e810e60f25dd90b798bc4b1eb56a4866d52ef43b183f7a75e9e02e2a906f35f3ac82185659a876e6e13383de72f98b11c02de1828bb35062e4082d241e3940d9bce67b7b8aefd3bcfcb045c01684169364c54df73006da22aae6493c71a6fc51d20f34a0c0fea89700d826c8fd569324825d3c8e3631ef4cfcc16cdbf0483243ddde06e9ca5c674593fc3e5830649dace68ff0c60cb9df99039a0e3648b142d3a4979632ab719365b66e5853d182b0b2c6bb7bc67deae370a85d38fa4a0922f6120ec45047bbb5ed20988b83c03566ff44c788e61c9bf6f9ccc7149bab72ce1c1881fec4148c3df7253341d38a6f7a0138156d32dd1538b42437008748771a2331c1ec025b5a18597dc64d8c16f6a8f380d56ba9902d2fff18b63bea208c8e25788ca0a0b7ae7c3b6644f94e99e14be31dce0a2d06a6b7c1299a89fcaf02430d7b72854c56a5d4e337e1cdf73c3dbbfca7c96324dc5f894c13474bf28629286e2f1bc900c2cece04967ed610004caf3b8e0bcc95416f790fd2b0014168363f66636bbe0a4c8c64e68e1e11a5cd6d6d5de52d95d60e042a7466f90fdd4f0c6a0bb125cc2f303fc2fbe03c2cd3cbb31861f6dab03fcaaec0ebbfe273b30da8198b9a90f29e2a1d3660e06377eb43a66c13b1fd6968faeabb33baf9f706b2f5287ec0997ead0fcf1e61ae472fbb314b083a3317199ecd99d3ebef7532c68ec157106f929242ef0d140c5e3999e2fc576002cfe8fa840ec5d92813a6dc89b3339fbe760c69761419af49eb8da76a6bcf76a91cec2f80ba6a0d756197438b74e72ac8b058d711f2e896493aa0496205ba0660cd4dd2b55dcbac1367c8a4a31d2857e336c6b0263614a32c3ad071f913dc46b206d31de8853a721d00a4358cd90e1010a18ce5a2f5a03b11a748803e24dd81bf6e0cad6253cc6587bbb0ac2228adbab5119040ef5d7445c54b8235a91b06f878b20e0cb4daa68cb80f7fa2333711b807a6cb1f0dd3de6686e787fc90cd1fe592e5e5c506e469c9f15b4a6e3305dd77a231f2d0dfa423ca08bb54ded5c7385c270971bd74606ae218b42a7d5592730cda0f7c07c88b0adc74e8e266a0b3227b9c89f77593852dfc9beb07aff1a822b91cf5b414567f4bcbc6763fa3ae0db162407606d96784048896e47e43121989936af18cdd4906313c682c3a25fe23265c8d8446e79b8eae34f03e0555448701a73ecea1042affbb5b9e9ab433b8f879a160e0be671941fec255f549ed4b17b8842bcdefef641b9bc30fe3d7f4cb99d8c4b00491c74b7eefc7448e359fa0cac978b58a74f16bd4bb8049840ecd4714125540b09508b63004ef7f630a087db2f3d87a7fa6fa1cf1cab4af30891ad676acff5bf7f379cb819a4cd6fb016489db96ce956d02a56ae41ba944cd0b59e6c076b7ac8800c43db7d3c310adb6c5c2389936f94f7184bf86e3e85cc23bad690c7b62ac056202bf980a2622e47f4fb372dca8d8bd03eb2a661339334676fab41986a0bab673c1069a013d6f31d01f48818ff297a469fb989e0e048bce8bd511d160473c63aef777bcf3a4bcd66eace1b6e53b51c0d46fe392ef8d9b42652d541cc0c940381fa77585531a04ec5e81820acaf5a6f77d20fccb19792f69703310daace4b7e4959552ab7f961c2b2fa4adde2dd4b826f16b9cc57c8c2e5c3ec813ae98c3e7c30e18c13b560444db2321d5307c6bab439f920b77c7085c23e4d1e8ddbdf28a912950b2b09b0f95c3cba8562e799822bb95619b0573b690276fa3c6ba55bda2a25ce1f97d5aeebddc8c57e1317fbe518f22a7f866f512e0e43fe1d75e2bd54acaf2913ed80947b74fe110ad8e44f7af1564c4c7ceccfbfd6ab7a2552a52f99a30b271be06b172c36040569dcc27b89238e4c3514172e2615b03ca326579c08c482e2c8667e87a7fd462c0cc025faca03122faa598e69f366025c7d44f1c586089aaf44a27c6dcf7b681b0060161ef1f663c3ca43f79b0bd3b864bc755f48ee0807a3b9c848369ab63f4bb1e38ba6a997d8859b575e1c883644d5f58f8932ed8d333fbbf14837407064fa38b25cc655befcdf2fc39886413d97343bb8b15b7dbc861df068061dc1930cca6e4ea9d1c66cbc042cbc89a01b847a7a9948509e9952de8ba0408daaf01022220f67d5d02ee27c2fc30deded551e9866fd6d5b1d04b02094cce61c879cca35ff5326873e9ba0a21d34d1e7a994a70043c6a09205927b894b29c32f01b066c008d7f6458c1bfb154ad2644ba88070b8ac60a2b77d78e512b6722f44835fd03f7f3d8075a5b05bfad4b039f21d253da089766cf6cb919e81d38c176d1962c51aca2e0d2e31e1081e4f0c12bc9b5d87a20cd0ee0cf36713c09e8bc5aa1b7aa5cd017289e56def92799c30395b43a71992789bf80f439a22e4fd8abc7310c4e8980e1b2b9c194934dea2430bc390759fe1ec44d3053a59d3334c2c974e625507ea65040900a4728a474b16d6e4a911bb6af125e4738c3c7139cb71a3077261858690647ae01d0f0213a28bf193ac016424bc75cb5af562f34fbbd422ff017a4f106a77f5f8bb16e9439d0bf2af3282dea4e680e49868b08e648642488236ab88bbe607894f638a6e63fcdd486d07beae1aabac4818695151be919baa2c34f3ebee0abf4cbbf4fd3fffab289a4a08bd9717c14ca07765a1ef092e5090841db56cbf792f5a4d76ddaee6de9dd86946b723b5cd9539c2d4ef1fc9bc9230cdd9512f352501af63421d64ec27cc4210485fc6a46ad3c91f8bba9805d175e5c1674c154014c826b4713bde250edb9ad3f1cb1b74518fb5224005d49c43da60732928e81bcb2d8c78f708aa48490c35e80a60010870dd8cf765843f3a6a9b8690093e32620d10b7335ba800ce279c8c8f623f485f9c9d31c59437eec9f5fef9194e451f81f84e318152f4769369cc423b57c73934fb9c33c44415e9a5887df595fbbc3893d5924f4387326a61e5cfd6501b502ce62a94beb0077eda99b94b44e670250a46633f3401681e0a7e8f393a630aeac8d2544359047f6b2f43d9255430c0280a678f5f1b1223ef86a21f772fdcb61ee9f0b69a002b129fe1bc1d6d90ffe4ed1711282c26dc734bd352434c507a84796b2af15d8974069d4875902de6c963bd0be60e937b22e36cdf7192add57c9dfd3ac9c5812f8b5a8611642f366cc55abfdb2efa217f8d1fb0eb8cc23eddac90ec89d587d255dd48793b620fb5481e2f8a8e13a6ec3413ae5db37e323a51ff31c587acf61ad61f04866323c1bba99675b3ae560230320b56578cc8cccba083c6acf6ea2c4d5b61e828a1c761426e5a234860e49fe797326f8ef76f969ca7b5123e52cb6ad686f82777114094a43342c2e7730b3c0fde1bab02463f162bb2d213adfc31ab62be84034e3c9dd164104e9007a732db303599382c07edb9a604f466401e95a5f559f96d14fb1cdde7acf2c9a6d0da3efad2dcb8746fb98661050edb6587e96bb7802cf05179316d5e84e071ba29fe32fcc4d89f67598ae14e3ec45498256c9c902af1d9357bc0469a0a78f16129e12a366992e17e9d60a0243c6fa2623da763524d5155cc3d6c712482a58a97a29d5ca2126256c9e0d629b92519ecaa929c1d3e417ee57ef8b64c27d41e4cf656c2cc727802424b08279974fee805a9fdc46387523001aa0e45c6806e8822c1737f91c9b01a55dd6080f579ba84a0900b92b10bbff4b36aef2f2a63885ce2a208a4435564c9586535d800e2e939be3576e8234a1af87eb943bf5bfd4ad5283cd1be15e2456c425c2f6c5726749b36fd5be9d24425f7afc8bf47354cdf1c7afe826b5c7b3e3f021ca2d5fbd0e02056c6e289a4674682b3a756219cfb380ba82ebd249fc1a9552aec56f9e0cd9c92875294805a934b2c1714b12bd3f6f56b9c884f4598aa210d3e4236c08a68a68ab32e94c61952ee3a95bb6a549ca2a2a2f0ebb3ed29b064a6f0126f86532c060a9117f5e3718707e2ab7e26941ce77eb902756e21e81b303b691394f9f66057597b96342d46eb28b771409708878e32885f472430cbeb5ac6e3636909fa339f08d2a50ed60f4224249076db35ee5ac33280f28525f629f5658d202c286db05008df491d67c70762b505c4e60244630eccbaa441f747b0b66f84f8a12ef356457d1b9f9c3e351f0351242020914ab2f76a33ba3bb6e4d3e6fa759fd01474fded394c05df050c11e970879cfd06afa989679b58e55b3a6e061c37a9a269a3013f88508f29a605aed7767e101712970fd55822d92ecd0ca01a06b8a12132faaa22ac1ed057b04d287932f6181b295fc3124471fcdda072a0734411d23cc94bd5d7fc783335eb83ab6caf8556121830b8b19bf19b0a409ea34b7c6ecbcb5e60b24b94378ae11aa826e8d53d87e47727628ffb6810b8fae114cc9609c7be86762e292391f17ad9f761026d8d7fbf21433d1a4a125f863460ba92e9debc62bbdfaf3c632ce252e0f0838c9ba41bbe6b36b686724f8a787a986fbac8973e2d9e2b31cce1fe8bc373c75912443a0d33f170efc04c4ff574107ebd29cc7ef7fc984938ad85012867556639c29a61b46909b4b4f7d42e1e7f9edaa7d028ee0d630b7809be61336661055beb29358ee905506321d4af9e88e79fc7204856cb99298402102ab77b320ec46a28685e7b1437a437f868ab86ecfcd8d3fb537e5f4a588f81d08f0d3d946f5232ad4795281b350f64d73cd30b82c8a0049f9d2ff5db5be472239f423126f9836418a432160296b1f654c5826141fabd34f68ab333c70ee909639b7fb78067b00842e5f22571f5eb997a6f4259187eb1a29841275852cd8cc288b68d564eed789f1fd109bbc9d08ae274e861ed80dc04cf5ddcb1a3a16c8dd16884ea3f54f628ccc6ede66937ac0355e2e12653604da8027fd270897f88a9f0fb1a9912f764bdedd92298ac182254514afe9be4020d0e4377f50e68ab8cf185b68154c7d95a65793e6701b7cd074e8b96669f2c5c49ac8487751ced2aeed1a31aa6c6235a5e2cfffcc4e77dc43829d89ddb6c6353250f7abc85974e30236489795034f46ec4887c16355d38ddf74d8df0e79a66cdbafda692fdcf980d33771cd3015df5077b082d08940716b44da142498d17758f8bda771caa150e5eb82e51aad291b6c4a88bdc3ec226e4c635e989a997d4f5ceadd8d037372af2e7e4a2c54942b303c2b82f09f8ab742c8499c2915e61c42661a54cae761239e1726a1480532b9d38f9ec860f83a35d4247c8fb3859c0d07d6f708d76889c0b737ba63de50671e32866a018ea2a18b4f11952cd550b54fe251d2fdf8c62aabe0934a6998a4795eec6700fa1d0e29772ebafba90754a3e9eb39ecbc02ca3fca67f9e5de5193a90ee39c6d9095dc62e9ffc1eb01bc35d687e8cf9a313d01a2b141cdf8779b2de3b1755a1b17157516fcae4e39c62d81416bfa6a3edc6b1bc484dff5054acb4f5baa472d9a336230cb9e9affbbccb49cbcd839fcf877d36405718eea33ec21a61773c0d9a6b12c3a5dc881f98764b5231c1de56d978e9145aaf2e711b06a08ad4baf24f71da9ab7872fcbc63e97d30c7138b1c72a6c7775ace7353838343cb0b9fb13426f4555ee49de20b7a03cc4305b707cdde4cf1e8743a1dd926a80425ebb66c7c9cfa193d5dc41df42ec8f04114932d40001eb64893517003660e7cfeb03ffdee2c12af6d09bbb44ad95bd711c5869a7df958dcc5348f3da029a98cdb1eda1905478d4005fe05e6c101df1c9db28ca51e39a9de7e247178d824b22b6171c55ec9996d314e665f338e418e62faf93a9cd74af00c58feeaa297a61c637e2956e5365431aab87c73b2a90230c5eb6c5317a334be260b2de1c298d12e45edaaf76553576f53b3600671569fc56ed6412acfabfea5897eca57f3ddb3d88b99464c7f900c787b88fe65949c50e82591a76b90271fc80c68686cfd939dcfe26dd2f9dd5bf951b87496056d6d3515d5d3e69638fd90cf64ad13785965e4f7d11454b38f58581e35ce78d2b8e44f2e012fad2f5dc240222e3a762ed9bc40210d568da860aeab2a3e749bcaf975f90be6bcba579e49d46dc85a6684198ba9fb665d8b83e05db919dcf60a96cbcb132c257db0ca475076b0ed7906b4186dafdb45794726f1ff102232de2a0b3647dc70b8bfbcdc37b5c9555bbe873ed928bbc8c45bcdfcc910b9371193fab3d77f0aeabacd71f0f2ab9b1fe884ffbd3ccd506a2c16d89b2c4a87423864639b0003bfad3bae06ab9bde9809724b5b921628cf06f18d4455abbfcfc9107d8350d5057f76787c37cf966f24dee68262bbcd0d9a26a67be34cf3b814f5f2b61a96d059d84e64190c843864669444a7becb08e8d2069a34334f443f6e6f8e4bae8ac68815a251adca20fd08a80903c37d725854536505008c7c7a6552e6c1a6c2fcbc31606596dfd5f640845b6d4710e2f8f76434831e0c844a75bb23c5ec3ee7553a5354b28f8e19cbc4c418bf03a2016aebbe7eb66e37c24ef03db8e53be32ba451917cfcd61f5f06bb1b5434066549852b1c6a95a0eb3fe8ec57e1c8e934a4a5bb707b34e73652ad8cd9aa4b6d3b25de053f0aaa9b0181bc512dbbdec52ab56640d0345c16f5588a1c56f39c6346ef800ae889afaa2b905e8352049f116095016d0137d087f6a60e47a812032df0597fe12beb029f585f511f6597404f8aae8f69c8c0d664b204a3f041eb6b8b937d04ffbf5f55f5aea5398aba9b811a809b17c345e3db470e7757b66329aa045d522b480944e0c544b25520114f5ba0f1a74eda1cd65aad6cf98574dc1df04ddc27ff18f9c8c8e9b59ea09495e335593702d937034f2d7144997db930fd56bf32b3b3d6d6858271aa07c3d15f48b881b224b7d64881da08c5ce1a853b52976551ec6154af4957249b156e6ffba1e5de5f85be26b694bce272397f7b417c69c394ca34bd00fc9192527587d571fac34d1233e3bcb3dcb0722cb1a96ae23a1c7b312cc984ccca62cc87b64c353efa367afe6ebd5f50532a52a8fa421339ce7d5598ce4bcaa3afee62291ae61f299f59ee21efbee1393998e4702c83c69c43c9634f4e84152eadd24f10c47bc533851a219757abce61aefcfc28384798449a0b81bb06196a5e9820c4b4fbba7f844bb485c165978b8e067c820cfbdec63027e9f42573e6e40e28fcdb5c7edb570fa47a6ed9eae77a3a297dcb9a6616ec9451827fd38ece22d93bcd81c13360cba5de3f95cc6e4c533f5c8dea5a0893e48ccfc5d9114a346d1dedb7cccf9f17c2d945092d79ff121ce7b6100181230ebaca7ed1a63dfb0f7437602b0fd38bea64c2f8a35f10752be25bf28af07243bdcc30604f7218552020a4ec9272a44c8ae47b96239130b6ebe1dba9ff55e27c35add5cce44bcdb634160b3dd04a912ae2bd2675330deb191028a29f82f100120559e67c674562db121ac818e3807ed0a39b5f2b10c8a10a7af19b23b106878eb760628c5e795e5ef8ef46a2009aa4a13d60199393d1dfdcca2caaab440bd457283fdb4f0e1e278ee7fbbd71fd681c943833196525d762996184b0d7417589fc8cfc00fc584b9dbda17ef31f57e005129425cb933c576f9ce040e91f1488ea189271fb5fbb6dc5898f9aaf4f88299a52add2a0282da63b787deb82c8662f5d6de7dc05cf72f5180ff591e7b632e597be327c79169fe0c47ad598a268a46d81e2b9260d1990c3e31cdbb0fce5b3c425dba6abe244ce76f658ded4e01de0a97b32d0f7c1de6bfcf7d9ffb7e8e64747690e94d2aa37e0afedaeb1400108376645ac0a719ed8291788929173692bfcbad1eb1ace20dca44180cca89185ab07e9f08d43ad43f2ae86312701044da861bae9ced7735a41e0ce5049163f38c077b789b0791a546b941c7ca961e5cc28fe9775fd5f9c38c74d38481fc74cade511355a29a8dfbb3cd5721e773924b22d78f41dc8f60a284679ff9b06d5ea80a0fd08d548e5a7cf3d2790c3454b597855970ab9638feb7f687c5b7e9d022e7d53e278790d281cad5dfbb75041f0c28975c6e46731d0f5827ab7fd289ab630498ef9f6ee8cf54f1a2ea426e9b034733f88599c2874a6464606378f0ff5b2f1af015b824157376f1ceb21d8fde46db5bf7a157dc925bff7df01427e99f6d1586163d690fd46d221dec51d8f058cb0cbbb431a77179530782acf25d2f53d205e2b91eaccbb26a86fbc1d8063db1820b049596ef605c97819476cbdf0c1923137f479f64d0ddcc0236ade6916992138fd7b65812128a1fd3cabda0aaf96ced1266324b71b76b9bbb8471191b4d71465571ce6272c7658a11996646b180a8d2ec068fa97a7414b5944bb6231920c506786ca40b57cbb896abf223a951293f7a7ed17007ed68f8651a17af337924ac965719a79da81a88c7ecad6018828cceee6f19c7ed64e1d45172f605ad316150750a24b3f6e81d9e46c1bb0012b9105917945f27e65f50c0fa3c3252d1440cfd9e0556519fa0f874a57f2e8145c5c639dad1e64cdb1200b9e020747104fc5056dc68539881939403e519c890141d272e9779d28ea314deef2038c60d054f71cec4221d9b8699355f5bb917e4e63be5aed280f5e7f0e4f2188c70a59e01e7e5eb7e018618ff389b417a28092951a182c72e90ee75f673f8ac542a63478bfca9492d295b9dc58208c675988fc03cbb8589a43ecbb310626774841d2d11f097bda904c8ae3c7aca622a8d4096edd22b9376e23e5b83631c7717d70133aa41a0ccaff10401b8d69c015676babd9fe08af0b792d788a50f5ed1296ffa800a08e2c334ca237542c07550b040e046db7ab73d8d8bddfa243e7f0e731f966c610fd54c8161090ebbea338fd5a62a9da771f0110832a71f24b8699f330fe4456b1726506dcec5c004658cac2c18c8a9747d2519360768d76ea46c2df4e9318a4460bab69fd063e88a62c2061f62f3b4c1def06453b025ff39f87b9521a360d24728d86599b68b01cd089ad29b752ad3cde8cf755f016cc62392779cfff5b40ab53f5de1548ce6b2a15897f9327fffbb61580cab3a70ad2d3081916602120acb9db9dd2c61fdacfde286dd83981c36e80903e11b7524a6de452ed78c3f381c492c13b6d20064dd18ceff498e3c0e8244b61e677495f24374e76f35321867fd1505b3679b81598b2a136eb79a07fec1d6ab4a6cdce3c76f94ff6b861722feb3c1bab4c1ca1a9f82800890b988666c80914623779a55fdbbac8a442abcf5282ed32094c37a88cb3b983ffca9fb1d01eb895baeccf972e706a98ebdf856cf0a21d58ba1c568b8ba76ab80f10760f1489c14b5f848cd01375e4475658053f8397a5c30ab83d9dd93bd9d80e1b65f958bc4b51caddb45d01aa69a8be224c950504c0e6c2aa1d2d71d0b668f5605fff78a60f5e571361b40e69bd04fe298c32b866864b65920d263a455c00c1d4efb602a11bf798ac68819dde54fccbf1f2350fbca8033c66068cb645ef8d83c5ec88873a64103667f0ec7ea3589f1158b34ee7786cfb168a99ded7bcc216cc29b756df336fdea4ecbf69cf1c4cc626ed17790c3240a986eef37acabd86c77a9fd54b158d4e782ad62d4dcbcbe0f425750b525a672394c29db0de26968930e3afef9fdafe8cf439c6750829f94dfe8f28ff43f592918bc3c59e59ecea0136d7dac52fa28d464903b90cf2bc7844ee54462d66bd0035ffc3563a129520bcbfc30a438f68b71fef8ac8206fa483241949e4ac2911c7999273b71923ec9bf11e547a7ac404b6fa0d06e75507953a4de287f8b095660519b42310031cced88b935803e6319f530b552c6cf6c9de44c92c080cd79959b2824dc92883f0f98a89a109f05de845667e92f246e6c194b4579a65e0f4cb0707d15fae6f00eb933d36ddf187a9c83a127b5b58e7c348a8ddbbeae9282c0bf09bedfeaa2e1df35ee1c03442694c6ea011ab0c1c9769e3ecb1e2a9a056adefa8bfaf17a597adaf5e8f5954b93cb7dcdeb8425b848f531dd341c029164712403b50cbb1f8c02c217c30e6a7015a47fb080e9073ba667828252eb9190ab1cb876d5e4d82a70ed24500ea1a2345a3ef391022884715024696b676d85be6ff54239355191ad53a0a8f096dd30fa50c5a818e1447bd75176950e55acd2e60ed736bf62bf3478c30110824321289ab6328ef062fa177082bc03e2f45d442b2583e468884f29adf10412f2bb1f3e37e9e7bc5d51f34225da1387c2bee3571309dab37c5a27a7541b9f2d604ac589db6eee0fc54014a3ae046a017c91bd6d327ea08a756ad18823f9d95bccf2d37b7e08dece6946b753dddc651c766edaad9b6519689afa18f54a54bd436242a5ba2a57b89f87f1a52ae703bf84d370a7b48298eb1f33061b64e7ec39c370c8b704fff8336a433024d8759568eef576ab830d2e832c5c6daf757539e558006f39348749ccd985706bce3949d7abbfe4bd43b06398e115cf0bb50ccf66013b0c50e7f469faba52cc534f084c841d4e85946f995e80f0e83feec574b65a2369c79497a0bbbc891f4253a7eb542dd6d7a3f6c5fa614801905925b1abc35d4957ba33cae499c1086e7b3ee6d318bdf84e0e846534d6245447fad6afcccbce0852bae979ccec4268d0a3a0f08aafd5014460436ab38dbe816fa987f58efabb73f60d209c6bf485d7b6e6bafa0dd53b0487ad74d497a782c577301f9e947613d4228ed73c70624c7721b60e84c0f2fa1a31ee3b8cb23087c1db6fda5a33f0bd6d8cc295ceea6c853995dec1b6bcd912cdc1339699afec872c972e53cac1bd2ffe308d320ef8370f4e7071dd1e418c476dc7b71ed869f20e6ad4c9b404022b1e7c18136cb969df47a083bf2421aaad0abc5c931ab662bd1e1667c7f40e58efc558fda4bbf9ded5368239b3b618903eb011dcaa8f21d255f34ad97fd8dc37bbab9c4d1622db51be1ba2f221f38a789c8504c6a07ea6a88b7814475adb60c3b390905a83f1917e940570ecb76bba103ee7bf1b3fc2fd73b586b41a0a20a716511e008013a3e32f5aba007dc7ff5e6cbb8af16d5a7ab2959e4f9addc476b511110ba7563ceb3b455d279f875a2ca20584e3d44415aea9ba3fd394c44fe764e6fb2fe9eb40e177b6953b84e675c698dbb1e3749a7daffe62e29676c66b1cd8c7b91543834374ddff23e12673e417c83d4d70ca14e8671d33a4b4cb6ba4c6f7a046d0c61c71cfb459739b6f526d887698c0dcd9fe973d11d43e95fcdcf01fbd78736356fc374129fef1d33bc7af05c88b9e085ac6d79ef62e64748b1223243fa922e34d7a9bc9d95251757bec1523191998ee47bcc815dfbe5ba4a4c4b69d6c7cd43dad062b6bfe5360c5c82058a04e3b8824a774f177a4a0cfc2af4293c973152b83276b56bf0ab5d2efdf436bab28aba6942437abd5e7c3dfc870f2b670f6f34cc205b30ec0121b1feba8f6130d610900115a02d9a6b819029fc683cec2604ba9089c9f8cde9a7dd1e4cb2c9bcf4942b61f8c18f3ad91f7c57badfebce0648f5d1def5eba819d039413c9efbf6b25346cae0ade5990b4339372afd10fce17d95f9f09682d0f84a3250ae5063109d193630883ab59c93c80869b8ef4404cb13e3519f3e403a5723b7318d3389a4b17d027d51431e4e8406a346298e0a7d9aed537982c6358cce7feaf9fc2d479d8600999d1368694a3156cc0a1b2afc7852f5652326a2bf9f548b11b1f08d0e96cb41591a6deb540f8293837773448bc01e8a25dfce52568e4754a56f8fd9417ff9f59159cf200196468943ecc4d4a3ea45d7acb7900ae1278157a46a8de227f974cbdf10eb70c7834e6e9ab71fe8e4cf1be5ff376ece9bafe1656fc44a0c03adfad752bb50aed00d08cbd10587f815f163efbb0a070bd4bfe650f8e0b2b7c83da7005c7519e48cfef23200eede192a305cfcb5f163de6c4da3593a870279bea322693ea8fc4f351a96aa29fe88f617a1fa911dd09bc397beee4ff3ff96f61dfdb08862b355d60418bade190ed8c3c48d3921058a7497137758c0769544a024846f1fd8188731409bfb48cbf90c050e86a71420b833afd0415b9c7445128e218f2af6323154a5b6bb5d2b71833d2a25993cb61a2a1095f7d617622433e2fdaefff738d4e0eea90c9d39b869792530fd0b13e905e68a08f2aaec5047d05a70c3ad14f221732dae298dc56b882ede849de5c83b53dd59f742771521673764ba301a52bd23297834ae4cccde1b0c6171731c35de230c4fd24fc7f5d9c2b4786296a3d0389a5ab6a2af7bce6f6388b76dd7bad69b4ed3080f64c050825d38c6054f7c80fc79b369bba4fdddad4273fd79581c98226d7f21dba56d5c912b84b674629b4dcaa70a37810691c2426d4ae3fa74f603e34f6044893f57198731bbd98d71457693f6d62e7eae9a6c0737966ebee53b9dd7b00ab0420bac5937fbc76d6e0a6b88965623af8f095824237c6c1a295868d531e85d2215ca27ce39c4219ed8f2fcae540e780f84f47d66b444c979d71aa0c7513c32690f639fc23148cfba2f0f6eb48584bb863bfd5d2f7234a636ea3d4eb752fa6ec048d04b4fe99f5ea502f71af681d4a893fd0f1852360b6e780deb8997c32b8a11e292feaa5c63f8b6aec05511d78bd4d8be66f21fcb48ac5a60515cd9eb1a3ac083435bee7add9e550186d2f5dac59af4aacabc79d3109f4983cd90c452b486a2f7506555ddce658bec0d92372b117a89b2e03524ef25062955d30582ac2dd2ddf93fcb2a8dd5ae3eb7174f9422a7a4763e2cbe30a1d01a4c7ede9d2e99968bf1e1abee02ebb671e9ca465228623733427a3a0640dc6a84c73fdf5d6b0c4ef7e24d167d152d13e44ad45f8ffdc1cf9f8d02878c3792b4d74b716c91fdd4c4ed266d1d448efe38b626735a97f1a49f5ada8397df33d97c51a05e341f3dda682a7638f065becdaeabe02ce1095f6bf22727636386a460242e775ca741cca0839e613cd45139374355bf46e4ccf314829af5c5a11b0923ddb1b3db4b55bed550b28c33c3fbf371e9d86f4707776e7c739b06d2746d8dcdbd52a29593a4e2d6d91670fecf0345e44ad9155f8b9bf4630bd00dbb50bf8368714afd7f25ec8d8e7fe6bea9acc9a31034b99bf6e2cd6332206f3df9c95c05244c37ab7a271aa8aa2137056e7aedb0da44b876ad70484bee13b5bdac2cd7d62ee6eeb03870c7608aae07e8f73c89f835d00adc8c797324cd34488c41e8648e9c15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
