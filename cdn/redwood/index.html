<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1541aac695bd45b81a9d3604f67ce5458c813729e19c162903bedce888362f5facb6223c705376fa6e4eef30a3b6d988aa7a40ae361d92c8b9789ad1281b2c65d72e999f05944862cffa931e58b70716c5b800695434f8caf9abd4f5d673720cd5d71c74f19fcf05fe42a79b37b6573e8cbba624549a15b33c7b0e99f68454ac74f9a882505aec5d9edcb8dab4f8d3ed265ff2a0424de416909add5fb8f91e4a9d0a4ea86fd02507f0343d54f9ec9664224eb230ec42784f904a8daa521b6558999dad7acc851b9c9c006e35d3bcab3d5320b3e20d29cd78f26f97da4aebe7808ecb1bf2c8e9b9ec0775fe45be4a80b70de9443538750e69ab08e551946f1f9f74c7bc5805a4fa429cd8d4a621f18e46dd66b3f29e5e638ea2032fef126fbcdb6b668288a39a5eb73313cc13a64d3607e6b946caa90c796831b80a83a723f36b73ff6c729a412b414739102237c378acbf0140b2bdf08e3f911eff8989a3b71468ed49ed791b4e400393a1f030da6f0fe68b3a10c75f1588a880cde4a40382e5dd2a7ed6dfc5a12cbfb69ebf211864335676a6549d05a0436293f81137a937fc9223c2990842a874ff047373ba662ffdca23c32e83cc8197b5c68b83f9491a5bc2bef1e76db7901bac36c09bfa2b5531bdc5afadf1edfef4d2636daa6be23ef9797c2f9666cc16bbc5db78a6b7f1c96da7ff22db83a58726878494165abfa90bc4ad709e4180b4ae979079c62bf9771c97847e3fac3493beb8a813acc72db74f25c745bbe4549477802060d06eb7c14961dc8d7b1b57ce0f2d2e25d8f67787e46b510d317f9cfb687346c7f4c9229a812378988ad17bdc2740cccbe11baeb64b315bf4660c0c3dd0be562ebc04d8261b9b02b406777e64a0a6c4d8e4c709aee7c26a35d2365d6b4a4ec8c7908bc67d5a73e445ef6e46dbc5dccf4e8110ae9c3ea6e868694b43f9c874d4c000984e80db587cd293bdcf7f828e7ebb0a280b39d7a893937f45dbfb39838a07a7ccbfb131d4adc130488c1d54955ee629ae8dbd5febaaf66649e502307690ec748adfb6960567b95ec6211472a4218b7aeb79326a00a717ab32998eb104bb5f7dafb6c8aadcbf74a69ea052da833379e2262ede6c40ccef3e71c1651c41a0118ff8b1c8681239e95d50b3718dd6f767b0e85fac4c36d694f2caf70f223a134582948004f04c8d821f32d2072ce29689c06513e5061daab37e81e1ea86df96b08cb99f0de1ae1060e05c6e81240984344d51a549ff3da91c2210cba69cdaa3d27b714a837b92738ebb1573699fb42f663148a7b883bc0ff9da39b1aa0b5b81836059f1136057d4405a59fee8a6ec0d7a31d89ada53b9789c3b9234775a0dec3b4bf56c101dc6ac52fe4a7dbfbea033588fce7fe273ab192f6ce72c6fee9923a24fbd38dc344c37a525e6701965649bcd3edf5e1d24f7e2382476c1e8cb3fab47af4f8235825ea1f27fbab424f213b116b7d6d941228f0308f6a9fbf1a7c70a4f3fea3fb7ed3df69e2b5d26381479d69f00da0dbaf33a96419d98296f0b373263380ca3993861ba7a7965333ccac123c0d7f8283b34969f0886901543c133502f0eed2ab3863209ebbfe0077f1fa71154f984493294a768fb265661c8163e30e8cab4dfb1b687cda71098bfbcfe3de24ac53a8397ad0c18ec42a5339d9677989dcdae436202da2ce015aaab43bd1ddd796888f4f01f239c5952fbbce4a88115496d8b1ccdd9e429ed95d531d3bf6fb8d8c666365a4b6cd73758d28a60a7f7186ea2f973524c2f163be6d6fcc922149950546f42f291a25e1066daf6a0308feb7fcc8e3cd613b804d535ea864c503dd8f0f9932bcb2f88b42a25e1d448543922d6737cbbdbfca32e02f1f4a4221954bc6e1f108d5997c1b3bc262e1e4e43b63ac973284327ceef3eb8f0cf76628782338395af2fd208edc70e2733a50f352ef27646fb8c38eb1c28685da0778b9cef0997d1917042d6d34f99c1c85e58aa1198d63bcd2fd0e0678959e462975e8c58728f41a9d1f008d8cf9a48aea582e9f0b693227555b6807ea942a4d57afa92db3564d138875eda96fd87d0349d35b1036c9c620f79d0954a9e61de6ffdc4a9c67568b8ac199459e34cb49d670df2082181d8405e6069a1ce9f37e2be26cd8af97671a11d374f13635ad45791df979981f837e15452b3aef6e072ad0aead8547c59fb35b103b7918a237bf149d29cfc64f75473ad8734eba6483350eb0c9c70b3c43bdabfb4e79e77d50333ad28ebc1134c85e22ef99a4f9b5c7e30eb51b2634efd0d492cd6e7df0d0105efe9615c97a1019291af395fc7d3d46cd46f6cc197eefee51d7133f9b051a02f4d9830212a2860ca319e44adb6d11651a14a7e13bc1026456c4abeb6ddfe1b0f81dca3226559fa52db02177012cab296b6cc988a2123dda3129659a25f2b92be6f5c32f767e29457dbe52824c7d530c6503bc2e287412427d2d0d60d9674ef8ac6cf10234bb9c841558bcf5b5836893677bad12a8c34f677b6619d66ed736296358c20e2c7ffc83851f365b38309ec934ecd4192a5fc61296b104e40b3e1ca77b8985b3ef4392896880fdfcd70ead5adcd2d21b1c91f9b3ab040fd44fb2ee3184b7b80b2bc52407f6377fd102f3a8f541aaa9c2c1b06f8e081a3f9648a297e446ffa68ae0f8f79dfecfa90ea2b8e3b4737cf46eacf814af4800d8294cd2615f4d0be4a140ea99654ab3a7312c57b89411b3ba3f1e1b7e7b687131abde5a483e3b527f9fc6c6c1ceaf6f73825a3156c30d70dda1dfbc52c4c8b76063bb55684fb57e646a8d83c4e1e42b947e10997cc039152cce690bd89bb1dda991bb4c529234ed5d576c864901bad77892249d0508032b79acf90c56ceca1a306776c1d8b2f6164cecf3dd257721b921f549d92b94497645f44d6df2d9a1a4b57cd2503f106eb2662672a00aa0a8f91399e69e61cf532f8b59e8a3235c0458533485c5c43fc6a4a49b4a1b8ebf38a6e3b3bc7e91da4bd02e2ca0f4bcf3ffb1779f5c54ab22ff6175d1d1a69c69c4e9333f70b0a55264dac15d2e6d508effee35fc8132672fe4074bddf3cf38a4e0d12625759293a3530638b5be84024c938ca10ae27854276b7266f3e8c781cd931314b52929ddef39aa8be93851dd7cdca1144d0263712bed02ac1b757a7380988dee78a4e19f1b2b297c642fdcdc3191b5620669686e41f489d12a22e24badada6b62c6431f2fb44b5adf0944bd49d6710f75dd0e24bc74329b540a99cda5159085f60c8548f3f68205abd088265e8c5b1ab15e70634cc22d2ce834c4e948cfbd2cd9ef63fae805885f09db7b5affed7867fbaffbf95c637c0a539820575405bcf173ae02e785cc7e8051f8908dcdfebf4dc90e5c92d773cf3e5d86c7e1a9d3f3d659918a2baf548c4e30e1fe7912a7dde84e7497476623dd129595c31a4db1f9ff875061593ffa4af88f945468197cb0473d026de1387daa5415db328ea33c5d6359dbf11ddd39912b32129dfe9496c1e85cbbd6a7d77ebaf1103d80ec03e5c4fad68aa8e146a5d5c10903357c041ddc465bcc531d84b0a1f65ed991c160c54c0bf4f95c67b80129410904e56e86db94062a489c79f7b01002b5e9a3f5220b6c756eeacd42e5101be52de22041462f00b4ae0946fc2490214218b792b394e951235c0c8f5ca72ee57d29c777fc966c4e0ff73dfe971c26099623366a0a1b1cb160102d688be4ec18871abffd2df1f50680aca7f95551bcb850e8f3edb32a18f559a608c023d459b356ff7455b5e876260fe1b73a97e733738484504d4a086653127254cb399da9a9de6058fafb758ac6fa6d3391e0f3b2499b64a2993421133a567a23f187ad3435c15098decee9ed248ad5ac64ced48311dee679ac7d9a969c5b8eaa28a08e557c8281e1a1480fd2b34cf0b62b328ebebcc26570de421c3a7424dca50116312aeda559962a35df682eb43e957872294ec538808ae9a8d7092b9d919f37d873f8e75d5da702a92c35e8efecc4bbc6442e5fb5798723f35ac3ddaa3c277726b988e074f88ed3af9f857294d69a843e7cf5f7ddf639e2aea974d60a4cf3a2c555a6259f50c22f468968b312d23d3e19b0af99990166649290eea7676e434c4297af85375d398d610c8b17310bccdc2b5e54dcc0a7d52f6bf45740b2a83b1fa58f40079a6f33b8625b3600d2215b909dc0d8de4a242b11aa125a4e4c2991c1b4218b376293b8e92f78f56c872deeb2b4f45476a92ef394f533461f088ea980102e7c357b214186b4a185f8e196e1da2583c1747be0f0c62009a8541eb9ff7251186247ad818eac92e017ffd4e1de9b8224abf5da5a847eefff5c07eb7eda35d2af609eaab5be86a41961384385d7e185af036ed2252da4cdf54d4ba1c299cd9c5dfabec0755936d200733493ef39e7db438f66d67cc2315695df8fc637faba3d9add9f7431a7d2976f1d081dc7f4c5e991417e860d4250369ccaa1b3a56f5e2c12859769a12edbed58905f5033a87c171f5b24444eaa76852e90396ab4a339c79dc329c9acc3b13ec0d1fce115d6e5adab962e1471759cceb5aff5bf9f681ff3f7a1576e6fabad81fa261d9dba8494dc0d3927ef8a1998825c7f54b9a1bb543dcbd947ee9c8a31065caee8f0fb9c35564d7392fa54f69dc2a290db609d79d198311e9fc596211c74a29aa589e38042d7fddb673835e0064d5c3032d59431fc5cda5dea31a9358738e0a2878edda388a0ecf1ac8db26476518c698cda3f8c1399de470781deb6f88b6c159cfeb751b568d851a6ed411dfafa277a4647453fb7f722c1a134f69a7701cf7006b63645e7205fcef6933f57c1114c8e2342c2c8ffe6dc12ef262ba5e3fa253e0e7e787cc289ecd689d7f0d2479266dead2e4874cb09b34860a8bd6ae498db2317daf63ffb4695335c39721f10cd1a599f745eb71cc770ea30f4097ed505b2a566653cb5c02f28029492150df32edc83c3c9aa91ae52d28c5ea6ba2c16f664b096c46a365c6ebcf2e2095328c50b5f43f04a70c70a48d5bdc2524b8f1e355a504e32552dae7ec9e923daa60def45f5b719233763ec5d2ae8fc47f90e9cc92f628e8c81d7b1f465b3cca5316f53f1b00e9056939ce186834752c00852fbc2c6b7ca2910df95e80f7a748734e297594d9d93e9b16cfae05ac367b41000b91824c5e97bc3eb26221df647b14263552e2f5af03f0e6a63e205451489d8bd89a83634b71a8605a9463b35f6d1d485caaa1bd84b72d183644edb9f068236b70c9126c5c1d30b7b96c9db11fb148a47c9649c93b3507651a3bf56b44734dd631deae97543fe1f09168cfa4ac7a9ab284cbf276cc4fa915f463dc9ade8e0398a5f561ed7c67f65d515076ab3523154ddf848dae9c2dfd62d6619823ea7d7421581e7c2f474929d0a481b139f6502117dc6f560c4fca8443c2745cee5e2e810c0e76d7a26b8164c4d177c0b37ec4169cb80eabb6497368f7313c5dfb7a2aae1a7ba1c8488110399360ea11e0d54c740c676d39f4f4eaefa109cdf4e1e83f0f3f1d4a80d54d9daeadfbe23d1ea68b31440efc27af9d4bfe13633b41f7df868dda3ee650619dcfa057d16cd56f4ce2090953c4ea6f4eaa510569d6b1973a8eebd6dd9b3f0711753b1af1b4e4566f94afddd1abf08056226f7c5c2bcf7cef5c7c99a6d3003020ff46d158b9ef89747a336271615e531770be42cf3f815b88942932dc23611d91ef25538471cd663ef305662faaf4144b15870bd4ba0b59a7b8f0e27c6769ea6534769fbc35a48533cbdfbb2b6952ffeffa63e12cab610664af8b85412fb70d74ddf5e8fddcffb575155782d41775eff744c1297845cd8f2ddbf4f522be51e14873222426b20a42261180d9f989fff8fd676c82953ef72f912c65602ef32be2155a4520c8d1c49d95764a84935771e301ec496a58071d14006817c56d91cc8d42af14380fbb0902c8edc6be612401466c1643dda8ce717b06f58896187e39c1fcb15ef01c296c641816e4432902c1ae74ecd5dfc8a31fe900555820c84f501dfb3327354041b90cedfa3503e3fa3839aacf01e4722106ce87b5f548f58f7f58f575e241fbac203a7ba50b76a07d7dcee46f65ee884b262bdea3e21fa42323c0cb220a3768393edfdb2665b7e983a7551e741705a1af53ef886dbda68668cc4dedafa2740837aeb19195fdb64d550518d2d58ba5b882ff9f150617b108f1a1fd2620fa0febaaefcf2486a826f891ca5661860068b1701fdb5a4cfc47a5475964f5138b2635a7b045c1b787583ed2117e3879caf39aeb69028ce6a8a8464b03d1be1f8c5d92b6fb9713c499813a15475e79c2bbdfddb86ac5ef0b4a23b63889e5a0786b3041e1094a4a871abbecd5d3cff87dace10f7169b761d7473b307b1d7f43a3310d2ef541e4d2743777ab2cb13407ca62c08363397ca4b3ebdbdc76c5be49651662514c96da8a96f5a23159321d4619d5189ad86b144854b18b2d4c5d25de038a3bcfda23ca31ff5c8c09dc597b40f39a579ffd4a696901d1f5234d20bbfb8ecc1192933fb3e2eea59948a884cc0469a9de69cf2dd0c5d8ca1d95b36a62ecf0aa7c31c2487db5504ba129e169166b2169fab9cfec30f55c8c7c28b44cbad480c3b93bb51357ad249acf8caaa0cc730ec164819ebfa72aa9a2b48b0ae4e316e3056237b6797b1844a4668ad75af3ea1eaef9aa4dbf6edb94a8b034946e7f16f8e4defa4b2ac1aadeeff5fe1e22ff72f285e20ddb31e03c33f2a72531662f0fd07668e72caaff1db8c5912ffce8eb2c53f7bf4d3867969a5309decbff65bb94ce6ee9e19e6b9e2644dbeac98279cb7ae83e7def7b977ea6f6fcf7dfee20de012c15f8d2d7354e6ed3ced88e61f5b95ecce84bb467e5afe944ba4521e3e21b6be06f43c8bd3b0439136dd5aa78cb87faa229b6dc0446424491849a88c92b48e8d7eb99c39e6d3dfb833bdc0a51b1304c4d2fb2bd1c42c1ab0244d9b95585f449785f1d34ff955e23341380659df2d94893dd28ea997d8706345a7c13ff2bf1862a4b6e14eb157e5d20cd37e393834ec159f35cf29e8b469dad60489158fe78cc349ac282e8ecae6925c422317ff7ed69cb7b3b4eb5d53387a52f67f8759f9c5aa73b7138b0cfca084cab0ce14a9480221aa4638929fa28a47574cb999d602fa0c689ebe40a9828113c560b133e448a65914394c19cd4dce935cc15eb6fdb506c0787e2b54837a6ca48bf519d5b27be1c577e8bf734eded79cb10fc3f4128baa197120086a415a4da48570be2a9a7422cbf9c9fa4541be30e397c793d1406447fdb4c0bc13458b833d253869592a732be56a5291df47d72490401929d937ccb2fd154682b867f9949cc18967c3f19c03f0447f0aa823ac7c7fcf88b5ffe83437b2f1d7b067a03de065891fa719187c56849cbad5d189a8b8c3c39e4a2a00332c55d7bece53c9848c8983f0390bdca7f7b9e99282a7cbdc3bd445884f76fe39d4b807e9ee6c6b24e38808481371eea9e4f7572f5f965ed49901d48861517cc899a46a4d5398d90c2b66eeb571e1ea6c1bebbbff40e5f7a5dede0b9b50cccdfeaead999c9b1efde783ec5442573ce32cfdfaa926cb470f0cb90927e219bc2b76dad8203d73ef85d37768b9a4bba23f6284484ab64c4f186917f91d8b9f07c81cf64dc669bbe8e4288fb752a2d95d91bfef1ac0e373ff930ad93e100fc2e3c504c74daa1b51a546aef236e3258ec2bff6cc81bd874b230e10e003323a9f4f231e5343418d457685b086fc4b8373becf3413cb702932d036fd9a183b541377f47604aee3acfe8b4a8c4eab1c599dc6fb90e484afb5be938b088eb90f2db4f9eaa70dda5e54ea1e0d4d09600357838ae549bcb4a8db6dfa58dbd234fd6618f0c149de497eb351935eee1279a81c7d5c495940646ccc7272033df68365676ce0d1dc40767b12e375a38f849bcd8ebfec13257062b3cfbb3900a1e622ddcc20ce468a1f27928a8c7141b14614dee3f8b6c79339086e7f408e482eb00d7583309506ec56be62de947b570e5967d1da5ffad6940618f92e14d6653e1c3b5803a8ef86d7e882f5a5234c2ddab04a4700bd4865eb8fe50652e29a07bfced8f210eaaa517ac4b2817523d4e121dfc75f517eeaea54130aabd1f0457926fcdf1e5d8009503f052a471cd2cece3e10e249d5846935dc278889f6586a0d749181084f47663a33d73e37f3c292a95d4772e59c6d5255a2a812e276aab1b4528cca7295c73b7bd624bc5007c77fbca98f0fdd96a80ca3015296e17fc78188a8ecccf312bd35a96c8897ab17416602c418290d3a351242327c5af9696e73b60780ffdb3d086b5abcd60191c134344bc3543fac4b548e6f4614a72e68a7539da73038ed5adcbea81fe171a017fe78e2bba58409185875b72b14f8f4b0a828ad88fcda08819cfd52ea27213b833f53a68c454e7f9688977ff5ae586c083356ad88c7aecf8441da1e17fd001b2948aa73a81a0dfae457eac3f5cf5174c145261a3bf9ac14cd9708e2954288d15e2053241cfebeb1b22bd0ecbf1a158b95c8e518ec2da410ee55720b9219f2b90fdf3b1e27c450ca924af0b5d96a2a0524dd11edcf15ed82bae69dcaaaff406a34d96a873a41f4fb1b565370475bfdfa9325483621da7c1b7bb52516cd8049e01e85d210201d98f78eeec75d7df07aa4761a4cba1de4f129dfbd17adc56cd476a38240256c4a1e53a23b1faa5848ac77693bd248efc775bb85d3048f6c010ac36dd29eb4a52f84d3d5a1c86057bb672ad7667ac409bcd5428e51541423cf7ca711e005b41405c44f97fc49b37d885bd5fa44b5090f6e441d87a8e97d76d1e1603f10808e8e45e18244b588c06bfd91e0f51e704d7ad7fdd9ab4948edc1bc6aa1723395a0e8692d9f15f7378a76b42cbf08f557bf392177b06511f3e9851837e6a662e388cb1ecec2acd3f8a921af97217c8695c86c83b082792f288779b2588d35f84b5d35ee61ea76fc9e1377ba9cf2312de7e83924f68c540691c7f1ae11fd82791aad73ef37e995e1a16de8e71a2f751af9e1fd3ff689c45f58039a9013e360dc9bdeca6ae2bf4796312e99e68357df7e7b82b29f2d524a4e510bf16f251f2d74f78910f18017def6d3dcc84bc3e730f702074d72dc40e978dc2020fc2ec97f6f6bf02a267b0236ae766c0e87f05b1e4ee4d5fc16646ff3d51119715a2a58f18910a6c0dddfd150616fd0c2d37ec2f3e4a6c195f09ef59e5e351505779677277d8278b111739a3df6836a51dc233823110a49fd082a08e7806c19dae5e72b1c6a23911e945baf7917887694b41cdb9233a7a9cd3684d3457c5e39b0298aec98baaeeadda2871717b2324c13bf53c4fd3c294b6b680c87e35563e327d44052b4a0b8e04c16f61c73be73d3b6cb2cd311c45f1f5f50302fec4008227ffd0069935de201f74fba8869edc60594461f271047717de05edfc45953c4ea0b5c50467343ca4653ee1f4c1bf63aaeeffd548bb45398daabf508fe025c22e065ca8289214ac9307930fb005733962f388e258d2b78a1612a47a4409ae29b5248e134d326ebaedda0e39b08a0e7111a572b6116010e0e740f551f893f19d6cb5e502a76af4856d2b9e0e488658d854a968712073274b432b89ba1c91739084a13ae4a065aa52349bed3d9de53d77233058bf9d04462972cad79e4f224e22c9e1f041d6d74d8d58c060720002a4da9adca61ccee0735e08731e1bc0d36ca36b2905aa380de60d461a68e67708ac507862c4c9b653312cb60ae6661ea0a90e8fb5484b23cd4b760d585ef7a33909bd588c2ab5922475453936239972b26709f206e7eb735fea17d6c7ab2e3382611de3c812b6e04b7f91885d03f874e84b0a9fb24a25179b1a10e61286306c10c2bba97d62790f8f41ba94ed1aaa015ea136dcc4fc7b658047d198c40e205ea7a35970521d8d4d2aa991727a759bd2ce04ea07fc43dcd48318081bfc39946ce1afc9afeaf4ad952cfc1d5ca5292fd7b4161078a11ad3c8e7d9a3b0f187ed831050be8be4f565ceb6964375f74528c24a2f622b3d5201c37654ee87fbc7bbc73a5cc1d28c5363005976d2f740cbd4a6d38eafeb8b6282619683d23ceda7e8858eeecd12ca0c967eadb2f96efa946e89b8ae54fc04c288307eda6703027dcfc59503566a3953c4dfdf7d5b9005b8c5bad44c07a144a212af7c207699e6ac9001f618edcf8316fb5d2307a23f243905141c59b38fbda5eeb928445405620e9ec16ba62149f1eefa76ea1a1d66a2d0cfd031f6f903071e507c21963107bc2ddfffcb5ceb022d608ca830bdb8fcf902043162b308f2f08aea7e3e194549ec3c58276387d0bb29866eed76e1dd15265c0c64d1353d31ac7c2398cebbd5d8ca3548903e1a3aa6f02a35c3fb5d87fb62f953ea0e09c0eb1c3bf14aaf898a581892a098cf4e5bfc9fa003b35a5a29ee4271c54a5bb146f2995b732e1461c63e7354b9a5bd1a42ca1cd82e5be019f2f22cbda820ee249172a2defb3f199114f7f949f4c251c5c406170a8af6049a722fdb46e0914333a2b3a2b4cfdf4f3bb99e1fb9460f47aab37c2f82f7420075c2c139f98eae1059e5826c51338b797c67fcf7dd84c769493d3496e8956054500d7c82057c055c4b11b2f74ea26dd4b8d2095bc095035244a9c6b20247d3c31fec6347cfc4944cb31ee344209e3e3ebf0e528ac938da531e9278aa98c40e7917571571f4dbec5b1324bfa6a72e7b474dd7a740feff0578884b837ab7f39f1abd717e65f69e4c9affb6eb09a251455cc7aba860697ad6ac5a445dc65b43948d2344e83d74bfb1fb6caafbd26364b8050e7b9bc090d357c7c924d808e995666f809566566b9555562cd4b8dc7f0f2d3860e1161f3c5ccac9820f85e21f08e95f443d1e3ecfb4fbfb36c9e193275d52091ffa4cd3926b7e0f4675eeea7210faf0ff2977263afa3e887b948af6138be818f9629e8221b34991d423a6bc2a53214075b144d90b1af830956c72601755cb4badf79fbae96cdde4db13ebe94095cd39bfc952d6ec73c3a9e27e34a38765ae9404acd9d62e297005a63dc9f2fb6e326a142d2791ce352d725e1de4c7b270df0744dc0e436d2d67878636c10bcd2e98a991557dd754504fb3319058122eea47fcc1ea687e5590a48f42693ab1d715e41ab02a3b9bb719007336dc00c2a3c8c0d6f22c5495637dd4c6fc3333cb843fc8c6e3b97359deafcdc9b4e97d68c87cfa1f215bdb26b7195c04f9727c0bdc36ee4cd5226f237e4fb99a300b684ac9d94dcb1cbfcbf71eab6dd6496af09ba3b8dd5a1b2d9849f9289b2b1f9bb4c2af599324c7719d3cfd413bd4d898c8d6c3bd34d8462d93111b13815bb130cadb3a565b787191a42bcc1e170499c3f473419dccd4e642efdc684ee2e517f5edf0643839b18edafeea6ecb0c49d11a652a6c20cd2ff68315277013e78f589fc6cd1458834bc07cd3162bf3c18c8b21b38e45b6381f636166f030a0df2932b14479a2015181687c1f2a53c7a377f412ffdd9fa085ff1b7c9be3b0e94c1206449fb4e8dfc47a477b8228e50a012d4e2f99ab35c1e00ffc29f03c9af550e63f9afaed12ceef8ca3c97ef7d66d4ff5c2c845d59210dab9cbbd3a9eb15628d3a20a881f41e5b31bc331451b4e54e46f20ed773bbe10f3b9efc2fe1e5e5bf65b36c367581af306c80405a3898ba9cd82e143a6de6e9bbaab963174164a5303e781dcc528434446e7bb379c726ebcadc79a1873ddc5a59cb9b5af5ae9df42e977c9d24c305f6b4c85cc80f2e253893580a66f9b99dc8285e2ca8a5943a8947ddcef018f8aa88a16c7adace2cd8981563228be46889635b0b1094bbf0a08ae2df490dc02717a0bdfa529ccf147ee1ba5c6d89c38a94b0ac460b0748be5e06755c1a3df67659607591b1d5c0dfbfe71554de2144dcd72e9dab57078c4febca48b54bc282304b8b43ff45accfda8b3c132e9903f994eba6c5f80e8b947b5f98e7954f737662c8e72282c8374bc21b595d21d6a686e6086343a6998acb8da2afa872c0bace203b150634cca8ecd0316362dc53deabe9cc4f71ae702447f3505f8c02044fc380942009722ee056008a2f26ecf88eb94e6f968fc153b872cb44ff5a95b6983e287e20c1e9fe19b3057383dd358f996d6ebc60484270baeef2b31ca1946c2b007df1bee37f19404be381c4fca2d74d9b87ecd1db7e9c72f537421bdf7b68101abc69ee14b763e15951a304d1b7a065efb5fd367e2a778e2b4e1a04eb95ea804d912f95434cf0efc711521f446573fb32724bca37b453176dac398c0269990607a9e51fd2f9066759b22d6418bcc899f9a705dbfc00be1e9bf87e7d07ca2a6abd4709d52d7765f503f960a227f6af6dfb82c28733b5b4156154d34a0f441830a4225a311227f7b351e837208be77d0fcf2621aaf6992f59be820a19264b67d935d90bd2a21d5999b53738852e3dcee7f13d38ca35c6243d5fca992322e59fb04fecdc3910439e6e7bdada15faa1f3a0f8498474a7372978e6cbd499846ae6d0442a91e8bc62c8af9807d2d8dd7bf097c4a3f683d3285c150e6d59c6734f43ecb8c708453982f0d5a943f57939d4bbedd608d7f7c1cafd89064bfeb1c1f0c27a07d12a1dd1fa9d89f84f8db9191bb9325c2fc0755e2946ae021aed629bb3c9d080304dc4983a6c38b8ebf4a0263268c93531692760d5c85e71c9c4630c4b48653d865898f9e2be58cea9538f8ec79649daf261c8ea890007bd5f7cfe46db707730f5d7991e3155bfd7d3f1ab1add7a1aba1017756d01db8d861783b7f4cb4a5e4736c1741d3d65a41614029e4465ca20313e0ab1639e502d6e8ad0bfc6e87977dc6d5afafe4c9463a7849185a564ce933844c8e963b1aaa9eef16ff69d8a954d2a33e72345ce2931d470b12ba480a4de11d68e68a70228e2d5f181b70171b9f8d240b2db20d78fff987fa539bb59f15f81308322f122717cc120c1f2579f198ea82a9ccc5d7d18d447b896737f9936e7b0e83a9a7ae5d21bf80c6951cc72535a9dfe0dc735f58395d7896cf24804d883d8e322a1bf8234ca1b33b40ef16a4f1937f99d8eb909394353fab6ee22acfb8110cceb8ae8ef307c2a25250c905d29557f8b9f1ff7c39e5b2a769230a9f6420baf9952a4c67d51c2be6e483328dc61ab5b5a2f3f46f503a66843648a9ff996115222a56d9de616a069ad8297f6d3360521c4aa4867023219a2edee6eaa2b5b470819917073a0c830c2628e8be95f4ee150a27ffef136a93427813deeb653d0e486f0cf0061ab2ff15c7dfde83f78489a30d8a38d7e8d9257a03a442845760a2af10530350d305cf911d92191774983bcad91307b734c9591e9e14727c1bac0f9cb9fdd86cf054c74cf48cd2bfd0937e19a8c2dbdf0d604d98c1ba681693f0f8be8e08bdff111fcdc500dcb9373df5c61a8e17e9e0c45bef28b8cb8ae06f614d6e9648a721302fa3c6e413558fb39a174625aedbe3221b9ae09d025c704518ae70d4a7a12701916c7142eca91c852b1f53bf7132c847958c0675396824a8cd97446e6fcbaa77db6a12de9942fb59c78ab2cfef2dcca158d0553fe7a09130b980cd4e1cb5e1d9838c160da9de859df3a454a7f1d855f3fe211b55551076383594bef9ad6b017f2ffa94b523ae978568143fa8c234299218bc72c3dafd7484c11b295ded8e33d9525e28205a96de46549e022c489a5ca28935f06f973cebace8ec10359223e951811a67dff2328596c20665f6275ae343180d4f4de02eaa4cbcf2c1effbdc3f23c81f86ea5b8e20909ee88b8cac471471b23064488f937dc95829b4a5d73215086a610ae28920a0c291f5bf76b80d3ce5c2e37b371ca4f9d9c8254ca5df42ed3f7ba269eb6483e0f6a9bc80494bf60f7917dcd3dbef128f65968658d3aa42b3b739bb4a8cea69a29297edbaa8fc6b20da5e405b09f81569fa442a2f9d957b74e1220ab2c2d0d66f8f4e8f1ea43ca6f4ce43dc6a602aed9d204f6a416a75c8794ece67eb0a52c377f6b7c954fa251eca8667852f2ac1201a9a631671b6131f5a3e73c68dfbeeaa84c2b9649fcba00c6ca1a0a473b9fa9ce6f2ed609991096c9d4c2a53f1ec48df9ec992aa60f6fc16f88e53ec33a8a75b40214f509a190f09e7023f28f375d6bad28cb89e0b197a7adaf944606cfe4dd7db1ba9720aa5acef89c7a2102f39e44e0c373202ca2a879b51ab254d6ccb203fd6ce33447f2c520a8305a908c582638075d2b728998ed71574b9f939bac153b9496d263a3a191c607cbdf07ec47d5333a84387b4059f420a75c6498f0beba26df48718765c7862c33aa2cf3e055a8d1c0eaae2d8b0e03fdcd86696f50943616eb6460d2259a0ff28adce45a981b2a24b81b22bd85d1bcc26153e33dc61fd073d7f814e237862809bede29631df2c76ab1414ca6b98176bf9cf997112c0a8edc611bc1798ddc00e8f9bf109016cc88b45579f79e026486ffff3cb9cdbdb0e9328164527d7bf7fa5394d8c3619643602c744d4a89538b960a671d5c3ebc220b881fe0285767cd4eebcf434ebc4ce7917c5ae4b3e3d718cc2dcd4f90906a1b53973a20f707cfc24980d1ce5f667229655bd0299008a6e61883b4443175a6da6f1eed60a7e29d0ccb634fcd7fe64328ce98466a0d6e70736ba1e905c48356a2aa5c9da0d6c23106a38470334a499824f0a1f449e7ee4505c08fb95550b3aaca8653f28f1130e0d26bfd6502f75c49ed2e162dc208e08391b21a3cd78f76ee62aa301920c376d909b2a17adfdba35dacf1c6307ea64d84d46ae38b49ce9ba4c1986170d91e1bc232560692cd30f2e5aca0c1cae07bbf54a0f92b2e2e988cfd8093d5052fdd825bcc17a003835c84662257a7604d13b5fa5700fb7a449ac21e078637a82fb590f0ea33c5fa80935308d0bf7897a8b5fdd96643aa29c28f70a447d84cae40fefa5b5e305756e879f39163cd9af55c70853346096a423c36c6183dd17a13b0c1dbfdaa30ef79e9d81b4d47993b2342da094b799a985b433a37d5176f31dc24139aaa9fa4c81880376dd5f359843facebce5343372827e4540c9eb25ff33402f22fad6096806b62f745881a35328545043365a34eabe5aa08443f3152676bb042d5415ae92a7e705eab426987053b6a041ecadd15c587e8acd9616c0b5cf39038b0c0dfa96fa9ef0f5d1f7a65fd54492176836591d5411ec5e1f64caa2b67659342c2a4ae94f9df568419bc167837ed228b565d78ba87084319c49b11998442d115efb7a553a3437316d806db087cda928dafb70c70c2ed5371e51d2c908ce30ddd8ec55973b8ac8003d960e2b7528352011597be0a1aece3ee5dd9dbe0913dae0d0fb40e70cf521c78a1643a49fe521dd331bcf5f55b8bce64540105969cd9ea54502570466398ef043d4a97587f53a71b0aa0f22a43588a3e71bd5e404c2d12be1085116d028a650362d548feff6e820da4e203ebde4a1234e17e11abc5d3d6e3edb01de486d4cd080da1dd40ca4b9409e427bd970c187b3e71d3e6283cfab4986dde731c16d0400db6e046029af194f4873a54728b486ade56c5fe22f455b8de6fd975d8c8fc1b8a3e685d320d3a057c698384e160888a54e440a9a399a02f8447844b7f0ae81eca28c34ed9f4fdff5bbe00a9323aaf84c5a6419892ecc7532a2b8716c44419814e14bb08ff358e103c697c228dca226975b0cbbe50017ba3fc260a49e8b269eecfa01644589dc3b9399c7e4421333057deef05a7cfc06f8c36e9b5c301efcf5bf904357a410c9e957b09ea5a4d15dd647e9aeab88a29180b64e355c18450479e8adf0dfbf03b02f1feac9f6a74577654445b3a8770cd0790e02c7357cd988bbe4054ba316ace8babe5457dd3046e2521845570f7406e3c823d246cb2b30222fcee2c9cdd8e035c874c317804e5b07dda9e313650b0c49a65337155c0efefd0d4ab4de26e55bb32d2d2d405f4bcccac598b627bb6bd14ad33422da1998bc1ec879d408c9a09432705474aa35f59ddf6cc92d2a924ddb30e8a9451ead2fe311af5cd1f61e002cae47196bc7068647e58d7e4ba88495eedf924a624456603d7da88fd39ba16b22f7d46c673aebe07e0c6b71722bfd56e673b10c79f142111b35d6a38dd9e6db717df4a8b7837f876367214c0387b64b2034567f4709940baf92cc2c17c1fff7ebf250f4ed85c9678129bfe2332ce1e18ea1b9dd89b9727195e701298141a0a6af9e84d56d4e19ef33365cea14b819aa63381ada3e6f9540863b7c257e6f0990aade06e3edcdbf49903e86ed01d64e62b1d21ec5ce3964b69761ecc452f0cf44070e246912cda556bf3e0a56fae02f8a810baf77d65c461f48e7f9cf4bfc97465fe599fbe8a9fe7778f5b62b15c0f49f3881fd8e152a122d78c4ec26fc914bfd9332c1b5e0cf6417d4abbbd5f7da9c87bb42e73bbc4f34346a47a0f1f145b365a67a7af22d5a3fd07c76e1b67763a63713dc66fb83fbe1c264bb972a9eab8a53998b5e365b8fd58e5835a5fd90855ccc17e1289aba4a6700dcb30f598c05f5fb780beb1ae8161ab576a6406a3d04ed85b4fb3f01e1509f14adf39e975fb222dde84bce086a72e5ea07054c0424b5fc51d7aebb0cacc75ab30ab566e3a6dae08ccffcb107b066ce7ac154ba0346354b953835096ad2ecf5c937ddc5df3c7e7b0e401ef8750ea866d49911f495249045c0e7b00108d24c96b090c2c73268301e420c7f50adeeb437f3a8bf0d9a09cbed59ef13c4e9183a99b06ac42daa09bb8bd8ffaa9b3a0599062f4fe745ab360f5ea1cce07d8a92db977e2b4e2e9858d12d85ab2d8d9f6e268fd7e710a31957596178b1ebc51fa764f55a771112a89f11d9f5749302d998cdff3f36922272ed0c67e74206cd8b52a79c1a92b12f8d6a25af2fb57891b934dad048e2391c0d4cdf1eda7d7910e8918821a3cd32b2bb105ca01d614245d6f7b0b65cfc2299b6a0b91987b75246c9796bd53377e60df395123bcee0643b6ec6048a278a517ec2588f8a4fb455b2dfd5703f74ebd516975a9f8c4b28f9f3b49393182f107d6c04bd5a07cc9c10f23e313277a510ca067a926730dddaec03168932737da6ede457eb39eb56e6a34587bd293a22d1b202c0425672a8f8771e7254dc33d0bd259743f399b1c4027068d96f45a458d1fd92050ba0126fe3ea1918958fdc06be38630f98cb84366bca09162739bb84c0a3b95bfae9eef9b2fc4c9c41dfeb88a39bc096296f0455b0309f6dc780a4aa8216c4301c11a64851e0a5ac28a7b0b1cbdd183003ddbae549b6ec6cde40796e26486a1bfe2c2e8e3ca6e2a19cf309b67d433249401c0ace0d6c6ff20998289cfbebdbd722b88e1f3644aa97e809fd968a506cebda8644261dbc4e62687282aaf40c87c708d88bf0dc00a92e175563d1d2a534f9025bdb1bff9c1a509d0bd2447096cbaa6bae8de17fa5e827c845dfb83daed4b6cb69e9c15f522b14553fa5c3731145a943d7ad2b856f09265170ac88a8706af09161aca2f0c58b6a92dc2991c05803709bfd4a8575ca324d5de4fe0e286c93f66408d59f9b6e3972ef77e8cfd447c623b48c100943423c619de239820b5cf1612102cd8b7e452e9e96f2be21c22f21e8b2b069b73cf16e22f83171295d00a438c74a020a2665052c9a2ac08af9308cbcabce79d30111997f04024cfc541be0e165db020b44b129675f4358db4aaf73d972441b3feb8e5655039fd7eaab15f5cbc96572c7c2031174e64fa12fe0c9c3a66d226ee5f64dac5c00f331fdb4c25cb3ae164cbcfa72ea3c4a05dcdfa12613a96fcaff45829e391ceb239d52f8ceced5e923daa9ff529d97acc620a4cf24761b42d2a6fd91af0e75362070063093c5a484c6bb78ca267c70a2a44fb93ba74ef54d6f5691d9fc7e3bb6dacd67a4ec0e4e066886e5393cad5ffa5fd72cc6038a13ac2a902e06f0d10c417096330f3a4758daff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
