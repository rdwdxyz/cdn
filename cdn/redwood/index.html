<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b89882f8d8bce89783d4403ac3652080286f8f5c315f3917260096fb43140b698ff6d81c5fcaeec463cd92960cf96a3567446eeb892a86d78039f559104c689098dcb7ce037a2a65edc7da4118e69c9dd448cbbdb4690a0e3eb5b4c85252c9ebc215f15e323581aa3082249bdca4fa90a16aae98786daff2626906107cb274744b42077254a51b7f1bd2147a2adc78114a167643310304a2de8a043cdcb3b2fca14883999377521fa2684e95f353935b3a85698f278b476c44709ef5f365c266a40958ccef9742561e3671d9a63fc5bac02e5a2f1295058f7943b9454f3152da9402e3fa6c34508e161b8c97c096a2d4001451ceb41191c411326e27c043fabe2048b7f1e20d1fdd57050248d1c35322e7893f57fa0e42559b3b4aa3f189cb423e969b8f93bc86a8c2536ccfad5ec8b72a3dd953594ea20034564ceecaf213cc3313f1db608c681a233cbd08f89b6864869c8fac7cb6e295ab8b5109652b7c90700d5756660296d45461480562e393319a85f6ffaa6d35f38d3afc80699bd6e95c8470aa0371ae04f305b7c840e76e4ce678d3faf58099524fbdce75e490ae7ce3f6c6b848fe29ea92d990f62b9172f694704a6acd9cd567d5dc70828e26aa33f504668d1b16a2db8cc3a018a59bcdf1dc664a429909f52231ba6c0fd6315710d3522f0a23ef4fb4896a5a379eb7a71c63468ae91dcb2473b242c2722db0253e9898abc54ff254ea39607d25886a67e43b2d93264f02d33f6cf2c026caafec52c02b2efd62641cdc65c69b9e16ec4788de338c46113f7e11052654689b3dbbe3b93321d21af056904f22181e54456d92e9e7a7f7a81bd9cc58a0d18ea79c7ed2fc51326469652d9f1da1ca727b3542e92310d6cf1c95bc4e41c08491b3fe215c8364e07838aa86f5711af118f85d112e1b7061fb7e8bb13cd40de6ad092e74fd1254ce7f11792f65fde46e793e0a6a2720558f0191bbc81f6599133cf187d77d49f63384c60728a983fa4f7f2dd5c85a5e7486024d25c7341615ba1f8465a711334d3b9583261784b7ac1481f7af98b3ae28a9a9837effad6d70a378a7e03dbd39cf41a7bbb03fc1e92ff4487ae1eb912a652114d80ef95bec4930c81f174846f1871792a7954e25a9ed36b37ec24394d92740a14d829bf8b5f71fcdb512d96e7a5ac8d4e66de37b41ce119897c7879d7679d0c358fdacb20ec0a09f0f63ccf726c1a5c797f6d7f67e394f39461102e8e9cc0e61939e2e1974dc623be40faf6f3134514426f4b56201f27cb3998c0d8127841ab1a6eb47f51c03c808c560ad6148dbc3a630ccbed4d2774d420944e8bc99ae8e0ef846ea4f9254a29ff1dd3240a3b62aa4c86c6b4dbe08f7f53af176235106f56ada4f4b25ca52512c49156eb874c3108925b3f4d918ad37d7435d8eab3abcc57543ed31cbd98eccba8c038b12da77cbc340f8db8c20ac624f95d865de8334a9d4ebf320d876a4e8e7dc5ec705431a8a55afa32a15f13b87454759f26c71bf7fa90ce825a0609424fda2cdb357c84ce66b2c83c6bbaffec7c99d5fc96c2e2b89a3e509da8d6bdfaf96499335408fdf5e896f3dd08a1b6f115869de4b4105e8257234f3e524944626ca00da20d47c0d08bf4f8257311f4deb1415985e14fe267f12af9e9a94d412ba191e6e4aa74110ecdf7235cbce3242a04b4e4a3d806642d0bc3c2bbaac483214d6a7e959ec16bacaf301fa2ef657f49fe5e830bddfc95a8d22301df890cbb6b414633d0933b272d3becbec83f4549fdaf531f064c6819a91cc7e14d73a8e3208d769c3a7e9c374bfbddcb634faf07efb098e434f6abc8c8b04571af8f5d379dfb5d8839bb35a02cd16d2d52230012caecbef12c3e927c4d0532f0445e95eeb3918225e6eab069fe9eba9a7c6a7b1916194621f5c2b6499f1b6d2bb7c1f608f69cded69e90d93709306209ac644b6d92f4fe0ccbd0e2de2c970e4f9cfdd9ed9ba085ae36ade26e1ca9b5f7f208b31c47dc343987a17b3824ce60ea574cd86d95b5b37aa8f4bef21b941133e6cff26af2b0497348c7c9c8c59f6d7e20a49128a4409bc5161ab02e37c40655ecc3e77aa13879b113884ac21d3bf16e3b0265b92eca0c70f40b655c7433aba01cafda0c2584268300dc900c2d2cab490e2fd95b2e36be560316ec836be4df4f4c25faa9b27d812a8c071acb93d77a5d4780a38308c9a69dc292560327e119646f1393d30f0942a56b9562df2639d97a39921ccc20368b42945fcdf325cfca18de8f34d75f41217d045f7f65599706ec1156c50747c30423a1550f546978c1318c0e29fd8b2031bcf7739df6b0a2354306b9bca8752b93aac365bb1e54308bbbe342a15b11a01d843f61f0ebf1da72ff48b014dade274847a139f80e72d2e4eb8da530bf86b154340d8fa5d64007fd767901da21876cb5b550ab2961a08c5518a90b358379b8d7545a5855504ca994029f9455f266f857050dd26ed2228993750665a73b0caf057689663a6da1719107555c889e1d3d49a9392820b7de42ea500813448ce99897fd4bd8f01b9660c4d7320573935e5eb870304bceb4d52ba06849b9fbfb2acd6c5b10acb3c79785f5049f7225c575b2031f1207eb47d48c6158d4969ec5dd8c610eab553dcc342d0b46a3d43e0925007663a1f262c324597bc6d2c2bb6370f1283291c095c1adfe26e856e46e93658c9b279b56524367fe0991c9b2ff0ac283b021dd8c26468c17506363f64ce29b9598b1bff4a5392684a14893451d84cb4810d7ad06a0a3857903b63a32e3c80979a7547b2b1b231dab6e8292f74b71336b4a04986babcfa60143c7c4ad65df680465175a6314da2ded72fdf2ab9f8fe684aa5ddc559b15aeee8d9585e4c3355f94bb409098e91b69c65990204d936b773ca070173718b08a2a6eb1baa2a7ccb7175246bb35a5952ef5d666e67ac72cf94ada8c85233701afe56a963673260b4484e0e046d1a5971640a2d8e83973b9d3a1f6786e3af95a5561e02997e9a904f5d8edda9857b639ba8b1f0feaa6a16f8f58d53d33a066c2d85cc59cf917cb22316b7e6978ef17ee326e0c79fe085e3b85ac46578ed0d682b8b5cfbbea6f9da5140116acd19bd83db178e61eb26805923a8902c724df0595acd5395bc2ee6adff9780f46803a5b3963f011f0ca1ea350678601341701f5064810dacc38db620205f597123b29e77ceac8855bd8f34fb8cac797a74f69548268c2cf8a917d30674d32326b3348a3e099638b66ecd9c6b4efa117a19e2f99b6ef73758c592127ad4c82a21b277ac3afcc8669934ff84ce4bf241414aeb516a092d92cd56066d536f0b34d882af3c237da655a549f161f9b50c193a854c2fdfd67b7c051c333592abf4f6f928974126bd4520d28a665eda837e9ecbae7478228219762a57a4dc5da558feeb48fc48cdf6f0d580a913a3b9fec66bf3bf48dd1961f31f34ae0e2d286d5a647cab188efe8892f5c912338133838bfaf81676574b18491a569d3bf9a1a6f2a58213fd125ed43d0b86fa6aeba65d10f8b045b3df6709042e3bfecdcf2a537650600f0ae25ebb6aa172f8855082776fd80d817a5a28fc06c024be7c7f758a23dfdccfe210553b3882d76e00e7f0c040db7e44d3d7663f0072803bf2633e97a220b21e51f68878f04f28cf60574549411c687965c6cca35e671a2e68a3154cb73dfe4ae7cc9ab76c39b96177b5193eafc5cf8de6d6120287359c3337de4fb017ecaa6bae8e7363b86b3190918f5b1fe429e443a0a7b1f02370fe881f71fded0e87ed9a1552c7784b3ca237c3c89d826467f5a4fd667bdf15184f879e9f5d9aac6f9a7360c5a65bfc99ddbe5d08b8ddabca2421a11f7e5cdd6d61ff0968e4475aa6eb72f6820f8d65bc30573f706f1979398f6cebc6348ca69fb789aab735042bfbc297a8d710c7e9cc08de5cfcfe3d4ad1ef64f46f12a3ef26180d9c34aa6daf6948351838b64ba461f4866f641a7d726dfb7d4e97243352979b4d7ff34b9670958c4fde850d17d282f61e6cfb2406e09470d5f9ddecd6c8dccf3b5a405fe1be6e3e8740c37e7c32a9dc88f6c8b51d30cfcb9eb35069478019cc8c25a6d471f8111bb9c369c49d15d156f39e5875534ac82780bf0686f0f79a7117b669f25f5d62baca374bc016bc15c181bafa062c832030f089cbb2ec28fd79b2adc7b4cabee2a21099164d512ac2096bf3c7f8cb44e6ca8df8ee97d4a1de29710c04e4e6e9971531eb4b03bdf9e79d9fbce751a8b11f6af283d3ad154963a6c4b8a5a8c8b3627eaaf9b06b5399fee9d093f8cc9c153885f61ad7764e3b3a91085c7c6cf6cae7e5b67a5c6a82e9a0ab35220ea1cf39a63ecff24b76e9a1618d50976ecf01760f1d31fffd5946aa0a672a1519ae13591c15db024503d0ec8e84a49448e23f2df30b5ddcb8211c713439f3941d306345e029e7044ac7ba54796d64f5ef776b88267618176a469a97b4cdbcd20bdc1a1402161b15e8bb0678a1dc51ad881b0e02bb23de3b391a83f03f60de114d3000b8e248318fd8079ef4c72773b3a3576dc1ffa29d60c9f4d32d648545f8c70d17782b35af38231537ad853d6b1fceba62ff7f1d9c9f6898e27fca2ada3c80b88a065974fa76a56c8eaa828c48e75ba312039edadd00df54280360c2853a6dae8ebd4b10a34a2d2f46704bccc6bf49d2803ce7cc6da2933719f135ab1a45783132f7f0095cf9aab83425afc56cfef3cb25768a098b2f447edb94312be59b31b9ab3abe843a9979c894f6237ab6bf0c8831e65a5586a9ccbd21b258b5c656614975f557c0d8f9182da312358885e2abdd9179db1cadb2d3356c3f59b5b2376f3ef71a122863486495bac21b054179266c0e4789db861dc3171b3d20d0c5041353d17ec51f8759fe9953feaaeb8a81ffcff400925af822174996cccd538bd0e51cd115637f0e10080f840f9d350b6ded21dcf7133051929c1823fdc28f030526bc90ddd3f09e8741d6fee06c56bc90be33edbda1991a0357d2990a914cc6c0ef32692625b342286a4a45265dd1dc46b75a0e912c08e7039317c5163074f05ee20500ad5464d25efb4bc3a0965d9dd292009e1b6e99872b0cca836944ea7295a62757c2ad2b026693298a7b321c497725a9d7c787b864a112d37b717ae5303521dc2bc0ae2ee4cf8ed62212690d042978bb16963118858b85b39ceee6a2dac21ce280010d6745a29ecb6abb91ae3aa5351cef1991151e125f7c4136b59d4f23c4759de5c935276665cf29b4eed55f3984a5dd7f583427db8cbabf59b31b4e77c390f62dca133745b9e266ad7581cd459274315bc1d066eb494314093e2483a875d194a1769b674b808cbcc947e4f9a64fb45d3f1d1631ac867139b882d00a6fa48844d06b78442eea313698d8804316216bc7473b759d395551f738c5a9ea08e46a161d28bc3a68e74f50d7ad9c8c8967aadab37940decbd6c48177e12ffbf5ce5b561aa6602e103b866ca7db4095c6de6cc3aab57204a737b1171e4cfd6a8ed0b0523bff1362e65fa1cde87fead357ecb49b44e7a9bbc51c116e44c23947b1bb8b287bd6a7672cfca6ea6aebdec8e1073e6b18dad6df1460205d88c742384bf32caffd4c5dffd1a8e2469b6a06a606e1c415a7370db09b086b7f2c0f23a24e37948a213ba8beed291856ec37b2dcbe038f016683d7644d0fbc68d08e79e2a42a69dd3b08b107f236ed10a22c69a1a47aa7fbc23c6729e675962319cb158b780105e3214923184a57dc920877e48dadca105c21595d24a88ab7430019e410303fc06bc4bee316882976fea2d50db0e48ef15c1deb842a5da8d98071c252120669f555c2066ce32cb1c69df39c5805c1c3e7ac9cdccf741462dd20543c0641bf56acdc5cdbcf20392cf2204557c7b97c63e55524b1ae462b0cef4bd786e3d4e5400f4901e6750873207b3ea687cdb712b9855fa96c70e5e2fb833eee79834a45af1cf130b25b52b1b4b275823da85ceec9d9bd3f7b06c4725249509ead2c4e066eb0a7587bf46ceb16d86ffa373078bec2fb7f4d39d9ae096def8325a4627754e590915b80f9b4a5ac65b9273c0d55f41527ed0d3359e1e561fbc9ee5be30c679eb09696ceda8b86321fb94640ba1de2e7915da268da12dd364f3b0aadcffdffc989e31c9d75f36393413b72a826477f14dc81b29419a394d3fffc2ce4d4fcf92b5b5ecceced2715bcf810751dbd70b2077666eb71f89b7c8b55f816e8246c632373a3e24a146db93eef0fab0f4118dd9c261524182a1e8112d6e386df3b7cd645e626f70b98e6ac7352dbe871e219c2ab4426cdabc84942f29e60498dd407dfae7525cce97c4b85666db5119eaea1388f898b89c512dced2f4b4e4ff2400823ec93064a5c1abd30c6da53f43c990ed23689782153ab0bf64e452ca7846a2b1140d756c0b7404f223a2590a122563c770c935cbc2d46ac9775cd0ffb6201b396a9f06eb5938fe7f1d54f18dc87fd3e9205e39f8fc1a74fef5dd7535df12c1be8650501c0c0f788b30f2add99bbb0d4fd93ab0dd8e23dfbad38c1eed78b10a210d7e2e47100f1f6bc8a50e53fbf5b75fb7480c9cc36a50103c56cf4ac220f4349832e337a8c48f9de9e3a48cd88a16b61cb1363a1071241f3e9e67d8df937609dad52b3b62a4b552b975305c21ec5db8a24e959c3393819fd595978d5ec8ce64a540ce07b1eb431b8c9524c1c46b005307bc36814de17af8da4a2e04c3a3ecdf15c501fa8b2733800df5133880753629141e528e0107fd28c7e36e115bc03482e8b6629e1e9e5e71777025a66825e7c311ed4e6d7c11eee7f3d3a6d6a6e467cbb5ac6af16eaccd6c5aa013986b95681d0c240e87d820a847c29d1c866916c34d3aa7baba182b7bf1003ada1ec16a2f94eb056b7a341d5028c779e1d4ed6801aa082be4bfbdcad7ea830f9347e0a8deb5002072c3d69948df9086e8528977650df6f75e5478c5fae6562f21c226780a06362cadf86b4ea1da6a917152c4035d8f9e773bbcb6608774b3af88355e672449e1e3f0e1fa686b708ba82c296d2938444bd06bcf568d0de01a264e88437f518cbd44eef390f9dfdd47b75725d277b42fdc143be9d101d29425fd2e071e4308e88be574d439645886f6c91bd302afaf26110c181534672136fc1d818b66934963df734b33d631ff5e58e4005f83bcb0e292c46fada430807051099d8979c018e46d571edaa984cde12148e5614f5f6d4c4fa5494bace6d8b5098974d8b54f1b202f75f3d9b3598dd5e8ddb965c8823f63a878cad8f39bc434aa0335afa44f93ddc2ab663aefb9f49b482ce45e107228f44c49025c1fcf2080ca015d2132ac562a3b222baa7147878fdff187feac2af7f1a84df8ea8ad10567250fa6db8220b4e788c86153251811b509d12a67a8ad468d6e411f48428983608d702e79a8b44ff0124ce9764ef163f9a293cb0554a330d6bfc0a2a13f80fb8257ae897bf999b91d8863ad0ea373f6d5ce31b3f3d6c52e3cc1768598faa6c97dfadbf9a2f03d268228407caf3461631fc57da7b506b79e9669a346630400dd423c485dfceb6805c0e3e626df49cb230ce3c7cc7b6e4afed0f2e619b44f95fb31ba88599049f7833c572f3d1eabd96a05c8bdf89638553faca087fd219c30e3665946f10182d180cd1bf5f754e7139bc90e9ada785d41ad281c43c55d3a7ae57b7df72164609dcdbad4f6d182170e1be34dee5aea6151ee765cf8e9b5ce49a55dc88e42abd8e2e5cdf98015087a4a130a5bc75222b25368db376fb2c8c6c88d92ec9a4be3109a75645f07cb4b83d885d6e68c9c0d93a7a7fdeafb15c5aa85102344c74e0609a5dc4dd8428f03edbdde6b33c3b07dcddd8d33f5c9a5a4fbfe124226f4b113b9d34c6d33ce569cbc729a126f4c6dd298ebf19bbfe9e4a920da6ee68cad88d112aada7888bc93c570e272be7622380409709f39d81752117f72d3c739e9a91c2dbe1f50a8fe80bfa339de968ff41fc70787bbd6d1062b24416a53aec3e55c6ce0d6cb1497a041c28fef040b097bbd847d4cbcb40c5701434ba6c7808cc133d701203779f57e45e5bd57a78245df60a2d073e32eadba0da63ab648fd54c8ccfc728827c7ca34146b5a22e3c1a96adedfa7f591a7abe6b459376e3d054c4bb5913f24494d03c3ac2ba759c9729932df94cb6a9c114af548500ce936904183648a98b72f3afd72a0699e00293af081d76062c7ea4ac9243fb35c34df8ec7d8ff2730be7eeb530c757583c2a52d3c2e558029404e5151efdc4bf061723ceed85388cbd3e85087d7c167b83b795dca956cff5d7d8684263fc6677866020b9dce3efa1dd57f2fc18d7fab41cae658821e9c92b3a043bf20f4a71f0cef245b20f4676dd0e07f71ff17db12cd6276f3d819f2bfca4090792ff14c9be59ed3892f3777a2aff503a4de3611b21995d87fdb5443bfe5ff1adea5c05823ad56d6ea8088489954bfe0cfde6bf106e10689d16c1bd760a3b9b4f088cd66277894813eb493b9c57a05916a3889da149bf6cb5b62e4d15441f5243e8e9f27fcdad6fb1bffc0ffcc7a6b80aea20038382645af386d3e91e2bf8f0638ae2c517ea8db80c9b6e813604e0be9bad46dce29b9b5911a7387452bae5d41ac9f6ceb07681c377bed378f696ae6e412734c6cf48167aa1584cfa4a438d6fbe42e8bd6af3a58f59da9ffcc33ba96410ff5a191eb08116dc65467e7b47f58b160376f3fe98e0f8d19dd58a29d5409c5eed613e980d7948186b9e09726283d8adc0021a5f593e1aa9a2d608ed48fd96ef48e1aa4e78c6ffcf23a1781bc076b6dcc1c46c7b0626ae7995541290767bbff4212f58b3d6f2706978d4a384cd968a5e8a4741bd4c232f0dcadf21175458990e187d0c74f4aeeb8b8a7a58e0dfebf681b1c40a344446eadcf2fa8eda30e19fc4f095ecbc59cdffbf7dc9b6d1d3fa731a9f4b98b84a6fd4b394971fd87b357afc4efdf14ab08efae580cd11bc77f445a3143c5aea4ddf8853fc8bded8e7d6126134e6aeb60f4d28e1acf574c0edeb8aff8cf5065f1c3cb07aae51555f336e739a987f990627f07c899b9af520f831e312b09b17946ca0ac5c96259bf49294f45662a88e7101ef78601ce53d5e678a49fe0725ec65a2d3408c9aa6661ce5169a88e35d0427af650b41e44188f526d96dcaa5bb482a375d5db5075d3ce6cf4b1d4d027794e16e5260cafa0eb768f13f8e184724f03dc27710e42f8102c3ddabffe252708456ccb4bbca48be9340c1a3aa322df35647ffdde9ff5fb821935444fed5efe9b690f24db3e9fdf19ba5f1ecfee81a8fef7022ab99525da518b4852efe150c9303e6a28876f24f71d3e96f0e6e3e2c1c9efc359c0fc34da8d80086fb3d95b12bb75737f3a7c0acfeb0e262821df5a38da0742f882345f2c2e39978cb45741d848cb19d0d1029ae6761e668b8929d60ca83e5ef23d0af70fc1a5668603d02a6932d87cfce28e383bab6957c11874db2a7209d733f065d8823a18521051e2883655367932c3a58fef2869307de271b68130fd3acb19d378264ac617ed6497bae5f603c3121252e6afe6307177c17ff059a4ae3126d443c517ec86a0a74aa32a93e46936011ca0fc6b355d018c00fb135030deff50edfa019978978eddbe513794ea7b1b88ea079f1e5c5577c674e879c9bc0786e642ce26e4ae465a607858c9e8aa225bef9188a6517a40b9cf4d27bd8b7eb59883b5ed2947d9308bf388a92ab4ca074e9b3b5a09f1546ee68506ce3e4c0e8f8352836efb2453fc95e1d87f693d0398bf81ec77ab21899b16401ecfa098f3f3c97592b1e102f0f7b19ca63e383364a9bf1514ce82edbf45ee81657c1b14f254bf05b264837c4e78ea68524f646e3e584ab2f4f08fdb2ea36b833a83c905abdd04ab89830cb2593a6ccd8c38470396bbc7c84fc9cc4a8e6e54ae4d1239c01d07eeddd16b7bf21b34dd1731cad4d8245c1267d0b586cee154c8ddf07e8406cebec6ba3cdf4b524193d7c0157fb9598273d037282c8b5d85841126aaa9b7a4401dc3a7ac2a9dd4a8f5ca09ed6419eaf50a372833ecebf8f67f1b35ed741ae430194734ba4912c3747dc70b91fa2fa5090a2515f0cf348b30314058d48082fb53aa7bc6d59a44a5d30f0456f2c4b552dac7e4a896a282cc09ef04c226c83f6afd0cceda41c329900f640a28727edc3109f42274c92f589bd4a70d0844332a7a9e75936ac0273971551e38e7b37e503af40eb2a5def6cd3ed6c7d7b1689d6b2052a983bfb4e39cb1ed0f9abb29bb887dcc0a907bbc9a59e09e5ee597a16462c0884658110f88c2a9d31042c58f05d49bcbeb31f62f84f5fc6b7f938d2625060f867455e3e6b5eb11a7e1ed333da9072aa98e5244e223046e4f535089a46fcd96783d6a94662564b8291ddb5f3550add59e68b6056c445a37239db19858ff0471c622a00a4f15f153399733961c00f3cbfc20bc3227ff8e90a96a8a05f511d5a7434af9ebea41276ba71791a08fc9480dc0646cedef07ab3d39ca141b978724753c7367a4bb1032acf958184423db74c99a1f35c75abaedeb6f0a92c2001d22fde736cb79023f0a1d8b159d14d22739ffa70280ccbce585f106aea5bd0dc79c69211702e8a90cc0ae0bc133e6c535297fef07af4d27cb18d94a8dbaf06fb65dbfccc936b35e362a3b352d6c66f1ed2f0c459c0f200ec1b4fa3dec213194c62fdf31c2975672902535c60607983fc97772a53379302d218df7c4685ebdd3abfdf73efeefcfa6e4fc3977de81a27465cefcacdff5b707a8bd21fd490071082a33033aa324826d8e4f26907dde84e92e1577493a63b30bd6d25da503bed30dde7364a764e828c7e50b15e482ba6eb7fe61c741f4ffe76e33dfe2116900493887f5e22536f8ff0779470575d44c422e622f7b5c1691e7231dec48b705f793ccfe5d2cc6d0a0ff682e129ca455b21af108e253af9873da496aaa9c4544bf3c8ec8ff8a33c388439f441fb5dad3210573f0bda276b0b169e4808dd7e04ca0ce9a411c1ba20fb686098cc0e2ae943c0cba2fb7aa234e19593158f531e2221019a04367bcb0cd188b53e4e2773cf3d0cd4bced7901f54ea49af4837c0636c1729f3a354f6cffb435063a9fadad508196350496a40abacec9e21df52e0e6b02925a8e59e7e701dae419b8c25e3b18975da874cea8260fe4b996ea897c5f7ed2ea12ee55fe115d0a6c2bf81824d10664903b70f939c158764e912e3be3a2ccc5926e6a8877792148658f5f8a875523defeeb995046c61fcd1e098f02b9aa5e8f92701c97ded3b6ea13c769c382a13e6e29651f357d45047522f865699673f5db61a007ca628b3a0f52e6a95bf845d8dc835e470a61e80eef175202bb61e92fa8f66dd112c137bd58e6938b1139df84a26d59380f469bc2516fcdb831af886bbb9b40113dc6f424749c0e16a1a7330b3adf0819f790ea0c440809d56b9c991fb1a1ff3b7c4847c7d4f7459c5a17c137fdff441067dadb40252c4590078ca35bfc660b0bccee588cad6e5f5c6e373e9606be1efd9c1782f06451c000168103b247168b11b1f187af737cf6c3887e048bf28be56c2049fff9195678b1dfea2898cd01d7b86441de62bf7b38b14f39be393eccb90958376c4fb540dd872c0162b428acf41a3b2eab018f2a8338906e1ae258e1243257ac0ef6bf653ae03c69647d9d99b020a51ab6d5f150da373a55d29465cbc2addc5aea7aa90402618b0ff3bba1c363c0350e135b60f9661930f30cf7cfe4f8dbcea13d4e23a40f5b657365f958cca44565ff532c8f91ecc4fd819a732a3814fac1373618fa934bbdace9e429d53b9b7ca4c81b9f31535bea0ceb4a3d750dc846b9ac61fb12d4636c8025ff2b3b11897d6e57342ba433b92ed8bfde2a26f54ad6499e0664affef6b102d11c99b1bd28759ec9dd0c8f6eb199217754c3d49f7bde670bfec7b9977f57226b104b567eda797c3e0adccd5bca5e595c22074151c86c61b5013ec371d32dcd627e49042747852ede3cf47fcadf0a5185a786e7146aec9411caa48c9bca12e7b7f1a7ee8cac08ee2368bfa70c14508c972a0b7926d525d045833383dcae0544dda863ced1ad82fe4be5f296ed658121e8051a44f7025f0988f3fb0dcf1c3b0a536507ce91c98bf56390683887597c24f7aee3739ce093c2d6adbfb9f1b73cbb644758307b5c81759977cd903e7fd7ecc9c05561ff3e4b0457d46f669fe2fb31eb582801f00483ff08de5670fb1d880ff6c89b9612b57dbc45b1085b2fdc57a65df57089fb5ba905650b4e08c414dba3b56f1673337ad383e6777b7a799171ce4bb943df249c644116a697320968af526ae554f7ac3842ccab3b0c434ac1534e7d9148e203bd5e2345b4cfd621b2c87906747a29ec7e137179d32fd14a08ddb1c943a34c327611daac9b0da045a4ffd6254e2a309e6c8e4e504453820996fd5040d39e9fb873157696063e56bbf44ab839c247898fb28b18f1f30f1a40b6c184fbc8d59d7428964929e74330e4fe7d2b46ba7a24fd7bc6da6c34c619dcdb2640d35510522d69e40acd9903344c5c5ed9db088b0c4a1e811c0fcd8351668df8043aa6d920a42ea0b07b8a22286dfc56b9cf0c1e5d5ed390a8055f8cf28d3bb085616a4c9c7c17ae4dff75fc71e6fabab89d6f35c7307430531398e44840c4681dcb60e3c68a96a52dcdefb7e3ea58fe61a807eed39f91369bbd61650c2d2e008a6cb1d56edcdca035be30733048074677519ce320d63fe20f6b693746533841870648944ccaa5f258a8ff5b4dce9fded499f581472db8823c79a64819b990332969711af81932bd07415819996ee97da45da36d9e0632a11cb3953be03be4f9a8c65ad6346d325ecfc2134c9c1616a79e07a870341a257999e492a61dbe8446671563cc5bf36944f2f5d552f195bf04627e5e35803c2b5977a47c8266258d44474287840f98a04f24196e0f42b71678bd686c2371d78e0db5ebe55c324d9c600c0d01611205f80f0d88cd696ee11d821b1b273d512037da8a2d80d2370e6db07695ad0481e87a5e6e402db5e95eeda90a826df29f403e5e8e9d55a67a89bbc115aff8bf46dd23f6f73f4a996227fa26df46b77d34dcd2302284b8f1c578e2edf58901fdc669f4396342f3ab427d808aeb51579f17c54d7bb4fa940423ebb8f53979f36c994c9476dcbff8263c3bb5713f7d9256bf9234f2e78350c69d157db9833a69e104c278037bbea17ef7516982a99cc1dd441229ea1472e35ce15b8657bcf4b0e1f03773190e3c58071932b7455724f636e7730a43250bf9611b7ce661153c5a900981618ab30651d44c259b18140f6dc0942303f9361c29d0f3a2902e16a550b77252ab785544517ed6671da9d5bee0c0475e39bee6653bf9f5c4cb9d6ddabb91c53cf2c9b347396ecee72158c803fcc3db669e03a648591d1de28b4084fd06f15a7415998e1335669f49c595237beb2c578dcd36a983d2b1ae077db8aa79c623e69f9db0102a00c239af2c294486dde542415fefe2c031e7b2046937b36f5e8be97b9914464196ca74b9eb0f3e29762116d0c3009c9fc0cbd5d2805b5ed768d871e67ba0f866de8270e245b0253115e9f3c51261d1cd7af5a27a70a56cb7c343e2b37d2f404b392b7b9d0f05278b61846b3bd367a86bb361b7d4f182c5aa7dda656c3ffea1ac9c19d0474e399887747c4aa360c1183e52ab9ed3ba1fa5e857fca647c720295d8665e760c66ba966d2c4c02cfa94bc56067e2f2a0b81df8ba7f5149410a2f86ba6a5562f1ee8d3307e7c5053cf0f5b39ce5279178f4cad9bb4ca98c1e867bbf4ea49c9b1eb313ab51a3a84e3197ce28f4c096d083cb1205be61d4fd7d86ad095f9689bb0b18355f814d06461db9b84e8a5a326130628c1b8f85e6de7e8aece057c2023ea019e50d18fe843b37a7143361d39c6cb3b2fba6363f82bdac1161358e9a8238a809be8d172d727cfcae45786c10b826b622d6abc6beb53afc111e8bc9a3aa3b1e7d14ccda94ac7bea0e397db11036fa47cb1764a5cddcdea1dc2ad1697da4b56f1cf7c1a9b34844354edab3817a45f88d5082df6eb0c64d947bf4af1ddcfb46d5bc674bcf416aa4706315ef0cded4c70912435f881c61e0b46083eeac1cb05ce905fc6e083cf8b9adc35e4f4b51948e3be1d8fd2d5bb6f9796e4cacb6fbacef6e93c32b97be9c2f2f015b46f8b7100d235c79e706f87d93985117ef66281b7b18283997b8cb05b0c027cc25d72ba7e7948ef23081d537430029fbbcf638966df0424363bbd2456822b2e2f1556d203bf1e6c4a502329e94898b3a1f5f4eb2bf8f511184fbe76fddf84b59c817621ef2444621494aa9d6cc0921fee9b492a42c44473f5b69e34b5a45482760bc911587faa15d037d872c7a49cf8f2fde7fb342667b397e8cda72df6d3a40b3c543bbdeadeab0fc3950ab20bd2e3f3e0c2e13358ba3b49be24c953de9c6895c15b23bdc2130ef2d189602e401d2ee68c66d0d658cdb5381c626aec374263706b6c546f88427dfe2692759c398fe5022fbb8fbd8db2a2e66d8618fcec700ab1f4ed1e3f0dba4dce70907d13b7f502714ab9cefae16b561da2980b5249f7c8eb258fd4fd1228ed6baaea1fd4ca2d54c62557359d346d6cc481f6872b883e66d56468f55a65370ec3bf069a5df3b0bb1b43be9572a27c5f9df891c4c76efdadaa19a4e506ef487458a318edc5de75e440b479fa74c50868adbd3486b1b150b5f6012555cbfb53293952c2d9dad47a145b4a3aba6e9f25b41fb28dc87f1088d3362efa4a4b391bcfabe9edceb4dceefc294dbfe1a848d773f9c25f9cbc1a9f40f665a28d1a73630e1c8d6471bdf0227ac078312c86a764387ee953991bf4152b8dc553dccb5c832e49d33533e74f11ac75720ec94d6a447418dc308e5d4b0ef663cc02034c0c2ceb8e4f2e22540e09aa44bffeff14eafd31b9ea611799150a5a2360f30aee4b2e89903ddec0569e26e4b92b226789aee37dbc452e35aae4523d999662ada16ee740d3dcc61803e34551e15946c859e41eebb0abcb1a8cc353e8bde1c322cd00ba2a4eb01b53865d2d2ef0de6c018b289a0ce7a865e082503d587737487d74a60b1865f391e4a0e830071e50d37cb6909eae9fcb499dacc6b912d7d71c19369d1a3bda921f18345448cca87915ef949848c25332f1edfe06ede17b4b581d0fac99fbfccf8c4959df471fe23ac1d80d61b30c15c2856fb4912ba05081638344b8d43d7c92cf7a458e7ceba74be6769db9e3caf3fa6be398d13be8adc7feb9bb1480f3c15c31dd63bf2f8e67169dd7f55f5c392078ebc6cabd5f5837c31f4b48ea676ab4de6183d42a8c7857dacb0d007fff99c1c324c3e62a868d2ff7ddbae3a282acd485eb93587006526334ae798f65b98fba08f68af524c7bc21eca4b51d33fb4b60ec5632351d83e60b557fb71819bbd11c3c8934cad03c7530c96976ac0d4bd75cd17aab6556769b4403184d39bd412a7e71885bc1fc1b9e709a112c751a032dc657ab56c135e3264145b05d11e4d535ac5553984c0c0c2d664ddd96243e83694b5fd86cb4366b40ae5da1fe59f013b11e1e72509de2b37949d20535f30f43ffb8e13bc4f8ffb76ea955b342b22ad68c2f9ad967d013b16855ea8341e700e0cf2235fbc7a255c6eb152b9bad4f186d4649bcfe26240ef4c8e57a4ed5b74285d95c7d89b6b12190e56b82d32c8ab525d5b96ef2428fb02f23a371d2815a3cf74603abcbda2497de348c0f8877c803c7689ef2599d94bfac1341617d67ba599122651a68a1fb6eacc1a33c54fecca3d07e9819d1ada8b82a172b008cffbd1c37ae7a4d90010d6c3ccfa255f523749061fbd0f966b0a1d5efaec07acb67aa7e7031e1c38fdeff44b78c8697310381e40c1ea30ef9e18a8e09e45b2d2e06f692b410382ba4acd6146d1bacc4f1d614bf4bfe7214eacea75acdf07006471bd9f9eae974d6fc1e07ad4dcbf0518f6b5f495b62021a9af5fa7ca6b0c6c3ed96b8ec974881232e4b8887e8b09d802af02b0fc695aef30636a5cb070c1c5a5a687d47c77b036fe8ef3878664003d64d37ac50f9489e73754bb9e36c73b58056b1853670c128082316efdea64a9e7df40c9a7c6995f1cad12e99fceb078e9272cd08249cdf3a92109b4d880f64c6a3d2ffeb8989eaf21f65e8335f3aa8bef418c19426a17e4cca151d092b9790201f2a4207f1c39fa196ca5a6b08944214e8a2cfe0268fd5e208d89ab2d59a4f20f00454452578a5ff19a2aa0f305211c547df5ed00b22fae2fc84e23f396a58631f5da6ee64908535df7846456b279e94b65215285c93f3a788da45449a9c4bbc2f1a6784ba093535bdff6390d69dec7b97bb95cb87efe472a09080aa2fa3adc84b2c1ff2e0b41b9efc8c9b63357608cf88306064b22add1b2e541c0f3d8af6fc8537ad6f222bfe84d51f7f189738532e6dd9918af1a0dd1e4c67186c041d79750f15f81bc557a203a8751b83350d1c4bb93706ce58166a1e2669dce24d8bd9a34dc8a303b2cfda7da79eca76f3a65b401c82365da6be28e3d2a620a1d005e28b5eac3ef48d0155df2adc467863b59b407c2f745ef532b6930f52e74f32ace5b04fd5451d3b07bbb3b07b7509e24afadae891e405e736973958d26545049933b681fcf60f0e5187a0cadb1978417a4db78dec212f0d1ee23e81496677b69435426c1e32c162e9d0cd40f61bf8c7fbc786e3c8c876981e41e58c10de61b2d66a3a5fe230d1faf2b66ad4d762f4fdc6d5ef0ecde2e697b1e623c421ec177954d2640a0fb7678fb3b39124d6f2a28438e225f6776346d98ea9aa0db3d898516d3feecad6a62688b2f27b0622cd979763074baf6faabc6ba04c0141fc546d5ebfd741bc2733de7cca5c27e5a8df9a8222fb8b6d53cf22039293128c4583f095ccd868998db450af384db8dd14a0321af6095b242e2f9e91b28620eadc90af81900ac0f35b7933715ed7832bf8654c806b8d10225d1b8348e77f8e33e7e750399e2381e674afe54a852f3982d72b0578350da25005395947c4b285a4a50bc2fac462cf7489d76a06107948d56bf4aba37208d905707a377a95782e4bd8c92c1489c241b1327e855abb9aa51a34f31184f7a1803d6fa443579ad7625880c4588c5b5df37f8baad43ecbce8706a8f8f010cdc24c1babd87e7e8f2420d82715a6376056dd5721519dc982bb8bfab906b64b43106b09e2032ec5b10ffa3eb093efe1b30eed4fde025451f3fc6fbd36a8eecaf363192848430c6bc1d7e3f11cc5a61b9ea5a067a4f107254e8ed5552529275a94c73a7d4638aef1002e998e4d5294bc9a1b318119a40a0b2614f68407b775284f3d78e92abf879f79aa210c985df93f65cede5f64f21324081f1e6ce4117c3fc6715089a8a6aa6f829d930f64527e0e1b23be3c15a0a00436f318a7789500c7672fb8c8980e9c47fcdc7b7fd605511e0ea37bbf9c9f2f284ac376760de3246762cfeca640f4d11f5dbf1510397667d93a328538bbf311b1a652416a923f8b752401441cfdafd0a533a0d76a75c0d70d9cd072ecf924f7ecd1b75adebab3cb39fc84137bcba4168c4fde850df1d9add7d36ba68891f61f0966b479e6bb9f720c999d8bc102a2e3316dbbf6c89f04a570af71343a8c05ae87fa09cde0a8d29092c2fac6d4d384b966d8ff53086399c7c37b66e6ee1ac7cd8858ed124d5e4ebe3a506b642fc1e8fe967fca7a164f2465c1442f1ba2583f569c4b3e549b04216d1344d1dfb1f56a866dea452a0792847fb1eb9783ccf7391fd0fe4fd8ddb964dedf1631db32feaf1fd4303f9d3e71867466bb574c4f2fd4deefdb29572c2f88301663630532fca9db5225b3e6e65156318352359c47d20618a329d44dcb68e4f2f5eb25497f4460bc5be7f24996eba9e3d1b5d7d11dcabbf6529d4c010eb50e0987479742e709392f4b66f662d921","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
