<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81d76801432204a468d10b3d98460ca647375cc65ec050a776204e1dcb7b73b3fa2eed657006ef339da1454a3c65afe7bbaa3107d21f8dadaff9653450b3762b686687190f735edba42cbefa54c44cc236a1590e2ec8a4490a04dd07541bd4d3b432089959decf9b901f7a1457926fd42c9efdb1ff759aa925e1098fe6f1837ac5b1425ac351518ddc157c5a82d29f06ab75335e341b345f4ec084ff64c0883016c46780d41ada1ecc0cf8da2a5b173c6a8547f603ee626bf4c2acd0365d3510d956c2b44e3b7c703602552753fd684a575890fca89ea3e3676ddff26fab33d5c7b90df31fc4dd46867d61e9d439aa902a2a1a6b25f42c62fc8e143ea0600b3334f0aa6c3c35cec0756e2f42e81cad433a9178b20502913e4521f3eadf8047f58a445925542f48b4cd051350762c818487f0645fbe5b85598e02f94bf0168cb324035759de2657d74d36b4f20409d7231a41cf8310ebf747fd9723585048add2ae16882ff7b56fdfdb86687b1c5c319334fce52af6f9fc91c895681b8a612d93f97c40dc143672100b49d44e9ab06ad14ccd5fa6c5c649ee7ebd27c0fbdb53dc042f0d4ec5617741d95e30c5ba52e758a1d596fb778b20c1d399c93dd6723d1eae9a54c0e185706d833f1b0d1c0fd8cb6b83570de7abd5cd966766c29e7bd0552e0e4eaf27efb0fe7991b5437138d33aca133a9703a0d54c2a703f79660dcf5cdb802be3ec2fbe3fd2a2c3a90575a1fcf05f669f36a5995aea51b4ce5b34735b328e426e5812ccdc95ea4747ff940a6b0739eddec652d00879f8598cb3eac8b0eb63a88edf9c312ba8dbb346500263e03c3dce7d4dc2d90e987c922bc33f23589a9aeebe6e0a6b68c407d6b1cd17b3ac69a9f5e8ff260b5120672ae1f08a4dacfe4476be841ef12040d23f8fdc9531dccda6470a10b63fcc12401a8288f911cf931c7e59f91ebc92d2d20b5321460199cbfe1f72f8a20dd0e31e5a77aa245e8143cae15c18dfdde5fd8fbaa113c0081c5ef167d901c054e87924b666459958c99fe599fc6fcf9061f66db7d0fc452440685b5437bb4ab644495ae29826320fa0646f66b502392609537302a5b0a766ffb8140cc5b12700a911a5155d77a6f73ede0fecededa97bff2e072e533c0b995dae6e32cd31a0cfde18295eb87a991208c3f4761ef2b38afa8541be19854b5039286239ff9181fa119f2b680ab1b2abe33ca7be255172274e55e90c75fb2d6d2e69b944c0b2b8c6bffa9bb5f3fbd8a1a8a832f48c92b7ceb3d9b71c3c168be0846936ad41f1275c820fcd6d59cc6c7a15091183c9ac87d633e6b0e1c6a0cdfee75a90c878e2443afafbcfe4c729f31ab847c465777804c7a41e474b78038815b6cb72005a26fa4830c2c8f04d6d431334c9108097b6a312e4e3b4460235ac78a0a3f4b686c3f4986bfc96c18dc3678b41072cf3e33c15c8ecdec9e13928cd3c6bc8a7c4ff4f2deb27d78a1927ad162d741e910671c4540a3ed30363a568e8102272d704997ea6fa35d3a12ffe310948e9afa8da3b388b17ccdcc1ee338ff94bdbc56f258ef7f6d554f6fada271598498e9753400beb97de83c3dd070af9f571338da101045ff6be02f4d1d5352b2c44aa8a91e03e88dea3c86349189004167b746905981c8c261d3b344f6208a398956711f8702e65ecd7085bfc850a5b89113d350264803d858aadc187d83fb15fcbe80aeb31f935eca6c2335cf743dcacfe465dc9ba0b67a6d70d4224c1686f55954c4604ded4926d3bcc3e3629e2c3479ef91d502123203b66e1e2b61a396bdf1aafd89254afd98629b99e83361e78ff4c55d2e0eeff3a1dabbed811fb21b5a96c8f5422ff93fd18f6e83a356c1a3f1183374ce3f7db1bfc62221f7f26acde0bfdc80d8b81b86fde07cba8c6287ea1ecc303b135f6cb1e3498803331736c3092d91127cac0ed4f305aa996433f13e4c1d36eae4cbe84f4b5a431ca945f68bf724730c11d40f9aedf32706ad9da69597721b11b8fb7106127ce1d5ca8330fea81e2e471e1bc32e3a288032b4b95efba789cf21511af9c8555cd24212fb2a6aa2a51c4244598e2af55b3425a6a107dc15c3f27bd8c3c3dc5c8e38834376d26151ba92bc63f7a3bfc1c164c913164b00b6b341dddcadea25eb016dfd6bd1d7d598cae03db2e896cc698a214bc0a332a3dc00b66299fa5c7e03dc976aff104ee77d182463586acd32c23709199c2a838df665ac9e9929e4fb57af166d61dae78466fe152b4f60a9a0aeaa7005b811b6f823ba7e2f20f6ba08b0865e9b960204ae7bc4a127a2d8319740a58e4222f16045e065f23252248ec3d292a242f18b40a2ff3734adece541940eca59da5b2df10c2e278c755efc852c1a678f6d080bd0e00dcdb35c2e0f157efc813b09dafa1939e3c34f002cc95b1661615fb4095daf8e80db8d87861773de2646acca29cae7acc3d299a60d135d565ac51ed10bc2a57c09b2f6de6dd6a18718ac873647d8b9e2661e097c6eb2f66adfe9c3e37734a0bb2d88cab86575ac2d1db20cddcfb0d532ec1e1995d57f60036117c40d9402c267c96693bcf5e1febb2e00c4c57e0d76703c6694b9a8124ef2c6580653874ffaa0aaad05c961a940095e5714b326f38f186ba3c914ba580239d677d11df8ea1f22c8208182e8b9b04d1ac9f7c7b2599b62d5eb1dcc2a4b2cd67c34be50e558e939a57e775fb1d62ddde6540ca723b026f5d5451e5513e0f48c2a97df5c628d1ee28026b001adcd405bb112b62701cd8aaac7c90508421316696810a9b65dfde5fbdafe18a8afbadc1b6eb15d3943878be62983f545ceded4a4e96fbe86950dc1143e9a3d482812a8d497df540dcf120c4f5f953f3a3a8ff7c867fdd2e4d6647f8177e026d2a7d86b7e18eaa7173f3eea92f7ce393ca9993b21bd8df0a756f86e3e0f1ac223122e700a938fdf507b7044ddc990ece3f875c5876efb536843be1d2349830ad658a55e7953c56cd3e48dd83712528d72d19fd2ceaa8b0f57dabbd21fa48171de7cecc4664d86ea5b0d4c43ca28916620a38858cf5dfc7ebffeb8ffec97c916e2141f0298a1a10f1452e124bc533ffa1248445c04c1a15fd1218e0e5f1de96adb78e7b50aa4aedb2c5db7185c45a4297f51b3dc7a5ab5e49aa68bf86fdf3d3960a98a59fabc72e5d32691b60c6ae7dc6d630aad643aae94d3133119127da87c042d66bdb540f8e2ae225b16d38af8ee491dfee137474cbc14745f522f6419a8a175c5ab5e4501ced9796369c6919cbf6614ce4cccb8befb01aaa9cdcc4a015debcaba035565da3d079ff42fbf1cdbe9845f024f80a53f3213adcbd63b94742a9060960dd7bcc42467ac69c8de4c025ed9c085d1111941ef309573681a9ac577362ed8f4a51c0561b2bd09bee0fb53e31ea3c75e8ab8eb85f1b9a81aec4f7f96dcf80a83987a820544706e4d91d8cf6c391e848afcdcc0f6d5385524a1066168eca30534f8d4f25a4aa8f1181d3d840f1302fbe90943b5f71bf13876e9695608fc072719cea5aabbe9f64218f3fd3edc80722ef0724a9d948f4a197e297703107b42efe9f155dfd9b0f34dc3e6e94bc6cb079bc2ea55017300d1e020f96787e506c111faa28825305421b0645790375953bd45e48dd52c721d237536d4570a23eea6d631b9cb011e386b2277584cc04b12fbd0735ab365662964fdf5cbef8b68fa8a07ab08e021e69c8f7dd886154c0e78fb9f5a9b771eb5882e7ddc964676343f150774eabf03d3fd3432b885cb359ee3fc415b2e14cf88964508e472aa8aa29cca1f2d87feb7476524061318ddc19330ddaedc06f55138aa362240078502a5d59d94bb6ce57a750789e301c865c7eb85d746d727d9005f91492f56a8a35139e80777841b33d4f760d51f49cf9db669855ec45db8e106f966dbed6aa8525a066fa34136cc518f13735e5cbe7b11a20b71b136998f2d9f42f1e20f5f71756be2c647cca528df79a9bc25ab232a4c498f750f0c60346f2daefd2a8d90059fa4c0c5ac5f0753eb1c93d0deecd7ad21806091c0fd9d301a4afc1ab75706b7c3c276a93e481725593521c3d88c18e55f338289468df4754dd073661a40ba6da2ea738fd4fa0e587248ebb6555a308e09592509e71c195e20fb45f0f4a4887620f993932f9890800301e6e4f61cdc96f0e2037e90c6ca4b47ae825865bdfce2d9ec54a6475a32e972a32f004f8b11060515a96207264872796c2ea0ca6f0ffb55b32ff3b7ba23acb0e75c6fe94e0b15a482316fc7600df075aa342231799acc6a1ef1c2f5d58cdf0c8e18cc4c10ff96f7877dfce0d229302d1069c42b252287e470135a32e146d384c862381316cf927a5ef29a7806e082671195b511f59d9bb55e1c687aa8e84b151d953ff215d147fde4369660c527f68c88725bd0f387a8a2ae226930a719f0dfd547d4a39e6c2ef6c8be5da6a5d86fe706458fca5c4098d320c1bb0ce59330876b37ffbb862d2ff1525dac6d0f6054a5f7c8c8b2f69ecbf288b5fb88ebd7e37cb4da860a5028331040dcca305e44f9b18c9eb45f4a7ab932b768450aebc407d3b7922797f6c3c17fc9d18f02ee1d00a22b328e219e215d0d69823e6cd547bdf62a5166319234d69e1596ab1d7044f229b8ac6f18024804d4b0fa1ba0181d68c83b5d4926b26c95508e0426b7e669bdc566eb5dbbd7907a990cbf631aa95e1304f079d978411602b666dc94dad68b287ee5004f781a7c71c6b330ed92304124582eb11d2c00517b12304f202a43829594c5bf422bb2ff408449b821798f00b40365d1e0613e8594b6de9dbfd7f1f9fbddbfc51576f9d7b9f9ce9788de4d707fcea4ed3e6c7d5cbb740958744134ff3ca5f82ff7d45c912364031eda5aacbe9d7d238217878b425afcaad6041c2cc3ddae55d542268985f9aafacd00b4fafb2116a659896cecfbdd1c7d7f99e1cbb64d1d91d3977559ef61b02e0ac4f15402a985242dd6ccb68529dfbdacae3836e3ad3427e7622d6531c9b99eb158fd6438a5af168632114bb04d314d0f5b374ca3566872b8e24f4cf4608fe8b354cd0d2c9898d61102def60696eaf6b8ae845d799f4ecb59d6ef45197087cc0f023f1573fb38cf20824a1464712f4565fe937d179be7685dc1d8cba206826cfeb9501469177ff3ef0ce50dd85c16d3a877559afceacd856a4d464e937c5caa3cc8c3d1bfbe92327db1bd6492dadc96d390bcd716ad4c03ac86e72dd0a4eb9e1ad849379f1fd2f6be516713f19fbe8ec290a473f54f59fe479567d55c7a74ba0f4a7b28ea95efa56387a43d7e86cedd5d27ab6f23cfa2398883f82dd5ff03b358189919172b3735981eebd5c61ff23192e634be94bec354d8a677f59d5a35c6aee6198d19b788bc8276e59170ba69a367af0be0ed28c8879f8f17043634cc05927128a6fa180efdee61f41cc64b3599f1cc01faf50e27de7bd6c1800759bade733c66ee4846328d80249da0a6813016cf332fa12a85b17f0999496dc9f6db104407226877c4e7fd5f2a97b935716cd82303e47251bbf6f705f6879f58b69221ae3bf293b4c4bafb3570aa6105ae82206171669f56cbabb6a72e0aea20fd8adb5351d108f5f9cda86e03c3d89a7253460af5f55ad686594d102c8f5dce32b72b6ea47ef9349a9fd5045837d3955d2546c7f46f531634ef0bc2d1679ea662bbc6e1ba337c6463443e46344ac7a74404700dbada0e7905d116a334c5066c1ccb52b5bac326774f0bb8f6a7c76d1b34ad27894661c5355ee3938af5fd0f15b80c11eceaf9d7dbd400873c919a51fb605479b2458c0f95af3adb4475410ce4e54c212b9fcb84c9bbd0d2b6106965d7823a8fcba31b2a9dc798d18da07e05c8ab7d272a437b30c41989c06aabab4584cf863577e7fd2f6023f32b3bcdbded2fcd0d1e5e833d05a136b041ffe23e6dc279763b7902251dffea237bd00f8db5e685db54289373574e14d8f7d0db93d132a5e7caf6a2b6ad0c3bcc5c56cfd38e8ff6179812d27014ffcf5ef262fc38791bbccf1346b24261ba0f15a6d451ce642f0b9cf0cbd91a7c54022ba958b4297c63866ad64909f3ab6c3307494169659147eb1d82d6365be75fc2993b0bf70bdd2184f27ae257ab0396859e3b40a7eb58b2d46312c021ba5368c225a781b210783ed93ea546e3c8bb3c61df4affc9c3b93a343ecb4db41ca298abe29fe46928ba5cb8704b311ab7fd8ad5e2d7b7ad8a2733068b359a3f2c311da4167a2b5c7f2c5c6689c083bd4058c97ecfd604f3345219f9f3ae4ed4746613b7fbf7f92d504c7a4e81f059289b5acc09c85c5066e64638bd12eaa7ebf38f0c08317b6288aaf1b697daf6b8ee3dfc22cbb48ea86204ded017d8d7f08e4c96da5b2c0bddc0467392ed7f5a8172e0152c9b0013891902b87860f9351b45e15580117b224afb9c5aefca45445e4e219fbb8c39ebda1e884836ba0fc8e166a1092e5250899ca6b5a21afed38e6263deb40b868f85af7fa87ce5bfac967d8249e192e9daf8c2bea595bec8e6d363b5c1a08b080274c00d6eddf6d469ded412e814a961ee5736be7462919ca58b97479c925c911424be8b66ef98c44f025e91bff40df9b3d3125047811041fab4939d765362a101ee0f4b7bec0c352abcc82b226765bb2baf0126938d6d4045fb259fa41552c291fb244826be5d53612abf58a560e6662f30800c30db540f57ca245839a157e578648d75649e00da86dbb164b06874ec76189ba4006bb108b91686e16cefd06ffeeb92821af5af01ca47be86093d7535823cebcde2c1e2ade098b5c4c0f0640d2d55bbb8634d4f7a315dc44e7825f38528d3657bef1f12b4dc69ba298679516bfdde812f8b1b964540cf8e515e4ab6c9ab6d095d0454e32c82bbe22cb757af436d649669c0991cdadbff65ebbd1cc22112fbce8c1e5bc67a84a3b366840b9bec8d8ccbdb51a1fdb3e7476d5692dab457a1509cc0f6b20f0745b7e81e878037ac449fd1129e4114156e9748a0623f00a543511898209b998c5b1fb33267627c0df60cc2ebb4a96059d2ae816dd58fcac6cf6fd68bd0c8323f5ac1946706335b04eba90959df53f8a95d4f9e28cb2494fe2285f83213770a63eccaf7deb097465c55f180a854ec9c1a8481908d8b2d5d033b04be425d3af1eb184cda3cd0e9e32a7061e74350a05686cf0eb3856c6acd02a242a571195b7c7b3aee446178c8ea4d3de7d669078bc85a99f6d422b4eabb6802385ce2a525d7d71eb9c87b6fc3fc4d7b9af3050272d11708e233077786eac0f3fd65bf71fbeeb0ea4164eed2573f3494ccb57f274e2891c7ad79d2ecbf2beabb4bf0b7afbba439c568f3c0b7e8eb557a94ff10a1e937c3d9956641d2c4b1e576ab8c022ecfbcb4761d46772834ee43e04e91ab49a827c6256fb225916e82b0a00e5cf24d497c2e5c054d0352ed5cbba6afb49756ab1f9bf930e5b734e712e4fcb95e4c8d5c539a0fd95a320dc2281e5aaa048a57513d032952e7cdd892eab6ad3ed21cadbf74051eab015130f26eaf06d885ba498ea480f4aeec1b369347973010cb0f22debd7252f36bc7fd60b446c7effba343bcdb9b06c5a50f05e58a7ba74eb735650da42805473433455f2d658f09ce091b98e23ddc6b1e61402ee82fefdebfcdfbe2fcdf1368a51749e5cb37b16f5a89fe050a45fe166b0848dd815fd1a81f5bf5b0193bee69aba0f5cd6119cc72890d566ff26e8245abcd68f74ea47c435cfddcec82bc785f29536e02126055463c0a4c398e9f2981d9025c7a9cbc91291c0c100a08fa4df0a4f8fc95654dc6e76a0dc483fd16633837242dce284e898b4fd68ffa349c47303da9ba6bcab2d196e092d89c50478103e84c23ccf65cff6dcbe06b537c69c87fd7df2e2e0ac939228c1af4dc5588077f8c5ff79cc5419664eeb21879229cbac557157d43c36fbf6189ef31c1f0833d599c37b09d1bf4290ca07a753fa76598676bcfd7f9577fd0874a7eab285d5e90eab965610b065192fc04a89919204dce6a0bbd6338398c4bac6fd39358b738976880b683d4c15ca228e54c28ed86a4f2b654dd0f7b84ff0acde099cb186a7ff8bef85d5a302cdbae33bd3131dbffc2b63daace7565d440622af2981b2248bc6596d56e8b2665e9a87dfe7c61bde8cc5f6496180ba146a72aacdf079f13b2d61356f633b1c051878fa280d5bfd515f9e569e53df2c1f7c9a142e343fc2020f8e63541ab23d90284a4834f6e6a5ac529a620cf793e752696b41a201db2eeb212eea5036e52d588ade13cc48b64311104991e9d73a06736232222eec09cc077d2d8595e6f42d6eb08cc046acf87f5af99e5482f91768b7c0bcb54f02f708e838861a2229d37344dfff3f42b620ebbc58a000923f86cfcc22c9bf62369d66ae8e2270c9a76fca40136dc22f67c4993d98a8b76f646c4c6442ddf2f9aee2667d2eaacbf9830662a0c2459ddc176bb9116522f130aad574ba527eaa82a04f12ce83dc8a5ddd74f99f4857b8ac7a2669ef39f94c682f359e02d410ad66fd1a7156254342e60737ebd1041aadece42c1f3d14584e6d0ada826bdaf1b82a4501bafee7c8c6568d153b695db8872e7e84bbf491e5f71e75cd35777faa0e0e442e6beb998f9c109c6d3124e0d91fb4c55fed51ac633fe5f93b34772b95aca27d87363856ec88f5a4faa81165084c13e08bdd698aa5bfba33f52822be3e5346c3a862cb707d722bc81897bd16704a44d10dfd7ec05cb7ca0eefd5a1e7efe374471d051e17b5c45b55596fc253d78b13a51be87b020f672cf75ab02c8bf28b78837a7beb12d679088cf3c6a2f55cff6114a9fa71de06c02f4f34d8d317358abb2ab0b3b71f479b6ac0685947445f88f1a1f57b1d242f480e8336053e05313fbad44c2a6de432e0a4c0bb949b30ce1755f3b172b2228f31a4262ce8781ab6d6790f2e5a9ed6aa945e2bc5fcc578c0ee3ac51a6781957c4a8d22a2479bed6f7b2fb54d6ddcf36ccce103983c6bb29d0f4b4358131af40502c1e1b78c03b6b5d006fa0a3e1bef8f5c4370b3f4a26a32874eb6e3859db8b5de8c453a6bbaf8b601771849427f4f486f9dcb92ba70330e36c3dc01b46b7791c431f852cf1c10e467362192cce544f8adbf913687a7baa20fe2b9168af5183d533e9916664dbb2829ea546ccd5c890b9788a691b07ae476e46d0f2fc3a82990c1fb95e5ac957b3708b85e529ca7374ca736426b2cc04125c7cb17a6aaaf15017a7cbb1e1bc7d687bd39521ef334f276c225a4af0e7bfa25b2f42f7ca4a321b41d3093c15bfbf6f5ced26e63b727c08d1f633144d48879254eb697ed3cb1924ef154fb6cd98a4cae829b740f1d24e190b0360f7d60cfe2c6da9f6d68a7ea067d7b4f0a211d2f5c03764fbf741c8af0c7b91d1c99240d13a3ce9069bc3241b6cc3a75e347dad38a6cab217c2e7864af8950b671bc9b23c575208c2fea21b067b27d62836db65f7f2f26095f91fb095092affead25a0213a020418f62b3a9b9a0f32c2ac5ae2aba9dfb6838d61aa78eca8a7ee398b5cd1dae123ced6f5f1479f5827a4a4e6903349ce0867386547fedf5fe364f6d91bbc9a25c36c44e58d00c0228805506146c883bb56dbd3f3c3a928d8bc4ea23ce70b5d51d21c95833031af565a8e2d0e5ef55520198697ec48539757f33690e672cb3861e8e410851dbd15627cac0b55d0a45802b0cba9c3f6b4444a4b7bdaf4efd1e6502d2bcfd47360928ffb269e9de6a9551b106bf6c59b0b58abdc80a1a3255bd51a43395c1ec882899367ef7121e30050255688cf43edd89fa05c5e03516581bab09ed63196cbc23cc47f4593a42490ea537eaacf7ce1edb5b1bfe61955baaa1a257e806e37ed900d3ceadcef88680cac046cd6de6dcdd2d34fe9ae7240c21d6c5d920d0ba12a6e01bd74becc59a68073d874508c447741b8634dbbe49d73184653257b666b58dd065de6e01b27e11eb7b08b79123277115f7aa145599fb43bc0b0aa125627027f7ddd3ef8a34409bf92f94ac02038d4c2dc59186e2db7282312ab53136791c9e2d431e96cfac1b325adabb9f0b5d62b1dd555af92064d3f23446a4c6e825fb14ef4fc260b6473f80c2ce743778a20d61645dd2d2ff662b030d7f4cf5e96358bba38c322ce7a29d798d7785b6fefca8a9204aa282ef959e41f1e902d65b670ad99364d3632e2ca593d3f990f4e55a4e514d5b0a9d34287924a2eb4cd6da0d2144b34be5f6e64435823138c7b33b121bdf825c4826098d4bd2a92d4df2a345699547cc2dfa90704a3c7a3e11419bf018c9bb7354f2f38e685b54f6b838f67dac421094ac994a19393af4b4a477fce3231100d63f47600ecbd26343cbb4b423b14fc013b71d79a9a4dc1731f491b810bcf2053ee3d8e3534ef4677726d46b702495506556b047af6d2f8ff54179ca54414700bf9b0f6b3cc28181bdb7e55b0daea9bd0908dc7205f0ae03b8fd2f47136d35511aa69cba07b9900b1a1a0a2a87cb44e489c9499754866fa5d5c26ff6e12c41a679d713e79f189a92e18da3cc150868e1e6179d86c54c45105fab275489c69d908ff13822c718321adba7dcd1c3dbc7c7c0d4878fbfc3f47961e132cdfa0f401349c8eb4f67aa3ef0d4563eff3957d18f736f3e16b7a665b62b79db097b60c8598d2b753861f1c83406c71fd3f80d39db713a164afea33cdc062c3587e71f42eb31d79af368da3c35fcba0a3095396742597d5ce93d38aea39c4d142e7db651043bd6f276556631200f9df5bcfbeb5f630d79dc04241d3745d862fe031c25972cac63883aa226cfacf543ab66f0dd0029f382b3cb6e848785d2d41cca21d8eadc36267fe4047bc0f0eb6937b6583f095e793add070e7512e99a1d1f077fbcbe8bb158f4bf2888889df98704ee890e3484075d8b90bec65a10a467e0b28510126d653874194750811d36c7f201f232806312b5a2e90200f4582a1b5f7ecd8b7f43ec8615f4f07415b983002519e1d42c372593405e4000e96ddb2832190b771ab6463b8e86ddaed1eb4eb8ac45c64c5bcef6245cbda0527d5fee8c817fe95fd9018a61807de1e420c96cd7375ebcc4146d17c8ec11a0a96e6190ebce86f4fac97471a1299c1994e4e4d65d390b494e928d8abbb34f34145fc8f486d2e53283407167f160cac72ba69327e6d4edf4ab215a3243f464eae7f66025b41781e93462199977b779434740a9dea0b7df24e28e77fce79b02feb67e74b85c3db61c370ebe9b80863d59734262a7ad340987b17cacaf312a581387c5d5fa29c40c7324973dfd37f10b964f186b9e50a06059061eab19852ed0d58ec47570cd7309e29c4269b272fee7d63cad70b120dc9c90aa2ba7d07bd82881bd5717d9ac449ee0a16a2c46ccadca2423437eb285bfc58a72c18e029ff3db46c70abe9ccc29c02d3712d3e35268e8f0dcc1d2f23b071f234ff6816819f4942a46740749064cc3959f66051d7c4b9fc92239a69fcf39d25ce84155df7f2335b5ac05c5c1f3a41f5bdf82b8cd953db0504ff86ed6f13a38dc266ac264cede0890454af7692b419d7766258ebe2e8e84182fbd2aeda2a42484b875dd6267d5fd2016f91f281ea6e676be531346872421e797d0886fe94d035dce09bb4d710b5f172f9e8616e07595f4a8619670f3d90c623ba638ca129e68495160186db33c9239462090376ff9c08657d386249ee9531463519a41de16b11601688d7e9d55b42dfe4594d04db11d2d2ba76b57928ec979c0485806231d888f5af4867a9223a66c37abd28e922518d1939cd3349ac23793790e6950a730b5c1329ebd1a516597a3b3dd601b1456b71fa63d6bdf6400df222c6aabd42ec452ccd49200087cb585eeefef41d4265670a3ac1c8845a205a40e317ca158c192fb81cf300e9c83477fa3fa676b08e5df41e19b2d3fbbfad8c2bed72b97d50a5f9b7c94686519b5270e91f0db7e4506e404b2d466112a904ac4f338964aab22fbebbfdb54c909aa0b57eca546932c3fd8db096b40577a345f340e6fd54a9d57be14165d43be5d169349973920af4a23baa1e79a5243794739255cac08c4f222f165c27e5f10ef42b6a2b2791dbb3ad13d37994af69fb20c5b554d321665423ac366c7c5088c6d10cc43b3e698e052e4b0162961ab0a52a3fdc81424dbc5ad725935154d3f2378cfe7561771978fe8c7e0df6bef06765394a894c21f2ccefc807074d23963d74244167414909f4484550b8fca2b791cb4a861238ea310fba7db4107ba4c0e9342db061123be5ade047c6af4012a5b93e7845b8825b32f05a874ca421d91e2e32704940b8855766fe7988faa85d6b394a6aabdf60efd9170ffabbae74ced05319beb3731ccf1dd906f5a81b122eae625b11cc9c92257ff661dd48234cb75a615535f91cbd653f3fab0320bb5db3fc789acd8c116e97a76a8e94e109e0169a7c47c1900be4b0af84aafe2d81166528e80ddab161c61a108f4d8433146ee7322d2185751a64059d71e3baaadb43974cbc5f3dc9a10cf3aeed4fb5ccc20c85db007802cfda22a29de477352d16fa5a86198156063dea5869205f862e377f876e3d97798155fd529d6bc47c418913050fce09f56356715f5d1fd2591a41d20fb533f33b87a940a4553bd8c34891359a00120ba4edebe885acce84e4a0e50a0c636cb0a779b575880c0a2f3da93112474fab11c1034b74284379ab99cae8d7bc0406c1bc0f28eef5300fc988c21eb629cba76bf084b95a5605668e66c6ff6f27ba648178d7fd19489ac42f9125c0605f848828fb2c1d1251b85ed5f37fc73a16e97b9c4a9ebbb1a845ee920e68928be332da75eb4e2d6c187b0bf88c1636c5da57aca9d60e04c226abba03355c461533725fcbe75a4becc27488b50347de02ed876b9a2252772bda89a3ea018de98d0bea976d41ce5dbdab486e52e8ae992deaaab8ceab0bc7ece08602e57e2900e0c1416a1e91934c5f3ccd3ec28ce92402a65d18ac5a3a2eb4c60977b7fe2610e57e164c606b272c5963683451df9d37b707e01269bac9876f28e63caa68b46cd81b21ea9a3029ea22f2a2697540a6517eed65f07d9b5f60e92faf9e455d752bb23f5758386824ea8e532d9936e66a7bc5f3d15c95fee0322fd13d448e99421e836fe94a9fc71213b245c5cbb166ddd5465ef209e0b00c26c390a7e76af3fdd9c9c0f1dde2874b0d06af674d40db238cfb8848d7753eb53610c950bfb71456eb25db09453fec0b4dbc9a4ec83fbbfa2269e2226e438b46e3edf22af8a5ddb0e52083226d57acf663bfd1b8ded35f0eb44d885fd0d0cfc56900eb6147375835abe271451658dcf8c90ad9c44197631868aeaa39de50bcea80ab8f5036444f90ae639b7ee5ee4b31d4bb95f9fa7085025dcdc37f1d3ce83639faa03df0514ac244bce5aab4aacd6f0377e87b0bed1702adba1c62b2c1dc2ad7070828282003efc7fb93a7adba0b6045a531031477b325ec8913e19809d1f0fa78cfe9ab6ee8297d67ea8fcc45c23f62b75a27893307d950435896621ed30a47afb8651c323d1750e5c5088df5052d5cbfbdf2a3cf10142e5efa3796d3301d00096fac552596bbcafffcd3a1152d6bb75b457153f8f4ef4e4bd4f8703e19912c0066a44fe8d89c467edd7a1375448211d4ebd5f34870273a9756f83aacd89a133c1872a2abf8b763befaf39fdbefb885a35d34ce73bd693f0befd1d7463440ee451dd0c240e1c5114a5de7c4ad342c642a771702b1da216e4e3159a8d20b5c7b67423e4104fb636db88a83d6858d6770e176177e5e8139b884480a1b6e08a9be2571b0db2fbdb0973bac11c98fb9d40b99e686ffeb19c809072e700b00ba8af1f9fa3d2d673c02967be8963b0db5f4ce3ecb381a9252e11f09ea3db9abffb03ca9ac268d4a04303bc5f3fb17ee2aacbe0f674a425c871bd8ee6b2de2fd5c843221107b110cab63454ced8a3dba2573a2d4865e0f685e37417d504fbed9e0798aee83dbb4754abbb9164e35eb00714c3162dc0ab9b7483a200499942d436ef9845c710c00f33b5ccd3c6bf53a2e16ffa9d5bcd5240b50a01113e9079dcdb8cadcf099486eca1863bfba94be05c1db659febfa89778905e35f3510dc7d5fe89dc4dbc0be803ae716ecf55587eb2d46a6c5302c506adc4a88c1493dc8e5f24190756956d5922e5fd4e6b5068203f32b0c6520069526f4f957bb7016cfbde1d4c9ce6d2d131cc7a151cf1f774b4940d45001350c6dd4f210590b019dff23d6bf19fdc037f9e230551f3c7d7f7ff5f19af2839d69a1e66366d19ed3192886f7efc185e5a6412d92b7fda4b87a388288daac26c5ee9e651126fac5465ef3379fd01eefca9de12e4f15d393163944c8aade2df60188293b403a38837e6686f930928a395f40d718945b90c4527c81e3d50a1e63af27fa48b5705fb5afb4294c19e96ba5b0692d95e4569d6a31e530dcb9318e58b44d8b388048639788e1c906fdb29fe0806408e6622bf04a7d9c76bf9790a6002c8d13d64dc9cf2da6fb69f3b36feaee1145c529d5005e301f5407ec60ff40365b3c239d762465586ff0ab12987981cd137ef4adf983fb653b268cfe8e8cac5442eb387bc73eba03a266f37b8ddb5d12546c69cf66c4a635a881d4f2f06de90128066a2c801b8d342c0cfe50932871fe259978ec596b8ff3a876f230a79c4f0f08332b2fedea6cbac8b48b7e837e2a5bc090cac7cb5113b31e1ae57323ac0306ddce1abfac0572e9fde0b835c08b2cd41890df0c4891273183de6671bcd9add224d555e04616493fe77d166ab0b5351960ea65c5bd2f21aa857c605ea7d8ce253adaa942dd8bd4b43933aabda6e023d76b72b880ac00e017138f12a28d75cfdfc06b9e472cd6e90235e1af9fd2fc3488113ef6804993e8a6a179efac13f442ac1eae1c6ae93be62f94f03b9b041db58beb90d88bb13d2ce717c972ad35cc4ce7bf71481b90fa57244f064a64d43407a04de38cbd1f89c710136b12fb1daabe051d20b81355126f8d4714c1be0079ad9010f3e838f55a42d2745ea3250d316ff8a21501ca79a63817b7abd49d21fea724abc912834b2b7e67cba2fe71431f0ebe48857f6cbf191b1df4c0d25d1935185ba440f177bf56cbe42f0421fd714fee55336dd080d720c2dfdb59f2315c4718f9d2bc9a31a9418679d5a7bb555a3c7bec18fd860c2abe5c5bd3f8aec85d6ebcdc387e64f98cf360b94bb595c46044f414cdab899d1affcb8870362523e7890bc64623e1e0f607863a47416a820de50d304715bd37126d0832bbb67826abf819d8e167543ee44d7d4eb78bd81c76d80a0f56cbf89ce11f271c676a5d8437a8caeee3a344b4ab7cddb1e951ec8e3db56e363b7f82cf1f79682072f557b47c8b443f0d320cf05370ed48914d278de765575f364b7c2ffbd685452af7c2aa91f911d4fa3328011f150a423155d584329de1e46cf84d847b7bba64d851734acce5d5dbd61137e57d8b761b4e0e590a099b99d8b7db9221ce76e58d3eb31828f2758fc6838516ec9eeb213fd93bf3ebfeaa11d21b103e604d904d4dc35725053b07313aade57a3d503f5575b94adf3df27aec9c5eafb3ade123a52d73825c25a36266f03045f98f09466354216f3edfd38e6a9788fbbc10f0f3b0a75565f3cd040e2a60461ba1455eb8ae31ff81478c6549cb030bf1442bee7158138c5c37c2f35e0cf5661f62a31d643c7e22c6fa4c1642e7fab293c309847d3e145c634e87490e776613cea4ba84cc757935bda7d82c3c017a57b263eda57c7ac3e50b7a55f15ffa70b6d05cd4ea864e7fa5624daafa393dc3aa68b3d75807901944b12a82fe9045d34e005b0148b177003c866d5f26e63bf749cfba8ed17266af5a4870d394dd3c707d347050cc964a16c8ff9ab0863e4d1bfdea4d078198144d2d07611a7c7b3df1ded9ca9bb6a2df3aa7db1e597bf2b84717e45d3bc82592d04431540349c9d6d52e589f8c0b653c3a9fe173bcbcacb4e9408c650fe470097930524233ee5b10fc392c4af2da600cbf316f7503852694f8e82ca8a1f9f216b74e0ee7091a171dc2bbd94981f656ff1e2ca9d500c83900f2969d60b6410ec7a2e1df71e183f04786d019282f35b783af6bd246bc7060fc18a57c57c6dfcba63f6c5673e9da2ffdf7b7fec4d357499b378b519641db01f316a90d9c48ae45c0617a7125d897d214aa1c390416833fb71ac38fdc45632c5352449e7bb93ad41999a6645edde689ebf85a6559addde3bfc79edc11c9ffc4f6e511c6552f52beef1f4999293746702b42d02a7b54d5855839a68b1f31e42e0039acf87d3b1eb7a9fa5ae07d6d8d24e32f97710137cd8dfce8ba5530d54ef010d0c3f064d3804954efdff2740c0b15987ca6f9dcc97d53abb065ed74872438b9e15169511116a9926a38cc85fadb6719055f64f0040cd3b97555d5d6127e7dc0afd4ec164c24d1a061cb5ea20be555cbbc32a01a3175d67765a18fce72f62ae3cb148f6388101926cecaafcca9c98fc99ee605f1394927f05226b9d30e89da211bccec841910617d51a098f71c887d60c8a85fc67646c03e861ce655a812f17ab1def1043b294aca324e124a9ee0d7300d65d98e9479f8ff8f400995f5ebb33907a59c37e43cf7248219553ea56c1a8e7a11c19294b0b323d1daf4063ccb24c422c4a0a730a67159e9402462ef80e2f23449df38d68ec2e44dea24d57189ff46fd5bfd5a9f8d380b5dc93255d88ad0a98f0680862f4395cd2f068c35a18e1b58bfa6389f19214543aeb3ca6bfa6197dc8cbba3973cd31c95bcdf87bb8702cee325bbf618a5456768dc72d4ffd6338bcf8030264d191961b439415d7f923ae7107b9d6b345e9bf830603102a11f9afe4875d94fe42c6f8f4d710cb2bc33009d20dfeaeafbf37f3626364526651d1d05776c4e3f726554e91ebe80f4556a9df8399080c3b3ba59bbc79aa21dece84932a2d360059ac383e36d76b3e2fcab37c43b7bcbc1723bab7b21a30010ce98c0096adcd03bace0a7e0d2a0b179b8f0946f4c0c2c4124b3c3901658787e9daea13c7bb7a62725a7f5cd96f67d4247cf688671517e2e587da9ba690184986f7168a9feb7797d6d31dade88c67ee41d159eaccc6981086aac58b6b67e6575e7f87c9c0f3dc80c24d36c91e27f08925635bc6fb7e09c2aa519071dddf3ea16d8548e4d90108aed954526140ec721b9b8e6a69bcf6b24c578bcb73b1baa7213320feae9b0b436bcbe8c014af60fd047331e266b3366d8b174a6b9f1a8ebf0f8721b800321ae5399da3207854f74d7fdb1004182b6fedf51ba29f6607eae18fe37459abfedf82a94bd4c8a01b24315e48984110fef412fe75eb4740cb6fbd00c8a9e5bbf92a9c6217e2873e5fecd71b4ac44c2eb1d57d57823c9242d270f06809fb2a37bbf976b67fb3f31e8f67041b6c13626baa433f85d16f8eff54f893e479e2c17f23e50563efd21c2855f1dcabedb0b990e0a50a321864dbf0b01fbcbb20cd5c0e1a5e7d2883ef4996c30c7e43b52cd607ddd9e43f7c56ae0a07ac529516953381033591988f36a57f843198c9f780b877518a4603f324cd05bdc749c0d926ea0442edbd06d9188884e385ed515b9f2c98216e292c50973d2fd4da6761d8d54f2e5b3ad2db6aa1cc55d4afd827ce3c80f6941c7a216cebecc69dc1288d01cf870b84cd15e3d5e10339c3f26e9e419055a8dd02aa2b4c1b49e9f6d6c89e80f05ea06abc11bc556ee197976541fdb974ac3ce45f42850aaf48004871b2e623ca1aca94b53e8a610c90ee814640df3fb0fea902912197b72cfe28c66830e6f1a3adae4d524e781881316cb33d80f07b5709ed82d3a7394f52947b436b26a245673fffdbf6cfbd7e3930b537917bad91ae83f04fb45da128f63e0c2c2686a34f7874bcb1395aeaa72bd00d981132347c0f2c235349d1bb2bedbebe9d6e1f031a718efdf0b04c7f0ca693d369876ff913bf7d9ffec3778","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
