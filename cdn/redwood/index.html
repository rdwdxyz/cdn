<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60edbfb0c0f834459b1cc1364d01f709513fc966e14037157821581f7b2c22fa2e83868fe98c4130ee77acf2d9daea6cf9362480e8408a3be778313eba08bb5a20995c59129507ce8884b36f00075845c762b58ae6b9a13598c1f7255a79e34ac72e6b230636a893d8e91ba775afde82e302165d9b74f50e149f5e04b0b7383c35f71d0c53969f64cd181f0ca41106efafd3601fef17a564f0617b9baba0c9157ee0638db372684a73ddc9457b35878ff28db53d83ad61c632eb5fa9ce2199af521788a12be04d42581d16bf4a2f1c826e01e7c2dfe101a2a10617cfe6b1e32edf2b3925ecdfdc570ad9ac61f451498a368c0d8c352089ed5a845e610513d30ab87b7dcba572fb6510c6f6f45f89ed038dbf96277a928f786d8eaee699b2704229697768542f4f072c154f3b5435a0ac0a6edff93533ea2ad8f586070f7ad356dc99cd12401491ffc461d81ccf1742994165f59465cd9bddfc1ab4c091abe5be87968240852d99dab73e4440831e1339881b7569199dc22b985baf386e0e4c321379d30ca24f8267b2431b078d1bb285a1a5d7e7bdc1da351bb28991b5865822d72be5a3eb18daf76ad92764002010d0b20461de99bc8143c923b9e5a109900635317a789ebb56882d25535090e8512fc3dc5547bd3d21b1ca736ea1caf909a5541600a37ea2a6249c4cf4fce10fdc4f13c01e76e39a52f5bd45d4d385a22c209b7605cc4b8974e57da7abc9f7594e5f429cfc3d4af66fb0fbf29be692c66773d267e7683cd84c8787cad9cc0af9b20de3ae5af091714c151e3b335bf21bbe27882d06abd25a678ffdccbbc7d5d281bb510e93866596da8ea7481d31b811500c860c8f563f26de07692ffb3525d6fd85229de037d4760a30ad70f93c3c1a90d710a9b15d8891590cf8ee7c3ce4429aa4977ceaafd89a331bf9e4223d99e13f8bcda319da22b60ba2232effa85238b189f9d072e9e0072a5a305e6b52216c2da84bb5cbd89baa74794f92d423c1c3547d75042f4e4c672cbbb245db92224483f67ca7ad6f44ab4c79d79be250a34d98d024b13ff4defe3668d504048a7fafbaa849d81d02fac44c1e9da3525fe465f988877403476ef46ee96fc9f5844f171e475eb25ff3153ddf7361b37eba6f8413752936b9bb58dd57da630c23d8f9acf98354c1018d3cd9a0b909948cb7a48d54cf7ab9d15971da19045a5dc203b5c7bf5ee79fa5b4a291af4bee32a5a2e54f405b02a376fdba8f41996d6996f74849d402d4d025bb94652630dbaa307f034c21dd112343075d4640dc877194cf09979a77b91851a5eaaddee14785017927a531e5514d08bf97170b9e4c758a6da00774c51ec00307f63a625a22a4c256db8ef16b857a8471e22327683689973662cd433975ad12b4d9f58abb19532b1bf473968ac0c00d0a49b5c8eb205f28f57f22e725b7cf8440b5dc2913f4e68f70b0f2441725c1062b14a3bf5dfc0442338187134d1fbc084fd4141f5a82ee97e78bd987ea5ea37adc7c4852858fe7aa8a9c452a84449749f760e2c098b8c9704a3df6789697397aba1f3d3448f6cebf34a8b69ff0f182780d8b321c588bdb676aed7e64c4609d913e1425908bfa1c3cce767d54f04689a5e66f73a5dd8194e0cb9dc2e859f859046bc44032e10f173bdeda92d84b087d651e0ca3dd7549a38dfe3fe7798feed0900ea6aed854b4a0e47c12e3264278dfded5f2eebdc48beaaa6d17eff2a3023ce4e3e6ff6c16a013cfcc0decc67914345ce18078d1e8cf3886a71c76bcdadf5158e3a5a3b7621176f5e08e7798a21a578698d94e60a7276238606f816f9e84432908f69e66370dceedac768e7bb9a060507382a23a1bccf76b590df155519f9e0b65c6e20e773795593f0cb546c46903defd4bd9167d9aab1bc0ed07634b5aaaa02f71d357afc7710283b924019e6629f067c92b7c0eb016744455611c812d659ea0471ccec915ba53467fd7db8867f013d11cde88d366ba7450fc3d01c6c3f2cf9d7684e227b5a27eeee9ddc30310470e6bd9a9ce6af4512a98a39643a8d8cb093ad727a583884339dc16e1f9486b74e4873a12c3a0d0a1f0e8b0ebff4d972346ff31f7b540cd7e21ca5978568d17110b3d6746b54b52135cdbb11ae38d27e594a70e285fa3b72279011ba7827254bce9e058799818ef93ae5d90d6ab2c9d198de288caa9b7ea1c07e37789c38791dabc2e23e0a1fd0447d3c4ac09fe1f9008bb9f04b2ac2e57da6b474a09dc185c991bbd3b288d682a8c08f815401dd51e694cae9000d96780f3e42856d75e5b009304078763105f7bacbecbf87652ae5522ce28b29182602678b82991d9f4cf643db76436a5220ee896d7bc469b6fbb0e9f7fec5e3417c721623ff108da5fc2f3c581735ff4afcc0203da9c63b0457997f948565ac4d7b1f853241074a4db2962fa05a7944c967dfc4d49d6988b53ce78621692defe82a9f328f681de756606e7c8449168fd5211fd17bf8ec2c7feb6ce09fec7ec727af73257f613b26a7fd64c794a60ecea886cdb76b8308f901842e7eea530d7362eeabdce27c44dc831e8b733bdd996f81f6c366233d8648da5567a71df4185ae18f86157d485e3f3e173a2b2467bce321f30a0dd93198ffb9338d11cab18f89a8190031dce0e44db931a26db7182cf9633e5ee02f259cb733a8ac7a1f6e1f0d88590f843768effbbad0b93017b28c7ffe7f7db4ca2769eb970c31e30b2993e39b4edab293f8afdd8e2b4b1721f8cd86cece7c51744e81e9d7e6b2b42db2af5e0106ae7fad2c3be1d3b4ce48ca9dbe2355e46885e7207b18d5e93317c82dcbbd0517d0bb59478124cfc3c3624b69141deb464dd8be70fdb998526948a407e8c06d8b7e0b3bec3636a0422daff21dda4bbc9902a53622a001e97e0fcf324aa2a76e102e128753928a9c6d3b22001bb5e9dd31eae5d5c0cd9d7b9598bd3cf0ec7b8b291f5d5ec9c8112dd50428d8e447b0a395bd1249bf55379aaa8e3ba10f8ce1ddbe7e49557e882bd0fb6251ce7dc110fc94ce0eb299b1d95403dee16b155dde61506e2c71ee271912657117b033dc42ef2338345ffbd6434a27a6d523070d69ab1d6b32181c8fbb6dde974dcb99fc4922fecca4f6802add867f24389ef08cd7421da5e6b7536fd970ba72d86f7403ecddbb3442909fdde194541c830d18779248138818ee738ab2b60f381d50bd3d629b5f59bbeb5d17e4596e406ce4af2cc767d6a5b6478aa7ceffd82337b2f36a0870682ad3629a00a567fb1c62834236211766ddc4d5c076b0fc0da95d89e116002bffedfc4d1b6c362c40cecd2621c26e21d3c71b523d70b1b8b7d5f000fb96fa1b61dc454df61eb4fb2bf10c57ec3a0f12f5fa15e2cdbc9a24f6a3327c4a79a46e9dd33cd2c3f3b1f39f74ff8a8f77b58b9be2e3d1240f5276faf331a54f79d68cff179b92d759ed599bfd71afb90d6ad97dbc9bb080707b6da072c6f50ffddcf49ec3029701cd1603092cc5278a4ea2b2ccf884891a16ab980d17617a2d2feee522d9cdf3f2cc51187994f42721c2cf8d9383eaf76408378f87e08a39486f2c4d6e2288349596264340523494a7e834ea72e60a6236a3b9f2515e5fe01219c011cc694a92a1060d99963b1738807412d30901997d97970fd5e2cb7a79d2e4029830ac6d414f2c8b6b47927723ef56acc429910a33d123bf205d43d76992857086249f0b8e93b1ed12a53acc12c98dbdf17c2e4ab132bfcf5f7a3a29c133b3c6655430d21c6a2d0c2c1dc37898f257d4ac64e89b3271b311c22e50b8315aa7861aa314f2aa45292fb102b09eefa9f466376754c6fe4560c8e2c327d9fa245fad4b918d69f97bf694d133d3df5d14f32eb73894206326d890838bc0380a49659688e9953497ca46a6c6ba9d9139ba198ada6bd6b1713744031109777abab8d14a81c4f1f0f445a0aaae840196fb7da704f884a8abfb77de79cfe5b8735119761ccb6b7061ed1a1c88a7476e8dea677f8e1ece553bd81e81259c3f6560d0d1d59458cd02933b3efa5ddbcc19dbdc22a6d9c3cecfde5c0e1eedc33f63c8fc20370442ecdda0d81862d4b931b40c35d6434ecb1edc1097d933eade63203652a2a71ea5008989f7909734b35e03236c5964d6706c72e058455c3f181c947746b1f8b6bef203897c1189dd994f4e46f2db2514051469c0c5d5fee5aa0ab911107210855a78f6b4c353fd713b3ead1d2cb27b71898c99944838bcdb6ee85b4bac4b9209f65258ed05b489a7dac30d8d9778fe7f83e10ed086ee0445350d5275b4da7f8befebb14aebce023f919ce9d56e6afd1b67b9a93b6b99cf51c23fd3838e9c3528935adc2d51e5c31c110fd9f55e54066007a0a8b163b3a87c9162fe7c91a710bdf28cefbb86a157393cb9233288d881d99d3de4da8531ec6fc0f91f270f0e48cfd854e0a6208b45e6b5d81bdfd5a762d4d039c9239b67aaa035b16ac98d8594d8aa19d9892b501411e02187837c861c1b1e4e5d61b0ca84f640cdcea2ded5f16985ed626c5b43ebefb006435bcdf8f0cd55639a747c88cf7acdc7fc73835cade6bea9c77c56d218d289e1ca45d047ac687c43de03309be31e27ebb75753338b7751d12147871fe962e8160c2340e269da026b4a77df4213ced2e3a340d829acf3ff81aa5c6f0c45288b4fa63f6e0add6b715774021f0223bf263400f6ef1b3c32e0dc28388820de4b69d80c80a2f959f316d551e4392d10a5da2539ce2a5bde08ca8a7278f1453069f58714e644b01e19c5d4f50a3f393eb0eb036f3819972305010450770026c7d3034e250564356314bf93b6b6dccbbfbc75ade0b2269f847a90d828320b5699c554678f7fc9620b05c9ca961fcda2f6941e58c7852d61d8744146ce17f3837dc49ae8d719f53df8f56ed1c2a10009682fab40798cc36cf2b46c33fcb92c4cbe83d336b6a470af225fb6ebec75fb4ad5a9cc1671aaa4a26bf5bf9d7a6be670f847683fb48b4fea2bc18edb564be42e1eea98a0fb6989f136ded97d355755913a475ebef873e71f96b7daad489d934de259f54a69ee5d831130f13b43e98848a7d6251661ca0b6974da05c8c8aeabb0534ba7e1e1e49f9eccc9a1395b9eb363ae51eea53e78e8e6b3ffea07f6be29588850a9e875cce1e8153ce5736461684e1492505bf9f5f703473536e18263027424ca82ab24ee1bf411bb12ae05bdbc3039fb4aad18956cccbcd192d005535712d7cb84c5d7abb7119892cf8431e41999b81d2d1cdd542a7e9d5bc858982805632c1df73d76c77e92bd6c328a1ef63641d2d0cb69a945bf6e862d95fe862d88df265098ec0cb47b50bcdbc19c17e3576578953499a1ae208f6bacc3775ad14c518319ea0d95cf1975d111839b9f615466fe8c64238fdcc4ae52a5ea675438d0b2f6af6ed6791597bf8fc6dda05f9c408e5e919f73ae8f58f3904214e808c5a4e2af0ba0733da5bdd804ccfde842e6512836d9c9203edfb090b303ff7e67dcaad2f86923f77eb967b486accb92b3a0e496d1cc810f0a61e9fc898b6e348ea2c5c580a4b876cd851f2f4d30405b59201ed67f981b8a5ea5f6024e88c9f47262fc197a649f42227fb85be5e08a74b6490abd090500a8e135acd4afdb4618e0ad3172c74824dab3565354bf07cc3eac279d914221e9ef3fb7604031d944e49d3d8cff40ed81197c3b0013ef92ce8c429f98c975d8db3a89eb7263af866bf5a518f865a977699dfc69230276049c325e7cf60004edc4c89024d6b1c3839b481fc11ca171b48dbc2f8c8f050d024917b718f70a4ba643732b3f5f93d466ec055b0761ea90889968acbaa49f2c359290228318c6d93867800881737b7ec785f0c6cd6858d6d6bcf72dcd99b097d08132a2d2f5f211db57ceb6f303a1d142d4b83ddb4f7a917586811f943fe7941a7d407748d93d68b93c5c7d41d20ec194fdceafa997ef95c0e24a243ec399bcc701d7c1c6c2be6f2b254afb02d6e0e09c38283567ecdc6fa751ee66a575a34702acf3946810596fced3d8fb2a3353ab5f653602f89f1a028d52e58934fe3f7a302fa8374c46667512e62045e5057d7c3dcc6d41ec6a2e001a370c1fa0405ba8a6eaf4a749c840f7f9917555f749bcc982dc1c9ad2ca8d4f459748805521cada07e23e14f5909d34c3c3a6588cabb25da936143cb6eb947b677c98ea17e2fe13b824c2a8c8aefadfde3bdd30d03856c6e4b37e8c3d85fb6704990a361ec35d4ec8d9d44c5445aab0a7888a9cddc428b8c7da99e7fcb5e4809f47dc98850c784d3e5f9e512559743ce7d3d659ed9d31c89207bfc4ace2187449155026833cc4c32d1e2779dbd45489f4b5904c89ef15c50c3fcd74e070c5d233761ccc5430ecd4e8f0f29d0c4123b9a54a25845404394215760d38b3b4b5205b7c4cbae98fc0d9091f6fd47a6542cab9788a0b1e048fb1b95cc300a32bfd9c13908229c8ed78725b04cc15c387ee9397116425d1a3ddb540c05204898f41481d3436a2b3115981b2feef8ff36f47a765231afdd115be8ae805a7f4fe07388716b5988463cbd7c3d1ba04dcd3c801e05b336e97ad0bd80c8ff78d6e0b19f60aa444610494acf8d7b213344213a60a8d8610e5dc8fd8336480af10ce7f0bc05cb3ffceade199e5ff5f8f121647bb695425194b2ebf0c7069fa9de7b380b1287204dcbe0ebf435afad42bb1cc57a64e78c75cf255f55e2fb7d036d070de1ef02a70c9a62ce77ca36f5d59606fde77aa1ed129ab8e7f662ab0d4f86f93adc90ed86f890915eb7c339a226eb14dd2482f0fbae2c1347fe192a8d3dd7b932787eeefb7e8ad189f4727faf2a844ae1fe31208072574a16ca0f8a1451bfb489cb6383faf9a5b2978f10bac963aa008986c9956dd24787cf496227de6e5e6a7f1f495a15afeda61fccec66c567d75ce65e2ab5cc8f94ec3a42853df604eb6d2586eb2bf4a810ab4d1dabc047ab2d0643a0e39f151f14bdc3c1e4e31aaf3b972643b289ad9d800814e3390c417615abb061b831733786cd30ac91c7c9a887d9990e300d0604f14edc755f572af9e370f69688cf25e2dfb8eed2472c988cd24de2c43567e86128caf1509a3611b68a00b6f27f5e7f9e7fbab8230772454e734060cc4ec2f8d2d661a92ca50d73387a32bf5739bbf54e6a7df2264718dd78a54d9d387f7cc9b3c654cb006af953940b7fd99b045d9b7ba86d0e8fd12a528ba2134e883bd6edae94810bda7313a3678083e380eaf48ee039ea18f5248497073945632b37c94bf67e6af43af5c2a17bbe6a9bd4063e0e5ec4183b694c98ab14a44bc827eb332375db5c1cbfacc6f4416f0567dea534b71af00543ccb173ed923561476a9c654a55ba98ed82076341e9e6dd85132f23b7a85fc4d97aed4738340fb562ad2c8fc92209479b18ea2225c5a94f3cd98eba5b69314594fb26e7b95e96c5f50ee1466bbc65c2531441ff389b5845712c2ebb052babc1ec42f4f323fd4f9922d1a9d39f2f550cfa15b221c5186df030aebd0a190eac2232328c8adf045fd73e4301bb157561ac40484ffa647ea580f4886335eb52e43e03afce78aea9bcdde85cc1e4c9150586749c4e283fff7e979d5fca55e3307ac85ea995dc12c315cbb59d07bf83c46673df265587f9f72801e72cdaee3376fa1e880e761249e3fb7883d58b19fd4090a3137e9ba00fb09adbb16f99c2735a71f375f7fe5059820eaedc303e2cc267a334648490f29baad76b963dc81ede7d15181b6c2eb165f0a4cfbe166e7dfbca40270375e79c50e3b2f93c424a13d7e26035bb59858309baf4d4d4c0f6eda252c36889ea404d70a71dc60f2a8b2b8c077482d44956f97f3df0a6310c84334f5e2eacb7b0d4e90653abf6e499f9a3d388540be5d3cf914ab2d568b9c39b1a4e0ab1fe6b725f7deaa4c511d41477719a44b7d2ddd583015a1d059eb5e7e6a93e679f58257ea80ad0baa97c2bf7e964e78580646c1b23bd21a0abf73a9d2789be29a74f2f9732c70fe6121fca12344287e008d42f31e1b0d9cbb2277e978df95ee058c3a90e4894533a6e320fa8d436ac84c8b4e9fb5f5eaeced6fac66968b27a90d6f20d72a8918e41e162e233e4fdbe1b5b3320378b903884a237b8f2c424b27af54638b556e582362bb52fb689126ab230a2072b74fcf72a408d3e4e63a817e795858377a3c458e883df2258943234e9d158a4aa1d56eb18b585cc45df2f9aa0351e4d9907f9fab94585696cce95efc932cfeebc9fb9c2ab0359548506ce1e13ab1d13020404424a203d0344f0ed16ccecafc4e1498114f41ee6b127e48311afbfb6506066a7f2dbd0b3b12ff01dc9edb96c50342cb4a879fd348cc159b5532905b13fb68e32d990b65fb7a9d11687a89d8e0e3f288f74c079bc1a42b112390bc2824d1c7368f8414dd1b41b6a640fbc14e3b8bbf4344ecf28dd4ccd853d3b76d7118e466d0ec0f84830937defd1edba8f3ec3e2bd5a2ee80d997caaa03783ee5c05dc2f5278802ffdbf25750a40a951178f4715ae352ec4de3f444d7f7d7d0c24add7ea12bb6ddc12eb5f29b24c8500d11067a5a216bbfd035003366d84601e41659394101c782e72cd851f27ee1b5d8ff51d144380c8b4870f5cbd2ed7f000cf1638bd5b1e67e221879991d3e9902bcb24339496c857e28919ec07119dd46f31df9dc31858cd76b4407a3596e290a0f1b3c6b2a2ddf0e8796081d63415bb9d6df0f5235bcbe24a750ce2056966a6539cc6f3c3f264a1f41991eb3c0e580d2d69416c4cc6a0d74e4ae5149c2ee4684f0d7309ecd232a5d9d3706c42a0c599eafbb19d2f968b6e83a113baf283d68ddcd2d8b0e379c96b732b0df525152c5ecdc784879a11ae3e9ece3af641f39f27896d4abf42610020fad91a23065dae5df5f824f48ad0c1b1f19e76803d4e7926dc930721b53ddaa57639199e1e55ce6261f2568e6dcb3595e7ef83ae4dc5a029a854fc654460d4dce5d3c0240dce6b86525fbd31afacbc2103d5e4e2cf13749f672625d4791a653a7bdae9e626d0c00db2de032868f3fbbd29916194828e81a46784da4f8e96fd9812422d08b3350517d9dd8a35605575c11805e189a973d46b59c63a2efdd4710b1c9fda81d887b92d3c3c5b98126a05feb7e511d2c0bcf0ef5e245dc22051ef3b68773464cfd8e287071582b5628aafe35024d838c0f52d2fdab41c0f0896afe8fdb21179b58c8d6c00d10fe1f29e4433addc79243f614d9893b219ec10a1a689eb38375874825b19ca2be206802a2b95599ae34ab3018e4663a41483c7d6bbd59d874ca44c7929dc058f62144810aadad9986524d44dcb3232b3e93802932fd0ddb0b56bb669d061463049696e37d30ddad64fbb0af8f070ba8129c956021ebc0ada8849e69f59a16eee077fb943c8faf4f5569fb33e41e36bd6830baf0371772a33cc8aee15312ed48196caf004073a685d5190f7191cbc250464f2ccaaea2935e48c74ed88e6cf76e01eaff41897707ce6ca2498c6f5676fec9799173ebfc03cbe6baea10d35d94ba21bad83ca36f7ec4e6b23b7db9f5ebb56782686ca5a169ac9bfec6eee327d4540e62315cf61050fa87192f6a4bec93563fd46b3b608f1ef367d23bb1c3a7bd41694ef6d4252096e801187eeaf03b38d818fd59fe6af7b7da5116f8a20da6b86716d2d4d75a6158e7968f016af1139c4e1c20ffab1c223b5506919a609fda3d5aa714757717ad7acf6f73cf2ef44d043b2d638d76fb1d21c2895f7531713c8e427ddfbae8e7f337253b01114f1ca48977b69d0dbab2d04e59e464d2aa5119b7d15a259203c659953247446919b1a0f76ce4edba3bde197153fe848afaa437020befd42f69f81c5c930b56112e42f4ab9088fe3b3e57b057a86d053abe645f2fee0e2b07239015912c8514ca1123be934a5e9c0d32553c6b7cd27a41c7bebf44d61cf0eb60b172af9d4c72851ba7cadcc1b757461df1a5da17d41d8b38cd8f1a8e9c8a27f8ee1d827bb363c9926f48e1bbc39b674dbd984509466392b696b9ca35305c187e3237ec479a0af40da06459a6ed639952e76b0927d3f82b70d60d23b43c473f57b4373d60a018b0e3442cd8e4fdbe6dd6765dd6c91a85eaa994f0588f56ab83dd5a63ec9625c58cb8125e556b185fb6d349766342885727c3e53d7e038f453ee7d073c7f4826961dc8de0886336f3a86e359ce761a4dc44e958536c598275c737fe9332dbc3a81ed790a694133758597268d164a5ca1e9ed777e966246bfa70ce56ca018a80c2c7d57715bc7fad47cd7734cbd1b5e28f1e1a3fa299b8f90a18eb26c39d27c3ee21bf5b32e21fba72370fd92f07abd2f4c4a3163f5b79f478f80f388c483511b74acb30a61fc0c9df2d004bb0b8c14b87f133c9303463796be28d4c72e4ccd4148d71f7d5eed74ee3d14a312ffcbf44a0b2499baf027049dd46362ebace15da73a3b3d747050bde5d0def92e2e3df1ec5bd0e4c655d80128b9bb727b0cc5cb6224b925367c068b6b28894963114f303e613311dade02a6a77394a68bb60cb64cbd45220dee95a30c01fde8ad28ed7766edb55c392cff99d9c73c750b055093dbc1858fadeca4a101734449c5ba630d1da9f205f20f68ee4ae6f7be1f7cb72460ec4472ac4f7f007b3854525d6e490e5b61b23127d9a8ad3f56da76dfaedcde149f850fbbdb2a1a8913b200024b338a5ef981385ac5ae319eab7a6f56bfdab4bcfb13bdda3053e8d8e9231eb8c8dbab244d90d0eda65263dc3fa39514db80eb3995fc41a41eb92617d0f5cd21cdc7914e200b2a6c1e1acf5add5cff790ae74c8067419a29d10843a0deadc436865c8c5aef43025897b4157c0da79ad24e7e1bc7c7d105d96330281ec05c29d6b2b8fc00d4e58778e6c4825dd682e072191eb17232eded538d4a68af3fb38d555dcea17ef3e3029af0e7a5922a87a444ddad7f0c47ea4e07910fc39fa2f9ca237b115da74062133720cc4ab31c3cf9d8c99680235210021f8a70f4797a9b073a81c327b5c747bb4b69a10ba213c2c3e4e80a81adc368a458d3f9857b1575bf8bdb74e523c9ac64cc4dbf5d65aa97af8b0e7bb57bff028478689de3045bcdaf631245fdc946ec2470927d91f99f1c2146bb53d0c361370d667061597c00c4de14fd1874b885327dd2bf5976d09a90025c3332f229c84684316ba09f2b7b2f469ec12b73adf408b3eeb86000766d65d21d4abf540c3613436ec73a50916b7f5e5dc28f276e898bf8a2f0546b0822c5a860d57d3b1d4ea003b784865412d54e3750d314340ac0957e54f7077d40c27667c0e54dc5561f55f2889bcd9cd6a12c7b9def369c144f8a12dde2466aa015efd5f42188446e644ed2dc4eb9b66843d9afb8c41b658a8a514ad8816070fc245819af19bbba177c2ce581c45552359b397e7a4a9c34ac9b6d7c4bb836be8c4cad34c1db3911ee14af42c976ff497d98dddc943ecc2eed7acfabad16f24bdd1c9aeb9dc9ee26767f0c94a9744add28b59659b666e2ebc098086f5a2f911ea446c67d6e8d54b2bf6d33fc32b3bb064c94a3d5bbb24eaa76305fcedde44471598a344129b4eeb0ca9658ac25f98d3a3f825db7c4fb0024c19c064aead091a4d5559d0d3cdf74a55a63cc6b92194eac549f67ee23be44479e25a653ec14464ccd6e7db2d051ebe23a1cc371db70b35f2b3b04de2945f9bce4d09732c1d84687a2adc0688cbb1d7f1c0614926223f5225982a07ffd66cba8db8d80250209cc1a2a9dfb7163f8ed82885008a46e00c5a15cd2d4e9bbc823c7bfae2bd0d90e06464806af753cb83c79a43753834ce394cf3830ef26864badca05443d29de306013230acd22cc3cf0e26e270912386959b36a05d741e263a877d7aa4706b0b57420e0791a87af6c41dc134aa230c8c584dfd74400a39d36651652feb98612d8b23e855709f48931c18ec7716f55d184f001575bbfb64e218a71a2a0b34df001e060ecf6c93275d0f7f282b87f18db5e69ee647a83cd8e6cf366017c6547ac73742d169444cba2e39a856cd4a851830c8d98b3642c9e3f8350ca4aa137f35fcd2523a4784a4c6dd0b2d4ee5f8638912e52a53694535fd388f580172e7ca780aa1a0163dca55e98a8391cbfd5652b31d3d795ccdf42af73368bfa40e785428581c148e1ba5476dbc0dd6f3ed05926efffba015357a1218c460ab589099462c8184853cf80903abc948d0a4819518e64f90de180f31dab8b71c5bb6044b2e757142a3ccc5132abfdda45f166b2ed6f65d6bd46cbd0a975627efb6bfc8047058988ead162d083f5d67568706c0537c0d1e275b5f9222eb53aee6f53e83fe4ab6cbcab5774f567102846530e44d0e1995b3205a9892613e3bb1d06f7afa671015e4cc1dea6b8d29c24728f1ab9e99abbf0d9b666594752a61c8e79c93527bf46ac77e8fb931369cdff4ad9271f54821c3b454a6253839a77421e4b91a453f888499678ce4a5c67ec100b53433110269959a74729d34b5c53eeb13a4d46997c2f25848e6c9532cd8bf68a8cd870a91330b12c2346d5ced9094623ee8bf43c5d87e4273f5877c5729decf0464cc0bcd19d7a29fcd1fb8f8d9317dfcedf67107622a06991e6793bacd66299cef813fbb89c4805f6c0f72befa830f73c0c5f2eac84cba66cbff3c078c379df4f27805107690c4e650b94ee941638f6a4a12efcfafea0d400f87b944c97f587b595b1a46ecc8dd7dd0fb7542c13f7b37614dc100e871019f2b55c03822b1775759dd352021f3fd9925201d073b39fd5663497cc756653513f18d2ea30d614ddfcf1c7b061453dd07b511416d973ead7929d1b548a9ca1384e2a989a84be837fe68a8ae99acca8bfdd6721aa2d3a3e07477630c9db9a56e772600347372612186aea2d7d4b7d4e7982edef59bdebba4b9205c716131641d7fc9cdffb7061ac1acc9df596bbe59df33460d4283ef68ff291cf18b473897dce31a0e2b9c87a5284587dc303c4fa010232af43dfceb177abe55df6ea85f0f36b32574145be0e533af1c3c801dc5389516477b017fc3d2c2d9f510d448df24e1cc6b92e6bb0a49beca8dd513d3052d7e186580062518151db91690a0f569af8dd25d857bd990e7f0e3443352343a55f9ecf2bf7428cbd9c64a31791d2ae8b19b2d41ce498fe5deb5b9b4cf22214c5e009e609dd016ba0c024bf1624aa85ff8aadcfc71c0c09595f6302706bdaaea787a9d0652cc15b8f4bf7dd99897d961ff3ac11a9f29831dcd0d47e0b7433bc3577125a20097c249e1f5db61a69e7f487fbf58bebd36b53b20b7b1ff90597d784b2ec77edd9d9dc1595ba0a3a5becb0dbbca023d61c20c5aea7e162797158a5de3d2c970b8c947d930b547ca827a9578751b9d73c1111c95a40c5f6968760921b4a488670d48f8f718a3335c418ea250fc4bf786a81c2428224b9e0f12871f9b8bbc20405e14b35ee45c809111b1a28a7d10fbe9dc90a8c844dd3fa687090ccfdd0ade8b49a660fd43ebf4c041d55c2361fb3f49d05c2f6997fdd26ec209ad97fb3cd68dd4cd4a33916fe9a7f971270a4241b4e2f552dc4ac1a9e8bcca827a553969f66d738fe2eddbb015bf3fd7326921cd6cadc97bb0df128e4555d713f5f48fcf500805ff997fc4a6d3283db335e49677026afabc6ba410b68fc88520dcb0ec95773423b9307119de04d3dc347e71dad0a9bd788650696230a30b6cfec235402c4cfb2ed9116babda0658b3a1ab4d0c5769cb2221215cc3490ada9521dfb88e0dd08fefc5b98936b6e0f72011b4ed902d2a567e0dc9c7c4b2a6ed614855f5b16a28311ea660b850d9df4b8645c08206ee3a17dee359ab77fc4675d89578db0573869c4e0ec58cc6dae185433bdadfc8d5359998bafec4ca739ca8edf638e8079f869cea8c17d07c855b71bad7260279115e1c5c1b8f70c14f1b913bd2aefe0c5714b9455b4b29c6fcb2145cdee357e5aa7a8ee89600c0a6c70f92e690c51c5ac11774fb088f6f6d6f7a1528797bf251c0cce0463957325dedf772407735a79c48d7850b64a17b6283ec23b19a919eb2b4484f91e7d1c5ff6ae6493a1f8dc52dc06611700c6e5c85bdd9db2d0a3cd52e945a41cd5ccbae224fe2c7216b0e7c1a60c9bc7cfe69b606e866ffd3404e422d27561930e2419bcfdf2b131979bd4ff929a2899f0a6ff208ada3de2d063ddc4b7c339d2352138e26ad159a646d2e4f84a68a2ea2c6f909ebb885df97c7b629eb4eb70ab5cb0477a632d584f8b35c4fbb452543351d8d1deb6c12ac1a4634a562607be7e574270f8db45be18e7ec5b8fb04434263784782b6ec8c76bb19632e877574de19e839aad2fb5cabf35ae898970a76b0c6a2dcd38215455ddfdf30d632c5d17bbfb7642d8c08019bac87ffe6b322ca3fb1c65a5ffbca6a0b01b49a0862424801de1135b436bd054f72db89c6249cba9b020a58b5c2e43fb3ddcf720da8d11a490e2f234c551fb254b8ee4fe4ac1111514093846fa01ff5d3bbdab302e41c23b7bc10785bf9f9382436b40cc9f00cbaf4e6c619ea8c36a3eec1a0c9c77186e7197c898be4dcb5eb93dece240d7e376205997bc5d35d9f0b1a75683b067fe79d9f06ffe3256f14874bcb5ddeeb8f7bffec013d8b27508ac45835bb5b12a96891a9c04fafba2fe157b6edb406769d35817bba65c85753a60ae14047510ab297615d78db7814fd9d329d844f940991a02fb6538b52682220d6369affd04427aa7a115cf3fe469e8e1e134408553ff10accb91165f51e8b9776172cbbdf9451bc97e1f6bf79882d855e3ad613cfca8501ff6418ad23dd711423a2d048ca4ed124c4bc8225b314c3cf9eb89c86e2813fb5e6f4b112e425e1fac711db6a7538fdc0874651e3f61321cf4b1a2f609fad9ec0a38edd037b68a0b60066a96ccf672a9b7cbd93b7366b032eb2a069c8e4da7161f35b488ad39e8a343d69783b6360673763baa5e9a0df7ece6a905c53817b61feb7175629454bdeaa2d6347fb7cbc83a09d42bc1b53e8b161f86f10ef6d770587437d6995b4301626ca13f89b611926e6165e93e4bf4d527d7599799007a5f86baba7b1c1015bd9bdb9b5e9ac2fab89391f243784cf72b2a931f87f9a39c248e4c4dbf7cffe7937f146618e5acc033a39a3560fcde7fb4d17a2ccd19f2976f269255fda131efcbdcc84bdadba0a249b5224b85d209533eb150bbc9bedba08b41cd1b41f50dc8cbb828f5bfebf191139f66a49df4f3c9f7d6c1d3043e1ebed59b02daac337ead59a3e4460a7e9e4ba69179df6fc09478d0510ffcf4c9608ea4bb9566a8287c1f11c5fb71acc93d655d4812d83f228797807cc31a40c953e7f3d9d4884beb048ed17e758bb3329d15ce0a50acdf5aead4802985b7f1b3ca0de8df21617b99bbcf85e4dd69da1ef552bc2ed8df4ce816d24c487d0f35d71e14b215bf84d181d21054a984a71e5682671d4b73bbae885329ac3ab87ac799a5bd8caf69430ab52d575736a7b26d62155816c3e736af002a2627476f27e121f65de3c52d093d176ffd748cc7ab0e169a57eb30dfa4bcdda6caa386c54bb6956464ef15974caa952ef50ab4a0bdbcdd230f213498aa27c1bdbbeb3831c92b72cfd65b0edbf7e20d22ec9266a1b57dd3b926591c2af7abd6a300ab004db8bb2d1202c52bf5570f6e7616a1a21f712e0f6aa3e9eb7bb78bf44b0ea90209665415f97d7e0a56285e41da64abc0bc536b6638c3f598c9b55ec9c4dafca92e4e85be8629ded0ef93fc15bb5f74de6200d4f3a75e68309811dc598c42ccef45628ce8600aa05ae349b829e90e36c93693f9ecffe64a6cafd638c5827daa7f5d3a540b914631409f29d77855353d656ab71a83afa31a393149a4d92faf7598ed94d7919b63c26d58c82842fd301b2b18a1e1c94a73d8cbdecd988fe5e0ee8d9cad82e4c9f3ebc5e647505f74f6bba949efaf81b961ae9743c1c37582579c1b2d723790b10e4f4a6dc0b55f82a142971ddb9a37348a0d86c6d8eeabe670051371828820a4e5cc9d3cb9bf880d34d6dd15a2ab1fefd1595137bf0cd07bcd951d22f1769c155042d011c17fe9df4f5c6aedb24500515bd459696cc62525cdf3983b37d2bd602466c90fe8273619d806a1c869ee30ea772b18420fe616ed3241a9cde23d45b80daed4ddd2417fdb3de811c8af2dd6ecd37cebfa3c1ed36bbf96ecb0719f124d82e13a4aa875d08f92bf12e6fe20178b8b04afccc06adb793d731804c6db37e5dc605ff04c1a4af080d53d1ba12935d42de5b7233ca12d386a80989cdc6dd085aa419f59575b72904480d4fcf445f5f1b133ec6f2d3762470c539dcbba8e4cb131d24857a27f8be7d6b12e601434514ea2f42a9ce39dfd46c7567113e1a6506ebe6fccc87a6fffa0ef1f21a991c4ae9cfc0c64034b4e506f869caa6dbb12796f95b405a11062fcd89a406a418795665c57da66dcf0e016d5170fe30a6b1f4e48e46e6aa2caf873bab676b1f16bc4f335b75eaea1e0c76c71aedb7ffb4067e2903855fa72b04c4bbe62fc52a6fc5568e2ea577fd6130f0fcf722f55a914bb5f2460b9d723a6e88f1fe89f616e75046e777b1b84ab5bc400dde149dfd5270d51df0b2d84825c2f65cca6d16267deaa855677ccee7ec3a957488eb7a21a40fdcc0e9d2b5a541b5f3d9cc96f3bf2ade844a719e2e618ad44c6c205a77f98890af656fd636d5c05bc84ac59a8b99896ce2b3ec532a4d47c56d4dac04e06e7fbc0d36d74963e623d3796dcf5ac2c4aaa14cf641be18fb3ffb2901ecc6d203dcda055d987989731f0a2441c232f50cd9fea0559006b898cdcdd3a9aba6f76c4776385abeeb2e076e02431a05c5167f277105c0e7c3e8f0faf9cb06241e3bf153067cf44ee9eb448fcd1d1e96d932cb4e9ee746fc7be648869d981b0f4f321c655e1c0006174bd11c2d797c7cf566ba4d7e1ca545aca2a3b00fefd12d021a0369cf0fb94df8ea1ac92ee440b82730c274a78074f02d35d8656a93c525ba0460d51a0d474255c2b72f37fdb1a57b8e4c5f30509ec48614beb814fca472e0df2137ca855ed014c3310f4ed00a10a634610b8e55eef06ff22798ffce38206c747ad6897087b9a4a71a53f64c20ea906b29425f27727aad3771850dfd074fa7b4eac24ae075d6f2395fae7f676d4c321a61af887a611ba174d9d923b86acc2350a899bbd8a5d2fae049f3d155d6c0c588de12b1af85255d0090471ccf76962df65ff2e599b287607da5b84ae2c3e69127124c592be83d25f6d1efb8eebf624b82c6ca507f7e05b4340b0e4ad539301f83dc0fa6f6a01a23edbf6ed1871080d75035ecee85d9ed64be03c0f6c452d6adf51d19ce033c4abd2eeefdddb30d0f1b541bf58293ca13c1af67a5fea7288becf0752d4b0bd2480644c52c14b7948bcce84b096fc7d04d48cb694e9ed164b39125aa9a40368fdfbc93e9408b46b88d836e63b211cfb901c4bf0aa740af78f85120d72148b78614942815244dbe82583f21099418f3a074b0ba95bc31d4bdd80a95aba2b7fed13446a7459a8614ee07a98126ddbcdff0cb45380cf03707614622e0b9ccbfb81d2d86d56fa298d643b6d05a152c0a2d4aff70e5d0081f2b9c58d74995b67381214857dfbf372629e747c792a129a9f7d4a204f58491638cb833413b5e4990c0a35132283976d2f48a8a7c2403b05b863c0f53d42ac1fbf0787b2ae673fb54f16ab01a27890007bfed674b0c7fbab0cf6f5be0038f5dc7b0feeaa0d39cb5936e408f41b292fa4ce97657165a8eb0c1244c1ad9ed8d4436148a515e18a0e7783f6088339e5ff8352934d46d0f692a6a02ea5c5c1ee9e7c1d7e74d0e1be1fd33c5404a723c5d08632b20c19c256bec33b924e74d56afc7a2e1b839d80f5c20d6483f89ca10ff88af10b2ff83dd09aaf825b95261c7ea3dd44d876402e60daeee57911046397c8b7efee5f2d4fe035ccd27d82a644d6cacdffc1fdb3a23f4620f12fc2bc12f7a74f2018","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
