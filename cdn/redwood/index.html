<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4211127083f09420520c1c4ab8eb12802dac5457b5c107ec5d38b7aa56d6f7d102ebd33a1b42f6b90aea49fb2ca51f276d67c92e5fbac0c4ae4b9619ed394529c03c925053bd6772b74006ea350af83f4ee1dc955b388ceed5ce2c96a0eeebad45a03839b69c5444cc3768b10351d408371d5ae49265367cf9df551f21eee8ce85803ef6f4c26acc5d6addedad38678b2d54214e7e7f3394e92c59615136e12b2aaafaa7cec5ba412ea9fafe0d9f6567b098e0375b67ee50a6147d5b5a5fba7b16590983f5880b5e61d98c125d5d1e0ee02e498285aba5d172158de93cf64ad8fdec2fef37737425b3b67c6c7125548f0c82d183763cd2036bf1e5d0399797afc8de07fccedd1a64eb978ee15cc217cb35e0c425c7b4853b7e6ceb0bad3c279e6f94533d4467082139ad3b8d8ee22635eb34ed7dce73d2135e740c1dd319fb2a4e48684d80c924ef22da43716898c23cb827db17eb5b281eb87c7e3fbe8e7532acc36a475e2e8d81ae4d78a4279b3332affc8657937c8edb800525a5030a700a6185c3336a39c425b8495c146a2994f8eb79878b3318ccbe03faf41e3f8ef83370481012751f2872ff9f800cfc36e4d1ffd06b9e8318e978cfd06b63774f1e5addd5b9deb4eb43d13cdd4720ff672e6432a377b00ec24b21195f1766660bd4683ab29f484e88c84b85bd88d2ceeca923a68d59060ee55dca23d18ac2934e857ddcf45493aa42da92b766d1db057672636334562a441dffe14e5af8f4e947591360b1d2d54063c374634f4fdb86b45b94069d178f2ade4aa575a43753adb89ba92e00dea5d0533ea64a30dad09ef825003f427dfb413d6022700484790f19ead7af0bdf71523ca1d7e4fb6712154f802b21440f72b8ccc26757a6cf6bdce561ea5b23af0512dd29b6aba00ba0f9d54535d41f75752da5189e5ce1115700a111dee0ebcaa665710352e4be540df989fa4b722243e37e383129a7d2247ac46b5c43c32494ddd16547d800296c5218ffa8ac80987ab238b2e6465a547e8ea63b7e40a63327f6d1560f86df7e7045c71b2701837e6f7258370dc18d70aac7c87e418701380cf8d2ec73125718d3190b66933d2557248fd3bc00f3ec0d257523545a500a8569017bb82b85cc834d8516aedc9141096f6d0ce8848ebc914d9c33ca5f60b5236b637050eb6d5a212cbc8b7ad325c2cf3660159b143594b75edadcfe2a189ae48c3065aa4d6e15faa83b231d7234a937864c7913e66cd07fe50907283e3c06432093599e81a91bc878bfe9942b6401dce34879a0f62839f927be5a4daed618e1f1094639a1b68f6d9d7f2e908e04d6d5b9e3332197c32a2e88600b9524d16df5790c0e99eba39bf748383df66d0a2c46ea11a86d19ec99977a7eb273144819da8015799ca078cb7f4991f6c990aec99ae9c5d78849c87c812b2f15220a39224d17145e1516fda4dce8136f1b1d0f57380cd31fbe2495bb294b9289ee11c12fe910645ea0adda6bf81ed8388e9f5df185a9a6518faac195408c35d8ce848dc08e7667d9dc2f58097153a5b765fb0697328633bd40cfb869a9ecad656b4a596951c1e1a3953e793dfe1c5616e34c759233792610d59c4b6f6c8ac568aefb4daceaac94e259029153605a64da9d1837c954c8de36fb1e9750f0f56e5cb6bce0ba5b609688b927f0a0665a79074005e280252f8032e823761bab9617850366ca91ed184ea711474325bd847e84dfe36a91272eea3042baecf5e8715a43949f391e7ab4828bdb7f2c5d6c5974a31d4c7398d3a2d227d557714cf2d0d4226cfabedc0bea413d43bae54a97eda67c5b80a5e2b188575b48484f039f43ee6d9b2218bc02a5de089efd6505ad4cf0d75c61ac2472be24934d801ecda307c3d9ee35a7ca70ba9dc768f718d89c7550ced762efc9fd752c4553a8735cd816b056c15cee12b7e1908af8617f32642bade467661cb700590d5639fc4fb7e8cf73cae2193ce3ac211f59ac7e0b936a8eb31c32d737a7261aa76ddbbcf1171ce17f521d022d32da0a5db4949538c820ce67334afe0b2ca47dd97fe97a625953c73492c6d13336c2fac0fd9e8c9fe30d8a52dd7b151852e40fdaec1ba62e989cde9bbee5bf71eb5a219813da9a4fd53d63fddae5c72ade6fae2ab4c4cb4906b60499671a78bff3b30416cdda55cd0eb5e2e5a7155b4345c421da78c9385b0a67b8007d9ac859d7750faa198954aa51ec4fd118c004a334259d7de5d0c9bb7f38af2a57f3bccdc0cf467d37ee3c1f0a1609e8cb8d489050e2355a4d9028a47a0de06663ca249c9c4c1fbcdc38e2812f3c8fbe76a7258bea5494284b318d4f2e24f6247101f07f38caf81ff5af37b84ff147efcc2e56cc91d9dd26b9bc25ea85efc97d053aac351854a654c492b2361f7ce750eb878c9d70790707d8a5c7ceed468287012cbe92eb2bcc8453c1c8599f3060f576c6ba8981772f5457782b81060508011536ad972204e6f8c9d86f0d79b0abd4bd8dcb17b2ae581771f39e910698afb3711e9b8ec6df7f66953309edaba5eabb11027ad2da262dd96eaf6c2eb5015bc40d6fab30b7badbf174878b6b80628c383eb450c74211d9f29ca9f2c1960b23b87557bf373331b35700de4108611afe347b74fdfa4b38b58afef6ae995143daf386fcda3aa1fa53d3425b5d8313acd92fb75937f84d71fbb31fb27fefe392e573657910a09a569880ff4667755bcaeaa11ea050cb38eafc2638f92fffa11e40c0c92d48aa0204f1ad66459d969e1b53a0a1f3b6da8f3a4f2897ccfe858f7a8b0819b8a7557fab1a8eb5775115d84f74d74786c0c783af82d531c90ba59d3659776116ffb7be3f8de94f8f9fb630f62ae29b0fb38be19afb2047b014b2cdd1053d1619520c021423b96a64a89879658cc109d43aaf94cb84a52784ca6a3b31bb0a2673f35fb50da3f3026ab953604059299e2ae8bf90cf9660698654cef2e2bea9097d71b9985acd7bc1cce7aef00f15fc7b23461a4f014f3f48139a8d322ffd615af1a8549833e5ca889c7298ecd44518eedff46d074d42d23039c0aef0b26437e4e5c5f880c7b8efa23bba992b45cc7d6bf8192fa33dc9cf0e3f0cec8bd75f9e270d38965914fa31687259e196eaed9c58e02da7ac347fb7ed9c502c92a95ad69bf6eb366b51493ab8010ff20a7a34bd396dbb7cad70ebcd4199e68a584419700b87f58cef42244f8542fe09500d769b88c55e728a0ee1d023ab48fa330033f5ccf6e4fd9a05e0c8abd8e7b8b6fb83ad6b4415450fc06b5d4d306b9c8b1a43a99d2316a22b53a26a6030cbb28f64e0ff841e52fe414477a3f6205b200c11736889836b977c9141f70e880bdaa00578d68b10488b5fd218dab0398a71855e1b1ebd5a1e4db6ef9aae31aaccaa994a487c0f56287d8649c19603b507837f108c2eeb80fc5ec15bd206db73ba4b4f086b7510e14c497006f73481c7388e6c26bc12d7a84bf8cf576df7bfe887f0d2ac6807549cc47fd857a1f81b1f0d50a28530922d4ee3d5ff319dfa2a7986e65d66e1ec9b561fcee01cfa09ccd6fe4fa3c64003914c67fb089be93e095cd8c3df83d8205fd3142444ce5da735e811004e461a9c2f7ff004a10e2852ee38219d876825a1823e55624a1ca0e41e3258391392557be7dd9f3ad492eecfcfec123bebb1d0a2ff5dcc47db590abeb37827e9adf33b1ca1c3d404ecb8f0f08fc1c064ec3eb818427469233fe7015aae1d1d36a08678fe2f2f745a60174b6e24c4569963f56d0c76292a49f189fd8f09a1fa8e54303dac6d6049c3fdc65fa66cf14ccb3394a8f6f68aefa40a0a03a6055b156c55f4f45ae391dd08b95b7a421a74d4c80dd2fa89bb461e10daf64b903b696c123e644937e325be7a6943316ce38fc365f8eff984dd94793dd0ce228f9810676109677b5f67ce0ddb90120e3fe07a7535b475cfc97fd8d36e1c21cbb77a9729df0c87520fe64ee06e71e7e313399d3262c9a35e536182da66de297c37c892bad06c9afca7d547f19a6db02a452974118211aacb95fd0888c066751bac1b995c359fae6835f97e1e6dab5e7c084ff796315e1bd6b696d3b280fd872edfd4fbc4fac8c6d34b66df3f46dbb8a0dedc28a41449da0c1171f703b90d7c904ccd0dcf34b1b0ca932c6e6352e2372c48cb2a616605ebf5c502f2947b56a98f32bdc4452586c64a2d2869b5cce3dc8e73e107c4e1d57926cc6c3591b7bbf865e32c6a0395a85ebcf54660538cd9c9fcac2ffb8f68e7cfd60edf6dcf003b023d396864e4f0932cfc812dd0b9a280993d60713a98a3fd325cc46a3482242a8b1d7990443c647d323dc8076fa648c42cf1fe2503097b555f983f804e8cce0d5cfb359413a80dc87398c1c38f4e72e7229464e4663948545b5a6cb99c18019d750f5b7fa4edfb15fd4e7302cafb1cdc3e1f50b92dfc3e3d5cbadcd9d0e64f7cd800c9295ce1cf983a6f9d1732484e1063f361f41918ebc04a703201bae06c685873f2c3dc81897f323ef126f0ab2634f0efc2f2e141ca07ea1072e3071ff14f1f073985c1d327a3d92eeda548ddb7a0901cc4808132ca8f732feb5ea3d85bb8e4f6615ed0da822ae8cabcaf72d669cb7bd166c84231e95a817a8860783921faace473eafa4bdc2a41251c7dee11188938b4557bed130b58b451bfa18cb31d0b54520fd7b32e39c8e595b754b1cb0e78d3c1bce49ebe1b33b8b0b3b2e0bf49bda0d6e5cd6e7385cee2ac58a199113833a8ec079fa6395bd26459d4864a495b9404330a373685fa7233d973887e74ee67072019c0eee7d94da3f5bc228e2fa9ceefd2d2e63494e2bc0d8bab9ed99bcc4f3ba3daf5be539fe9f838af3612a5c9a565323cd8ae0643b328745898ffdf346a1fec63ec1138f1f4efae4cb2e8cb4f589cf241ba0b0e25ffc53e937a079f0085fbf1444b6d4e78ab1eccf499e702cb4b3ef05e0196a32a5fa90da30872f9ae9f264b2666c175ba0486161875a0cd58f51eed05eb246c6cbc9501173ff2bd4b6a25a5eb22a4c2b1f08b5091d284f05995b761a23a48116ee92a801c622111c6fbb19dcfed575f8c2f2a951ef869cd8c36a15cb09d0f742e85a1b9b914267b441cb8925b199b6e9635367554dcea263e98f0e7840f680cf6295b6c95815e482611682600f19048dea83460b7d6ebe1215c6ae3ab9ba513ad65d49ee857fb46e8a8f2f0414f5c1b0902a2e7099db632fabda07f3b82ec5daeddbee428c482ef69072104f78601f9689669252e14a7d0d84ea168aaef880504a7b09a4192c326896a2faf32c1eddd0e1f8cdbc7d136637bdb50f1f19ac574d56bd6560f5d22a661fe8d6d229496161ac3c6729dbbe39dbe71618b362f2a4a60b6609a72ef8510394ca0b1a6f8ba30b0bac50d5ec4dcf90a2acb481c8970ac34d694f932a88e1c44f130583d01f84151a66596f6a8a2d99c0eb305b1514dd860e987ceb3dc81faa3f77b8051a9364f8848d36e1027fa46f25cd0ce5f26fa2ddacad7e9e91df9c20df3d1489609a17f2e79610394ffa1c1f1bda04f7b1caa4fe41f4da852ff8b2246f32dafa3c2b8a2b95bc0cccd6d018f46361b903d1fdad62e5eb7713d45d692f62e46cda256147017905942a6c91e27526d918c013e03dce15943b95ae69babc23398560d060fb93cf1bd735890de5996949c80d652fadd71e9d773aea5eb9423059c1676a3b45b4992d84aab493650fc2961279384c8252f04ed6e2b3712e0059b91a5b1c9f36e43ac2b7f73f62bca2e3d155823cdd17c45cc245e42825229ab8660e5bd29d12614f881ff02d88f3a045463ab0828e00b11a8bca3128d5420d729f06898ee31e537d774c83282fa4a5cb48236ea70629363eb98104b5fd041b83297df0ce0e40531aefb19943cffce66f12540a96c5e82d83b93fc8422af523595aca2f1af6dcc8da4e7bd0d3798cd3efd5c0529e4af876d737474d9910a24804e6e23a9f4a059caaeed1b289ba3691c802e2aed133ba295cf4aaef00a2e833f08634aff9c0490884f441ddefb418030e549b9b2ad3945a162accca70c62e299067c1136b3600b9c08d4f288d37bed17c2ac23417765032887307457aedf089ae04c30ecc3255e418477649b459625a8e7c1965ab8c192165957f2e3e41ab5643b5c018439771136f0c23068bd61cd03787d6054e71511e6e55f96772d09eff4d56e05e833bc3f6ca454d2e681d267bc5f7af45a5f685fc3cc75e97aff7139f81750fecdb995c72bac093250e1ded2bef0f5f339c212c896277bf60de658367071a0d983cb091a738c41498d31daaf9619d70073a185a482b8fe8fb2489814e9b153a8bcf912cadd9ce94f3eee2a1c5dba9430bab4d81bc9490e72655d860659ce5e01771a9e54e58fc7e215e0547dbb7214a1147764f7d01afb59053cbe8745112115039bc1df0e79c26f477ef07698ef5855c5be68449d597483e9fdcc623565d35a1e095e62e8605b2113b5e455d6caa62c8b19bc699f669770d86448143e066fd510bd0cbdce24a5fafe5f574219ea836a9b1247c11c560b296b45b31dc6a468a1ddfc179e549d00f51c8a1726be4caf78ce5c9a768ffe770a0e0908a0ae800c76180bbdffe3a78800cc89ccce4f55bd214bef9bffb89c62ab0ed568f6d4b8613622d0fae56e68cb933a6134df34ac84102b8dccf4ad8e14cba321b1230bcb831f0ca6e819edd616b6171a9466d4415da9d414c90eda94443c3b85b7a790ac27ed38abe3ea083f7f13a8a0a25fd735f35d7158780d02bd53008e252d4686b4a8df2ffd3a4005527424bccfea3ae22712fd8ee5527165f887837f059c1da5f37a8319c7ac377ee41006045de730e5eab8a9aac55ce8d8d7178aaf7dcbafb1eb439fb3b0fdfc23d482c178dc6011fe62fa3c2d8a04ea4693fb58e8471af95fcd68545ba2461d873116782148ae5ac9b7fa9815b85b6c5834c432ea48b6c58b8ca213c35ca2388e704f1dadc0524d5598e81745d44a51bab65a3a2cdc22dab857db189446d6bfcf1f5460bf3bcc0e940bb2de85922e03c588d8749ad378687a16fb511522aa27dd83db1307e6f5523d7032d978d65da08577f625796471b1c68dd85c71dc354cf6af4f381e9f6ad68f59d4d9146a75c445b71f54ff81c5afc65e4edaf4591e3a3a3d398c9a15f28f6fb6afeac4c7e61c7c3e51022a64e599bcceddf863effe9bc7c648fbbe40d729d3919ab94d2c1855e207dd79313d1d717536f9f08e3fc3bcef93b8042b5ec18d7db9ef4d0f7ee14c189ab7360613aa28b48a4eb2dee87bcd82d7ff816a5bc7a54e893e70e88a319d4c2c39ea96d21e85c145186aa2f749c9d73ef6174a14d2519485dba4195c5f085b85a40876683ad132e6b1ef496f31cffc9a84c1fa5806424bb02c93d0000aa389589bd53371c2d723e2fd25df391e08fe785f00fc1f02a9fcfffe50d1aec89721fb5160d51ca512c95b09d3a8f50f7af262f731cf77fef2c18a48749883760b30f5c94c1c508f95c6e10e013d4425f81f1df295012eafd18ad21df0b5c307f1b2a2c2875be206492c69b0c7c7f29f154f63c14657142a30ffd766f89c6d229c4cc4d976d1b03ab7292bac764b8b0b36721217bed2bee0e1c66768e9deae471f80965668551b411005643b4ebc2a96a62d4263f9bf4cf185c62f2f4c166703367a408f18f0d8ff2e8b8125f1c8a2837a91010bf1cc26ad73ddc6100ac7bacd46ede21c3aee19e719c87d7eab12a164a7ad2890039a2b23dde32c8705888c0e7433c0f4a3ef3d405ed40e294a628b70bd582285da9ab1e4316114321f9380b9a5dbc76c531d667610fbfcabb5f9d0c7d971189f711dcf994988add330ad409311c0947faffec71e6ba7f378aa5aa8f045b03aa92be23b5917874f5f944b4f716f01f9dda008a55db41b4b02574986bbf5c601e7b9d1f4dad8dc8d154cde19b98c83d5cff277025b978df4d3fada428c97ac9aa1e58a616215d83946729f8acac99950e7e4944519c269afa9f04108b4151ed3b4c71fa48df4e74049f827adf5f404c2e7a94fcb1ec003d4808b9cbd55385478001bd4e8e6252cba4c0c79fe5b253c8b48bc3a1ab14003d4aa4bd488c4a8944ebf17569a23bd41a60d85c507afedbf086af4f7a3791f2476fdb09332797e81cd987628cfaed11b46a9176ed43461a2663a51dd24492546f07e36640e3dd276557e57ea08f1712fe2068cdaa7677cb0b8b9992f0f4e28d1090a00473f1eba0e433c4285d6667f42c1b4b3c660ed1b7177cca3c5268ddd2b703afbc98588b0ec2b5d1c5606d75a449f4a2b48c998086979652e7aebcf534e6d54caf7319fb1bc6e83240912ec11abd237935a51a34027225f4e116a545e417c57f05b26625bdfc2d089a473a3c591af72d206ca64794df5d8c9237a434f660fe02e2f64bb0ccd9c48a865a2c6d48f5290365b9453a026d7b054d2558516be5df23745de8f8419f2c4a15692984f1c09588c0e031867f0a877d47d319e8e3cb1c97c717a2c99daeda8e474da747d85e5a692634a62bfcccb2a9003cbaccbd8348c5e63e351f2d57936746107266e9497bd82f3d04fe392078f469be395f8039f7001611d1ed2fa9176c6ba222b8bac33022af11418ef4def2bda88c3acc8a16b3dc07e09a8b9d072813c85a7cb4274ab0e412c57e71a91ab36354cae7e3100097ea85f4f4a50a584f54571c1eeb6c9952647b26b2e82e6eb4a9566a63238d58e432420b0121ffb6f9b2578ff64055faef6b5e8fbf44a8d3617319ec49c791fda06322d49f06e306de1e130c65afbcce8cc8faeaa167f6966fe3a9b0d459f1fcdee23bf5e9ffd782738d6473c3dcaea3ec5eed7c33636549dee3318aa505c665051c52359d167b20313fcab382aa96cf4d96af9d97600f06dbef063242002c08b40de065741258297f5383e99ddcd2271727f25592a696ffa64e840664f26397f66b04b810886e8ad0f42b960902023d5146c7487ef5c3457dcaa10c3283bff18e3c9ce3090bba6fa55cb5538f15e07ab68da2dbcbaeac53ee335a3681a76ad73b96e852f9ebfad5141c979ec780ae435b319090d5bd8cefd8d94ccac19eb0994624cecd6b6b422d190b37f87cc5aa6d78e6fff33f7e984ac615b0083c081e0cb1b5f60cd1e66bfdb75a7d5960559f808a92369f4ff4c1a3df9e940f6cb636fd0b01add744211900efeaefc35d56d97d961f6b181f8578b7023afb2096363bf9a35ff9f7a86fe3458c229b8b8952367a34ba30bdbe99e7737f35b88d2bdf8e64981e36bf99adab13c8da8e348c749768e07e394675a070383bb36b8f3ee1abd47b69cbd95b0da504f9a11594192243a6d52f2c2cd64d4a270dc15f115c47603e54d00bef732ba5655cd8c856621fd61a5056c60959ed6996d9664e72f8660b5873fb6297d801f92e35a8b7024a29d39c0e3725f81a5e1cfe0e4d9230a366aa1054eb2831439843d84a220e9c451e361590a6fdaea225fc7e98df3b90dcf785d50e60348a6e575de7d41d9ec14651c96c01c2b38b2df536cabfa3e226a27f0d279edf1fcb99760edc97db435b56b64cca9af2a6fb136ca1fd3707472218d435e52b6be4730b69bb4392dc666a59dc07c3855887d477b665d4b228ce98f0eabec6046e91f5f707756a4ae4c0d029976c8412f6b17c84dd4b66e549f0858b46be336f1b73a423349720b979b6079830b956218386652a153edc7e73dbeb428fc56bd6adcf22942a891955fcc9f169d874cc96a8c79c5fe93d216e2249341af2381c161b6e4cccd62a07c4f8c2571522d6d46a670de2f4540e6b0370394ab7fce6e69a7b9d5929262a499b33d9e14e806fa96e11af64cbfd4f620eae997c27466ea3f36cb7f532b05fcac8f1a4742a983894e93bde869ec443184adc17fb7d75d999da1d2a615b74e79d34e1d2b23a9790138eb06dee3aecd9d8689e9ea81778ebeb246d688a5432667eb2b32c9dcae7d3744137407e895a5314eca336f556e8ac7d26bd450429001f79cefbc042dd34dfa48965330c8570786bb742a1a9ba7f6bb1b02644b5bd5de69f11d5e3e63ad34df380fb48c1e8c2219cc4108514663fae23e9c009bcebc1eb221537eb4e9bcc5987d5f31daea295426b4e0ed108359248fe6b5fd89d3d161d64f74caf227aa6482d5293c8054d5bd7571ae254fce1d35cc4f5b87c96f38820826b1fc3676ab072703e013806f418db5cb2b15b9b50607ab1a05b4962154d516957761590d74d0d30dccde4d670d2a30e6e796c63d3dea98938949a0f8d43b06eb3b97766de96a106a7a76c9fc5d2dc3a4d524d21cfa9940e831740542f97e0771db64b359df92296722ba23d9a250239bf01c58613bae7cd48ee6f7253ca0570f24b68e092c4ec41a7b1fecf63f0a500b030afa77bc625d039eb211a64eaf4f97ac954092e1d24fd706761ac794c87935bc0986cb08fa0e83240195ad240405f741ef07acff18be3bcb15a8dd2c7598f1ab0a92b24b23a274d63874c6bb808acaf70e2739afd5012217746441bddcb3b3e9c74abde026a0cdf6b2184b14e73097898bb78ed16761084a93161761edf1f358d418626ffca010432439c1805463ad0c6ef3ae96ee6737d94b280ae00afb36d9d0d2c2622bcba6ebbcc67acf17d73cecf8f8ac23579ca759708552b97a46b448ad14d3006c2170fd656a3853d2f5e56c96a481b55942dea44f3616aa216d429debc613595680fe9908004d36cb1f314a69350b0c6c8ca39dafef7bf6560ed3c9e86d75939d1329b6b447c6e6c870771e8b1e01c7fee9489aac534890cba9dab63c2dc4d0b41ccf7a9c9d972d2c813cb25fdca5d2859efd5fc73b30e203793374317b790d543cf471d875f4e619dfc64fa36005f51ad75f8c63c1a15c1ee15feaea422cc318bad214448d749b74ac5208d7b2aff095e9d955d519db6b7a32e3118d87dc1b4425c71eee0f89a213b3324dffc9f06ebb571155c4d0f2f4c5f2a6d94cbba7f29005069365216a9b7d1832ea7f43d554eb702e89ca8058a217d70babee7f6abee377a641646c1820e223756b545a20a4bd37a633a1dfa728fcc3079e15b0e234672af01569b339851e906a899239eadf69e84cc4424024711a8cd8856e9673fcda27518e21e6d0dc66909624a1f6cab81e753cdb2622d3d6b8cf0d148092689c8baf247d6b84f1f160890c04d89241bbbb93e3e5ccb620a86262b4da794673952c97e6bb0c7acbfb420c9a60af1ba249139624d86beb349cadc85dbfad8a469e4ac995244452b4d5216b97ac96fa8ff3e7203adc61c855fffd62d5df9b69458bf4f24393076799eeec49835337fcdcb099aa59375a4967ada2d3d21eef24b2a584bb488a0af01be538cac79382104d8fec6a0932d0b0047322e423cc987ae7b2bfcb6b0928205fc45b0520f0466e6d7a5a99d1317fd8e10f0d608b1ee59bbb3e76a58c6e4ba7481525e8e79992675abc06166113630028e1edfcc8a135476abac19d3b91acbabdc52b9d6be14a240f3b66ae60f606ae9dba6e9f666b173c25457744fc0b5016679aea9fc5b8e9ef5bf552d4a2ccbdb1f7bda72a9200ee14fa8d6bd0ff89b35f2fb6c38773e7294a8b57ba8d23cc6584fe1cb3bde3330028349330d05b586f9e20c2485c5761ce055c0ea3bcb1f067fee9b1bfd93b04214c0de1c6fb4deeb293f1ef653aab0a8587eb30f0df96c744c9be5c81f5ae9bc22d697a8647588c904e5054d883949f70ea2c717ef8f9e2327611bfd0c7783571882da716ffc6953ca0b1498eef1af55ced0cda34ec59993af3bd0a8b0447f957c9916720c262c5f9649f5fbfe328917131dd1fdc604760f1fe28608d880cdb8040ae7bddce06a9cd7989486f9b0e5761cce2776170cef745bb3a6b30674cae6c91c92739a50076a69181e96953accd59d9250b8e1486e8057800560ea403fcdacdac6d1f9b94ffb5a3b6741cdf1cc869cff702e0bb80e904e89f0545fc6c1f15c5685d4ea4bb03173d4b0b53f166b02b56842b280ebafd2dd98087d7c26dee5a815547285fb0a20f8275b7ca9ee5fe566c351b738166b0836f1a5cca9a2a5c5fb2e5ef8ddae103c8bf14765cb849f1146784de2749143808442fb160277a5232fc27a5a51165db38c97b6007f5179700074fb4a4b8c8b1084bd20ab1646a6fa48e985eb23b32e4bfe939925458dee695b8843d6c15422802e5e8c1c4dcef9ea90446b76a59676fb56e1262240fc839ddcad188cce2db5a6370691aefb04ab8f1142a5d578948499e071c78c772c57b3a744082f4866814ce00e8b3e3413b8bb4e401ab121f192f3b3e591e8a4e9836e73a1e525fac84c6bc0acf3ca56cf95e17033d83dac7ca41eb05dd8f3765cc830eb8c76d908ed5fac3ab5bf8904d0dea620feec3ba44d174ce166195b332fe244dc2d623a741eab3b65ac39cfe6b496670305ed70c73573a63f65131e59a21a87a560b05a0bc080cb2368534f6985a0d5e3de822c01df57a3c0cbaaa3339e948bd6c9e4aee82d8bfcbc291d55d1060315703530dc0c0f376709ae7ab69fa971cec6420f1c45f9f0f2362237153c4cb4adfc435a85fb215962ad95e29dcc5d3eb4cf88280cd4c8907d5ad3a96f8aa92ce25058603885c1ffcfdaf2057194b79f5c4eae785d31e288554f1cbcc4bfe7703a94013f33f39821047c6d060ed2378718c6c1f606adb4d3e2cabef8bcbaae4561985ce6c9b15d662578829bc9cf224fd0c14d0c30715af888bd091d7683c0b620d7ff0cdbf10a1b3d9052f3d6bca2b0f5c0acf066a0fd492d4c9a19c82c9f6b0a54a584bdb7f4589d11f28ec59f9690feba82837eb4c0929fb27ac4b4751c5320119ccd8beb08dc288e1d49a892aa8bc166a9ef3fb29e6136682128f5ca3c0b3457b02309aa55f9834e12f3ba0dd084f7a610571a2e15e2ba193879db6e35ff677f1804096161dd905269f1564cf5f17bc14d3d741e169bf98fd93ad2512097daa357d70e739c0f95613ee372575f1eb803e93cf2f6898bbbd04ca40ad619afb2cb0c0bf7e6eee0facb823018a14ec28b39e5336df4d590255291ea61f6056b539b19cdffdec886abc1d94d6ea29a652b7f2bdc0305d8ee5aff160f2122dde2aa0cae33192a144b0adfaaa82169724c222ab67664e47a11295e6145a8b8abf7327132461c391c127e59cdfe29f28033d174de238472eb550f8f7c329ade8656eb992bc78c136ebc3c8e151f469f9d5923ed8caa035885e280351eb3cc9b7abbe06419d07f952a02ac4600d93aa434b4dc78d4625fb74c461c8cd02798653fc1d91bc318e61ff5df1d3b8cfb1b52c8320abd4fd7d54917ba556b8a2017ab24b8a0f2242de057ba4755f766846ce87996cd990dcead1412b12f4002d2bd8882ed95d42915633afbb51d4d51c4fe60f026961f9817a6622598242357684e7fbd8445eb7ac2956054ee7bef16c4ae139a7ee0205367200556dff9162faee782b10cde692450a540dc1dcf1f63197de4b9f5b43241b244acad1b4d94f8d0bf96da29e4f67f009e06fa4c7217cc7751b161460233d9cdc78d1d3547a8b29110f393141e1bfffe34684771c9d60345b27783aa3723632e2c6964c7520e4880a38eebb0832152cf559a58275a7baba5193a813ddc68a38f10b5a4190bbdf3a9a0beb7d59ba214b116671d903ad5efe19f93f5f9b809fb68997c17a5b2ee7ac0b73862b6a4d02f30f895974d50eb03fbd9c222e147b666b17ec57ca57faff5577313f0a9d001cd36f70757b627b437b92afc7abebdde635394cbe2d9ccd589abc1538fcde1d16bc42f2777cd19e770926735905be8b16dc6a419b5ec44d654867eb38632f52534058a08c34b1ab8b7615acbf906c4bc0f6d7f02a0da94e2f7d5ffbb23f9d8161faf2b25eb062191d45cf4887fb910516e5fc398fd011d754aadac0e7a4029d46617e07614d27bf1884cc17df36f9ca13cf54961779f6b7564174f8600cbcecfe3380f090063a5c4793dd838ffe1332ab9ae18f4561142e09c8e816d1b341665be37b01cd57de0d41469d28b45420f09c15c6daddf1b4eb3ced4ece43395c706740b6320825ba928dcafd54ca82b04204b6c5784c509fb2bb69f5b51809b1646254e4325740fd70e9adcdb3de163e88a2de724ea7987142923b883fc74916acae12cd8467ab4957422f87069d0a57883fb7eced5bb7e88c4679a77bea8d5abb6913b8437b41a88034234094e4f8c686224e03147d70494661147f0f05a03d123541cb6e0096ce1f8d4678c3a140fb8c7589fa883c6eee791fb844ea9eaf584b710db181042241099c41f67c34e5ecf70fa37f628e473d173004993815a0bdf3db8a8875bb596442db97fba0792df94e45f403091b859ac625d3f01cc7c9bae135432761b3dc52856162bf97580b96cee5c700d354d8198552306158a0cc0a385ab60b45b875874f7044e278fa2245fb68d97773d0cc932812b522ad9f4af50f5d77577ef0edfd3d97569c2e6a346af89fce630422e3d560c71665e7390c7e9bcfd5de43e55f7e5532c00ca31dde9fd2286241fc23c33c6614de220012bd4010eb2e34e14a4eb47670ef1baa0152e7d97c1a22546915f2917e0f049d1b66d6bf9f2451632293503890df559158eb127a5820488deb47d4d72cfe8e2ab812dc0a43833f55eb6a15ff5eda0026c86a8534c278ac6868d4e81049bbc7874c13efa37c2c7da824d023db30d6d1735fb942bb387a9a2ba1ca450366cca6dc00c70907eb7148826849b6e746d084fd0d9fd8665cc074784d29d273240d3bf23ac69efb515f30ff5d1ecbabb478b7f875a4bbcca644adc4675050c2840bdb28fb299b3a35ed5e13e27d5049f7c71b2eca395be8ecde096119fc0462eddbfcfd1299b3e534c94b613e4b40db55eecbdaaa1be5ee6f70d1855c44a1d5fba9b343dce9d5b5b6891f1b4e1000dfd95241b4e89ee9eaf0fcb0189d7db59dd3f80f1344758f4f7c8a750d278bb7b533e03063022adaf8475c5c349d69bb574990ffc7e1b4b06c12f6f89588dfa13822f5bc0f8ebe250f1caf467bffe5747afe55fe05b15caf968d9520eb3172c46bc986b3b9b19a162ef36a2ccf9eb1f9f04faa9e1448310d81b7da4142e947f50325f277cf7f0bc29a87be30adb96c8d9191177ad1850badbf06bc6c8c470410db3721615488d3aef0efc3e14329bb355257610dc35bfbe7029f36643e6a9ec8cccf27fcf596315d7b16a1fcf00de3752a91b02f9af21e7a078a654490bfc9d03ff4f28ce0f9e21812c6ff3d577f115137be1f7b5e3bdade85893a06400f38e4b1fd2d66a2797ce37d281d1454b8628654a16e7679cdb8c41b7cbe7a55e053c7d9ac82cc271575a1c6788145bac3a5ae3da6e7d0bab9131ce83abe5a84717fa2e514a3a429eebce221aad484582a62b42896aa1846ef40bda54230c2bcde5568f1fc6b2f311b6104a8b5632d68bf5bef5f5b839548af25ceb83e95ea236211e89344249559768eb2e71d6d91c3363f9d4c05b22374ce1d674a5b7ec65a14e9dbf574aab23975507a10860995e2f93e959d65ab5c73940570a73905571e077624d8398d7ed9802f54d3840b7d97482295c654b8ecb6d37eda79d12102ef572b9ba552c4d36ab173516b7fff3761b365c5603ba78d03c92a45a5182c16b016310389caa28014b3f90f80e7436b73393aa89e486822eeffc64213c8061f1920d7c68963f64fce0ab1d6c7810605114cf86ae635f4651ffefeaacaf2f50785281b0e2edaf6471ec1823dd989c98aedaaacac810b169bdce9503c421b5f43f876ad6108608ac78100bf9881b3908358fd8dfcff78047ecb38b83c5db6c81d24ebb63db87a2b57ceb025743f1ee130953433e6709d746585fd77fc23114feaf15691a1f3f7c023603bd64e671d9e8409fc43a79399197f31829bd3520136198aac3f6d1ea9e6aa03591de8944d37b73771c2356a12ca588670546aa5e65d4e22a6329127d30d6255634cf2eabdf28d707b2b19a3d3dbb28ad0252ec485386806d29aa9668f4e6fb377ed47ad99922cb11b39f2a5095e62401095c29b1cd5d614b3eb053ad4335f5c120d98327bcf93e37401c6912828edb55a0e7b87294ee175f5a5a5c165e64dfbd1d4b13cd1aa746c920fa34dd9640939adc126030b8bd75e1742da0252ed246aceda2e393b3d45015a82bef44d3b2c775e63cea1902252b563267ada48ce50682c5514b47352c790a75ca252d5cbef8cc39fb05955f2bb55c45acd3050da5d77ecadd1b9dca8dfe4a8c0ee1d8b13c19ee7648afc92f231fd51c903659e10ccb548312f4fc4523dc4054092c046ae7c107d8d4f285fd03b394958b59da429c432083589ca0be37f3f8895654ce13f2d0fa354f519cf0158d17732c460b906966f7c235aec060c907d2a1d9bda05a5184a4a60bd5ae9667a45d6f3f9d71d45d1c014ea792aebebaff9508e726b410fb4b6374ed07786e1d7e74422bb98e82715400e84d4156b10838e8140505deb3fad73990e44d01ccc5ed4a249d73bc77ccded3aa140a1bee9eae793705f0b51a1d5b72e86d13083c750032f3402b20ba75b1a50946645e40e5abebf23dd4b2019f9b48b5d45a8aa648b2dbba8ddbee98ea80f8f883a167666f44d3e04e423dad40ca8380142320a1e5454e8dc6890e81316a3436265a1acf0ead4e68f00d5ee8bba4fbe51314cfa81680d65c7952bcb3f8f00609e09d88f7151ccd4772cc5dda1f23986023d6846ac5795ac8e39f0a20e57423ec01c1c78d938c757bd81f3155bd2576f16c6d5fe76d103da6d29e3c58df46c590a483071a3312604911340d74a4c220187b35ddb7ab17935905ebee1744ae081696972e0077c6d6c23fa5b9e3f549fe6313df8e0ef6acac5f8b65689ff82a62458f221a7f2e356058d89302805bb05aa94bf67fb622d9057121bf52329d26b3ee119f0b633ae733cd2e276ab7b945b15e86de79a624832065c6692f2f2549e44a03600fdfaf3ef1aa39c64ead03ee27bd65cacb8a7d4a96d9f58f7b81442fba2dee9661a0a3b37ef93d8c2ee11eac5670dfb28cf13bb91656ff8d21835e4547300be2c0ac431148ca50f7d2a79ee51063568c923214967af8b8d0d36cc265de90af39d43cba74a6dc4a01ae369482c4f191c423d27a6b652df50242dcc5e257bb3774fc22a8d0955d8cddac03e34f025fb787fac314e8a52f57205d4e7dd4eb0c0aa9e77c8074528b8a4dc1449df9ccaa0237dc32600c0c4179c39666ff2669783d64183503f6c348842c1e399a44e77cc2e935cc624421339063927537cdd4f65a238bf681d07f5e2c9150fc0356591af315f038da755aa6d264b31e4cebee9d8a43aefc9d5e80d12b43813258452dd42015e7df56ff0456e33ec107679320e897b05c38ee82df321e43b6386a2dcd8a9c475579e3da4f9abfb6cd6e0e38172ea85e74b9b9fe1ae1b64c9795c0bba884a50c593c1253e7cb55a6c5121e5ba9830ed97a32ab66e1ca2d9519f6430c845c003e1c186f719e60c630e864f7b689313cfe74ac91971404807f8ad8152a04856487c9adfcaef069d7c7c423039cd84f8ed22865bff9bcfddba2f86eaaa7e0789e065f03e4c88fccde766570277433fb2f30efa498c8143e15c5d9f1c8350263ad2a0ebdbed1e38b3f779ca8846c6e314d1cba0fb27058755b4582ddfe4fd0213bbdb7aa2d21eb31f8e2908afbc5e376f545f729fc6b0d045b08c13c316882568dd4b300fcdbb7a41642bfdc773c811849a4a84626b2d91528682a43086ba2d1275e25e623f7ece42756e186b23bbc172eef6dd1c72ae5e2660e8cbb5e94438b1b4756b7a1918b0598eafb42adb3122f1d7ef3d037561dc9b1e00733f603463e353fee1d823e74b1c0ffdc52048a735b510428391dda6ad9b5dbf20148001acf1f24c64aa89faef3e735c17e38e7c6b158f8e48857edf38a1f499b6d15751920247f13f35a93d1c1e8c65f7056ab987f6c6934779dcddb60a0c7175228d98db9b9cdbfb87258283","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
