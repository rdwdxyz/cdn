<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af67349a9e35a894a51d8762d5f90eeaf4d9adc7b5f8f1de623da6ded7273b90286b6d6e9aa6dbeff70caead9ee97bc52ff50d3a95dfef314e203f419db4101f4d581407771f42cc67bba0a840555ee49dc36c726ff7227afdf6102e62d1f6a9ba82a4efe0448bfee1c491b5427a4400a0b26895fd3eb472c2d9483ef6069ed79b2c950fcb2993e2d64fe70d67c45a61224ed23705380ab9fc9f7babcfcfe8b82d5d80fe0bb510107a96c36691b168405f34ab5b579d3760223971b732afe376025af7efd8cfc7cfd4c6e571769822d9aa55b8f4fd1a683387e71ca360ad9318e9645df7910f2714297bc84717c4c0be81048050833f094d8bea63859f629f238f638241efc6dcaac36d3827864cdaa533ba9daf7bd478daa9f18041d0ce71517b5b0ea0cafe628c975bd27e23873aefdbcadd5e4f4d41a6339f39dd53844079947a511ac43e54ca2d56cb27378c24b937e6c3e349913611f8bcb263b96ff75b80cdbb9888216a238346802950428061f0a544a5b65050bffb9280315ae8000a730321b21afec759685d5baa7768da77e2bf9c6ccdf2fd1ce6b44d4cbf5bbf7dd5a5fb120104766a0372b945df3bb3052abd5b16fdc01108c06d147fdf6451b5b00ea36789f7c87c8f36ffe3c1f37358f392c06b0f5491871cb897a8b84aa71e5f388530f4c013812cf88d270a93a68254d490d4f6780fc5734de6f28df3585528f1d61217bb8081fee8e8980a8317a623a7c7f31a415c3c300be9eb8088b8677dc49addd5ffb409cf36b1d39582988483db7b9b43c2d80af74a06a5b89c9c54934a0c648a52478199604075e70ef3bb2ec317125faed5d8cfa91fb49776a8173927777a659e1688f5ad020b11b9246555cd463202aa9ea8e455ce367e125cf095f9678e26da67c53f39749ea1bb2b9f194bc14ff807068d9390ac6e1c321a0230be433fc8eabc19a52eec3fae75d3761b853e6792214ff291c46d67246aaea491308585cfe948af94e408160475572f704444ec4af7669a22faf83a1ed0261dcfc1101c12690267368a98eb19b7cce425847b33c740e68c35184d1e3a7a2f7fa7272a9260b775b012c35fd731f98644972ef45fc313d4ca95272ba77c35da173a0d86ccea000d20f29a6afcd960b9024d25286eda2d3cad78a65ce7227d447c36aeb872a50cbfd567bb0dd510a40e7bc5312d57241b45a879c254bbed3783b7b87e9960770081cbc475f717c8fb9b212709d67ea3da5bda1e18628cc1c59b075b8f1f928e022f06b9a242688b568f119bc300ba862f3d94e7685584ecc63613c4edbeb1f7330d08453b38f7231284ae59a3a702c6e4b044e11792f56f630724d11e9fa22a03f1e58988f69212a2d47ae7d8a320301fa8860081cbdce51b6aab7849aacb79afe99cc9e0c0b1324fb365c782df28e136216bc76eea44a5ed1860b2fa10537fe854e3cf314e4ddb8e1db9fe0dca02e99e6258fea9c4471d6c33cc3054bc7f859293b1734cecfb1fabe0ea34ea8a057030861516b60e6559e67ec44756d2bf85ca95573e59dd30891e70b7b316952259f71a818d233e15df91629f737099c855ed84c5ee654481f3d752787905553d63b665b8276d54badcabba634771fbf26caabe82fc3fcf8438579d1c29d64a7d38c54ddeaa616298d6002127f5ba9ebe25d6fd28cf67911da9843ef83c8fe4964c009f2662a1c776f01ef7183d08f4c26d38356ad28eeab4d679de216d62e5d667222326ba55a11ffc55af23504d20c91644b6f31ca4abfa80120e3c2c18855960d53db2c2acced4b134f5bbb23e4ba9e5d169a694c35be6d52a2508a54f8e836744cb651c2828a03307aa34122cfb4e1c9be453156847fa5d23167551e19a00049d8332031a1e4c0d4b1db4d11c9866d2a60ba1b33fe6c71247ed58c3106a6b8153e5fe53d5bbcfb9c0553af33da78474e2756da0639b156423e8a338483b69aaf9e9498ee0e725e273e67d83722e624e470a5f2b6a8c19d34701102bbb67f34747e4331f7349f5421fc615378cfdace8bb51906a2911cba4af65f42d39a31c9f5ccb1f4bf75474cc42f2896860227dcdf66dfda1894aeaf18c738c36e5a285bdc828a1e3413353d19f6ef89d8e83a5ea5b8589eebc592fb82b51df6a6b7442f18610bee2e26ef0cc73d20b777d87d56d481757da3da598801d485587139c386ca28ec1d65075d6a66970f5d012e4f6862c995ef1a03e8c5e076cb115d7bfa0e7906cf272e1e34fe705338d25dcea0816c3805a719ea19c9655783ac07efa59d7b6ed804fd488f6e140b7525cf6585c9e14c2ec6bd59045e5b0c231d14f866569888f60404d74a6729431c751d0aa52cff91fc6d7707907ac536fb0f24cfccf6abf60a9871a16e28ce1c64bd1bed3ac7937c433140685f16e4c9a530c3b440cc285bcb73c93ba0abf1d977aa3402985679d6eb7bb5c57699698a34fafb80e5d2cb5064ba831e4d887fa891ec15b910cca51c336d32703fc88f370c43adb394a5e45b774b18156d182786f673bbc600fa66c23b08689e7e700bcf6a91b12f3dc2ddcd624705e53f165bba7a19ef2a60712fa2e7065bca02386f669b65dbee085623f6aeef2c1385d10d05074e488087142cf0388447e93ad4de15cbd92b03618a70314d4fd8fda07ddd4f892bd2a2035b82f105054c0e343222821800f976c4c33a548930a31265d7380352464ce05647d5ba4dc16d54faa3052cb3b2d2c87412e544c5328e3a971b9c8a7bf88ddbca1de15b79fbdd8f5572f2b3a9a90a4dab93b40034a3e910161a3e2ce1ea6c93d5f681ec406a20a49a26c26f20f6895394d8ae44a59ff27918074687c055a30d16c075a88cf0d1f07066a259a74ff851d9a81163fedf3232fe5e8892140b7d757824d558ae95ab40e00072a2ca2f53b99804352bead8f7e84877e1f9de35692af5d7a6ee1916d1ec68d7a29768514ec0ca9f5f2275ebb67b79cfcf7d948890d6d829af523ab926685d229547854cf8b33ef9e975d8c4ab7018211b793312f57ba280547696dc6394c43ad14067a8cc21a33977c6139ca5ea5822886d9a46cc170fc16b788e56c2d2151c923920d2a99cbecc5dd66e0cd50dc1a1bba1b9385af2b671367383bd9a1968b2aead2baa8373092ee124fec23c2f5e563def4ee2b0cd9ef3be3376a40acc2c58e782ab36da100627d711846b9baf75909921b8008a10640117a422a4aee99788eb539aba546ddf3f81cf10c9481b780f636eb11bfdf8538da267fbaf34aec5d50f85098ec5db702fb93aa6d2a45d6f264f6436390154db1cca1ca461e9b17ac3f064293e4eb8e2afc0e8db7501c62986ff586ce3983d076f889a72914d00dc889d33f0d4cc1612469db32da0f6a58d7dcf6bc3c2cd2c8c50f25d160246040436d2c96b8ba1fd45c8b31928142ac0b59f29a1f2500f60be1b0c6170b547674de61b4d379b163a7e644e5dea25fa3a918065686c9f9bdbdc4042dfa12137b62cf95d4eb9ae023a99ed241c689e2a7f69422e450b797a8e9c08e89e15653e4010d673bc740f4e52845e7eb9805aae87e0de7357c3c8a02a5ab3af8c1a01ae8f03fcec6bea1c9725c009ba8ee22bc3f3feefe648d16c315c3bccb236e59042273208c9b5ae813bbc2d64506cd9b947a119e9207f5fdaf5a8c516b005298ac953a2c74e6260f4e06627bafa3577e60ee676363982903823da82a703e1696c474b1b4f5936b76025184328de07b15702dbf279acefc844454bc96604c8e62eed745bad06dd94985f6ee86f6ca3186b4b5a0adb22b0a2d8446baefa283f1071ca116f5c1ba44226939197d2ad69008d541f75ec791c4b2ba32a896996e4eeb1623f7eb9c57eda07affc45b8145639a72b5d9f7a8db72e55ad54d86cf0c9989fb05ea5d9f87cc867a4120056629eefbcf623c31688407e857b727f861599cf8bb430a6610c02b59a2ee8fa6f4a86903493656285961042710e704dbcdb218b9db2cc010cbfeabf7deb324a126ab88601c9c317fb1827221a1a96c01ddf97db7e8950085625d85c21ac5766ef92fab7ce638f05931871668ca01bd7889a7909dadd60e99d3e184868f8b5b96a643a921b1497def8aac98bbea19e80f0ded2445c95401163b691eb1d95fde3bf589a90ee8a51b33dbf0a3f9dcf001ee5b33cf2de5e38d736ec560bfed2b8efb2fd90eab58b1a680dbc1e5e79d3f7380f594f1f8790ff27c0d51ac3241485c404b9e69371e99b08d289114101b5108737fc6c53d501dfcb133e0ff301ce841db0a87a4fff920daf5610efcc6e51b38d1c1f58cf36116737fc6ef8b85b0d7206b8998fa50c36958f4b55218626f520b66e00e42060de329b1220be1fdb53fc5e0b9bfa1e2e75c0c64e65463c9613fedf0127c494598af132e970c8d981009fb1329e5b73051de44e14a7bbf2f792b4aefe19c5cd0d250cb86d7762b9ee99a8c089371ba78136230312fbd3a18b707e7e45a884d76acae303ba363b2d84115b8536a82fa5559fc5b6df57a9534524ac9cbcbdde9aa351baedf634649668af73d72797452e5f83c2df8fbe9ca9beb3a1272a68cdc89ac4feb689310946272cda62aec4a0db81934ca85358569d3f7116b4e90ca3fca816ba4d8a28c68e816694d31de1e4ae1e45a99c1b37d16c48940eb589b4ff78a50babe4670dacfc69ead3314b6f83f5309a0e4012e395f0345bfb31ce629d128d623b5c63a2bca80d6cf124d147d4ca58dcf9ec44b99d072055681fa308411e91c24d84e9db74e3aa4925add068682475f859ca72eb8d374e485ca6353a18c5ed538e12788e89017a8f1289bfe9f5847502ac7b03350c7b092637f67d2ca52bf594ff71e78ffe1462c0266432eaadf31e2821c89be9636052d958f01db2f813bd55f9ebca65955aa9617bad9437ec10eef84db519b37595a29e2dde11179e18093e6da47ce913b761a6e88587548a179d052740e7f9f7febd61728c851260be45a902538ec82d9dda93b7a0ea31ad4bf1f7f4d772cce5845faa7bf418ff23c43314ff6c13122dad4323003820568f396297df03b3de58bfd7a547ea914e529ddc68f91886e093f0c9358ddecad4afcbf0cc79db5da24468eec5bc4c928bacd16e01e35fa096db60d116d345b4e8cb2d7ebc7b3bec13f5d7633810f556fdbb045e039d1090eb55bac6885482b228b2c30bde11581e9e3398631a7d509ac000290b3720e58ffbad652fa2a2107bce28f33f6407af3a6ab56ca69415598f608f60b65cf99b96dc81e4e7e3f014d541d57170f4698f5117e06c67afc20cfc254e7d22d2b0cf7cafa0ab429f375927559d393a411c1a2a977c7a7a14415fbed7c7a1ab7a7f91d60229eff0a7d4620f7e12a548fef6e53072cc87b51e099b4c6f8ac5451906d795907c39186f5d66fa77c76ee802bd86346d14a0eeba8ff633d9365ede02013696de753a4a434b3ef9838482ca84ec164f2616122b7b7da1b387fcb8b6e3b714f189fdbb524ae1fa04e973d9e025d0509b5103c80a2887d5bbb81bc09f71a561429b0fd38838e112b63dd948e2cc16465d895dd805445096b2d62c9378fbfd086768d1e1ccced54cf2673193ad65df46077c14222200fc5d80d53f70ef9b1af50cc84d932a8faf8c25cc18a3bf7eef0e196ec97e9ebe791f6bd4a92ffe52f8653e94b0bd90142e868ecdf048573705f83699e394d5d3d477567e7c01a025547a51b72a1f983496f15b7a3b775a894b1ca3b9d58d51d8fe810f364b4df76a1195eabe093fc2761c36c3890575b154fbf60d970e01e337b1c0b11cfc57a5586205fb72b17452a8629efd4b21b51b811e7761d9d42f4641c18f2a9031533c7bb031635b1f41113dbe78d694efde90a052f954e97e321afa5bbe25cabe84157175425972f1c3e34d3e4b1ea462081ea792a2f80a8c764ecbcad5051071ef2b7451b91d981978f9eb3d19a6cb54a872c83a4974a54bc7b2dcd93aa250e1891f28a14ac4c4009a8854c39821060e0661e7730ddf5e367502a9a09d5886f2f51a1f600d4f872ec74be3bd4c542cb9bc9b8f9865fe29b30eb8e51e7f7ad141f7fe74863157e272a487f66173a37276d51da717c8b452059757deba28ae1996ff178734fad9ded862698224b9e20e51d665fb41bc226cc50ef9f4e41cd023350678bf59f7c558c898bc6a332ff6695b44c3fddb15a26243c9e00dcb387867c60ddd35aa0f5484c06afebecbe31b6da5dc7afd3553469ca5f8cbef157b8a67206792f3d7f2bb68ba6463d29467535242d7f4280a8d8c9eec4a32728ec6da4d493941405e5d3d94f136a180eba0e80cc55db860f9a9fcff748020c3f10e8ef9e458bca74d33870b176935ee6b0f49c2e5fd7eee4f9648f010635e73ce4eff4641bdbacfb6c1edcd4260056b6bcd391c3144223a2f2f8fac0631ddaf7a4695dfdc6ac6c83e950f9f6fae3c5b60e2ee850feed0386862225a1a9130ca988cf2421476bd7fce16ef336d1161acf8e08238418e48fcb76e4bdf15dc1fa844893d73f64e8c11e311a4e91b5aa09575f5a379b5eda0d0a37d2cb3ae0725c5decd895289018b1947dccb975bcf7598ba2d06fdac5828796aa284dc1e7c24018c5ebbc09fe2be8d23e4e57a13edda0ea85ec6b8f4c8d939a4c021108f27dde2d4cbb8df1374e450858fff7b4e2707b4a49f4f7493f797f8b5e516a87fc070b2b2263cd2e216cbe236924b0e09af73113cdf871e0728d38e0a0268b8325df92bc0f4eb7b3900af55616d3b5f6073f0452d492cefe85f718800818f029c9d42521f5ba87d696ba800bac62b46e049ef5e934a60d673bec8b08feb7cb7a967b070494045cde75042dfd39445d7c78b6fd9b01a6f11855176b19e5161660337a44c1435ff68ad9a5d304d923fbb542c992d1171db4b2a7a0a22657fbd29da087c7fc994a111e79bdbee362697b989cc2df07aa90d9d4c9c80efec4d13b6c18439212d16b8c1f1d797ae6d4c7d84b2e3bbaa7a30b7797f4feb7180eb449e1716c476268853a7bbb8e2e845d0587ec4e712301ea95be48a964f44f187f637e979372e67f7eb561db7fd189b2d3e666c228a4ba906e6d35f9d6efb4a64c95d51dec651b9a5b101eeafa704cc8fbb30c9b76054471644e6ab3fcaa3acf3e53f73e6e83ad0d00d74306481bbdba21c6ec841379cd1aa10fa9396369b45270f084f8dd754b3bae4986b0df4dd53bf05f98470256706429ad86119c3f44449b1de6444341a20c90619ce1818c4f7b662c218a5405ca79f7bfc7e90d62c8453a551382b9e6fba4a9ac1e2d01516336b9d937178cdc1c09f01f72bb3bc9d6481dd9c259860d281e54b9abd7a69e18c0ea5ddd1a2efd7350ce38c79f8d6e608ebd266ab5e4578f3ca5c38ca2ec5396957bb4eff0ea56395d5c7f673d357d21757e85ca7af7b39f39fa7fcbbeca9c4fc63c117750ab67c40c420819bea62857a8f09ee9796ca61a32acc8392c9f15de3566c43b40e473be30ffdcf0a1accefcdde03184ff75bc6b7eb1793c5caed7edfa619744b380a7d70bfc9bd207dfa6f34c04a9837a21115557adcf1083c4fdd93139f95acae14f3fc5e6a6a6b371b0c81a6168794027c6f8736a8dfbecb1b08d03d5b29f89e2f0a903da1d3f6122b08123f0318e6cb86865f7bc26ccac9b08a3a02d1ceb05aae364eb3106f9fd6b14b919abad3321499ea093eaa662ad1da223c91f58804d27c3696ea80c84803bbe167bdcddfabd8762b621607838fdfa86237aaf2731f87b5c1e2377dc76fb693660d42adb52b0061f7ed9ccfad3c03806a19d0f2e100b2b20323b1e7be1eff675f2ab7c52f7cb5aec90b59d3f91e689664d53f7730620b5aefcd45324fa7eb67fd37b23ae69561bf70c4fa0d55237eba70514062a141fd772da92b665a2b3b819f0ee540945f4b05fcc35bb2e363ff0ce62e7f540ef568e44a0c7f1dd7e6e705ab50617a83b157ac68afc1f0b9e1668c8b95a83c0d8205d97cc454750b6569e65fd58faaae90d6eebea29b015038783ddfacfa951742328b907ca0267ff3e74e594d80dee9cd38de4c7a5f9211f3b0b7dd11ec789f9081bb21239cebe8b8ac6ea77c01ee69b92dde949d405fd0c44ace944db77970f9d942a6004f8bb72bee88c1b4f616cb1c1563b76e5566c993aacfb4c2de544cc487291dcaac20a18c499c52996ab00e1ef70509c3343b02d7c28262d8b0a929ca04b8afa6c6169f8005523c1369b9266daf103cf899e7b80a255fc78b8e582a72282f6f3f60a44dac7211ec4bde776da8562c9b6179f57582b32d9e2d7ab6c1e44e10f3cbf430ec3a4ffca85732bf41fb0f971116f75e0fde4ce93e4b974c55fe7bd0047c8aaa7a9da8c7bf67851a2c6f5594eabaef34fe84c1cfd7705e15e83ef1d379a69902dabc3a5d941d19aa86091fa51ca1f13992bae8c169c6a92ba34bd14f55535f04c6f58e80a7175d5da34d95125a6639c494cfd653478ca57bc84ad3618c010963b5a09b83a4d353f8079998e5de6917369b052f692c0a4fb27ffa8c5504faa8b894ddc866b5e8cea4d234b127372ce4dfca83172607436a9ceaf77a6c181eac5f9bde5dad6634f21b45a316b3eab25b54cb9c4d5404ea7e93c0633d057cd4b9040ec1639856fa86050df767a961aa54e8204ef4d2b50b672ea6cdc8a079a9553e8bfc29e8bb48e5967ba8c462376ab8e1b492dbb722dec6a74402cdcd49cb120b335977ea86261a55e4742a72cdb7707e2eddaf543727c9940ccc0f8c44e3323cbcfe0aa1d216d538df4ed7807830dd68502647d4ddf6beda949c121da64855380114b482d5578e010428f4f4baefa881c000c58d4c72d454e3b61dd4ec3ebf6577e329f23926a2c88bd1214ac91d55504054ba1672638e0c3545cfb58f89be026ad98d239d3eb2131107140970fc94879f271e6550d55be1afb1c48d538b7f93e60f498dcbd66e4a329cdd9f2bbc61ea1d3c11a00207bfe6ae1f956c61dc754a4fa5bfd18f6a8a166e767f5894a73242686587a333be00ea4ecc6ffdc007bbf0717c1c73285b3439ebe6c1f0456031f2e8a51f308cd093414d06abdcd880d8386f8dfe75f4c3907ae9a4fa42c28aabb8fcef40e10a0b70c6016edc7d00a72b4fc61aa526381e62b0ab35dbad4614a52bbc42f9074b12301ec4d2d73bf28b408a6e9df943885c0d2f0d7bc613caf2f68de9c28b2b4d49eb2d62237e8a469e11ef0e3c484f62bba3259b67f0186ed7e24dc566cbce7f05e66953710998fbd8bf9d77ca8b6fe09a0184086b5e2c3d07b68eb4e32e893b6572cf6528d5663df714fde1b9509411eaf8e8ed4d4802d00312678ff0b31e3949e598f50bffd9a44a39c167ae07475f9d2929f0239a84bb9782200d070c7d91975d5f7b2b07f9ac236ecc2c7d11f4c99ec2bd241b07eb1dfd146642ee9346050b1d902a33e2e8415394c8839e5e23032b0ef1f0f233e5870039bf3956b73927ce25ffa775a3ed886908cecefac6f07085da4b57537232191043896b8f573d5e5a19eee5cb0218dd40fb7c14b3dc2ab5b4d63239e53a77ea8abcc618cee39c65f6e16738628aba27a94b6cdcc792f2a6a2005a2ff165212462f89c3fdb324398f6199ad597ff50e325ba614b7f456b21a123c0022d9d5e91741c5c12a8a61a0fbe1c15858b8bdbaf454d809fad28e5ddd2cb53f145ba2739cfd69b543d32cdcf6ed08fb2b0b3cabf2949787a89053e7ced525e6f1017f1f61278744ea2f087a8fd1365ecbdd1f630485fb420d579d0c08de6e65c2621b08354d78132c9b964a85d2a3093d78480d6ad8a52d115ba42f0c8a5820c7153d179665fcff1443a5d0cf2c3a5e9c65dd0ec8bcb9719e1ebe47727377bbce2587f62a37e288c75417c174e93cea8fcd1f12456c0f74e8acc924c509187430b270a5a64ca9e68b1abb1c6dd56e100ab7f83aa8e7c46974bb754cf99fb3cb14ebde899a78083322b6ea737ddc3208df61703340711f1b3859e2032fa00f5725963dc766e870c3168748c190295f4ec62cad11b489cc9da24a2ff7c873444e4a22f5244d2c779aa751881c723f665a99a79bf9241ea8d40b4d159b2dc5dfb093d98a9898ff1343a267301f9ccd6365e66b2c204f7247d82a4f781167a7fec2ba1706b6405e16883c39e79dda764630a972d7ae1ab8b72c391644ff533a41dd0443ddc8c55c65c013aafd2b2d4ecfcc6e4c2ff6393bfe0ad1d0ca39038074326ad8054b943be28cb5ba762b2efe16d1843e91ec380e2348cf863c7869eae7b35849b49b54e24789f06eedf2c46e40173dd92dda2b25c12d063c9dae6c4f9d71fd7a5caa1df5110f4360708e491c2bdf5e20449e55804a09eaaaf8058006c09914789d8ad1a567327da1623cc78980a642d3074eece742f1aa1e17e6ba9e04eca31a127491377ae30ca5d9aaef1f2d2babde42646ba08bf522dc1188c9c29332075136f1ecaa93233925d7acd7e8ba6e27001b6510f3683571bafd7d261d742466e8957dc7e6db8158f2eb491dc287cde573acefe56d030979154b3c24db1af1dd3badd96d40c94666d4c439e81a74260584d1e449e743984f3aabba7a5fbe61f8613fc9844654042c330ec7270158334a9cb9abf2661ab38606146daabfb65385d3a63a335bfff44b9362fa055bda4a8bb4af1aecc57a8384f147b90a3d81e83785a2d1b8399bfc8856691ef08d6b2e5bcfbbb632e7bd6b57a43ba5dac141c6105be48aa1548584501e39b0dd6a3a1301f328c7a039e320b6a4ce2ebbd5266531d38ba0e6d75f20b36e45b04bb0e4250dd7112411b25c3cbe8cf7ea95dac97d185a2bcd2ae6176e42a30e3503f8e29880fa69ff5b6199483f75ea10f24e69c0fb998bdc87bc8b938406b95dbbffd3fae70e0b285512f3bd65e7ead66ecd0aa1e7584575e99beebaa1bdfbefe46ab8bfec955c142908327f86c35c998d7a95df16afc1a437e00b6d2bb23934d2ad61de6b1871f5f9a684ffff7a3758508b13e02621736984224484ce79dcabf09479cef79b3d702f9b3ad165ef19f83d464fa702e134313bbfb9a01b8818cf1f2b0fbee6832e4df4692650928ec955d0ab3e1799c0096afb7a277dd060e4be3936286205cb0905cecd79cc5d77fac3a1e3ca7b2c16dfac5c8246c3a6289ab1428cede0b4f6deb3fac06a92237a2646ff345ec99b3cfe2dcd0b0b16b8549d173c8c5aff65d899ce75077d6518d9c5c2beffe887522c7ffb95094d4aa6a9cfb824ffb73abdab73a2019b977e80465e5af4cafe013004379e0ad33b80157bb3a80208e25055a9cb9fb51ca9bdb06b71eb4af33a801e3c379aad4d3323041e92ce2a2fcc316b6dcee441b95977dd757da137708a671c300774bac4e22759f9c6801e0d76959cb09cbdee10320cfdde6af0b572d99ba3e9968cad0ec18fb9f1eaf1d2ec2d6255d8faff0c655ef748f4b42ae5dafd9094c4100576020a05ec0c0a4265891b9a48c5991854a36ed0b2f3e28cc5fa2848b34785c47598fac73a4bb133d3122dfd053f80869dc54d11c6adacbd1d257f27902f95bf356dad41c03a554e8742b6219be0f167ae621b466df61a30149ed4e1a25e9c994f805ca438f7f9bb8768157498dda8daec3b3f8aff9c2b0e7c4f93c9ba075f7da3e4d54eee810aa39dd1e7559f858283d1f8f2ef2069355bc806993c0a8c7d7be5a6e3634c688299faa971f0300455a5077e8b1fe174ee8842c9edeb2c6bed5ab034e49dd5e8d374be961a888285c87222798961fd6b78913c849305ff471c1cf6551751fa62b95bdd70051bc801129d7cd4a3719e5e7d30af1c98891d9dd9060b9c2adf395e97e86a4dd4c615422189a87f8eb68ca972296d4e9a596ff7fa957f743533c0347b70bb0a8c0d0e67872a201a32117b51dbee63f133ce81e77fcaf0af656bd9adbd9c9a703eba60b99b09fab91ff29c02b98e86267c6ff25b1f6c0914cfce1b4b9db301d8bf54d279ff719a7d2efedd72ee446dc78e0db024ff9168ec8b090488f81cb1ba5adfd2af2e32744cb5559ea71b4212e963d39b440e553f610b3395ac54610625194c2dc1a35eb9ced02ff306867ef8edf2e7863236db06a5a5f5fa25f8130f7fb0fb5e357f5ba1eb30eaa54203cf99b42d91045a1828e5a3e751a74c0d26559b84f94a25019cd5b8551505c2a2d3b7e27a04b07f324d3abb607fd55f70c791a73e7e990a6f4e2d4214363111acf904a17fa24cac7ac25aaaf85237939b3ac2fda1b32a1237adae1eeb46dd0ee532ed5740ca50d16f7a7f4e8c9cd1ec2c2da3643b977a6279ce7d3e0f15276fd1d127811cb71abf13900a90271db7beec4939e6667468ed33f5c3ff750efe3640e8d69d0d96aadbb5e314bc63f6a0820b3811d3ccd12df37dd224b9ed105d9aef54ca5cf77b014d90f4e242a36498ec12744c1bf8885b2d0fb840b4b50614410e98ce6420fd46ac8554ce2f6b4bb410fa64a280164010ec3d95b8564ca45b2f3e509b4a603bce5cfc79ce33952a1edfba8a73428ad9124c38fad7ad9d010aaedd00c7b49f7d243f5b99605958fe407af68d14c3b0605ef4b0779c8207ded430383e0256b543895341db66bc57ddd41991f5c0a02ecc0087617bb40fb2f8d1f8d362b3e67318f852dc15ab621cf5cb680ff3fab4a618e927b01b86e31f566b221ebc5ae30a922ceee59fb80cfdcb91bec9b16d18e117cb2f930119dc5007c2b3ece25a5bd888de092ea6e9033833ba95dcaf3915073a9709afb5d67a6e5dfc91906470d94cc3f55e52bad3a9acd6b40b6a3303a3be540f58a3847ca514356b7f273b3016f54378daa87753be266f4571f1df965bb43297d616bb30f30f9b5e7135e7dd37611d1dc347c4d74ae756a58174811c477b4e5a3b936d5b98830e898407861d6a0f3fd951c46b17c03e0d7c23a533354204048b7f4db5001b1473fd5e923ee4796a8973f042bbebef424b1d45738f935303bcd053ff708babb86ded69a2df30c1ab4d0898daf37a175fc4027b172cd2035d10defca3685b58dfff3061a2b16c0f1f32892a415c2aed4b9c2cde7962a0f742db87a01fd96e0cc34c3a754a95f3e964f4209c5b8a09f056e18d74d43a4bb29c6a1c612df2d21a51df4379494af2fd89bce0132f4d363e8a97c9b4d0f93ee9df8b3957a73da565c979faf3571d4d2f0dde549cc2c841b2e193abbb640e7c0238c1b33091da5228fd3aae127fb6fa79a127cc3bfa8215136480d5b4dac22668d25d99780b03245706f017526708c055aa095ab4dc2996d60d9ff8cc5a876909c8ea0fa4b8334d893f19e0d17d29717bd3711f2703e9634f3fc81b25e3582175f83502c9ca8a3f53b12f4c670f54367ffb7946bf30c506bcfa3c72a59e21d2d0ae1e0d6355c812a412412dc09d80a666de7d55b0bdc719863a1cfa2e67ad20d22eea4202f2ce5b8e65030d6c59a7a0958f262577b628f927fb7b5c81c8c33c9d12056187d704b53df3e6da80f315bdb6c273147cbbc856fe675749b631aaf413e4df2b50fbcd31ec67ac33951482194c5c2cad976b1a99ecb893a72913dc8866dd9145420bbd0cf974724c8bad5f75855a3de22f0feeaa1783683ab6096d76b7022cd8d570c1da159c9f747667a05691c82683a8c0ea73a83bde004ae4db4ec7bbed18b01b4df2c915c49c27c4be2482f02c6ce22b004ab988c05b5cb82b9ab238dd9fc55b7881b27f4626c36a75040c72840a84f722510dad0ece2387c5ed00c8883124c3769dc73f9b29922ac7260150f6b627712927b4fa71b3f7e967f0756f73a1cf01dfb92cfa3f536b02c2a7ae827735331bea67cdbc056a2cf061659738d2b835b931103866a5455b656db85a90a8f7bad10a44eb4fb29cd837bd6fb92401ed680d4b249d9ecc3b51028b5e65d56c338f3d868113506f7fc0667f2c3b2ac22f9bfd52aebe29f574cf58baf47cee27c282171ff93158cc351912a27dabc892f37b1d013df78f53d89841df75be2d34c2c54d45102cba769917311d6b39f84e93e710a87218057f8a68079518559bd31cb7bc6b4d78b8eb3e8de6a7ab62fe14722eb22855ad4bea6f7c4c15f928e2a98b6555b7d0448938baabf53a6e4c2c2326d3a1c6912014cd66870ea6e612771264423566ef51fe295b76a666cab1673931bc3959cf3f3e2f7d274d9155a03101e7678041dab27257750d1db5209039312e6cc9f918f54fc109d0d41c35faa18b803cd83e3bd3a60b00dd6a7c93b8f35b91cfe975dd9348b6d389adeca1d5cf526138b9cb70ca22d7d9f01c756c9ca2a4b9d772d193d1a1535f89a75ba9632d3f1f8c13538be824f229767b045a573eec6b6641faf871ecbefcbf2926c5d9bb10283343acb4f23109162bf0a9a46228a13819f3926035be4f2029cad864a6d4a2c73aad86a3f9c88fd9a786779f54759e35222444554bf93f86169a6d8c6010739eade00d579e05f1fea64c5995f7a6c6a04f04d58b3a21b19eb6922ea159b7bfaa81fe0ea6015831ff7ebbcdf34bd0ce27e93f077fd2919a5b350f8dc81ade509049e8557a2a4878e4d910ac25b8c84f90bb182edca61cd7dc05695f56087e312ee0b28508e7843fca9351a343fbe28a7db27b2f9eb68d414d3c113bee8b8611c149c046e55df8c439daa7ea7fdd749f4bf207eb918982d46070c6d7dbd0bfae5a458ca995cbea5b09777637114e64a4458c0b36b7593c928752fce3442fc13af4ed575c4f5459437cfb69cbbf884a8d5fad0bfb11b16c800a3ee619affa81a1c160d090e53969eab0fcf0fdf56681745604ccd577a72bec932362811eb3a4b5a090c0847d43fe5ecd3ea29f73a288fc6f2f2962d8cb1b6b97c916224d9f16b1471f96d9ed888cacf4a01b21f74db11cf9385a5efb9ab903f46a3633fae8e74cedd6d731a5ad4dc71390a15c8b9dfa81f16d6b598dcd6b4c9055ec2eea4ed8952340b608dedf5b42259b7b9d2fb7ba79e2dce9fba24fc261d2e1843c22f02ecf0ac1d17e7d5530062a9d3d9a85f032dad4246d049c850cdc1354b9ce48c181ccb8cb8608be6b1cf98d63c85593be2beaf4110ac700b37f4b7ff78efb49f9858bc7d4fa6ae706c62e86141a037df132d01ff26d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
