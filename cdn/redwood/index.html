<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d6b69f604b4778bb439a9045ac5a11d6dead64f89785b23fa9df1ce7df90114565098a1170f50ed1236429cfbb8d37e2d7ce5bfc23d88625a31fbfc30be4bf9acb5fdcd03c4785eb9ca002acf56f9c1b821715356699a9aa8ba67ce3f1f6987b123c872ee4426f4a513782fba1e1f340cdfb51fa2b02f1d93a8b21da0dc7b289ea9eb8f788c6ae01a19261fbe782747c2066ff288608c0f285db268815086d098327ce6a64bd53a6d5009f3d2cd8f01e726ed64f25738cde31bbeaacbbf931fd6eb2a59c9be548651550c48a7568d004442cf0d9c0ad0369bce46b24e4f1e7ac18ecf80836df91ff35d114596e656ae1c384cf285bba53595233a601ada9eb71ee526aa6c9431b507c46d6b48347d0f03c1c89baab560d70950fd01299b54d970046fb3376b4ec3067ecc3e1cb56dc2e88a32e8ceccdc379ec243529b30cdb90e86b7cba11ed7a44081c01457edaf7ece5894d7c1bacf85b00f7eaba38759b07b7e5717eda3f5ec5aaba37f46ab01cb13057f4c5b7542a9a057f361bb9ef0c194136679433732ce4f4d935d58e22e0cd99c4f886c5e327a7289b120064355453a9a9cf25d233c8d45bf8c1e3c6aa910d3d039d23c926a39d46370fa542596d896b3803eae66dee755c05dc2c8d6889014a7146e56197b10479bce786112d67c50b364e1e8071eef32fb91fc161dfa494d00abb7d94041a58e8d79882585fe1af0201c3e6b4c44f205e71bf3b0543866287235a72d3094bb6c5da65b266235179325ca45a7bce531b84ae66f9767bbb854c73c930b0917607ad32a51ce3ab87e1a0a549a66d105cc983ebb75e2195046d7c0851d3c3eccbdfcbae225a8342fd10d0dbe4c6136ec4e17cb122c2109e087e8d395c76429d4eb83709e107a42ef10cab18427c046b978c5d770e55a9fde6adfb6042e3339167790ea91dcb421a52155226fb55c6b11e562ba0eae302083e9e468f358b987206dbb1120996a88a191308f756a380409b86a710e0ce83753d5a01ba87449814048280387246ec9175bde22e0d561e7a298dcab0c092d582fa4022eb892ce6ce606d9c4a208c914edd8e06942b9186338ffe8636a4e207080dd687e7374c138679c1a6f1b04b2b1f7ba3e6dd328492c8a5e0aa54e67d4ec709e52c189ba94ebc5d3583f18cf21d8720c1d0d011c0fc136c3949ebe1b0c86daee42c0277b5b2667e1dca01d3128eb8e4925dd644461682dc37b839fd470d216ace2d2ed39849b8f09262c0bba3ffd94ad37487067988fd9ca07a2e007b4e64b8fc04effbea4df6404328ae85ce72a576979cc216cb310eba6a7dd274c021a46db47796c47ba13590f7d8b7334cf2f83b36688b724fca462c4b373ef9f4bdbec65e342c275ca51344f18a5705e1edfb33d88a8a56fbf8962b43cfc04063cd36feaa68113064695dcc449420d39cd3cc8c62036fc4550dfe3d1174bf337b06f44e78cd2cf462d6f18e195e102542ce5a935b8a68bf47de6404d714ab32e5c54b0925a98cd76a81649251179db3978c1b752e14c996a4356ff8a64c0ff8248ecf423d59e56b3a4fa7f32fd584a39801f4fdafc5e08ffef7393463eaeea813b80e92a4cf0667878c61cb58606781a1fd48167713189fa54600ce0162624cf1506fbafc458dc2411102f436e5aaf76d1e582f36daf386f4e9a1411debfe19189f396e8d83f72b736bb94bb028f10100314f57397cd6041988e67758270b80a87fa5c81467b1b08e2c782a59db96efcc0322f88840ff777923ebe6a38739edc781c88e25851f5c8cd48aad19c8239f63108042af2ce1f307ff7a36a17115bb3f855995f51379438cc114105c7a36cf8d52473e7a991542106f7fe49373427d1f284db8014ab4d0657a0b4676b35fff1af41012d6439ef2e79cf7ffef0132a8136eeac444f4a9b064b1a870a33aa2432bcdf809de864b16eb88e7fc274a4a6599e5072acf8a87b7b2998d43cbcb7ec2aed8c56c3c4edca19e5b9acdb7ca8c7fd255a868ea20589a1a024db36db996d56ad6e5c7886aad820627e88537fbf8852080e78aec773548dbe3d0b3295b1b8a924eb9ff8206a73a6751cb01ef4a2de6a4edd0a8688191736da0340508952a4cdda83838a320f710eeb1e48445cb17a11febcfd8a1340ed8f16e5f0e66a5b772744bb142f7519b603dfc4703d57e7ceccb31e4d0f607a7f4df8b57634f4fe1880baf16907cc8ba42a91b414d2522beb2489613c4b7b106a5d39600048ca447721f9a76abdcde12aa82e1d3a9dd9a1aa985fb258be5dd0057257a16ea585e06b51c410d0c124c798d5f6c67bb2e55798cc9178ae3f1317cc247a924dbdec84e1ef40a3f0991cd4959f76e93eaac702e2e22da1a542c77787c11775ee65198d3ecb77b0b72b675bcbcd80d5a62b8f78a2bdb5cecfd09e95ce5ea3fc2baa546acde2a511ee49300b4b6c649d8191808c181cab10a67caa1e80a8912b1f74591069cbf94ba2d5d8889e01b77a48c7c3961732ee8cdd99e179698586e9c053685fc6ab1b71865401bf0308f540f3db636091a45699b19e0760312af43228987ca1f68c0ea721f2e3ae0e36ffdb0ecfcf46c3a48d9f80b1042800384b114761007be76b999e61d04dc4be3de9530c99403f7cbc867c2480047ccd9da969541ea5463dd3d34d806365865fb142a0987db7876f250a24ce6168a57ef40898d79fe0cf6396499ac489648e637d93f016a59888ca07ef2ecf5a2ceb48490e26ec2d61c25a9a50d09de221c22de6ee1b84684574bbe78440ea8486da010ad05feb38c3eb2674429d82bebc3cbf8552699ecc20c3f08f5f3b39bdb6ff15bfea6916403d6fa0ba01e08f8cb087c8414774fff708616607d281b703e984e36ec84195758ed421487378b035db8450bbd7d7f81e083582b071a363c0b7bcd7cb050ec85d23058acc9965dd9fc068097a453d2bbbdb29f210a2a49c8d739936a3576dedfb27d2ab419b4463949658c65bdb00e657d92ad877c85578efe9dd586b51f3dec35a7d3833fa6e94c6c1e616f7b5b4983804ae01d263f351c2dbcc2f8c867ce527ceb1d0f2b5bca6cc8d97f5f552d4ef4f7283af51b8ec6a492020611bcfc2834455205231281fe0a714c247da05cef5e4cb742a4a6d1b63258dca2a27bed4efe0ee7e47757d594b1beb0b0688e31eab0a39f68e9cacb9be8b4390038b5affcac59d6eeff0210159d27f549cf338e7c886b17db9844870a2349f2412b2a916823403c69227ba8ac86cc7dfed891a4bb50dd48ffa6e182e0b5b71fc559d85e04cfdff3a6ab5c312af89a9f3c5988a2944413466ba65e444cb386b5ba78cfa6f668c890d0bdd63dff2e72c07d54c9f9123d5ac51a94f7c99116b409250eb814332ac99c5a6a0e8e2dcc03ea7f4c70926c4fff1bc102726d00fbd7cd1257ec2546ebad7d1f1e372d5c0202fe8fcf790a14720b192f66086cc714862335fcc29cc68ab52deec1fa670b2d351423d4842b98d7ce1d86f78097e2f5b54f8a7c7cfe0d3024ddaad4acef57f713e6d261a8bf9064b6a90e2b866b9f6fdc50d6ed66b284e9920340b36de2c3f7ebe548aa5f7397eff0660faab80b92a5205917244e91353aaeb958dc788ce9da3139097d0e72c59e0e252a31b16613b7bf6508487675e734943726b3c75e4739951f8515c7d6405553212138b2ddcb2abdf3972b6b56869c7396abf83c65c166c6bec03b6af073c33ac9e8dc950a8fc4590bbb7c4240544e95666e62f6c0461518d1f60904d4075551c417ae2e461b7554809dc2387944410ae442f1098493fb5832e42758286f320f8fa4d0164faf49df4793c0dedb6a957d84e908b41cbb185a85d4b23ca1096c586b43e84f7c5df9acd5c176e75189a7b819736258777cc7c7e76010e509658a7a5aa714496eded22b7fdfdc2e6706286c6693e086a3bdf7308b0764e5543ed241237c61ae1945b12b8bc0d2382cbe5857b84d44a02183b4e9f8a733894ebb13b4e573d109855db16e6f51c8c3b7dd5b04a175d049407f1c7b99fd942b01e0b85fb6e34ac4adecf0e245456f33fda1da6126045148f8daade0ac0c335d3772aaba541109967bff91805aa65dd3f7694444c48addcc108d5e7b484d9c0b083c400c265e7483d7afdc3948f5c09d542c51a4c52a73469583a62d3a5dfd6f97a68c7a771ab9281cdc4a47d05960adaf5f210d3dd054f6852954c2a3bcdc7fc44badf96eddeb1238a08eaa64d3a817143b64f2329527b0e5c3cbf30aeac6f2dbc62b0e9531e0078b44c959e0b688f1444a4d90f69b670a536cbdd54932f8c43a49cc1df9c4cad028c98b360af6b02916c209211ecedd35398096f1c5e6d3bd2550e73f1798408dcc19c34736f93debd992263d2028e1d1d1ec1836049d61617f5491c239568e13c3e33d18098c6fed778a47ac3a99eec2dd1113a95dd266dfd190a57cc1dff1ec21839900dfc798abb4e3cf7a1e8845f2178a2b2d18646c58f4a59a94593d90445b036ccce42f9f897a9e6a371cea82c3c18c9df729fc6cb83350a7effaef15cc429b2c5ef197c79be5fc6bf79da89887633726d025aa306f1a335ba09c6cbced9943700e6868d7eb9450a4ac978ba34a3e0ff3e4c7b602a7c8718ce1cd5e0151c0dcfbab73cfca79cc022037f0e110e642ebec0b16124df031c1aa08579a650bafe9d070b09a3f5ba9ddfc2f7f81c4614fd8e690914a9d781f9b83be0790bc0248a6e3e7653c4df649ce4c7de823ae946ba88597b68fa64aed718f29cb01f3a1745449f445a0f9086f51cae641bdb66f211a3445c22cc9fb0b24c853853a8aa4c7420da0589e9daec03bb65dbf92eec73ec6036ed900bfbe04e84b853208ece3f2c27a11e1d58fe790513d03bf80266919e149d3d6eb328d749d7cc2f496440895a66424aaac37d9ff92e970dea51d5f73d519260725c7758506b5b94aec3ba0cb265c7306218c143ef79d8d2f85bf79e390f01e6c786a1123291e45b1dc94698c954f6ffe9efdc5482a085cb3ea6975dcd50062fc13c662ec9a8847cc4f727c41ddc85e3c45ffd590ae5dd8c15d2f4a38a7555b4c4da66ebf3216d22782d7530b6ecb9fc07885f204bf1567797ad80fa75fe621a0e0e33fa14b807ef4146d9d6b73b9e1eaed5392dbee609e5ec3c861bc980d95650a77bb8c398f70a416514c32fba6441c4121332d4dbed6ca9fd47983f4c1d829a2fd940f43169439bbbdf7e89ed5bc255a646d1dd9d4160d73ea3afc21a54c749dadb50fca0c396ff569f18d6db83c6cb32dfe170978d80364613a7a659c7df6723b19403ad21574535101608deac203c9d7964dc0d959761963cbd8a405fce4c89a0b911371cf6769874bf6ce0d27805aa40dcb6fbcfaa8f63d654d41c7e38ed31c917c3c6e05e8fae91801952c2c04c30d01658c76f6a8a6ca6d2dda8f2e9b41dce172be1ae5c7ca00340f0ce60661caec5bdee4bbaf40a171d33e2781a2b6553d7178ca87721f075d56a57c20ee96c57e61430a3013074a469275f7ba919d8408924313a44e5caf27a44d3288228f080a0883c2bdc4ebb348cf9001877f65287ee74a2b79d7ace1543b425bfab01027a9b63b4230ebdb8f1b302e9089bd5ca0e84f40c301615d5c8fee6a5c0db301e18967730572b6b9b44e26056a85febe39b9ecede596de7ce6698746a095a673859ca6c644791ed677ebaa7419cb0dfe9d8b0c5111d9140f13d40039ca5bbb0d87c8bb440a5f9f6c9c6dcc115a8ccc51d1a260ce927a4bebce32f06555792e8d53f7a99c737023357d28928cd971bf071db635a52465bd181449448d3d928ebb1faa906a495e7cb492301e50d065a35984009088353931d3109bc4b0559df373681050babee90baf5a9a522175675f14e9740cc0cbeb912afd9d56faf2255fcb561f11a287f12a06adb73f6b1007e06b91722cdb40a324328f14a1b3deddcd171dce07352a50aec2aedf5c1a61915460412422dcda0041f057c917a232a7df0751863d6692fe2b48308024e734ee372f2448a854c9fc8be297ff12dfd2d231358a189a37d7a659fc092a6872bf643ca127792c8e7d9205caef043539cb7f0b65e6555de1f72d8339d4754b98050b907b11813853530be4cf455bb1a1003b26f54615fbf1cc66ebadfc8dcaff34c91bc0f7567ec75b695502c7d415d88c7cfd9211af7cbec7b69bc7d29a1f3e1066b4d7920565bac3eb6e5eea84626c4a09abbc0b08c2410e04ce66288150e5c43a3c54763d65f6ff23b135e6dd3d13bdb359d7debb766fe3893ff8303f632ad708f94f03b78f30d4746eedcb9e1349e53784e2dee607e4169e3403983522bc629ccc3a5591ccaf09f20e52819c04710f5eebf467b045b9bc3e240faa25cfd86197002984b61b9adfd8625a30cc162028dd2230c08785595d66814f797e9425a09092687b822eff782c629c0bd1dc973def61ccec63b1b159512dd0f39ddf93584bb7588a07db7062fbe26dd659d1dc466172f34ed5f9e003ebf88adb81da957a0615f910043be86ea48fc6bc16d0f6a17902fd289ff2eee870fb8614c7fc862e7dd1bc431d567540dfe4c5d476f52eca7291e8c07f6ee384975a0d5630997933ae8a46125e4608ee2f3daef03555c0f89340366fa44933b227734c3dced47584875eb406946705830a3465d974d4d3e31635228c4110a7fe90d8d58ef24f03aee5117d68fec41f792a251f40ebba4611b289d28213745f40bbcba77315150864bb958f9b36e2a9f5f47fc5ff9a26eb9099885129c3bc955e7afc26cc507a1e963f389f27fa049d49ad61ac15714fb06eeab19dea85f7154d2ef0d7d0fa6c2842cae5380c96b4bd623350d7f614b1c2b649d3477904e1a8bb33e627a1fed29f42f3468e960df0c1164f2fc6bc422d9db54f3bc70df9564d1c82596680386c14665fd3aac86d4e5ca1e081dd6bfa39796962b673a33dafab05ce5f2506a55a6b4bd4ee5e2dbfa52a80aae235e053f361f018de2715550b5a7a7b23d36f8e8a1f28efa2164ea912efdd28338ee0bd927ad4546653e8c8b304e68c71e1758cd25c9f7f99fb716e8dbbb7fedd4a468137d307fe0131cf9b049d5fa298c9f62fc1e540b2ea22d8b03556fa4f2eb632cc80c71cf0eee01bfefa09212e49d7e116b4d2607c2bce069ecf7f348ded36ba5a0301dd17ed5c83e3842d2240f14142d260db6f4fa4612e927176ec8d6d62706f033b8e1353ab42e6d9769c583c83457f1199656cbfce9dde58f4d5d2b2ca7bc9dbcf4fb9bd4fdacc8fb566d458ff81f6cbed7dd8f27f4adab28f30b746683db35cf1b1ef65dc92cc07727b2342614c9c9523ef5acd482795e37e090ea5b0cd095f771b06f7767b83a90c50ce8636336022fdf76e42e962090030ec17da7e057fa74754e056ed86bdf6d051fcc1bfb3ba5af50afa811804effdc560ce6a0bf9809008f993c7dc5bcb62356a5705807759fda43e92983374c44e698a49a13f3d813ea758567e850b7f9353040e2494017795fa3ea42861f74335e2532567693d08e2a0337c58b1b2fdaf472192003d0b95fd2e0a91fc614afc5ab1f9af6259077618f4bd2021de375c12766b49f0ba1f6d7ae403e649bab186847735ac2e333cbf7401c23358468c3c9531a353c92493c65ce1b6fece836fca2031d177a45c5437c79289214852ca29814e279d3f1b52a7f4923669d4cc5a05c68cb66fbffccda33fbb81f8f5645c3033504513edcedb9651859e81aa520d64ace1285a0b4362bc0f06d937feeec179972347f81f5e24549ac331920834edb7403e2678c0617d39d628b3c95ff359e4a77fa2a2810713f793ccec3e31e51d2dedbf94677ada5eb6c75a73142ab777d69507a7be4a4bc27ccf30b5a07a01377b9a4cc25f25fa35bd23554c29e1a4194108a667021297454852f37e95d6fbb0c8a041d1d1cf284aa54c181f3441659e264573a52b47f326d5593e11a0aed283e7adc7c5d562695c97e72ab9ee148af79452332a63cd490dbe3fbfff9ea08e07be985d8e7e0d113b3930116d35c1afc9bfe72bf6cd12638eaf17fd9f1facf1c8e30f4e5f60abddbc90d2f415fafe20e824a65a4f65c9aa498b78ef89d1e6b43fdb99af1ab1d96c700e8a050172de0378084837eb8dbc5ac36045cc5ec0028e69547bbbddae212de3747de11b2d4234d03c78ebe527d4e0343efdbe2212c3349cccd6d66f3c10a0b7680cc745bcf1fe20bb81061c1ecb2af9f645cf5e58782c712743183d846dbc3701b42cf4b5c76c585fd2c3adb56967d4a97365ed1104b887250ff05db289727231b6bf3f9b67e50d362c2b333841826db184215a72adf34897aefe382075b09d0b86944595542e9f72d867ca481639e5c16d188abfd86f9167b539a4986212fccbe43466e71eba98e318aa33cfcd752a50ca2643a2634565a94b8a11a86b2f6b4e1c0906c855448e1ba3ba9ceef2862346dfcf4575d3a38c58369efed575f70b888feaf42d13b2afe4f2f0137f6aaa9313a161ef7feb16d8868d40b059d562d76a09b155939180d3e0c73eeed4aa2aa7ba858e5c190f39dcd8690055c3b163f86de33c436d96f0ea9c96bd43090647189440952ad6e29dab888809a1663155cdceb6e6ac6af496a30de1ca81323d5640f09471353cd4c046781c06e5dbca08d8c60002224c1aad0d9f0676f5e8e80f9048966be64ca9a2c0d9ec85a327e812a5759bc46498f8196e0a4f679e34ae3cac6c2fe61d2be3b136e0218f9d14a8986c2c945f24a2d2b5e4ec327b74e02d1b0b6f39e6c35b821123445269c8dcedd890e65bf33277c12efe5c6babdeeeafd8a5f0f411a73f1c2ec74408e869a40d25576192a3c07d20062defb8dcc76a3403f978ecb361dd2587267ad925d55e0517ecf7c46e90195ae037b7e27df55c24913fd7c80b1341093e594ebd70b44636fa761548dc47dfc108f444c3e97bfe5f84cfd2193d41829a2cf88b4c86b1652d3f8f55841c1e3d13cce1abddd53c1176da82ffeb9e98616d20a1bb60a7ae4422f09b0c229838a16edc1b706a1c48bc2bc7cc980bfddd2f09c778ab49673301f2ab2fceb2f786b6268ea81a4eef6c7eb3b87b40d155c77d8c44841a52d8836ba4f8a03050829b071b91f8f583e1860a597fd7cdf2ff0b3a7080da0435761c59a3b7d2d1ab0c4b13c94dcd5d7718bab7a41342b45f9ba4dc456566933306cf2f3daa5b881de8202fcd993bb4e2aad4144624778d713e86055eac8715501b4809507d960e80db0809c709bb1861115723dcaebdd359371b0daa595bc08684327b79ea9d43470f921b4611148777186bed6499e8796879dca5bf38a5dcec519dcf838512b139ce23710803f97fae698b1bc6c97ebea2381192507ded21f0907aba8b541384a66eaa7ffad976d84994e26ca402d979ae48401ffeba02bb894f1c94d3b9437d0c122e4af337aade1d4a92705be8de5b2b3a386a6bdba01d238ddf4da83e7ca90f28f97d2a7a96c3f1ff1d226ed5c28dbbb683395135601b4c4467a1d05b3da432fd03794ee1fa589bdb21b3ad1d5ca502e099cf5350666f52c60db0c2613899ee4420d0a81f9efbd38f1bdeaa1ec8e1eb9ad623015f3d1147b3f4c3fed5f5f24bf3786578b7ee48712733923bdc19f99033b8891df4d76bfb75fc28799d1facb4652f96a74adb651e871a7668b9102a843fbfa601f75482bd9b5fff770989eca94d70e0b3ccdb4336739dbed7bdefced253db21368126ad2e71223027a119a4721b8b9b68409c8cf04200f88819f15af2cd91df21ab8077076f7c5e32f1df219f372adcd16affa1db6669fa2d3656aacbf4973e2f591e7caa70952362fd624e0b4d66bf465c0a2da68aab0843c689b982011bf1608c507cf927d7ab956b1ba9c7a00915382c40cd9a8f7548b4e22ed032b806071cc4145f9512dd83b785f9710c0f9bbeba08212ae551119e7f49ffed309dea4408c8aa3d97da5cd2bee2e0fb40e3c1b56ca82bb28727b238746c96ca38dd3b6b7ef3d2a167f7bfd4cf5f725330f24be600761395949756f8c7d5665d35dcb35f5e3c32267334d83e88e2a2528a3d48a69d4a73edcb5d08b3ece6675261bab83d2d73ea01e4e52f3d42d8bd1a0b2a181982e083d11ff6d89482f59571fe69c2629ddac98e64404a9a2b658b729fd45dfd46774651e077e7876c4413ff364bccf2fc7f5ef0423e50a91952beb226d624802a32555af244608cae693f8934cc42fd0be3e18349678b20656e90bb9f4a5f3ac75aaf13a06a4dd785e619d75f6a8e7e1fe8e0bd5d67e677ba956fc38ede5f534390e79b721966ef3627f2c2e22b3738da82f6a79b44fc0580f438d2360c384f17030c1f1959c45bebd69382906ea7d69af9265eddd8af794ac763c591c319e0dde521a738ec065bd36e75baff38119a727718054776fb4a6fbd51d562f37228c7f78392b9b4815d8d2f0adaf012c75b65cedacdbb73954beb714c49d9f462643ae895a87c0650e06355536e24efd94bf04e2c6b2199f97a6a5075a5b8fc89e63d9c83c1a73818a8e3aa0e1f6b81d9999a44b1ed184eea65c065a163c6c07cfff5fe4eda0fab6ec230d8cbd9295ab9f0aab8933b850a7bd190993be09ed2939d064a08bc5263154731a4e48feb51c6117a049f1160b3dffd113fbf90a3ae20305f0dcfa97a6962d2e815aa8292c55535e34c6e1ef1a427457fecc1e0a08696dadc5d4da6d0f1b4e56ffecb5eb9ca9bdfc2a992e50fdc6fb623954b734e3c1e3ffb09d4d6c2f93e17b41d7082ea9da13929e5284020c5b8baf5065bf1bebb28995d4af9da0d63f6b8f418948a23b9fbe2c6016f678df76d5cf2ec57e8ae252d78d5bc4ac54ca8cd3d4cfd13871467afc0d6777db260ddc07113f9f27d3e0869c5ba23c06d182eae2861a390f3af21f7dae7f24e6b6edc04313dda68bd1c260e7ead8da8185dbc421f7221ff8f9bec08b9c5fbe90e7b7531a5c9305e946b10fca258f264f3476527cd9989ae69402551cab38a54a605f00c016b185fc7aa3de0e18eb7e0eeaf7e2e3386a89f6aca09d84b5a9ad117236497f7696b95c2d82ef27fcd9d5b56adb4fff4c2a43ca56f32ac11c7fadeccf505672fb80662fcca76c976b880de785d5911451d43e16961e35d8d21ad05d8cef4a4fde56a7617887726f15525d51e0fd8b801615448d9bd71369602f0ff43811a71d343063ed216c0e4f86b8b48a55e4d4c9f91a4a9e5605e15ba0c8615429bdd3f9aa35690b1cba50fb27b84392fb0994682a734ecbe690735191fc7f5bd3aa28e690f1d548677f08cd405e99b85b5e92ce6e5515221644149bd859864bd7a556152f1d05a0ef6dc832072b3adc143ad003ce5c0c2ca291bd98503840b9be5f60eb3ef4cecc5c2ffc1e98d9c71e8999b7d3649c6601da3933b40232e262f334efd009f462301bece74da684f21efb2c6ea60db6501fbd7714c252bd1ca82ec6a40db496b35524a5e43cd436c8f76c4edeab642bc3360ec1a93bf2ebf8f2b5a9bbc897b62cb5cc0dab2f13eb2fa4304fae7b55f03146d93f41f5183083786325812d960d7820472724db60eb775a6d57767659f5e4791efd610b6fc4f74a8babaae63f967a154f1ae62a42b363a681e852e64ba15ad58945c1ed1b6f6844090525b6751d6ce7fe5728770e7b194ba989afd20687f9ed992b5db8a9f80af5504e75b486560a6358670b5060bf6cc2f08d934986ea7617e6c2411418638701f4f8926397611deb4144d923c51e03b733a3bd676ba9ca33fed81c2a79088edf0c5157886cc45feb0ebaded7ac7e3898a202beb6606c3595f8a1ed55bff406d0c5e4a7aeb1e4dc8b259281b9e17a0e1de76cc9a54a8713326d0a2990c14ce359b6fd8a8cbae554e1f82e43c844d6f24f0ead1871eb1c819e75a0effbdf3e6b51b7cb425c2d171a0b72b5ccc7981b3b6fe0c1b9d990e1eccac61e369f9297e24f21627f07c660d5adad98376c30384e2c36906552f7ee8709977e1f63de95be2be5436398531b5274bdc632651c3d90ac7b273dc3ef00c92722b49b179ea2b426fb4856cf1cde82fe5ac154c30f832a30f4d0b6712b902136cb4197d3ddfa0309c149c5265a1882b881b8ddfb5546f72f1b7b4ba65910f530be3e9d37722796c2f62b6796179febdfb8ba67ea06a60110774f0708a867f4b5817cabf7adcbe771d8b65d35ba02edda5420db1098c1cbd40d2809e109862713807519ad02b8efb1919968715d239ac1aff0680ab2514e9b80877b5e9a084f3e2cb4dc6976a8c620ce1a636b884ce2d178ca85be82530717db70beb32b81441a6ae11b1368c6e6210b941153cad7b67165745156ec5019de0562e892905a22235138a7e7e2822f75e895b1224c48dd946409d73945225c9752f32bde08eeb28534a120e6cc5c29b7ee7760bdbe05faa02160876af367b947615f3beea400ea459f1b60402138e94bddda41b3057d89c3474b89247c5daa398eb716176625bb26fe220af76cb6471a466b9e0c7636f5ec2ddd58e379ff5d973091399967c0fb5d2be6efbcd9a4fb156f7266aed60358700b16ca4599a0ea655486d7fbb6d3d7dd3395798b9e54edfe6b5127f4226764df6c8d12002ac89431a690d57d04df0aeb82771eef7e89bef140585543a7469208365386173f874beea925192ba6f429d6b9f5c6260cb33d09134efe1343dabd31a024baa69aeae880c1fb30f5c948225c4889edbc3ad1d18153347552c75a33ba79d4d6225fc612af4c893f4d5d66f7cbc7a8ba796941e1a622d9fc46b0ae943d376748d48fd2405a377282c8fdbfb3b2565b3c904ffbd46cc400f3b3adc696a75c3ae50dec167426e46615c5fce8dab4d8870407c71d7ecdd4a1cc4767f90fa73479a0e6530f90e2976f67a67a089a6ffe1509a03a55970a63a953350950a85369a2a0c846dc7313549d4a40b4da49da27b546414d38afe68a63ea745a5c06748942a64284a8d850df40e91e348c480cfdb8156f944f5c80f34b137460f005bc26486f5cd684f79bb792a87923459721b23285f925ad5a844c1bf910dd95f78903a06c2b4d75f932fdbb9d0132d1202a7ea250fc8d6deb2dc2b771997a0e583281f56f20788964c55a482713b394ca49f8282bf57e0450b6cd8fdc766616a019db2af150e9ed848c0813f6d8ff16fe6045727c0f439c9980577e9d40dbcb36fdd40fbfadcda121a72af27d3222f951ee7ce147fe9fdda4f9fd829fe5e20bab4bda49c29b7031ec0171267447dca0f18460291fd941f7953df7a66c8194d84e7b7120d8d717e08a54bcb9f967dda9a54d04e259e6ff504ba398c1bd16177701bcc660d1603e113672c08928e08f99d878354bf9c548509e7271c21ad11605bc4bfdc2ef48e6ee803aecdfbfc8b3687db7744e721ea9d9ec4bc992e85458f3246a37a434982d9766d6c27884d16128d9845dd45c3719ce8be2340f9df20122576c2fbba51126509d66bb32795811ef34fd0b7096802cb1feedea983bf083bfcc7a514bce61da69c05fe0656ad58c1c48195bd3f1835ea4b1d3d8a7b74375dc200a2942341712cfd426110c105a931cf337c0748ddca6f9cfa42b9ae9097d5fe6603c7848734b6c821f7c763699586f41d2ca91e0ddd0d89a4aaa64431f860a392eb92b14a6d0c7b28338d7b80b34f92c15db40265f05e308e275306551d97f5b7067ab53124938c636400d9bdaeb46797873c1e0b8f5a1ede6c3a08abde68d9a75a7c4914e3083b0bc089b32d519200745f338fa5b173e5541dddb3a0c32cbfdbe7701eba13cd0e0a97601e2986c691d46cbc49da3b92978188aaf0caeeeb0709a02510be74f0ee068671cfe1e605e17e168b7487cbbb3c3eb1cd01496e7d9a306b0b986dbaf5c3e334659b93f5bcbcab8e562a3aff795f20e11eb297c9465463a6ddb4a956d271c4926d15e5f0c15b5b413bce44612ff7d2bf1624850898e34ef2d83b56cef20faeb84eef007f9e664be340d6278622722066863d519a785d1096a1d93cc7a4f46697d3711d74e470ed07534a60e0dfd4a7f23e552b170bb932de7a5006bdff610ac7514e6c4a0686fd3a9fbcea960c9f76df132f316014cf300567eeffda52b071c1e858d87dc1c726cdb0627739a38707688506db319c9b8b2bdf36908dae048baa58ef8ea1ff1c7341618d296c584350740dead4ef04aca9eeac2a5b91e365f82e4819c138fa1b07cc6a70f002879b8972e0aba16a8aba9e72a5b7ce3d6c14ee962681c20271678bc1f5b07f05b93a3952f5edcb1078ddfa9b028d577612d46cbc194e7bc6ab509dcb18b8bdd9a1a8eeebf513d514dbde7f79922dde51b778c8fe8fe8c3babe34126fb109f526b5237f6bcfbf81ff5d5e12f03bbf08ec1c52f549a04d8cfb40dbb759b7062b2236a7fafb54c8c1ea29ae2d80237d3879ea619cf0fccd01c39603f61d6e882bf4a5093a31e195c3d5335a2398efa54ed33cf77cd98134cc913871c4c6f3d8d6200c6be9a5d061ad97856fddd0f0e06117501a78ea1b72026df875598df20f5fba72d34b2f37b6ec570245c1d8a1d70371f512c6b485685665f70c93a849a0fd9e6d9e1cac59b8d131670e34b28ccbdf79ed7d188103d9b26020ae1bc1c2ef0652b5e2f34df780a24c55189972479cf2192e2c4f3d00bf8258e01e2ce7fc1f477a99946e36b3be020c60507ac56d1cb77363d98aed02db705cfdadd6e4b82b44a05aa075baa4d8dd7bc3d2eb008bb3a09599107d86d9f43b0d9087fef31b89da438c44d63851736aa2c9328b7aa9f0cd21b43d5039c8c57078b37e574f90033d75ff7e0d977306f5d8fb60f089a2f2590688287c503697d9dd52e62e0219844bfaca612309956c5c981e74a35acb8beb2c0922d76edcce9f233d5559a12c42fa9df086d1b42f8fab395c36ed7615deed3095d20edb1c3e95531a6f8a8ff51de96e596d2fb41f1afdc049ab572e65febfa91712ad4ac71a55dc0b629eb2e1b136fa02b69f6069b4f4d71a6c6263c6bc3b2829a299e40768b21d5fa767a03d1bf01fa9fe00f04459780b082028494f731a960756cc53026f62943199a0eb24ed751640a63bfb79de7eaede9a2d1ffb1e85392ef607b95be01293c94b13b0a5d8e7d45f4892af021980f817d81c7111cc9fa67af1dd32206760f938db98f8ab0be0f5f1d1b17f36e0bffad67b8bc3ca029d52603696df7e03aceed2e73da4035cfb920473217c80c2c98dc3091328d57c581126a81538f22f45e619ec722d271153d4fc284618f87a4aa349b9ed570eb827219d6376165812ee1c78c1d92da4ba8776c39712df23897c12450b204ec83bdbacbf6f14b66db01c509595dc30ef96f055c7ce271f8bce06ab78a26944d6230ae97d789c8b15f11aba7223a489e7f8cc86e2dc654cfb4e4806587b447d8aba893177ce3d2c9ab8f0f60548779fd08f55086796569b87aa0570db1718425bd9dcf37e33ed78762f8b620b26a3d768a3c9684acebbde8792f799b5655e217fbdd8ab52f1a71eae287769026f91c090ad48df9164f829befae7b8369a49019e38b1b630d8dbcca1e932991f59d60185684199804593a23bd985a5efca273ba4fb7db9e875ac45e3d93f5344c0f4c53062497dfdee3d666e81800d4ce677ec884e32f71bffdfa488bcde676c65a0e80e921582d5ad9a6a65296c9e606153398eb03031fe55ed47f02c0d82b8155961d589f0a6ae340a08ff9611de53f8c700090abf123de8a765f4f401a0592fd283aa03a22e10b4f27c3ce81210d08b92a61bb261c3a5bcf0994d71327e2e5e82f80fab33cb4bec662957f91a3cd2f8294fd6bca057b06ccc992f80494c18bc15333a9b4a8b4db6aa31e89a1748b700f496d690c114409985807e3b1ed0f54b678a2c5dd4f1d77b008ba27ae2fe1b5ffb112852af4c15267924ca3cd4b699322a8d231828988e38705e4162bb3ff77fd28d62a4e1edd00075cf0efe20ebae1169127d77218ed7eeca64b2f67aef6dc5951e6dbc5040e97ee47cd64e5ecb5ad011ca8b8e9ddd4e202fa718d189958c866d2c209551e060ce9334f8605ba9b9f25b8cd9d6b9d86d8ae94118e27912bf2a316391b8c8d9a56c586ebbebf3c0e99bdba79f87ef2ee672fc8058d296702407c73110655169d2875c0eb98495843ff3d05f9e6ae9b1798ecea4ca39da75c08357e210411aea828f1966ddfdbcd6dd54ffbc61d82033757e1ad619f527d68b24691245d66942b08f5185e380ced1a7962e5307cb8b86fde3af0d32595746a623e0c880c766e7d69629da8e40141122544d06310d8959313fe1b1023de25c04cfc2f47d96f364c5cc3d6f690877bfd211e7c17ac7421f080681833e578654f920854a51daf5115cfa88e6618351f62b8437edb690dc0e55a04872ee44ea6971db6ffc09978598e1451b2ff3632b4ddaf96251988bdb866dcfd4d009ae45286b72d053f2801510bd62ed3eca205503a849649e65589c8d3c99329ea3aeb91a8226323aef53cfab1e5d28afa63187f1cc65f31bdcba64a89d6518e6351f45b0ede7cfe2f08cf48cac71ca6be79fc0244b0392312a7300c5d2a1f00ec98a3afd5e92e86ea0f382f80ef67b9ad98e21503c4507e4907c248771fd9ecd7e35753f8533f768b4d2222fde0c07b4a4cc9f8d7c003a8819d6de3edc620111e2093a7005f7234f8c7ab4729b308803fed26e02641c9713fc8ca5800a82b18b5d7661f436979db3819227c02af97527258649ea988a8af2fc6130b733a7270f38a42cbd5d299d94229c4e4e11ce8c891659badca2d70ecf635bfb8888bb90a5add666186c0e09b55ce88cb9b17da89a692b126e35f9e9cb161c87400caeaf82a3bc275446670a2a5c7ab5de01939cb42338223a392a02e518e7bc6e684f7e915524e9d515aeaee9cc9027efea9d3c3b27eb88e17d3ced113b38dfd99b6a6f150f3349123f500e2c044f0365a6b7cda03a29171a525512b662dbcca85bf5e431443df20b8c69d3fbcfca68807ae61b2368d985dab2bab36f347ab0cf0463c907a7bdda143dc33431272a04ce810b7df76ce80ad57270488c0ba468b1477418433f8bb7d03f489d10317a8f29446ee079c25e443a2d1502ba7fad74b354edc1978d62914d42c047a15f2e237291a48572a425b275bff4e91fdcdc1346bb836d71e9cde94e26882a0f3d9f2333e946c0265c60f7b8c35c559842a3acea57dea9bc61ab12289aae05070ce30f5a2b003934ef1146342dca7d7587642c33f1e202f5dba6d9e545749fd3316b0507b42553b6ed650de3e126e491acfca0e71eca501cdbb5ded28c6bb14dd145a7c5cc73489770bf2251688b07c6d2a9df3020e40b0bd7c98fd293e5a3b60eb6b087d44094f75ec2d759c53d42e5449d3aec9d5d41f8c1890792593b83396cb2c529b4ebf1a1cf5a483a4232675e4aad5d67914b214ea1b0dd6818089c030e3cf99a3f855f67310a40475ec3424f34435079a2e5b73f013251b252a84b6d7005743e5bd56b0e47b6749fe65e3c934b952cd8e92cd9ef470d004113c1804f9d46abecb132149c389ad54c439f6f933359e12750cf0d43ee43a69fbcb97be86f11a6b1e02b1c1f0d5ad67977491b20db7d34c74492fa1f4dd3f67ddd0e9f2c7250a57dfabbbb3a350b871ee5e78e88ff89cd1ae414d26d210b750c22c88dad2b92bf8f4db8ac4f80afe945b3e221c6b02d53d00c580947916b9227cb65798e3d64d526ba24e9ac084bec865fb4a00a1023458536fa45fd4e43b9d348210aef26dd554f419eb5e07dd16ae7fc42c83c9fbcea5c3811cb8f8fe8a21221241c5f418888b2892ebb9a5773f92ed0d9a57d38c65d39cd22e3e5c0511173953a7958f01b5c9adf2bbbe21edc330fccb03d472660d2899d905af24fcfa800d6c4f9abad15a96902582c5abf64c94d34a8bd1f0aa95c56359a6bb306ccaefa130613f9c332d6ce36c2853d716cfe7ad4a15a2cb17dced4643d55c7d415ef906234ffa77d372a5b5a5f09e1c4e32c2c6c21884fd6ba8a180","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
