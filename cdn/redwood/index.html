<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4e689667242de0af711f04c04c16e3da6fdeef21bd730bde763d93d3d01c883b534130e6645cdefeaa725ddd8d1d8f4f1c96e912b2e4d41347d3d2d1c6a70ffc12d16c856592adfe8037945e0bf53742d65abb62ef7875c9e677a3baa180fe5cc96319c6a9d50d9d01a86649fb3deb7f2cd1851df7620f95004dc8765c55aee0fe752214be613ddf2cf842748eef25a5ffd498d6f7bf1777d821744778b078c5dfd723e367b2546631100bb9dad379dd8c58dc3a4b3b4e16cfb5733839dfa96f7b1bbf876ec2e6fd62c331742dc39b54ccdb9631124a5d39bea02fff503783a6f953f8b1dd489bdd577a83c3421b4a5026de1af3e09f78a639db3be6d34a8843104d0e34d3dd5473dbad0f1aec0ebaf3cb449a4a093d8d533518e78ba148903ac2a9c311f932c357ad2291e5d642d96fa5bf913aeacd94c52ba3144e868ca359889c406c46794a93d15648479bac5a404701730af0cc607c3e4d359c3a6660610f7c5f0ed7948261ea7740c9a914aaa30765ee9782f81a90dd21cf7d61fda83e66812951b9b1d51a562b327bfd7cb170d7b10a1f5782629eb53e32dfbdb2a78fcf4537c53cc2a483df8cd57ffbb02da140082a21a16942e821ac232c0216c9a07b8d1d5e152ee7bb7e7ddb496c38adb5ea3f5406b5196d65aa5dbb7e5b755cb5b5dbb17a4d78d1b520177b87d8b2a8a0fe60aaf984da26bef795851833da7ea80d87dd5984650a15e3a5001a5b7a84c853147180410e8a3bf1fadb129954c94efede71ee10de9f1d039c52eb289526449fdee8ae90a02ad7ac7e9fa62ecddb36cacee6c1a2cdac41823fcd6d19b4a269c9a103c142422cf38061cc7e72c836b1d92457c4af237caf6f27e5ffa9d866d8bac2fc0c104c9cd5849a55692a750ea19b09c346b99aba1fdff9c3071f5a9ab5008b11307c14d58d37e2d02542f8ffe1bf11554589121b840973ed4cc173dc060fa8526b68537e377d54ef57f325688954e267b0bbb13e2a2134a56d288749e95c6bef63a57bac38ee03fb6e2db1aec36855889e8782b28995afb898fafbcb75259dca4574801697cfd874913acf5698be3c27ace01eb33e289742f911809dac94e2776de42136c9e8319efb1b3e1e988d220c0692040e58c5adfe960332cb28915ec48cf844f9a6b1d17d1fb168537640638c057d3d707d9942af5d5e91b7693a9015c5bbb08be2919491e14cb85936312bd5c37099beae10f11b61363e6f166738d5903063c753687f2b32a0fc67cd1cf970735458242d74f9e78c2e048fdbbf74ed341798b45d4656f5091b65c5ebbbb54b2f64260d56bb796f97e9a763ede233e8d2b359d24155ee3f7f5028d18d4888c067ad25a4b5aa206ea8e273e8bb7db878da0278618d4f82eae29fad5b66de025334c48f6176de9a602e72ee5f183da43986f5f8a793727f8a1245b474ddc234454849120bf26726d4f00c54169fd8cae1a1b760f4406c4e403532dbaf6883f54107d9da1c8b14d05832c568dafa69cde72b54d21abf9e66c664ca7a46acf94ccbb21a737edae630712a9c3cd49c0deae89748c1884221e9c6c76effa43e1a0fe589267c6724984fd8620cc4185e88f7c7666ddf2e926eaa75a2d44be4a097ca86f33d084a8e44734bda26b7423677002d943177448f780f72fb98b06751adc6809e25dfe76098e7130d5dde2b236af1e4d0c35ff457b13103b6fa3d82352b242ee1aa9910ca09c95553f74cf18f8577de0760ad67890b21f72c16bb3fd0d06be3266ffea0b329598c05b5cb1a6c5eb70bcd5b7f51eb9d27cc11bdf0628f9b9dae8095527e561ef6dbef0f31792618ec32e062fc5a046e2205a322e56401383f7279ed8a69afb1d5ff6fdd34fe88e26262c08b027159a56120efb3f0c055196831503d1483421bc76e55d1b28d02a1115587cf49a91c190b23f62990dd779af96bde18b866d7cda0c4dec6686a39ae024eaca975a463a2f9c903c1933c2f947894243f1c39d85fa893d6cbd4634e500be3e85cdacde41f4a74d8ad52fd3203b07bb878e428a7a25d5e1237c084a67941bbb0f28ce334319ada24d7f50c36224c7c85e4c420f7798ed90986b086f846dd3ab62ea0724d7fb71fd5fd36854298fd854f4da1736f8ebe884d4b32c9b846813d3072e9b16141d614827896d1d3c9f037134e7648e66c81fce6d6a1930be7d9b4256b98866fb9f336e9c8c32343f3070b3920a54ca690e0e353c6f349d93e8bdfa2773ab124e80cf6859849d334a8f794cb2d06003a9e78f79d7d3aee593e83df788e93a30f0da3dd2d8c51a1e77a5abc51e03d312e2fc0f3176b5f75c3e84b1d155bd55bd93a5ad54e3af1c4f93d3463ee63c237b4990a0ca6b2ac298ecd729cf04fef15ab67f0cb0e0f550c2a86a1b5977caa29fb24be39636456412f5e5a2d21f446dab3d102022136d5f46e93b644d0112cc9cb60c20ca2205fdef0ac23296f4d8aead584916bb8ff7d1299ad498b6541b04c442d4ac7e304ce7922743fd6de084ba3d8ee088134845ddcf666ad59580d139e1b48fac3cc2f8f661a8775e3b3ef96a4ac2cbe7960ffa58414b21cf0b9bb88501c1269ba2cf7d9bfe4856f1cc6db91d53ea381c617d223ed70b265d38635312dc50677143edccd7edd053702cb033a99dbcaca7243f8d68b121dce1399985e9ee9b4887ac151ff1e29bd1a59cfb21a55eecdcd4f50d2eb2e778463776665a4426b9411c8c0fda0103b9019dd04ea5c3bafe50c92b81a5bca134ccf66aef58ba4e6d9752a253c24f27723363160e247f1aac5eaa462c8d8c2f4b95767918d2f5e23069281272ffd8e55b5e600cf4ffe5f8ace16769b93cd520369113ad6440f2223486777397c97209b11ccfe88be5be9284a5a99b9100638565defdf7317426a6bcc5af0c6e05d19d219fe2bd15fad9cd978bc330f8f6a2b3ac4bf4d9076bf87cae05be7a47ff85f23732a9f25a1ec1eeadd69f54c5d16ec701dd902f3cf5f8a8b4884b882f266d32df990e181ce2e7c184ed23425bb99a605159c3bf7d4ec93fe4b3fe7f43e1470cce709a8921f8068fd54eaecda61105e5da9e5e7c9896e3e2802846c786e4d69f5bab234554b704eb4e90e6aaf467defcbba503a4d0706a77d0b21f5bb4620786f178ef34dcad1dfaf76b3176fc651cf3fdb39164719564280051f22415d5a424cebc57dc02427d4fc8f5c41a1022e6e821a87b80d6432c488c7456dbce6228d7eee194a8d022dc1c687c1123cc6ab7254d886d501c8ff21cbb1a65718c15bf772d71d82dbaf9e5ae006bb25b959edd4d18173720082e9e1d9a26795cca7526a14fa0eb028b51c1843b7a068c8fd405394fc66d645919ca3251dacef5f6cd7fc73e1fc0df3cd40304a1e41e44f846922686a898cbca3dc454304e8e833d89b95994b07b7c628149a90aa7f73176702f2d0591cdb485122f1e5c2d5ad3430c16286eb37e5e900faad4214237ae667aee1cd84470b160f470d1ba797f15201809fe411f6520e8a7c928f6ab90736ded76b6b4acfb33cdab5924b26e0d10183cfb6ca0ad7db832db594427cf244dd88d967036f0217893bd6016395c8efd5d3444bdb9be54004ee0a83d01c96f0f16a611fccbb22264b6456828b0e09004ebb467c307ccb0f727a2cdbbe494d9e81262ba8137dcfb6e8fb30263ccbb70cececf7111dfe1cce5b4c7db70301b5b7faf5b1adb7389fae4e851e55c96d641a56b5a648fa3dee015938d6f45fd703a59b86e998ed25033edf813a46c038af62a7f3697a44197fd0ccfc98bfc08b6bd9251528d8c69b036b198ce2202256827dc5e1c9258c93dac0ef6359b87d08b53abd0067a21794f3e76c7fd92809808cb8afa3b64b9121059ce08d28007dbf9ef02babb658cc605974ebb784a74cdfe78510a206e0142ba5c0874d067810df8fbc0d957cfac03f4caa00821a74fcb8f8dfe17c9a604c77d4895dd8aa4b66b0cc0b7cade7dc3505d32e9c092ec132cf1509388dbc2b89213c7f619f955b52698a3cc4f4bcd6e98df39aba7fb4ae84db881c78b3667588b2a990eab9eb97c46ba272245bf59e40115aba46e634c0f3a17ba265b9f9ec446e335f837c71ba467ecf3ff0b55bd83ca482427f61e34b67b023109a5a645d1118b15f333a1df36bacfa77fdd1b1f6e38ac9fe599e5c3730cfb7ab1a99bd48b69308252d9d29a4003ad47398a0648aecf916ac221c9d0f852653271c230aeeebbe811511f51028edb1dec9a2e40d0ad97df4da8d61888421fcab076ced44ba204893529577ae433618f519a515fb6b6183dc2f4c8738dc66880937800c1021a6bb78c5cd5ac8c85ba38fa953a47051102089181d786b585367c32e72a63b8ff04033fc7cb25207f91092e90af8882b80646f76792fc279ef3296c8c0a1545ef3d72abc9acd0c55b1ad96641db38c771cc2cf401f6f5ce1f311d47f4e4f39754cec754b69762780612439787dfe6f576496c8511115d99a04b756563ba5b2f250c068e1b3669db1b49f0a6632852b724145a09c8e39e79099ead7994c53b592b21921438ae9d96cf43cf08381c0953c89d706b0341ca488dfbd4188015bad9c4d1ddb50c945d4878848ee0410d836926b2fbdf5fbf2b0900335f7f08877c4bbe135407bbd55a2d51b3288c253bf5bc2e577135529723fc7a1cda825061eb27e64ffd396a0614affc3e4670c64ba4d893729f7f14ce4cf4a58dd77a915c262af7a0947bc374190795f99a509624c474efdafbb09c1f2c874a9eb83944bf9948724d26e69557a80e590bffdb034dc4cdbc64f98529d72fe44fa3741dae5b34c01512c8e0d4afdc29c72bddb01effc3e4c8efc176829c5360fba901b4ea65e124d893bf569e6458846a4663fd4261858bd16058b5bcde4a463f3d1f7fe6f27ba12af096277d997615e88cbd44e83987797fc51ffcca469e1e4027d053c55b2a847949fe99844e2b50ba49820817573e1d05767f1275a02dc3bed1db9d6cd4e8f3b076a68268e46f8f37023d153551ffb49a80e1aa4e554ac5137245e2cff3fc556a2b5fea32b51d250c0f0aa430b03be3896647bc1dc1b5758220f1adfe6803abc1099a350f35ef84184870ee35be647112fcfcfa4b03d66e504a510865ee31a29e8ea37b734ee43c76dc7d2a090f290febf5fa564060691834ac631e54ce4622b3ff165f53a2a9333f8a8f047fb9e0815406a00f16c4c03334755e8a8ccc9f36f9b87fd0f79f0844b4cedd3dfd1dde102c987fb7ea4527abcf228a3b419cff316a84d2a3a6e2c4c46362a6754e3295ec1eb310f598fd6470c98833452271e479e7acd3c8e408f5031e5e9d032757db94279ea3fd3bd785026c04e6bbafdf08e7d3c6be4d9e830e4f5340179350419eade06c5138c55642a96323eb646dfad93212bee0e77b24e74ad8b40abfea768201195e04b533fd3f3f0badcad25a96f9b6b04d3c04f4ffc93c4b987ac697f63c9bd6211da174500b961fa93bbe3ccc976f4fed51b5bec1391bc95db36c8cbe86549596d8565082446bc782f567eb589df670efaf47db852dd1a2fd76a56067f52f685710e59102843ecc32c969d1092a228d8ec4df708a1ff33b1de549263d91690ed604e151d3a2d8a479c78364218311f77552fe7820d0ffffc630d67e73afd47bfe610878bfb4adba4b3d1edcb539f840b49bc1e1bc36da3016d03e94cc0245985778ff51e3953dbd32e10f50cd462e1031cfc68c557c0c33d5886a3a69a3d2638c0c4e7463ea8fbe6da8fc9eef52642af7adcac0be8ed0827c416b766edca93262c4dc388cf206b409f61e4201eb532d5b13d1766b51e4a41829424ac5e1e9ff9b0e2d66d7418bec4e4de64ab2221639fd11dd581d75a04bb60608bdb4bf123fbd5daabd98e834ec6bc9c6d42b5c8c46afeb25fe329b7e4eaf667d81a0b3afe7e760c9b48e795a6ac672b4b8fd5d01ce880f39bb74990f5dec04f7977e17508ce5ae5d1943ba96939ed20bc40e6368238e5a3b3cf4d12734ba968aa192b645d7c709e00a2da039d8e276d42b38906e5cafd0f10d293d94267402ac1a429d6c4c35a35fb6a202b79dedb11afc8c37de7d8bfb380a878b7dff07c7e7334c048de1e2d14fc870390cb4ebf72eaf5ce3a80f16254af664a2a11d7549be36ff36d397262024820e949489bbaa16b4d69e706134acc0a37d40355aaccf88886d8a03cad79e7e36e56d656bf86ff328dc4c16d5b824c0dde633ac7fd521a94d7566b912ec59ec634d44b3e39bd6ebb2c97719fdb0df6aff9dd193a8554848383314ca3af6ff8e0359d1e24052ed1df0319f7ddadea00afc83867489a131328de053e7d1a24906fef9975c8e0854c276284d2311588b89f4d28f58907e05af26f7014e451d471e48c76b3a71d553f2a5674d18d899655fe6a8f1c397f34a7825760f013a6d97a584c3b95cc51d7bf16dfabb613d0e708aa674f9c3dc1e6b8c98435f8e638ee00446388594b903d46d5c2209aa855cd0df127004e8a359305fafeecb4a8fecb5039493179e9b5dbb3f8d959c5b750d13124d3ed81fe5a56910b00a98d555a2ab2a4350f1dd343c375d65b1dcb73a19f8d7a6758dbac6721b31ed184bd6fb971a1e07c7ffa36d7e764630d01513da1357fc63ddcf582f16a5a2b3c406083a1962a172a47619b9cdf1a2c9d5d9e054ab7b6838127ab39da206eca9af43059c7ee95ad285392fb1a6dc3cdf815143c92e8ecf16b6798fd75be5dbe07fa08a1d80d263c60f5d31e7ec5b3e45b5c10cc23e11dea65593ea883a0ba4ab46a6dc0491947c43bc80e9f1eaad946ae7b16b649900a048171adf9def4b9402198d76c05c01f0ea58ceacc8952063353e0d5f8ea96fbfbdf2cd5abd933f2f979a9d1b3422dc3b0ff3df0e580a5c8bce096fe701cbf70b035793eb227a9a3bd037e163323df3443bdb2fd19fbac399dd7a2579e1b84aa60194d44d1abca4a459449a0758afc2993f92355b8b5c2d849e26b96e006dc4d7ba35e869a96e096d27574f44d87c861da601e0476eda3284a75d61f74cab8c528b310a01099ad01e169b1c48744193b94b5baf9a72a939457e94baeca915845bf18bfe9aba780ba2dff2432bba130ffd2f7ddd535ac6bec60913bfdd3c643fd6dd238ea3acb08c9302468caaaf35b9ed8ce9c6b1c8919e53fbc599042fa3a14d4543dbafed000ae51fc2f68240e243f6abe310b934aafe116482ebfc9963044314d287005228ccaaf2aa798de32973d008399c87d91a28014cc9825273172a3687b5e8d1c1cbf06a143e135078c4188b9aa07181f9f519e8e9edf37ea6d13dc5ba1bf2f6e41d8a4ce55e5c1d3f9d4ce25a977ebbe42750d02c713eb2b4d3936d7dc9caee8aa35962917fc9de2f1dbb2b00396ac8b64c9a5cafe7555f1447ff6c68c04b94246a1e936fca51b8bc2793e85013b7ac7341b53c6f3afc6a827e75dd7703f0453e3c02138d142b91c486247aac10f21abf741b9e44a3a6b89791254c3fa057e192a49cda1cbcc0a944281f73cf7465edf3a92daf659d68469a9ad5854d3d6167f94a9851442efa0a060b7a0d4102bcf2f6292907a0f98754b8ea729f245ada4c6d7ef3d0ff27e6a8c7b904c7129bbdea9d3869ce5c1f5b8685359767f8ce941b5e2607d9361bf8f7c9f7fc5076ac5893967ee547872ae852547374c7c08fb295eb601a0ad40073a4d2a1ea6cf3658512c2f9056764f1dc515f5ca0e4a96bbe44641b39d6c86ff00b11063c609ef16830311e66632b73483dbfe5610b9f3402226d6a16d943a048ea93bd3b3616899716e8bb6547f62885451fefc05afcf64c7b849de6129e8c50fc76007946066697caf680c35557daf958827310e516ae922b2fe4180efb7b3cbb2df0a5143f648323f33215378b3e126cc196a21b99630eda716136a792f81be0c46af012ab1ffd0793e86eb3d4f443470c89f80f2a9292471bdb0583cecdc3713fcc358ce8c629625446dddf5441deeadb1fc7ca7fcb969f55c1eb6de828036662a1af70d2029a95a175398248553c5dd015cea65ce73ad9619aafa01f83b9b98670525e12a2b9974cfd505dd1116535e95b250da413bd4d9eeb193bf669b0fb630118e48577407703ba8cb0b8f1aa388ae0f303dfe3c6712884f1dc61cf9f142c2105e41a743c54d72190728e4b3619af0917dcbb88157401e33adebe057d8aa52b80cf9dfcd25e5d33ddc5aa7a82ed52d1b36a45bb738a9a389cdb3f0a475a0e3556601e7510343c567bbd50687b6fc61e74c9601d8ae1e8517ef19f3f4e5fe766956b235be44e0890787f9fca84b1c905adb0ef1308b30332d7dc0e13021385c683f48c34255548d56c624089180f0710d22d83abe53b7972843d3be6ac5f6d38eb83329321eb89c087699d15123bf42dbbc0dc4c0577d4a5cca770cef1b2d251659aa89d0762be3308c0dfe06d35aba3ce6be842b3551c245284630c653cc657ba1570f6a5e0881a8c559239634f122ad6d1f51a7888b01504c6b2a22b167746472bba7f5f012f1db6a2ce037d20288dca6a9a76e91031faaf547a8dcda7058018d7552293271c58116a34fd38dc56a1851bfacfe996c1c46faa3c342b6d146487584905c68788f4c7abece2ca1938051a51df3cd57acbf70abd1d24253d58d93898d4cbbf3cef0f59862bd06b42de730b0d2ed1f68082f3787eaeb5ca22ee76920dd792dc10d4fe95e7d354da2ea63158a32f7beacfb9692379c111a55524a83a9b5f8907c7c9eac84153ddf8261c9c4c325c389334f841b36c3aa2835d798fb697a8e55f84854d0b12c14d263e5d7c7c0ff56c56550ceeb9c43fc2dac8819ab7982584a493ce2ac9681f88d2ff19162d60021b9f1692ba5930819d2e5f010e57621bb721f8eea0040c403b063ec519855a7a712937e2b18d71d197b504efca2820521563843f865cbd8342bc7dfd1ac2889584942a64ed2866c891f74b68d8e4f42725afd9b21ad3bd3fee95e77f762d2c1e9febae1ded47f4be69caa251f716d5d649829b4ffb8c5015af8511b1a89910c35bc46f4210963464b62f6cd58ce4828c326a2bf63f048a2f0f76c775c04692fb855f719b53329a07efc4422988316b26fdeb2ce8e35c3214f31a7a1c06ecb38fa2b1e45f4be71ae8b0daae3104859d63de961863245a3ead99f6465f5fcbc7e9798a127064877276429c2d1391487d3ba90ffa603f90dd0cb77b477aa8e5dd61a3a071f5d5a80decc1664d189353df9120f86e8934cb58e80166e1ad83ff5156586bb568797c286c860f8a51e448ed3d9139ef1236a5636c0e32b346653a70f6f74a330751c842da459074d41acf958769ea35d3d535ae011148211e209149ecec10387f8581a9e1740ced61811af68199b05b90ea2cbc9972d7ba19d7833b7ddeddcb3a2186f98309533a32e4cf3172c14ccb2b61f94c763ad71f3233ab82ac33aec828040e4e744ad66496ed5bc4644475f6ca34b5ddd34a4c981304d51be3dd78460e8c51d283ac82b9cb27be39c6b13d467073e3fc2b2f6f441e877608efc3fd4e3f70d8c3a5b021c2c5f3115103bc74ae6fb2d73a686c333b169a012ee19146eed7174b54717f603ddad6925825ace5c5b5b061909b94507047c895427f87366c735cd5ba990bba11c68d14167d367c99de4a0b8e4e51cc957f740e09d12e8d7d517f28e20d7cb0e473fcf0e55267c6552ad2f90fcbb15c8f7b91ad9d1c635a9d4f14b69c57a43238f0c82f75ae23e0983ad5bd5125c24cb92da2136492a3df15426730744aea0bd646e758ea1b21a1995b30078953140993791ed62e2910e2dbea55325fb6bddb35562ef59beabc4dd2356ba2b14fb3bd61fa2288115122cb89fdb98adb5c89ac5a71aebac0cbe213b50eab43c7443cfcf05725872469323b6cb324a8498be9c526c40b212844c95e57783aa6db1ae249d83d0f656a77238cdf3a643fd08dccade27c139a9665177f258c986786ef957d127a3d1abe9f979907cfd9430dda9ec1a253b16307110cbd11ba75ea0cc84ae1e01b97343667d7ec7df4303f4bc750650e1e1fb62164117d1189bf5a4ade493ed1d471f75008f5cd620c5aacea59e834bf4783288da9b2ee480069a2d3b228770ee11b8c9de11fec39a894cd6fa9fba3f59f70694b4f31b1e662ff97fab25aaf1d6a47293f8e23af50bde8e8226800ed0074cf8fcb0e6481eafb993be99385657c1cdcc31534acbb32d1ab2d23d5ac89cac267b9eee39b5a4fdacf0f73e663da27683d087e8b95f6b66c7b93718b4798839191eb826eb7800925a44f2bc590934fdcc0cc0c264eeddcae3d4aebf9745ecfbfd2bb7af6ba39ebd80bca38b77090fdc0feb41d8802aba9039bf8775a8f58ec915f40a26441e5d40a96a66928257b656063dda3ef26b2d4b6f658635a8875ec692dfce3a07728ddd97f381b4f358b93fb4b4961b342509839636d075301a244b4e8bf2f4d4ee4a8488bd1a87b2bae618c5ea0555721458afe96be9ade12cd07880a766e2214ea446b2053c3d4712e689911c07e5479ff37bea69ae08ec73363c00249b8f32b0113746c9e8370a42840594e10e83001fbe59195ee96b1524c0cf9dbe2e3e3f3f7a16f39a973c0f17bc50c84529beae9968ff80070abd25cbcaf3056acd7b4ebde3484b16a87358ccba602954c24c8b7b62c0f1d9fe9f736119f22727eaf15b1b9430a86e32a04c780d98009451d7d50c1fa334de7a1934764402add75c387a17ae0626888e8441f72e6577858057d7ca60965eeb2fc754122f8e5fa5dc26a8c31a3484176794e7b2de354b0c9463ef67fdcefe28ae9a9adac43f8a8b715a6c2f435a31d5c9361ad0732743a3914074756f4bfc6d80e4af75cc10c11976cf9c531e317fabe33087d87b54e3882714bad43bb7e26ca01916157491a0b4645adf16e5a6688b54285a6ffdc852a0fcd48672a865388f0e3de428b92e3070441b0c0b992be5ef8d57212eba774fff1a1961747c800262ab9125d6682283fa7cc44e54b495566cc034c772961de3e1a744c90cd2c9d1ec36469c061e98b5cf60ca52e53dd3a0b03e5d078581a6521fe9e6d262050ca710a9bce88ed619bd16471b14641747e67136ddbbc1be3953328a5b3ca8e488d588edfd69b687d1bee85984698829b839f6bfa169accc4d36f7e59e78aec1ac51ffcbfe9e4415374cfba89a414f4924fb7ca65eb2555a58329a963055763228317e9d3a42c5e92346f2f81088ec5ef10cc41952b47cb923fa483cf3c1b3c3248284e69a9dec661c9566f247111a8a4c1a876e73b79a8844f910c0b47a5aa4e86cd4f78b7a3cde8f9fafbe836fa97f6f5f1e58dc72acf8c73e7c1b86c80a63bfaf50a958ce5047e87886d47ecb52a8288ef541ac3666ac12f2a787474ae719cb5c214b15e334280cdd53397430165af80b699f230fbff3cde361a130f17faecbb582d900eb7692c125a5f5ccc597643a0cf3ba429908e2107c8ac28aa6fbb85ace950aa1b46c905b74a13829295ffa02a925018ca16097e99a4cbfe4795ba32104586c90269909dbfbba6f357d374a197c5d5992f675f20e7b7220af6b5b27db95acdf952765e2f172792d09212d2d5e5c2f36f5798f1e70b40413dcb059fd946d68e5c1f2e3d4a011917b646ff40577436f4ae73eb636b4ab3dd1cde73edc8e49655f26d173e2cdad86c0dcf48f8dc7915c8c11ac3abc33e8e00d2a73c393609469a0e90869424409df1adba0d528ce3d7dcab758d7e24b4eb862ab833266fb296406baa0f9c29b67258c556ef2cbe5e65a80dd956eeafef619feb933176facf9e25ca1afea1b87bd5131fc952fd34ed0fcefdd2105af59a016738dc8dd6fc0da8b73f7e1f677947c9f99422f0f83d0f8602a1d1bbb13ee32d571837c47a0b8c77ff8d9dfbd00835b10dab7e0b57cc5b55ab67fcbe14d8fc521b0cfd51fc0ce2fbbeb35ef11aca310635ed8297e5affeaaadd6eed03392690ed20a65071b0054902caf9221b064bc12cfe7213eb6739889c9864ae92d6fc67203d2938f19a931b188ec065fe78ec509b252bbaa58872f90ead057b2476052e3bdda202c0b4335f88934576f1e858782a98658b95d205e1762ebbb8bdcdfae80d9a6a1bcb955cbefbae0b93dc39d2939f15b47b6de14e3cfa77fe19d7701b8e33d7128e59a81b83e94fc08d6f1f05da8a4d16fb894c53ce6de6154eb169e9de32fed306c689825e1ef6da033a39709429103b23ea0e30b0bf924440c3ae98a8d1185add197691eee48e63267dd3297a6988f7feda501d6ada23e130f03db1ef397ac6201327474dc4cf4053ec0450477a22b9acefc78d5a893209d17717fa660b48fbd878e3fdf68aca25904f49428cec80d73f137e4de87ec73c20782afde2e5d123b17bc836b228821e0fdbd23215743a4cb77796fcef5c46537b9efd7e763c28fa5b593817960fd2e51c920a233db9ad0db40aaf0b4685617ac0433b3cd1a0273b8cc957b0e117d91b3754a1900152d1708755cfe9e0bf8c6b4bbb6204b8a2603a4e788fa61084538c77962e8e221c506494ac4cb004864f8605a711aba62f261c71d429fb42413e32f59107e9d3e3a3829608393f6c1cb4175c8cc1de68ea6f9ccb13b4e9afc34535625ebf2b53aeaa6dc16e3ab077b7319528baa2095897f873614788f1fc234e4473a5b999396a777143a1d83f28d0d050345969bef3f221e7b81a73a4a3e053752676f9a3790fbd1a5a2b49b1bcafa009b76cf1d0d1c9b588098237840f8649e7af0f482bb26490adf0f711eb9e73f899282155a8f04828a1e4788de5b0cb1ae069a5961b6c1ae4ad0c6b0cc6850f7f342fe881fb0b7eb390a9b793b215f02391df263e993d402a0ba695e5c75e5f9f5d16f9a49cccd9d342606c9288a9bc28f0b760fe8ede917c14b82e5f4dfcfbe389fde66a24f8aff730e835c7ce726d7a727f10bf30402170d83e93ccd3282868413111b1ab055209a83a0cb6a48ce622d08de8e4148b90b48fdcc0f59ad5c7e281215aa716879827e0b47d8163f2079322bf7597ce1e4c428359c85df372e4cf9479db842ae7a095a90ec0d8317bec4d00f30e5fbc8cb241e4784dba20412e181f00cbc88890a1604e6618e4a7be1e1c7a3a94a81ad81a2b2a3feafc65c91a65943482fb67080e1072070a648a13c230d43029eb7ce9f0e4258eeaf896839b79bc516aed8e36629680324e106f6eb0d97f028a75591a2a73ea07073bf4f7b143f9f92710329310813eaede9bf3a0c8a0afd7cdcf97a6367e676c35742b6ffa753f805c312d3bb40026a7af7160da98bcfb86b6f1d5cb0eb2c49b45e15145141912c1ce3c0aa1c4b393f5285f62c2087be6dda9e2ce752082aff69ea215dc0f90f2526f0beb5bc27bd5d6a9cdec48c841a2e3c7068c915b18cc072e115083bb880165d29513fa1c216635fb46fd3f23778463fd67ad491a7783228d71fc1ccdfd533c5d66d48d9cb93c4504069cbeb2fafadb5ba37bbea29ab49a892e9534294ac471899bccfd4c0995415d843113f02a21c90069b29f4f9b02a8d8cc8f3427c9ab1218fff017e36672fa873437754927b4909df708a4177d00ada63aebbe2beb25ff971baac0d53933dafb95d5457cbe01466aa5f1015fdbb6579d21046eb0c847de32a394a9f6096238a0da83c91c10833088518cc5a0416ddd35ee809060af4106efffd7d11443dedd0f3f2f2fb8c01cb5a6304948b0a8e4eda61e82c1ea812afae186e9bb8c05803f406e4eee1044431b00b5ab16512dee075e872233ba31bebf4026045e04b8af03c037e50e8f0faadc69d25f6a3ce804eb1f0d9f466af3e04133769597e0a49958cd1935057ad2e6c55bf2b215698b639b373a3d1809e1fcc0f9f52e6fe73f8aeb22980875814130492866409c52161b7dd6abbd71979c99fe2a3dfb421d1f58350f51edc2afc8b4c62c948572404f8c405fd68dca927c10fdf3f13dbdad265ba2865147f448e3755ea0dca88599a5dd6bd3c97eeb300e484ed7419860f89b673117fa0afac88ba5494b4ba29c53c32ebabe15dd101676c04c91436c52ea27d25a7895766b8df2f96b5ff18ccf218b277743b582356d318ee41f09694e76226af35181d8f99be079ac32c6c09b6547f1d84af39eec236f73f1319b2e2677b2ba286a87424a6673036c151ad36deab714c6585eca9e6d989f9034e6177adc24030fe6b7a98c79c9f34974070be6d0c32db86882e050b0cd98652b78e6720f6f3b5b43bae3622351459fd9c01941117116e474006a9f56523e54df10f7953e5fb1b2fe51d8ff5b705a4e773bde4fe348761cc8c856bd44ab0cd98f3a618939e37dc6b41730ac8f717a01e1d04f03c36d303c72b5bf13c1dc4a64189b30699662a38ce89f0d6b2a95678179b4bbf94c2ecc6b50f31190ebe9c65f29d1b2ee76e9dda20286e91b59747aa9207d7ef395e0aa0e7164075b0f6725aae704adffb6c7904d0feab0b34117f624646dde60eb375dd5056e728b5d13bce363eda50f691a351fdba99d7a9335e9bbf542a2c3d02d2c98a3c3c788232e58fd48287e722f32766d2ca7ced99ffce2b4909ea2508ca9e2427f09e6b8d6d3e93f18a8803ca590b7570a5b0e3eb4f13a28c56b42172ee31c3284a91333d24b156c6b831014be826d6b4f98161e4eed8c39d883ebff16207a3eeda86ec62c26ff114c6f7c12a4c1ce55e2a984e706866652d85a835e9fc9dc7387c5a8c3b25c1c7eb772a114cc9521f731f056befbd2114fb24c19e33dd714d82c83bfe6e3798ff706c9251028e0d6f45b946035ac0bda0469bf87b8966f2370da8e666a3273cbc15883a72c7ec247d72829684ae2f0e4c1a72b63ba79592e18e9cec674f93dacc1b466271387f51da0a0b4023f6817dea9ca2122d2e7599cdbee76fed4c7081bd306427a103ce92a83d26d84a2ebe27e6a67f1971389ac5556b9bc280389ae965018299b8cddf2aaabc48767a4b9ff8d8caaded087fbc9b4351d24140331597ecd8565994e1ae31ae5e697909f021c4c9d853352310f4b15febdb8870a169fd0cffe22e149678209d2ae0cdc53dea84cb9fa09e40d2d02e52afe3623820bf28ddf50141b1839561ac56db6c6369ae17c2f9600265393cc2f4d700e392a95a18748274a07fed70b397b21740abe6c11e98a8cddc2d13183b77c03a9a00163f6d8dd1cb0335bfeef5a7241baf4a2f7e8acf4e1542e3ee276297adeaf8f3d769238b025c2fe120848cf1069431ed905bfddcf28a04abfa5a5190d469af107a8bda970f00fe2eae88203f235beac0c706ccfc5406c13f290e5046bd6ae987523afd28b3b039f3d5f28aa420ee1ffb4f8918273d9f1615e4ae405e06b49a627a4b4e59ef3c2ca5495171eecb6d6a8906f81a65c37ff688e2458f7631077943a838ce3dbc9489f99e9d9a89f158d818c405d959cf328f02028db564347e1f3567080c485e90f837aa394f97be4a8cbab37e0d43ad6bc2e52a47f095f3d76b29935f261da79e6e786a3eb5c994b290f25d8a37a8e82f425ba18a7a382173b981a723d3c9058522762218cd7dad4b328c5e5430ffdecca33341ba1fc15bdd20add886ac8e989d4b3f76343d77ceb2cc2cecf9af460a153e49c26584d75f583d43a405d69863e857bf52a777614f9058a53a3bd7facc8b1a9304b2d21470844050cf180471e77de5143bddc42b04561c1a69c2582cd6af0b0a61eba2896cf02222e9b00fe5cf017dafd5209dfe236d32ee4c00bc9b2fccba9f67ad1bcb03e992c73a322cfdd33760e5336c0d1fe5fb8597ac71788c03d570527d0adee927956d009051a25f8cbba69fd5b8a16ebae519b3adae9b763c36e21025eba8b4584f05efd4531f98f75e32b45657daf9d817d20593cf99ba176b2be4d83dfa8eb95e166f9d2bb5a0e3176efbde954ba5e82140c9237b8bbee0e416bc3a3ae32579a4329efaf5eb2628622997d01cdb1a31289fc6a0d9122a88a3f22ab992545848dc694fcd5657073de8533a44c90d99d6d8bad1e110d0eb2e0de051c2403ea8376843c76b240a517c1b1cccc71c9dc12de745e973861ef45bae0a94bc46e7dd0b2c6ce92661474767f0e650e6fe338776b5597284aa3cd5206b0b6b9579d41e6e30812424123bbd5c8bead1d8167e65e2eaab35bb4da3047ab2b7fc9a829d3176c74804988df71ba7ace40d69c1c793e92b6a5b84e053f827316b7fee24efc626e0398813eb65f19cfdbf0a709688321b3908840539c9e77b0f2c5ca21a868d040b6e9df78ba1e2fe5b8b6cbfbb7fea914769f52a1bcb61b90b048f2663c3a7ab7d4d470d964135ce393454913cc7e06f508e439a2cf07669f48f970514f27dcef44d631f7ea1c146d080e6861eb1153349be1a5574f8402f79d05aa7cce6b32b83a2a57f8b2420be6e030eff47302fa5d9137a4a650b4564e5b98ab17cafd77e0a1f72435ec65956e0b499d28167209901c1d2eb701ad2636edbd0b1e5006378677003ce439b79ff8d4d4c337c6be7981ce4863de70db41d8fb3a9b60363983df01d8bcfe23758dabf378308d3920f11a388f018efbd4a8181164e45d0482b27062dfe426b04e7f04c9b5a548b7089fb3511e6ab372546ef5b409d6e470f6bca6adf595df25ac2a84d62ea4b0d8237a59ac7b030da1a2073d641ea070977ee0b538f7dd4c02f29b6e1839d5c7fbd23b24ede5027d7b03bf2cd24eb72c16cb9fd5d01f8806ebbfb8c140ac961162c34f092b62fbc2df67d98762fb3ba2352e2ac9ba6e9a9747c813c87ff8747a126635ea733f6f9784b17872ded1a90b8017ad281306a183d047dd84cf23fc6d4411d86d70741353d917253f1aa5801b13527d4d923935a0ff980935944946b1d4620d3da767952c8a86867c57cdcd76f73d19fcb7c533d8117653911781351f8b7364f5bd418844166c26f2296d2633967553c6be7b2a049a15887caab77b6c55594ea4ed0cdc1092f839694cea94b28a783833a9c48b37d71d59d05d2d8f34364c8598e2dccd379c3e3244b8e78c53f1ff11f812617b429c0cf97199e450cf7b1838c6314f5b588a9d5df94f43ff2c11a94bc6284703623c6e231785287152e64f37421d405b5776f325b611839f07db5f142d89269538aa0ba0128fceeed6bfe3261fa59e9765eaae7909646177543c890bfe62b960221c05e2818de0b7081f8caea127ae5950e63b9cf8f864890b3db0eaa1bfebb37b8bf5ade398118aefc9355108b3fde5758e562691bc42417cd44b5d6eb13268d374cc075fb75fec945020ba6a09f168959b2888464fc22f6b39987594437fa7a93351a3abd82995661844ee55f2c59e5294607d0c7f2f4b62c4cd9a48e09e25e8f24980e8b9cba8ffed07a91937721dde16c295b60cf2d13a252e13a06704ff89939285a92d25fa5a11a63326770b876d78aa1404c0abb8ae9469e84de1e2da78892b32b12f9df66cc8766504477125fc2f141ae2e0f5870bd51fd18e8a67fc1b0f2d019632e4dac4ad709231ca4c8cc322fca49f087afc4b163265d75cfb27151468be842feb251adf8b4d90151710bc20b25f6e74f59f19f81c76b1ce1ad8064b54e2d9e7dd837dc37586d22ac6d9f0a69e65c39e476cba36ca86c61e34f4ba46c26f90712888af9146c3fba5fcf9625153fde8c85799ae1740a7815d213cff7d210aa6eaed3acdcec06fba789de08aa7b40178d35a333961b3d934963a88868fbfdbe0ec8a9518442a299788ed095f993cc1393da9dff34561a2635faba6de9ff70692bac30dfc84acf34c5240fc2be4488d5ed988fbbef40a6c4eeeae06c6a18ca4e13f6354b50ea0bb1b8e95379b3e14342bda50ba62206741276b324170f55a2b0ee0294cf8e77d536f1b7993972c0d5dd17805cc0b5f54252ddac71bf7decee14e246ef5c3747f4bdd0c2b6a0b85a40ca7979f5bd8ba2aa3924f7944aa75e85116d0bb61ff987c8eb492729ffafe00b9f1a0683504b1d4bde3a84c34c824788928d96cf00538d96f66cef6ac75935c059462c56","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
