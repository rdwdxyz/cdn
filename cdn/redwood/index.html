<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33901ac9ede9da367e7e84b6bb26cbfb3928ab8fb4d8fa0d75d577b44d51e93dc57e1fb2dce76c57892654e25a1e3df2148f854f6a9e3e65d27e36cd56bd90039d5ff6dd6211d29254b191a56532b5344674297576d7d5d6812d1f39761b4343fac0e257965a2218617c233d67dd5efb4b9b9ad7a6930fa3ab5fe342c9cf00fef3af637ba539e7c67bf46148d74af36840f935b65f45f67f32c55100dec8610642c38ae791a98ace89e828c96763ee766b4229f898de65f6d1103574920a4f228409b64b95f607a6abd4cad9736563f9d9780bf5f188a0044a6a57decac8f0252fde301f1e757ec009e564d1c6c3a7499755638afb829323552b04ab4be5ba9c9819262fa13fbbde032abe9b68603620b27cdf17dc13fcd68d88643aa5d974203e319f7e17a794ccdf4285a9b3f0948a626f661e8dad47d48dd9fee5b7f87d52f94a02a141c0faa4905fee8ca32c44ddca574a7d196068f7e89e118ad04acd0e359fef254ce83ec903f3aadce00474443d5c0c8a86ba88c461d9e0cf447524ee4d3faffc7e2ac9766f5a49e9e1a30d77bafbaa15d03b57c54cadb88cd88ec006cbdf3bd60ebdbcaf4e4123ee3cc7cdd3e337f895a3137898ddacce6ac308c5690f253a321db7b3b81c11aa987ca711088569fadb099887070e3aae44209e91527cceea47bc7b03474411be4d784f82acaae39996e004ac7c825ff81cc95429c96f6c99d92770a7664e12393181082001855c75bc82dfeb8296bfacd0e53f33ed80627e3cf0d8337101f6f4e30d62d5cf38ccbd0cbd5122f54ee6113e0b49a9ee06148663adbc18263a49783560789f8ee739b726aca94b157b02c979788059a396699cab3fa716d817910bcbffb24ca33d8269383569bf53d21611d1e8145bbb9102a61611169ef63f11e24f3d7fe8097c5260f5f737c113f9c3e65698592ba16abc57cae9b4ded7e4fb032648dbc9a485d61a778576a902f322487d131534febe178f2e91ce5703a3e268f48e5aa3d9397b5916c7ed9ff10cf93303ed5eddd352bc2e2e70e86c0feeb672bee2861594f7a50fbe7edeac0549b1f470c9e24184eca55eec4b233554e502bd59c0065c52a41519c09ffed6361dbbf9537c00acfa6b5d5f783827b37d202e1820ba0d36dc9e1f838b2d4b40ec552a5a030d1a36e571653945ef5eb6df2123ed54aae657bee19cdfb93ee3b50523d0b8b2daf000032260b767530b871a5c3f368129179f430dd9b6868470dfb0a4a41d9e2d6e35f08cbb0d23a6d0a7ba8997632af6bc448b630adf02b31b27339033e263f2e55d2a7e522168208cb44e7b2f2ff6b05027f5cb64c2e396cc263c9f76990640f11ab6a32324bf9fcb40e2251734a286abea9114c9a6e7b6fa35f9426183b209b1ea00987756cc4ec70fad4d74f6d8d3ea88a116cbbf1665dc76d72c29220d0195e6eebf1d04ed00c966dcf9b87a7f2821f92dd508c07813f813e77080a313f7181c6b3e762e929faa4e61c700047bedf60eeb950542bfb617f832c9dc5d86ed87757ba178301d603e0b6e7a461709bef1b07f0d6b8706bf425206264f750167022b84c4368021ed0bc9ad45c978d6493eb4e41fa99c7f470bd36bf71c44d75d9e0c8b3247e6bee84352d5c258993ab74b9cba907e6534f1e6fa0dbfed95268eaeccd0d2f53207d0370490967efc7dea0fa45b86416918b6c869cc3be3cd5c007f75e2b3bc9d82ec806dac172440dae8344606dcef9961206ac1747eb026e238546e30d767d1672bd3da987a963cc489cf4c2838d5b6de6a9686515a1ba8729f2016cfa3e547cf39ebea803b9dce733f593c2c03bf1dfbcfe9c126ed8b0e447f034d951b98f177b390d055626f2c0ea211ff52b7fd952044b3d240d5328f2275e5abad8f9980471ad4c8a85f061954f4088ef2a86a1edf88ba0cd94abbcb4f17caff1187657ed5d5fc217751067850bd30c1b0cdff45b5a57b959471d5156c013b684af566b3f4e9e42d39ce079586e6f7f5ada7cab5a902a5784965523a489b6d07547d66274a03296b92325d530875b6461917a8153387b910ad6404ed39da1e6f302d2a333caf289ae6d74535d51f496919796d0ce012f6bbd905f70d63015e68e812a0a1f4f25ceeec97c61d8f500a12e3d63fb6891c977c1bf5f767ec774cbdf35acdbf6c3f2d54da53217641dd846da587fe3c9f0c75b9dd10298ef68b62ab84597d221881b8b7f1201bb4a99e79ef1015773bc19a174ba179bff32ec7f2e9144827a6e4eaee4387b08f5375981c731eb3ca8fa7a02a0d73e6e76545771014125964433d290b49388cc60febb4269f9bc48d6bbc2a841f450e98c91c41849d930439c1d445a272e6120e4c67c2525f7c9f9df01d3b8c86a6e3f21820debf36f8d3a001a09e0547f59325743ef9bddbc727b4b1324a061ed2c355f1d71502535ebfc74486c54bc64a7dcf0b1c16ba978d1868f66be50923e32881a557eac48562ed803e464f590b2a54651d03dbb9999e3549d40a33d891be8c7d08359b2971d911f32e2c5a121e8eef85312538bc02092a8b7dde3a61c3574d787d27344646381700512d07a6709c9cd9873fe7099eb359ba753a6e07718c6f38b175c28d71c1043d27decde5ecdd58ad475d7021b2b99ab0a0256cf54227f66922d3bc0ad62409f65b327dccc6d4466b3cc12a9db3318dd42bdefbf65bfc11e9c88109d7a51721e8b618941c1c2cc88ed86cfdb6685be48ef5061634b651146817130b7f4847cd89aec3cadd2dd432012729eee5e72e7a32cd381dc826c843f461343d99e8e293a1ae3f20e3292eee5d4431e72c6ed20a0fd7d04955da6df3d42b3643c20b9c91f473774d74a77ab4c579e7327b28eb6b74cf92907f8b2aa81f92132155590135bdeb1cac49272d4bcc605cd45da02112a632f54b935a1113561c9cab48bb819d787fbdc277ca3e18d5873c0b1ebcf1e4fe4517c8c99076ecfe8ccc20abf2147ec4e1a03d9478f09202045f188c120af88cf2149f37d053ae6b02751be21905661ae2b13c52fefd8fcb0e43951bce20b11fa4d424739ea3104ee1d8b151f8fb3a5409e5f34cab7fc31603ea77c01dde3c00fd5a69de96433574e15ef7ed70f2d0cff7ace4cc5a923824722ae499f4ac4e6ceff317960d7b9d2fb0bface5269310e2dc006a52c9ab1c9a3be8f2221496671acc03b9d4e57291b4d6f9bb71b594d410e668043876446979edcb80df1478466bb2d54e767af3e5e213254120f03073be724964e9cacb3893b305e285e18393fe0070fedce6689ee69dba0b4179a71e6bd0436278b4eeb36e7e8647b4546a8269b5ac4d224274ddc4a1796626ca0fa2acfa81db5eab74e3122104eb3b346887b7c2777779e2f984363f315daadcb075278386b5c3ac5d3467ab731796d90763ca895bbae3350aa1e302c662e7cdb0b8fe621691f48096aab60729d7151efbfc0bad92f7c494a1de458e2d103dacb137aedec007a7dc3cfad462bb01f0dbb35a723da17fd45fc799fd73ca0e89f6a85cbba706b89829df4ddcaa6d072a6f4d6d2ce3d05510d222255cbde72c851cbc3b6b201310ce0465023e68f0bfe7ed7f7cd6d05c18865b2e810ee7ec0afdb72029af29137ceb1acfb48efad5086097e5d49b0e3dd828d98d65514ce67d2db8967efafce733f258fba0ba4260d2ec0681b7181211b063fd115c32f61dec609481e107146d4d22d47e6f0f5efe2fc021c58bd44148c663b9bfee55ea0c9acf15aa1a66191b2f81ed7ada801182d3685029de48ccdc5e5a0ac922a0704736fd29d83dd5de7533d49841084c90c038d3c0e00e3384dedf3cbc1bde247e84ed656c429f6eb3e1e5c091552d137f9b0081f752f8a10d75fb688432a12f53916f24014353f630d43eb936e3edcad35da38cb2f6f89e09dfe73aaed26f582815ef27e590f2798c7fc7530194657e82f3a60fec7473f9ebfe04443f4ba44d946dceb240b20ac85d73b3eeccdbb0d9162290a5234a169ea2cf0b2900e4b4a6ccb682b7cf5bd7c71c2a320e7e44c35cded0962529c5904e88500981c9e9898e90b2958899e3f0672b6000c832eabf3c271285022fdf7875e9817791bdb9925e8fe753e8ad690f66ac53b7a8dd0d33c85dc9f5dadc68c3f67a49dfefcab8c5ac15472b10eef09dbdb53664bde233e737b1be6e06bf8c512f1aac0185c53e81493e001538ede6b28de9c98f613c8beb8f3d92dc7175b302047a9ad586ef7ba905b0109f905cb757326ffcc7232af34aa1212f27332064671ea22d6074bab7475c0065ae3ab5874da730e449bb8b359c18575a200fda26fa5940f7529aefb6ee20f9622c49bf75e72187ac8f74578d2e121058f1dfcbaa8c319f41ec294684028dca356ec2a0c7172f4a9e3d0338f3bc405fc5be2e70e4a1925a3755d0465c7940d798a6925f1c57b187cce7b9cc18ae5fc0fe2a0e648c04404297fe5ecf8608684d6c7d8342d8f2eb5b24dca6d10d90cba44c32b2cd700326fc1c8d1de8574a67ab8fbd9659437d212c7b5e155959ef5b35722fffdfaaf61fa0e5cf9c164ccbab2cf1949f08e5b0ba47175e927950e4015b21e29fc03208a025e144ff4d7461da6d5e2f26490cb6c4facefa261caba2ac982dd8def76a0ab32f9c483b6ba128c32cf7b65c3b141d8853ad09549b6ece9a6af70baef313ffdfe6147de6de08ca88930314664e4f4c0b6a504d97680083aedccba2b5fc5aa6baf0cbc941b3824bd95b8857d6f676318ff2399abf7d027437b0a1a3565a8820cba13897ada4b95b81cd7d6b68f421dc80569bd82388f71a75cad8459d931c361b88dfb3912b5b9983a2b9a8945d4425e15b62bcf9fc613c69f4ca755431f5a600ebc080f38f2b30ad68eaf18d515ee9baa19be46f23bcbf62fbbeaa6249b45b2f10fd62145b8a82fc16effde6dc7895e27013b0843518145b8ae524ba78c7740289c97464f39802f5ab70516dd4ed84952a676df3c5241828ebbd338906e8a8b13fc5304ae9f9ddc0cb91b78fa91dcf4cb2d99b0256a11f8f586753434e3acc166468b091e21d4cf697078650de352e2e58b4efb318720f9596f32cecba233f33c22f76cafe8dd4d5b16c28214b769590a1b249971032229151b979f4f2681c4f23606fda0f1f6b4fbafdae238f4406499853fb64221becd0c4717a7cfe34ca9b18c6d352863597f978318f14fd57cd7d2359fdb30807814b299486c496c9522060219172853fc21665475ee2c685fab16984fc195dc11929fd2738eced43e5a50a377f876f2a3dc47cfb433d24592c4df6b44b85162a9f8bc2f27c37f62d6607e24c530be60d342b3936f3a5bbba75665715f9e504c5e0a6321c1f72cd340bd564c0a8f4a33984abe49d36095a8cb76460aff50b676d30b6ffc8e6a350e1201f45795c60ea2f9087b7f10fca31aa71427c3667937f76e4740f19092bd0989ef53ff443093844125910bee9d613f65daa964bd4705a245b691ab1da05ec54a152775c88e4c638ce9a8f87bd113262f65860f438766ca4b1f7839fca3e184b87fedf776efec186425f231e8a98bef550a88d5f2eb39b44157b199f035d8ae95b55402759ea0d509f2e2084f524f1bd23394762834d529d2a87c3c4ef1d50ddd39e49cbd75a3ab2f903a431987894bb7bb1eee4afb37594eaed847d13a8593702dcdbabd5a15ae073a454f65f527c014bf9a5a5e3142eaec8cfa48ab591039896b39a1601b8b5fa8c46c5bb68d146d66183009fe1ee85091b8c298cece916a62d0c3156db101c144f5d53944596bc93493024a14268a170efa253bf821888d39a2193b087a0f0f7ec0e9814c0e9eeedb9051925a37f7e4d32c54819d61b9481a3ff4fd8e2a1c523a483ba5a1e1686a430cd2e7288feb13a5ed8a24bfc88611a1b8c3b0ca640d037cc6abcb8996692264d98839e0b34de26b223ab1738c40c8ff09b37b8fdfad5217a2e77fabd4ff41086c2bef64efb3853433c7578756850b9eae5efa7731f479ca9713a9130fc8af51f97a80e0eb98650b297114081e3aec2cb08d34c54569fa51480c2aa4746521a44025baeab0fcb2c151a0de845cb670dc8d1d37bfcf4d92b404cbb8610f5932157a416471ee9cd534361b126bf7c042836a9ac80a7fd1a07a7d7d0556f47109448f242699649f596782e3837f800907f312f64304dab4da77714dbbca839aa9ab6892ba195c8bcd1ba3d698d9cdda0817b0009bbed0ac208a9b50bc5aa0c4ff2a15cee408fb8a8a826a4e9c43edb2488a9454ba0b41393491e93dfa5d7b750644580d43daffd735886f1e36236537fb2208c019a07e11de2f8e89997154137363a412c8e432005f7cab564eaf90972e03060f2611040d14ecda72585e4683a42e34d1dff3d55a1a9fcae1773f41b5ffdb5df65286be3b93bc5879a11a2405f287d5486fcb95fb70aae51f35037b325c407683b93b5a939e9195125366914e4ad5e6554d0f8072075f8b59b2707188b95b8aa6083da91ce29aede920adaafa2c558086af8ac68f0cda313cec518ccaa22528ab2555adf515b94597c97a98448cc7bd199bf0e6b35096733404fe163220f6982955b80582584d37d3eccddf8b535bee3d764a7fed9e83cf5f9b81a28ce5bb604aab969a65139f7333d7f74496e41d17fd73709fcee0e189e46f176f19209c918880c3e1cfdf1aee3b526ea66d8c08caeb20845eac9bd9c66765276f47d909c774f58f23bb297fbca16836a6a0ef9c69c0ee8690b7eb62401e8d1957d5d5724dd24a3d8816c545b630c61225a8b749d2453dc1bd2bd3cf39d99f394719411ea9e98b0bf6f40506874d44503d3713bfa00bc4a143f695fc8d8ec1f5a264a604bff8fbcd8f7000ed4961cc4d5299c96f17ca8fc7a1caca29117b5fe7ac933c75a7eeab5244b7bbb6afd3b5ae1c4c04ba1a77539dcd8f0556ddc0e4a0222e71babc806bd3f576fa40e40dfafb3948f2dfd6246c2c2b1f0554c704ac15a9e275100d48559913b4e1c39dac1eefa29b16eca7bb9af8858416e6efbdca42c5255a47e8fdab0ee1fee8ccac35516f3432ade6c01dc32329fb76d0a18a452c2387cad9fe4d17ec3262dfdb049b9bb271d13ead5aadefc68d4c45cf1729cfb32d04565f7feebc62cb8fd078eeb2040c9a99eb6dc96ada4703134d65881d794e5ea06caa04e355d7479e72cc7c0ffd172c3c59c9a6651d23fb2ac784582a00de8268e32bd0152e91d266f95c7d7ee393d5c0ee5fccc9c364f1b2052f654291baae3464ae3b7baf8dfb72df2073fc20a40dc123698d097ee008a4fe7e9cce3b68f02e4713176b9af4e69e922f5427f3b92ee9ebd89913675f82d063544a5fc4a40c1096a8f09629311a991d3f6a4aa5134ee4fce8d931b33ae93323589478af4c488e47c405325f91b27b5ce830cec59e84dd57025695933d439b203472db749b20207fcc0a37ff58f8e1631c2c6680cf7751bbaa74a0b800532c173dba06eb54255fee3b897978aa006555c3070728e7ce1de497d90088ab54329cd680bcebda791da3eae178ff95e81a722a852d59a0461e41accaf390bdf4079089a3d12378c7ac6c284690bcfffc4ad92e564f7f4c126eac257116063297b5f4c71d3cbca2c5e0e25c3d7fea24f6acbb4e070f635c00ccc095d7dec5f10efd5b8a738f17f35959869978364017b3ec15edd851dad626d924ede0751a6a8a00176eb700f0dbe3291925fd337492876cae82a26446dceb1fa062279db14d48442a2e6affe0187588030f460e0bc6ea1865e09fff1f866ab405da9787e97cc7cafbcbc4f83ae28bc8ff109eb2c7de9d2a8deb01067943f0a0c03f5bc743926e3b5a4c21225f08e401cb03fac8de720ce4c586af059397b6c611172aed733a9356ef802e33dcc01e825e7a20005467b110c8e91ab129aae329cedf66d7da3f352ae3d8eb998289905e65cd3471cd13b4596569dd17a1811b5dacc4e5a88fa4fcedc701e4902a27e2521ea65ebff0483da6bcb19fd29b6600693be4b5209209b4f18bb222f40219cda362f7cb887e6832d593cd60ccfc25f50f47b24a4254318cecae099f98a13d0cac50e7e7936d817c2ae8eb6d53f82e73b3cb51c5ad5deb1e7036f76dd3cd84895a926ae932b38deb7af64ed9f327523ca4d03d0f5b88b92114310bcdb809c8d409ccfbb62ace098c6d0f8a22950b1f8150b31b4b9037dd1a9442069cb8d34ebd0b73156644b70418a84c0a92fbaee95a133281388e64933241ab04b3ea0f0fa8194bc30c88e558a62e0f25703c6e1566990b48dd32705565c1baac6302f118ce7bdd973f467ddd3fa7b81e01e881e93c0652e5a885589d1f7ab395eb15b91f5921900e2f41b1fefd5fc2a25b51c432983970c130c23036cc4b9db7b1d122a545e0eece10aaa13e274afd361594d64909ac151357287b464ed4606354030c24b05e7de02d0409b94ecf85a35e87095a87ddf31c631f508e8669a1366d7343f46fcb9b3ff31bbe8bd94629d50e4dd4d0d5dd1117be1e6e8d0b74f73ee68e2c57b851fb802e6f0a18f1f42b29e282820d4bbd678800d6daa96ea2cc6fbf51e782fb68ab9976799675609d59e159b5970fa2deb6b45522a30eae9658b33b6a8c03581b9607adf40cedc2750b95c21b36a860b9ac0ef7f42a177eef46ae30b9aad8086f8ec62a88e69c89113d1d864de00d16ca0143a98f9fe5584e395febeac85cb79e690b0e8994064264b51ac88a2a1eb55fc1ed628675c9cda6519cc27eb3784703c755535b5853fd336c8386b078c5b7550de64bd1e9ed56f05cbc29bd723e0bb9d7ffa0df18f2729267d6c9359e534c13a485c556e7dc8cb4ec8b8aa5b10e4e6ee8432effb853efc27491f41ee0061abe985343950bedc073ce67c200dd987c93075f6dc79fc5b325927034bc20b2e86fff93a00bb38721e9aabe6c7177688475fa7ad65d0d37b057dc374c045fdd4feeb338a5dc251d668a847d7b2dc68250dfc39bac786b23a7367b4e086cd2594cd5d48096bdd5de9731ae1ac3f10ba989fd3cacfcc1e695cc7fb59987f73b652c620e74715d700eb2baa5d6dc596b34b3d48336a67672f7321078aba56ee72b0c27ef28aa2bc82874d74d1e2e668612c4d30c7264b99928fee1559fb5d9f27b8edfb24ddaad370977d9f119762d3b68c8a66ae5504ce9ad62e748f9bb9a8f681ae1f6f37563993a9cddf22c5a15a81184761362be0b0d61dab73a99f4611160774679cdf862078bb01934df4b6549da2e1243f970edf1ca218f1c14fcf4a777482398dc4065aa1faa538a3256a024f952cd7ba4a83fe45fb99546915be8843cd40944d0b40876bb0d7dfa01f3d5499b9100aea7fb1dd6b2814a533a6f2fb0778f02f099f0dd43de3dc9dc98c03a312106501a0f4ed7660b2aeb248d1a42a47139611d7a1e731e84633f36f081c8e2ae6f40bba3992687637d021e0eb11ad24c5806d4eb56ef28057a8b065fbcf402b188a5d9426399074884b7a75925528565513cec17cbdf1bb516da6d542f3ff608801698e2cd4da6893521dbe882f246092b23f37b83e6ceda22c88fe291dd393f2a86fa609e9cfed872d0df8a91f67fe9229bf465db9587fae825543b8053a37cb4d32f61f91bf2778cdffb3e8db1898d84167e75f0b9fd06e1f954a1a4ad0d63d6b314f20f52fec1bd2abf4c6f602943a991fbe849604b63dbc2983d35065fcea436e93e51c27c989b5206f8155c54e1522c700f8b7b4588086e36c555ebae98e529c993be5b7f4d270300537b1a28242f4ecf60228392a6ca0e2831aabe1105cc9b3aa6703a44b6feab403f478bf6f20370f4e3f1bd62b21017c8e69f5804b2eed7d7853213e0c4f29bf0efc170221a7cb27f0c72fb3acff95fe5d29df3e6c6b678c90d6d8811d44b0d6fb5c87b15455d858762ce00c07ead165a71c3d16cfd435acf35245b60e524a85f354f467057e85b8b34eef31a8d2af71ee6b6b72af99c5cea82cf74cbdc0767d6afecc29b5766d0de2eb122aec026677e31357538b6c641c4abb28d84e908b93d418fa07a86f141e45e24fca9ae53815bfed674007feeceead885748abbb1a9954b7b29e0981b0875ffbe5945166d042c7883ce15f75f9f9d10c4f72348707d6af009cbba7ff79c15d892a99a2816825150396163b755bcc7fa8840b41928b964af8c797705c43a0f36095b1e4d33e5cfa285f2450ea72f2fc22d3c53eb5a5d0c6e9a1891920a9625f55cee663b12896ff5a2ac63504c4ef3132bbe74fae17a395655e8fbaeac61d9e73bad73ad286f1296dedc79e67ceeebd21f979a8a8d7dcc499d7af565f2689cf133578e3d1a4798ea3c566fb557b1628aab096706d46d0873a32f209973a7fcbda6d38c6be5803ab58084ddbd073789a08ca3a3e4263f20b73ee9662d6139e1502a28da85e3ad4ae9bdbdc10f2565bbcb7bc8a9df30d627a7c177cfe0ad686b0d3b8dff9ebff76ab1df4c9b3d25d5749a2800fd0bbdd7b9a03ea98478cacb5b65e8c7c2e950ea15fd7e515f06d74b2da54ffb7aa4bf080cb9033d0aa7b178847588a7b19eec3fa0eb3af33805a634ce0def100b57377586592c6abb9170676ee74b9f1c33d67a7f05dc0537050bc5a7ec6b89846c8f6f2cbe19b751465282c343c9f80a72540a42385d69e1695e4fe6477ed43eb50beb87b71603ea7e7b9d88fe2cd9cb79ac6ced1b6dac686af0a2c470bba5c0e5ed3fe499e9d4eb964b701419328f399b064c2fed788c751e2220065dbf2481691c5628e703eb226c0f79e8ffe9044acf9e090a8e2f562c6cf1c37f4e8c8cc3a4c018ea969ed2dd11e062a3d3773f471bfe297ffc3aebe2b079f57ab6ed5eb52cdac1b1c34193f4eb9271bf36ddc1e65851bd189edfce076bebeb9a0b757b327d8e48cd062e8cbae3e63dc13b3e6cda8c9a129fb11743c91492ffaffaa36624261d7d42070bbfa9326e431a4eb9f71d543f33e32412b486855006e7ad2b3607f69f9eacbcce28cb275ec2574b62bb24268c7193998e0619a4f2edf4086c4f10d7866462fe2cf4ebd7d5d646c413c88007ac1ae3fd2fa7d2fe3660ee3b4e148dab64b3a0c5e140ecbab75285b075547766f272a0370dbb6c593c01cda3dde53c7011f78cc614e4a856f6f7ee8212e6cba4d83abe8deb92d2c829de72e78ae4b2d13077ce1dc1fb722ffa8b23615554f3726da647d2d948044219c572c6bd5a9eb83e5b2288926a03cf19dfa60f09c183529d9044ef16450d6b9716a37d9a9d231b9a2163cf85406eb946f8367e66eff6adc91f21605eeff1e5b60dbeff8c43dd9ce7ef7c1a484d48d7b84ce8f863b8bf33f01b2ed1f8e1a38991e511abd9e90279334a79c6e17644a9178d4ff243863f7ec7b95c32a8c6f99e9200dd2fc8bdca424fbb01851c59c1cc5b22c21f98e212b6035074093e06b3c36256f044ae6ac793895cb22c74b23feddcc8bceddf9b917469ed4789cfc46e0e8498f3f78e47ce886f81c3fec7f3de621c463ab88f98105a5d8b6ce5168f5ba03759947f3e4772750f49e3e1365dcde8c61f879441a7f6457247eee35aaaa895312b26512a20e61fa0ed9ce1d66371e1ebf7095c9fcb60a5946d6f9417ce34d19b497b9acc08642cce414291fb2f94ecd9341b6f1ab54c97567f3022fe4b614050f647b11938d0177e0e60ea944d54a9e2e161caf61b9e5bc52d809b3a124b26fe5661b87fc66c77a92411c2f405adacef8675cc8477a5d793ac26479eb649f73c190f84205e0e1429055bbfa3cd7e7b2d46773a55dcc1d77bbaa3453458468d517468dd72440ea6b8a400d6fcdd34ac6168fc3fce6fcef3434091a225c00f86cbc7b73e99384859b12c700bb8eb97483c25a5574c6c37e88e0c95d6bbd0503c4bb4fe8acdce78be36da16924126ed9b8eaa2c1299c4a60bad8a1d276f4f945f1fe413097e99663e553947a86ead3cb33a54a211d497f6fb0b424972bd5d69b8c7c17440a9045eebc3e25fd0de39934c2ef14457767cd2fe8979fabbd2ed3dc752e043cdce540be2b685e344c065e4a077cfd7f9704420944a93da2e10454dc5c3efbbf0667fb3857a3c48f372e8ff8b02ed955743fbe8fbaad30d4827eb8bd2a89139c4cd811320d65bd768a57f8a40dee760ddf5ba410b45120cb5ebb38cc826c999624b69d2de817c9726e649f63e00227d197271dabc0ba53c839fa7df33df40f3104a72e0ad42d5d9d23faab9d441c8cdfcc62620c9fcaafa58fe533015583e0d3f5f298c92355c25c41ca0476381a195cd034e3b1d7b3f16b7935634816d41085565afeba97a4639c73cc5a924bcaaa25ef412c0980de53d54e8c5bafc1f8e76edcf42ffb0f468d6997fa0a9c5990d4439fefb21ef8ffd8c9002ac6c6c5ca1aa3ded327b37d0a0bba795e4be3539783cc19c1d4644e05dd9fb8766782127113d0315405d953568e23cbf0f9c41908d11876e09e1c69e7ca42428a282cb612daf86c3767fa9041b7542dab5b685a83173ce81d269f1f2e0756f1f094f50043c1f0481f0936b9f17a6e972703bf38b01f136d937c0e277f9faa4191e3e6c0adc545f40cc21547eca2c6692a6404ef842339b5f045e96e6565ddac33d940418112190f9b56cf6221a88a2f2881fed52db5bd70bfd5075a4a5b469f256ab83c92543ebf88826a678905a26c112a2be69db44f07fd395f8418ae78abb0c326a6733e20f6a1629af4b5b1b3b79bd756642612f82e111cc6856317a8176275f4524439d19cf12b73a0e5fa347130c1ca99d8717ea40ea9f1ee00203d9d1c3e19d041fb4b9dfb4568488fd5ea9d8acda0427663891c5e4288e3db4f26fa464802f7a815da973bdd6983d91a486733c6cf4aabb554e6e0523bc78b7d961720c156265253adadb6ababd1a1761bb651697d9bb8294829473ed0382e6ad1a166e2670f6646f149085b9559da1e597536f1f8f521ac8cd4bdb4df69b6ff194da0fd1595035b4ac594e34ff42b8d675a6211c6762a2d9dcb9d4bd34f9a9162568e63265ca166392d10f0e3bcee96ea86f2f54eb69b149cb47f61bafcbc13b9250b6c60b1b73186d1742a1078dfa4e953c85ca1946e76309b0303890ca9d4257aa79063ab969bfcb0f2c093f44f44b655afc1342037c41ba7a40f05f0a3c4ebd4b87a3bcc520a6e80ba7c67ca4473e45a0a1bd6f0f9f82cf7a2bae14207f42dc8a44f357ef91af5c2bee20289c6f1a7162c6e5016b8d1862c1f68daa5b0810278682e314bf0822e5cc53e04207c313516710e2ea25efb027e764aa73549787b0dd47ed2b5e8c984770e6b1c7bb6fe926c9f3a886df3ebb4cb00257c5b98f08b0207657f0e5a9135afc85eb7600c0877d89b552a9f1cf7a0074c10f1bcdf335e1f392c3742e907aad73f56a8fd11ea12906a7b905971cdf51fe7f00fbbb5e39b66fc3d2ded250bfa858a2a545e01e122404a3cf006388486bde79327e3fcfc590a07ac2345e675a855a56113859b88681924fda7ed1cf302ebdbc0c0a42fb6d6e03f2bae4e3e58e9ccb68a4eb069bce8b4d9241ecbea907d74f054001ff8f758c3db9b8095cd93748818acb7cc295c3393097157d1f1255687a8854c7199b191920c9991e588f2c80bc5207415fd5a639d80240e9fd8d5179c77bcb456eb19013e6f8b58d348e4381cc6138513f49113be0dfd812766cca9ccaabbc5f3202a8d9e24d62afe61c5bc5ee62c086efa79ce374a678b3d88b22961fa2edc3d524e74b3b0e6fdd4099aac420394ab05831478aa41ab792d0bfda5c16b4fd201197bdf215deda09d29bf0e1f47b955d39193a58d19ac4148dc98856f5e94a91356f560d7472ef97167c1ba3f2bfe58c9cc3f15be363dd1cdb97a37fbe6a37bb1ce0b2941e813316a558523596eeec57314b66017324a6f2deec292396734c80d1e99fe59214e010586410f8844ddd2a055915e7c74ce49750d3d125b6da93eaa1d5d682194381f08b31d6d63e277f1183dd441adb3b0019be20da3ce42d4f9e77d3ed1e46887686a3fdbd839ccc81b8cf213a8524df2054096fbb8821e37a72673b912975525bf10eb8635e2c86527ddccf2df0d7e2d25b7552abf206b3a7200df50887397219f1eea15cbb56cb3c32fa52de92740924c6cf3042c72a1530c2198e910b36d340b58c8c63985447cf37132c88d30e9a8e5d815e5fcbfa8fe0fdf4b481b9b358b0ce22641f657f9d8297752423b5759f41a36d3797f2fb555983d2b96703abb6f011577968b42863bd3971300ce1c672376fb37ca492f314673d16b080e8c9429daf79bf491e9e900328eece52d7e5f941f802ee4252e7f786661ffa135e897201f52b8ce55f32bcfecbb92b5165184b53110eed848d59ba3b71a77a1f4ef39322652e5c8a32264f2a4f88e46af22e76f3a005cbc012fccac63a7c8757e3f71ad63618a7c9aff474beea48e4b9cb646f7cb3e6dbaf08076504a468c8c293f068b22d6d00a603838d4dc3ca8595f4beadb1ffe1738089c73f05cf57194fcf244cac36fc9411fa068d5f923cb31ce441a9617ef65d694457295c4f9e31628d2ee3b226e7c948af99c6d3fc58e1c72705bfdab4a9b4fc09c54f92f3ea58c888bb836e92ec2f67e69f7e82b04bb70164e3c4994609689e3479a58ec9c57064db163d22f3116fa7a6ea9754925c89468329c4aebfd5a6cd9afc166e340068b4aeae2fc749c931623b45e4185ca56d699029ef3fd1901e89494ebda76db278591e9cbdd85bb13a112c9c0a98abc3aff5d8d88dfd0195b9f04860eb512feb0a6cfa971e2173201dbe7680cedd6e2e40a744b2b61dc8098cbfc08f1f5e18c954eaf4820c3e274fd7e46676ed4ad43f6cab668ec859d18a53dbc328accf07771bb136342ded5361f9cc40b05e95106e24cc838a8d8cd400a21f79cbe771994be424c74b2fe740949c01a95d9945f60f25f98dee87bf58666827857120f29077874da1110b830623412c6707b9a54e907ae8ca9efd52b237bced05fa9c7500dab8310d1066fb3156c1ecf99ae2f7e230bf930f2cf17df923afd226826defd4819abd4fa786e938b723097b537a7b49bda717fc5d1eb32c4718cb271b2eb9f27c6e12e5d768c0ffd04c5288b294a8562786ca40e5f13d4f9b9425cb72d334bbc1234736429eb5b17b6bc87885c8fc2db8e2855d41b20db39ca093ee3cfd632f40fbee325cefec1eff0b306b0cf022527c0db6d9610afd09e2a5dc9cf0ca71f33d583eef5ae62e09a3a047eec2b372cb660120dd50c1849ade043d7bd439b90602124c82601133e4def541d89ec39a86f64055161efb9cc2364c28f60f2adc9bafb3228c1ccb53b709c6cabf8faee058cc13a4ad773d54ddde10cbc8c796724112ece09a700b7d93bdb65ede33da6b61c1e370064dd8fc0889e821a3d6c848448cc65d0599f13b0abe8e9a030e47edcf1c30c41fb467175a5b003f73ff74f1a6dd6db53d97db6a54a82122a5880bde34db02216191d12b50a91f812660cba3064cbeb1ae20bc5ebf8968de5e5125c50e086d9995b65ffaf64579181a89d76fa03b53a1d79011a1a8991c3d71a6f515d58a299b91d1732d7cd09c996a5908204d68fa5f1fc9d93ff37256d52f275597ea914ebb23da36d82ccdfd4d2f6b3d11c84b6a1de42048184075bd843ca890643b0f7e4dbac2db98458755ff73e5b10eea6e0e5612105342087a2b3932bc3d3749954a13464272f58019d0b85be65e28e4ec4219903d09aa5e23cfedb2cea880142a30d621463723e87d5afbf10725c5e86334318e2d98c347024e246dbf5df5bebf7f995cae6498e1a232b5ff1b0f42b296782c7e63f219cee994e434aef99550b044022227d070c07a831a29a056a81898e15b36fcf094c76a4bb3ad233d29b64d87405f90b1fe0c7ce1c7f54ae9dc9647af85782862c8f62a628b6d69af1a030fe36481cb9902ed66e3f1d387661b95b67e399c20e0bb4f1caa4b1883ef25894b25a2174ed452187cc02d1da560c7248ecdf7ad3aa59774632d68703e276e75f3acb88c5070defa3096214e3c555d8f7d1add0a1ca91e7cbb36dc4bd93898571d3d715262f6830e48ab6b588a717a1f23477d7dcdbbf3a509e7a3fbe2fa06595b0b4be6066a66374048cf4ca498aab5c61f6049aaf9f45dc04471b2e40944183acde8f4e24f3092ac0ff409e909cd58284f018de61ef40b918d14c03f87e260355155a6f901202f434b9646539f9281e16292b04a765d94950cf3323d794487b3cbff14ed52274bb511ede1dd48f98fad8e85fbf029870441d3b168aca4fca448acec6a4869dc8e55ea1ff1657c16ddee738f7cfb1c6c6f1fe4868ba32547fc954e104472201739ef1b45b243844a33f5c96f7f49d0b4556753c3300d0b34feaa8ca38140cb5d85d986f056b8f5603272ce93ac34e1778d84751ee44ad0933aff250bd09935a47edcba680d6ca127c8845216bfaff1b0e28406c9d56198a4b1e09ed6333bfa988739a79f665163b373914594a893c91fb7225ab3daa99d57c721b472e2ee6d6e1926729aa800f5f6dce139af92ee45fd6532018f21a636ec6d1d8ad1404edd0eb8aea40983b0f818c6593c8cf00b7d5cab659a143da1b5da851951dd871d78f964d59080245d1201177e498e34e58c222781e4071286715c03160ffd6bbe78cd9c918c5a7d8bac8ecee0eab7988e47dbcb91a77b51432fad5ec6f8ce88953f6a2a88ae4e5d5b946e502db1b783c20420b68b2078c438868c4684b27b231e8c4ab52145304e7dcdcb142eef773a612ac76461a2e2e7bdfd6819e578ec55c8337983f3595567ac3e7e38b0855f52ff3e61cc1e7a817bf049d3b24b6d67e64de053c0bbd653e11dd0026e92fc84155b09ed1feaa85dfad23f040ed829fb9f8bfd7c9c6b0772dcdfd55498be9497749bbadde3a341b6961d73116e19bcc20e8209dc0d1f3a09d47278f07f16dcefebe05612403e88053ba25caa2f2e0e08fe173bd18536c7be67dc868f3ab1ae5dff4b9b18073fa47f927313bbc6b9df2b76a341e91845565789a9d957be8e4c65951d5cce998d6affc4ba8a72a373c7df03bccffe4176ad4b0ca2efe78e6b5d8a60459425573b176d51ad94b35fc7aa25ce47f1d22c54e74132c23cc0fe879ea7f555a86cede53b8bf88a532826c7c97833b5dbd130e900b371205512482ef95dd764ec4544ed96f701f5bf546a1fb4ae66a23f1d845423309cad833961c7c9af83e8e00d46ae0fb68fb782a21e3b9fef3c1e2644c782381b8d5fba6c91b234f1841a7681499e943bcc3eea7f43c2ad2b55ae54e59ec38e17f229017616e3e85292c6967783736a6f168a198e95c30d059592318750cd0cfaab81e69ca99adb2372b429aa4ca01db4d86f54a8d6459332f73b6f4c2bb0f8493d975508ab45e81e46ea989aaaa58dfeec45a9ea0db22a90002990e5c9f8bfd036ecf79e80b1d0f20d62a478a076a8f761f6c882518e3725270093196fefce6dd673f566b94e35353487a930ea737b84aaeec193ce9266f65101e4fb01b5da20019e1355d8faae3ca162fe9368789321c9acb9415151d209529dc2b26515b86ff571ebec0cdadc09e1b9dfbeb26272d12247b491e46877cd7547e08b130f660cbef9ad08df0fbcfd061b7631669f3c93f6ec07449bafc693b15a70a46df408adfe08c2142e42aa846399622da3dd1c8eee6b3f0e2f54cdba2a0e637148f240ca14aeca1ccc4d36d7458cbca3a00a17234904d655aaa8e11a2bf8db1fa985aa35461fce5d801a4f15f05099c26850a824b0a9dd3723e5ae54766e325a950c099cb69e1fdb79ff466f154f74c846a7f67c527b7cca80a3fcf89baee8344acfef3e96d39023b88d2ca002290693eb12cfa60ce1c3b234d42e19ddb4125c92ef5328c337aa9cc252073017ed701ca9bdfc4cac906dd7d37746c59e279a6e00a0f92c86e3412a48e127a99d0d6d8b57cf3b2ceb9883dd3eaf7941039b9ef4420ccdcad710ebf75ee384fc3ad202935c594b04a70bbe571480f618f496cce0a58eb219f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
