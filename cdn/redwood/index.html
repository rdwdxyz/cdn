<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92b589f875df54c6a65dca244591378507f72db9310fe192032c6814f030b10f9d0723ac07f585cb2041db33b9caada6e055b833d48803674f180c98d7beb85708761b1dead00c9269483316c0e841a5cebbfef5f97e0aeec0f29c41b5f3c0caa53cae2036222229946ab5dde0496095e371beb147ef561441e7b7e00c8b2870ee1ac529abdc48ff180a00bfc3d33c3f95026716e8fe4661f8e25e895f94148122dc365013b6d7d6e031138d2d2f8f60c54a82b49fb7c78711ba0aac3b6bf9bc9ba787b29343bc276987d5ea38e42c705371fdcb8d270051e4f3f23dcdc20c111440684661214de52c0afd95dd1e9d9f01b499402d1ea1208e8c623193f46a7dc13402a8d1a5afc49a1e9b0871a5af9d616aaa8f076f25e02600c3bd56c740d3e3c9a346f7f7365ee3396e17d3f4530fd223af9af622f9704b379d6f03be122b62d353356bad19489d1ff75628d15e4885558ce2fff2c10ce0d5cf4631aff6a390195aaaaa5a4ea81b59ad2f189b6c95a0d29e20af223622dbee4b5449c6784bd95e4e93716a5fb55780aed149c67feb0ce7632121f01125923523b3466d0d231a4024f40b77279dd64b0fc7b3569a04cf6ed56643ce32a12a6b68b6ab74a69eb196e4abe8ab5c861f207074f15a6f55a9e48f4930d1ecd0f068264fc3b9c61e8b49189786befb5a30fb416697295c0087ae7a6b76f3c47e11e07aef3c3c2532fc40098ffd3905890a8752e6cc47f1b4650e94cc8ad465b318cf66361aa122853e765975bd6903c08523eeeec131faa7c647e42eae12f64c2c0e3db9af86a2981dfebae7bf41a6f1693e4189aa395a5bbe1ae9fd8d416d26cb7241aadc51098daa7890d8f2635d2c4fcca0024b5c99ef0ace76620d93c9465f75080738e96d4063773a426aa7e7608659d239d38934ac41f42bae226be276735aa7ed606cb2ab293f342724c8b4b7ee43ba82913030207f8f96ff460cafbce9ca76220705330f34fa928b7b03b710bde55883ee65a0d1691c5673659cfa6dee5b74a65a80487a1546820b4e10946206266e9a4c451cba783327fc8cbd6918912ffd9ff007ad6fda7b754cec63bec98a936fd1cedc0979c8cc44f9ff011d5350be0a844f757620849ed20de557de76e7c883b04c1d1d7339c7c79c46f078f5277bbd7b7217973bb17531cbd2784579aed4c96b139d270480b4ca72522754d8360c858c03a13a5e23fdde7330eb3591531c456afdd5dc41d13c63cc98369c9db8ac81bbae113b988164dd79942493b199f93e0d6fef4141e2735cfe8b2161b69968778584836058f62d18e89bb04903e4a3943b4cfae6d81b33a08766d2e58baaf6469bf03dc55a44ecee9a70d5f79f4da55f2691ff2874845ea5fad0b6a060689e1d9fe54013575caf3ed30b2530c045e224dd2450668a26e833b408b1edcb72b7fd19688da3f117d3bac41b4b0324e866f2bf7bc880f160fafc1686997508d51530c143c2ff8e8e9bc13195a349e4e913e618d5b1f897529ef8f6bb4e419e06046ed24a47eee78533ce64ee3722ee1c34267a05480b0cde223e322e3530e087cd06969a2ea8d0029057e551a7a722879170f4ea1c48500fb91a7a8461a7df5faf7128504ac1e26e7f342c18b80eb5aba4e2b99475962940109d5e9429347c338161681bed34a501920adad9dc7efee1f702256b546656e7e1aad0c1bcc83f322f9da46e193c74a2e726346513c88c0d29c7e13fe8f0c02ad0e12ca15a126cd9dbbf4d9c40fd686ce0eec055b787a856d05a66be69373fd3f1a530f74a998d9bad01a1a0ae4c9932d8964ab5a3b8b0972d04bf56db6cd7576903f020fc259ded61c4675f4e5ddd60a1e78af6b1fecd411c49fdd4f2f97c04decd84bb0d90dbd31d841b5fd1f91f71a69f486ee4d4199026674d0830442408334e4de8d6394961a333a6d3230d544678da1496a497ca0f3518cd72f511f496803fb1ff4536b5f4ac74fe0c55d4fcf77f89fbcbda60bb944a1aea8d80e6017a5a3224d00ebb2939cd3c17943f55de7d88524a6c6e062e569a0c83e47c7cacdd44eb252eaca82e7ef8bf49215a53e685b96117aaa771eff2ea05f3afad9284d1a85082941a50a1e2dd2d726be514101d97d640391ab1edc66dd608c0b4c44a3e5706a5e1d0704286d84e4ed088262ffb7816d00841ac0946ba2058613f283694fa0991f0d479ecb6af498c7c6296bc86db4022982c2ad415da8bc5b207f7332756ac69406ad9ebef69a4a7aaa47c72b5136aff1755d73268eabce816a880351ea12e34ed152315efe00c1797c261f3c131ee9240bc4865b9789ec66090aabf0ea9497ace3ff5a2dce9bc94c10a4ecb3cedb918422ab8c2c47eb546111c3de050e76b3d4271d9674ade8d268aa0106f69a923a42ebf0de23f6dc46d24159813316018ae506d4b0895e218711cb1e731888fabe510606c1bf8405ce503f0ec4efba28ea3094000eb8b97a4204633b1536665558f3782402f2cf10733c0ce51a873f0e24aeadc89996e116a4d728a0b60f9d0776db06afb912534371416adfa862df2688656450a56cd88fef917e7cb8ac61c3d3e151684982cda280fee5ac5c34af727728794c06216e540c8de6ce7c73ff6d63906dafe8d5e43aa1c31a73d1fa6f17278a0387353c91907638c0537c6e617d26db5aec201269e2cbf9e2d9ccf86624633fc69ea693c0ced3131248fcc28c967fe7ffa126431f856689bea55df10da22f9d1aa4c9d89e67ca1a2ba0b4c8e1d50b5ba5efff1754a131366aa59c6cc70a3691210954485eb13d119f91b0cb37815354cf9583787baa104e56304d85250a8a1c6d864006fc6db1bf445222b19f2d595a7ca7c5d92438803ad409c8db5530f541229af05b861f320d3fd86ff42770809693d6b267234b0150c6bc7f5da7c16420e4e6ae2f8e5a63dbb45b9814618fb4195270117c0d233a3456e64b4d03be44d37766175c39bd8ec47254cda862bca52ac660dc7fb0bf8b693c0562648f32b30a607340e174151700451b5dd6140d0d11affde0799b95948e58eac227694a83b2ea864f8db3cb4601f0960d1723452e2dd18f99d604c42ea82d0c648b15bbe54ec182a760424d7ba0cb6ff8f75c7c866abb412a045832bad673fdc8d308dbf7319e14c1f7d3275e538ea5f5e546c11741ce33b099aa244eda66cab352347c9c8017c993602a7daf2600268c62a5952d7f320f8652512c899f416ecf593a8879fe20afd21618990150baeb55d9b11ed3fc64128f070b40257e10ce4977de5f0ff2f31f061bcd63f8fd37e45158fb81d96a28142c2064d0576c14931da2890a94a4c8a5c52a6bb91161ff2d5d0447239f98403e73dc439d1506c03d527e8133f450e398d521394a23adbe77fd6b1ad30e084c7fbf70ae0b790198e3ef1e619d66a9979a7f85fb3482090bfba873b443f20b94586951acfd89f96c340e73914bcba63bec2a006d18beee37131b44b08aaf04738c9b9bccb194285d2329463f381da69e4344d6242f2296cc1a1d11cfa962fc10a6e1985714e05b3a1a2d3b3254e24b22620ae70224c2b4757703f03a4810e87a1642f0121619940e7370e37f45032bdf9b30a8d96681455e3621b44aedc0d61e2a294bdc39eaea086c69187dc495c1c2bb510082ce1c7093c0dd856cbdd88e6b4b45600850708d6c9090f553cea22a789f184a33c948991760d03301dce5440f8aca9975fc33fa399b9132027d5c6557e9f3aad9967b2d0d84b4c49029f831e60b9839113b01e06c4837e0c23b3ab2715c42e7047e6c1dd330543e6be06d0a04d991b363bcde2c1ace53ed3618e30f98915a98441dfc6a277ef27b83d0aad0336f75650facdd0b4fb6ca3f8c88ceb1963fb7178725c7f9feacfcb8f8707ab4129a3dc5a445f6c9ad777a6acd5212981826fe579924010e80fd1ff4419087057ff4bf82ac99b9677e7b5e1940dddaf15e123dc447ae67ff827dd6420ae0a6c2cdf9a9b6fb79b02b4001ee69ec28c1843729b83be7adc57eaa7d350a01b2241f1590605a3169f329f8dc6ef9d5a46d075af09bd3b14f9a5f566b14a257c19ba3e4d1053c91d356981bef6fd0cfb87ddebfab488de5d7dff52269e53ab16d6dfe2054db4bb5f9832ef666730a310af754d128a37452ce67dccfe4437c3da5354c185a099fb214ffe0047f12ecbaff20552d9a02270d911652db2dcc6bacb5c1f932bfb44e1386e015145a65b9e7812aeeef3bede22633d8f9bcccac1fc39d82e36354f1c0e68b8936fb16615fcd769a1e65bc584dfbd11eb8783aa2ad21426bfefc99318bb20f3f032ad0c100621f6455e2f0a9a1d47eeb8a5f6178d9a1bd33b191ac82e3f9de58e33aad520be9471621f4d2090927825ce852db4f453a84025293517ae578caf5dabdbe983e00d54711a7cb80bada3eadf25eb2e42bc599f29231f58946f543ebed09ea7ab30f1c87611f732a395d9ab6cf03b81bb92dbf4bc465d66ab6af0c9aaa8d8e915091277813c666e7c3714e3cf0ca9992547d203c16ce91bbc49215d4b784d0256668b32cb72f93535f94a1e6c3469ce3c4f4a13b1c979b7dd3b187ee1fe68f7e25b359086512eea3981b02196884b187d79d8c9b212c6bbfa782b43fc7219e95b648b4ec7dff75679f55007e5c4c35ed9b246792754f8f30620608f7dda85a7d2b9dc231c077e766df548a1e6fc087dce49a438bd456bdffc8cc97a8ae53baa1ab63b9ccee40b7e1852a18e50a5331f05d74a842eff057c8ee34a8ff9819d7c0d5d654ecc039a79ea5aa8a7107beae4d890bc86f5bcc4dbe72127de23e23eda71864f6dcafaeb2b9c8d483f7ca56a6ccffded1f9d3f43d37276a4adcd04c548d3a5d1aec47edd7c4d0aee80386d7e161a028cb1ec664eaeb4c268de3b5c59460c02135a81d9cd68a84e576c4724dc0227ccd385dffee0c02d37801630cc8caae5ca0cada6a394200702d3bd2dd663dbfb9d4d3af7fe7028230f8f147113e1ee2effcd399707c29b00748c5e5b8c30b7c6eaaf9d49de51d6fea7b2aafbd9809f597a3d59ab89030a879a50ad942ed384f941e6bd011ad22240f9b2e24eff6f79455bdc0050c42c1e376088f673b6b37cd2fe51d12ab72ec78eedb7f98caf1c498cd14e360486219a6e7ad4e7d8a523536677c3253db5d5e4c7ed86751e28f11497a8f35e172a845c576105e90d07244106e33017cc5a85eadea83f6d4e626df3934903ef6d7ce8a52da6aa0c5756d2d30822c9095a8812b2235fb0c160ced7196ac533154c3ef984a6d4a8243e0e8388a907977a43c0290c73e5a49043dd28188fed950f704eff56c10a909547b091cc11a42c6dfb7d954105b47d49bbb31e460c4ff038b2c969169f61fb2e949e9de3b66cf7417c9fa4e887a91d9cca8d56a4629429176fc3fc1aaac1e886d5ae030d6cc6b60a2cc5e4d5962d501cf6d3b39506962d12904d96b0997320b785f93d11a290051a12139d0264da6d1c3a9dfefddbe433f6605564c51e2080bd9fbd3cc7f35f10ff0d7423e01263016cb56b7128ef261b169b9d4fb4b3088881be7e74150b4778d591cf3b66c496fddab94ff31f05535bbee9698c81ed2da949ad56441597f1b4264a973fc2fdcfc71a19a3c878d6ac2c1c7b39f8b424026d40e1e983667871d882898a790a67e56dc577d46519539e5642f3f61fdf976c7642e6447b3517d79ca54a7fefa81fb8a0a3a10700c3e25b5892d32a4630770af7007bb7f6c230ed4a8a065cd6e816439639744e182cc25493199820a1dcf2df237d29d3a9cf646982aa14ac03a40d4d42c840663e690a3d05bb16d4659d8631ccb1e3422077dd0bdda1b4217952cc6e9a883d2fda288eb4e0a5cc5c68ba35ba08cf82e42ace717e40479ef710b520c428f039b477284a60546bd15d18e3b2216b7fde570f55af8dfe2d127bf5008b932140d4296edbb17e2297fdde08ae2eb0adf51b2d9e091ded8a060fb48cfcd604e783b1fda441012c219bd65e67ae980d801dd487a3ce3bf2a5ab3c61928cac85ecb20d056ae614fd0d61440a8bf2d86cee1def26ec959be9359b1a4e7cc5aafb34a48ca48aa1542035cce49fdb0a3b8cce6d7853d70a0013a2afaf6b3fb5167538842b050edb64daa596e7d37e88b65eac5f7417ec9966c1fd146571c54a0fced40952fc01aae357067cd156b377cad212988ca04c404f0cc6e6526eb3d30232914ce70f4617caa7031a32aa1a5f6de8a28c842d3f94241b23fd4b48b59906960a134cc35b6b83b54aec8bc1c72ba687616582fd9913906fcdf5f53642a587a7ed8d7c57d3449ec1179d46137f1f8cd9fbf8d6c74ae2531aef64590546b8f834e03553ff4e5c24f9b7797d657ff781617151d719ff4072b60be8acf166250e236e2b7f4d926e358db55545ceaee722a0b2c4d6f8ecd88faedb18e10c44359ead220b4fe7e5a46c99060e4f222a4d86051df2f88e97e04f5373dc7b52cec12c3e1c83a0eed30785ccd245359167bd57776f0368bf5ccc993d085579af6ebc71693eb52e6db4873b13207e2639519945696c67cc8ea5df635c693b6aab503aeec09c78bea8586f5496982dff0cbb0fa81673ea9997191d24e13e94d9ce58cb67e5068c6b53121736564cd24ec3843e61abef554ce09b982c6fe7ad1f95329cce3658d29d71d940086ffb6bc12ac8aa61c3622581d83a9cbf9026fe5df2e6b4fc8ea37aa03df479234c98b710a7c25e208b12548f96a460dd5377fe949e97a25997f417929371836cec181288a4ca44d99039da1cb305f72c293f3f41505b724dcff3a201d704dd966bad77da5e1f51d575b943791f4b57b115a69e12f2eedf8cebff87c599213ff88fff139ec99a87b91aa46370c85f972e2a588a8cb84959b50902ca17628d7aef9392ec4b21d71db912a02675e2a520838d1d143113370210dbe912248a405adb9cf368cd2f7374d7dfd91cc69730e317980c42cd087ebed190abf5ba0985df063021ac461b92ec34a88b5a831daf53bde93ae09d7a42fcade5ee1ce336345001242d2c8e1cd9ae686acc9c61e90f010ab327d47af1e7023b6f4d12a9f2bf25b6cef3c89a8b9d76d32743cd071299ca4f4fd8a168c22d2cfb8168202ae3b4c52a63c8d48e2acbf06754dc7c9cc5d91a1ddb2795a19d087e307a3b2b9af40d3bd38828ee7bb786d7a13d93d808983e48030f0509f03b8fe7de5d50329b76eea22b04e548094582de3883d3c821f9bec2b78ac208999d9477e022ba173aee68d04bdff111c95a97668f4a4a465361814e565057a2bed21b2e212f394dd40af1ecfeeb8ffb7ce71fe3141cb5ee8d89956aa929b328f48c70c7dfa4d14c3868500a6127aca4d6b505abc885a2266dde6495daeac78aebff28e9bd750b5436e7a30604d329e81641c283d9ff7360ff80c323e5a40c8e9454c1a2716654ee23baff9a125f97e628ea8ecbbd2bc6954fdc231853e797adf3e6a0b7db7ce283bcdee4ac82c0bc1ef0ac2af1d8816a441f408408d9e488d5be15a7bcb53485a99646f47e50c1922d9a0d795d4310d0af03686e026cfc74ca6e92bdab2bc30548e667dab62545070d547c1c5d0343916e96453917c76c134ba1699057efb085842c667a91c3dc7ea5130cd2c7edb346f561d97c2d6fbff5a8c19ac29e2e8a0942bf8753589a16107ead9d23ca46a3ec542fe0f0005e6a944dc1357823403f0c1fbb7a36c0fc80cf371ce602e80a459c8177030c834b3c6dc53109be2b4aa00dc87de5ab2bbaed44be2307ab5c59add198f1db7e84ed2edc3676319842d4947967e9a394a85282587ff8759cc57311b1682c37218729d1df2bfbee080e71d3def6f47b0f9a0b60f15dd9fb0dc54ef599f76a97c4514fe9cb7198c6f22073f310208822d0e770e4008ba249c739c61b11690930cfcfe25eeab3788e9a5d4a1897ce1b99480fdd069798b095d4bda9d75454a1c91ce50eb209e5ae59cfa181ad0849595ca2fe49f95e5e6613a7864e1f952fc6c22cbe8ad0da8c7ce5d1abced0f03ff567993374d87d01a136b009444ec5612cc7f65fc17de0429c275093f235fe6d73288ec395d1f5f09c250f70395493eae47607f587fff3d3f2d6a217fe54e91a1727a87aa37a35f2349f4de3b057c986d34c45c6f1e0387164afdd6ee6e7e8c76ab58a316cbe10ffd345e304d65ae66893173e734c1574497f9a0f6087db3a11e771e64210a40d1875645923b242f13b52784cbca3bb675fb3759826f1634d192c461a9f485de85c776f36a74c8efac995a641838dbc1009d3069fed38ce735111d1c51ce384de997b06a52d0f15334818a2c0b39cd293e8372e170918be33fea07841267ad5dea770262f914d79fdcd4caac0a95475b9a7a4e379776f74c80188d4969013442fcc3babcb70c6eb036c228075acb7c71ccbebd85bd45d26cb2200ab8b44a55f1d6795f28162aeb20b20b75856e31f6014ec8c4bd8dc448bbad9b1515829b659268d801ddd9f433b0e9c922d170b7485569591118561dcf8e8112611e7e929abfb343d22c609367b5813f8f86f26474c3fd567297ca53100ef99af842a4417b33c139f2e1ef54c1e4d03f8b522e1f213cef98a6a2baf80963e30374ef30a99f9c7c50d5e0cd220757d099c21bed6689beea55e2c549a394290ea235135f19c916a29ea95b1331867deec68be3843f874404b6fb9935c722b7516b2ba05b56192062a110b992d50bf678b5b1a048344518ab9d48bb18a35ac14e4d5d55d413d1d921f8375b2807e0aac9a29dc0afe62e30892f28f5e55e0d2e9bdf54851e1e2730b2a6c599011c683bbd9d2a24f0442d9c38d5d92f8377f1508270bfba06dfca30b660e4de45d914aeecffe2880d847067e82045d852c29904a176144c614a1c37030c7cf20fd790b87d232c989024797420b33a2fce4312dcdc6e9223dd0bb4a9525fc1fc7b2ccd9c956ac6f9eba286b675bdb77415dc504e12e9e80e6cf35627aa96da9840959f91c4a5af966189026b768df15da3eb7fa11cc0e7e0ec143931093e6f3e0b2b4426d961b19830adec9dbade91ead817bc79c65ea357b6a601ac345f7e6f8dfe19d3cdd1d2efb4bc8df04c41fd7e1589cb304485a4388af2b2e9eb87fd4b219633d2c92b5c75260c7a330a09f19fdac076d318dfd0b1358b1c12953444a813ba77ec106a92685a318e749cb3f5d3d2884dc0c9ae8ae8b080bdcf5dbe19d86eb7c924502c46b62ec13b878d75d9197e21fc18b77cef1fdbaeb200dd7ddc56b18c955e7d21ea97f89f3664335a9a949b07693a3b40a4da94342babf3103e699ecc17458f6b5699043d8ceeca9e5d2aaea30eebb4fa1e9078cb711036173faa13c22e33aeb49d95115059630faa5de14bfe7675393910f47bc8b2e31deab40d529e870e6ade339f60c5305e144e2e88750eee42fa44902a5b8b5e3e251616ec97470ca7be5d3df2f61f01367abfcf97b41c268ea07a9110bd534409fef5bd3f44f5bc3f0b46d36febc6c85a623981d232c40641097964edf34f127687215592060296a112787a3a5f1c0a65aa201c9886f99c0a4735feab23458858faeca1078596094d1e119012ec4b04a8abf91fda33e894ea45d0e3a78294cc0bf988d8051446e61d14ef869e2efb38ca8200f3c19a2c2229f03e8d4a20fbbdccbebd17269ed25b969e776c9ab25cec35e3c5b75238900c967096778df61c3e6eb943a9e42a6cffdcd1b4d0084110c6991313602428dd055ba02a622348da8da21ecd06a7a3a49fba8ae1c6166ea849708f3f933d99b7b7d5968159dbdad04b107056aad1c0142db294e57c1e6ce8455891be8cd2b7d66073df041053c37ce66d20191c1c7536d7e00706a70ec2fece295e599fb89d683ee353d5de0d71523447088f6d876a0ce9cb27ffb4174e649d7669c509849264a0343f39feb36ebdbb72cb02373777c13193d4d3d312a511b1ca0a5a90a1756d2c84c36930920577e8b1e9cc8de05c82a1f4379c90785165c66871ae4700d1371f47bfca4a3fa91b9ee8b9a0651f5439006b5de93433e992587f28d14a9610f0d08d303c9c7702023ce5002b07355d90bb57f992fa051f28ccc02e75b91fb5bf7bd720ff4182cc0d3cdb5779e7c208790ea373359f7a568b8146c7ff9bd70fe49827d6d69f27d9e4836f77fc1e1ac4707073d202ef265825f72d68c4be7ca8f2d5f0f17f321fbb015349934628b65cfbb09faa32a4c804dc1b2f7b311002b53cde4c8b6580225519699c6eae76422ce09a829ae5e42e2e7c7ea299c910868ba437b68ec0322d937512aa830196ebfbf68050b42f902afeaf858a18e67dd56391a9b0c8867c88aa4e36ec486e599aa78b01a05eabc652d7bd44fd40f24b2d11e0d9753b6a730addbddf389d95dfcc14a1af8df24f263fb71e81db9e5f142177df2e994b10bbd23a6a52d0aae998e21a92bd0860694890a06134113d775aae685fc75edfd7546bf9f07ede41affb9430b399bc056bbea0af03ffad377545ea1356dc6f86037d8e7f79c08ffb2244fbd679cdc079a39d2acf3e9863e8a46edf66ee92775a62ea71ea47d8c1ffa27aed25869a9af188d6eba3db3e8c929d11cb42c12669e605558eac45623bfb010f91e989102af4ff6efffd71f391acba62bac0928fcb183c48c5d5ecb25939f42d479976399551939ed22bbc15745135b55b550bd67ba3759e478b12f7c45d729b1486e436eb8191a9be3a0cc92049e16e11fe9aeea93d149580fa40d00d02e6cb38aaa0f90ed9b3b6469da413603d61e5ae076bdb72753a38acb0e1d8e8e776b392708e5ae43abea6106ff607422e55593250edfee921c170a8fb2d89afa46151fdc9d321ed96b2c6dfd96d563888440280b228c07a9fc56439dd3c72ddee0682afcd6f653734abc554c047bcc3f000c9197015e771059df123208100e4fecfe8a26d9d6d6cbb2c6e0ab3269140426d7936dc91647590290baf5f3242a6226d33e66579b180bbe4677ffe503b1ab6690f11e2a06a3e441a73e6710a3b8e80bd60434a6d2c4e0836caf029573cd9a678d1439d9cdcca847266e6a3dc1bd65f3d6c77a06559ec82cc4324d2d3b911fed43706d36bc30f290960440e818e2e20ca3bb3e71084b07a1a39ab036853670eb420811e8d2894d95857dc40124914ba60ef6be7df35c04ab2c09a04297e0bacf5a52dba2173c5748d727b4fe1fdbb1b6120956207aff73c33f9a80b7b05f1c6e064c9db89bc4cf36df25dab367d9cc7418bf7726db6e6fad373612d2fc8d40f931b4440801b1e87bebbc6f73c2366075c8ec52c11580f199fb2e3f4a0dacc97e6f087c7f27bdcc3ead4f92bc6cbfec22d357cae42e5b2144ded677a2a428149b5fcae1bac0299601c5519c9ae04657759c380c515270f839389dfb2ca2bb1eee0b712e7cec60da8b9ea1264976b805c8a191faf9b7c0b1c44af158f2ae7f24c024794de953b13622c0c2340f4667e881f756e3c8837d1def4b0167ea1d4f305a11e0522716060231d31de1d271ada6d7bb6c5a63a951d82e41b67749a2503272f09c97a0ea177cc08e5aa0b8e5fd3991c43131dceb62997cfaab0a0a69f45c0b490e2a2941124ea240372977d9f24c4b12dce20f603bef9170a250e408b8226e2f75d05ae7dbb279eb1009db822ab1140fd7f5a0c4b7b85c4f10d884590edc1b2faa74ee1b3fdfe2b50be6e19a6eac3a7dc333acb1a4a689784be9a5ca1ab672113193d65fd3f3f0e8540089e55a709b9132d0d909f7c8dac433a0e31822db04a1a614ec5259848ed6f710ffbb9a38005f149632f691a95ab8c709525dddd53a8be7fd290c66500096d890494814ebc1be2538790b725a25e3ca234bca6ab45cf07bd4699c00ad122e8e59b80fae415ed517d4f22408eae2d7688f4707414945ae4419b6cc06e9ce2df06845ca8c1a2750d6505a317ffc51299fd3430c6b5f1ed107b965224e632ac5f5368e0f7d7a4e283737215e634e89c4780c84e45d62db98c6947b46acbd3d1887faafd1b5e407c0658fe3668076c74a78360a93160d9d0aa28a4fad55d3021dc9a7d440bc167b1720046928281a630659bae1a6b4cec81bdcc8af31d4c3eafc2cd13c439385a81a826343542c34dbc8735cbab2e5a1d414dd4033e402b8ebee366284d9685812d0293ede98963832de4bbffe3426af7b297ace01c60d392ea43dc647bac0908e2ca0c075e4fd5041d77107083b09dba581cee82a23f93ffadab5507cb1f2c5af5681246053f5b416fb52e98e317c45597adad9d6f965750c33f2188b77a9800276b1a45faf02b2f960fe02e7aa6a07cdab46ebeed1b1fe93806c2124d77e1eee83bbd6cd14bccbc9112684ca99fd17280e9461600fe59a05f04768a55af3c394620c66560f52a14176a5a552f260478c62b69c65f5daa5cc541da5e606cbe3e76cbf0fa6129c3294a21ab3c69d36d3a9234716816b00bf5317f49bf9d07bc2c1c078335ff3fb506bcf28c78d32d3601466ac3831ee62a3bbe6aa031b752ab69ac7f0b4444a6fd76bbc9df786947115009ba815ec8da051fbd19c6055cff8adeb581c88f08eac29a50b40749a3a2371197e6643a3ab32c57f1eb9bbd1c3db4f75ba91b7101f2e95067f5d7095dc758ad5a54eb8137c373ca1229a28f24ac3d7a4d0f62eeeef5278b40cc6d95480d945e68855040b24f68b6f397fd73e2d70e8becbe68314da13decd7fa5a5c7f202da4372305145553a5d9923aa9d30e485cf2e888c229cba066ba016e2856a961f757d8ce8cfa7f0e050de71d69b1b1af0e4d0bd005f2110e1b18a80ea2cc45445eb370e99cdb567b3dc402e836b638520270996df70c8058aa5d985616b46adbb6765d375a86525ae59ca44b9de74ffed7826c5211780d03c43a416a5d95e7352fd54194b4c078a5fec271c0e0175096925274a03a31e3b2663a05cab1be969ab90cb32c3db00f152ce69dca00d0325ca677fbe19075211ab50c49fa9c4505c4d5fbf09233338ce42c2003f710455f99579b728f1c06317dae92f2f89df0efd12fddd94b14725ff901dc6fbc4a932f4c5657808d5f3742b547f056258f0b28712d83a14bed8ddbc9c3d410451ab16dbad6d3ad7c03701e579af41f071834b49e903a3c33b045ace20bbca4aa8d0944cf0ce936a6bdb23c0f72f13fd363e75f8787bc73b76dc49bdad3fdfa40cebf564525b21824e049c83797a458cc7591f972ad61d704ed08289df90b9757aeb785916e7a7ea5f4ab4904d3ee4fa675e55db79903a349bfcb0447fb121ec6c24cd2d8456689d3698b9e7e16dda9ecbda3697b4e30fcdbefad471bef41b74cf4073cadb17f48d263ce8fb4a455f78466eed72ccd11c4ca37390c321b649c80ab6d5f00e7f3dd47fbeba7455695594a179f69873c37ee12057053188b9076170021d89316d6e3cc528e6e8e2bfc976a7a61cf380929588d2db6a1201e7564486c030f590885d3e2d29a73e63e77739208217ec6c195ee5a1c4313f5aea5040800dbb7155055a2eeab6e6590dc45ea93a4090e035a2cfe54d6e8811269069d3d8d58ca85a9f19908905449337277533a17f34b33d21a421bb0150004c72c3393b852a5210233c866289fb4643cdbefd50307e51048ac10679e950f6f1698471590c5e08460f7935cc47fb1bf6ba26f278377dc79251f461ef6140da9f463bc103d52796c9b9d706309e53d84367caf636023b8c6fbb6ed40f2f6a89dbbe91a14a1eb3ae4b486e7fabed61670088606cfbd3dcb79429fb5dc8499db5c16d923ad73678c169b3cc577f4d0eae23e09c527cf8ba52f4850dc8b546a26b7f256e68f665f7a0cb1de33ef2cb333772a12f766bc324415e3b72538465cfed902db649ade3217ba03e45c46344be0859bf4eee3bca94c87919923943fd8a39911ee9c11ea8618e04ee3bcd20c197894222a8a06ae30ed5bc39da42a05275449f0d8bbf3fb149fb79babb356660ff8ac9ae782d9496dfaa6c52f8bdd799293c88a09ddccd92d9765fa0a1ac9af2714115317ff585a35fcc9ebd96f58313223f3a60d52f49443fb4436d583f263ce4d762d2586a4f3d020acc61cc8a5077b40bba6142c9532608477bdf55140c529f888120ee4427f81626b714e70ca79b6542aa63f6082bc5ced2f131796bb42fa346d28dca54859261ec07cc98687819f9e86445a9ad133146bf7cc803be81cd9e56b993f2ffda2bf811e85969b29905ce72c63a3bc8db8d99ad07870cd79b5eb1cc7043da0a75aad7df402d29b067dcdd196553e439f8e58bc9138ccc9d8ce1d7690307375e7175f84067505cabf1e867c246dff5e374ffd20f5dfc5474087fb9b0b32f71f2b55bd8e921cc720e0d2375708df034309ef9311b420cba6e015a42f2e76bf8c105c429927ee302dc73166434e50118ece46c5df4f488e1d12f695a2dd261b96e4ba4af655ad6348326897022c0f78774b2b08f05cb89e7d2e58a7b94ca150fe18c6b84b0f51c5485360aeb36c8d22328636b7e3e1dc7b4b62e3795d8357e66ec22d2e3aa2546c5a9f85ed47866ecd832b3dda02d910a220d1de9e7f5c8fcc2fd598368b257ff13a4fa88180905fecccc8e72a972cc3c58c8810e9a3706cb5e642882120d0b66c6b52078207d8d29b12f4f9d05024c084aa704dac9d009dd13a422f520afda79df3775fef5e0470647f25e98800b10574e2ff9874f73c089abd2e8108249e37a7f52f3447d45f638527ac8a5f74711966299d1fe1ff3ee57e9e67cfe8053eb87431d3d9dff33de3008c844fbfa738c0b37537ff39ffcc9909320a8ba131cc11bfa45d2d00cda3d1e8c948498f3b9cb8605ff8b57b8e9e5f5fe2718d5b02c66058d07f811272af64af48cf12937db190e7bfeb3cb7de0f8e9ef64bcc3f3e73429e72a5f401b778137c725c2de4b935f85a18cba2ed1980a2b3b9f462e7f1b8d0c926d06c73338d7d86ae6f9fb8d562eb81bf998e7e8205b23d676cc74b7454d5763a111c9aad66f252db5d55905f99c97c05dc934a30d078ebba280a6a9e821f6e5cf6f8cbee2a4044e672d44bb0d129b3f0a9f2330db0bdc0003103a1241d416c4a13fbec1ff8ac2dc8a16e45387f7db63d7f3f1f7bba0bfe913f445d55b202bfd5859a869a566f71bdd3bc3a549aa837edc968fdd6ad7e6947dc77fe7fb9faa7b1b0126b00be862311917ab1b6628908ba25893486c597408c7f125ef46261ea8bd1a7f34f1d50d1b1152532cdc5c78d6fe43a033b3b4f399290d5ff3b916e51a33c20dfb94bff0243da70d6d140964d84d9e82901c855255a5ae24c11e7c2965cf7c63d99536677384c79a26664f3889ef973d16475e8fbc8f9149c34874f99d778f217bcad1d59272a3a0179dbfe140234584c25c7b20e33c2037a0ce1d3d75282f40a45aa8adac3fe9a2ea8e907214bfe109448a4ada174d9f290907addf6cc62f5f6d867a2de6ce187fd00687a1213695f4be2ca93eadb12db97be04bf3cac5c015f63e38e075b3a067ec4af96f41200859c1e239175f89dd3b620c01eab0a9470f97d7fd5fe17b4604bcbc258e044a8487b33154e4c5de314d831fb2dc8cc9e1decefdc10ebb3b54f1463b224896951065a4ec041de5922dc59413a6348b319793a460ea80fb4436085e57d746389b96044e798767588adf1350c766de19fc261b4870b03692d1014a0b89b5049f5845170adcd3957cebb756c48062fd22de81ff53c145f47e4111c57faf5c23374b39c11c183675b19c9a976bf2596ecd7f03913794acd5dbab00b073befe258d944c0b8c6796b93f2316d6f1da3b659b4daae7fe2bd8a290ead256965481e03f7f4ae02adb860116e336f0b6897849efcf30f00f1db8c92ad5b549eccbe1effdec3f8865604e4765ceb98ddc14472ac38e0fb50933d10fcd336fd4b12daef9a3c6ac8ddb71cfecbea3a7ffa6fbc05c6545d70daf2b7eaa9e602e98200fcdf1b48377f504b8ac25ca15f1b1e5f3457319122e4deddbe18e7230b8eec9cf2b1bfc668fc27a5f5848913bfedbd23ce71b3d4a290544b8c2dbf82003e3ca82b304d91130c1bf89d5c8a1297cec65d8d88170cdb792f3db428cd56b47000f38f980017c3e2639869a86d08d2a19c10a2b02d7e38062263cc607bff19d53729daf8aa7a9ce9a36940f41e6e219d7df061a75f675b86abf6c7057ed4cef6a87e849c5809929486867f0123c6fa406ac6e1ae96b72643d8f964b0f077ac2649afa1bf74003067448b166ddf3340a10621934ff758548236d07ac280c2055260f3afa47398e6e63b70132f598a7fb491a162ad16512e32c63583397d096959b72b4a514d38562d9d3f80c179607983aa651480bf6c7a40bb363302b8f8ecdc28a9d0779cee935e3aa09959e7e8fdac34995c2c295cc035646cd74533daaa07374ccb91154c72fe491f1945f64c51838b858765735787ed262a133a3354617e1290e34100e1be9c8c75601fa0cf8f835fd0f737f0671d2221048ae65d4a1d146ec4e28ea6630c49bece200b27ab8865a9d284ac3facc9e5e5b1a241abef828752cd96df0cbc2a58cfd70f24fe490c386b39dca3a7cb72242a38924eac2f0f180df1db0f9269f041c4496a0b8d57cf93729a98b32f35e26326185fcb865faa5c382755df6f5eba57b4df399ac8984e8641d736fb1bf2d996c21f6ec93be940acf20b0130f2f38c659b2b310bab628089f241e431539a6607018a1001ff494921408e542851a81696410d1e9e4b47b9231de04afeaa0fc4c19b12a0f308814531975fe700e7b7f380b6806e8387977ef6336f8d6a87d422df3930008c3ca640a76805162cac836355bd1d5e1aa4f4adf8abf3f00d1aac8f0456c8e77968b1e34a965ed5d2adec097587c316b1809b1572f3d90cffa790e3a17a4dcb5df70a2477e6fec5847774316f0bd49dbda88e63f8693d5aa16f594df1d02a4624a8b8dffd04beb8c0ce5571ffa7668909036f3ffdae053186067accdbba456d00dbf0d081baf202e9f6ffd46f54b20fdd18df1aa0d57507f7a6c57e1d458cf2f580ee32b4536baf3d2e80b30f51d3144a06fc6cece6f3e42e12990fb786597840f36bc376042fe4064ce67983d351e0a477ecef8c58cd09120d8e6282c09621810088392053524e761186f54a5378b36c2b1e0cc21114eecb0eb7ec1fcbc9a26ef95062119e6656ab8848d1db5a8428f7e71e02f5f24e586efbb73a7e1865b3d0b6312ac8c1f09d8d38bb65724e8b39a2e14426a3787532a0b46ed8bc8c69bc5856f5ba20bc7a8f789611afc723cfc45358204394da4be0ae8140f236ffc95976d407c20b4166edd52dc19c9de6881cf872c98dc44d62cfb90e35c4a527092163b411620434af29af23fa75320e9e68bd7a4c3922f3744ff91f64c662c3282089ea9e2aeefeafc576b4416f09918d5efff23965fbca28b8ec6b72a1e7427021f3d8781f5ebff18bde814277b6ecb2786f6de2f1e3abb4570b9f0780343e3286f3e58fed75a16817829ff12021d8563dcebdd5817a3b430129015c3a94232d882b5ce794502d321acf2140f8a05873bb02a1e59d6ae98adbddd980639114855c6b9d59c5dfd09ee8a9ffaa028033801f9bfd5335aa0cecbb347a767989ff1d02a6953608e26767a2db608b3ab346cb191c11d845509aaecada877ae65ea1df68863c4d4fa651024f53469f4a74daf0494f240e1d58d5acb5633a7bee42ef358e1429748123323d1b6e0f358d59985cf7b386d23f7195ffcdb478c72798ef7909a3b8422d2de9a54c1aae87a2ad00a4a8b9e1a7c6c630d6de93c4f1c5b23bd8ab6cd3c15e1c142c34bd0eaaa9753a15c24c3d83648aeb3b289654ca547da431f1506376759ccaa1f23fc7d7a1168a5b64e8c329affb9243f57b84653a98fcd01b495828bdd92295996fbcba4eb055b5080af85d25962ec0d1e2c585a525edb7c2e1177dcc4621efa7ba7b1d82ac5b0bba5a74eec39950e2b3486daa7c9a9e4d1cdc16da4ea315776ebe0504e3507073895489f9cfc5e3ebf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
