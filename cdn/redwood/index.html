<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a809288fbb3cf5db7aaf886de089487cab2f593dd8c03d61b3d4c7e434309c09d3db4f98224d8eb2b1df0e73529dfb244ccc1df40890247bf94ca94b4040a5b68cf955b467a326820cf867ede8166a418f22ec53e4552f6523663985951f483db6bb9ccc45e648b771c398f9368e46b2775998a3fc88a00729e9b8c7aaefde789e8401aa26deaa3dd2376a7acc22a00d89109f055039cf2f6f2129d151be56ae5463ef300bac606486b5f859e7aee2b1ec5df527b4aedd2fe8cb14e88cea1c6c89d33b4523b73cf2653b2816c526698bf6390be9b27d13399ce9627a679332eda190b95c0a89f2c7d9ff0b361bd5fa2da0b559c639ea708d0867a20904cdf8a04461c765b2e880df853d35fd157da9d30dbe5fdaf5b867e1a00bd5f15e3317bff8543bdaafbcc70800b4314949bcd0b6cf7bdadedcfa5912ceaa3fbf7265148e8624c3a9afd6c1eee714349075e283c3b149784075109dbd38953a9f00379acf6e6128851620454c2fe236fe3a7f7ba77e06746ae31b50cf4a23d2103697fda05425c0aed25037b738a346085256dbea339f25b375bca26a1ba735a3527d5fdf0659c4183be05f505d0ceec9a34806b89f037881ddd6cdbc95189a3b392f2f9168361287eb16cfb5586412e2239b09d5ac2615ccb8e6d0eaf530a7e6a7f2e5ef6b5d0a1129219681f4f2ad75fbe61b0bc5061d4d2b18bf9e748ba2169690fef88d289e73b70e657381b6eef58676a2c84194407e520d32124088bd0267226723274285c77ae38e7df91a180e2947a12fa2b4fc109105ae1b7c8d4a3d923a107b2282ff528ebefb389f6f710f5def06793c1860057ee42e546c644b087bd04fbbb03ad65aaaf75523e7fcbff725696a82fac1b861aabdb91502460ee58c90ee105dd42d658d2dc718d6b52e784dcbb863c95d49690edf5d33f16d6d76484ca35e0ab8522462caff2dc143c46f0e4d03af6dec3af60bbf52323148a93b6f9a5d1b81d3899a7f34b54227e41736304c1f45b753e9cf45bd17a0147e83d101bd08edfaecfebbb1d8516ca389790b55980f41a909c171156c4c2c4462613d86c7f6379ea377772c84761d6c6a5dbce826bc4032f527e9e1b169c9e7aa2c9cc4aad99c1fc5eba1fab7691956348ac9c1f4e340ad5172f83f3e9a406bbc2bdeec2696c7815a254b774f0d3b452359777abb8e6cf0e97df6d5347ffae5f267394585cb55d60482b1ce4f8c8071fa34aba555dc8bacc55bb212e7c2521fbbbdbd1a07fee49dbc5d705d2f8b6e8f5c8c2d8accd8932dfe6b7b6f483104c3a8f222ec616b30512c8d250d8e5ec138ea2628f2420a1249c55edc49571138f6e7131b3efdfebfbb5400afbd5e829f6940d43dc865a69921aa7fd68b4301779f9c20d5a8dfddfcfee62831d6c34628efcf618ac4f3e74bd1785ab201f7aaa14af0ed2b0de7c43f7b48b2e621de7077e32777ce4a84de5b12c5612f49bad435733aa483fe36c92178cb682a28214dfac2edc9ca97fbea0e747760aa0625858034ea4772dab0f43547e16fcbd5d970d0caa93c4fd496a3458c4aa2d5cf848429f519008abc44f2170f1822fe7f2922614dabad02236351d08d23da2beb2821147b7c1a99787672484b6db104eca68d6aa9740159bab336c7158d35ec5b045232c095baa1910ce4eef1a71ddd75e4a632bbb0150d425f2637b9b80b7b156d105fbe144ef19374cc9eb27357f7b58ea7fc927ffe4eccb3a1a07c0fc6b4e6fa05f31782182219a86afb82f5a9f86f369ecefaf6af0df5ef8f9c61a5398d933013841a8834b4d1b2b2f1b0e78471ef937955aa55e2ce993b0b53793200e05bf5ae600b3481aab6c713d651ed62d20e704814f9c5dbb679b3ef6b6d7cdf960ffad11d327e93b12f4128f440198986db95643346993244657548294aedbfe797e0da04d4227ccc6c4a0a73a0a4755c5c48561e775ce58dafe560c679291bf973efa415f10dfe9a313529f37c159b20e2a898b8644dc6cf65496da231c2a1a0878539c164207afe5d2ac703bd2d8dac95876fc1f8b5b283a4983d92ff7501c5229eb0a0b15dea736e31e0876d977bff865a011c991933788d3bad133edb2e9f23d025326cef9b59ac928e028dc271e01a2d934964501bd2f90e4b0873930b6a0423db95af544274644deda9d55ff05f135a84d9ed6623447a4a0f9e07b0b25bcfd4e0a54694877f13c113e493168fa7f16314824e6641fd6ac608b88f8cbb14556a83d07e8f5ffe0fb7964608bb35b29946c772823781207787bee8929ba1d6097e1b870da58f1a4fa82d3732327a8db0099c3c4ac6be04973d9c8aa40ebb3f40bccc73c1afaa4f4053fc53ed1031d52e98233719fc7e16d3c69333f2a2f5400917e6c4dec7d90898cef179b9806e0602118163da5a37fbd2553a25c408137205befcd8cf8941908f0c3b5a72baffc696ae8571d4b02ae1f58cc5638e577ef3684adbb3e92994a62932d58793fb9231c80b9f3bd82d654a9098f07117891fc14a02d0dedcaf68964a4f15d965c19a754be0bd5ba544467da91ada09e254c258ca80839234b6609dc5b3177bf7f6d86789322d5650e190ff02721c2057766b6bf452263bb001d1c6d90beaf0b3aff1a6fc6cf4452cc23c3d1a10577fea174537388790e07684002721b8da934956e771948f81b87c2888563863620d321a15897cb27bfd3cb57f6dab9eefc5fbdac8dc87bb0edd272d6f18315e81ea72c59847f333205a66c5fe075062b1d02909ae49b6f781881328605b0c8ca85ea58b6d87871a4fea7cd1dd30a52192f7be77312c1572cba64c993b6e58c13918392d636a4e34b9adea2938a1d586fbdcf3dc639c166d896268c64f891f0197faa412bf0ce4c14aba047aa6e39b398a5e2184928373ad12cff6e4380eb97c39435082ed4a34118368c4d74db83bbadba08c07707076db34632e795749fb9ab93e340cdccba209413ffb4dd5af8de86c36051218743441423ef4ff098471893f3641ecd583fa02f3253d3dfccd7e1857c9fa46fcf400c7fcc183ca4841b3d3c40b42d39f360c00b0a272a6681022ee1f9ee1e64cd21d47ced3a6d08da52eb892534521c8239902853bc6d76e29da6d4413e10e552075289f617ce184b3a27e6d57a6facffbcef0b794e4a05d76287a875a4db6712d8fa2febce5dbda8a2d49436b2e4c8816942950694389c44853fdfa55fb59150cebb0aa4918c7bf8e0f4fbe71eb11f69e5f3dbf4f4d2fffe6445841e8a217b5145e322879d98722a535b76a9925cc0be45621aa0bd8e9246dbc8c947c80bbdb130da1889a41c36da6994de49b96ef68dd9d7bd3a252689372a28c03a0404e79ee5d0f0f87afc5f8bb2bf0f27345f220b6ee576ce2d6b17182bee1c712d2e5edcd8ecd27d0898d0eb2df697d81187c7e8fbd141b703977887f78a92b51c773d09e267d55e586c0ef2e6e98fd6f0906c28459ee30700064c78261b2219827feb67561d94bdf00bb7f4a7adb707cebb9086a7ae9ec84342439de961be855008d0c13dc444a1089234d349022fc3be06c2eb2cb67273a0c27ef519b09aea18f119aa5a5e6b7eb89982336a744682f3dac4a46f8a3f53da5dc97c1ae3154e5d0227b104e3922f95e2bffb7669171b1d2c824795d089eb25ef0945ca3a1b35653decd372585649aa5697a56bc147774ff4970ea8395932a10dd56e89c41c812bd3f2424b066043c52cb47da963235b509caf370dc7d758e5316dce5b0a5b2230d57739bba04534ebad2b3d5d331c6a211650cc8a179017023eac767384be89303a8f232c7f912e2b5ec9104d5d8251f88e476abdbbcf1f9cf2f1a7b98468b17a295657d6c4dbc02192feed2f258e36f19325fea9543dc6d8a4c684ef4fe1c48b6df35e0ca6f489f0a8a89e779ddcf0d63dbbef8af86cbd3173774e6b129e3b04c3db73a4b9321374b48d655eceae9e72dc0c6fb85c6938f8020840d4b88871f0f9ebe841f7639a65a30df2210830e6e4c968292fd27bedb5c554e13e7c47ee5a277b16d0ddd05fc007dca4cbd00aa1a798f67bc2d80dff4c8ff891267159f9584d1f3758fcb6c0f0e4e14590eb06c56fad90e3640c4426c851161208b221c5494497843b631ce91c6746c9fb326682dd186afe4fabbbfff86be665d86bc8684e903904d23ae7cd49dc244de4435687d13aec2c9ea2f082fba88abad923e9dfbd056aaaacea146fb99a3bafe716c8d2895c2a71c3bc052ac1ce18ea09f558338d6a5c58af3db70c6c7cc668d702efba12a0a1b60637e0889f74bf2b3f530ec8f91e714b2de36256099e15af27f6300e8aff2a39af8d2817c1ba27f73b142d994e7cb8e90fb8b5ea001fe7545a407df316a1f90fa233f250bbd229cd93ba904630dd6cb6ad9d6ebc57eea6b4944e0ba33c3cecca22d2924168b734e4cef4b9f94489cac54664fdc93af56c8f6c29a57c93cc5d6ac86745b3511828d5766e9bbd1162348166e582110876344189160b4bc2231e47eadebe0c5ad863d6a13151fab83d011888360f8185b3816bdc2e65068a97d091d2b255db3ca66e8a84fe6538299d2c5d16d56836358952c1145fa277fe896a67e3bec93f0d5e3e3365d4878cff76583738de02d28661f06119d1b0d741f38cd842513e842b18c617cedb59e6bc217b09a9e60e8e7ce28a5421ff2c005e8cd54955d4b641ab50d0d193ddfc45bc91d7e4ea2574dd08659a5e8c1c82739bcf822202bc8ebfe417f242e5a0242aae02a30657fa98df8b9322ed813a8426bb68215edf6b5d4c0dd228b825b630e64cc95124f5e5ed3ee2aab973b031bc7054c9fad0647446fac34a7b7877331d001975fe98d83861767eaf0545cd175278c804230aae39b3d4d7ac70751509d4a99e748b2b960eff4024ba410455f2f1ca599893386b4c85195d0d0383dd6e66fae7dffb5c920c4eff75a4e2b74aeaf670e42211a6f1f41b950b02aa646959128a44a2e39fe06154ba7f9bfa9f3387775f29666524c38566eafc280cf627a4b8a794567cd30440dd9095257cfa98b626d72bcbafb017a61119c4078c57fe1cb1ae772201cab238a6a24468f8426abb52aa9dd13ebaaeed439d629c3b8bbfd35ead371eadfd5f35c652535b2676520ac74a2b1abe39727d9584b405ef59ff41d17d7c660d07ff314b5682732c4dca9ecfbb3776836e7d6ce9b709e43e8e0b79af005ff4b4613bb7bd215fcc686b9360e2c561e06efb75ba8252fc784fdc108de983146f0138c7e59b6b87570c09e6a59791b9c4739093b2e9a21c238d00ac669913152ca388767f93f3ea1983ecdf5fd52b9256cf057ed705fd16fadb7ae400d1dc60086f2a3e00d4c597c74390e03ed5d6105f9b59a9005362eeb9f12d65940120b149497eb8f3927b01327fdbc974a5760ed8d80868af887affea07bfce2e83599a63001945460998f16a0640fb99369a3544bd12fb9a3e918f9ecaba7ac6b7ad0d0e572ac90ee63757d6e9c76cf548a5f08642d5234cfcb1aa958dfa8b19ab18ba2142501c582e5d2bbbf2ed31f21c8c91f3cb3c598eb857159bed4e76018690a61ea6f6b9b046fda28f76ef13b81045cc4ee21301e0af43ce506f3a0d7f4744e3e1f3f1df5cee0e5874da8a73295810e204ab36c42c5e731a6d009a27703b8daf91a11d4566b99acd44839947113217d20a23b33cc67f0c7ac22e7976e9c085df3ab50d97b3e9ec203ce76690c7cf333a2a385f4d61e3d1f7284bce13fd81db8df51470fe6696295b749b73a361fa8dc3868acbd709a7808745445b90f3f0904ccd07a912a98533f3b9662361653b27026adbe314df269cf16e58f802523c5fd1d8c650be2f599a45e91b7f5663fa5e73b9ea7a7c11c59f3e1d8c71b1dd68b5c0741eb1619660bd845ffb32163c6e46731565a86c85abc16fc60feaaa33ff1ba7c156558db8776d877a4bfc3e1aa736cdb9ecc30764206c786a99f4dc8e072f624ac1172e63045df584405d04b9132b006ad451e65dcd18ad2b5262b83a7858ff535ae54fe15823ee113d5f43bf0f6a745588a42d7c38a377b0d33fce0f386b01da88c9ef561725a775e1476cd7225edcbb9ab711c95d46f0c27c29d4617b94c4b0c9f54cddc506186733620a3228643c966d8bb665832ba0958d97a63e901d5ad8320303e2a56d097398d66fdac7fbfa9dc4175d97eaf5eedde69a5201780e52d030a5acb5c38eb81f9b0608a5f87d880ee6ca02cf48a7ae1399182462263041f89b72f96e984d75ee3b6d5a5b92574794340f53748698e566f64327851ad21c692d086c46e6709d2cd31fef152441245fbae6b695d2f7b436180e6299727b26355fa61978d4c4aa93e46eebbdcabaf779ba104707e3e7a8dfa6b9062346ae77ef785f2cb74361601facd664a837c9e1f860828430efb63708c708e602d07610cafba72db575adadf82cc44bb2c3fb8ff4ad40c3479a66e4838bc0b13b24d6daf6885d7e5e9ea17adc2a00c647b91843de6c8b99aa05c5cb47db8f2e06d3b3c9322b03bf6ae762391ce23be1f8f91682a9ee258e44bc655b473f73ed3f952cacdef177e2596796b24e5d54b1bb4e07c2b92334ed491f7c20d7430a080f4d62678eac8a37ed638f4b30309b5228d08a78d4c5b06c8cfc466247d7274e0241b7801903bd5e9c3ca9b98a9d49ba72ee83c52754c260a05b9483f6501ce27652c988d785a6868f44ec0f8bcc6afb41e5cd5f5b8e4600de9f20eff4fd3f594b7baf0814fd0980e1a755f8c7a78d04ccd8bf1d263158c2163de61a15660e8d3c8c7b3aafd58e9f550d9e1896410384ce80d5bdd129f557287313b1336c5306b83f49563d27185b51fb9f08211baae0a78b51ab64c4ae3385d82e52b6ccc89a437dda11b3c0daf5d75870b76e74a349602906b31df561af4cbaadd4dbf0d36025c10b2a49e23e739cb20b324539d3ec5542db27ad75328cc09a23621fd93aed5ae5a50804930b33ea898ce722c610c4c09ef0117061b2007a52af724b63f0bc4342e4a3141a576603e18511fd9ff55515951fd3de8aae05001d6d1fcac6a40a7bb16fccb998d6b086adafdb52744d2b6f89402be1e6651e79e9bfc3b2c994b06d3ffb96f978effab2e6ccd74e913b3a42ece0c9de6f1abac2c08299ea237c1be5bcb2e45c45b17b2f4709196b851374360ea1babe15b755744125edaf50b2ebf7074c13d8f8a1c6fc3b754d4fd117af0137bd9e0f8da7fb6dfe27a1dd7b056874386aa4eae16071a5c0640f64fe54aefb579079181865e74f52ed78226be0649b9daefd2e0e908c297d3213fce115f21e86c3af7686b91fe6ea424ab42c94f2104fc5df2abe2cb44927abac931eacdc7c235590223ec11baf80e2c97c7ad4756562a17a61c97d6bc91335fbcb95772a17160b9720a1cc7cda49990ba391c1eec58658a3b7d5cce737524a07ce3a954894919c722d9c4ea51e4779849b7e144e1ad30e480c70d98187dbe7b5f36037d11073f4e4bfcc9d67978f0f6cab32635d55fd01728d0e2ea9b04311bdabe9ebee8ea61aae39c95c4b38f1667234db06501325be22605ae3595e356291716c8f8b9be09a9c1a5035563ac3bb845750c44a68a74a083058e974e9a544eed6ea608efdc1bbc4ca1a57c5d93aa968485e283405c366b097e2690b9de8f48f77242901ed0f22edeaa51922731161e6f199744ad3c6c8a113c2b697a6552296bffefbcfd3d990c721afbabacd319001bbf4915a7eea45ecf5739b41bec72f2252b65bab69d482b1dde4bff0e5a766fd42a9ae6121bb46c4c284981d8778bbff6b4b26dfcd9a7b323d4c9ac1dd7734bfcaabf604329c19e3307e81749c6a8fe9480a66d1acd2f5ce65e8ad12dd3f0d1fad4ba8d5be428a0f1bdaf3112dd3d2798199e2946dcd1e81a3f2b2b0dc7c3a790cbd0b5cd4385a4b0e0b91d7f0b3adff73990bf705bfd607a6e8dfbfb4a51e6b0b018b725330ee62a634baaee013df250b0c9e8e5cef35d948941728c08ddcaa345c3ec30126f4fdd18b6ff5114b9e26062ff54676055ce90246c0ce50d689f8db3c5d33297b5b93d7783b41dfb8c4418d800a248ceb27ee939e9da66d9d8093190cdea85172e8d1116222e10298276f4077667439dd00a062f7b458f793f15e03f4a723eb22dc27062b6a20d376314cf45cfa55af937ba3d936ac171910f24b452e5d7b539e8e4dcf187589e9379e8bc8a0194b1ddd0cfadabdc91da4432f16051012697ee19fe9f1a991683f014aab0bd7bb92a8674d75ee51b7987936bae79f821965b0439f9eed97f95959c27d88a5e7f210aa1d2bca33d94addea39db2ad5dbcc1b2a930cf40abc4fd99dd13e87afeb6f5a581050bc8e54c7fd8f9276a21a4b393c462da5a45ad4f7d988c889e521b42a36a8abeec69aafed7c83704c7b566e0f72cfbb70e31dd234af1f05ea93d95ce3bc1544708c7e8e00a7b957e118b156729523013acef1ea799ae31c422b0f2a6a58dd731747274f35d701344347a733b69f23dc4826c079a85b510cb90fda7ef563fd5c520b802dde5c3c6ceab37c1417f49fdbd16249632e455db3cb79c730cf980c84dcb4ffb81a0bf6829296ce0093d33a9ac85106973da96e4fe1139bcebe9fab807d83440a81da2ebbff1501740f40a696f14ce5b1657aa95e883ab77d7b4b2dbc048b51624421a705b481e57dffc3e2114bf90a9d04954c7949d63bd124958baeaff3663dee06826bb921e09022bdadef73160d82931784bac801de2a4b013035054dc9e250868de2512aec9292e4709afe232a687e335b3ec1f30b0ba900b4bbc640770caee4e6aeba075dad46abaaec0441d9a046bee5a5bf6043d5019a2dcc1fc342ed0d379413737db5cca05d996d2406c5353605f331fa4c9e0ca02c9c92363cf42a1fdb86b5528bbbdb01c89044d42c7c5293f4139320365bf48c8ceee6e01b25cedb4605edf0ce72de392499e919735bc7875bc56ae78038e6426b72adb16e68334a8765f2bb1938fef9db96b1890e4fbc21f8ebd1ba949298053c481256098d5b4464f64c1cbc0b77f8f0f43102c30cace3326e7cf3c85d32dcc290cbd34218070a24392a46d054e5f8de2442a115df6f558a455dda488377d78ae1b19fff725429a5175b8747dd94509847d3d9d9de912c8cf103e7421647b226f4b956a48346c1bf8a69cc7450d4af5ea279506d0c0cf591b6e1a9e4f16b1087f29b8a012182fb7e89ab91eafb5ebec6cc8087b96f93e2e58be767eab3e68496cb76b1a4715bca17767825327cb45437be5161e7291ac6aa7d3bdb3bff536ef2985ef4af90676b5f5d34fd2ffe3849112b069c475a0d4e9d5de515c245db0a9cbef8a87c8cbd2d7426cf02da11d23bf93a055d5443934e69d2899f9536d87b94930c1ce71556a6a3dea9666d8ffdd756ac2cb210b0435829b8d4c324746188af4b2dc6da9936d0305ddef6ada5c9930652caa5da1e74c99d3a616174537bd0118e88da3cf7f105ac5f776850a4b4f0f14098d38ae808f15fc1a5148528d27a9a87da0235ef84d1c84833cabc5576d5de5ec2378e38e9b6d4f0f038f14fdb7419fbe047c24f2b3d2a4fa00402be91821e0bfb17c31738a62366096230feb4b8c6712931dcda9053774da6096a511c51552faaacd9e885bc24b263e4d8fb2599defde29831d33fa20450039345ce19eb20f326cc6eb6db7993c47b8efd7b845c92c04f73151aa16939cf2c19f807f4205c22959223c21b57e1a1c0146b07b747c08e182cf0f70a03b53fc1e7631d1e828bd847707ed9febeb259cde5398bd32a75aa4270a88e7324721e63388e6d87a153de0502904566e8eeca27414c1b247e9e434e36d94e392bbcf56d375f4357d06fe4575490ae749398d49bf1b923f9f64f137bdde97add959ce962d4aea3c4dfa84ce08b76f66bf7fa42e2c974d659b011b5278ed1de2de3d845025cc6b6e8e7b1b59d32ff7accd7ec62d4eaebc1d0717a7fa684e19be6e71da8c50af7188314ec1809aa4c1c612975dd22cf86af42ae6bf4e2d8a0574040232356041f34271065dcfcb5d93da68e6ddf1641845ad18ffc6dbbf4dbab2cb133bea2892a024245d0249e8757f0e23d1f510559d3b721672288d2cf9b90d6d94db836d60275c110118e1fdc85eca4ccb8d8c5b56a6a23c7b5e380268c89b6145b47e45a6db79c60112196ae7afed40d805c287f3c56d288f9d7d3db19b7aadb9c4a6ff550ad491b37a88ff0ddbdfdc61e593ad3f34d292b9b4ac984b8ea80355ce9eb95a85dc9b9bc6d866a1d7bea3762d822fd258f92fea3aa32325a379d93ab5ff048b73a83b43166966b6f44186983476a61b6ca1a2e5549d87413d221825bcaa0c1ee94c1fe2eb013bd9ee34cebd734cf4b685423d5e6a3bafd41ea56b7fc47ba4a2a81ee890f0e96905593253b6fe200668ca81bd2ca09c051d45387da9e7e2079cb9b2130417042a2be80ecf5bd677252b40de54b9e81f18d69382fc1bc17df87a44e732f3b1ebe02ec8480d7119b39075b054dc21dce86a5f2f3081422ce2c2ac619cfbb9cad26c05e766c5b9403a3b9b0e59ceb2f14251cf3106aade626a10e98f9c530df3d7b7c852598a9aef33a93641dc478c815f87192e9db6a667033ff6cf9dab10d29a1ff681a043e1de1a482e496b8a03356d4b5f4afbe09d9adfae8a08112b1241884934dbec625c3b53ee6ef4bdd37acc76fafa9512c8d5c53eb921e8d00dda7b71339152b0a5c308165fd94dca15cf498ebbbf7f54f9339c9f521cc8f433d98d4925c0e07a5dfbb221baf572f3819bdf07160204639d45574dfd9d15ca371bd1352e1e8e48b79b46ea832fbbbb9a23ab4caf6661763bb4b3f65c18f4666496ea304503801b02cd948c7f987e726803c0ab54515b65d2006d42622f1351309a24e0fdc28921c9da4f771fa8fbe5c155493cf2ac99c80c001a046557e74b65b2dce6557497adb284b963b2ab6f2cd65fa3220c38dd8bf9d4a7e5d8fe0a858612c579c4048034f33df8c9c6f261d7436a761f47cb1300eb84395d619c95a75db479ea1f750fee5510087733790e9d3f588e4e769ce6580f4bf6e040de6a457e70dd0da77cced08e43a0de258013dd5ff5bfe421fc6d36c1eccd132349a12c73299118b90febb4a15872ae1ed5e250c7b36cd4c20786785c02812435144a6834360318aa9622e2f57200957a31cb711e7617cbfdf3ea25c07054aa213ccb2b86e60155f76a235c3d7a0ebfb2c67ba38c58638fc029356fac507f740313a0622392f23fbf7d1579212e2ff972f5e34968294c824b3ac5a988f6ccdc76183ef2ca102cdfc6fc8aad1c93aa0934824d45067a20b98e6823683c9c56174e7a6a0eab552090278b4ed1e7b5d20b4e93c52e9912311216b01a9c135da593f62dae5a2396c3838fdbdfd1c9417042294005583748431c5f6ee1f06f372046c1293b7bc0c2d997204f10baf69e6d516a35c8bb0a9343bc85458107a01c8001d82bdf4c451d5ed5c3229da8f21c97336ec35fadaa08777f51d2bc6a04a673fef4f5afae014c210ed4c5bbb35772f35035b35e2882f5bf7f068b57c49e8ed9c234cd8590420dada3e385a69308a359aa9dde3e4ce4e1997791412c0ef6016a37a6b6840d6d921b80c6d841dd942f40bf5942f0aefd1e447664deb29d3e1c68977c540cef8b3e68c8254817beebc42f85aed5156f2abc11f9af3e8be24e724f50397f6311a2d0bce513ab2e6aa9fd70ef49b960ecc3498ed46648a888d2549faf91d42c0e14d265b09d8669c43193852c39feb6593fef7f53bcbe2b82149eee263c8713c599a06a89ca1c98a4a72860c9e7dd587497f7dfe9c0bab88fe82fcb3d4262717c95ef70b4d526b16b3a78402b01b8f5e9f507ab402bcce8b16303825ac865d50d68391e71704721cf1a1d3d9f9a0e356b92c208319a4b7153c8383c1a39ec91cbaafc619eb154a23b596e087bacffb4b1417e00bc1c00fe8a75cc3d1ab9e9c8a286bba0f3e86c8c10a97243881401c898c2c68389aa707e692cf54210a880c4d066bf6e55f48c341adaf1f8880d135052c08195b44cc8cbd77555459bed9dd3f4d1fd7d9fc8b0ee8c42dbafd56dfe321b42afff4458624a0b03f0eba2ea1f5512e3eeffd9176b4891e28366e208deb9dd0a1166c5948e4812c67f86827fbe51cf78bc819e02d3c27ee5ed1367b9d184b89b93b38f0f5bd6780e2f0602468bcc7ff1d22e1da998e8ab97101612c9417f6d37127f4f2c01821f31cd9b4aea9cf949c56954ccf117b0f1412aa3748a667a6d3be96552672d91b04bbeccfab094b9d7f94f981213242efe4fa869eca5271a109b46dfbe0e09fe91532ae3f378da357e61a6303d91930d4d490c4df6217d1cfa35c6a4478d705a2e90dfd345c17c471b7a630861240c5adf2ab328d65a27426e418fb3a9700331952de4f84a732e4e3a43054ff30625aebab1be1fff3a9e4b939edfa1682c288bd9b2cf98c01e503bbb848cede02882c458bdd9436909038d526c8e73797e812665a0808cdfb1c38d3597159a83ea2f5ebcd0a33d58f1d5da136eb92a3b6cb1fc2253d628dd3df6d17ca603da0650c2185d2a3f54cbb5e62f401e35d18ecaf4b2198be82fa1ce1927df0dea406bc603cc4d412f21b1c97b43f9da8f0d68868c08605aea0abfec584ffa31584244ed6513d74279aca8fd9f130db681df84c509b4ee6231136e64fa0aaac291db2fe744ace4214fbbfaf5e9ae2268f9c26d910290ade88705c6a73741388ce744e2702c0ea588c1e677ab37feb31fd115cd0379203a77f87e711ece0690c025388e0d90f0a038ee1817906c68e5bdde2928fbad82553452e78feaf7cfee6936463a8f07b2d4375b512b72d782e0e52258f0dc416e8aef04aa9663129fca34ce8beac6189b7447b5f097757b198f3afd50313f3a4355c03e1530ce26359315e71ef618f24d59c9cb438d1f721ef59ee2831e51fd40338f178cfc67b99dffff44a166ffdedeffe8756b048d0b13d6799ece47e4af4ae643f577914806443eae021cea29f28bab602e41fecbfb532f5ecd1fafcb936a021c9905145b0c096e565b8ccb93bedc47512d2352738af62b41cb4652323625883fd0f8e33edbcd532b60953791027302f3c296963e6b1fe92d3207a330444f3b844b9eb824c81dc73a960af0f004dc77f7c4d025b7206ddd7dac5a5e8c8536c2aa15b979d1cf82fb601ad21a77e96c922f027297d30fb63c42a353212c736122383bc267cb6be7f8a15c22c70d4c106bd550fcdd36ce10996d196a33435cdb6e61d9dfdfc958ad05f465ef18e7b731052dcda0dd666de230e0b277445cf3c1a379241a14405b9c4ed9e2442db260eb1115ca4499d73a5fc05ad346975b56d0e1707d0231b461442c35942d6657c4da2e0df913cf8d4c50d0d09e0576cadbcbfa9939d4c5c8305b5b93b11de5330058dd5ceb2689b510ef2a84b4d68b7d78c60aec862dc3a1f5139222925add77458a207d41bfcbfaf298c431959d6ecef10ecac1967b3d2bf90092c4f007a9fd29a4ddca097db2ec6efb10f682559a2a94e2bc0afedb06b9f9fce7bdd608f2c4ccd2c83398d21809cbeeee254627ea24de256443d1f985b8570d489d4d076d1952278cb8218827f157dc4d8e87525aa567ce42e4415fbe13ad05d2424d941563f6a825d2c3e6bc1d7c62b4a469aa0f6067319de2ef9b82df47a325c3d94538512e64df4be2675f87c327202c10033ce9d5644f7f61d6801ab77a000601eb1197b64d71209b814551176a7f6abd6f5191cd4bf3f3d9818dc973cf5d068aa7ce2cbd7b58bbdfda19c8b8a79cd55835c61907282da1bd1876b3ff04562d11bc5ec3ad4b159fc9f5cac45258a8432ef0c7cd9cb2faa48a1283028213c25b3d7be0eb3237c049ef4c3d4e3969cf4187c02925ab194460ef3080c866e55247fd016539721672a78e2154d2b3d16bbc325e3a2f64cdfaf1e805ae904fd34bf31f74e9255348080498233955f58f082b910a5c67d1bfb33f79a26fd92c551d0285a05316e0dd1dff7d277025312a430bcb34349985057d9f0abe9ce20a1e6fb245f64e769dcdbfb9c7d07b030abf8bddbd2a4ef054a63f6d5d60790f1d14c4d0d1264d52fc5e180458ff1b7f3fbcca30dca9a455b55c7a5e92c176579a560da3c22f537252978f0a20d07abc2c11011cae998d37f47877a94bf7b33011d6330946c09da36829e9f23d4fe9f24946451e750791732882ca9399861ba879eddaa24959b78b7bc74c6c902b27ba503e2680030ebaa25934ab46197dcc7134d9b8ae6b040e05e4a46b9d5309ad16dab30df7c637bdc81f4dda66be999644f9f1994dbc0a88cda6f02d3f76d60153eb37d41a22ffe706ba2b469eb005848af98044d3b4353f71514e81f6a69c70fc4206d66b8313c92a053e01be9a745f6f5ac149a790294eb6524028ec6b6d710e3661c6d931273007e911db38b1aed70ec3bacc0625853fa993e7d67915e28946096afd530fcdc283b7a865a7bcb6e0b8776896ed4236879e674eff6e1a55362e639f6a0ab0b8cb53b808929dc600f8b0e0caa0da6af1f60e41a9658e28238050bf1b8da62ed36ee495d8f59c7fde81ad61188e01e2a32831b5789df9811f5911128f4c0c3b1dc32bb4ae78537a68f35e35d69fd25fd429011aebc2c80f3e840c479844bfb1806bcf864799e1f07a593212c2809385b23997c26557f2c75d3344f0fff17ee29c8a46b7f5ac4fa6c8cf4f3052455671f8d8ceecc766894af454c8fd1c0b91607e3db68d68156e47bc144117c9676da1b12f816d9c4ef7e4ef513763a760a52900d514c643053c6803c5ff59d2d8c4ae8fde1081db5660e0891d10ef55f90cfe18d851fcccde225240392e101ad2ca39b8a5ea7a0fa87ecf70db145c1a03e4d33daeb4e9fbe1839d880b8d2b68e1e3bf457d6da2cae4fae9f797b4d06679c73100c638e8b8f72800aea0494c7266d99d2ec7ff12ddee03fb95c239ca4ae26c302effcc1ddc9505cbaa16a97d70e3932e7a6bb1ea98c9b67959518a7aff0de027e85e869ecda00c6a1124aa2e717e1f639c725ccdf50abf63f3fa8e99d1ad550a3f7ae8be78f917825570d017cfd114dc3e17cc51","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
