<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4750f921a864ba284f395c0adfff3c3886945f2cb8ab7ffda067167c78835b71504c55f19f5c81bc1d92441bd3d6229e96fdbaf9607dfe1077129d8e8a7926914e19c52225a8e51c354d8c5dae35a2150836d721f9d1238b1f3e1ef7d449afd57496f53803f4ab6357a9e227ac015708ea3b4c010794fea432099a87748fc4204e0a289861b439def0bf9cb9cb4793143f2315741d81c4a31d4dc3495f1c78cbf8ce6df0085eb04c9593ec85666ae6c5995f623aa6519d6d273a6ee1b3dfe5c57091eecc9a0a5c287e1bca8a7c56124e95e56e1e143463f59f63d27dd4838868be645d796bee3f63653a0a40ff617c8afc58e441633850719d2effc8096fb931590f12ae5a283bb91af28e587c8f687f85cd95851a6759fc67c68ba56a504abfa51ff0fbf537d185bbce9faab066f4402334fe35a9d56e7a900d4c50fa9718cc655616bf0880be914dd94c30c247a01c6feb24ac9847a7514797d6748fdde3b5b5cc9c8e99eee8bba9b6dda82c8ed057516fa54f01cfb2cdea39d16ec4861abd385d1291d5d3486b3891319eb145d36ce83f60e131596c4adc17a8837461290084dc10cd56a8d7417ad516f2800a14eca3293647717cb8d0a06d1d5454ab25449412b091d5570c1c461ea3a63fce481cd618eeabf7eda30263a09d494907437dcf36990d81ebd088472e5af06a1ccef1501d93d055f2eb97aeecf96ba0d5be28ad75335c1ad773466ab988e8be3a88af8fbfd3422d2b4234db166b962326e9f188369c639cb2ddeae031a6c282a73084de000b915438116e6c3abe4b77349a839a704a2eaa97f9c34240d149030f25c73b1b209ef1541476c3c6d656db84377e2784053d5a84c1769ddc9fcdbc49d8b1bbf7946d22db234a5e18f6a48ebb792486f3bfadef3248baa10b89d344d678608c2a5f922b8ffbb1fcf087036e887ad47dcd7a7504849335384c207fdc63ce42fc1d1a3d128fc1eed896efe9b0a2fda8213d25850d2f60e6fed76f1c8a0e2b9888e534745b6107e4913cbcc181cd1dcf9ccca67d9c5f896fc329c205035538590f3acfd0a4d22650bf210c2416f4dc56f42adc3368e4a49b30f6424be92a6f0c5f666ddba8678cc4c4827fe8d534fa3457b9e971c8a470a5b5e6c723719b2661b3161e3d7e2e24a55493eadf196e9d9ec6841fe6177b26fdbbb72064111d07115a59498b1a32fdbaf6b652cc1571a0c176db3f90918fd2563fed969e6aabd724b4941507457e2047daf229dcf3b4c76de75fe660bacee9d5c43fe3374b926d30c24c7ad0e2b329030eea1c85fc2b2bf7fea6d45b45aeaa1402de2512bfee6b2c6f85963b8e8096e7415201a2d530939ce5bdd29df27da00a3fcc409824c226e8e92131a11e0886276e57a09409b17779ff61dfada1d4d095447ef70a3c317aa1030a56d0fab1d8a8f92ffdd0f0f9934e467bfad02ddfe30caf431e7cb52e3b73450c9d24c3d52d2cc2be5b224fee2b234bcaa3f4347dae058705bfed19833f348644c0105ac38cf85596edf8141453db5be5e444eaf5958264880ae0754b268a148f945005ee73fa027c39a8a8c9f64fa9d6d5612599f612cbd78cfacef390fa110d0d4a0ba1c54aa6242a7c23ba486354fdf2ad218a540dd5f4f5c0ff1b706adff080955cfacebbdc3c92cbf1087cca1d2bed26fb760e61741595b1b321646b39651cd56baf889348c27b6a033c4790ce12bb9ce55fd0246f9b01c64f5cff4069b1b98c9a4669e18e0d439a4fa9b9a0464b9cb05a4a2fb43444d025b2b1af7e278d9068b57d8f759c0d5c3d7c0f3f3031d2639a46275a22aa30ac4a49067ad65b7c59eedcd512bfbd94adf4ef3a70ecd8131eb66e77cbefecdb84f13e443fe6d909df3098188cf57660d5926adc970d0b350ff2eea4fc1e354217837aee907b4f5aa67e1a5f181f018e41a9bbc36960d1fb5589cac990b638b7919c88bd21c93762c94f80d97cceb6b54fec4fa4c9b5b605d2650bee15c186a4e21a09e09feb03e094826f91b385264ff30dade9b28bacbdc6eb51b097346d3aeb647129071ec0061cf03c127fc2b50d81233bdf04d5fb2a830f98d5f59be398cd803e207ac6e4f9b90735d98a764a59a32689836538bfe197bfdaa1391067f077834c639de793e549a7b9aa3c0eb3495c458a162420b8b3501836ce38598cf09f5de05c07215c867312779ee2f19b918d272e16a80a0b93dd3535e64f06bcca4b859f56096f82048f25ca1498cf5ae8002f772710b16ed1a07e742760db7a9895d3f322cd93742a1a0b17f294eaee6a9ed2d0369353e80791b62d948e425cecfd8a9629b0b141494724dd75f240e1abae2c0e91408658ec0d33f7b0b5df38bc4064b577ef08a49c30f57c636db1c7b78198fea7a8c4f3f4f06114493cf371009ade39c56cec510a48bb31ec6966cd3c0b71b7562be8a05ccb8919aaade30e52a795fa5eed548f02058f7c795315bbf168c8f593f2f7fad90f5753c1f37fdd51a54863cdcfe9258e8dfe74d78d646ad044a9574c5f18ef9a374edcc5b271bd06f998b220ba796d300bbdb4609f19a225148f37dc1f222f330d1ab8466c9af0f4d2f98b94dfdf7ece7f32ac44c96f797e01452445d5714085c3ab33af62c83c8635d725962f4ebd14deffcd4a7eee087b389547464a7e794d75cac91672c5e21f4f2b010b1f24297bb5f5efb4a4795412f76af035e19e429803ac9304e89dd20487b23e254028873d1c53d351bbe3950da0bc97deae6ce94624e50a4cb0ccb8293378893303444e155dcd89506482f5d90e9f54ada51f572ae81d3cd85f1305fb8d81a9e2480f8ffac9c4f1dd1c815c6061c112c7d7c510ea64cc36e1568e600e5a3f8df11dedccea2de7db88b35619daffb65d098a161d3593c93abcd2519a2b8ffcf174fd2243c32e34b0756dfe916f8a40e46a6dbaa5174530b2d453195087054bbc0cf34a70d1b51ab4b4bf1e546e76565b2decfa80729903b7d5a3d3090995a830587bd5250927d8205242f02330dfe16b3e8462878956662c2341b96350ae0c5d78cdb6e4f7e3dfb5f243c314b4c997dd6c004fb02e406f861bcde01c5b4d021416d3db8ea5a1e8dcd4a924501c45f89e12cf25c9fca7ca249ee1c43a4741af660b1a3aaf99331b69238450f9489dfe8ce1a499aa80a30ed4fef60cd8548e66a4559ca594c0e7ba8280780f149e700bddb97f3471ee741a7e436be0bcc590cff3695a9c0beb5b085feb80a9f3b69fa6fe64afebb4315bed234a5f09932cdcb48ee504e81b0f87e3d50fc2ce5bdf9ea380b882b539a86616e9fd739c2e7408b69f831f7d7ebb0bbb25759c10a19859b0a4367f4dbcba01bb3b9f9cd4948fa2e124111af68c059b20505c393fcaffa289bb20d1cceb4c6f8977fcedd18ab70c5f9f6a15a9dd446c91c2a7e226f60a232a67aafb15a7959ab3b2c0571459756037ec048f2d598af9c807677ce17deabc800688c776a91b79811ef8d4736d4063ebb7c96ab8315bec399d7c1734a17ec1a5b266d78e6102c0cdeaa4f28ae9188332fb2efcd0dd7498ee6d0350c71e2479b125c8baf27cb20404366f0d556e72b138bb5262253ed9dd56d36fe17743a43651ba5ccd0296b798f03bbf5633afec74f742d3acb45cdc17a44b6f3335bf72e0a7a36b827a7ca4df5b12fa6cefef630f1fb509ba17dac083b1a2d115bf75dc89afe463ef584b322f06189b9fdb4a7e3e749071d2680feebab9fa7aaa14e7ebabf61158efe4461c980987d86663b014d8d90a146a74e148092a7b311cab5cfebe356bcdbfd44c124d198aa76b6ead442e81101d8636b30da108ae8583a03ca425e4ec8be4094c9ac076d952eca47e9a136de70ed6140944e8e1a97460d87f32def83c58b2d74ea8c88961be0658338e11a3fe313c03ccb73c0516a99d1b8d3cb337b3cdc4b48cfa4f2e14ef29b9eb65237fd526b2947b1ca1425ad218e6ed8675cedead3d8c752561b7854de7d0d2e3be6e8e3f61e68b0a8cd9a12f426601a81786bfd444e0aeb2729e17006b01c0d01ae72f0f263b4b38a9d5e85297b749976ce1935c100af1249ae56ac8569f8f0df5f5bc0d0e96a167e06c9e3b0d24d19a0d243831d418e99bfbc4e697379181400b192ecac22f3e43155c371429f92caac2a06990c8aea83d44d35bf3d1342c311b884f1e4bac3a9a6d8e5b1fe900ca505b6ae0da63e624518fee82b9d330bcdeac410a9323feb76f462a8aed269e43b87e8b7215a075c704f2ef4707ab223359fb0e9274550ad11f43d9eb35de46fc45f30bba4bd19f66cfb8ab4261d510af74034cf682bacb656daf86aadfd51168c2f519e0b393b0a4185ed55dab71201dbc282983c0daf3a4107c607221d7f2443dc160b23dee44ca98d39da41d873531a6c93d1e7278e974e6a3fb9d0e9ccd51398b8b57f961b6fa2e7f3e22ccdd1fc457476ca8442b1484de572bb572763bfb02803a0e83bd5ffe314594a6ddf15d214944aeb13db6676d6da64f7890c866de1c03da1cbed66faf0acf2985111eca0e5106579a4a94c3f8c8dd188f5024cf77ed443c475b542d8ffb725fdf2561cb0083ebade3e90699582c01b7c52fe6b777fdc2312d846161a06254038059ba3a2700eb293e3a362f577c39e24284cc1361f55173aca0c4ddfc29abf07f7d777467ff1995cb850a4223fff5dc3a624f2204da7e29e00b60ebd32560254b165d11f25137c4db37bb7e511ebbf2300706abf3612ffdbe2aa96271f251a0d3e44d48e8d3286b1775563950ebd6d7e5a67b2b4a8d98d254825e42edb9af2dba520d18fbab7357daf762eb89b4a554bf6b8baa1314e86da4476cfbc6c9589df5ed717f4cd366003ea77cce0712a96a9543998ecbbf127c4fdfb38caf9bea2dd6f41cacabf82996ab026d58927b1a72d89664525e1065f050c7de4b94cb3327331c5aae76de68da7995f31e1601620c6720e59f85ec6b40b33732f0c8caf39d9ee146ea5f9fd2598573cb9c1565d37008844cf19948cea2be2aad246723ae72221f080820c5cdbc6f8991be433c446b25c826c4915853ea192e9096ec1d81bd1a09cfdf575ca8272a1644f6f7859fa2ba896521f1a64837c900d00bf831db3662715037e39913ab47075393fb19c6958f13c22e019f92b5b0fbb7d916aae2679c8850edba6a9f97b853654a5f9ff9355f1abb9bcb9ef8da9d18faf149730ab4a696a0cfe480fe59dafb5825bdf477156d5365063699c293438f63607c203670c72432d050bf1bd5ef2ccf634598e47c6aa92f710296cee64667c60d5a341b77e032159f3650a53240ed050e4c535ee39176b0a118ccbb035b46629350eb458c5d02a74ff54f72b31186e42d5b14832f415687d3eac43af80312850f8c230a8bde6dfcd017eb584d292e932bb9fe6ee31c81b7ac507c68a04f659d2640100aea2a4ac4ba40ec3b752c3be34c622630720b9c87bb10566c5dcd20253d978362371e1dcd56e6cd38d5ae3d77b63fc5be4ada94cc76b7c53ce8c5133d54059bf4d3c3dfae950c67af5e8e4f3931ec17798a24286c51fd27383257a8521f674c2b958475bac3da02661d5eb769deb44bafd318fb480d6dcf76b73ce4ec470ccada031066ce6273a07f9e9bdb0515a2c94a7d60f2184c70a0c506fcbc88bc55e9a5ca137f13d3bbb89ba0821b77c0c683114c7b5b76f01f98e6ed1e5af7f94f35fbb5b897d44d69cc8960b38feba765bb6adcf85cf75f7595226a1ad829cd2e68db41dae74b565788995a5ef0772587699f34264a8f96692dad32199bacc37a2d8d65161a3185f68ec38bb0dbe3db9b9854b5b8fd85b13ef815b8f2ec926c340552a0e1f69a7dd8eba2c0a4cd466c635eb9ec11ed4249a4a015efcf0c2198e218caa8a38a55408d15d77c359d91d78f6846ef83316e8ffc0bb91a897c1781ddf4a0a1cca072afdf212a9b4387e597b7c2ec20aa35fafa370603a551d8c82ff7b6af3c7f0c6bf7a5a3a043d940ba92f1eea6b2eef62b682a1bb280d649713ff0c41a64beebe6d104dd34f6a66c9a0e9c9f106b72c65e6cf86882f00411236f99d6673a9b4b26874ad9b9658fc5996a00bdf3c5e1e559d8a434eeb09128b5a635b0fbac88f35ad9d0c8d84321c88e4ea89d0992d1b959d59da2d5107db0fb93e96f4eaadaed68d181f62842c05b6eb844f24b125f52735f11eb76e691e82b1c35201113f281b39baab90eea8878fa1c96dc9e4a0b9dea465bb5246a6d34ab950e54297e83aaf5a85155cfb2dd6a6b93cf907bbf2464e197cf1656086154a2266e217bf783479a1b06b09effb2bd32f59174f2d606b6993e268050cbb1b4e7e6a4416a22e06f02af80ff38e339484ea4231c304658fd14c536f0a717dc1024e8c39ed7546e56354921155405e9b49602171846978ba57d350a9c69c916e84019cfecf4deb802c1b9e3a538fe950284be30fd93d406140e84f4dabccf90ea6d7553b7a0944da6d591465c11b14218acd07af3585ae2d2e7f150bbb4ee7d03d63531be37f9b61993722a44ac710073d93902a4d764d406df31a5cf3ce4af0bda2e5e21b49b39cea1e78d848a691f372631d432ebe67a61ccbc6fadb8070d0bc5cb0a57e69660e407f637afc0ce2f4524dd2a76c06fca9b13c2949b604236a533ef4095a145827b6b080fb217ff05e3659c96cf9dad05cf37b0e1ace86d70331fa98285752fceaf8847b16a92d568f757aa394d1451c872f1ceac041a094a0010a310d26add24ac4969bb1c095a3274337e291f24c37dd3ffd774e58f5ad5bf3b0a7e9bcfe793fadf2c7538014b7dc7930adaa1301ab62ecf59c31ff8cfef001ca7d9840f2587815eb4aed306ba0cd8ed346805785bcbf93d76aadcfb62d324c53d6f94844892ea62d62e5839baa6d7f50bf7ca893ed0146a9de5f817b7f00ff2ebe2789dac49fc10a643b4607c802771da13cb03d7d28bdd0a159bcd52682ec554b5199f319aa3b5e56ba8a37747d746b04030fd768274ceb4ba331ec865c2a956e654b52c91df6ba6cbbf27a8188ea8f568f0b8f24401a929017343aa4701e3dcccfe1405074ce9d7116d23e302bfc580be6c6382271f4d035a5138af215c77f7a052ecf47589cf331c8b657cddae9fc07f6cc2726513e2883e76348ec281d5b01803ea5a772fc92ac507387c948dfc9b7211f8f931b38db5203858840c109d2ac4a3d1e928b06814d1379de1d0ce99f9b67a214349157ade64536b87399a75270cb2e191c7744546a437f3720d6985731b6456d634e129167720e2be412cfd70fc052bf044160cabca683e8708d13bfc22eae334eda1ed5ba2324535a9798117a780b9a26826e1bce9eb7a4f94bba17bff41394ba0884f03651c2d8799ef591709901ca7e271117289e15404d2a4d5e28075c18de96fd169168638c127e2065973b71500748a1464cee30199ee964fc12e1769a3c3b62f31f3e3730fd900a434de540ee900701de5ce5579c7d1b54ba15f60cab6f2a932427b75626cb014793ea869e0a61f88a6eb05d78e7654c76a8acbed04d0fd3290511f4e1dc6293488bdc1ec96f8347f0eb0ac070c4b389422f1a1ecf277668111135d843ec14a808933d1c4904827a05cbf9f8bd435f07db1d5659b9c9705b4fcba8ea46925d0b55b1a8a105d96713717218bdad4a843a613a16186849ec8f4e8c6c19a933daf056194c187d5fe51bab83d77600d861c89086da88e52daf160b15505ab020c157a04bc866a5c4865de88357738e8f490f6fb699219e9bbac713782c80768072d71ff8f8aed7674fe3a3250a839eb17bd9c077afe71262253143dbfe7276fa16ecfa24fd1be361b1c6732ec281cdc059b9c9089b2106d5e11e9b47e3e3a0293509ee5a20930f67db283c4e8ac7a4c06f361da92d5c1b2ebafb87dabd9b8dcac8f9ce38d3b5cc41927a2502e7174199495a9ae468d9379d36184f5c1abaec348f13acea856904135d75f1c4df9d84c2815ba8a9d92e9666928f96cf5c5abcf4723f9bf76c9037e374a93014b4d5c725d8dff71c23868ff656e32e229f29785ff3900b50f281b8f7bde0e413b8f0b87b8b8824542f938d9ff17de05e019af9020998594551f0e53db3e14875e6b4b3c46e1f117ccf7fa6d5c345766239f77a3d27cc539b4a82812178089ef6ffd7f4e005f013b22b9fed6c3bd4bda611bdff79de8aea1db100da2a356030255e92938a52f3f975eaa577cf7b31d8fe97597f931a17ffc9b3117c10a5f4ebf938a62f63613ee69ff1d600fdd5fa96682728575a708ea536fff7e508744ce5aef7cda5d7a8860b9b44de1c92f508b3a1d5542f9c4f473155b88cfcd73263ff09f1e22eba41ae00de7d04fa9bbfc3e885ad91cf4243112329a8d4cd658675d464c671818c109e56a9092a9b99b0ea60ac16882cfde6c5c4e08ede9cc7fc5efa0c356e241c5fc997b6849e65d69d401eab89c5416fe839b28bf8bc525951ce563ebd519d6b64ab714336438dc82f681ef5f6c6a54cf8be2baa0f9c42048cddc30ec20e07bc204dd959bff6f80d3dee27e23f53ba0e58b9555547ca96e4ba452a26192ba9a1a883c3caf6331d071947412da9b29cf4844452deb6dca095ca610dedc42cfe8f0bf8f5c69cb2d92f20ff772183b510a98ef8812e08f7e24737675ebb81311817528b24912d8de78f7dc45e851f750b24cd9297b385d6d5cc80cf08f6d37ef4125570b7afd778cf6a4c943f70435da5e94ac92f5ff12431dce86dc12e7c38184b63366a69104c8077a1e5dd4ccb4e5b788660e6d12d4bc442d1a84cd56d20bfab939b9bc23291c454e18a2fd8f569cf3af76dd0325ef2c6fb0ad03630287db6c69cf913934abebfdd35090d5c70011a70d1cc989ef926426888021d3c3435040c55fac3ff02def3abbaf2466987b1b343182d9d9d26ae49b8b08f75117c0c7393d24b9a24228394137ba9b8564022cecbe7ee9f87e3bb358fb83f2f38ba20bdbcf18485ddac326b2a2292b3816c88c7ac942454569f6a0a5328f5cc3cdf412ca24231490d2581acb091b09c669d431090bc671ec2b8839bc98c6c31cf5f290f72b72e10ad97fd223efd1b77336e28055ae1140487af4471d8d41a7e05504f48bdc30a290e2a31fd7f2606c27ea5a9ae42905152ae456c89deccf51aeb7fc9d88008523198813cc38f428b3fc0292d2c2a123388119fd7fbe8e543d9e56f6119f2c0ee4eb2a8907f97895500ecefa4045c693b356a48b589396934e165096b03f7253c03773d52673444f2dd1f54a7d00b7f59e9a9015c5e9ae19cd5da1b2a669db706fde790b1f613f8cd92fd03bfd923ca19bbbfe2335f438a10a02ef38a187f962d9edb6fe4140e4f6fdc9e9d3ae32950992646317d80c72267d9a97050a86c38f4c96cf90df9924d813a2159f221b47be3ad120bfdc4e7df96967ed518fd5b300254497c40148b343d87e91b9003d9e3e0454030d51484907e559d006acd5bd3b09092d0cf7fe36943f8a49e6249cd3c3c55fb14897103410f6712bd4ee642d3520c47223c009d8bf8724cc0983dfc4a99afff7ecf76f2f51db2b60b41e688f52597dadbed91e993cb82e09f1582f50b035a1b6f7e6778352ea55b42ff0f0a5f42a04edd1e880506dd80e3cb59077295f4818a82696a27f5b2abe0e2ce860ec5527f89d4ba1683b46e3be18dde21c7e2e27fbad961728615b9706adce0d30e51cb8c90b43891982be3305f847a049188a5a615311a3978bd6d921218209821638fd1a15ec024dc0b4ff86222b76716a2a2a552fd6952538e544c94b2c636c036c698245a1eb9ae124e83d9bf7da00cf98ba93301a2013b7d2b98265a0cba8b438383f102a394cc25e6acf1364694741fb3edb6488ccbd52a7412d76e4ac88612c9f8e74dd81891512f6c4a6c90b0511644bac2315b79f416ee5fa9d090f508ccfdb1f21bd4949d7634a6191a4cc27f5aaa0e4eb4b108304416ed21b50ca5e0c0b9f626a616a504cab539f8796685b745e64e59e83246ffbbac3abcf7d76cdca6b9d002e511cb2dbe38ea2c1f25c65ab5ff5fc9498532adf2c62c968c7c483f65b54a544632199ba0bf3fbf77f8f865f35c2b44a353caa5d1bb381e23fca57eb31ea307ca7483f2c570d9722cdebf0e99095f8e73b1015b5e90e513fe96f7a6cc0546cfdff610cb2197a5fb1d5513618d0f6558fba2ffe133b942da35ba6a33f0e453834c09b3cdabfd3844c54cfb33d1d1d8b1848950e6f49b85d221657894cb1eeb3dde4713644b15d59bec6d2b0aa7fd962efb9e9bfa92b0036b766afe0e00553dc22f8282c8bb0707fd594ccc38afa9ee7e6bd980930b17575d349cf813b04a06efdca14ce8a77270b721779d2b03b8eb5ef2abc45a9de2241edac3fd8333f97f8648ad8b59b6fad1d94a354a43691b4c0d21a93c13db91e262da13bef6b7ed8889eacfa6203e59581bd89becd54e0c0be71219e98413afb3bb1cc7fbb1616c4bd25f189d0d3d97bf57a32df35e1a6c0f1ed859bdfec00d5bc142b39b71eeab92f76c7e917ffb785ae36ecbe1f8dd54bc5fc7310cf85af2fea715a506822f7e50e086355fb1b2d8b9db0437fcda7390422f7363c3708a5736f3df250cf64d9df867e7e81113d0ee43b284d07d5cce6f18055f63b40c59fde1e3f7a176cddd53ecc5d4f7698959f39371a14bbd49357f5a102fc0d0275025473bf8ef5cd6615a43c3201269817b79c42550a61039da1cce206aed722cae2fa2b5b336f3d7f4ba1850fc09ab865ff4f92dea488ce40e67fc604002b6c01f95a36668ee37097216a5d7ad7acd9715bf7d7f852f348a51bde882415f0b4e75e20ef216ed55ad4b8628b915658324e7f394bb8951b5ff7c9821ff4d0e61e58c4c765600f48741a7580a2e97f4719971a6238edca631454245893a50c83e1b4b2fe3bbd9902ee10132a491c5fd075227bffe19e44d7de79e1b098396f7f6bb0c2aa9772cb87c869345bf400abf20a353410012cc451815f7150742903c25e12a64984429b4260b3e1764449c5dc2ea315d79ef2d5d2e4b6c4c09785fd1f3c984a0cf8ab6c69ffeae1e0d8e4fd803b44ddc90bc1033bb1d523f3a9e8befe72802d441868fdc847ea4b55db3bccd65d28232075d21314074aa4dee666911114c39a74409a2401ea3f6af394da777d75a393a7a14d5d9b81e3229dbb818733cc3209745763419f33cf5f459b1007573ab3a8dae207c0d13f41739f3436e9e900b3f68f8eab72d7532050b4f05cc316b94f4b7d5306aadc0182a7157aa8fa770c4136071e8b836d70afdf92047714599dc893b415ae76c69a563b07734e2f9507c1716877df689eb6a8a69d2054e5699d569b2c27f5a1782538c57d3e78c4684b157b0bfa844a9077838c85259b958a58792bdbb696b59ed00bf286a1aaf14f8107abcec11e27e5e2530d62963e79075389b4a2060d441432c70373ff2d1f6220263ec6abca82e394dc5160be04e25ce8f936d15e37c26a2484f30e9ab1f50c1cf49e1a168e811e425fa5e4ddb12154590faffadbe0d4c11be7edfae3893bdd1f743477ad8ae4c13f3cab23f48a344ab7f7423f7018bbe5af98dfe5658a6b50a3a09a3188aa9180a5559caef80abe647ecaecb2df196f41ae8872d127942eed2cff1e51a2fea033108886b70bd2bffb17c7c55f940e85ed7fffe9e4c442344afd0269205ec17b33d6ee7d3c679c45ecedd29abcf4e2542a2fa86167f147481efa6932a9dffbd4b7d0d4c4c04cba3fee6511f65edbfe891a5425f56d00591d49ed4c330a1e984658e8cf9f205d9c6cfffdbb24d9121abd0b9e2a4cd4927e0b8d7c5386213a39d75040ff50b1551ee9f48473942351a2ee81a776e029c01028ee0e67ff58f786b1c64be4dec430a1acef722ed93d70e41a8de4605897e2cf82d9f299b1822215ec0747fa3d45e98243d849b17aa01ab79271d144d9ad9abdfa49abdd1b8b5e1fa0a53222e6102331dbe180f492a5bfb0a5fb0f6d8bd6e5bf3f730dd4e519eeca770c6c544623ae8b347da56558dac3d9aa3812f2445cfabc2b1c03f2e11a6675ada4f1be26c62f349f610816e42649a4a3370344086045322f6056eb7d69c0a88a9d09f93e1857a8a70a0fce4619bca2925d304a20220e5bcd010422ddbd1f63965b6d781e585a4282c62cfd6eba4e2677f7ce5a7d0840b307ce9b5a10027c9ccea225d14fd89a48cb29a7377aaeea1724fc1996e1d3b41adc71ff6805ce42db19f6b5515a03430fc5745cd9066b333132ee3aca7afc2b0c900e6ecc112c8772fd1cc9fe3c0c2080e639d073ad285ec10fa55f17cd034bf911b641c860d21e6b76581439dd1daa153bead53b306c785212a515f8c15250192a1dee6fc36a7605e66f715597f8451dda405a26a16f1651590c5d43f322514492d9d342fb1e0b1fd8c4a4b359fe8ed900ddb7ecfbe9af27ad906e26fff622d2132f3b6a227493f5f92208d24800fde46b5f692dec5b475fd8abdc6c8e65a19720aa58a74d5546498bcd9c6c6ba0f4b7a77d752177061ca6f0f2be6dd3409115bfdecd6bd22da21a4e775380488a7e6188ccb146035e58b8366bc09274d66999f29fc912e8cbb2a82a3c5ff8d8652a15e3f390fb78bf219ecb39aa7eb8d2d1edca2fc74d8af86def92894ade0860baa6de2f3bdaf484fd4fa57d743fd32eb2b9e8638e95bf1d305984ec08cd00a59aa5cac89bc2f56bf04f1d41dbd2a4731cf14c365075a5bd9ffc3bf2a5522d1711fc4b7df188af0e4fa3dbf2083a47e66e2d8cb6357ee3ce2b3b6d41bf3a512348905cf9e14df3f03210734200e153aaa41fb4a5c551bca4da237deecf28876d9684cbf75999d7732dbf287667af2200e940907b5c2cc821eb666af50771eae4cf2fbc6bb769d9042dd27e290e5b4080de90baa36c977accb9870c4ba11fd86b6f8be92df5ff53db2e79403f63189ddcc7fb729de6ea438678fde35dbaf106f91da678eeb96192558098e94d4553e4e062c710cb735823819cc3359827ed297071026e3ff2ae88527d0965de1f10cade0599a93e0b422b10f61c33a1ec2a2badae6244c63b2f16e84f2d0618935991b721f064e49790a04e5cd468ce7beb64877a4b95f6c8c9d997bc45dd65a1ce6ba45db495df0cdd289fc0b8d3b13d500ee4a6d5c866eb0bfdbbd9e0cb5207632b458e076b707344ee94c7d3d16b92db0756694f3b2ca9d1c74da1a68967b1359d50e4d06b5b0109bdfe04326fb3afba690d17b8eca0eebed17a7e7eb1400068c9f2bcb98a86689b039d9e4abe0e0dab187b2056e9708433b334602516861d495663b339e54d910199c51e18a461a0333aa417b131f9c778e3587b195cca02834a378a69d0799c7c4559a36617a4be4540903dbb3b2a0b4962283d924769d942dc47dea41acddd6e05445398e394b4d1bbe4968561df06f5999c7ab5e7b16cdfd863cc48f0c0f839a4cdf9ffeca3630d873d99a499825c3eff4fd7ca6f54ac44d6a8c6fd75e7b396bc73610b373b56dc032f3640b90fb397376b2ca2ec3a6f05b5749bd5f3f8bba3aeabd9bf917deb591db921bcdd6f423eef3833e59c3c3167c50030736b52732ad8ceb492aa80c45a32f5bd7a94573677613a8f83d7928f05b349069a4a1189333cb24ea24ff02cf2bbe1ee17f10e5e147dc5c7468680ab369047f7fc36f81df397415f4e97f7e02d96185674621fc6e78ace0071f9e5f7dbd84eee9bc486700baad4b69275adee340f303d3f11f1431523f8d0d502574f155d61fba09fba33edc926ad811e9370d074f3286e564f288719b1febb3a3e98963f74bd1d3e23dd36b56aa014f3b145b6a065c4ccea8f4a2c89bf83310a501a5fe532be630fc79089c740ce641ea5983f1f5c011885ef659b1abf4dae7b7429dc4bb6b361e7469e82efcebdcb1ccf16e266cdca4c6f623fdfca754f105ab79d19d13b6e87c39d4280cc7d78e2cfc6892babfec29aa281ab6d26185465e8a10e7555e500053c478d08a751f7b6ff1cd76f819536cff53abe2066d4f7a32bdfc3d9a3bc03705d6b75396aef014708d530614741b8d0ef778fe6a4879ce9053e983aa5172c9a541c60a988e79b1eaa4d09256671c8a381c6e34c2dc836dfe0b58bb1221774b1155762dc51f9ae1cbdd576c16453b2fa51ef81e6d4f27f590a182b4f0325bd0649bff40fb6f3c391c8cbcd02904dde7c5e2b447940d4429757e8daaed8b6280bf40cb94beb00841e88ae7e243ecfe542ff8d4d18756c9ea01426b8a70fcc2b079ff5096b41367d554a1f044ac23745ad8693a4fa689aa3b1c61f36c01e98d89c97b76b77ef37d1ee319ce8a8b012d279a9f3aaf6a8f7daa6a9c39e37020a76b3a599d54f8e354c45e2dd17b6e44b8c66557eb602d7f35929052307bb87ce30547e50ccfdf39b65b86e2290251b6c7c11260838ba6af9056e49d91e066a3004b6423d24df02befe4ed115efc7e64bc2dec2c5196be82ec8a84c753fdc90cfce0e6a93413de9af09d323d789103d1dcbf3a36c35ecbccfd01dcf04b75dce606c09c76fa7d85374da65f371b8174868c6f770831139483112e9d1cae4f5373b5f0764669304e71c5903caf36a7d2150b52af3c7072493e870299c5295fe63cb7949f44b1c14672bfe783dce3456dfde37355be91d46422d74c47cf1cf718951dd038dd7d8708b3f14c5dc8f73c92884326311cca8b92f3ccd1cdc5a8d89c86fa8f8f270a75194f4aa4b8f07b8ec01f532052b5a7ff045c5bc9deea0f159faab64636a2c850fef3bc23f06e71ed9bbf9a481885cff50fd3afbc45fd826362f10fb5b9e9ce7fc55c0dd5709dede38643a4befe9876142e79f8d96da28b69a1023863e2b9ada816492553fc56fa771c220aebabc7129ba15da12fd96ba233044fff56627338df008a585477f1ca7f876744b9b115690a8e589b6851b2981597a76e9530efcebdfc51c79519c2b21a58232ac9bfc32bd239239ea2b957fdc5caee6763e9de2814f05a4a52aab6a85a0943bdcea2ef5c033c7477da21db3e787d16c2b53f0d4e70bef040894289cf07c14109b8e2c6334f4dd44c7f66afb23638d982cc0b1672f240bea8ed413923d9aad0e779c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
