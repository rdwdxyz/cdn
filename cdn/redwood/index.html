<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c6fcd925b98076a5f2cc39fbcdb0382cfd20a6f76b3b13f0bbeff5c0ece5d17dfe455301f21f8fe04fe138d2e546cef0f60472d174421aa2bc9db89c09f0bf3aa6e97f42e0a81fa90149f258e93d32d3db3848912f0b7975b0cc6ef56af8e3ce4c289886e850472a5cfcc9bf14f138d533c4d47360996b414b42ae58788d76273c810ff3938fd79f1400b030dbc2a53b6941d4fb7e1862d77cf6a9dcd5d465ef09bef945a5493166a8dfb7c777f081b93d8ceb53c4488b652a40afa7e8264c7124ab372393b0d896d0be30ed7833dffd34980d0e8a07265061b36e300b960a879ea9f0502c542f4ef144f8ed610544679b75d817db066cfe1100f024bbf894919d13249a9376e460479c72add178de8a840e84d0ff48df62e4c0b3c51e265ea298164a8bdf8320d712697946b93694ef026c9029bd4e7f0c354d22cd7b6e5be4d31480931055fcdeb2155aa5f4be9d26500ec236dee829137b25046936baeb2e48fd1bb04f26c0f77d0b33f7ff3386d841e656ba812807c22941a3a8ff82423bcddfd4f01f177abbbb8387074c42674964405ba5722de990f80bb6343698d37a81959298699b5cd0a074eed37db2b5c5e0f7d054b65825e3fb50a3b4ff454efd08980909d72e10104cafef107b0f5e0df8a51a2906dd3c76af75d8efce9544675a3873a4bfc8481a91b0fcc2f89e9f0f7d6d7b162af1c2985a43a45f9a5d6f900afceee244ebdc9488bfe25a5e5243687a84ed180bbcc886521991851f83081642860a6bcabc3aa9e0dafd44ba5a02c21bf2b665ab5d9f2955b88d0b9705b200ce704fd59ac816a2849cb97938d8eb1c0c71ae4de0313063c6962d7f979b8d55daec259b1701aa5f6773c64791b7c3b3ac89e0157541b1887afa570c7cde99b3d790129cf3130bc92323eef0c7cf680db3460a522fb17c3d3e6c450b3fba2c1fedc3d595ab0f0eb07031a151a05a667a32228f2dbe89064789a8f2da9eece324bbdc2b09befb75fa35b8c1223958505b2dcc6cb47417d8d9c9ab369b3dfff83610d230efce60041c9cf584c03d9dfd078e74ab1c376074e981f265a2441c27ec3fbc390ad882020feaca8f635afed64ad8b02dd2ff43161f62a3e713179fbfb5b0693016cb9330384f570ed487cb30e1cc41fa737a65f76d55e592a3f221398a0e26524ce533b5fa33113f3b4a6a0b9f3daa2f9240bf9bc1c265d383c7039598e0c079840c97ba39ca64f4c511431af33c67bc67739d6570275a74308bf1e23a60a85962e3e2938debf7ecef1c73296de26eab59a632dd5c2b663f142ca4ca6dc2f5c551c9e27645c96e049088ba14badf00fb840fc44d07c82b059c2822c7daef5fb39f74f1bd8f836efbfb4255138135189a4339fb397505f3c7f05cb6203f5d55f806d2747ac6eaf07edfc956977cb9df9b1a87f70dc3c02443d5fc13fd69ab1149adfc4eca3506b4994f93c03b0c5160801b3e8b08580faac429d3cd18d8a8097b612640239014653a986748fc5a327ecbbf7d1b444fd37aa9d26361eceab3a7b02cf4d3dc3575875134a871cea2a054709c1d81ad7a277a029d9c83bdf8af203a49161c4f0bc5de9d2a230b1d9c6fcea1959401a34c1bea178936c9ce8271d1a5f2bc6918d930b2f01674f7881cbc7d3753ad2e135a84631c6af3f3ea65c63d7e45afba6cfd3ae1b208a1a9f2580121ad8ea48a55f4b3eee97f6581efdb0878b287c0fc48748790c7f6f7677170a66c10cb74b22d373b7f511925280a97109d69e458c51dbe097c0b53a463c359ee7e3203390f39a4ac225efbaa26829cce2881f76f83731829d13a797f782698e84150a304015545677feac3f9890db81eeb02ba8661fe3e51dd231602c8715a84e1625ec85154d2d19156f76e3b2a3e1bf1fa2c1af8823d0ae8334ea1175751d8e171f1af58ccd5a011f5bb0551af6023e2dea70711af20902bda4405dc8fbb54c09b421d0c800eaff7cfbb6e0e962425d9fa256a8323ac98096897128557ccfbd1bf8166a26ba23759cddd9ebca4d9d72f2f30f84627243a55deae3ccaa4b4c1d19986fd72dc68f8ea16f79181cd196e3d4b4948359e38fa3bec30a87642d27961fec685a0dc3130fbecc9ff573d27b1fda385cdefbc65c15d7b7590c98f3dbc2ce7daaf296fbea30d2a5cdf7412998028e5c5b521fb2eb969bd4af6e75619f6d3938bce283d52012d1dcbc60849d3d13e388abacf218fcfa72f7b0ed3c12f2e5fddd646288bf2ff098beb36f9ae577283246c8db5635dc5e4bb2b51d24bd81de76b8ceca99f3202a0b2bf6afd21d64090c4fc8ebf62cf89704bf6594e0ca14f4c07988c1f0aa0d5d94ce256449d7ed860cf2b2135b59bdba8811d508c833d61ae472292d7d5fb644f9fea4a7887623c5ecbb089b2bd937e0ff6ffbb9f05297dcfadbe1e3670d37c56a3287583ba9e188cd367c80b710265bf06f9c175c1ee63823279182b0732bcdcf4720e1e00029537be1c7b8ee282de50efe93c22bddb3839632f5d472be47eda52f57b730aff7ed44add1faee9eaed8da2962ffd51610b6fabf166ea6af3db717e040245e81a5f4873a904c88e430d2834b323c16728415e95fc1f702d98d8e63200b6c98900911a1652c2d6e43aae7d060c7ece77c8cb4ec54f900cc1b98125e90033ad49eb4151c75bb5aa41477baec7fe6146ee3457e26e5d083bc678f724dc69849d875a6cf799fcaf3488fbbfd74d19ff9ff933f0c9aabf46eed884ad2f8ed0df468dbb6a5aeff720657c5f36b1f7ed9ab38d0522a096489a01a7c3a10321c490fa812c9f352f1288d0ef39a89fb305804fd64a0a63ddcc84002db6baa9fe7ed1c6f92edaa463e2a1ff5941ae0409cb61b3943b3b3b95b5f9929eb61b5183218d28ed6b463a12aab931b6d8a23d3350f73ebcab9338f2aa1f5464a6c2486d82df67d7a02e29803e1dbc2df8655dfbcded004fee71d37effd6bb4b0a87b4b16b785d4bd83ccb839c6b0322de34a7c030b1a7336d70100f8bcb223642a783f947a89558f31f9d716b0d43228923bb89d8ef159c476c8be3cec69d13c9deab9360c677c56d6de1b0ff91dd1e783437a54b7151a889dd3fc9aa7593c624c9bbbf2daab85f83fb7f21a66d5db35019b26be30e7d55d009719c1df3f990e6ad03a29b6351eb71e47b57cac148ff186c8283c421af1c96cf264a82d16d944c94579978a74c13a9505882227c87ec71163f6f73f607b3565d63ba18e23437fb99218434fc58becd3ab8cad5da9a50cde0b37bc3fd0fcb085845074c27ef50396ba47856375bb319e17efe66439837fe09ce30fc2505a7a8b2d6003ac1ca6080e2ce4651b2ac7a0e9cbc6959b7d291b75b8e76db9c68f2e89030952fe7696206c8012d651af360337c76cd5cc9b3de5fc692bc4eb7123a11b8a264d7bc0758f131453b195d35588927871d36aeecac22dff2599c4da26209c602b7a66d0f7e31aa4b431fe70f24433083d2a5d88ea800a0ad5ac81baab51ad51113f1e805a57aec4f5200713b2c71e7e08482eafd7b545ed0aa35787fd593e6986771d6c852ddc4e0f4794d9e3c57794d66ff5d126bc1104442d62e7eee95dd3080f81f9910a029a442a2662d09f6b34558b5688f12423a66f5bed1e880c66f9f68f5d41e9e18bd5fdc6e788fea370de9410dfdd618d662bb6e1c04e4c420637dcaf153e317f34b8a7224cd8e21c845c18d7c458efce97d9f8c42da7aaec5617a51e2600235234f59da147d87a442d0d59faa014f54001758e50d66010864e7289f9eeaa2639f4d2148aa9257b6291a2215ac7d2750f68a74e2cf276ef93ff7d55f30a0da2ed2a1269ccc772946737c3efed111e140d85db8f9add872092d02cf55a15baeccb5d13c2edb0ed137852c81a42af16c33fe677b1b999cb05966b683eb802b7ce4495f76d668f323eff524554d573894f1949937529bb37796a528b2dad4591b92b8122125320ec457f5032079177abe8cb0f7cadefd28237a9ff98d055e439544b83ea0a00a378717649bbc9bb0777361a2ec479219fbce11289a7e95a47121e62adb122fc5780799d341a4a1efc4b7a1074a235339134f01b087f9f54795977e2a06c664660a4c7805e46b2070be49e55cf5697253fe585b2ebc7470c0063303c236fa7eda94b845b1365eb14761269b0d4a0dfd0ccecb192a5a38f59ce06b1566e6362a6a8204d62809cdb21561b0af9935e97b15fe62d4b3c894e9555738c671c6274c538e2537f3444323ba2c1704d16190ab60ddfbc37ef08ad5876e4e96abbbab78539633675c8ca7dbe1c06df8d834d2e74c4422e199913445982162e15061369c22476310b67a62d82856c08243f1376473d3f9c5b1ba6d67c28dbdf6123eca1e3254b2ed10ad3ace7cf9d7996bb373936bd626d07ca1eae63583962613d64291f2365a48028c0813d0c2b56c8443e8e20b5a0719a731eb2b6c882b17975c90852df96295216c803465e9edea9413cdbec4af18ebb8333df82ec868239004b9b05c5cffcb1967c356e8463f496a21fdc07be24dd9df7baa052c14abe86afc4e0f3418013110353c40788a6e6e9776aba53d7a51eb99a2b9fe4142771d862d40000bd7cbced1399f413bd6b940a3f9eb8fc68b6d910da849aee116485eb965a8e8acaf9060a85b9e680f956bceccc698e4ebb7aeab4b9a4fc7e12f2a2b3df11ebc8b8f898bc7c96994b33f9c509266a7a8fe4a6b2e6d0ada9b414771812c3771310772b7471caa6ebb9d7efe59e7377c86e87cd8d586d658d1f769fc580a65ced87889b5454c3afaef25c9e05554f8b4b31510723348ae3a8239c8724496851c1100e3e39d52aa0f7dcf02e50d7d44129867ef936f447fd9f55a29109c15e5757ec82f2f010b06c971e2b8220b9535de99812ec8b8ecb05a6015412fe86b62dec1a65f3061da5e9c2d8b2bcb17428e4822ef20c76434ceb0e9f8267164e2c9f274481d5e4fa104d983b91a2e91e86396ee3fc13a37dfd5a7114f68b64f703fc1fd7a0b31bddeac20333362c764299c63e0cbfa6125fa6f69a92fa77ccce18e6b8ee0ee58a678853ef9fc79799bfc10161f59c4be9105973e835195a89b08fe30b31a4c71a7ed578ca5a214023e11352936905fa7be5ebdb4958d5a33cbb8d98b903933c6e5f09ba6329ada23ecdd0714bc1762f3ab66d7fc33f9bd7817d9a47da5851c2c7bb3581fce28f533da428c50f777483d85c5c59101b9b76d34fbbda59612fae883d058a5f8393553486d92d157ca97090952b903f1e1a1d641084e9b7984abd277e9d39e02e75ea2fbff03a1b18d251c27cfda44fd3b65758fd148d590ce2ebea4ab9c5b9dd9cd8da4d9541473291e769be066323da02b12f50b15feedfbc6f27a1c7b10522fe47c7b6cd79123c6fe20f4d7e8c92e7c36d7b29be79b437391d659c0a6ac6516d3458516b40c5541afb81e24344200f8749eac31e03a78bd10cef0f1704fbf52ccb3f82f1f8a0c75df859c6a8496cdc22884a135e8b90696f1411033fea3810103c7ed1e778015d81c1e30eae1ffe9f9616b189994f3ffd1c9c4dfffaf20f6070ca09abe6800529f804c832547fbf8ca406abdbca7ed7aff0d04d1c1ca51854622da50f6a7870c25e92e3e5eae8a98f4fc5983c9ec518cd6fdfae2e5f2923d3283127e8afafdd50b96b1c41e597613f33d17d960a03428107fe5b79d9bd9497f79eb6150534f274ac3db75a247750fe1bb51ce8aaed26a4285135ee7007927435539cca9d7fe9522e67abaf4f0599c03262e0640be7b14b100bd42bec4832934c47f89f47ad5f82f349615200288eabe09649fee13a598a56d4fd1f47f0ccff19798242cc5b1b6f4ec14484af7ef378175273cd1aab9fbc06e4708aa28936a772c4dd2943e02eca311336b23d2b3598b58535d2bb9aad607af97bd7edeaaf612429dcbc7c87014a0c7e7ac68c710c278ff9ba43ede9d2d356ae60fede38e0e02d1db684a786e47a2fd89775865ef0002ef72d336312bad5272633a2dc99b20c5cabb07f712bcc28023f4cf6b1bdfe71a0425c92f57197e77aace3940a901068f1ebc0d9abbeab6b5680fea8ab86155f448bacdaac3cafbac27c173a6ac8247405201550037a04ccdeb894b242edbb6bc7780c0a71906dee86e9e152b1ed210edc0335c0c3fde3ccd6d3368c822eb3c2e8bbd2c3daee1a5bdefb213c469e818286eb6c4592e957534ec10652481d34c7e7c2d7c790af25c2e213acd7a6480898b1eacd522551ff4eda221a8e39eede3de6d3297ecb3d2f9d2bdb2775c800b6e3416ed88036fe8390c69ed394f30285b470e0faf6ebc65632077bc993abea7933bc8b6265b3a7720bb756b0ae177a99990e7960aae8b98326114b72530197ad385853fac135cbe21bb4ad5b95e3536c7c9504cc0b2936c2e947fd962c552c436a70453d685d676352393339bdae124b51065338a3be45c37007192a2c61c6d9556b171fb4f4cc1d0750f8d3e719d8341397213d093d00f1e5094f20fc9d7459fcc02e86cb6dcc9c0ff52184ab3153bef5ffb83ef3f8714f882d5426a2b485c34ae63f0a49a1cb561e9f4ae1e54700b284fe75498c7d37ec2889aee919611b276a0a027fd438d49d55b69bf10887b87e05b8f74b922cac2c29d2c7c7c8aedf3045b7097b9a56b6657ba988f6822154c9ad082146be2d694d35e3d6e8dd1c8e03d2588dd751bf3364887b753d8d21df87146e5b2081ba54c9fc7a68d49bb47b87419347c31ede1c8eaddf0a7f35315b319ed4e9e62b0677d8e0c2fc6513f672a6c7d8b132a5959696c3e9aa18e2886510b5b6d2c7518f97759e6c5eb48218fc2fbac6f3e76b1ef24872a53e5c06abf3219128a083e3d115550cfc76def1798102c7e95fb2b9dfa905e571fb411f7c41bfc37d985d3bd0d5187a4c9e063729848dc4eaab939b8e928c2db54612ea6cdbe5132b3aac4f404bd31980c87c59646a69f24389a97bc7ce6a7dd275002b089e467e6b7e00bcdd3b249147714a82b710685d88d75b00c8dec5647ab64520613f80e4cbba7932b45767b4461dd82ba7b4d65cf1036b8388b187e2821847abc2291ea6fb73cfe451bf4dac65378f03aca6bc6e62d49a7f551eb16e5b0a737a80473c7d24fb3cd613c9943151642b061af23e59164acccbd62705ef425d85efcb760caaade3dab9a5aa6039086811021beb14eb417abb71e15bdff2a9cc05fdad7ded8334c603a069c32af10fb6b76216d0f3ce398caec8be499fe4c149ef2c170ff39ca8b571744b8b8aee506dca2476de3c1f03ccc2832d74aa0f1b54686ec809dff876eb3a88f64d0d5714b15607826c622df936ea21e40f56d80e82ec7fcc018cfd711c087c3e2bff183fa43273207992d24ce6119560f397228e2adc7fc501c36d813c00b347ba404ced077a9540da241d6c011dc922a9eddf4e7c24807257877b5f4fc59c6f2d14f5a8443c9bb52831b9001dde2d5d81e92cfce0f560731db43850c41e24c93fd4106d8b65c92df57b7c1c7265bc13b55e6fc5aaa588847545abb85df8bbb0d3b80b7b9dcd74abdbd7d95a7080b585974879f08b7d910979b27c8d4e23b0199c6045df4655506863094398f8e7ec17305191a5db57cb6c6f6cab1562bdf3ed6b22c75acdc8ea889ac4c22bb227a3b47aae9bf0c97d5cd9e86d8ea0b368f2413fe52fbfd09603ea3384203d5d42c81299db3a7fc859bc8005082df5a338ae53213b50adcfd204da537e364e3aab8be3e7e7ffcb50b85cd2fd13a480e5454de89916d07a44b3bbcea29f7b2b032fac5ef2ef17cc1e6864f07c483696ef26cf7e7c247f23c7564986f51ff54ff719acaa747bcee5b8501da84ad09eeee40495c70cd0ad3b124ae664fe354c3cc7a3d779dde8dbf22fa1f4d1bf1af3bdd0e8cf5526b23348cfd5e250f16c3c21d73eb2e71be883677e88e6506fbe00599587b26569b84ba862a7248ac09be0710f14ec9f18ce2287882732c35c907b5dea50b4b6ffb4572ef9d28b6177d42dd093a53c8186e57cdfe3274684f46c442e869654cf28b021ec80a2cff169ce384e9feab16d9b98c3d2f4ecb29a24b494d83957f5009ab90bee977d2dbd9a8b10ab57bf54a9a53e148a487aac49826e3937024615a3131c0f6d1eddcc176b431c6dafa22aabda5817548b96793c510d997cfb19d1d6a3f9aa59550a88165a0181ccd61a8c308958d4342a0a8821ca4c37a5826d02e79a19cffd4bd43e87e43c7d3c6cd1b1e730d228a3e4ed22df2de511db00d4fc16a89626244a8f41407be8102446a29e5b842e4ed2da58bbeffb5ec67fbe5849545b2b05c22c71adfcd3c7b52510ab6a1f4d0a2e51cbacaf6c93d1eecf6903c2a72b864aa3255e0da323ee62f563415136ce23e9aabec5f6ba08ad88507d8a806f5a52cb36afa37765d05691caa7db241f03a612a5ec237870039ff2b06dac979634b6f95b219ed2ccaf139a1ebbf7e5988df740fef20c558e66db6cfd84c4521b09d2ae2f0fe4f022f28b95d40194e8d4c5a9a40f9894ea74e70618b69a11f1534ef4386bac4369260f57d9c671d8c0c921f2d6ddd874327b04656ae23d33f5a34ae5e18f6c5f67dcc0379bcbe219d5d9e22810a8fd7a430fd62656bf48fc072ebfd6ac38dedd3296271ba76fbe968375a523303742d5d18f22c7a07ae1e816e86a1a2405a050c6eca6b281571548a38dc13c22fa67f6c21faf6371f119a03260351fbd48712821e9492b82d487b3f9f878930b118a90dca6ecc2dffad1c3a1957ff71d776275f600395d594bd7f6d5c658d9d0332d7a2d8f13c2a4d9a0ebb6b8e253d390f56e9eeaa0f9cfdcf424852302769106ee60501ef7d27875a288787c247824ed0913b9ab1235571843306b3ae6d3497daffe18db401da3c9875343501bc31cee8d599242d9c2b080c4b377d8b950b43bc4f817f2dfe438f91380f5ab8252e9adb79324c2c6474d8b837dc70f7fbc5c379325a562bbbd93c2cc7c79543ef2152b2ef18af142493171f2a69dcfb74d09131a7bed7b9b41b1185d38cddf406f153a41c35e65f3f79b8a81400a7b0eb8ad124450bcb0df220ac15acf37e8773f7321899b38c598dc0f5762953f99b36c1f2075628065aed38b1177ec177f445489f5e3dd0e173e3da98af9423ab1e31695d4777c6e6bc269a32339175ac0dd9716e4e26395b7048ce9b0af78b873f413b82600718c359c5d011c15c8886b40482ad2bd37fdd9b3e76d2b75f9a20ba40b8644778bff4aa06e3e4bd289c3f985171633df5e01bb11eca4462a7bf3fd8d1309813266a4ba56b5c19999e6292aafdce126337a8ed4cb67b2ba3bc1964e360de55070b2c4f47aa29cc55dca031a77e4e9049c4007aadaad1412b85753a96d841393f4575ea4be15908c847f8b542b596fbbcfa1add08a9796e4e55a0a90ac3c75bff21f4319459f31f51849e02994ea4353f4ae1eaeccfe6903d1d8b80d1d69cfb4c975057f80d9d135a7a42f8381cb2cbdfba9803457b20a96011124650637d5223429d6bb42792d9468d86bf048087aa07a0fbbfbd4f091a73a94a922f8b7b835aadd9fa56a7caa01c3065491ff71d3680b23e39d8c51173dd31f0ec19b07d1ea2c4c721ce3a879de4b1bc542dc9bbe53f9d08756db194f4352185e36191b6a238b7e56c5993cb52feba680cda31cc10f19a6c40fb62abd07002b59c6fd7eacb59e7c30300629aa9ceacf1032419647dfcaebd4a069b9977948d46f37802e1a87d5e1dd1ac5260fed69782ecd44bc75c9abc8c41e5aeff133b344d12a621619d53c65ef60e6e0edd167918ee0ac16a2f65980b37d9083c0aa2c912cde642ef17887203a72774be3a0347b97eaab47c8a6aef08dd34f352cc9ce4426f300d9948a88e3767339002af373c65d4f4a72e58b824f2c5ced4807ae5e2c63881348f5b01b187000bd464b5b44b3a1b518d877779a6ddd7c3960151aaac8be7c0722867fabf51b3efc27a9c5ab4874148c58ee53105c32ec0a7b3d3c96ef8c6e1519e7e6269a212fec35e060bbc0bc4025ed68c3aabbb79db9a96bc16f06b98d69d184424917a4bb5c4f76b24aa52e885ba03a20937b71aa898f90a2a355f42bd55eeedd7aba4ab6b52c23cb87dbf0d58ef95b4da383a2ec16bf6932b3fb91b4d0b04c475b36da00be97eb1d253e11f1307f527f03c275d1d0f0f2022dfce8715758333af596c306e8547da4a57a7463d04921df9859b3211e2cd1d9d6491ea130ffe19f894e36d2e89afae9360953f88b4a62098b4a3454b85d199c8931124d593cae3b6008cf09ec13bab3426514fc54fbc5db77bba18a7b708dbaaf5a8566a93f8d14b7c3614ced77fd9bd394bf31529b2744f5b0684fa99affaee7e69fe45657d9ecbfab7f3e4e9dd9b1ac1a1b278b5809f66b7d5d3f4f803e6e9610c5c9e97d35a77dcbc62c2e8cf87088e74ca7170af3a078dbcdac5e99713f6b8a3829ead71364bd8d9a0ec135a309f92845e9d0615a4e5b43214a63c81135afd9cab02ad5f610f038f18c091dc3a7937000bb5c80e961e1255a4251160dcbf05ed6461e669a09d0d4623d552f0fa7b1a8e58938fb4580a093d5c64ed2e7f4a20de7e4a589b69f217829ca2e085f1315f89d2fcb5b1b1c73cecbf20ea6862de43adaadc29982fb4a69d13e9d3ffc31c2fbbab9ded9a932c8e1fcb55e0d29e2c1001a435312bb8794966224dd4957194153fb044c036f948bc3d354c5f20d44f08188561c712f5e4cd45c75297f5d6ac627bda9433749d02cc0bebb8734551c29aca8983fb2478d34cb995fae156365a2e72f487c61e532813ef62a7cd2ddef638beec59c333e7e3e383439f07383fdb6a772335776c11bc7dca36ee54fa3e99f36454ba9bdd28c99f99848b7a9f6481b380cc83a4b063c137dab57d069e531e37da2e7a40474f6e2bc71cd42779059888c52a276509af7fa4df0a5a59eaa8613cc80a71cfcae9c8cf7ada6f96f4eed9710a98954aa92694d6b9f40f66009f293377bfffa3c3aa79a77d139cae997d2bd9c836f72ce5afa677995988366fdb4c9219ebb35118e697f551ed29adfb9e58b17b8fbff1aedb384f3dca38382e22303bfb50fed75f7cdf9eb35202fdf050ac95417b9ed7ac23bc46cf0fb1987fe4b33f474b05d7e8e34aaa53bf36f72cd0dd88bbaf8868eeef8d9787638659076c19b1bae458a4c9d9b0b9973f65c9769c7642597d3b91dc1969f471dd4d5bf7e1761564604031761e1782869f8fe82bf8c4da17e8df1a600bc015e55fa9318ff79a27914d1e9f7267e3663c7c309b1e6ef8b4baa37f99392d4ff2a3967ef857bc155e2580629a8d9d7bb20f83dc94ddfd4f65514c4609721a7825ee738cf3b954f35087efa4ddfe7406d47757f457ecda6f079f2129374eafc045283d3870850261cbc48e0bcaac817c9a6dfd88c90038a5db5f7019c9d9dd6028da83836e9a471e2c62f091934916e91e1fc23047c9796025a083837b1f6249e300c36910fc26c86b6cf391b1af9408372bda10e1980e2470be1107c940e38eb1620b6c4cffac97fbf426de9216cb95789121075df04c6730273e7e9a9d8c585db959d2279a2dfd47db6f2ed9a659371067497f06e44b440f7fd9435c2a197ecf3c20e07c54285d7bb3cab6a59cf2e2d88731e527ab4cadb909070a5262252d6eadad85e9c1a9947ff3cf95af386460348a228f8fbe53936c2d64e31dd49116f264b1f433372aa5b9e119c636e2320396796079403bc730bdb384250add4903b115c358bdfd2b6855083ba8f7efc5b34471e9ea46f5fff5a717340e7d9937cfaa670b6450b6da88988b8818a6f404df5fbc7cefac5a8a80d6af9643388b0142ebfb805ed82b9a75da84f3c11d6661d93ff3d1a88b1c5cf6bdebe6169ad30e8f16ddc76f67551deb7a2970b221ee77499974aa0e13935bd27d87446974717b2049c8fbc0b1f72149c25be036dd21223aced8502d0424dc9d26151615fc24bbf975aaf6786eb30093b430ce629a5759923b69a0b3c1a64c227c42978caf75c561e8881cea6b500285ff52b3f40f4de48fdaf838371497bd5cb3306ef388f931dc20dd315e4db89c4fc973a41b5e1b84d40786606be9e919f56f8f257f2dc2248416c14c81242b29b3f3cb09952b7f0c39aa304bcdcbbee71bd3ba71916a9f08a28ae684dd3ac7a98fc27610db2b9b71aa155587a169f869b841d1e93bcd635dd211766ff480bc512c174e431c58a71d80c44e463e1bfa2f1700b1cec8df6b2363cb33e1498e47b58b3f28eebc92fc774028405f195318d48aceea9c7f96a2a263c9e0bc102ad6cf3d01a47f5e2bf58e66d1f98cdf8456d3eaddc0578b82b6fef3d1e3b5040d46f5183c6069e9f9e8fa81a24cb1526520bbf9d0b0ac0bb29ce7ffa9a54d73691780cfb8c5e23525d621d5b392b4186fa6ac9bb8d81b4e43fba662c49425455abcfa84a7b73b385395859d336aef53a5aaceb0c9b2cb4867496bda45cbbdd0acc6535d84173ee3a7416ea1fb9949b428ffcdf6a540b688233470e409589d3fd678f999d4abbf333f0ac4ac7b932927d42d630341e418750b2999b6a3f91f06829cd8ff3e040f201c21d3741f1d09b07fb56aa277a82cebd66e0b18f555a02bc32a645f49833faa41e3d9dcd6f2fd1089a31c3342655c943f63145407bb2092fef15f774564dd569ec4676ae8f5cefdd8694ca1187849ee2dac2a2c9707e8be094354e06fe22ac280fefd04c9a5eaad57f3d5592393d2d1b6324b35d8984d3bc0d827e467861fa76247153dba36727e20c8a1bccab1b148cb35621cf1f712e8aa3db9c9099855b8eefb4d4e13354a7333cc0885b110e5b751e76ad1475fbfe7c0953b7cb42d61609d5abd49c1b8e1449d589bb16ca575b162cb6e88b0e3b6aee8ea2c52c4f21cffca69de655117f5b393340ae203c67cc6b69043042079a645028fd864712f7682ae243257ce7be824b9a9cb5c15e8cda18bc7722e3010cdd708317f25176433030294dcc64ff55acf1919e1bb264b74a5e042c5f6455c1502703a997a9c818f85b08cfd938c399fb8c224c69babc007b02be0bf399ceccca6a83b18a50bb34a26582ee9d57c89536dc10183575c11ce27be218fba6e6cc9e6c25c76eff000e08a43f24ee64a10673753cb41d3cce89bd0e1b96ada89a9e8525eecbba92151a7f9267d301e33b9be6c721de26cf8214c54f4634cb44afb551e0eecfe57d31c9321d841845e556ae0db14dab16722d0a826b1f12dfcea81cad3e6af3a57a6d756df47913bb5f97a278d3a5ba2de39ddc977781bf0a1e1cb95e413ad49ba5ba642fcc84592924e4e45b53c0221a4ef4c9033fd49611b04dbc51919dab1c9445b762c21473228f75ce46d2f5e7dd8a0f07844d906a0792bed9f56e2b3c3ed1f768ad4b0d6d44fe62979fb18556eef0517ebd6aa9fe36eb932a3fcb0e21130aa692daee3162cb20cd82b5eafa7e65a2e5f6c044610f4bb090420a93e6ace4e32fbfd1512f323fdc651f75154b9fdb4a5fe9f9070ba6f0bb85a96c85b0f50c95a3c5edf1fafe00c21e4170410e9cce26596f4256db00b65b62db651edc3a59f04d811fea407bcd5c03336b91e0c8bb49d8a3052c26b535ebb69ce9c0501faf26ccb1a18f0450144e7f32a6e8ca71a9ff172aa3e34a3d48f3c5b72e30bad0a37ec6e58a5e5d65604eb114738cebf15ebb8f489fe1bc49f65c006459612cff0d894fda66207dcd2776481dab53c149b752abfe2cd51f10f3bad8ebcd5590cee7b1775b82d92fce9da7b9a11ae4c486749ef1842ce6d262358004254292f4064ba018c1d257874637016733f7db2496193b9288a096f964fda8838761410aefae9d526f1c062c6bf50cd7f9f946b3318c6876e062d0ad3288fb6e329dcee9282914cf9894adcfb5ca2fb0c76e672ded4dfccd3e8b6a3db22dcb94b60f1e5b26f8588aa09f0e5570e1b95dc228205e99361a12e0344dd38788bba9c9c538bbddb899af1b081c4f1080806bfb248f6da15f5b072149a5a01d583595c3a2a5914f6cfcccfec1de2c218d6448fd7c7ce14576ac4b840abedd06ba7cde7843ba714080992d582ebd5dd09a136468e41d78af427cfa1cbce9ef73440918621ed6f80dcbb15c8ea55720ed77edcb9732669a9ca33a585e94037a0fe924b968d98b4ee6c63f5028fa529a787fa9ebdaad8ef792ae075003eda70c21666428143c0d24657afd6123fcefa43ccaae5601886ebb9b989442201e4099b2b16cf836e676b6a1e6f17f68b9f9344adfe8945d2e26f2b26866e0be65ccf49ef02b07bcccc950cca400661d07e53db4b6d5f0467415587c869319f0fd6fac41cee345234921e2d82911f99fc2c5e2dc02557193a07105445fcef9ad3c15161eadc3266889a1a3817e0b522f2acfab98dbd9f5a01d7d6ca0a042b7e007f72ec65b8e43a28d4812c13f2082ed8b4fd08a45f337bf3cce57c7a30a67afdaae607fd33f5d11f69183473d136aae60603ed3bfedd1d0ecbb9877c569c9af3559532bebe39bc50d701eed735b73b5c3fa9b07b4f5ed605ada87912e4cbf08e15803056b34082be90344dedf55dd5a82405f0f1bc84ba8f17023301e6c19cff13268bc7fd40b8ec2ebf567039ce3cf442b753b104baaf6cf33b9c544a458c30fa21c5aa8dc689a6be5b8a61866d3043fafb0edf6865bdfd9b1ed43b81896121d05d062e341cc74a3871ea607aa14db71bf0fcc5b959c5d0f982f2d1e600965c154bd3cb589ae83dc74881eb72aedcfd0397dd62c7b0f68a2495ac4a3e90a4c893cbd4f5f930b0a88ee411bba06f051783c64740295ea58a95c0baaf8b3cbf946e84c2c9c088e2fa99295a89d91b8b07fa38782ac19993bf4edb7c02c46faa2955261bb25be51e1b896aff1cbfc41955f4781cf9ea80e98bb1b5711e9a5b1b9d5d0f77b3556be1b088adcc339aa1107e01adf755669e6ff20e3eef6b8974ca5ddd857a73774a3d3c84666648b11b4a9b00e7dd6abc6795c08a8427601942f91d47d34aecaf251e3c825ad1bdf7c2184196ac49b02ba142068e096e2f2cc312e7d2071fbba11282fdcdbec22ca9d91f6c02b29d693e7980b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
