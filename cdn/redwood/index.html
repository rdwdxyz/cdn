<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da812d7da2065512eca5f059977f670156c1b3fe705707d2985faebb665999bceefd8f5c45090e39bb5631dc98f274059ed17a433e2976557d0a9851b20fe8c18e5bc806814a1f2c30474c8765095c82caa9c910cc7ad027978e54a6851225ed2cebee00fd583c44b6bfb0a4ed3c4fe1b286bb3919d3affb33d2ed23415ddf43b1b951d154dd39a98ef06a6dd32be3475cc08c5aac91df9d47b5c7e7f7e0c29db98e77d151205ffbfc5744d020423a39a9ec42b59de5b8bd6e6a012f85aea9543ebd30bbe4696b6e20ab43c218aa8bd47a88563029ebf66885d796a3ec48d9480ab1b7e19266c6c952be7a95f6c21fdede0b6d28a4832b12ba48d315ed53370ce311ec5be2de23e2ab68aaeceb46ad921e1726c8d36786ca60d3434b0dbe9330b030f520d30cb0ba975b1c546eb392a66846e028673e3f25c63a8be405f16f700db599d8b6f88b1246384eb45413dd324f2d0d70e2edb989764d3ce5b8ac557e5f15f90f4a8cea244f6e2d80b0febe7cb39a62f371a089236a4b9229000f3b46ca671c2bcb6bab07a01247b274018640fca12c210793404028e89bf24952bf63da45cd15e1828db4dba2b09ef8d95cc9e245e2ccd6026782586a9bab9b667332dff070f374f58548910e2162878ab16d5d0742c6b3677bed0c9e2733bae4423f79f0fec819290b65974f8e44ea8e8aaf1a517f28b2c987a645e85eedba488901d2beb4d35488eb0ce54f2b595581d9c3d2134b7b4d093b898757063a76c0266e3ba6dddfcf400b35e2b77beb8e471048a0c35a6362360163275c9658855e64f2f9f3e50b91eb735b734f288bb6dba818af79ff6388949fc3f886572251b7c15c39ba1d5895bf1e245082457756cc22ccfec615874573897c058e85063cc4a96cf9f0f4a2650ae13ac9be5dc0f4f4ff29044adc239db989a938a3a051a6ffb5a8626fb6db0edfc69c4efdd0a7ebf6ce75101e01a45ec61d8607f6f18458a06e05cf99f9e358d292b990e32b33b04029a923114b0dbdc298a50cdd54ae19d907dd549d2c4942157f5f841cbecb2f5067f80e170f69fcb4602474e8ab7293d1cb94fdafa29c517e4fff112187a890e4bddceefb3ed5c2e907bf9562dabd15156bb85b08d64b4de7d77f8e86db17ad4b76360c609914fc3d08d1d0fddd35c072a06f94953b803dbbf861f6f6bdce0040a393f1ece64751a9165e6e2b0ce5739b283b64f72ab5686f5a647bc8b4ad50be0b71bf278368d6f05121fb2ceaed539e728e0f2f8dc960bc3266d2a7274e2b791502ee802707521a9a1dbacdd3ffebf9a78cc7f95f9e7c3698d8eef674d779a410e90a7e0c2f32250a884c323025ffa49e8b6a192f3f260e6a826d825597fcc9420ea014a9941895f0eccd3837b6dcad0f80275f96b01d148bc305aea624c0aa1a706bd1d121d3195f7ec70982adb2f33e6658c39866f83f773d9875b04d452dc8e64ce67883649f6737ce54dcc038f661b43a882332703c4f09ada471a0458b1b4cd4bd8f0b79d51b28b29517e000ef53806f83a1e091d7c7a29fac79032c6258968399a8890a8b3c09390e5661ea5cf56a1016234b334d174070d078bd8e3d12f22e600b0c31f2ca853fbe8fbbb24dbcaab327657ab9091add9bc5c1a6540c889593fa3a62131c4f236e53a106125dc719f71f47a85c4ca083083f33de0e8a2a739cf80bf0e4b0dd567e054df30141bf197d5aa74489c2d85cd2ca0701fd21ba2aa65f706b7b23dfe2caeb0561677e0b5d221426a998998bfd8d4174bd730e229507881d363795836422c2f254272ae2390d5191ad23f86318e6eebc40143e51d6bed1b7c10b78393993ee31667ecc4fa7db3ea43b54c750113e5a296114bae30c5b06ccb23d7bf20bd16fa7032a162e96802b8feb9a30a26cd8a270af9a54ae7c9e4d0e81d9ee5df7c1ee5ee00362b49fe835b2c8d61bd9ac0052be5a10d101aa611ddf712233b2c18a1d56df46ed988e9e8ee38bc6b6012207759745b53480722f2465e021e4726471533855e86648389f756d8db6e24260c4b208c873773e4c7a79dab5b7f2b5ba7210a4d25e2c3c18410fd937e44a93b14b3d0034f604110e0a04c8a4ec0642e5195395d65087a38a11b5a4d239b84b41eecdbff4110a2f6a341d348314a5e8e7a245831863fe4d5a659aa5e3978e6dab6527050d413aca7968c0d2122a8f13658d1cc20ddda8609138760869d3b48f76a69055b196aea12e5fb2d1f22e3e500b642659dd6526e758c76efa140b8a64e5ba0eee36ce6ebad5ad693e971c9567a3f8582908d564d59849cbfaf2dc53cdfab1741db428314a7e793fd9ea8cab7f495a61504ae1db1e5714a814c46988871ec3f018c3d80268e24515cc12c592e95a69c74384202a94a3ecbcc1c9dbd7c6231b5c974636d0fb946e6e137f010a5ae65cf2ad4dee199d142b673ccf267e3f8b171dae5b609e69d352c1b87d342ccc5bb6cd9ee5bb29446893e8796cd9926593163ee1fb6fe3f5b066e126ab965e7e2c2d9099e2b5c7773731c6670dc131a2d993b19b87c0a6716d028f134f58a7bfdf519bf213d63728a256859ba46ea356533716a9079a43cb619ce9c96a524f156fbe8684fdc704c954d5e4cb1a5e491f9ca09dfea2c74d1b703bd854cd1bedcf7e812c0763541ccf68586c82047bc978702ecd3d2f19982853ef2b6954fb22c81933ab9fed23eef03c5657371865440ef738b85c655b8815c57ddc68c75d6788e1a4ab6b5b8b0a0709bb73d7f4075c484016033529860385a9399a1ade488efafc664b85b877b2e347d035dd52bb6482fbdc33f7bcd121c9c965836b34402cf29f4124ec90f6d50b150f6982064457fd0f2ce2a374e214074921593cddd4533e78e01b25c2d43a5fdbbc346d2c13bbe1746b71684514ff98d6219eadebd85d915311ee0699cc54ae7c9355ae3629125d6e441c6350d50628a66a458b3f75b601ac9699516bdd05be823bb72b3bbdaae9c91081e7bfff9b29f24b8df287cda2211c522a3c236681f3787e085a877c2b4a5909477bb418a86dc2892bf6ef327e358c87b123cb58c4689048952d85a45fc33f6319ef675f1ad6ec2501699effeeafcf1aa39a3697519e2e08051fb50834e50b1b82ae0a65c1361228ff6719150993068c49550114a8ff1629f207ddb146928b67c961208d663f339cb8b33651d050eebb8ceea41618036aa3144796c9620c6f0852d49cb594688431819f6aa35c6cdb6136b62f4678b44c768ab65c9c9454d9fbd934a185bfd531c7c1ca25723cbcc9089328a39737c64fe2f5d2d5c77c50ac993f1c255a884a45c27a2d880cd8c48ccc0a822488d408383066cd0b1f5fa1373cb8c1e3f2f0b0b2046f98901e97d6df22174db6340a83f143ec2b74a2fbc82f016c31c7cddd7060fc2fa0c7821c0f950fb8ed872b58d306d3ea4d31115ee1670a92948935ba1591d3fcfdb9ef88aceb98cc11bc679d2321b2ec3011a5bb5b9267d013a7c447d23c7ef2e8fa9e5766e90e081447620d23235089dedbf6da5fa1048af69d9152bb46062af132b0199251853bd4ceccc2a16712a7a22800ece71f9f26ff79e1092a02cbd3a974e14b648cbcd67f502e4aa3b6dcfcd92e31710f89221e5f6ab1efb4db335e7d10a1c9a36b38a313f1c0afaf62ac86a659f4e0170c0f0404b02b0089bf6435cd0b908af56d0beb67cf0a98792939cacb62b20bec21a2dba0ed074f65275bcf52696913940ac4be588581ce74676936d210f6786df8e7c25adba0a21d652ff9b9947a3d8a0da037290f9b8ca9ac8864c2bfb18954d506d7437aa8a06dd9b427c7d95d2f55fe7bb0dce055963faeab42d8a522fc3e374564a4ebc4f80d497e2d9e1cb2fed76caf66dfe31aac3d6a545c1e804392f615ef532b33c19e424f8dffea0d05c0932b2f9f2fb8bdfa5836bce3b228f801d66f085a2e594c71b97d8079b29a1113eefe1388b506518870cd17db69b0cfeac8a8f17c23cc15bd5999848ee614561e189a211dcb2579184d2ec54cf03f5b49453d7a874afc5d0e0a310932d5728b5bba6c6e2d37980d70ae429f1b92c55da37e9b7aba2971032e17bea63b50035159a0d605c05d48f8b53aa57af1bbb27a939792e30b229b30a784fe5e093a552688be01c6d8e9b653141d0a609bce5fadf6e646dced6aca7be2c23f7df9e9a6573b03ca26f16d433268df23bcb6626a2a6a6585a885b8009cf5b61c68ee87cc63f069d3d12bfc5fed643b364ca4967a18ca20975f6768da690d3c128bafcf21d4aaf0415dc9c0320d170efae35f556560bdbe31e07df95872db3acab1b722a652eed5bbcadda6fa95f3707bc9c8f72262d7ec4913dcced2b4260a1f697c72c6e32624deb09d7badbd4b1c569b6bcc36a4e50e45512bc607702a0b305ae207524e6904cc6ad947fafd8bf3a28d90441cf8cd07ec986de1a0b22457af9296e1e18a2393c700d40710380d63a40210a2cb63154cb8d838007684f343f26990aaf6b50fc090d3f0cf07946aae37e391141e6f4fbf09066bc60620a2d38e986faee7193c2819e73072f00a536b694d59b0b0a6173d3b0febab08350fccbd639aaf1ac1f38629c6270aade0dcfb5098effbd699fb3988f3b8059c9905f097c5a1203e6145b38474e39b001664a77cbfea694d6b9a2177d4144b530aa0ff7f2933078cfc59a93f5040eb96b8e87ca7f5d4f0a35942ae2366b3588dab416ad98c580bd12c742d039f4d8b7b57ff61fa2f05267a68eb687ffcac433b5abe6a800192635a537d2f7e1406caefe730357ec1027ed43b9523b943f5ab0553a3d75bda8831d031aff412a9c904b01b7d896b28dc793b3f1a14d6e34d8cb9ef4f190c94bcf4c263f0a29a3d0e6f79af234d280c5715a6f631dc6e2a98265d494eb2a2518edd86d5782f2e0944fae5138a8c952e05884483060b6e04062b5535d0026f368fa89c04b33e1f38693b834ef8b0cc75a49d1b3a7f4f4dedff79491bfee36d1f8e8589df46760002a99ca6b620b7a5fa98d16dedec3d579a86aef0345eebd02c5c5961393f64aa5a0c11c327341b2c26c78ce8cc7ca4534ecb4e5125342c5907bfe220372d698b83daf8e84d8c9925b55976ec2d94f8c8f10d41c7517b891242e5c905f2283a1ef9963655e8964ca265ed35b7e4633819898d82f17bec26b31e8544ccdc0565941f72a887a37cda37ca731cdecc06b6c7677e3223b485830cdf6c668e771136a69ba87361950944994e7a148188a1b455f4416afe8e55119e80b96600b9be66f7750717d55d1b6ce356a0d35fecd3d9d251fc1c0a1aa6fe80702edf7acef15b7c90e62909577eef078a13765a442b8b3706e0c3dcf18e79f9ffbab89606bd26dc6e8af9776f7db97a6bc918b070b18176cfd52c2a38dc078dfc8e7663d501cc02a36a6ed806bc171881b99797f1bb71289126fb48731b93c58751a74ee6b18edafff9fdb3b15983c59a5fca086b75e912a4b5f33759f429bf27cd3b36b7437e29e2f01b15d72788b01c78fc849b1233ffa47b7fa4fe69d5deb328ffc5a2d77dc8cfbf200495c3c82ca99f8cbc1674d95e12455fbd075bd716c825fc136a303abe3db7f1b84916a96629e3d6cf61ffcfdf4315c6b9f885ac211d0563e84f82f34941beb6b23c8a622a5666b22804dad6d09f19dc2d68aa623723b35ffa74b1e53cd47402aa38541c19fa0cb322a4dd946491346ef3f45db3a2e690c0770faf61a166863e1cafa11d68e2e2742a4422ce899c44f8ae160d709762d2e243eb77b1f64fc3e7b830be4a1af3ecc35f916d3286117359df734ba49e4760845f7dab239a75b49093fb254bf7b1669576ad38f4b03b72ac1bebd7678b178ab8842fd70a5e8303f6c6af0817b41aadfc6f394bf92161724d3a3e722e087f6c0528d4bbda8076290243cc94a4cc28382855268e74b00b0c7ee74366c9e680cfa3d9086efb5da812d9990fa7b0e4e3ac8f57993034d422b3bc9cbc1caef2848b202df91ce3a9d0728f6e9cead8b1cd92a3762f80abaff64d1fbb4d7e735f973cd6ed0b483da7ecfe806b333b4003dffd2fb5c36a04a63298044c749ff4363392cbcc6ff99c3e9747ad5a74f8f202f0879a35fcdc132a4d9b8a18d2bd8c5b7a2276bd1cee7bcbcac740614ca39c5c898a7e488839d2477615aae33c3745773faed40c93c17165a8c0947ba566b0de371c2e94a04b0a6d023c746ce4c800d2c5422cbe9408d1103203010d4c5484b06d73080ace248ffdbfc73eed34af5b9f6491101796e0c472ee2f8f1c4892943bad5e918a916e4ddd2308ce89ae4990bc9807a219eaf3ea6cf9890b912fbb4f2cc7813997af75a13ba9bd112f6215c82a8189164ba37174a65d2a99a74e3f07b9ebb8afdaa734f00527257a5a04a0ffcdf6b218a08bf22a1b3dd0a9a06201c7a44b88de86fd3945ad58d4c3f15e2c67443d25bcfe933c3a3da1e76e5654b9824a040a7725c2d923e7b31f275bcbfb8ef804ae73cf2dccbc37c69dd35ac7575b7f0582ce393ee3623e9cbfed863e8d8da182f4c994fda5e2242f366583bf95a927e8a1083d5611a77ed67e5536a01b557185a7c9b16d45cee56cd81d1498890936853dca57f8eb75cf3ed272367bac501c4db1d4a4eb6b1a9c52c36827a3e897096cb028206a2885ec49e994e78a2f081ccc7ba6d37fcf66b16581a0f49392cb06070954f835d4e3805c69d931e7d10c2ee29aabe57b1fd1a3c7ec0ac2892ecfebf7c6ca31d3fa88f73db1bd4dcc760a69a02966048962a6ba7c41d353dc810abbbc3949c8cce7725667db954c2a943a43ece868f5bb8b7064133a652cbaefba7194006a5eb039ad65282c05deb0070e6e5a01db7175414e00c156861e04ea398a233e075c01eaa0ae7cbd85e2396830df87f8bbd0f5402c2fca2faa74d0c8eac7cee12b60afc01ae6e1bc507dc6beee47abe921cc6d9a16a0e4fd699b478be0a8e8825a63738f73edce4123b7f780ec93314a160768039dc832cd2582784e30e20b5b0912979522a8f19fbdb9074f26242b3cafb95f521ea8d270b98eead6ca46cd26ba8b0e1ff0feb94a417d5363dd9d5fe7d68b0ecd15fc11dbcb1707c598991a1a1e8edb82c35830bb9fce818035b8b834be384d45fd615858cba608eb5bb60292928bd85ea7e376a04f05ce267664eceeb3b5efd11b66ee321a25b515522a78d4804e601d4a306f5e2f0d96b55f85f20257ac06290c510759b7f3d72f8ce1359d56bf10181104a599c9852fcb1f109783ed92d53179f4c455a419729b2cffad4fbe30ce468400e6121dfe6f4962aa01244fcf83a0defac57e2432b911acb75c4c4680f3e448aa882ee9f984e85c72c1762dac195b4f95b2d0ba7dcb78e83ba48b2776f05f9bc80962dab87bb5f531d486c7687d6338b3459a95a5eeae87e5840f971b579847dbc20a397b87ca5f055826082a9c74648c6483e1591d3438c8709d5c09b3ed8e35c40bcfddc18fb0b0441ce0a3128e4bb07e8bca942b02985b92583883ad9a6614e842b52c11cfa351afeaeaf024010a9aa9012f4f72f72cbd603525551880e4bdd0a4a73cbbc2d43aef94d879e43eccbd246efaf5587863e25942d8297545edf597de69c314785f26e82323938c50aeda19958d0b0922cbd52d79c15e33d8518ba61cd34eba0c235ee69e7632b547b78869366ffb07760dddd6879b525c144389fb9042dfed42c10ebf1c1f41235d5e2d6c9a14b9d04e20185e1f17e5dd79a0f2e731b0687d81c5d3b933a5f6f8947ebbecc6a0c7524f310e57118d901a945d6daa85db53fa66c52b716c0c3e3f7503a5b00366bc79d1c6cf3136f5b07a0c3ce7d04183f2698b209fbc8ef2647d67188dabe377a3164ea01c726c70770fad53bf398880c3df85b07681baaa7479773e3da94f212feb58e1810515debca0f53a15c16cf0c3bc53c8b2e8f6806780d55a1882c2f1958e2529b061ca1bf840793f5051e6c3f1c90850342fc23e8ea69ea4123b13e250c6a13116ff04662854a73e51724575ab14a82b43268a49d7dc6176ccc6398d4ccbfb071079662be60ceee2ec98c0a062ae9267da653ee2f0a963e247797ae2deece35b6a30af49ee7e69793d743bb91faa951c2d154cff1530fc0f09ed0ddd8ee6f15019c8ba4de77f633cb22e0276848846b16640dad9874ae4c9d62e8f778de090c93d7362511457603524a1d36e6b027eb797ba4c27e6f3d8490f8391472097cca429fbd0791354c30857e6043a0946dd88e03a903a3586950df03918306abdc72bf9f7c2c65e0337c6d23bda091b44462538dd647b74d55c4e3f872e6bff38a496c72cb05c31528a58bb44d74b85933f76244d979c419bc1e9c52ab398b17b5800d360a84a062b368698bd87145a2db069809ff5a05d806b1f9204afdff63b87689616eab13cc0464ccb71900d94cbe2f2c817f23bcd18108eb7d864abf13b20c5e094a871c62d4f1128b8ac897c499fcc99a6b0594bb5e64f3c7f84e06273a8d94f9d2bf973ef4ea16ad6bef0f1edc73a0dda4c1a331f3b250d37dbb38ff92497312b89b5c8b537dc1d807107ec50b9b16b54da42f3857865d81dcb7a96d7b35a5a3475e65e672ff1ee251b2db37e482845cab86433770c9ff3c7f297642fd539c894a1259f48f7b6aa2fa100ecf806f70ea227fee9668b6726c925160e53ebc0b197f8bd5c5b32d0939191a15ffd6986f8c691f97ae610b0abc696d073c4f7f77c0232e0655feb717d4d0e473c9c5ef1d81c86a132491e036ee9aa7d7f27e4589b48d9c1eb3a0de8fe5b906601774bda82d447cb4f84da58433977d8b19d085c53347148e3e6709b1b3dad802ed214ca615cac8224b6e3ae488146b00ac7b88793908730eabbdada58f220a1ebc762bd4818e25fa454902482cca0686fdfd9a9dc0d83af617cbd619c0d871e6e6e87be947de9ac55e12a7d1c47af5e3b64fa259728bf2814a7e1227de4d09475fedf1405d4f7d075cf08ff4252031432d6eec71ed18392f6d386831edcb36351ff4a6ca351f7325fc6508cc8a5233ca308f80c8539ed6da2163db433560879c9d7a3d557b53920d073627796118be5e39128bb4d1b34b2ec4631b15bfb4deb3d7ad1dce3fa408d17e37d8c78c29d65c099c74ef34a13574ad17b3169874e2563effedd1b28b3b3c9f49e32d33383c518c05e149e6bcb65d0a18a06c131f3d16e37fb4f8acb975938bedadedc74064724ff89071d81d00d4435311eb885991c546f35b7e37c01cf90591897bb679846bbe0ef42798eba750b99f8804ab5f600660e5b84e5fe34543922b8d699c284f4c6076d14a278432edc0badad78babd0662cfbb82e3d4b455caf8f12cad5f9b154eb1ba3bcf2949f6c51afbcec8157b780fa955411b993ab5c2dcc3baf3f4bd41f12d3d59140d2eeec367610b5a9d6120f55b076020fa97221184c5e68714183d62b1caccea4f35258646c211deabca728ce6e469b5395dc20657ea01e3f41dbcb21f9f60b2c5c0c2b9030e05db44c67ea5f4574ff9398e2c066891e0ed03db9abc85602cc643f252a732106cf16b95348c472cb97ecff0dafe19c26503d914a9c6b24bf6b9a0b9e2cfde5990f8ecde7a64696d077e70dd2837dac5700f1da02c7939fa22ea1ad45b3b29d8dc512438509babea93835c271a2d388b413b68ee731b26971e7092f7aeadd9430e2a7321cf725fc51199bd829fcfbe3de485cfe49b35b3c3481c89a31d20a889a7372aa92d2c4cbb73696917bb8ca0287a1e45a5d56c45b954c730466cbaaac2a413ffd095fa113fcc3781163ab7173b83921a7c650b19fb564a151736361098ca3e8feaf9260a830f4d1f34ea55db2842b852edef84d997b540ee7b65af80fde8705c90160e838ac5153bbaba9afef78ed6353c9b3c2533c5d09df55f327c81e3a6082802ed1081ea8a22ffb0f9d0fd184fab50dfec15a7e7cf4549bdc7b45f4a7622c2a0c37444381731b942cfe5e3b5390c59e023f26b6f6985dc753373698042875c7a8a61641fed227302050701d2bdd3dc1ae309f249f0893d817e1b83a8340d9a5b66ab311247d9efbd23724e58ca22469b8ad3e68d29dd589ddce141b9cc230a5d1d1a661d043708eadc6ad3eb59bfd2875b29f53484484d6847ef38099feb74b8b7f7ac4e17a366dd1d3bd369002aedea80717581c4b52c9fe04c2ee72a46d81e3affb5722782b5a2fe6b96e746fe5d5fbc16d5530b36d0ba9264586331aee4e3dd2c7150f8fd454ef5426ee923155e878161ed6012825de319b100564270619de189a8d4af79e54362451280598adf11eead5e76bcabb4f43c07a056654bacb179e967a772623da0c93d7beac652aef0e3091bb8d9990c685c0870d28ec279d697af038f4c7bb94bc2623682f9e59b50c7f5fc938ad4fc008c44696f2edf0baee61881875bae0cc28bde1c6e9dca3517b9c9b219d58acdc239554750d5a15f06b299a9abfa6c9bfd40c8f30c1601560770e88a4a82e2b1729de1a2e86c6ea9f767a5c55e2509c3ed138c0323d465175009ffe4cb3d7eee1a582311d258c5be1445dd8b34fe436b1cc5b55ad7fc0e30c3be353d376740c276455dd927d712d23d9e43c585bb8b302851b77bff67e57260fb995c634f73cf4a33cc9f954e0812d3f86b1530813a8f2856b132840e323b5630c89966a851cb76f0a7169f007454cbbe3998a58ecb8eb66e8465eedbdf6d9f58e0339f34659555406f8ae2b589b7a22821846be5d91a41b23342651824de31334dc13c7c1feea18ccbb3a34273c867e6d702e93507a8a79a90bda68333d474a4922cb47beb57a81c087de85df02d758e52906c7f5eedb9257c93774d6b2aac5e80f914d4e9371fdbd43c11954d31309c3f6018d06b27e9201dc3e76a2809fce5ee6d5eb1843a40b8267b696a2a1975d06a846be92f865f2e3a0c9ccfb6d28dd3daee6c9bacbd3a033bd2fabcc56ce4beb4cbec88eb52bdb0fb209f8313e1b870814147c749c430fd1f77f83d5ac6d2e70abf8e8e8294ce857b37300b06e0ed554346acf4173f0a7d559f512ee775c717374c016c69580e21ddc861cc84bba9e73005df6a3a22ca44ff4685f11159803a4aec0b0e9d683642be30d8dddacb2a2a2b9e6fdbedfb953b5db12a7d89acae995bf2d2b49ebb8b45a59a97273fbec72aae62fe70a1c4af6215967df3c03c09939c73436e7b16d88b720c8f78b431240b7b6302b855b3bf4a9afa958079c8d54442043b093d968fce65f246e65863e84650b3da4ed9c0475222b0640ee5daa8bea047de24097167f8bf33f2cef150bc883cc5f93ff1923c9fc24de19db4d204e2d903a015eb048c0637860260706b7764ecea7193cab4e8e38b1afc9098ec64b4d1fdf967c90e55be86b39210b44a78224b0a3a5bd83eae5fc58c2d7fbfea1446dc079b54aa3d0de71b0a204629fbc552df9ee3ce07e3127bc5e519c562641bd5256d02e4b056acfaa640f2c696a6f3c9e8db7bfc108f5958193e7e2970961b5625fd7c2417f5a2f0fae38a708e87c9d83dca555e61e84028b99655276a87ff4331f90c9236a4cce3d31af7f3a87ac2e1ec9f5140d2089e24b75f6540e8a793743323de682c2a77742d7be2a4e3b0163e20f6ca7031c46e82eda9b1ca94f4e7fbb13b77c2f1d8cbb19856116a0cac4bb8de50f726675aa05cf22492745796c06ba043b6b5bf1c442f11cdf43baf4cb7331000dca0bb1754cc0ab29bffb00b6737f76489368efed181a771aa22e0f112488f76eaca85dbea0078650055789f2a23d7df0ac18ad5d5c6db353f1765b2e770b0b848191b631df14237b5506fffc54d387b3941feabf11889ad20d6d57393bd403a148ad69b272af3250dbef7a1f90667b00a3704408eb6b810180ec83984db98f6a05120301de92949e22adce3c214ce718164f92631dca19e5dc9ca6ce3217561c21c88431ae31104e4c5e431182eed5565933124d8cdf9327357220a0c6dbb278048f9f3700af8f19244702a1de599f75ea2e9c542505453d5819e8306708a45a59123226a2356fd99b67ae22ca7ca8ad5cbada772292b6a0ae3a669b56577d290f29d83050a2c0fa99bd189427e180c8af6f7c619dd036cbec869285222b15f41964c11761d0efcaff4148926516e8272ee6a2d77413d4474db20c95d12c209cf3c23fb015b3c7b68276b54c282e2a324e4946e5f839701ff50f791cc2d9d5c69fd7fef12a5882eae2e28648aee86f4a71f9ab0a09865d7b464a92d5967e33e50c9ab22c38bbaf418e4acd25ca67e5da2cdc23a23fd6b245f403fdb7ce86a3da554e08bcde3a1e61b53763ba3215dffff85509a4a70eeb8734987d6dd5047afe8499b0ed0277ceef1375eaa342da3aabb12debe7f9010e94f6c3957d39c6e3c950ca1c9163293ebaf7d83cf6aa394120a4d9e902a4f8eba72b42034563fc454f13cecd272d85c6e179891533d2348547d6d09e35b768af3fef9d1dcb3ebad07d62a9db12c7a64637362bbb6bec8b40836e227a3e1de0d079c9811d0ae0c3da66e98f7ab5edf6cf9d20464526981bcc5b57abc79d6447243ef7340acc6e5ba33257eeb85a192e1c0e3966c2b31bbbc2ff5df60dd42ab60540f34cd9c54e4b9b33c196aa67f200fcb1a768b04d18791500f925ebfece4565ffd1c8e2295cf18928835d3b655a5cc13290f20f712972eebf1c033c0c00642f2d4466a74537fd2ad4acf733e840c5e7a8ea42d05e0397680bfabc42f2cc8a1fe814995ddd4fc259a9a45c51d9d362b50df83174052e83679397d37f3463650b1f3ab9cf4ececef706da30c0f49a388b37098674aa9b3311e067eeaed22ac87208116a05b0ac26a627af5da6a9917afdcaf78002eaa380eef0da709640fafbdecd9b434f3366c5901ab9a7f4a80ecbce05f5a86aa980b8aef6b138231b738703d123985a81f44fc24fea96865fe44ce920653e17f1a5a8da2627385c5be54693d81a56cf43cb4e6f163ebc3cbe968b17d87ace76016cb1662cf389d77c281919680b0ca62c599f564fb61fdf9eb219ddf290305627205ab9a58fef283ecad52b0ca94e7637b4459c7171ebf252538684a93cd802d1a76906805eb926e14b6d390893095454df9f0b34ba20eaae9353e9271c8595e4268ed0bef52850823692fa1871fb099247b51c6a0934aea53175ddc6738a419ee7b0da1cc93a3e675cef8d796aa87d8dff18b9b26373b1971b54c9b1e07cc2b4b9942d2d096ee8f4a46b70c7f698a7e645f3af70b8469caedbcc70a2294efc1abba8392d43b5dfeb6bfdaa599f9d9bee67d0e69f03a619a4a5f1e2f1f049053bed1ffa3356cf38934b563ad53bc1508224ba4f836e5ed72aa48721eef3e0f548b83e68a25f12f601fe9369ecfe541bbd5ce7e02968489e66a0f820fd4366c2aa90f1f072f43008ac7d4d55065437772e69418620ab3d1a94abecefed7b0b335356e93614cacf503384bf21db48dba5ca562a64a73e78897cce3f35bd182e9dc29d479973ddc1586d63185679c258e3df0c2640c7a58326d2537218f487c0cac4197a14dba4de043b598936f6ee8e876e6f79a953da6ad32dd4275e809bda8ea4229d1cd61306dedb3298ba86dea0676063f2734f1ff07def190dc8ae87b79df95159e476bcddd24cbbfe2cfd01e39890c83d02090c913c6f6fff2f95aa7235c2b3b739c044630553ba654fe30af71e390e62c840f591f63cc3f308205c651b35028681cc581bc5f743b38e9f35bce9028e7a86920d3cf044a652543bda1fe83e9a52c52fc3e56f82fd62241cc0bba52afe697675ed1a078547cebfbedbc6b548c2e23fc5a101fa1a5156c0c05ed88107592f0276d86b9649ea131325ca5207fa6dbfa25230c13a7cbcde1c310ccc35168456b9f57d140d0b75ea058ad6517233fecd182f142a6a987dcf1f602aa1bb5cc71dd0d90e7f6450144933e7442c4286cbefa8ba735cd08914e1736e41cf6f018875c7551520f9311e171d873dcd5219d3867275481d638ec4aa82c5211b77c70fa004ec008698f3f58548155cc5f05549ffd76c4a81ed3f7ee97660f829a425cbd86428446fccb6be9e0bcd9ff7da2769194ca7de194e6aa02108b970b23eaad414eba9874ad8f97c9947c95a46f766471ea41a1dcae618ee6db94f35cc5e784777f18bba585cbeeec243ba60c3b29aad740df25ba4874dc7fe782d76a29684d84ec2b8d2af25c5bbe3a4cdfc54652750f6b296dd87a15021de8d41d3f0bd423ca6561f352deadbe9c6ca1591f23f187d9c216618b7cb35d1398d35549753381361259e4d1809e1b4ec809494e8bf5d277c7ef2aa0f06e67a4fa414bf5a566c8a3a90099d47ec936650ac2318d80a1bc54d0e9cbcb6b4e3501004b5011c07983bb7d58c63c8668d83ac83889a3155214b3619b24ca2278176e63f8fd55948bcde50fbaccbcb83e115ef30c3673ba0d8b47e68dcccc194f521b623ac6dbbadaec3a590c1cee958b956ace5785c9ae5748f1f2a13189cb5b20a6c20273ac90ad842faa7b2de9bd1baf0c35862d46614c290ba3b542b7451d185ab0e447b1b00553a2431d3c81d4b2380cd65f535ca569bee4074fd97c8be771b068a353dc2733bb100aff4a09f096f5758f7b10e70b954429a1c52a8b270d9b3b6e08eec9dfc0b8e663a2a9d30ea1fc06bd92ebd8aa0a8ad1c150b63ce71c153ba5fce02dac6e79428c2b3af5048be1e8c32ccd5fcb20c929c57a642e4cdf68c81171ec4981cfe4ba5f1cc83018f68ae84cbf8cdffd02c5556e82906809700cff5e71f021c3f31db4c0ba9d57eebf737ce22bbacbf1d1e5add4a69846be69f11455b591f4934c7ce2b1f40327f1d0de5cebde62cb032d16c5cfe9b10e29bafa3736885cbb90f50d5948eec035283208e102ae64b8ce6b48450ca4f8cc925eb48c53d90bfc28022a68f83b7b1412216dfce4c60bcc8904a65a148ad5ea17ce55ad130def55e226c7658bef623f2c2cafd7cedb1fb804ec909e28210588c4130529e7b39c05b1707adb2862ba1dde2feaa0fb77fb06251dba9b0f74a21aac61f973b9231ccc6984d8d166034ba3160f25fd48aa8848a0d0efe6c873ef4a43e8f12e688c5ae0b45d00e3e30a0c52c56df658f2fef361bc517284d2171b075e0dc473d9b343acc99223f358e1422661b04b5153c2139fe38fc91902ec237e7c47f41478d3c28b756df74de892b62db61c79cdb1652928ef747ff8303306e5c225f72e88e27e150d7fbb6b1f835544d47e5bad2169efaaddc9d092c520f67759bba424e13c015f66752e7f5a279365152f026785b0e8b978a0cfadc71a304d13636ca74fc220ca8810cb0f5d3a2dd47645ef73b19addcc324508f810ec30b46af9c4b28c7c4cdc075a87f28a9eb8861c87d76c262ff8fbc9569c92acba8477afbbc3d174d9cb29517d7da5f7fef8cb206f86174f44e6b30d1047f2ea587f57bbbabbc116cbe4fba6fffcbbc1ad5cb777d4926bf54466ae3ad2a1028c92fb1679a6f047ec14710e7e6d46d15d8df1d24e2c50c4c8354f52205943abf5543bb58d0278332ec7ab3c4d1def14dcc1f0a46e1ce8ad66c7102ff2979d03aa7dd7b5523d3dfee6ac17e8e43b90b8c48bd13250853860d7f105e1fd8e49c462bcc21fe32d3949d13027a887448dd6e868393e8ac215384973bfc1cd2e8d7f8bba10133c98be76b13596898f59220f03c64a8a1adc849c8cf429a07798703f7ec9a7485fe4df1e25a516bdf32eccf32579fa3d2d32d3044134783a8e089188829ff00fca9f4e57cee3eb1d22c1db99f5ebbb0d9e694daf0d7bf0015cecdae3a1641a8f2397e62a1670e3c26fd3d4202af9ec9916990649fd9ed73a454041ee27e9fff47c8c11cae7834002d0b5f90547f402ea2497097e43034bddad6ec5eaededd59f911ade18c4f5dd841e6fe3135d491c1d23d45a7f22b4ababca9d52296e98a36b8c31af82d18bc0f3b6b5d36050f40265acd9fac355e76425e4aa312a80cc40bda64dc89bb70977bc9b5cc02f28757b03ef8ea296aba32791e2320523525cab0e04ba42ed8b168c7378bb7ad74a16b48ca3dc1fbe06a7012a4c8f49737aee5655bc9c8b61ac9c3b2f3db6357755f97be48f91dc3bae47535d628fba996f13b0a1308246db4c68b4e3cf10793acbe5f744a7c4e0fd2addab089aa084342a4540c43c61d092a61f7e80d002ceb6d068627e345a81b83bb2679d09907a30a05998a79c124db803ede0eb7fda9bba295f118789e4e2f65fde7265597661c2ad71f1e6422c62933a824e12b64dc4995928aba73744948fa6956632aa7d61cf4aa5bbe46d0461e39b45ae5e6dadad6b56822a4eb2291bd8a595dea8647c56c94996612adb1e54e8592985771517ef9dc581438ad0a1ff981ba3ade02358bb22ed8bfd938ac2cbf80c0814c5f1ecd7420cb99680629628d4c3cc9448d85c95aa5d1163995cae9cbc1239df6485a4e5a271289a62a8a267c3ddd9e74bc95f67e55a2f1c242f3806d7550462e39c786e0f4a8522d2d22082e497936f1df6c0d7757712e5fb1fd4d3f05fb3468047f104db7ab59cd7c6a7b8ebe57aaae532545d8ba91fbb2d16985a987163301d7315b0391e5710903f9d816824d9cf3996f01098888347ac53c4c332dfdfb3a4b64a88bd1c769ab70c2e23ec41678b2ac1ce0fe4856e3191fa22d29e39ab835584ad7a93f8d66c67bcfecceb9ac6eb1d7639e874d853063c7f7fe1e3416fb1e131744e92d24b6d48b8cedc25dca881e1aec22bab9593d9dcc81adad6914df4dac197d61a143fe24b499e791246ecf86591a7df983c3f8e292420524d1c13d75e8080cf15de48412b549feba500063bd0d60e2238d077ec968e03842d95e1f8e7bbb1e36111cd96551b8a7945ef04bebfb0657940efea337efdce8031ebf37663387af61f55b0ffc9adfee5783d4432a319f78c4e48a1692c8b453431ac4422135b66eb4d344c1aae52678818a020cddc4ed440763444b0fa1bef1ebab66a74349c7ada2cf6507ef1bd77d3f00f9014eb3c883ee4eab022b9915e195567edfa8d8d2593e6b2dd3d55041a3dfcca889c3fc31a21036f630e39d3b2e9f6b33812148787d41f5723234f427f68f02f2595fafc66976182a9ec431575a422d5f720b43980fd5fdfc8c9fa3cfea0619f2e5410535b5a93d6d5eb5c20a9fce230912f10fb1ed2275ff10285d577a44ae980e6cbd9923c85e4393064a3e9a869baa608985e79cf548ca9bdaa660df9b56006d6b0920b1f8b8bf18081130bac0bc7d7b9029baf19aec6a52ff6df947e96839d04ffa902cb011ac7bf35d1eb1c4ffa5a333746cf389b0749e1ad113803442c9897e5236eba8a09b950fe0bf739032190251c0037f2dcbb8e035b55e5092b3afb203f068be2d93541cceebee8b1cda4500972f533d54905d83f07c5f25b4e543ef6d79d1edf9f12f1507bb908fa99c1a09e3d229b1073945126985371a12316549a877d5d376f83fbe1a82bf9ad6c8ef1524911f2cc55e7c7a5b71398a36151da0c3cb70051327e56105ce399940d780e1de7a779bdce3587cb04b1e282c179505634e648493e2ee45d33061e3f163c4a9d98e0be4b929457987f592bfba66b10781424517a7fd3fbfecb56cae8b56aed5ed76b03d98187755da13171afc3a88742c421342887e8ab0e04a82ea1e89077691e8aba23435c9009f7b2d4d83b46da928503794773b784bc12e78e05571b52b76f2f4860758f77b5033ef24e2caa4fd2b61a9e010f1b4f630465d0689219e09f1404b7ed1ff8251084a54b3c8758b2e6170af04bdde1cb42d839e5800ef5a985b1b4f06846d39398b839f479b6899b130bb7da3f02e38b9d30e148bd2c0d619036fe4c4ec757ff57d0445535f6cffbb8b20bf8657974b72d2c8ead66bebdb34d51ade44dcc32ec61260d1dc9ea4f7ea5ab134c363cad0159b70d82578629070f1f92cf13622a59650982e7e944392628606c2603b2bca3f2bddf19b3d8162fea8dd5ffa3b413849a06","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
