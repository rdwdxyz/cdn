<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b1d074ebe1fadf3ac76760e5f673f5b57ad961291a9e237d857f904f4dea24ffa141d3d54ef28e7571133d6126377c871be8151aafdc2e4a59c0557c3b0b6a796b973e318220d2ee0a95ec94d1c7bb5b7d959f46d172f165b89d458599e254922d6bc93bfbeded933ba8aacc42da4676bb08c41e09171cc56b4634228b5e556a3627d001c9f7d2478d07502d8c13edf255309237b955117c80ed6660876fedbbb9d4e16ed07331d759e51639e4e75c5120490c013733bf1e2ece07025a870ae54dbd2779a88ef99a259ed10dd627a1df689129027584e2efdf0a3c7b1caa708074c6d8c213152737d2559abd67b0bc5a31d95b569ec682b46c10a6000a478fb645b1a65f4318ef644d53f7564b2b97649a0c2c48eb3020780d2a9d236d000c4d3c5cf30176d3bc200df0d1e9e23be609e9a6d47936e985fac371af518216c3db75d6df5c82028c39303788d7f096b40a8acc1ac0306bf535ab6c18c6a421de4a37adf95c314d95ebf36cc4def32f1ef4cfe28f6e32bd344a04cb4dc2951e1ec24fb8af81df3747a181fb5d46d05405c4053ed9a0f55ac35f209d1ba78feac97895fb9fee82c7331fa456cc80073c5c90f1d28138df74a9c1e282dbb594f8958265e41c4ff5aacfc456f525700df0288b62572a111c553b4a70460cb9a50d3a1c274cebf49c259341444304233c460c18e384316e38b05cd272125a798f507ff1a6a0a4a5c8f2e3acd89e23fd7e699def0d64efdecaed4331edaf8009923d13be5b946fb6d3f27f888f1b781ace3901a0e4753af8c7ff2aba836e6fba1dbecaa755bb4209d8b9b1fa265cb9e395796c3e03537b13e06e0ec0102ea0eaa6de518757e1df8f6a0a1e4f3748b981f1d719158a7c8dc71836b84095e8e6698af3d45a1626e2a95e023a7106aea22835c8953c2042092f77704739de11dc17f5940f2bde8c2bf53416c81f39ceb6f1746d8a63872d7e722951aac23f19516d5f1763d53150a4adcf5394ffe019b93046437c1a91301b02d902fb26230d9b3d172364463d288b0bc7cf5e5f662d0375c5c2bd120fd5e423af7ecb77f75d4480cfcf2210c339d70b3b2d0f03137d60b69bdfcded34e102f062d663b7df42f5e9a82731767f3a149df5d3e1e6ce3f901affd5bf27813fe6d9773b004f9e1aede05a96a8156780a89fd8eda221b2ba3654198619ad6a9caf548d68e00d3aea82441cba4315fb45ca5af5ab7cb9d36af907db12a5de7394b29c304ad51d936b8935319fb770c405fa6dc6a718edcef7d620a43837a7a20a8763a46649adbf6cdd7de289dedd371c8159c5cbf6ca913069e415ec68a76bfbd92e3fc8750a9ff8b7b66242ab6ab7e0f933fd177d6428aa85c9ede6e528e17564bc6901d6d14d78dfeb1b8da950302b5a65bc1eeb299062db1dc1346ea9d822f39b96a6781f6ea7b04a407a1d44bd1295b997c732e80747100c0d013f5ac2fb8df3859fd8d6b30286e6744c40586018ff4b182c1d1817b923770054268808614bab2e4f76cabe0b0278ca85717f853e67721ee934c73cfad1be65ae5df5dd34400fc5e75ba765605f064e08a4ab41c0270228867451b43483cb8e52c73124b8372651555a6f6f06483759a28a017e4ba23ace5673c6b12cc72f190d7fba250500b0b3a0f166c5b1643156c295808e2f2d49962a413caf0a67c1a203127f85a4704eef24d8e444815ceb753fad1364c28cf2392ee9585d7b30fef0480a741174272267367938218e49584c8dfda63b54a741e2ff523e04813673970226eea8c52456a42f69bfb3c2c9a363590f03246e6a37ca93db421dc2eee98a8d4240968fbe8b49ae5a80aba17831699ed31325779286323ac4f8a4e08789f798564bed854db0b655e5f76922f46ca56acea5036529f4ade0628838c910f4fdc76b21113e93b9129129211e734de19e817b13ecd0b6d0a6f96ef0cc613b5fb366f8ceaa192150e89ec02d3fc0598be40575f4e61ab1267ce456bf40af72946249dd41c9617bf982852ee2064f24465e6c1612ed7640dbab5b84190734c6f35e3b354c9503942ba28581b41a45b43eb3c8ce7a9c1f3e2ce3eb8ec87c09e924bed0ca641ffc85d20ef0da5aa7185a10bd15a584d5092f921b6816d5df480c404668df5a3e0e6eeae2f8add117cdbfae20c6e6f1d98202b7e3d058dc3e990944c3431435f843024b5c23c96728057d91fe6827f01c55f03dadd4a6202fc68c1d4e9ff475c6e59b597a0ed31cc79d66c90264085ce4e3e0293ea6d4add10ecd4167825fa04dd023533be2b9368a81b6ea7baf012ca25a9d5b1833d585de79d7e888844fc1f38ce3bf386a0a90cfc0e9f8c24aeeb53dafffe2a2a709ee992d15d861675f8aa888e0a7b15d27569c55ef4ae72117fe106e67bf2b0b46b3a808cc2fc35aab2a8ee0d8dc5ca0d1de1ce0b1cf76ed08b75be527ec6c82a489f9e739e5a2ef10deb0e11a799afd7b5cdf9a8da876fadefe23cb8d1a2c613e5f99f537fcf9259aaeb32fec8b8303f7ad3d2951e4456a53b0ff6c29cb767f070b8e0904986ff779035f444a20c897ea7d98c7a4a0671a9975afba10af75ebf9cdf26350ea2cbf63ed45b2f7ee3f3aa2ff26e7e6c2b5ba7b4b6739d87640249b655e724a5376937ca379bf62e6db612d824bc224139893db5a00454d7698d3411b4c6f68f1e26094b8ef75097a2b670f747a0e869a19847678f597f4e880932b5e3bf6248275deba7b9cb11d1dec6c9963ea1fae9cb8fa8c02f2993823493c156fd1d0a1ba807527eb1dcfe27043119445bb15ae02634d98a6fc54d8d9e4dbfbdbd2fcb10ddabc7935310b5b9984a51e997084070d3bfffe437fcccc5d651632130a8c52ade4ba208eb02c6945693337cd27491ced86e14ef2500cd64868d9e72d69479c7bc5622229cae3744692e00e3421f209eb1e24b6a32df61d73791e9bf61f4aaa24a613cc4b654107c98eea2b754f5e65a80d8d3c49326de28f54a2beff683b95addca3371b764b6039b66d06f1ea0b57415e09730a80c9748e1b662178395c9dd9141bbd750b2c162f678ccaae8049e18b374356bfaa322c28d7383b7a7eab7deb661467e3e7d3855643f2430fa1e0ad8b1dbb1fe3d6e9979d73b06d332edb523bdb4dc7158bd699d942aef16ecbfd30352746b82b2343800a77d54bf04ea5c1edc28cfb1a29496e7052df4df1b678e05628dc55b949b4dfa47042a7d0cc47da0d532dcef3faec9a296626cb40d9b2e0313de95865eebb9a3ef9ace9930ab272e008cc345b74b52c5aa92735b9b5e40a8a271b77abc5596844e5bfd46a8c8ac1e5ca3dc684b18962881044db260c1199f8dcadd9e467f87c5a1c29c8c53dba7ee2232568d314427abfb71cf93d5bf3908e5b23cb54b471b98efc19e2234e961517e1dad57a466c878f8f9f2691e10506b15c0434ee3cceba99c284625385055e79e4e9d15783cd1fe95bc3e54c4b7bcdd8ac0f9bffabf006eef41664301a27856f86eaf03dd918ee624e3ba9528f094aa59a91bed97ba9c07d36b9edb30df28c4d72dd7d3afcf93240d12319fe0f796505b1324c380758446ca38640fdfd97ab992576d042f09d3d2f04dd6cda8f6b0c03e2e9e14abbdd3f5c4e062ce1a3196558ec16abd3faceab904397ddea6ebd291abe51e19147dbb5a82cafaed2e2c4efc6c7b98ea9bc59288ca0a2fad4b54d8e78414f97680eb34ae927fedeffe00850b8910b8c2e282d96905086a2c92cf993fa2f484cc77c1bb1e9855b7038c810af171bb173d7333b0887065ddb1a288d0f384341e424944f7dc937661eb19162d06689c218be66af719b7c08233081ca1bea2dfcbefe47f1e9e4b255a5126fcf815e22db992658f82d1736ae7d080fecdab7f1a7f5ce56503ccb64911f545f2d8672d9ca348cadc9abd9ec3f3df7557172043e89a7e2e6fa26b469dfd581efc1a7f88a880114920aa9684c43c6665e77dabd7ca22aead743b613a99ddde6d226eb2e07c0595aaae243ed1a0062fe54b7bbd9cc0723b15658ae598d4e1a855dc64f128767969301d8c0cb7e9ac8d6ecb07b6708dfd65def4177f9005eaf5f9825427542b442085853481f470b566a07398b43048734a7d978913c4d98150de1b99c25dc4fd202071945a93fef7876663aac3748f24f2ab739203092d05d8a607e2267482375b9e98be1de470050bd71d130d73571b904d687ceefcdb04559b5717eccd380d70110e26a287e8801fd004243e66cd5444db79f260efa0b92c92d0627a4554ff9fa69d800f19834fa557e9a688f08c6909255954c3e1187f897e56a886829548bcb68a3e134f6141c97ec30faf019695cb664dc75f6dad1c2e1f297aa774759216fcb3b30abc6b1b7b0c5bd7f8bd6eaeb4f3f7694e34646dc16f88f906db2ce98e2f34f7ee9829b594d7535543959e753e8685904e5d12caae01760382a202ba873224d626d56c4bf32ce5651be589410fc96c72c758002aad2fc401970aa30adeb5fa16af07c83ca57b0b8d1571f723739653b3d16f7fd84ffe170dc7b40870e048eb78a63c295b72150e91043a294250719b95bacd7bd1538e72ced06971445b84e67da4246ab9edc92a4b35a5fdb4840233ba649ffc78b36a8eb573f12e0aae7523128cbd6535ff3ca023816573224e81423ab76c9573c91d1da37dc905f14b74da3827082ae53cabee2a2cd5f0533c142f081d2d88038a6b71237084869a1e4af4be0498f7f031cabc9318b78dfb4ec76812382c78b14e938dde99d7265eaf9b937eeda0c5970fc352db4fad832be2f37801f1cf985d4c9e18c28c3e18bf09100e4ed9941f1a030ea7ef8a10b3df7b7eb4843a0e8bc3ce262dd9623b1cd6264b2151b1081a3a114d26dd0c51886a2fda124e7053882268f598c5cb96f8c43aff78baef39f79061632c0a250e8f18a035b3032d1ac8a8a7868d69830e91a7651487449b68c5dc1f690747330a326f6f5ce46aa62e9c2730c0faa86477a7d706c863c8fa9bf40e917b6ef36a8ca43a29e85201e2ca62a0eb7658229237fbe24d01239d3b80135445a57c314c6ecc7f416fca515df9efcf3083b98770fecf2226b76435cb9905d2706fa66216becbd1917b0d0913805193a23fcd6752014bef91489b7912953dd1a1ca93ced4c078311dbe385416d6623fcf0a92d096ee6cb34532175c701e1b559494dce59ab39cf2e8201ba719c9f0284ea5184d15adc1bd0289a908beb5ec3c1e9a7d8243f8baf9d9905db6243493745cecba89c00a05fbe9b8071b1625cc3cb6683d079e419d1dae5b45b5d6cdc162bceb33fb507382b3978047ae69607c6c0535044830e4bfdbeb12ff6105cf12ed1c4d3179213d8d35b26179f927c68baa8b7abf941a54755f0c65d1172b92419432b00e06ce3a5aa602190fac4351ea0b7193473d07a2a7ec40fd09765cf8cd8ad3a11f9cf2f408834bc874a484b8b0158aa9a21d115c994c944ea5e972c87de40d56721b0a896ffd65d3391e22aa3dda2e07aefc034f38fc0d5175a5cec780e7ffa91e0685f9cb44ae5ea5acafefc2356b742d785349b709e891e749f4b7ec3f2ed2a6533174f41079248f917bd199f348becdd083b6036e28de225345e0506b20d3ae93a59bebd87c46bfaf78739a280c50e850c1a430d5d74b80478b04c57d17f7628b04d9dc00e3c78609086cfd62d44406682657cebe39abd647d3d4e1a1d51dde333f921796788b097f2166bb65d2753a004343c3ed866217398d4224a826f90cd51c530d9070b194cacb67b3618085667ebf9e97e3c1a2783acd74bde3059cfa7b4f78a1f429ee91403da0b7167991c61e2fe45dd72f81d63385e9ae8bff1a3d5f7a88c468a508d9e963f7e30a87c7d2a78f301c395ecfe43217ffe711a621d2a2a523ccb6f38b7c0a6f9a6a69230ad108864209b41f2b7310f5c84c06253a2e713b159ce57a925085f680d66efab53cce68e5051177b94cad7da39a232672fb99b2b029df70f1add0fb2517b3cb941cffafd6a7d500c0fe18ccd5b9106ce5d6b1a41231cc963793c5e3ecdac7d1f94c5d97cf770da2a95b0fb9e0260322e53b15b41f9fda117f649dd12d84a4046b7f0c43ccb7cb1520598e0bb61298415882a533e3b1474a18c4961bd5da354f3a80cd36a73adcb91b542f49e0d54143a0c6a7e5cd2b3a03fc1ea6e12c541f2618988f385bcfc1459a2a18faaecf53dd3be488f940b480593c58de0e8da75eba97ad8a05a3baa6727379872f001399400c57671f30114996862b355faa14fd2c4df4e085491ca803488648a14c38fb377ef9d6a1d862b909b817997f1aee581f2c99ec0a9a1cb3a4d1d2cc5cc696cba7f2deb772a33d6c8a6dc6b8a3433b2756a3fdaf0e71b4a715114de6c4932b15f83efe77e8a25aaabf6c6143d89c7fc36bbba1f5272d92372aeffdacf12224e45986a0b39de955882b67d1375032192626d3c0eaf03f9fafbf72ae7c99fe5f8c61395bc29ecce6314be2513724e3de56dbf77afddfe65fd5e8e8a0246c9a56d439420cdf8ff4d7595cf61648ce662f665bca4ed09f5bd25d25e70b479191cd437e6fd18bba5c3ca5af5eadcd7bcca7c31e7b89fd14e5147a850860fa38ac4380235541e20a2469c32b37fb2b407c0843a4fbeedc27534d5360e1090d09e581cac2cef7b0cbd44f3486841c5876f5a2a0825b7c8ba3fda729b905e0c38c05fa6e2c3eeb927331c75093090ea57dd8139ea80805fc61b33e17eac3eb622d140f9ebfb7b82ebd70e5f2d8449db88ec551bec6763538a3a742566ffe9a59359204b13eaccc882d923146cd168ebb183e9c468ac424cdce7effd88ac03895e43f329d73b14645eb18fa4effdc7286179bd9689f272843e114540c6bc3ab1a0156aa8b48cc75acbc25a53390538e5491819a7ed4eac58ffc25738aa6f0b844f1f6b2ad40a6bb7bdd7b1e741cc6888c392ce21d54eed26c29f17f8b8d68b0d5ed484cf1bd8e0141fa2a458ec186a35da4e0acd62e6fc1b53a20205a27475c91ae29d1216e56c9466ce6b200eda9649e6889ebbcb7874222d239984e6e7931235ae72c1b770bf8ec9f3321c2eb4e2fb38f67c6d2cfcf3717ad3d9cd08eb2203850d87b24be7138e1730cbf820142d9e5d30017e302a079c63c5a3a74852423844d302e8abb366cc6d426361fa6ac8289455acc74650f89a92caed0e7356a486d0c9dad3dd32dfd2a8030a0cce68990dd8c07c8af59a5418b494e8710d3d98a945156e7297f98bcbc9a18692cd908bc12bc70c9cc9c83bd837d6289fe1cda6cc6fa3a1440eed7660a3e551e4d2d554886a69534a32b508f25e10a541f5353934a334083a89e851674155dbd77436289cc44972db976a7b844df73af60b52e5385c9b3a455c7d3ba43ba1152d14840dc637a4a656827c88372ffe86b30d8d4a919e12b51c7074eba06497f0097e845a4793165cbefc923581771370a8343db8f03112fc3e752725446fab33607d2296edae3eb37dc904a099d30447bbaf5c8bf7819bee2f825b34cfe1e24ce3f181d90bae2b423cce4e82292093dd3b1bc7d8190f2e01a94e9a8d9c491ffdce1f03c786c280be0273eeab61a15baea0094ece12985140477434b96382c849210e62917bb8c3da373c7ce0d030e12d62bb7bcab68dd3b2f212f69f67ef0bcb942ff9dc5c1f39f48ffb7ea86dbf15e602bea621e734553e67aa443541ecd377adb8fdb1ad9cbbba016e6d0915ebeb1da47f2977f9f8bcef12e4da7761633c6a85577a8fd54a400dd5f08703621ad72f94acf83f63ce32f1cfb9eeb12f5c54d4473be13699e7fca5ad453a98ebe0484eebf6bef899dddfbed2680913b20ffa27728a5d4e1e528faea478690b93cf8268a9d5089e7a299e7de0ce861ae61e0ffa2ce31870772277283909fd48071c5c4b9be61e3b639fa39a64b36eb17fbf481fbc7375c80cfa25313c75703f901801656b1b418a894fce65f6bc7b3c57a8907263053c6f12b55cbd68258d1cbb8609e0ff48e5d0bc1a2e8a05e00564b28ad5dcee0ec33cac66c168e5b30520dbfd322cbb45487982404b7e2206815ba5f306d0512ad8a157349bae13f9d987c4243cdbd069e4e5a08e926eef6385009543517138bc377e036d7d6a63a4260bf582f2f55bc462766980aeeccd33d17941606152df55fc63358b823691a8d801f4f3488cd91ed96f51c7d54de6ae0f33aef6c9c9b2423c02e02a85f3da08867a6d522c297362120fc0f956e4a29727015bd31cdc82f1624ca2bf89523b697798b3df7ef509431c75aa277d9799a60c51cb027a26525c1cb17b40ad1949ced2687ef6957f2462f1da9c75563c6f9a5fec65fb783a85a7077b3ffbe43e253b23841a9727286d845adb41ce1b7d2b719320bdbaa7402972c6291373d58aeeeb500ee65b416a2115a7d46bd5ef519c839f7c73b5f21d1b9dd83c60f76aba6e4c2a53be6adc443bb7afb26c3c966fe2132ee259d7b6c41dc03d26895b6a8f8f23fec8fcd67e40f0bf3f1402c71191aa16c1fc866f0ee41111aad6fb23eba4c86f9d77d426e9499dd826b3ff89762270f68fbacd651dd39c0701c3dc849a72d33b11fcca51831084e8765eea0260c3a0f67de189dba99bd0fb5ab752f149af0ce7a101dcde0251e2af1fdf1f3e0a7842a54a84d02d92e7ba2e98f6a016ed6b67cca4444732432ca2a8f38a73781ceabf22abff1c9a6a7c770600c79af98394d69479977c3db8ea98f66e3b67d6472883b6d112b8377f00ebc9b5a6e626e4e01c15fb6899a98d7155de32c0a33517ea85965b27801effcd5bb02cfeb091a21686972df5a191ed4ed243db19bbd4dbee4167194553f998e8caa5ca951722d9cc8740b03df8a9e55b163103dfc572ac07f8af74fa5d79c07e3d4678a3013c24f7a59cb1bf22546f7b16dc18ed08666c4d2944532fa7e0b768b5b572b44806fc435071ec794dc8edf7c4f3aa11b0cf8ddf8fd9b2e215bdd99c10684c4fcf2a590f3a8782e28d33232e83910fe5295381302dbf016ee01826033c81e3c996e2a87fc4d8317df486b5d61f0ad91627ea7a645229da5a42ce673960c8fbf80bb94520c2178f94a136d1a0a0c4ddc3784bad2e9ec9a338b9f427408bb298cfccbc51ea713f5fdc0686c82ffed561075c252325a1ee7296b8be9f87a1d4352df3f188183929b336ffc1b69d6503f5d52ad15a682c234c17989d034655f348205c63882a0b37ccb623ab33215419ff6868ad201978c2e09441a3bba9fe249bcd8524b2ab290cd7af06131c90aa633da70e6dfdd26521c31cf974ba3a1e9bcc10dd3c33519629c010f1fbb62b440d51e5093040120be5aba4a63bb0aa54bdf8e1ed6f5cd94002f3688d4fa3c79790677eb96fba2fe9432c5bc34b723d4130590e0ba0dc629a871c2eabab2575fb919eda147162d63b8de0a7aae7712b22943c1b63d8a7b6295fa481efc31df2412fc65c46f9c683e441c7a6c042aba9078e567c6958f4dbe12c8470c152944ba928e04a377d9a6e0b7a1cfe812f51bf5aab29adfb39e3da82c2520452118569d3f52a4a58651c0e25619f6e592dabd6bc4fc7dcf3a90b68e3728bbdfdbe98ee0b34615a34c9c5005909965176c0ab0643f146bd17a34e878fe4b2ada8f6838d375830ff68ea1ada1d02e20db569bddec62f590e3b026019955a1b14decae04e5210375dd02c006341cc3aa80184d6f070b0bb070b88c5432dc035cada7511f1094f5b940f984edde494c6d75cfa42f0b124d6a3315e81b57e9ebd6ed39ea0c17a6bd2756f39b7f3626f74b42072149c77d0b3ef3ec5af28ec2a05bed250f1ac9eedd9db4f59e85304ff746571e745da764166e1e0524a379a7e80eed1dfb83c4d8aecaa7f782a07c8a98d930726a0b8068225de336c44309b943c230b47bd3a7db9c4eb2d6f7ff59ef9a34dd49ff2786afa5209db2534ceee2dbe31b150fd47ec04da36488f7a2cbbeec142d128b1735f62e313c61fc3a963335aaf95cf83ccdd5d3f843ff64161da6c9d6fa4a49554c6335b4c8e3a69ba9443e53258f9b76299954f277d3efd5f47517103341f4694b30d8cafc999cb1da47b40cefb8c997531aee63d50fe8d2e697befb111b837febdb6b9dcf9d029dd0a44ddda8cc251fb25c24aa4ceb07ed00579342da7e319af74bf2988f2a5a1fed36295f102be71030c0508393ea7f88022baa129134eab4c252fc427eddbe74283154a6f7ba1d2631c2180e044af6e9cf106fbf57ce28688b84bf8f5951c4e5a7727b8e67d3f63fb5a4b7aa41c0b2ea00510ac601c6f1d872604483d2ab594a977a6312688f08950f1060b54e5d66bce52ea9fe5acb6bb8562545d1368c219907409d82615811aa2b07ca5ca78d68021ad8d5b1d679b9748ea5ec505326abbe7ef90d540a4240705e6141f0400515729579002289868e29941ff5ffa5004adb01811d6284e9d23e728c52f85d9e1490640c728970e3b890e3fb0e821227b46029569a95bdd0313f2918983e4b0506a05aa2d786cda60cbf7563efc55a7da32860aaa6507da670c4b4326c7590d547ac77fe41736265b5ec796ff80c41b10eb9085f299f37f1a8b42796442a5236c7625c7a12457258f9f5a8a7954c7eb0c3e4c72a790639360e6010697352055bfd447d839b146a7c98c13995e5408d2e4904ed86a1dea49493cae729a78660fee89b305e4eb13060e4a48aa85edc26c17bb7fbedba5d0d61c5119f620a1b8c8d59b97a7268e744110197f73b4a09ebedb008e760f44b8b935b61bb8c431b7fa7245162fd6b5764b07756498cd0219d5629c8ce905f60e30f2d1538131725fe358156ac02bb25cddf69c5aa4f99ed16a5d2a44c42de60f54669d592d91fb6016ad698d8cf6f4f24d59bcdbe14c35dec6523e3d18663dd0c6f661285c0986e6bd32bc50e16c0f393c92d13d34bea39881e517a32acde75cec1d1634947f5fe5002d8414a8e7a7d7151cc89a223da6d65e97e6e12357f9e3d05dfc501ca5669909f3b3ca1e2194742839a16dd2832e81c6b95bb70455e20bb6de4343acb04d6a9749a33c7ee5841d013627aca584fd1db248d5072c5691b1f01db9b95e540bf82a7ba309218249510a6c80549ea2d02e234f30c1d5c13b2d51770f7f90793ffad1c973c6fc022c67a6a03c8e6e545f04495990ffbf79d3c28ed2e3532216a80feba47be569f7258cb68d95c2ae9fc84c93f8d2cc4cde0dbab04f9a2c39efe4995178ef027265cc46fb09759ff397ef152ad8c29501b32b98457cf7c505b16a07520242a7c5196757a40a30638ef13a8a747f396e0ace0064efaea56daf58b99a7b5a3c7809457be2dd5a02a89da4c05a08a0b458039a58d910522fb4f3b6b33a11499b3d837a7220eaed08f0eebc8ce3b96291ef3520124d1d7dcfa79ba44d5ce7e6cae7e07848e96d942bd30cf44c1e92384e21a88db62201a125e067ffc31d464a4528677799e61c8b23018a72b151eb378fc47891ef9d000bb90c2a0635a96d17cae625b92de7e884aa8791e32a6e8258cc33904d317c1c745f7a1aa155c195d5319527eb0cc957fa7a59611958684b09c39baeb346ed50ad7cb821679bf654f59b33474607000b7a15a9a83703d7f4f9f63c0e5da7b10df549784c3e2f37283914ddc116e89225019ec9cb25f7df6978fc43408a8198b9b4287673e9cce48ab5d54edb0e82a628fac64279ec9fa978497f0c7a443e0359e53b4f7f9c85ff85833a53f92518469cce2a0385f743f7f11e8f265898d6c3c1f84fdc012489193054b783c5f10eb3504646d2f1fc60b226d6f93e67562c1d29d6411629e6b908a121f1251a190449546810a56c72ac5644f1bd96b177ca670f440114654756e4efbee66a950e81833cd411a7e29dcbd395be0c54d6767346570d525fba9327e3c7899b3327c75b72857cdaeea1896972da35990505f741184dc237eade67e67ef2c3facddf2e85691dc2d7753a3a95410e6193590edddc3ffad324719e8725ab357302f7abe39750984b8f6a90ee85e24c40b686713d5273e39300157f28d0c02e69db11229f3d94fdf0f006babd3ad72109e3936a0c02c346da8a1b7a495dd0e9339d2c75b73c27a2f0fab191363d946293529f883a1216fca9460ee49d5bd170e2ec983c72913f006324ca200f1ebd197f7e7146a1d0cf6c6b43884fc07809b1958d54b621557998b24b6ef50a80c36b68382f9f0778c3e2de74514bff359363a38e20819a20e058dda7adaf9027cafe5a6eb1c21d61440077d50373a6d3d47dd94a7a31e505688ce6714372d32f19f022397a1388f7477d9ffddaa3a95c402e6ba0852b90a821ac09988d3691f3903d24e2763476ef134968344e03bf7f33c95f906a57b5372ae6c62af93823b1389da33a620747ef2d0f956817c1a83023153b1d3f12f0a184ff200aa70f8583faf1122dadf87db1e515c8e55077b8a1bd04561529bd75d4830af45c97614da454edc76d7d3f57eef4bf299b0c6cff610a3a35e66721dd905e8a5f1239c6ba587ad09279c79e3f10272ef46c3eebb2a2148010d3d6b49201f531b823e8b33509865e4083ccf0b8c11dd3384f0809ecf3f60a0e4c2d640f370316cd30d5c005306039052fd17a73db75fce66654eb17f7c180ac4d605288babc32b1aeeefbd1ad4b44a424718f8b676381b91ebc75413e066666135b8c55b39c14e0772d4c23ac278a32fe4c29acdbf39f3a76b64c77043439a32328cf3c9ecfe597d8ca738f1d1d25416534acda67691a63fa9e15bbf255388918b2c363f0178f22e0c2e0f3b55b448832a7878a93415ebd0d700ef4638eca0970cfe1c7a8eee850ff2ad3ae6298adbf82b80a5b833dbf266982df88f19ef04c7618854864e3ebb778a55bfff941e8ed1aa4fc2f8903d4000c1cf94609b9a42defb92c2b3fc71a78c0e93a1206f4233d617a6dfd5ae2d21193cd3722f13a336a5196b91153cf259c10750f6e99e2862657992f689ab07f689aa8d3d1ed2b2e5f630c5117a48105559b78548339e41a854384ebcb809a6c29d0c4e873b73413d1cf4f8598c99b3d94fa3cb4b4d452f5a4dd581b1ddfffa321bd49b76ff3b2a3480b17775119d392e14996a3b2b8f0574117f58bb699e84aa955ae8b52439f262b5bc7b47a0a9933363201e8c7f61fe526400183f4477c641564470561123091311fc5e301ffb266ee7677273501c76ba74db196be4d1ee9cf8e7006d21aae7a20cc651cd0ca8e8a59924ffd422bc555607695b249d7d7332135794db8e5d1a6dc867824541d19119a3148e4ed69370b79ee1e9d6d9aaf8816195a1fe25aea57965861caa5ba71d8cc092e5991dbf9581b840e0afdceaaeff6cd472e5bc7fe9fc79aca53c3418d95433433da68be1cafc676e7df3ea9a35faa8f2da6a8cc26bc75a2f397ddf2650c58ba68fc80931803718de998eed4e6a8b171fbaec9caf7085f7ddc9fbc2aa08ec117394f3e51d3ae51487cd1ca9c8f0e89c7fcd8c99aacb8da9893a6f305afc81ae710895a257783ab01dfe2749487b67b58f25f26c699089ac41eb890f900297b816efa0ca2c646daa9785a250ba496dc193d8e7bb82275da26864d09f40652c512285fb89a920bd6cb339ea111e599c96cdf36c7e65648be308246344881cbf813887c169b462d670171d5a6b5533e0926fc192e54fcae29b14f264940c1f01535082909eda1a2a9c123c588e0802ee1688a763c685ff042c500bf6de3d16ba4f9da66a4c77f7933baec28264130feda3e3b552a50474f8d50930c0606ff256901c4c19052d47239c96ba96c03c204bd2f320df7bc4eea64457232f316f56386cca035c339f06f455c9689b5be9cee2a6bf0a37603b25006eeb08f47eb886c41d73cf90ca0943812b102596decbf3eb49774f545be87f22ad1b6c897fad5f7b407ce0a5319be52fa3178ff10dd526119780a666178a2f37ee85f9a49b7a7f3d7fd1e6c18995809f385e530060b3fd3013bbb94620ae23ef977731ff27121ecb0cd36f52ee22d26571d8f68a045c4b9209fd1fb55175895f5f45ef4bedbbb697a10061c3bfd44a0a300936ebcd212853b528d19e062b4d74ce7f60199d0f766c9e624bd6e068ad5b77db8b5123b2ae9e9df1c550943e721c32519e2405126cc2715de670089058cebdea47a713ebaa5d47c833f564ae01998b786e6879a3ab7a9089542dac3fee00927e7e71c135e9f866a8cb92ccec9e2696c6b535c537c3d492d3fc090b0ec978b51f69ba771574d581a25b1819b74af79ca21248403657f7e8519cbd2c54b45d6ca6e3447c9ed988977290eb0c42347597b78833c418838e67f93402b61489be6306f37c3ce0f1fed23833102a9e01710a42bbada1516f27325702a078e19b9453ebda3a057720884ec710c96cf885c2436fa55a359ba4775cb89680311737d9579ad49eaa0466cd3f236b721a683d556d65af0c3cf3bd27d053ac238c6adec27a5bcad4a97039c58d1330f7e2e0f9e0c9d3d981d65d179193522c36c0694a91846938d62489e35e59ee1661417daaab80c078453c44f8c884a6a98e59261f5a7171f4f5f1771bcbdae6f37e58b336b772af2e5fbe79efa0d95c82a0e458e04ba6ba5d472e26c4d30ae49691ea009a4eaf3b26f40a9dcab59e6fbbfacc962f255a960a69fc18d4ffe985f61ceae0d291265b304f2b4d8abb5ccb0379d7c3166c2d7d6ce05134d152a8886e85dd7655aa2c702c927b0494014fb721a0c2dacdc9dbd72221151952ef2b2f32df89901889e92cb188267bafc88d85c454c4d7d78b61e0e0dd64e31d8ee96fcd870d216f76bcd5ea4f3e2d337c55a3eae01dc8f38dfc1d875a6d9effe731b019ab9b5d7e3e3b2fda7fa8dfd39e8989ee112f392fd0bef67a2221b1bf424498acbfb1f9e7f1fc3b646c978dbc1a8e1c92ba8c38bc8b84c4b107769c35a7e39f7a0e6097d07186f47bd433616f6673e508e5873260cd04108154154d947211e0e11625860853b542b24503ae2cad9aa1b4a67a99ccd4755c5a5d38c5c097a88f5501b15880c6162f4069ff10158169f1459664f6e3aa42c87655eec0c18a05a23d492cffbb59cdaf7dffc6be265bcf047ee21d6bf01638f94e67026e5d9ba1816decb64d62bdb2710fa3a4deeeb5a5c78849479e4dd5e34832a6eb624ae2c8bc8d3f9b523b7aa0451d460052e7f4d5cb20b2cd208ba3efa73fc2cef65cf75d1a9ff26033b53e1e3e1a63ebe425019f98aff93cb8386b8c8916e589894ef2246a344768b53418688031c73cb81a25f9c9b4ec80fcdf78a52505b86ab81347845e17bd526120f6c03c1598bd639b68f2e9a8e73f1a436725148c974d4f863f55f89b5c062a03aa58785fc65d2b73eb54df1ce34d215270d833724b9adc431d3d924f00571f149e2c1f5784eeb59e3c656dd01568d87bffac5d682e9deecbe243986ebb5474cd5378a99f8b5839b7b781070b02aacad57ab4d944e3866e19b02080a12ad08793004f70947b54b6681be5de5b60fd475a23df9b50c096aaf7e963bd5ac2fd87085ee8d09d1a090d87e11272eb476bb753b8b86583077e39308ea055b9e097b3537ce9c39e62a27d07b986be2a34f3239a044aed43a823d81f8b85e44f2d9d8380a03d67e8f91192718fc9973c3aa4b44cb4492a05d77a9e1f4af98e3b598e6b16eb0c810e4db45db0572a46ce1724c11221d15db2b60c523dd02d4ee411f00e776560e5f1f87575453ed9e1705429789187a40c452a6ad9d10b3b3b5356d262c5676c4201b1f8cecf2fd9b7a5c26b3a3d025e54729600e6e042ff40c92807124a98dd4d8996c05055295710eb536a92d0e1b0f3d83b6bf2509bd1d066aeeb0c80dbb7ffc2050b95f295564086dd57ca650dea6b318bcbe109b0b377672196fe6d4d4089614fa121712b55f3230dd1e3dac676360c167a6d26683d842036b0bae35e3a202b9e29fd8cc4af092839f71c88eaacfee5c9dd4efe14d61b0c8ff610779d7a4c9f221ef52cb85d76d84df1f3e2de47101d30b6e948f40e5b8eb80e8d0a42e03cca3bf2e693803a5b7e21c3d59fe727c719f2d9a61276392cf12cab099ec9ad42d2970c28e55cea84750804fb4c32af968b452869014e1db85a91187dbb7c0435d7e6c889b03553ae008790d09fce043af82677519bbbbf3558e061dd8521f59e33731a27dbf094eb16fc85ab775c5fda5735ec0a11903bf4b4e766934f6cb5a535a9d5fa5c052bad5e8e670cb9fedfda226ada46942389d5e3e0c0379fb43dd654808da477c5f10af51624f19bb72e4cb99e088bc3b9bb27086611d3ae94c6db0db3f6f1c9a5d3cf79eeaf855ee2dd71260696bfa180290f16be4c8a6849d3dad6b4010ef58a800db38e962b6c485a431ff4b04a7d9523f69537a56bb0333bcb2075ba8c03022a00a75ad19188c4f222d6458bc9288bdab63985608c80d6caa73963907b83e72a5dcb53461cac244a5268455f9fdd1811620c7f53b5f38e7c160859890bdfacde19f860b8a5d9c940b4918dd2e80c19b184e762b9b6aed2a251528ce8f67bd27f0a5fb6097494884c24a15cd3b2877875b0defbff8bd077dc0b0190f9ed0d8bd641a0aa8a45578932f58c3f14632924f9835714465c1bc09c366abcf67a2901cf788e17bf3efd6f001af0a842dbfda92452e7ff39e3d1236701f52fb0506ac69a097f34867dcae7eb2ffeb164c20efa976be133a469fd2312ccc2a2f12543479838f7e3e5d81fb4250e7088562cef1df6137e59777eda53bb940b7ee98a0c64e43c2a62b2e382a59670576af1215c533d7cc5b299afa400e4e62f67b06ede4f8b9418847bd3938b0584d515e742c3f69cac8aff2e7525d0e439a035dbf63778af6ec1457061bf04eb15ef3a5b223681e62f4ad8f61f518a496ce4549b5af01be664e38ea68de452c2057ddb83b5675fbd6846266c127083154c471c926db6adadd37e76ce129536e03aa7162c373727a08e39891d626cf1cfa9eca27c61f2fb2e3d1bb0f4e20310ffd6abc6d9793c7e4ac5589d2a6c5619408bbb8e295bdbbf21c3b1f2cb8d35388d06f339bff8cb4650d51ea5714541c9de41f15edeede284fec1dc15a81c27913526a624f7b6acc235667957773e76a98981be4e965e9d19d06d0d24ce7128e54539ddc073b0d273d0871f96ba0ab627a8e2e34d31359516ee244fe1d09625b9a7113caba96183021d7e8975f309ff48c98362fd2e128f38598ab779e4819fce20f6e4a3a975a98f47eb177a599db1942d1357f2c5fff07a5d8f91469da9bd988c98d5e214ba4e5fb17db6d6f99b1938e00263aa4771afcb0766edb08c97f2f40567ab0df97e635cb2a069042208599646dbb665cd8ce88c1701d199517372e9121f566f170db609410f5c60e959e803a8d4f67edf87a18591ae533c6b608ec180721579cbf6c7cfc78b80cc2b61c3e268917ed2bebd224fa55cfc1c52b8e701ce8e695e0dd850c1292e1ac8c8a865509c03afd9885cf635342f3f55f3b23bc598ec5c9fb98083316bacf8c20afbddb6ec807ed1e1f9063ed2659256803af89841da9fc12787801c0bbb96adce5eb0d8598198f4769f7ab32f96547bf20a33ba0c50d4eb823f5e065be127e66313150537add6ebef2d8c109c02a896b3dc017f3b51f53a00d36cf59e03e08a2796f475c4cc3e817a86fccd41bf65672a3604ed481633639cd5db725bd4afb82cc9554dd613a28d5b0c3a383ba5e2941081ee18c6685ca8391256cb770966778c8f3dda3811f93ed78793a7604ebc3d4eeec78181f732a6efb45293feb2be8989f3011d7bb84e1a97081c0b73d0d60a65fc1230e20206fc9d5161dcfb426da93344e7f5797761cbf4a03b87cc538ea6aaf7db41efd6007bc9292512c8bf42fbe4e8f399f3f91287d66d5abc4e2c2cf93f1a3ad6d17aea1cdfafff0dbae4e1e065cc0deddd440d14e7be9ec7847aaf240fae1a3d9fc22b5c6bf4bc7098276c90723901dcc1900b6ced3fd12a1d89e62ecdef2be19ea1c697402089b2dcaaa8ca6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
