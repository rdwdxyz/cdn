<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"598bf9e625f3a2d3fd83a4650a13692620423a3aeffaacbd0d5e52acacfcd3a73c1085498ea5ecae12d6253ca2126cdf9bec4e25948828cfbfc29e1032bded0ccee066b24b580718f3c1b9cf82b8cdb96dd1a35a380b1fbd2ac2f32c36f96e5f03905ffec4eec30549a2b0852f3b62bb03632e20e4961f77daba7cf5a0f23fd80759edcd596a4a51e7747d33482b7e49bde8b3e840db3f60607e462cd0386de4ce059614dfb10e1abbe9cb7140cdc847b237989f0ac5d775a398df0bd3a281f989079542fc29730e29177540a5434582a2ef7de993009be73646a9dabd8c3290f15f6b9dccbe24885d53be37d88525ece181566b88eee1e7b9b937bbd55e02806a2cf0c43c361ea5e0c5fefb8312f54d43395637438a4ea515dcab186271870b571ec836adbdd7c4764e0772d6eed4ec51a7aa379782d92f88511a7898a103c52685ac82c6320aa4eb7614b28a8b5ce6a15ba99a2d3b1dc813f180c17db803c7af41c44e42c7af3c0e87a91ad09200710f20e53ea03319a4e633a2dd142ad8f6216db05823c5bdf8199a23bc5e87b5c372864f962d9b85a74a021f836be482e82891df114aca231a1f7e1f5193e6224a645632ea645fcefb4635ce631daa28ac9d7c1250919e6554753f67c356ea0e23fdc9a5bf296ef132be190678df1cb30f936bc9f236481514be603c74885005aa6873bd4b421de85f919c6c7b8808cfd59434ebaae7cb75c34d5a863a0076cd2c075454f7ee8f25adebc42bf6312ad139ae65e7e77309ec2d6c49512df3d6492675d1297b43e4ed43c115a9fc76f67b513ada256086262361da049bbaf448e39ec3d88493f9443e13733aeb7ed4504eb8895c611b8cacdb6d548bd0fc8cf76117989dcd0ab9717f481d7a0e16c196c5965f5eb10f6498537dd4db00b156ba8266da327feccf870d0524e863e960a88f567dc0f7674768eb05192460ee77965c3b076cc56af1c85dd9702ce440118e7fac0dab8bcdbc84abb5227f972ca376070ef16ca58ce09a00847721687ae288453f3ada10e19334da5f187598ed581e61535ddff7b3c3dc1e2b41d11038508a5778fb65395eae7f9405be92dbe68ae71e8ee76e3ab1e43800c617cc29b21d9bedc8541aa6e40b57102ae8cace9470bd89e68d29581193702da86fdee03208507e15611e2a2bd2539fe3d85135fb5ad76a3b8460f67f30c4f5be3cc826af2d4d539d7eb7b5fcf2cbf4846af7941d79c3968e4f438a9efe6f43ad83e33bac9a4f6e2ce004613a6e8bee57c066f686e693a87c622bffdcadd00036d41d3ced8302db6edfd56912d7520712e504ea1ab7c028c1545173f0bde567a2e1514f8fa04cb963635842458aa468174edbe3ee72c001257f69a8a4cd17a21b26f486db066e22bc17be36b56f597cf728174a323e6aef609120a3f47c56afbd5061ab272add042c8d5cfa0aeac10e575cf20abffcef10bbc83cde738c7ede05302226969d807f87c88c339ce181d7e81647f6cbca93d258a647b2651ad196ae6377a483acfb20d819748397435f631b3b09ce2d4b22e24d92c7be13a3f8963eadf1b14ea1e556cc02cd97a0383289b9d8712d9943db187bd55a71a2f0026d5ddc62e37c5f69a5ea0b993c6f446c53cb7724cc2ef2fb927100a0f8c9dfecb3fe83eeeebd857b8471cf97296b6036d1d615f774dd2516e781b61cfc20c7dfa5315ee578f5a5cb8f9a179ab57945984899572dede2aa45f46f668161b9b8797a70c71a870a278a8c0a4743fb148eea5394af22997b7c9c0206439c1f860bbe61f216acfca480202b8992e529c40bd1fb9bf7fd41e2a8063ae347939d389cb342c86d82d6a978bbc79e63acdfc6cc813a92d10d1f92692dff8adbb5e3ff7f317dcf29786717fe4fe3baafe35e55f57cc7a61dbfa52148a2aea90d6ea44175bab437867d742402a63d49b48319a13467ff45caa774b7527395471dbb510d8b5d94405aa75ac406ce1395e9b53c581148ae9de4ff81f26df4f27d4bc35c38632befa640ca9f5e5ca99b4d590fc64bc1c22e8690002c60863b09df9807ae3e1b0f1c431f4d81ef8431d6f797309f640b7d22e4e46e5e9cb145f5c263f0f01a385cac0b6252e4a02f5c445c8c604d64d0e08f2971820be301749b04e9c35c59b97eb1b3fc37bdbad0869d0cc807beb7220977c451bcc896a29b5053f0970e8ab56b26e8c4174035c7310b1b1a3cbe91b1ca9d4b25ce70578fe3857c0aad93371ff8831d2b5bd8976360d460393529e64e7d459c4f7528cb9ec28bcadff31b62db8749e1fb0dba23c966e2924e6d68bcb18ef004d965a1aac0b3be4b18a284f0847bb89cbb1a3592903ce40513effc30bfff1963a5f4f401b669d048fd95214ef4a0ceb9c5d67fb1b17983c1bf6997b9eaeb78bbbaefda16a877227e8ea494a9f92b31f754164c4c92aba63e52d2f2232d9819edbd7a867b92d8999ea87ec11e16cc10a19ef87409ad2b327811676d5fdd016513eddbf24342240c8f2fdbec4a115e709101e77b9aa71bf2f1b55cae709afb6bcb94936c497b4ba7fa9acdf2f0cb65639f3ca9fc1adc4d54e16c1626e84f289a0a25f5ed3d6ed63938892727d7a981140bf47944132520b3442e0d91b380eea4f04e51bb1c0b86a8feace30ff1d652c098a2826025ae3b504d1a2a8d7e28c3ef0d35384f109af9b879a07bbef15294df358e21389a53398fdfef36b448d8ca58f07b289521b1876364a875fabab640b14503d0926e92c55ec37362850ca2cf1ab3a7edaccfd9099981a2064aa6542c24d06860fe0f9c3f20becb85960bdead6fd1b807e35c80fa5b1fafde006634498e63eb733b599cbfadfa794fc3746243dec761bb8595e3f4b398926049373dab93a9a5d75aa7daf881cb1c6857c2be7b238c13f1ecc1eeef42d0f3787775c559df16dd06251a846cf801defde3c497963ac4bb3b3734283323495d780c3db12e39fa0993a57884533b0f50ab4798de123ba30ac4cf3c93e157c649be430a2ccbcdf51eb4b5db36d3ddee7cdbe1159983934466124ae8ea89f3c253c17bc68e3527d04b47c1c5da1925c076d1e6e5daf27ce6996516828d0944d117c35df05e9fe794093223044bba896b637d51bd66c7c7214c6228308d046ec9bd3fe755d6093fe193dca32ba6c60804d94b18532cf2f059e15e919d9c540de2882e031477e5159387e9d395bb6c976f003d92a4b4fbb42e361d02ee32371d16adf16903033436608708c4009116439a64cf77b410a53a2565e5605ae947209589d5029c14584b282bffa69e5129c9bed19b884c9373d56750fde40b24a118a8d90e673f28e4652d6b69fdc91a71e1324cba77f181fbd64f8b7cd9b4446683d982918e0cebdc0b9febafeff33040a844e08d77cc4fe40109a650da211a3d240865947f819d000f86ca71495f22bbb30e06b9953a35674a1e69ec88cf401acf04da3d5e1e3138b586184132ec708de870f7861df1df8c6f0d25ddafd204e933fa0929159db806ff7e1886d004b63c1ecd61e18d2ab93fe42283fb724d72ce82622ddfffb8516e326be916d0ae8d2cd1294d172f8beb41e9559ee6a3b3fe597242eccec12aabd7e5b1bd912eb4ecd224ac11e4c5f947770ad85c97379fd775bbeb14dcf505a4c80708bc871a76218bd5f1de73857e9bee2ffa68d448bdd42979ec8ce4b902771546a7e3eec708632d92ab150cef98b61fffd763b9adb5814a97f4130785ceb7d2b22379a9848951a376b578571e9c6b5c14b94854c66a30ede9c02ee4414cc2ac01b5aa30f69ee4eeb8a922563684175d62049147844c8717d5820b30685426fc1b35928472b36099d4f3e4296fd9a3a7def219845b10f068fb57fb8fad54e5a32d319f206a070d82198a2d8ba04f30d0ae09a4a7fddc7f301f19175d4a14363845d5315df3465683bec321b52304a5637ecf254a5e16904751b5a65bdca6b3fae51220394959dbb86bc5d759a211ed30208a7747d7ca1fbe4c6f28a3b5a0f14fc16a1d430e6ab2b83cec589981cd61fb344d2009d702187abe29a9c92d07662f145c312598c35797397b27e2a5f7b468c59dfe4f0c98efb6e9d6a87e2acef53d4cb123345dd3dd1d4cd828b3df62a6931ce1abcbadfbdc536b439a6cc11ee50e78f8ecf02ba4fe0c7231daaae3b3883fdf6eb128284814a12559b2e7c9e4a5cfae6afa6d2329ed7f06b8fbc2b4729e755b035c29d9666cef4ed3529e7168680c65e09450554e0b89adb2ad2be35d080ed74a7e07933f722c280fa1d98f442ed9029a65524f28431f6ca1a3fd7083922162626a35b61273213f8f5a70639230227aa5a7faf06f918c761dc735768531e615454b1d40fa4e68d9e5e19f017c51fdeaeb6cfa854cdde625665a48cbb00a3fb99381956199a333c0821f2712250a51c01cde6924f6cb541728be0b486ee693007561bc989330f8a05458d8db061d02dd49f996bf109222b277dd8a50cf5a31a6a79fb5cb50625e169be5a5ac479be3645b2dc27dc833b6d3cd5e9607c1caa1cd209513a894955d2a3696c21ba6fce0d75b5204ed218452c5b7ce0892e7a78ca8c864999bdddea90b082f37631e949e9959ea7392be100a960fc2ba8663b0d90f19b55b1a7261290ccdfe5f49565dbce44a171c5501a5b363991f3559d6bb1fb066671ba4d23a3a614b7b2fba8a0fea05eb0f7c93dba61036b35a05134c22d9555516fc74643eadeeb898d8553de048e0d65c7cada69fc2f0579af63bf19ffa5d699d22a773dde28f02cdc6be5e90970414d853db0f73c019ab7af402d3f22a86683cbd7d7a23463133fe0bdbcf1d3aa1bab62cfd595e7f139598ca84a2fc7fcdc0c336c5b30ac8d6f01a9b2301abe431a813a09a8a6c826c42cb2071ed14260551b0e62d810abc55c52ecb22f48d637ed46cd0450f4b2e553d549e10f3d2537d7bc8369b09a54d48e76d46683de287263c5d54484e08a16a7e71731af50d9d1351723d55c8fd120edf5c6632fd18726130bf80b67c73b33bab0f786e4876e65c21b4fda4927f60efae7011c9bb3668cc2322834ce2d8b99c543e3cd501cc7a84887098058b9bdfd7d284b570774f8d3f8632c1090ab71389bfc1d19b10835a29750a7fb3c67a6da7cef07fe916df464daf8671b125cc82b0fed3115f3c709a08576b1cadcae6510821d38dca6ea807d201b2e64822ded7ec3b9a66b0faaa8c1b9ca1918129f5f60750e6eadaa7492b2a43e0d75f6ee3096a2a8affe1f759451d08c5b12cfda897d77d1d2844df7fd41aea402e8542c61a4efad0c8c46b385eec72a74f42db789f95d9bd1a904e1c865442df99df0b21e23f5c982b2f5ecb076a62e783dda0e7222d93ae7de44dae5631111bc9d9d537d345c643d97268da2f44ed60ebe04fda6ca9026b7e89ee87e95742d6434f5d67aec3a15b18c86bee1cfe7fc529be7cfb32e06d2dc256ca5503cf7d49bf543c27802c88ae231c7ea505c2b75cd8635829aa53fb6b5af3cf68a92149ae4378e6455a5f1c59772bb98223c42a120920a40f96765d5f634ec1d5859b1230915dc4fb38228d84577c7e324e13a25e6bc1f11773386f7fa01db97cf01dc1db85c1ccc790279f270ddda19ebb150a6fa0e93aee9cf982dac926d7dcfe35de841bd46d0859dcd07d075a5ed66afb140f704b3c0190466844eabe0b78a264e2092070b8409534387275b3a30687c5e078a004f24fa72aaedde0fb5eeeaa64d1e890cf1649f4055ec2e4153fbe4822e48f2fd5b29b812dccbf556d22eb89b00df0cc45ad59f3b3924c5506e1b1ccfa70b520774ece78d56b67557d6d834155024cc892e79acec1e9fb4aaf305562e6af6a869c7575ed60e59e6937ef607480cabcdeff0bc702b3b6d871fdbc50912403dfb4b600c2656dfa9c185e1afab3660b178040d2b57436e4d24ce6e71af36851ab0970606e1242319097cce57f7a0f85d8d5a72778c5ce5c96f3b8ae97797621ffb1775e6fe6302da8ffd9e87b82fef138415fd6c146c24f764b235d52770ae0a6940e7f401ca62f4dcbecdc96a69ea01d1aec9e0f3a48f06229ebecd1c3ef96c3fb2b83c72b29741f2fd0fa09d0283b2ffec1d8cbfe60f7f90a4bc6c870c4af6c7ffc8e24908324b6a8911fc213fb130acc78e2a96845689c7f8d621b2523ecf0885e03611e9f684c14d27ce2337b3c06c55b89f53f590faa6febd96b282cf0de5fe0b7fbb594e654b4ea9f0c09eaee126ac1297613be728dd6beb3de8073858556dd5508b2a3c41dd8fda4fdfe78f2bfe2e4aa58e74fb3b5682795de3cd1a443c3475246ab77006e496efbd09048b624e9ee58e25fa8c76c8fda59d7915e7eb58dfc443bfcc32fadf92708d97590b1d324d9e86a4d745a0dde9e94f4c2ef91375630258a29d0b2a78132c4a04450da40df438391f81e1ec872d4514b82e6d765bc165fc4761969eb3f23f30baf7f916f940f93996c95f2dcf4671af8ab1128e087bbdccc669b1363e711beb863904c46df2d10d70f047a02db68b16a48917409a84d63759ce0b1d9016d1bc2d9d89b0b73e7eedfbeaddf4056128c84bb052354cc3a06284a3e84820008dff4706398b2d6099466be87d02f25cf207cfa9ef49bea03d81aca6f62fbc89484413dc0e78a81481d177d1a82620961d64ebec7fab14d5d786fb735e5151f5600b2bbe4819c0668148e1252bfb39542f7db7385fae04d4b1e432deef031738984e3094fd4ece36ea925589beb536a033fa1cc9b2a329a2026472b8b061eab9e8d7384377b7f8f543ce739c1ee578d123da46ed728613b87fe9ed23b7238de631ec7dd901fc57effb7bc7ecbedc2671022de97fd5321b5cc2dd2042927b5a038099cc4c50ca26c15f41661bb78869fcf33f9cdb706785f783a0ac54279deb9d1f349eb3ac09c26b921756c1565898937258a9f275777f0230fb3b5a17a24bd4fd81675894f57a8e07059ce2092c335343c40372af229329f9e3e01abe1549de7c1fcd72810b5ae337d5fb6a06b7119f69442bb559bea4024267670609b6e8bedc0c9b8bf5ff0cac555f60e675b8630e9d781a84deabeb356fdaa1d7f5a843656f31c4d88dba29fca603a472b1c831b38729a235aa8724b746e24720ddd022d30ec1b404ca268d2da54944a08010788fe3926a80a4a360849acba15e52a5bb23a067d79b339c6452eaa07c4623d9271d8dcf6f76ab42174ce30c49bfa242e8970b11fa43c9d6ea4338ebd2414a32e9c0a6a75fe5a1fcf30c8fc161d5e92e57a4f30ddfd949872298391cb5841a3817c8cc5f49940ab106cc67de8e69f55b7a284026d72329be9527e3f616411d5bb177d11e267f066e742165197106dad1cee131f837de47ae7e1a45c431e968b06d64376b584d40911d05f8c3ad169c9f1e06b61bf193aa8e6735629c5431c46672e90535f92c94d756992179a4770e1958546bd238285df5b0e61a8e95c8a3723839ae58dbd6c30705432729097cfb40049b5f5e47c1e8e913b82b190c526b815ad250ac0a8bfb71d484429c48cad900b1403eb5c688a82beb4ca763b5d0b20f2b1f828f3a562560f754f5bc0f34a2cc57dcc6650f89c139b8f4739657a12c8622a7a95f340f008ef5114bacdf672000d3b34a0446515cf9fa5ef6fe7ac583ac6e9f8fd7f8f72b4cc5acd19174aa28f926697789e62633c5c54125bb0d4b60dbdf138cc28de5c8e0eccce6ecb1e3f6c777b3673c703e81eb499a82461dd5241320bfc7fc5f0397106d1ef6d43882c63edb791d923939e80650e5a577f7bcf54563eb4d98890fa34a4084baaacd838a1d88051369590b90da0f10f5c6175342dda49e3c3a3c4d3be2720cd52f56162659a3c518251ae10b8e5cc5bf976e6c86d957683507086d9dcd3845c7f1b0172e686f7167789a96ad07ee1bbdd3e6193d0ac5bf1a508a5dbb62bf55f67fa60ff68e16100728d1ca0dccaf13ab375184a35524ae55e9d57252d78da633aa4db8c766fe6d47bbf06832d8e4db10c908c3dfe99da9bc28934098a37bf78bee41035f98d33309005287e1174321cdf982ed4901e4ae709fd31af1d2c04e3ff592b6cf1ed1caa0d7d04c4a5fe1ec84cb32064ad2050712cd1d7262aba7eef79e95635ed36ffd77618e7a4af329596d6103b11c8f527036896063da27373a0abc2bf53c0f82f66c419d7fcfe24d29552053ffaf322fa6f10352fdb182395c31ea2e765bdf43104cdd9c5721fc5ef5835daf896651cd827dd4b6e63a86262f6dcde2b5613be0511c531dae9eefa1eca8571222d0c66b3eb1a87cc218c76a17204e9705f054d44709b58118ae73ea72f1ee811cb3845cdc1a12949693856837a55b60dbbe0e7bbea6b31545e8d0f6a924620c4f0b4577cb041b885e5361572b6083e9bdc47d817cfebbf089f0cb883bae5411d472fe07208fbfc34ed35d1a7e6c6687986ca9f02d9ae42eae5b3b1bcb1baed3a14b320831e971c7fb07bd52883433ed48ceddd4f1429541498d5d5d5220410fa6767cc1239096d1f8aa7d019cdd42bd7aff755ae5dc90092a557f6f52647430bd1287a0ae5db7fe5fba84c07dc0853cf31fd74fb05aa47ba28706dc1684937914b9325eef0459c4bb039c3121584634e86e97f83d223a20f60e1c47c270a03e031f6c3568323d9d6928a2323ff5cf2c08fe49e640168eb8449141d4d0ac14c279646dcfe4ce47fd5893ea031cea522d04d4ee9df80987dba57f091c981606156fda3931aa3383891a57ffc2b6131d50e83a583d4e771ab4bcd9b2c5aa26865024f129a532db9e946196b10c9779607e8919a54b288008d7a36519c7e5452592bdf3e1e43233cf6adcf1b96840445e7549bf8a8254c29e9de24572067e08e151fe5107ea016f07825c9833a598ad210c6e503e091fa7927957e05f9e6943fc056b5d7bc067111c4e5da37f4e6658fba6544396af5d016277c9ad853b4a1f8913bb7d14dbed5c2c0c0236687386b2ab3e7d3ff4922f86367631e4821f37afe0e4e3497a1a3a545baa3a08b893a6b64556e02d06e41edeaf5fdcbcdf8ef767ec75506f11469b3c4c67e8282aed9f14b2d58d89b85ec07de1f236c9ead6f0800ad0a05239710860ca9b05ca3c23d4b2c1ca86779119560c52e75328ae5b8ce56ed2cc6675379d69bb44283dc5d146cd914af2ecbde7b9e603346e160b3c013d580aca27e9e561991687ce5552153dcd8bf987def4e68b7ef3810590411fcf665835d9a1d2803979e23dd1047615b1f3afc70e80642b0c84442da5ba7f078c5306c5fbc6bf5d1f0f3dd724dbab88f991faf4b7b54ad42fa1bb4f740f7c45495b651e38e73e777496b482ddc4b058ba6d223d183a28bd73b5b97193f04d3f82e144d4f6bbc677d885345cf641f0ba3e8bf5161346c957df745337baded1b9b1230a32389bb68f456e92c6874a8e59c88fe1a316d7667132e22b0d2456bbb540c3aed55e7236be0aff306daa20004520d94ffe23e022b47f9df7ed8c68a11361aa9e38a9ffa2bdc59c5a6b67406ca3d51058a953e693014df75bdfe992580e629c5f103423183b0287fc60b6b46a766d5c2d06963b50d5bcf31a21c49afe672d3437ff17588a6c62ecf17a1cc970d4332d4c9ee2355013e6c2afb9876dbd7d91081b0b5ab5773bdb3af3f1577c1dcfcbb4f0c0d543cf5d5d3c974d80e05778fad101dd2d1fd682477c19f34d3efd21a02b6aa96bb3229a58b07d78e1e01f20947ff2354cb348cc3875b3fc260d72851cb3c22476edac166e7bc822682a4cb86e7479899db4c6803eabc7320ca416e604d2cf53665c14689a7c597bba4e039e5c58cc44981b320d11d240e32423225ba1c0d644da115242bdf5eec4d3bde1878f18287bd0a00b5810860de4ec80f186b5d87376b93d324609574c8c9183211592b79193c46d82808001aad68b6eaee56e5318a7af3f04e4e210f82c24de03987bb484b928586d0c79e0506872f5150265be77bdae8c5bb71e656c8012d39c365f221df1352582ff3110f47f63ad0d758a052e3eb4d846e80c2712f499016cbccc4e91de36845208b3d605509f2e1f511eeedea250275f29e18681376f0e036d551ee59a89af6ae04e569246c63bb36ec71dd9bf66ffe0b6c35555f1859e82575774d983a19ab0f8e034046eca4fa7a294f120fb276db8086c27f99e2ba62d1a63927f4a00c87b3bfbf7b99294c2d2401480b87fd7e5e18518cbf3740fedab8155017c0191b71fcbdfa87891e85eca9721b4faeda4ff01320df85d60420ccd13892a2fd2f33a1ab8cf5b2e307483f02b29011f5ddeb9fd9cc87ffb2523864231e82dc6456a3b5b61c107df42709841db111628cd5cde9d2f6ef865036c1ff04e9bc0154b5d6191d80df6d7c178c5180c9cce99e29bd1c5f8d4fdce8644435672435df516fe964bdfeaf071fab7d27052280581f68a12eb80e6c76c119dd88244796b64fa0a273014279e2f82a77d31d38a880d5d338c9f592f0efa3fd58fdba115a7bc193ff402dac1c75533f9d0fc0c233db86a5feb6036480f13629aabd19215e3c1601901718be1f3884bddf7ba053008028f8d055747066deee73716d9cf410ba54d2f8d6576e1038ee6a47385dfcdbf5f2313b5fbecd93cec16fd8dde7a4090f53bc311ee93296481a0d2f3ae26921501e4e66389f85b2d5d62493dc284998e6cb19ab4d17bf9562828dfc4474ee45e9b1cf6b9b16e0e390be5e4c4340c9dbf0308c6af17e1eb5a020e862cf6f92fa2b3ac21dbb462c1d780013b00bd8898e6961d60a4c837f887b98430b74c1bb76d9615b6131d199a4d8b32542a6badc5e0fc3227b65097387d68ed4d88e43bb06ed45ced2a9fe3ad9e361660f660f0f8d95cccfc5a7f0ba702062d5cac7b3774416691bfd7ff707cc80b575ae6cef27a42352ce8dd2127af7d08ab0ac47741e9406235828d70a158758e31743e1481622fcc2815500afbf17166d91cc34b18b6845ead98fc54b629dc55d3b0ae677db32c31c690dc8cb7142ae057d492b1da4d0558ee73bad84d4ee35fbe2058eb5318faa3e2f271cb017b008817b24995c0d60a818fd3aded10c390e411fb1cc1c1f2afc893e0c211d0b2282c024608009c4531ac22d5700f62acc1347c88248f720450bccdd51222683ecaf030853c1865dbad8143d1fa5ff57634e92998a92bd98c25f149560d62d5be5e2857ba20e361983728c91b83e6a7d9d62bcdde57ddb55892c0ef0610809e585ae2fc0efdbb8268bcacc985d356e8318c8fae46ec31738211489399cf17efb17a7b97bfc117df65f64e7f085ed37d9959c6d14f8eb63af5c631010c2b343bdc8a716ae40fd7a0a267932b2b7b9dd92660e679f287bd5684d4898416c28a7cfc6f62224e9ffb5336ecf57b0654c01745f3ca171e31dbd172c06b330b67b37a1b1ef183e57bb42a9a0bb23b99dcb7bdeaafa838ccb7946d65b525b1242a7e7e9bdac1ee62adeaf69a0ff46e6474d9a06de848abc735ddc4cdaea90e185b0237b0c84a183fbb85a961412cd8ee07c52ee389df8b053d0f2f9b614f4f6d498556093db9bae19a7fb212c5701ed2b898bcfc764aafd51b9de9805dbadb264bf4b0417b9ab908a0e126aa60ede05a314c55ba15b3b5a5c9561a08498a46e09cca819082ee5b082464bdeaa8d887bc80774b386e69e4f1416c82da886b05001987074decad7d8c05bb36419dd1c0a29afdd1ce8eada7b3d86accb1139fefa7d4d8257c9a3b9a272682de7663a3f9f94e64c25f79cb0cf9248c79bdb7fd1ab69b66c08fec3bd7a8e5259c80cc8e2d1ab54495eaf99e2e70647015b90492401eb1f5a2ce741e2d675c517bf8e76b880cf9d3c2e7de8cf7982569d4440cbbd4a979c19f4d2cc9edbcd60e7176c9d7e7a87eb69c8cac3df2169953a55f7af81d35175e0ec1a4fcc9f8ce292045152c3b2b5a5f891d7014ed16d67e443bddb9002e6362d87c70ff09c2423e125e90271417daaddc2866d8c93d555512882dce9de673aef043b4a377b1338ff22d139b2847c03b8d9db1dc0878eafa4e24fe7e72620cd41b6d52110075e523265ed936ae62cd37801ce5e1cc609631d9544630e52cc9725b1ac75feadde7c5ca18180e5c9be08cd0776f32e062e01d7a368fdfc3cf5c6c355c61c21e5b01a737987a27258669db4220eac2288d15d82ca16f67cb438522ffe4b8cc05de33f07164f6406f610596afd4b3cddfd3690a9f8fac2af80c26c2ac84b8de88d84993b630c75a368441150e9235f24b3d9a1efd080a6b86410647f8c80a4af915e86bf502175f88831281741c0aa85643c91d677ac0d01fd8ff8ed2db45070e83c1dd98b5f1c02e9e36b8da4a78a9ecbb449b89529051d7b3df3cc55ee93000cf39358f56785d93e0eefaf38134a05d2abc8be33b018f844c00db641b7b12957844c90de947b397ecb5bac7eb01a4e81223862d6b10f30052c12e88753c5a1bc4c261bc29b45158f493feffdd938b63517a11dea70d3f8704a3410371f0cbe607c069d57a5a9471959894fa6474dcb78dba455679d3a5dcab8b5e7323ac14a41c22719d9b2bcc37da47d12a639c4de263506fb94151cadc99ddaf96c0bb33d65e3b15cc7de33122341115bfbe9f5c487bf0a6b659b1a58152e25dc365356fb14c18ba5cdd4b05a0d15c93c0a375e5eaa579e7f9c5ac02b23cc5e73f2562c6e4c9dd129b69a7c468cbf6d3305a851996751515f38385eefd2b80960bec10de5f792ca903276b97c2b7f5a52b83cdc508233cece9506e71315b89e7ad6d50e62dde968440465d660cf71ec6a045b7abd43e470f443507b7c0d57363b3e8fa1b207f4c7774285383cae108b03e85b5c2a0f23f66953917603188138704b59906e04aa0e996a1b7281964dcc35b3f274481b103be7119a1a457b700507b6e6622082ec647e69f194c409fd63ef22225f9182b5fd368b9a99d566b471a3168d8c3d1b65bb99ee363b3408f2e1b0f54cd61657e1426e8960bec193fd1c2eb972e3f4dba8a19c218b67208d551818defd77b779f06415af768c5d11a97f7772374be0ee75a4e1f14c2beb3738f21d8f34741c298e0606e717a80cdca604db9d17a05d55a59442af8a0228f3385c4b4af468919ec4c7e2efee923126563200bdfc18d1399846d92b46620b541978def88f822a0de072f568726f98c071d7dd7268c19a50e4d080a2213010c6a5e5cb2d85a05164e8246207aebec1dfe6b7e5aeb380c61ccb23b973ff0836b252b5a175adec0d8da1fe55670d5fe65dc87f0d972b004e3a6de96d65a2af937036f04a1e473fb9e7250d3398ee1575bcae584fc49b99af5d43a617d44931f287b3a72af7819e7b85f17f93d2d0175e4e42bda967b40ac74ff5eeac7fa2e5f3fd0d61fa35d4f2dd3c329925c6c4e249e57e54624b74545cb3329caf520dd1f531dd3d8a4ce779a7d68eeb04b131960473da07957dd89be58f61c2e6ca66b36ecaeb2a38449641592263e3de6e49caafe542c7697a5500eae54124a688b9fe933fe8116f4f3614782bc5cdc7e85f4eb1770db921059a42ace5838cf4d0deaea6292599f6d7dd7082c7fba0cb44a405e22a71d6710781773d677c92278288030be6a47512ff9b65ece7b8adc203ad979ac400643e0afaa97e6af98ed52f44b5670ec3aff53075174aa28599ed9bf9cf27c406e175dbea93a53644ab10a5bfd24341b22a2cb72f80612f9173c8ade737a3fd04423f59ec57d20bbc9dfe9148e99e91bbce4ef23bb7b63c99a451c756ff38dc09bd0c054fc44ee230cdf5e338e8eaff8d908e277a42fef152d5017d821dd2e5f8421c3858e65d896babb159f30b5e9ae8d2febd602c1371269d18f550427a9fa564148c684d1389664263c34bb9a46529ec59f5eea2e68c0b377ed9c17c38eb952e49fc1af73fc15e71dda07e5cff6b481a039b88c07f9c536f7f59151ae6c4212e1b187304932840a0ff9cd275ac44e652f3443d7b4c1cfdf6385c0fa8334ae0936583781c61712d4b0d139709835850312db1682ab5bd2075759a2bfac6654093223005f3b624db4419619790a84db386c1982b8f30f193805dfea28bd569232de17f2b65d98434872600400e3a22a20110a99c843ab6f2844beeea06db6c77bc5a11634c15c783665dc4d73f3efd179b45b1330b31023accbcbea37d0eaad3aa7d91a1bf6454fecd9dbf5699bec6f3756d2e5756d8e86ad56ee9f1c9fa31c93b443d14e7c11385fc4cd3dabc808496ca08ede0134bfce0c71cf06411338ea438cb4e345ee1d0a4d077fd39e7123253763c450b17c43adaa967e05a7e7ee4878057db8c767861e5b9ed7aff5b07e6f54d2eab44a752403cbf79a3678953204f972bb52b81a0837057848fb00c427d8da6656b493f4a03e9331751f5764772a78f060b2db0fc88fa611db7c4681cf1795e1c484b4a90f6a3eacc94c1aa6be5bb506754aceac8ba803740c03f152623a88a0bb262cc178e3dceb722a1aff22872a4e9e02434709c627dc004acbf93622bec950b90f0ca71c165d8240c2e2428fec0b1ef54b09cbc8099b744a1c93e2267bf5169c898da7e21e9757f50356e576af91c0e6967666fff35d18454be891ee3288c0e984dd274ffee24b4730a9b4a249700f21fcc2db499c540a13f37a64bc50727f6e8d6e6b8495af009fc24c66bb6175cad9113924694b6660072496ff5ff4678e083f9ddb618257442f68fa270379ff60b10af442b364d9d8ea1ab1eb8729c40ca710abd71761edbe77393223d75d7812ae31d7574b52ed27413c89bf19c8630fd35a3ab5151d56d6deb7b21ccec0a0b627805431802f99547d3ef0f12e00446374402b89071fa6f3395023aae4bb9800c846ca9d367daeab3fb2e2cef378b2f504048fcebc40fdc5f28cb0691695994900f544feb9cbe1c69ea7c16b2432b0ea9c44dba7ba019b0f5a7c04dd21b580379ff546c6f1dfb42d2a2c179e5f5c9f67c204da1f807b5109f9c05f83dd18c900e5ec50dc77393d19ca3df5aae3abcfaceefa1fc552136b23822a258c233816e75cd9b2052c4b111b0c5cdeb36a80b215d6e8817359b89c43b50d1ba5315ceade8a952da2e7b62d91aa3fff6c636f0ee4addc8bb7c2dc6c85cf41fe05d4a881d83342dc0e8a1b00eb5834fba2d7b93e97ff15e2b4f8a4d7896f0c202b8976347c3ebc34493e3f7a49aa9e167bd89408215b916601be8fa11b268591d3905455555fd550eed83027274467787e51da4e1b2d5708d0772f8a4f48fc3b2eca6d5319fada3b7fbf80e2c7b784f60a08114006858590a6f392891e80fdf6aaf9882cba501782c1a8b96a04c1d5f3fd85296db0f0fa143f9c45d6bd3912d6acaffd288c735eee4582c311c303e5a5f10ac4df4f88a10bf546134bd282c4f93ce928e72dff8ca5305ee4eb673385bbae6da55ff9d955d2a44fbbf578ab869a140b35b60569df70d9eeda87508b82fecc0cd9237e79c223751a77496972d555f0bb76db398a86300444538e8ffb272c45ddc9cf57894669f8ffb263af821a773eb48348a44181f31cfefbbcd15dd3a33c97d3755a0c6dbf4f165ee4511ce374198a29e409a5ebebc6ff605def232ac6c5ae9cc0bd2a396b3ab5d5e3605bf2526ff44dc06ec1a800f50c69ed200c1cbd6c9709ec240f2262580585c6853062b087bf994dc93f8eb454cf61f217cdd57db4fd532e075ce803df4334e5c391435cd89e407e4b8b9465ca3c171e82f844022fbcee03c2b65e4e75f24e2c39522adaa964855731984669c69da8b877c9e52c4f29dfad0bd12e2574531f0cb7a732d123168fc86f3fe8780afc8dc98c0d71f5260d8185614dd1db09464f47322f18dd45e7e7ddec955ef8e94358737617f7d7c3560c64b2540eb640f581eba9dd5a4f3f66636c764bf05b102cea02da88d84a1b8c56b69d0fa153f3b4b0c2b4afa3e17701a85245c9a883ccb4c740fb795b4f542dd6752c2936afd63b53465bb9ada182d631645133b63aab311ec3069a790531db0ba58dfbd199539dd04550d2044219ddccd596d949da71e4587c700b0888de8153197e6d9cde95ad0a2492563d2118b470d9051b1f710f95e2a46ab83e732c996753a3f9573d559377c4591e18ee574e595980496275a9ffcd1d1ce724695d2a0058cea8072892828440b6cf7170863b3d471113e5c65b151a5a7868dcb6f2fab53ec425782d1c92a6bf9077c7be63badcd440db09c45944521a7a7f1f07108bcc5319dfd833867280a2edcb37fd41da916c035097fa9b053a36dd93212da5e430dceb4c3929ac9dcbd73b4cfc0049507dcc3947b51f8c974f765400afc41411a7d217d8e8ae84fb28cf95b17b954d924438bc9cd390a09f306d8e44af733f9f0a3c6d5bb791f94281eca74946f96aacec96623fab89023bd6896e9e17719f9ce990127da8050d43890097cb2f02de9ae3ebc0e33211791f230caa7335a2ed6a25bff7db826e6301b333ba912e97c34f3ddc80d9298cd47f9a293252aed93bb73393ae3468002574641ded2f4e880bd26e78726d6616a931297e20e123f3ec2a5010923cbb1b273e9e39ebcf07eaf97fbd8fc90221e2874359dd6c7b493b60cb2e655f7fae813ea9fdfa87c44759bf786aa5b0c627ac4b0925e9b6506b3c181d40d4d69e6026bdfad79960e49d14db377ec968ee62282d0804e8003e7f4122f1990b72c010e2ab12b5c3026a90ba1409dbd7f6fe4751bbc42b5744a967ce14c61ddcd4a4853fffaabbdcfb45aa99690014d6ca78bdac2d83138fb112c831ed8e6a6879c51902c93c4db93cd9344490287c35123264e212a6f4327ecf54d36946033d4dd63b7804371279697c6ad0c520ea9f322043771cb806bf54cf76830e27faf16c79cf01bed5d943bde2ca917306c10a500242a61a7b22a1b2af6ca6ac376da9911b11c530f8c284922804ef9576e4712ee983843cfcd41f6fa9c82e94e7b4ebc600810f21b1cfffd1bbfc6efab8dad667ea9827638e2c15bae22cdb8dbf082feff6c5287b35cf0b1f53631b9637272ba52638aa9e2a1465adccf8db66a74a55328fa36eec8f76384c50cf0c436219661c6b87e88064ee86af31ffab492b5aed13c0ae4a0b9e8984667ae11554ef6ff1dd8a0096ca9365c400f7665d5a473a114618783a60cb48661f464818682e9c12f8cd2c1556bca06f0514863fac8cdcb76d16777f9918f9ae5eb9a3f1f632a4d40ebc910e7bf7cf078bd571c9e6e023249ff41ee57a9696505999ad9fa90f8f32759e4f26785e209336e4ab788da131e00aa25733f418cbb3a8df2fd0387f455adb765609b6c0a2889c71753911cc3d61579513b407b3e61c772e3ee06f7047785a22770f51b1c62e84e5b29b511dc5c08994e7202cca4a1c6e28f05a9d7f7a6583f47205ba715e7b6e98fd079a3533fea74191893adc34636f3f610ec58e3dac494af18f107574f910aeebdae546f7b8e7720a9e02c206f68cbf5c55a482590ffb103083692538afa1c32c641fe43de0ce00380fef4585ce852945b80e2b6435e2b7a3b518c63495f92f302184c264a411378f8c6cea6c4c4e78837b27afeee59176b1ca23d4f74b8a1b5fc373045e1707648ee4e89b8b336bbf0cca2a9aee5f78acaa694025e94bc6cb16564715e061d0cf6825d4fa9ef50316843081506e730cfec31074c768b945084a842ad3c52c53fdca0a60665445ff1728006c501df902cd8fba0200360255eefc2d622ebff8cd93ab77a04b0c23f71b5db34a15bf84222ae09002fa3b42486b03744d428b0dd11726d927a39a42b0055b72b02d82b8dd052d383539c5fd4ac0958ee5ccb7d2ecbb4c629861889a24b37a47e20e49491f8e12217a7a6086e70fc715826dc2b7e3ed0eb060075cd40947a129fd78cbd04977b66610028fbb5d9abef0afacbf7f5c40b91e2e6bc802efd8abd6466eaf5cde6e872ca13e0d8dd335827183659866a8bb08bf8d2e4269e6377cfd454f173904f2852bcf1077b1dd11161ece8702b4cb1802ce3943a6f1521f59aea360d2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
