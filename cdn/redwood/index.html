<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"003e5eb7b958cf519b92060ae4a8faacd3d79892385336f8f4e1374d2cfb8d0458144eea43dc5894d6b75cd70bc222658742fb32ef5a8f11d8617ea31906a9d86d36b7afc8419f99fad676724e3be299e3b9a86e19bb5523b64367db9b2f7f931c8ba79df68c2c29310e9621062d58a6921ffc9fe82514ff06fe4f51e274b702009728954ae189ad68bc104f0dbde81231b52cab98e87cf601d3e5f341d3b3d4a2dc97b5e8e8b93ed6ad13ae9f672310808be92e1f3bfcee80be88d4e03d120407ba3dc6c956f5280a1e563f402c5efbe3675c1810fecbce5d01170136c07ede15479167ef6c7d7a399a398607915cb415f137b48dd2b2bb3430111823fb49c713552c587cd20f7f6ede47725206baaf211a8be6d82ec567785f8813f9316e4d45f28a363d11ee6e9ec7c93525842f5902d37d2a094f6520b58743bfbff09e6ba284cc484d0ec2edf1f478a43ed6891cb1a321bf8e697f61809dd7cb3c23a3a7b6ece02eafd1286474425a534e2f55a9dd82db81147445b94bc2cec7671ec2dd5d1a7e01f3b79a872528db9dc58d1c6d9cb62ffdb08b24426d87778fe1b0f60f7ef622faa98a6204f1c2acf82422e3f10f228caf8d72cf960b8f0c88bb8de9d42d40456d7b41998db8fb0abb84b7f201be35faae502ed4b6dd824bb2a22c4cd45bbef1e92a01ea7b0c8c4b61408a115001ac90ead141747f61f5329e3f2574184bb7ff5b214443f370958c25909fbcfd808e8a17b9de868a25f4b8430d4ab0d0d87da3eb460f90cf9c81dbb5d73887d5d1c3a149ab4207fc27a31c3d4083468654fa725c449b53df1d34246bc719bf136bdb6c7b7cdc0b2437c70d54d872e097f467b8c9ef21a592049fd866608e7e744ae4cf26cdcb5c14b6aca60e2716183c6ea23bb50fefa941674a7a7e391c1e29066aed23dfef0cbf199ce352a8eecc04c822de9fd680c0b2365e65bfd6eaa24eeedf99584d2fa99e3ab8629cad779997a4919d888f9dcf54fa6140c7dff813dd871a7ef4144883f8b6bf3580ef7e32d1fb3e0bb56f3b31907bb813016a15e532e7a11c3f2fa069f193fb6cf88822e4dfcad233c5ad8ea27984a7150ea18dce0bc30427818dc3bbae0c75ea43e6c79aa36c4571a28905c9f38370c5ce29d7ac405356bdd728c19b7aa7eb9a2df658e384b8aec2e06446d751f694c4347c226c3dd7e8d781a84243790289ef2dfb25186b7890284d9da6e4834324befb293ed9fd7c13a4833660de7b9d56624db75f0b614daf3b9b31c06ce70bbb7d98f09c33177274eeb32652a01de89e78de4638963e520c58e424846bdf44b6c5d12f8d7d1386903ce620fd7eb90f4edaf48b429e2847fad312067c31bc1ce3ec1e5eabca5efd27a95a99bba3d9cd7c9248d757a1ccfe52153c7a929d3790cdd04c891632c8e835440c000270ed9fd50b2239d04450d6c35ab817ae0db3a3e59667be8b471b6c2cbc03113e401b19ef48237751d39281206c4edd5eb72996ce4ae7af3e73af68959777bba460aca09647e48cfc0bcee6957fa8859eaf86856d07ba4bcb25d47d8bc3a7ffec0f8e226c613e6ae8933b2935401dc5e6c0bcd0cda1d9520813d19286b9d6e781a374e9f516bc74eecad1902486dea3ce26292ffef842c1e26a10cb519258665c715da9ca274902d61172f062d10885b0c7dc6db77eb50f3901a5ff79c4916c6d8124bb2527d52cd0071c51ee957606279912eb2f2dc76be7a4d4e581ef96c366cada51debe7e169222cad390abe8f328e54164d5c7df550d0eb1da8d0b55928c4546265568b88416263ccc9eeea7931b9781cada4a249425daf82398300b67ad074b50b2a619653fb7b166f5cd2a37bd1ae94f7b10c6a062daf42b3092d17c945cd4b326dcf5de5153a07fc8fff1cbf73a02bc203bb197d4aff0955f593b23af33a0e32d3f521a996f66541e420aec4c78c072dbf3bd1206a8c23de34fc060da79cac544b22d4f0b288eb44302b4c9dbf72202efb9109ecc8b14138905b51546310e709d594282f3c4ff5b825e95c2a0b1079d7214e90ba31f117f1a7f0e7327d7c8561f05376a89a99c55212a6ca807f20d0a3528ba52d2019e9b6301baaad7295c1659c222f9ac1d08563b0e1d66622e8b38b4bb9ce7a7836e6dbe3494d5e49b268b6a0d5acdf772933031bd643515f2fafdb5a8b90790f97a195d21f60780af16591005fb3a719bc62a649ab32586557080107d1ee616925437addd3f93686833c28cc3e34c38ddd5b46e3a9cb53cab95bf4fb0c910ab630319500409d3c76fe6273a891183d659c8545fb3ef8f96e4d39ca6a04ebc278e081dcf74437e2c7acc3e20b5f3d59cf6a79f8d924d714bf931b1793580cbe58ffe2acdc26f6c774664a6e8232a8ca246b591ef3884d40038456b0c8ca0ec8b979f5cd48299c09edd9671cc6923ff736e644e62fbdd14feaa8b1166b2d496754a0cf8ac629a6ac19f05ab8bbe6eb721f58dd61e84c8ce13abb9c2bb7ad22102a1776706ffcddd7a7925b84928aadd23124a1d8d5e466dd98527c32e1bd63933b1629761ef4c124d5e8d786c53aa6763baabd1dcac6752c4a06b672fcb7e1a24348345aa158426bfee1a5203ce4994949902ba8e3cf48ef2763f4226f11ded06915cde83d2cd9abf071f0a604b34fd457a2873f235285de3c4e87eda1e75ceab051617c1327f1a86618e39e2b4a0e593cd653a166a78d816450fe8767b81e35a5e206752f5183767a6ea15b4b0ec74c2e5b2bf2f461c6931e01e062177c0611fcfc666c826d41082b3cb01ae84c744b23bbfd83ee18e405ae75bce74db1e318f4a32977d2d692ce45c1cc34ef06508b356cb2dab6a740accd8d266671dda0959d5bc8f5677e96256167d4772ebcf56af0e13cd0211ab7f0f21036b15707ae90a7056ab69a2475eecb991c9f95deadf063ff74722225a14e13ab32f193035347947a2f0aad476041a8f381e1a08c0838c7629733a64419d66288565331e6880272e527ad50636d91d674c6f879fe8d505dc669588a46f254aa22fe488ebc0a093c45618c4f7f06be13e88b56a828c4e3926bd8887548995362eaacc182bd5eb24233dd483f6c14804825ff90a8f394e109bdc3c0e89260596b2fe5835acbbed5393305ab633393bff4d241876be7808c4f39f4a15baef81da4f39751fdf4278b6bedba3342786d8880453802a8302ac118785ad803e147613a499dfd7e35213cda6b841b9c19a80a9bb993f2856670f7c3b346b4e1929a8f05b482872ea9f9e9737f182dc8de3d0d70a9ab1ee3b249058e7c3767ab01335372750203be4e34541dbe24905802e95e1730fe6a6e2ea959aaf0a4bfc15ca78c6b723e7478db72116b07d5f4fa233a8e1d2b703932cc84b8382fd14889bac92b34047c050bbb7266e379df3aa703b90362caf17bc99e1015c467fa2b690b13605fae1c784e8b1ac99b08f1b9cd00175012fc424ade1797a809ae8ec09b68be30dd5546186474633734293110b12aab5d1493a8380f0f24bc888b8959343673996fc606668fba926fbf06bbf77441d588e51615490a03093b0efc0767adaeaa54126af472594c083732f4a8a80cea04c62a322fc7e1c38e9587826cdbcc94867b7541db9f42352d858cf26e60b3bc0e315a6dfb07093b91fde3efd34dd3dcfbd086943099e837fc62f0f91c894d14d5f4e965cdeb66464163dd4d4f4b41ae39cf0377575b7f51ed7782ddc6e0b19f0237d34615d302b212d9c3e9022d183b33c08afd9700aaae8fdcb71753860e69acfec01043a424b72f2ffdb1a314c4fd66d64828b6090baf92ae16ec6d4b4d8061f89868bfd35258c02a274682d8940f8e756c754b8bb1c37154ce3561b453c10617fd9930352dd445a87e02d069edaab395317fc625f9f9e3036f80f5cb5864fad2be9b9a32e5be899cdde3d10adaf8e53689647942c48080b2d821f3bfe6dd7f1c9c95e43c5eec38b9cb63b7dcbc7a06b6de3d3b590e9b4b9cedaedf455faf2e3e88ce5cbbd024b2e259668ccc7ca637a597071ac1a40367b2171e7928961e0d6407864585151645a90be646fc32da36bcb6039fa75dbf57b0cbdcf167672a22f6cab0866c67f16dedbd9cced046535c1c6feb3e6a941c709a320618af7e676d191f85cf84a09f31ac916669aefd2be3d77887d0ee4906d33c640f1a5d42fc43e37e2aabc1a7b92481f3e27f438280460b18fe53da0ed5cd3a4bbe06d9b16459a74ff32e14fc2665d9df2dbd608c3c7a4dc96c2acbe4f7614af90d687a8277e4c4ea84e3b92f0a1c14cc0e9474bfc8d8b6acbdf235cb818a1a0e6f37e8983cc2857a8ebd1a1b8bcba44e68f5d710cdf92376ad55957d7f40e1d72f49c369d58aefee252b36a7462eead8418470058b0f630047e4d82af05c5802380f319e6fb69d4bc6afd1bae26a716e408c889ad9340a1ad67821a32fbf110083b4821a9c96561f2f9a0aed675951e0f94ef01c42b27eaab5c491f9943e5861f9f448c421ff61f2493b1f1a7fc5d6ce3541351859cc1e2ac59afcdef59e8220ebd75f90dc0602440a513c65f0d7270f68e0222ce37232c82e4942fe51fb76480d4fc9f124b800e95ef6a88917b5d31b762ea51a3834b5c886674b654f51814fc257194885ca6e863d66999c56ac54d757cff78f9d81757c7e5eba7f24d6b8750fff1c9b3218a0c2c1b9183eee4f7cd731039ad7ea1fbe9479aeca69b579bc7d3cba0d68f2b01ec0bdb886c616e868f856fea9e194ebef987a0c5d5e9dcdeac708678e01c4ceabe657d9177e4c2ae73ea25bb11a1d7552274c6c910c559662178492ad59fb6f2dc171bb976b723a7dd112b7d72c7ff72c55bb787072ed717e0b82130449ddd814c1128794618f73f07aade70a815c821c8f075eea9a33db1244284b8d8e06616e9a2545bd85eb63a324a1c8269a2de2e3958540d43c012820e6960d06dd39d0b40286a36f335d81427e3f74c6afda88da9792159fccd6e5f6586628dd62cd132213c08d34f43916c352db86e0f1a5d899760575bc7f6fac7a5a025b1248663554df8b625965e243d95b62a639a825bd978ed5909121a3fb637ac88a65c7e759b33d52daeceedbe804a6b1171d9149295c1ae96588cea472aaf62b19cddd32c8d2dd94f8b2ad21fbb6116383a417e161f2078f8d7faf4125064c2a6636fd50c8da1d759658b66717e5b77db0bd6797586536ddf3ef2f415819e08e9c41218e580e61310d8fd6faa3efd57d258baf105bf436154faef43b2588974c303aaaa7b226add54a07f1176863fc35851750b9d9b3f8f477be72a14bb958aa0a0f404cb6dcc3802a76e0e7e7b2d5fe2e6ab165560640ab3bbc141628ee62b3376ca4e527721895f5742a0f7761f1b6e384d5592836f5cc17f9da081ec019e670ea9684b81c597bcc489ab9923102871fb4f625e8063859545313955df39e37711a0da9674dda28baabdb74addce75dbea28aac6b25f5fede2a871eaef1ff1e1950f4888a10a900178f6f91598a745fbedbd50c4729fedd66663c9d799f2f0d6ef7b4c9ce71e82acecf68a408add176bf9f2b1c39f5183fc2d86eb22a380af9832607632992320151c24426859abc629de95a4a114aff57c7e266b6027a1b2e8a11eb09fecd3d27be921628b755b18e7a8b225f6f9b07ec4995123ccd8f24cdfbf9d1e50f8e9a3c531d86c8790facc9f5bb79346837901168a9695f5d1ab63731b91504df1003a46df2f9ee83fe269efb206f2d0dc1b9e70a40b293f39956aab4cfb88e7d050ff8d219a21c6eb7336a0711258f641c27701ba48f2a0607245d282012132375d6f2128499075c41f1c1419faa4dc6bc24fdec35c2847b3627ee4662eef742ce97ca15265157d26b04599e92c05cc7882466e2975ce5a48cd1a8310ce616e0e4bb7f3294372700d7882f680b90a03d405d76f66be492e6d6a30c031ea2c3f66789d08890534177d3f7fbf534849d04a8266c58cb870d44a6451bc07ff9ab673b7d79ba3053b8f7a157f75e464474d6c26ecc776a88ec162f26d3fc510e433bbf2b5ba04ab7c12edda5fb64927d45aa231ef26bd0f15b9f19257571d596c01101102948cbf7742962f20d23ae35180c8c1499a5229e078304605bf7a53f3fe5c86e40334e613f7222284f9993e25b91b62effe99640c678157ec362704c9ed5783e3943711133afb2eda2377401f7eb2239c56bf19807ec585fe7cf4bb69675ef96cbb65eb2aaccd2f1d4e2b52b5458ff06b0b20fc450cca819771396083f33547b69453b91a1335aac6a5e3adea4e8dff6cc352e6fd2831251094d5425a6a41497e6b6a88d915cc2c15ed66fb213583a8148880e650d2676b0e4e31eca911d68a8083b20c9daf5d303ce225dfd4e7b71c18950e1164921f1149004aa08858f94eaee37a43b80b7fca5d6416f8106e3ca1ee082e19b8dc92ed597e052acf36069de373ab1637049701b0598faa9c2d9f03224aa70eb68a6a29e5c8d80cc3733b62a0afdecd39fc4af35262c283d00fd1e81756ee2f93b3ef331b93d0b05b17901c57894f0af233641051203126200146aa1a64a91adaebcaab7a5ed3faa97bf14718b504ea9943030900003745899716ec6bc011c0fd0229a0ff7f1ab3ba5095352ae76ddf8a87d421fa9c9bbd153b3ba715c1e616726748269741fd0866f589219f83ccc8fa1516e63ff79d5807ebfa05674c3c26ce864bcc2aa10f47427958a0a63b71cb01ac8822351ebb63d65e3e73ebe7e5473d77b482eda09e3caf6afd859dade2db6455ebe82415209cdfccfddd89e922d7c6bd75fc024ef3afa00e3b1debf549e88b63a0cedf119fb29a8a0ece7b8a080cd9606d6b921d7ead5f993dc70f0f52f96287a619fa5f755efee3835948e4c4a8f603544acf3d95a254747cdbdda2b1e876b34399e39dde07075d2ed171e6d870eba767f1235545597d93064f3f8f9789b4532682d5543ef6aceafdf69e6337fa5ac213fd64921cb3c5a48a72d01a892acf114a2e87360f433985e28196828f312f7a7bb292d3fac2da824de7aeed799bd1732f274e3132d6921a4f6a17b7ffddacaf5247ab5b35f0f9388471adb6068a8e5db3bb20c6faf41d7bd71a2a2052e78597136aa10b0273e7e85389a09a5a94ae475e715eb3345df0d17802291e0c0cec72f9e7237aa8bce1998b176c50bfae9f4b08739e6a50f60b8eccbb22c61c0e3cd8593ce8e79b7e1541e51ba6ddb335c4de3b0d6c564f3459a104430cb2e5542764c753355d387d128e0d309cac287861d53c3bf5da729a1a1bf080e68176abfd7094de90bc99f481c1da86c479e8460438087cedbcf41f12c285cf0627615284d53b01d5a23f3687e21d482eb31be30706f6cb5afe24f9cb6fb68f6777d1298fb150ec5d9545d46b962af0af6291e38ca2f8bbe258c9b63ad57f18ffb55d223b02d18adbdcde4bf121f49383923e0caa55e0ee645e964ff711c03ffe450aa16089cf4776238e8ade9cafb5aebf2c300b9d4b8b800dcc9ae4f0625f5411aa8ad7c1dca5ede26fd39580334450fc91e6c48ac186207eaff9df705f183a0e6284c514c2db840763ac32f08fa6d0bf672fe6d9b27949a1b7f77f8fffaa9939bd1d503c0daa840e764e3e7379597d60689426f4e0c95e5e23a5d2cac43026ea1d6ba78f5eaf7832e8ab66f840b50b526ecdd95ddd5205ff49b8336b4e5a90c75ee1282911ab0c5d3cde96db83c48ed8c57ae5c5577c87c2f3a916789b95cb4416fa195b3fb186be518ecef8c4360e1d8e9e863c7068e022d52014ac09bda55fdec191d16db30951cff81bd591b5de57f09e259e4a8aa802b0b874fd5747ae70d520699feb1b2d80d92ac4b7d9db11278a7a71a045d5f4737c7bddf912e5aca0a2a11b2203c57e3786e6559518f1940dd77ef2c9d94faa9ea2d4bbcab7a0fbc77725acad3625ba568e942f67e1c074913320380c59f75914fbeae041eb9c395b7db495b81c89e6a89cbe2bfe0313a1a9c2f130d8f609ae377c19767672c6d2905abef19696cfaae8602948a829cb3f5ef5dbc765bb15f615dc56976fd28d8e04f7a2c6d78f38167f7ad217b10228b42964d13059fecc6c662bda12cf87516c3724beb7ea64a4b11e584f7ffbf3663f043a71fc56afb7a0a459d4d58c217468c48fa5e8ec7d7302a990658761f55c76ed5a2fbdf89a932c547ad976a4ef697bf198e868696cb477c43fd2bfc432a549e3b3b16273c94600c43dbb0805e531b02e800567e99dee103cb9e5d4481479829eb9e44fbf2c00c015129cbb8df4fc0a1f343357a54d87a5c3a40960e11db2aa5fdf36c3a4d80e5082f2409d6711bea1d13c8943f617beeae1be439dd04faebd7147b4da834c4da7fe50339c3e0e468ce017b78e3cce48fe05621b09ddbb7ee45cd0a3fa576a8cf17624ddaa638f59264d98e9574eb3db829bd6a5182522ce66374485ca86cf4732089fc91dba1839770a46ddb340099dca504e9e66a34ccfb2a33b2a7c129ee6fe4e728b342826d71260e22799812f290394e2863c23f73502a5142d3d2c98371248c1f44f1ae443f1ae7294f0a6970805ab932c338c7afee40ae0f86b6ac622337059e735b450f07b7a1e72d7fddadb1824e44942ba2497b115c2c970b2104e21ee70e0fe81c5dcf45ec486828e701153798c5a1d7f77f93be0930a45d43e8cf3a174f7f5c0f68110cfa563b00fbf7db51af5e861742007d5f2da304f948344c0dfab55936c19750721211ab154716e3b42b3de09a3becb3ef67dac03a2b36a8c02a2d72e9979676ca8031caa6756e5b2a5549a056deaa90456caa029b208646d4c305a13e0197bb800e8e18a89fda3347d36ee5d6267a2d61b8f5a377b461c306bed0df554ddda9542d51e657a32cdefb9b598873fc318ab8078c9b4e0635a0cb33060de3096aaccc4bb9254b2d702e8b344031ebd5e93e81db6b7eb3c7ccbe8b2065c2a210267cd8f0f333cfdfc340c7b4f5b95691d54437c07467e6d13673396fe37982397ddf9022ebc4dac8e2da13369496473cb131b4de386fd066deb1b1b309d837ca360b73d3366f0252ac4668064dfbe156bb510a221298b644d30c3fe634ede082e9b3e809230f6b8d1e50e2e10157ee56935e2df3ad79ad48d5b88fabdd1f05fb519b769fe96590bfd28b5a2aee26b286ead7e2f37c4c79af96c1c13b09658aac3689a7cbc79b8831c0c3dc64646b21526ef3e4cf1e0dd6ea2a199ed6b3b0b7b05c71b9772a8311d057aee50cf0d6ebbd8c798a1f2fd86cfaa805e813caf059f2905bb7061b30b6e87a98e1fea1baddfd246c213f165ad59ab4bb863c3243576cf3835c2cb3d130bc1b6c1e7f88edfb9ab8cfa76ea186dc07179b8d60f9c8b12aa340a473abc191bc11cc673149d5ce03c1b636bc75c0c824bc4c24e055becc5b4616cdced6f195925d8ba3877393ac4d9f44d40bcc85d54ced22f402ce9f3955eedfb641aa8ef9922a8eb0a866457ad9264940d5c3dc0a0ee30dd6fbfba26bcc46825dc82a5e1e8d949127c64d63daf7705643ab68effaef16be2e932a4918f30ac1753068ad3bb28a46368a4d3b14e183576ccb02d59f927d99f9bce98f208c8af51d2e45716bbf516957d4e3b3232cd87113ce47bb504b414bea3ecf2b67cf7350d1e5853ae83181336c059883241bc7b3cd30079b912e9c62baeee9044dfb37c28841ef86ad839c1d8ffe1747917a45def4719eeabbc16ec56432f6b9b96deaa6af2e1fdb25eeaabaa2c98b0a71c3a5b38cdc64a72e2871c48afcfe43570ee58e7f601f682d99af6fb112e882443a30a7b1abeecd5592ca3fce999611263daf2352f6d0c3d54973aee6a2e7855a2c31832a9d89b8d1495a4f90f7982bd66ca6f4cb13f92f8298da712316ccb66996d9e0cafc97cbbb5089c4873245000538013dd5f58a6370a1f47b9429a0d4281919d4ed3d1f353ef2b9385c3aafcd66d15ab104d88810036b304afb6cb1b81ad9a6cf62c63769c02782ae747978f6ae0e44f55b24d0e0b8aafdb15f3ff7f6535c50c7f1df105027f4cc9a9afe80796ed92fd0364c30d1f9dbd1a9bc492e95a56717503fdf23aeae00a224b7911696e7679f23f3a01c6b48f7a2a081275dfc8be67b30199d3895b8f938bbb528263ecf24b954955b2e15cbfe88a7077336c25c7f77860babaff798459719031c59d36d729900e2804a6d26846d5094d51425ca3dce69d78266563fd29b65f78ed504f7e5dafd3404579914e32b5e8598a5ab9d29016eff90125c3582ce6c7e7e2637224c8db9445e54f795ed658b1a0cae78226b94d6254c5d0f4850fd4def5e570b9367616a0dc27ec3b6dcd5d0f4fdb756b8de13bac353b3794fbcfc9a610656f3ba91cfb306cff36734d34d7ac3cf2026fefabf3d8be5f33ee0f8c1bd61051bfaa9b68a7746dd90f7c47279d2ca920b5fd13fd3593a610a881fd94c8c5405d88991809f8fff38ced5e57e005930602479a62596206a61cdc3cf2a44a545166c146c0c3402f1663d6f259730ff75f13baa52e4b94b3bfbb9d153f2acc2a2b22a976f66fc60af715e0cd1238aab5adbbc7a4955a7657c8e0341448b27136ad9dace8f146ffb15bec26429c87bfe1a8ee692440dd353956dcd03e48a867ea7a0df4a6daa02827db825e7d8497dcb9f804200b2ae02b82f020d05c31704b0922d41affbb8558bab13eff0109314a968bccbde2acf92936320d95941154cfee755593ac4bbca844725ef4b69b43c0ebcbf9be26e17ed16f97fcce659fa6753a38f91c3b3987f8ac261fce902a95dc7c4fc00cce70a873ff2374db2127b455bdeaa991b9db7cd0e6167fccf019bfb98ee0df8bc3effa709dfa14477d6766afc563ca55bd7ec69bd3e8f367aef3562736cfccb13bad849b48d98015db17652e900097bfdc72cba93df10e309a0b3d4c72babbc03a9b5b58309bcb9faa6aab779345c258c6c2ed76da819d6b5d657c799704c186457bdda4c2d04b990dc81c9603f8606d824d96e7b708951251a33b2d87385c90c9bec31677d5b9eeee5717334b7f1c32c3592ae701f788e754d1facca5a424409e4a27443fb92afbeb7b08d9657a744c880b49c95c216da25d371327042eb5ddce12c4e6f2bc6c621570bf76b1f36f72ed8c146548526c12a02a028f605a4b4cf2ea9d31946bc92936ecfbe6e5c7f4512b1324c30f1f6681bc3dcf6c4601938f2b7b88f75b6aaf16d1805ada3d80a2c19f80265b7dcba8ee4250975c7d894fde3ac671a1ffe25161197b8ac4fb9f41f1ebd4945085614f61bf9de0362827a05f522d77a2b3119dfc2e5ca6ed47175bd093c8d482e97df6d87010ea8461f868183294f61322249ef567df20736a8818e74a891b77b53c7ba2f4423870431f959b707f570d6fd41e231c4e8876705c86b8d71cb9ec3be49f0372aa232f213404791b31380a5fe2db521ace586bb21e292dc0c8e8b919dd53dd31a0c97b31c3d4e6ec9938ba116af777fa8119dda2f92d0830d957265811e92ffa355948e8867a5f1f0b9f1c4faeeb30b813dce95c873bf3ea4de73253587a5eeea4187b27eea80b9f76ae8246588662ec62d9377c8610fedc29d700036f54261724daff6c0316b3bf80164e6d0a1dc36b0a830028c073353655dee828a5a32ba5e024b850bd06de2d28fa6b10e1eea290f63d6ddb7dd9d5d6b436adedbd900795bec90881ab844c3063d8b8f2f7af991ca7e2c5e5109e3a966121636fd82453677d3f6a0fcb5dfedf6f5e81ec707e0c329c30728394cb7e5b227d8ad97451c2d1001a376d911efe4838cf768d2b8614e34bd8172aa3708573083a079093497b6d37cc56e7e74c2d63b0c672e83baf56adb6963664a513f9c201b07669a25644926c03f8ef49ce53bd0af00eb865fed01fac39702a731a7b83fccee6c4d79360bdbb283ba6ba1b8267e43dfffb02bc7072c6738ac97be4f2545c9d1435242851463467ed6e19ada328657169820c110c632467a7efe976f34e8a6c5369aef5c58b1d3c3962a6e81537974f41a0aadc618ffaec32deeae91b0dcd6fa0be23b5125f5b6447b363bff8878dcfd964c913115d703ed2601deb688befb3cfc2e26fc652b4c39dcb89fe36bcbad72b3f897c8202c964a9c27d6c5f9681348a3e9953de78c1b9deda1a5574cccb2c43f685dcff14e44b7d6ab3fece0e9cee7d3e6034781f55658b3b8f9960595cc903903c95eb3780c395139eb9b4e4b7f7cb1e751f1875fd31dda2c84bd665ff4120e8d676b518fb15944f736a5db351ef86c19d799c1faa9884f073da09b055e1b2ec47fa1ce0d476a392b345a0d344ca94c68fc06500da66342eb23a9c37969702a44946d9930fd0cd617503bc864a8e70843424e297acd4ca021dd1d1e8c8c27f7bc861d936cf4ba63cafe8810b636b3f789ba8bd37cd9fc7f0d62c18b336fe832b881cdb36fe62d53dfa6effbf8e0e6ae8b143ad389369b766166039e83ffe4c17dc6d760a15ae3642505562c05052dc4c5b0dfd2af6c4fe74dd023366ecfae213e254859d320fc514720e9b9cee7c6ab2fb630608bff9d9cb5b82187597decb9db947f889f28d67b6602c190b00ba0b9c80cfbf4b0d20560fa40ae7d9d3e782a97eccc507b22cf5c81358a27061da1d4a3f7f64e0e443daeb49d7e2ed9f728154b818bb05c2cc31feecb5c2878da6a6ca8e1c24a1f119e48227479838977fe6fa78c012c52628091e3be5aea7344cbbcc2e6630845e1806f027158347c46f57ae52c7006c6f393cdf817aa983a67ff27a4fcda27c427ae2d960b0f1654660e3e15718b706818f10a2ec739676b109cd25d6a3ae23a2f74e0ace6af0123a38f21c1910431485381f6c7b709e26f243286290a7fde26aec8b5df28227fb50bb523e57006bf36d9f2fb6d56d041136b88e44134895f6d553b3dce2df71a53ae18d36069f9c8da1f653e271eded869cf1554f20a8847e96c381511ba71e80339cc811089bda5d2ca285d5438bdb900594a8c9c5b4ae9672eb46f55ad4140e7ff98b041a84e83693497eb00ede0d70474f4b5e448e121b708e30deb79160be2e28555696211049bdbb8f9c6494ddaf3974c766c1efa909a30a1279e0b0608996c64c6cd1ace1e910061db160d3f7f67e805ae8662a119671cb00c01bf4278b36b76632257e20315e2fd166147587b3c331359ac43328dc0e6804244f6d9edfaaf8e7a8230703063498048f8361059ba324d3b1f0101e306266c4b4192aa210d8f0bf1bc2ea85f6749f33d0f799e2c5edddbd500b578a75bd2162573e70cab31e503363fa763b32d317b4f7e595d707f040e6c3e4adb0f0fdcb7d1ea886a667688f9975d098864010e32a21f80ca352c40092119cec4ebe8bf11b979409b5d0f25d60e113f4a98f943b3eb1d68407869bf186331770ba7318a77cbaf3e5ec4055856ca728fba2515e1364d70451986c6378bf39e778512abcdc706c5ea231d04f29a02142bbc5860d7bb0c0dc40f34cb6780b6dbaca5265b2755c2b4d47a4ab869b275f3c8d03c9709ef8c1e540727a9c6a1b2960d9387de251da0a65385a7badd66467d111adf2959ffce6a03a1c0ba19629ec7ce1c214a9ed7bf196cc083cfc56adb8c3b94cffd5984b37913da4967b0a03038926569b69f6a396fd59d4b7415e43f8fb1c97a0a3eb0ed2884338c417866c18e21ac59b6d8df07db6e08466216aca8a30e23e07a9c728438ad1ea2e0435294b2853b87a067b126784fa442e0e0852a4c3852b7817023b9da9f467dbcac9d76fa3961443b3c340ea35ebde41cafc7f0b39645c32b562e13a0daf4f53a3d6ee2050d54bb358dc1bc8d64a647491ed9af51dc78c2d12c75db14049c677f8eb5fcc8139248b8b3e9e966dede91f55e9c9ebab386764fe396f014872a40ba92baa2be73f86c6752ef07452ed8ba564807ec13eecb936eee74ca7409670ba6b9e2a665885b6547168792ddacc36d8380f0fc8771af7463b3d5ab5f6df7126afd9d89206f099c6e8a220c6af4a8379d3a2333daff3e759386cb624db49717b0ba666957847c907e7bea72d87142641840c50a6348bf6be033fbee8ccaaba0b6a5e4989cefd13254826fa8ba33a789a167a5954862caa2b1da472bfb42735bf02bde4df138b492515ea258bb77d14facfa6a14687cb39c54f7e00e2be6744cbbc3b1d30726366e1dd103ab6abdadad47ea8952952a8f47419115f03fcc5a9241af69b9ef630260593453e9b6fc9a70420f92e9c6e9949c79c143a35315dcb3dbc3d12ed59ace5d2f0a4d2d6cd09be742611e4ce142135433efb4420ff7cd2459f6eae6c2f30a279de5569a2f0ae0cd4bd80d777f89b05a724b92d96f9f96876eb986a5a08b806aa6254fc5252fd486173b80f4a59193812bd415b4e18ec104a7368093b36b602b07577f18e937b6539a32f832a2d9f60dfb10457b852f3d4d92c41ea07d1f33244a502b06a6053dcbf648b14184b55493ae626eed2136579256ede261b883cd3068f353e89f56ad68de8584b60ddf6ab2ef46ceb9c1a922e6251c511c259c54ad9b3e90b80b1e4abcae0816f7e369472aa454834d8cd59d6555d7b7596837fc24572e35278326546d0c626e701dabb470d74dd5a5cde41affa211c017ebaee87454dec2890c61939a3a7e0172c1f40be49a4e4b1aaa5c2e1f1555f7468f860d8e3b853efdb2b2875a9a51f868b1c158877482fe0505de575a9600dc7381f5f61060cc747bca6af6cd8e8d5da3c79a2cb007772c7ed856d27dba607fe5a81c0367e2038d4834d6f81768fbc2ec13815454eb116c5b12ba323cca80372763372bf01628b0bbe73805f853868e43f853306027d55097d59386ca0d0514f592a5d24493f489f8191837ebdd06dfbc44d8e306c667bc66dd24dab17bb0f89480f94ead9c44892b90f15988f02059b75c81b748e6c00fd109be5bf962efbe6eda3f912d2593c03d10e9e14b2c9f31f500f4a3db4595016ac37","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
