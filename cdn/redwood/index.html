<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45b9dd3f23c94b92277027c76dadcc971ea7735bb95e60fe8eee7562207d3ec4404d0f83d62e3c7b1d2a36eac6c34f0da5cd02094c0fd35c451eea3cd198ab31d16fe4a982e3912e790e6144660e0a3ada53cdf2e1d53fd66179c2eb93a33f4b5ae207cd14150097774aca3fc28a51a3bdbf7a721fe8b799e25a48106e791f0791f1e59f84477efe68efc4de57a7cb57b059bb8255899fa6d9f262eebe81ddeceb4cce285050d0f7d3e24e24578a969d6e2e31ed988ffbeac42aba825c9bf859cb94ed1dbb94f35aa6951b9ae7e9d53f0a74e9ac0295974de3ae14a6aacecef7a86fc6637f765a9ae061c4ecc9d1eedd062846c11b64e22b75d2d0a7af62eb51793641d2a1709eb71b2a961b1cdb6a00e265a4ea0fcc08d10109498521b964b17dfa19149c7d66d9268a889dd672569568a50c26c857bd7b09038d1048840cd5097136009694d874ac311746222fd416a114629a70c946008922eea0669cec5ac5797c3e8b418daf3f0dea2702cab35ae456fe419e36ec0c32d658009fc20da3e37322ab5b1d9a6aeef6ea8e1628e1267bbc7eefeae32931d940c85782c8b8298d9b11308e79f35dc0e2abcd138d15ab42987a02eec94d99140b0fdb3fd8f50b9d0af0f290f1668853c3e1ab3ec0222aea9bf2c55cf0ea11a9539625ac6894ec51adec93f01c67351f0bce6f9446deeb58751f33c29a92e3a97b4e2d799c44908c39e39ece5d06620d3c4304d439dd080ec14583f9ce25f4c5fd2c7ac6d8a7cf8df9edad9887615172ae9cbf4406f2f1695a1fa2c6565c2a5b3550f9838adf0ddce94677e4aec8725d7fa62f9117eada8490ebe95b58154800176314fae414df8c01ad6d73dc48d07b1c84ea65c1b9f7a369099c918316cfd3f3033829e6c1e5271a4d048eac2053f9fdb11cbd2fc8f7371f06fe74b1c4e598870194d615a9f095bacdecb85b96d4b7740985d00335cac8b68c880495c649316ac563557701f48f4842d38a4511ac33b00ce008d6640ba87638981fa29c67f9160ea788a8e8a6ad314ece2a198d5b02bf479b23219ed91cd47291ddf2e3d9b8333f750d381d140463a5da271e31e7935bc80c7ee36111d369998b99f87889171ea437196e18e3155e900e22c7977d060aca0bf871007dc96dfc75eff87ee273dadc3c54a97ff4e6cb7b344a07af58d9844caae37960452ce97212df752a325c9406de3180edc50cd5533f3c45a4995679a1fe2f786e5e9918c0f4a84917cf26664e03a18cde81c059d35661fef3caa77798c667f0cf3f6c1498895976c0c3fb3b462da8d72422546b8a7e0dc1793a89d0ec196a4c9cc5c772f31dc7deecde9435943ceb8cee4b292183fdb78c2a2c14e6094cba98328d75e446c39b9c12d6b0928ef14527e867747a791e2a0e0689d6d0802fa501633b681cbb80573c34bc0690797fd654b4390ba3ccab8199dfa284b3f267dcbfb3cfd248d5126d922278f02afb29d32e98101600a288a83d631cc1aa8e81ba56dea68bd3cf1a768b5bb777baf4ba94291be07191d82a58f055f2ed84c5b0503d6d11f8bab638a4847625653e90f80e62c2395b7e7e0b31f4be10f2dab3a0ef11a455d0996da41455062bcb203c5f6c097938dc216c0903a409a1d64e58f08ba3119edab7db71cc9a90a1d65f7c5af0f16fde00cb2d9664f801899bd65bbe50d6664744b6e971d2d78a99e45d13b5e99395362ec9047ce9f075570628c6150f29dcd0a7e89fbdff933a4db9beaa79f170a465992134daeb675b6e2e7cb83b6003919be26b073983326ae8df33a8866411f19d74d8f9e1ccb8a49ed6545bd7599b12d06ef6b5f7f2493686addff37c1f5ad300f97ebb59c5b4d0152e9c3f46b937a26d8bbb68a0d65f538f2e53a104b14be44cbcd2e9300ef84f7ed3c906318ce7cafa88b00462cdbbbbad4cc0e4e933a7a8bbea5c96e7ab93f4491a67362745cc048b2648569ef9fc9bf3cad5cdfc0dfa26d262b4be364c5cc28a10b7cad4147faafdbf8516904cc88901b0806aef7a7d983d2ff0016095438389938c3cbaeb45b1143713d7f136798f91b3bb2f0e9ac716ca3899c883e5c4801ef04f664b6332f853708b5276271ecef9847f32b205fc574b4cb9de7d1005ae42dcd70faf3d12396f143f78160fb0d73314790bb37c284970a7855e641284fd75b43c8544c0f62a2350b7489459389245806a42dae7d41318313ca74e08841940dc6ca8a22e4fabbc3f6f3ef7c421683b861ba5e1aff29d60054bd26a1cabc4d5f3f5c23ad0dadc6182b18cad16ad5424972e32aa0d6880802390ca1176ff84e7217eae3242aaaaaa44955ac0d4a46670a776048bf964f1a24ccc28500f329e5d00bcd035834a93573f0bc8b541f0248ac06211ebb09bafdc3a5262a8974dd8bbd905439c066ce817ad855292c880750529ba62a9b15fabb9e5e05f57e56bc13c3637e4303a9a01b58e2e5285a3e7f60e588c1b12918123ea740e4cbfecf7344e4d569329e258a0a3a37596981f41ee0335dae73aa2645abbfec168a60e18a1db777030f711ac8bdd5bb5c74849c625e8a36ba9ee2d0b9c2ecce3bca482ba94775bdcd5bc5a6d4554214e4120d7aac6d264f051a15a49431815dceb5a25049d276037d8d27e02d26347dc68ef3056c0e80605faca009ec0466ea45c6fd69e99c21a37df9e41f50e43f59eddbd0de6d10a4c6ceab01ae7e4773b77e3dbb6690c38cfd4d0555f7e0e346bde820edcf7e82530578bfe230e0aa2b0ca104ef010118774b75fcc67c1101b2eb6e0df1af6e242d5ea74c16ed40c66bcde3bf4a672bc345426a89d6c7351e8f18fd17e021b54d865f4b0ba4b5ea9da0dd4fb1db6d065b0c5d313d278ca210128571d11c63f8674f61c580827832672c6fe2d17c59221cefb2869058e75b8cc571b1699094b8f16cd28b7c07f05ab7b6266e14f1ba0a6f32f3fb423994a65ee2a492871a8c337dfb4d6c2bf207de8ee7f8bc28ae31aad369b9a844f53b0586292921ce1a6435c302f6561a33341098824a66e4cd8367a8285e8ecae353c1ad5dbed5deb3a4b02771d4e8b96eafad302853d5af6c5cd9308e0f6f99c768e221e4541e0d79e1b7484b521f070605e79d607f811279acb6a406324286ee6b9b53eccb6d830459a5847ea1db29dd08104f0ac13e3e0d590cd83814d02db577e57e4e888089838f47d788f44a4b9d7a380d2ef4cd0870c69cf9503232489c57fbf8c8f790cce6fe8aa45ad88f25e9b86fb89a7067349633ee8aeb3beb9198b080205d0e68c2a182a162e9a3f7bae9fe66da9a19582369e6189d81a43f91c2775798a02a0e583313011e94a3ec8816e2b4bebd0ef06535d1a00d3fcea7d1985ef7f8f7f633a82660a9d0cca636e396322fb71c70b29ffc4b5408df95b9c7ae2d369b68c5c706e2a914fb1407e4aa1cb1273b318170bb01fa8165f3fb3bb79ac6d68c1394693615951ddb8a2881b36b87164e238c74038d98ec2156e24b2e6c6bce5f07aa75a4b85c019289435954ede2056df01666be331d823e30508e3e031d85692a9c67738b03bcb24c77bebae6efa329d6ff4dd2c834b81a67c70c1f11f9a40f4d3ab4bede75716e519181967a80c2ec148f0805ef5907281f7db574ea0d9842f5c1c227eba8ad7497727b768c4f42a4e45365d7b6759164eeae3c2fef3f6d3e413f1630534c872917260b1881415cbd9bc0b90a60c19fbdc2cdfaaf430688c23fae5deb0034b916a6095fdee31a3f72bd8213cc5ae4bff8ed92c70160385395662c5798812424f54cd9d2c5b6faca72a207f9c42b6073fcad6ea17f91eb71e3e61d59c4e61b369bd71977fc804d8c8c7e8f3e38d234b8d1da7c1049a90dee2399816820df3bd3e2ef71ac0fede94a3ad90d123a1c760d0db84a7391388dd29522739fcfdf97c7ff12b4eb065819753ff36b2e916fb4dda4f6a980011ded84fa4f6df56d852d4a937b0db6b495d8aded2e5fc35fe08fc592aa7c1cc773ee8ef1c10247196a9f0b502c40db9e6dee1ae20de8c476dd481c85bff606e9a8887ca9d261be0ee5c7bd524a4ef821068fc4bf5aa9f3049e8f602b2909847f9c293aa49bfcd1ea302f3a75020295aac20b4dd6a5b69cd84beeacbe87bb67fdcba4901ed10059671341941724ae6914ae3086fb8321d36b7a567f0fe4f8d851b148f83d43ed5e85e1549acf3281be12b7bf5743706ea05cda9cba34f162726bd26359f7ecbec416bd5878c4db6e2e76529c7e08417bccc2b6dafc879605dae94a518ed587c654bcc3b6acef4251d59d8f53844751a79b941a58ce1a0592835364762785286c3d20828cc16c3ac092b40fe8f2ddd69195ec0b43c5087e4cc30efc60e00a6a422920aa5369ef06ee9f74531b82dc7d25f78d566552b0eac2e465e32c3ac0bed1f02b93c088d5b26bb786dad405a1cd9f2df7c66736e447f118b30bf41b621c58c48a70ac524621a0d81a247cef84c95557a0c872596f9378cf3aa871a2d9ea9c5861db9594ff9b846968f40d48704e31589e6f28231a6183819fbc623197726ac3885e45cbfb84813e42d5184994ca73c4d05faa358fa6d6a4449048c53572b5f4644a3525174e3661c2fe1a1261cc50911bd6121fee7a88c07b6ab39f5b5989f155f3cb81ca10a2d86991d3e8bb167a8f1c7fcdd525b0b32dd838cce19fd654ccd3310bda31640b20976f3c983571811a71d1024ed2288a02539cbb21fd11ab168f5d38763da09c2b1f549758e0914b86e4854e0b85a2a276dbdebddda1e9516c2fa66b80847acd4bddfc20d7a3671b5a17c9d4accd8465bcda64ea146d0c93e365513cf800dfab4984831e46abfc586c5bc8f96bd491cb4b8fe6cd0eb6d8ef4c4aa7b8636b1d420c072690310f8e54e2031ba753f61771662b41188ae540756928867ac1b82d5fab8f89d38f4525cd8bbcad01313e9d65413199fb4f9afe5ba160c7bbfb2c83263cdff80e2b96a9d70033a69df7f068f2b65a9ce9cb5ab863d5763dd0147af0a3c91584a1eac861884d32c8759b6268eac51f235b552d52db81ececad752ba51a89b136f83129f8cf2775d5c232875c251e02868ddd647b2dccbcab6823bc375c344a44f10b36059cb0a2ab9070c3774cba236fd6ba6fc473e24f6f96367ca25bca0f07acba1dcefdbdfaa25d0fb15214974a3a3596a6a0eccbd063caa9a4185b65c158b8ef13df188f60c73d0597d8212a572dc9e7d57d0fafff0d2970357d754c5da51968c29cc10ac6dc1df22f27169afc335bfb20c49286ecf374f3f1a5b81799d7c71b3b9a4ad45b02f7a00cc7ae687e22f2952320c4aaffcf99e99c762697bdbc44bc92750b591fe6128249804c20ffc686b443da027373128156d390f56cf11a6015bdcf3e3529e379f668b510b790414a389ec5085dcef92f1a5ea9e74e52b3349094f14c906eb59371e1a958e5f9b5336843bc2e35b79529f82c65262a39d5a2eff30dc738ddc6d44caeb35b38395091e2d9a076cdd5f74b99ec28438179f3a6491075872860e28a2e2ae02cf29ef25844b77a85ae018b71fdee451b5d6014b427ee92ad8ce4a759cdf8ff4a1d071dc9cda7d0828ba6c5d6bf15919e8f5b264f4b835bb15f9e0931bdbb1ea4afdead2e4159e6eeb615af228817f15a4f2de74cf9b874fc918ccaf61faff0159fb6db732a825d2ac202e7d422133247752e0972627d0f7a5cd634507708c4d76a783383337d59fc7d11b4d2d2bae68717bc37a91b02371b06c99e74ad767fe862cd26c55b68385cb5a445262d57cc5de28c0e317e4e6d0361767b8b46c8260bdffa54d5d0d784ea60695c9aae0e06f5de50cd89091089eb1855522f78afcc0b47ce5a65a9771b7fdf63211f365da34baba9951d1011faa84fabcebb939f22a9a707297d8c35cbfa8ffec9a0447f190590e085e8980835241239b29a2bc5f9d26ccd3b79334656ed8cef71a3aae9d6a642a5cf887b01f19b5ba74bf900248adf61017dfd552dc73fd2200495d33aa450ac2b6c0adf1c41daf109c691d107d96cb03993e790de700e06537895ad0e9b15fadc92d742589f4d389d2b253910a2bcc7b9fe166d87b48838917ab386056152aac43ed30c5c708b82b3173f2bfe3a76238a6ad8438425bdbb1f1b9fe24af150c98d8af705a6814a841770f7a42df1fd2c5dca1f493b5510114a18693aea8f960423af1b49460e8bfecf9a0e92c146a280b98b222741c6ea20ae0e5aef9269cdb9728a0ac2d3345825f50d43f93462fc42dc292d5da9db117f01bb0a06efe13e5db9664c994651f6e81086a636f180a59e4a2983d8d2a9af8b4dd4d47cb02332420106edf54fa288af1086f52dcad0387c33d73f5aa0ffb4525e71410ea2b34e166b20f3938d82212565e639b6b6a15e82ea1eb097ef5bdb487efd5f22be3bddad673907facb69cd7720ff031764846eb084fc6c00417f1dfbb3cad72594cd8032ffffecd04b7c0a012ce7108603627483832bf0eb4b1781b93c82a243e25d68f3805c64b3d06db38544f66c2a2fceae49378b9aee5140aa649eff210fa45035ae75a0749768725e3e18adc97b4a7ae6659e09231a3df2a6cd4a3164854b39179999d8b70d571c1a3af84f63f98093dfd52f90f8f3d63453550b3ab0fa8245ccc357e955341254c217fe1e3f222808a84626a3d3aa341fec537815a860a13d22b27bc871ad551cb085dc576a3fa9cd10497e03a8af0cbd2cc0e15bbbab9ab628ae142e697858c4223955af564cfd105b5ab7b2b573b07e2d6d060c736f6fd23f97d07729e396af4567f1ac71b1fde7c9b43d05c80d2b6c699e0c6b2da31a8a28e894d738d0aa1048fec393c850b49e03689e38d5f330a0f286fd57c639110dc9325235cd6cfa76f0350006fc6cfc3e89074b7b7fdb27336308b8b830ab1bac616204ac9a394a400d3df5f1b41dd1f0add6f45d9aa126ac337aab637f11c8bafcb084ff4284d37659055f310e5bf65141fa2d144120a2b085f98e936979d55934e481a93c6d44790c1fd0e8f5974527623f08aac8610dda11d97253962c697984f4b6d43819ffab7dd4f915c9fd3de9b1c8dd375e546b3daef4d871b327f5953ccfcb9202ede14d3d1644d570f5a6beeb8a3ab0007e344d75559674c71901f978737b44bde43783474cb3a70753d1c395a7eafaf1702d2e7b3b1302a8bb13beda38dbeebbb08726e6ff7fd544241c9a7f11183b49f19030c6ac14a6f0300bca74cdeef9107a51cd9b78c4c43f61137943f787b557116cb56ad40cf9722a02fea3cb0d5519dd0b0e5f61e1db1b0587a32fd3795fe949d2e6c64db7e69d6550628508845da159dd64abeb1342aeec68d40d4d9126de0c73b03b3c46b352d9d346889db3b47ea0df141401f856df197063939248595ab7ff7bf944faf27892eaeb8e208d1aeb43b5056a1b5c36f4c2cca73fc8d14f408baa219cfab1492d456134fc4bdf691020b27dac1e462901a362125e6bfa149b44bac98adf2bc1e18eb8db61ff7637a189151290a88868ca016461b7272dbef98fc5829d9774c3ead015a2133b3e176ed0c33ce13b1bd9b310d411346413bdff421a39b2b527aebfc875428cd2985def993baed8bd6667d744816a0ac6466dc1449f1a3763bac7bd92e0e47d18790dac073f7c8d52284157a66fa7a39890bf36c3e24c4063227b6a353261b279bfad2721705602beb408e9c43313e7baf3518305eec17bc56a7e244b764f268fa0d1fbc9c6f8555b691a2daa3719b7a8b204758f8aa61cd049d122a2889a8f734e6103fd9ea58192572556094882c7101a1c506bddcca8b0421fee7541f3b0d5aac1248e9b5e5f59678fc4a6d10f4ad40d9541099a9aa1b65fdc1bfb6c4e2122613de97636964f30132755bf4adccad658c20f3201759e0b89aa18928af1ad11114116883a7d13453af05fb3b2aa4ee485e5e9934fe47464b227e6fb332c9e6673e74076e0737fdf0a3e2f67c49fa50082d864a7fffa293758c2e15fa86e43d871355abff1f780caa3a6329d93a33da74c0d4098f15b903cba8db4c34157d1c85bd68ec83c9cfb8724345782151ca9f478984c89b0156c2107edb5c792b054fc545b3f34ba9f84387c7e503236c703d0c62160bb6ff3ee3c676ea66d76fe0295b6a408b167ce5df22c659b2fa533d2a7ee840b8b615d3ebcf18b0c97ac5400dbc82040ff4bc6fd55d42a43eb32d36c6ee68250b068de453cec1b052ec4e0af4dd8b553ee02b8d7e340c2af6e4738eee2596139d2ef5e9672bfeab0e62b291e6ec8a9730999ef38c1e48555b9aae5965cc74b4f3655f3931b2dc380211c92f677b3d711073cf5c51de48b786b874d90df66d368053dadff7cb61a82e360b177e7bab55b71c99050560bf6840f2f522aa8b66b9b84b342f76a7fa80a7ee484fc7e4361951ee37a54836d1f7c856916b8ab817aa19254399bc6b0da4050164a86e8b755b2ce1cdaf2f93a4b59afc7f379a3adda3168f419a68f74f722f237c434bd668516cf664afd423a0303059a3b736218046add29fdc8286eec06f5b1e7d087dba691b9fb4688c7cfdbe5607cc048caec08124205c44424c1fd9a618c81deadd9aaac627d697e4de0a2a744994bcb5847faeaca4b61d443f25e063629aec930a3508910034db1e2b7014a43c09ce03d3cd7242e520886ae5b5bab7d3eae7cf8583d4e6e408911274d92bda6e7e3c177bdb9cb5212080a01c2a017dc727e0df60abf55beab1c2b3a3d974639f01d620f188ef1ad5c02cce359f5b8adc4812ba82ba7c2f41c7c075bbd194df684fb4e63aa3b56d6a967cbe2b1aa0366c67632a70c78ee1ff6f602875dba4c01d603aace6489b34a7bc6a23d7e47f06cb1ab61c60ca256793ececa2503a459ef83fa34d88e9fb55336248f5448cd6de7b4b509190f3a8c7fb706d8d8c479426a0f43b8a8353a3a58aade262fa4e402c00f9a9464f159f611cc8e64f9533fbe6a29d506ff12c7949a02be92f7d0a1b9931ade45d649a7476cacdbccf273f961a2afa92c91bd232e8f854918686cedf76e23d4b090dcf4c5453ea141152424a7a36dfb40df11edde39923b1b89035b235b0989bd4f809ee16d90af2c8f74f812a2058b659c128736976f6bf134c9c6b834265edd0a8e09507a54d21b51a78eb4a99399b78004c5afa1e81c4f4e500f9d6a12eeb50ed49da753668791af2a6e88dc7b649727ffe510fa9979a58365130c3aef6bb647b4e5984303990ff550d05074c9504b86f91def79691a89e2d6a49c970c0816bff468c855a07eaa252c2b9c509b34f16c6112b3f93787cfd4fd7aeaa78250eabb49770680bc20e970619605bf6a2740dd9d46fa3dcedf77732fd57e6cfa7556034928fcdae36c3b69b4ae9971c3d693d026efbd0c2d64ababb8e6f874d834d80bcd85a4b6a4f3edb7a7fa1f38f16e83dff031d00322e9f558a010a6c1812cf01d8d0db5ec365c5b790644b8446f56f1825c29bb91f9de676b6f0d5fad9cc48b198f8e9fa07e579c9cf2ec722d0941312446ee77c5c78ed6237fc01e39317f567211727738ca737be1a41c9560138f7f65fe165ad80121979d38d2fd47bc6c524cef26428e4fdcf1e7a8e1456e3079a9cb1f65144dd4d33d5494ddcb187b4759ad32258f1c93c958bbb27b8202e7839cf688020d29f9a5ea71f045256cc6f56af9f447bbda7e994ec7710c1c73b95152dd3425d65e15c0a212afe30a1246b1ad06912e4d57221b11201ca9fa16ea8490d1801dca99a3c4ae5e90ee1e0abb1c69eb77b2e553f80f297a05a907b4ba8b56a691e9ebd6bd1123b223b59fcd834a79eabc180cc094d7c5a6512b6d21859b2340f6fe30c0a8a78e1715e36024305c4a6d0cccac9bf2c08f977a358b7294e15f14ca15a4beb7373f05e607ecbac093dc5828afedd046d445b576ecf8a6bf1819d2b4064d06f78191edd180eb739f42cebc45501e84ed108b7e32d549d951ebfbaad3b9c04646f4d4d6a2e8eaaeed6abdef1b9f6501165bf8374b1106d17be5653850db16353411895ee0e5391fbf79408cb31ac34b2d1e4dbaed1378d96269506a504c6317e8a14781bea85cea7c003004842f5c6b651b7477c41d74ca6286fecfe68f345ffc156e5156eb2a703273e246a5308ba3502f7b65aea9815f98e7f52722501954eacc32cc0edf1d761b5edad76e0534f38fe7f4f1f2acee7a8f8f5862a7d3d0066858967e65b76f7fa1bd5ff3a7be5023fbdc652d097de22a18868191862eb0c8dd5569a62aeb268cc0bdbd2b0c3d9ed42f4e0ec363729693b406879d11b368c1fb54bf3a93ea2b779bec16f09482ebd9dac6c216bf40413a543d56fc0d44943e03f87f30199902ab935f96c11322233a7bb61b28b6728537b3400bccdd56ffbb3704c6b1500767c148749d3dbe70daef3c3e90bfe65167eaf4899fa4ff24df40f52fd2a879d3e3264ed426eb6fa89f5e4c405403522c49f466be4a798fa9489e7a1c56679338eb8049893e847a70b2946f10ffa753818c8060f0618ba3415fc00d169c165035a07603fa7bb9a1b51de5b0a0e47867212c6cda0da2cae816e35e32499905edd9c0f1d1e2fbe3e51837807982a0c33bdea4021f00580dc0455d7929bef6a0dfb88933a5d54eaa806cf21a649ffc7073b7688d98d45dbf4d3ef32497b0ef0c27166eea900873300eaa0e9cd901dff1820d51d4484ad8f498e10ad28a0d8650e812c54a8daa4f498947248a05da04ed7d02ec9c576c9691103cc6259b8577f230c6202b1dcfe4449e198026236b63935efddb3d3f2f55adf408b6e976cb56a0f1690f874bbe268986228b377c9f75508a82bb27b3c187bf8c66ee003ff6f79fdb21b55190b3dab8a3ee1d5cd2fe4e4735f237b37edfddcdc896a4078a885ac51afef37a75d2543af7bdad2a76d4610f9983a9d233aa625836df16c1a07a1544312d29e914fff7cf5d4bc41f0835b5887c973bb931d93c8e655bdae0328268206c96b35420c35f43654257c044f772453c1261e97ed78bee7c4e0ea28470da389da7f2492d4c4b5ea2ead1733b2e2d4944142bdc79b1aba75deb55fafbf700f32fafa474b00bd661bdf29e37061523a9b6f9711ee3e4234e988c3c683e45c6b4b68ac93bd6dac7304a7d38e2fa365e3c7ea8fdc20e68b89e42d5152a8129b81fdd571913ad82c5d598c2dc4146856d4d8612a69399ccb9f1509e2a45ec7160bd9cefd1cd34b7023f54e19ca54dec42306d3bb905672387fe428af0e080e956540a92139c2c08a412d66d7572a2ab6b569d1b7b886ffd15d34d79731f950fea35666fe2fc30a8375c4d242748f07784535cc475fdebfd8190479be4ffa7991ca4b53c096e0ef52aa60ccf866b5e4d37f3528d685b97e281e7752c0f0ea01a31a50eae47e96e865439e2ca6175e1406cbeaeb130cb7d7fdf819e4b49a88f4cd912889d5dbb36695abf88075611d21a3dc86e4a63ac36edd7dfa98e3b15c61c65c4dfc22938e7c8f2bb05c7f89e5d42f9c758598f92edced9347f70261ab3d855f0a9df9ac9825056bdb0b276c8ed2606f04687a8554893c2d2e7e1afc3dcd6f80d9f2e30396fd11194441f6ca7879c8b8edf75de4e05a05f4ec55ef7687316b35f1c32cc3878560585a98aa1bd5ad94915f17a4bf8aee40e02a3ae3bd033a20ad26ccef52c058673fe53cdc1ff0d1fdab8a5d85739083658ac0c6a91464bb4ab86201c210915acef23ff720e971770c2f0bb96fe1345e535420fd76119b40aaca98de47d562150475679a65ee1567c3a6d0bf43b9c54873f78c76b4f67b3da6d7cd306871e59f1c2e93085a1ec32dda47926cba8445f3da927f175240be621a4b3760388268e05d519c1ae0cd0b7971a5654dcc79440afe2052fe1ac93d411f461992ea9c537b61753f3549e4b7d1199e8a8611135130c0904e3a6c03a13082bcb3db0ee84e6498e2dfb3a9523fa6d8395d073e872fe9e59f1dd122bc1dc9a5e36bf519920b9264d0f0acc5d4d26af1a9886f4a5745e9235f780cceeebe073a7eea66a292101ad0a50cdcf0d2e1e20af7849a9660c26faf7bc3dd71276879d32616c10834fd695207cbb8a42d6f68a5c79b1702741a09ae76236eb63b0a2ff0d6cde9bbca9569695b88f8a77b8d03d8ebdb7857495c0b112798efdbf159f25be9817cd4bcaaa0c71dd5945c7aeb76867074e54528ab52ea10934d7f6a3950f9f268d91792373fbf554978a69d6fe9d0352a58dd81791888f063cfefec6c3d8ed34b096ff9a38b5b4735ffe1a0e97d4acdc9c80127136b196cebc40a629ddf3ee3faf20dab04d4d78e9d16f9007ac15639b23ff98052ef480ac9e0d6e8aa8fae6d88c4d1599f5f96ac385e0f8e14b1f2ef74642b2a3505c8ca46759c24104b0c0852e47154faa8cf017aa63a3a8a48fc69345324d13b771011e4cf874eaff284965ffbc42af48cd82bf76c84a04a6b4a8f212efbc5ea440556c3af594ec41b41bee754303098da6a1416006a373a8731b8495b39adf64e14094a23710caa05c1b132db076cd8893e34d0adb4d257158a97750263d7ea010495ca0fda899417028722c975e3a8c5f8734dca959666b82841ee9b6bd6f413596b2a528dd5419231b64152f9ca70cecc0beb428c630d1cae1f657c8a8a7946eab37d35ba938e42e46d13f80bb9cf79ba81eda665fad303eaf075031fbf297308099ebbfd8b1edd31a6ebec57f4bfc98bb798de912a1dfbc33addf203ba3b4c9c24e2dd004760afcd94a7ab7476d96372f51504f6e7b31e73340b836fe0f28a01e508302687b16de224bfad16ccca5816edd7f469b8caace4598c7f44ddf15822035df89bfd65a3793ff073cfa09c27b09d2d073b491abae9ff33afe3f57e680d276a0f9b647c8171fc210fb83a15dc9bd24bc361e1f6a52d7a99c32be52ffc432fd516a510a098ad547c59ac7c2573949f895a9d2bf9411b1929897621b48864a355d8ecd55ab89729ef990e8fd24952b64491cf610994426590536935a395182b77ccff25b421d08baf8aa36e4f7c73c162f2edb9b6a91e7721e27846ebeceab19bbe88584299b601d32255232c9c2e62963ae9acbc7495473d7a0b231b842d42b6a7e006e64fcf027ad36b584ff76efa613db4154597e9ace059336f576b52ffb405233d25f2b221c943e4130b4333ffd4da99f92f1c6a3fa0b51ab30c25991c68354087232e132a4fe8f4f64c31306b622bc0708d597e300f9a0c3db8ab883a8bb860e1a2ef04b22612a6f582e786e12c34e1bd2c0fc8d0e83dee4e5ef3c0f06ec08805369f95db6958eaa9f5a1dd579df5117b738910f229f85202e023a23ac1002b10030c9c3155fbee082d1212ef832e60dce6c9dc6267f7ca9025d344c5ab2f726e1499f5a370b23a96644dd5bd24798e30acc563c5f0d29d6a061a64f53fed0816ec3fdc6c85d4dec110fbdc9360912cbb4a078aca6414f6b06d96948e6a17ddf131bb31cf08c8c68dd58e06e61bfe043d689e1a2477abcad713b33c825d3fe311729fb656724a3395c4b9e5ba05452c4c73d862cdcb6193fb8884e4a13053a4fbe87e50b34c47d5acc20f2d95cbbc8c9640d383469b977db27922502d72a99143be3f6136b96eb0f841156abce3436fab331f8976eb9f730b6d3df7569765a08ec58695e8cfe35fc2f9a7fe10249f3a5dd4ea03ddc9d460977e1b511c1f854df1f7991e6a9bf01c414ec2e58f9c21e0245a8846b3a9e7a8938eaaa3166d3ab5c3519e2cfc43cd86a4fa85f94ab161471268794d75b4d2a1388da146c486393b43e9917bd5a91b25c5f960b54861f1a0316327f1f9a571fab2d9bddeee0d386ef484642bbe0bc841e750eb8bf4416d668032aafbe85a2d21f0424a14ba7260a012dfeb2386df94bd0814f51ea960497a66fd21f9ddb58f71829af7399c3309cd2b289c8322bc143037bd054f5f9fde5171037e6f9fafe9b23e4ed3e412f36ba252d5211593c5a96e6deb1c4defba3c78b9cfe87b0b8a46e92e9229c329c7ee4ad186d7d230ba9eb56b0698b3430bac8d3bd34b568bc2e2c5888716db0912ec14ff15b7d0da0518d44962636ff0cbff41a45f0dd2e69efe1d42da6afd20994f87c7c0e4b3ee7ef5fd15187a36c6f1d8bc56a093ca0ca479a230e2703610745165511fe574067b439fbbf1526fd638eae8439c8986d122fe96b4207f9cb1f945394ba943b55e068a524e5f32e94e955ab9f6d04ed4413d2eb4adf52b3773b20a808ac14e2a6d5e91af0ed8e623d610d46ceda9a4de6a949e4bc4f1060c90398ae715bb8131ad50605413f2bfc8ec5ed3c9b78ded76fdb5edcc61f3b2d0f29d228ceec2581ac2b5b7e407d24e6d1b2af19dd3bc3be8c345adf0ace2331674514d9b454e3ce29062498344b7e029a695cf13d78bfc06a9620bdb9164c8831f8292276216c87172d2dfcba1612df62c0ac58571fcc2607e334644f985f0c1aa7a1f4513ad2302b260f1a10020b425407c9fe0dcd2acbc6e2c86329566713ae94c2af82fac33b275d9c8c4577c3156b0c6a6b04ecd4b71bc57c1c6c5160fe15365221da0aa9af814d1ad9659fb0c258978fe8b8d332bc7cfe972a336d8b9c3e3979f89fcce21c318b6b413b5d0932e0418e3c19d0b9a0445841fcd0dc56a44cb57e09431f3aafa80dfcab59fc7e300cf65dae69e50e94c27a44a375c4f7c7fb2de8f4f595f73abc4bda6b15255f68e955856b9f0a5179230d07ba1f07bdd17557c34eff4b4621344d2731065c1a775512fc4a87b6023e9f3c0a43ee69e4da4153ee5d5665a179f7a746325fabb54e8be5a06b94f690e3cfe9a1effe79b2fcd392405cacef16d9a4814d7d6a736e45a416a4a2b9deb046401253e57477ab75f6d9d11a7036d374f411901f32c390bacc0c1f59b506412df99eafc6d2574a16d4952d8d47c8ab3884a363a82dbe634e1cacf9dc096709a8ef63fb1974b6e3715c27a2493cf191aa0770066040d7198aaf6aa78380d37f827f362062f7319d013f4e2a85f039029c26654e63a6224716738cfb40d1026d430a9016a6b9cb6760dc9ca75ff0b5b002548311c92c4cc14e6f178bc72856a35b7337807f3795cdb53e6d1f357d0ed65d07dab4dcb736ac53a69f1cff0cb76298c6c05295b5fae11c77cd753149c94e0c38bb4cc784209ca4483f06db7bd159a8af5857d9631d5704468f62302b6ea44a04453b2e3914699c6ed13b2327409b47531913d97f6422d8958e35225943cc8e453a90ce9e93f693c3298553fae7d07d2b3766f3f4053a9e7848485c56d837e5284aa7badea89288a645f84e9bbe3c12465e59a6b07fdbfb09b5ab665c9dac975881558473184246b6664bd5e863cb15a761336974528930015b2a716583b139db09cd53df3c3f522be77c3fa3d788eff9eab826801709f48af539e18a15c252601a07feba77f5694890704a5dc8b529466e31c15019f892868854bbd972ef493869847e5b88188f05e60e32455d00a0eb376cf34359ea9201f7b6016763e38cf3e8b58e26e878c4c98dcd2dc2730216065bc13ef5b96ba46d744e3baea3a771d2bf72307ac886f94f03e494fb0bf544184aa724ffe7c08ab01abd443f0aef4f2ac99b7c27752df0979d58fdc15c00cd6c9c5edc391b6fdb8c41c19cccf485b310d5a8b432ea4a00973669b1bf308e56f81739833878acbbbd8e892f8b85f7995196c21daa2fbacd15a91b818c732faa25db968c7fab40d877555c8b4b0fcfba45f0bad491d1ca946bfbf5d0c03ef6db4b03491ef62d2405df588b8bf0b98ef867d4b03e8d0f46875d1fc4dc7290c609f2d408c1eb84f390c096a3b6483b177f3aeae60c7bc3c9d686f6829ead7dc29ef6e898a9ee67af983a952248889664b224da315f74de73a93f04d273ad70d8ec5f435e7c9cfbe47f41340d3e4b87ed358df721305888672707a8b82ef52d37f958af4aebe957ff3c3ebd31675b8235b238da461912a0a9e9285f728c0aa4939a2c0fec1289800a1ad558b59d671923cc2167141517fce5dea65ae1d081b5abb9687d16143d757e364c9d9e8b932adf7d658dc337d26363b74d940d46fb595ab401482376fd353df145d5ce203e8134f7c9d48347afb37838ce2b6628a897b7de20529c2648a73c2826ec167155933f63e6eeccdc31233b63da17c2dc57aac0a777f1490e825b2a8b374b59fc985e62c22ab0a596b2eccbfa1394caa6359340fde7502dd97119312949d528760493a986a567d1eedd22411897e5d2deef09e001d1cb16599277852de186cd47ad3a284c462e389b84cd3141dd981dc7e1e99ab192d1155d187a55f3e1547aeb3da1b832b874798087e3cc789aa7e1195411f0b9692b195c9636ed7d1b5ffed38659745eefca2d6fc57ccdcfce58e88ec2b3f228ddbb915929b8eb4fce5a137b7667ccb7f079e4b3db8846c0d5af8fd27cfc0103e4239adc61e9b1bb4a4f2ee4097dd9cd27ebd9d77f83588135f698a2f587512e25d4b3fa8b7acbcbb69bb62accd385c0561784497f208cca6728e4c098f87302ea5ee1d424cb18a093665e3ef4d339bfb6e96455a5bc10ec9eade607a57e1276cdd10740a373ae8fe6a8ae444086426922ba9a254d4cd13ab08d7f4e9e913eaeee7d0ff37919fcb73d9dfbfd5d6001564e880a5cd07f2de2e21be6088adc85fae1fc484ddd36a21dbb2b44d5f865693859cab3f7dbbcb885ac905e1774ddf2e947b21d501307ae0f067d472bc29ea80c4d10f6ff8e92a2c180b8a64824bb34ae147c5a7866da60537566a3e6cc3c6d91fd48f1d489a2178766b9ec85d547e2a446ed955fa6f3f27dca8d0aabe544abf5ccc7648195c5f800b2994df6ab75f3514b8d3c3e207894d2cc496e1880f15559503cb6484d2db908f17786e98858f67e072d73aee46514e2338c1dcd120d1fd95ad728440e9cf6a71e9f6bea4245469d306bbb4ddd1c00df26b7adc4cb10cf50e07a3f622c66e52fcc06cd389b81a0a7a482c30452dcda50be4f8a1a554e654308f4bff52a696ed8cb260d8a245a504cd0dc12014cdcefdd332be024034d5828d80c6bd0d46da7f594b1d0726030b609970c2a038141048efe4afae80b06c3d22d2ab582e9223d07d9a33d32bad79711bdf0b39a1f7dbad5e4ab36fe6df508867aff5eb4a33c8ba0d9c57575062b0566d5b9c7aa8b112ea240d7329b7e765b845dd5964c6b3965e8284b67f686c67333ab859aae96a18a619aa5dfbe5da54c7cd7b71bff88df2792e441866ba015879e5f19e0802b8e37aa3d9581cb5f30be7cb61c37033c8e68f1f0b396f0a32ae7ba1b3d04c814a83bcaf1a75eeeb5291c35c5b2f8a83f016efd54274b69a2d7ee2a7dcaf2f996087297c515f208cd33d7aa9c49606513d6313699e2e17179f853ade32a8267baf369249645c1131affd0f512e26cfe9585ddd1a19736b0e71e0716fd5bfd2fbf61f261acd990ba254c626b9038f2aa15985164ee069c29d04385e37212569b15d8be008fc81e3a171f23b82191724b4ee1708384c820b69d8d6d73dd1021d099284c09dfe2173ca266822085cf0c4f53d73ab148f2e4c14d973b8b4a220cfc696e54a670cc31056d08952fd8734648d553892e3cf98e200fb6fa16e71146363972b1ff645ffcb209a9c7cfbdcfefdfa67313d56659a75e3a4152530f36e51324ce75d40e06452f0065c0eff2bd42c894f0cee4c0dd2617fa350f2fee07a26d5e38ffd23a008baee9911305544b73b4738cdcad7395a758cce3a77af8c084e77a0cc4188209256e0d544251bd3388ceaaea0c335a2cf1e528610b1da990f428e1e78eea1f1e1dbb08fc85fe160d048c7db7fcb7b665db056a9b00bc836cfe9f003bebb1565d4e074f7d0e6ecdf9d548187f94e714c90a5feb9e42e0823667cf34382dc9720cbde673656b91f0b5e7bc5dce7436d2d0e6bdc56be94ee6043e40262df492ae619cabecdfe157df077b8b9567903d62ec9e85ef378b49f8f856078461ac607cd740c92c9e08ad01c7c387af86d574642b58b1ec7b5b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
