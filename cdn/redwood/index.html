<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a65e080dffc0ef4f0ab9340fa9a005adc9d2d285ce12d668dc7aa323c6a238a4e66e50fe59f6105a5f2f60b52052f6dfb58e7cfaa1b6f04ba71d6c87b9cc9ed9a852c59b90c558c1282f99fe69236c8ea1d18d68930f635926d7da512919712fcf7474eddf54901c782aee624b386127cdcd5553eab5a70727822f05452939f10f2c9088dba4773d97efcbbb192eb714e5358841d0e4870d82749b9516ecc75338a1450dc563b7871d8a98db11e4407ada69976d04de76821ce245355e250b674ff1d98acaaefad4778042f2748cd07f2947f0eb34917cf37a78e568cdebdcbedb567de9c668976f667fea9d2f20080c29880a7f62722ff58aa75ebeffe92291acde159f3542bced5c6983ea2179a09b84001c8eea1cf0466b38982800ce0b51898cc5b93ebb1163121a0e1baa5c0dcadc4217d9103e8549a7885649f897461cd8928d4a31db040a2ce01633b3aabd7527cddd8e0b2fdc829d6a89bbe9debe7e3f684eef7c30eb6f4224078f6e620ef6d27f3fc561c5d3956d5fc3508c3f03c96d68631a959b1cef0a09aa647ddc8c4226c353b75ff14bacfea07569f623eafb64f55f0d8ee168e975d3b79402ae018c7a3e5ba9c9d281dc0dbaf1aa7357e16fb85213b5d1972348da8622e972b165038d403dbf1bfc9a8a6d9a8b4f62d6e26eed6a879de42cac9e127645a377b658377c7edcbcdad28129f4c13ffb4f060f9cb1fdd62cfe4b31b03b2cc718f2ec41c464ad3dda2b01484908ee3960c131379791cbf27cb55bb8ff9214847e04026f5e3dd6509a5032e41b0dfe9d9d0335e071f64f28808e2b011ec69a378c47c60a2bf6d880420d04b04853804aa35fd1a9424b46e619e78cb2cdf435ee9e3e6455fa984c243121cc5aaad33d62dd90bde8d64008189db250510181214857ad54355c151ba5017067562a65744beeaa3187d73e5ad0a5c997d6626dc3c66eabbb44df26cec7728f2be9b320c0e926fd9c48ae00bf1c230e38fb869070d58bb38775c1f1d493e759488e03bea32190be335a51d0e8926179e4e35cae55b633d051cbc8b6c38b8fa88b14b867033c17dd92f0c4a4028b914272fdc88b71909da01c12ac00fa3115ad823386d36c131a33eacf16986b33073a79f45313ef92819e477d1658ec0a4feb8632a54e52148bbb1fcf4d14a2326572fcf526ee54356adab9e1314c310b2362a0d39c436efcd96dab60aa35a7f5030b575f88aeff4680036d08e9a01de1ab8e2dc24b8384044e8328c7897767daa7e94e8450d3dc1e5ba6734e4cc6f9ce002a45c3757e5993d43dcfb8e12f45d6391880b606c328e714b4dee4a91c401937fb7c33f6e8cac06573684fa1e3d6d21dddcb9a288ddfa3bca706c4cfd5a9218fc36553030207e6681150061fd5c95169df662c45853cd7874d976b26322f32da2060b89addc674dc2da6b2bbf398b90cc1e6e3a48b639821f47626ff903507564778c7668d4b2376acbcd3a5261fd1abba8c0f4193410347b1bfb9e0ff7f5e2479d35b33cd815466253af0111f38b1ccdc2d5b30477e0ac5ff050b53886125c680274edc0c9cad95be5d415b187db14400d076b52128832eddd17cff779e58203f19e1e0bfd1bd22a10799e06826c18eb92c5c12c3422170fb397d2f8d8aadc91605a1565342ccb46ab610b1f1a4b5e0b6481e2839728fc923f7281aec80b94ab8cc6769758d133a916426475e260d09a8c5cb7122d14871847604ff2ba33e3e99388588d538a7a5590df35ee3e107ca9305bcd4b3c8fc0d47b76e0dec97809d862ecd5d67c035e9a0e6516113346fddb2d9ee06fa682ad1a820c414072abb921486e48271c9e0b6fd1fc3b856669463e202ba06aa65a6ae16d615e2aca92319c281ff7c0bb69d03c666ab95734eefe8cec104895ccc40dd46892306cafee5c8a028174c58400ae6a50eb9041e648f6710a0e625e9cfebc49aca6972d52a27dd49bc37ff706a8dd846b7daa41dcae16619ce095c27032ae83ffdac7e09dad0368fe93048c6c736286a295577becbf980809e255ba6e07440bcd0792c6bf0a8e7944039aa8e134c57daaa13aa7e72f50eb17710dc36994bdce3d1e7644cab0a12a6d6002b41e2b0696724253fca2ace44415db86dc92b502040907243fa6b87350b03439d22105b11e5412605938b4dbef407cfa839754611b4b1f80d87fa76f51268ce86ae9ea47acaa871be243d3afc626c55a57bf422f80fe8d433c8a92ca0813a1e7fcc3fbc7ea35f04bacc6b39aa9020142f530dc52a426134ab5b6c16b2a91951466c8a594a912615d314275eb629ff8bfeb8c50efebbb63ddbec839c63ac2fbee1e293796813fdbc926b6a3621bb4c1684ab29c4550ef848200de178f161afbe2d7166416b79b193968210a9fe0c98daa580e9df3247ab6ef94e5977db4735e70ad6dcae989c235cdf3b79a38526b1cd2e7a6b187c83c404a080ead506e9f718b7a18da436cec830316bb0390dd5336753321370b3926acb680987ea3a0ab88467897aab45b78820df8fc9951cd5d8db5f125b66b90352df5501735cbd328618b97159c92033ecc8ca83052594594a5e78b4bdc669ed972d0ccc29ddc9f1d0efe57381ddda38de7a5935cae6e0323a6f47402059133769fdf8591d075afbb7a3c3ce52b2c92dc08d63990b0c021470fc0c73e7515c725f612bc0fb316a013ea9bef76213e5fcae9dda76fdac8ee48d46878f782f8a4eb6cf259292e29bf048f239a9b116278136c73b2bb198edd9c1839174f17c48222d85b32c14b4617163f218a3fafa21638e698eb104cd5e70aee39b6e40d56484b7422e26590b3c7b72a8b184ad0f668ddf49792c08be64bd76de5cb6cfb6000966ed3632f8fdbfc792311cd54a0dc3d67131ba38c259eed74e1dedd975f13a26411afe3826fe64fc72bb024c694cc41a3164fd95c487fef4b91d1c36102d6729bbf0d893ab7500f31e7965e489e6e3375e89b323dd573ef8e7383c6417df6c16fe70505a345cd60ef3c35ab25c40a66a5cf01011356d92400fc49adf159d86f40cb97bc7ab6d2d4407fc04949d4a4dd3222e09c416cde3927a77a4f74767983457176ecb317b05d7c8f50de56802ef679c0c356f632bb61927cf18b9814e5461da544bac6f355c8917dcceefffb022482595b08ab9dee56c01691cbff5f17d13e3f1cc77d44d8726a764c5cdaf38adb5236b9743d4ff10d49953f6406783ffa52d8a48ebec91248bf466701b0ea80a7c8ef803a0d435ccb543a275fc57176c8b9d4ae6199d0e6339e7ca1f02705a800ab9f186b3f151bc40eaae8ff164512a60cb0079bfabfdf0e619983239472dfa193893afb1874877cf8bb2fca59e06388b6a1b564e56c37862ba67182d82c5be087b2c3957298870c69d5f7f273e08214d408944b4096254e8707370920d12db1135fcee631f403afbd693fbb033ef321e87c2192a3dc9a499d874ef2ecbc907599f47d9a92186cb6ac11fb7d4bd311743e834e6b248f7ad3923a1e00b8fae31200e7f22330107e43c4f478b7615a4418cfaaae9ce60b0730e32c3b95a499e5701f0e8688d85bee5eb9caf3221239c3d8ce08f231424c9ce09de4c2b1d7c4d604e899889c8e04ff39dd2b172ca64795708e80d92626a4b1a280f7b5c1da5b8960170f86453208c816af37da5a7c96853f1140825d2dd270647c83ce3a1f60b65116717847460da876c3e5c4b975d79093510ab288ae9753e6f68cd73536127cb339d115c7b6c8db7926e5bf1fadb17afb865ae82868157ee78cded5b3f1ec1c13f8055e5872ed89d1f2b9cb536cc6a6c0ce0079a2a4c3a213313393887aefdaff6ce165a953e8654c32fa019d00baf89cd262de71c833b889a4e76e78899d0ee66a053dfcc397e590439ca529f7b1bae9a91365ca38aa1bad0f16f0ee0a75b7ab71af6a850e5fbf181569717eac68f068a0d72cc019f21cfe1abc69f8501a5c86691af44d126a469347a2150c0d2e893e9af345c8935a5d54c638360bed5f5cc7c3ad17d5ba6a0fb21b7f5cf96d549107533859455985bdb71ceb9ad59fd13e4e767353e114fb904574f652ba04d84d10380cae0c879dd799a885737d8e817b39d344647a7cd5dda6c6ef1cba0ecfac6c6179de25698f0b70443d28ae50ff6bdeacbd7f8e32bcdefbf5ebddce89ef3d926671b4e93663c8852dfcf9d908a628659b3394b4ad94b5ab061b392cff17fd25f74009724f2276592329f9f89e538bdf180fe2831a645b29e8fbf41e4fae677392f89fdcfffb79027d499c4870056fce92aa34ebf8280eec91c267ff0ffb0623ce7b96253ea8040f77a6150cc80f50061cdc4c93ca992bbac30d3ec1fa6f30efe0880585cf1b185540364d2e74f9d3eba082d5fab40c040f130a115831aea4af1d900797c3dd39d1f3044c60eb8282676148da040fdde02e6ada73732c497d89afd4f9ea07555a63026867466c6be11e1005381468158125d86e9ce61ca8cac52b49bf9851cb7fda7ca1e0bf4e8fe5d83a175ca61a72c068f140f0b060e653437d6856852d3403740c0d488ff5f089347305338921406fdc12911a21928630d1d73108edffa27dcc108e6766e7d09e0cb19a9c554d3003e97fc1744b12def1d438f452ba07d25bdfae90ef132ae504a845c3cdac32c9e606cf44a18d76d069647a6953e6f5237f358bb47474a2f5a50803ecd047a0836402c631a1033751dee3065f5c8883665694063635076fa90f29c69b21832b0e19c1ba1617f93e19149d7cd19ead01146202b1e5f523c28daab71e692a3cc8e012a05f9a4690caf6edf898d840bbc34ce8878c71392e4196251e7cede04883023194c54d1dcb99565e02e7920111a3a02a8b26d46a7db94efb6a00840dbcbe63fa5327a92326b6332db552d39b480e3c96a2fe621c36c9f365955cf963cb90120644bb4b3816131b7b0b65fc246549a44a99a344ca5fc2b4be45dc5c6bf8365dfcde1ed5a8eb858bec17367fa767da1fadd2e166ba57283292b71bb5de14d973805a417446366417b6a119d96711d6f1ad505fa799e5759776468a61fe3ba6988f185eda9e745ac7bff17aa78c74f07cda3d4908034f0c7112b73875550c04d85402faa738ce76212766ea7e01b7296b4bcbbde840cf5d4d2c557d0fc48435dd2260090412be72a15f82d9ef7b1befdadd9d6a0473a2072b7fe6c08989223772e4836441ce549ffb20e7b1178ee6347731756034fa2f7bf728959efe2491fb72022d2410b1cabe37c4042b42922e22681ac55150577d6eb16061dcc307090e60cf348ca2eb83f77c6e885cfc5ef0f69bb5d5fc3a23e5992938dba016ea27e43644c5bb94f0afdc26a015ebcc93a3d97a7bf6a0b111677cbc469001a831747598f5195203b80d5aa0acd47ed4407ee3d271ac59346e23abff664ae0d6320bf63619aac6a87816ee65c01d939d011bc40e4f8364cb5ab7ee7bf0b763fc69702f8703adf5cca48a8ba6080ca08b4f095c416206d7050200e125489564b64eaf1060acda212ceeae51cc81b2f370e471aec51c93c104b53c75eae1429816fc2820a833030a49001cae60e4d61cb1828f255b1cd99bd5dc3845d4eca56c943b9145d7a5eace2b00955b15fec51d3573e5aecb34a4ff0164dc9d7103b46b0db20681e465313a23955a32b308c7180e5eee95fbffd3a1628f5113fcc44ea69905b7543971efc38f6a7152935564779b9c80263bfa4067a9345a513aca3f323c7562281c666920d830f576f77f7e6f50ba11369338e00c7c09728a490fdd0ef1401c6c5551cf720f88d017f0ee4b16cd2da4845078cb00d30eb9050ec7d7d122d67f963f12e07de112f99a26b04d04da3bfa4d2c00549e7ed0b08bbda616c3c0b1efed47c71627ba220b1fd61210ad2ec083a2c1da997125b753d4d2ec2ec008e74a07b91684fd4cf8f8c116474bbfa834e6459bb53d97b32e3399b29dcdb9060cb5c46027502ccf9c798f747851554736af2772317bf231d638d2543a50873a6e1e5713177dd0d67ae852c0f906e58ba098f38fd5e8a33c28ed8ba5f4249217c6728511754ee99e2a2428a3a641f6f606cacb9640e894fec5efd06d9091edc88b4d209eda3c3f9dafd092b73b73730aa4b73f33e6315b8f544e5f0aab76e915cb28a9f4aaae13202bb8081dc672494a93e9267c5d4d2a04d752728efa9975e2cce854b85a185607df720daaa61358c4984253607a440802e043ce9f3341e0cead36d14d74bf86f8432cf3a4cf3650c29ba834e8b4424e21a69c69c91eff606ca34a2e190dec177686eb61906c910c2660a1d1f29ecd3290aea9abdd59e7b5372568de74c5a4368abf7169b89fb8f4ea750a6577e8ef2171fce2c1360fab15aa25861697ee09bc90b09b7e24a759010a58d863bd3711d245f7ffca7f575915b5ec40141a242993e5823aa07c2537a080776c28f8247a63ff008b6abe03f54997ad29b715f165092e0474fe4b818742977573f11e2c30f07727d98f4352fdb7dc0f4bfd03d3fba81c9a1ac2c3a94a3deb61995d3480ac27b7289e3dcfdbef37e5150109089ae84494eb17a9099f4f517bad6fedcf36ce352023513d193eaaccce699cbc50c2378179fc9e1be63a21c7f9555bb118d54be1a5c86b5823b49161b29bb944e3df31903f44c1bc4e7ad863023bf926dee93d975fcd4efe1a0f948dd091f8730c47d7006614e4b0ccc6f203b2217e23003f3e4d2f2a2e3a28fad2d6e35309ae8e6cf66c7c6e33f7f75202804f6a4c5c0ef6f85ab503d91bb30857720e57c9ea53e36d5054b5f18620266fbf820c771edfd419364c5613385a231442d0016770de920ab6af659f9ee2a12c7346b68b4d3aadec212585116f4506609057287151ba4237bfd40fb3a4ee76e5854fcbfb901d2844fc9a6c8f9bee5fef7fd8239e8da996ac4913ffa71d7b56f4e90be60a274d808f549625e7a98bc4ef6e817abdd9e9eb7fb871491687524f8926f0f5afdd12c26cec041122bbc21a84b321bd85b05f5c7b8528837b5d1ebc6cd62a7cece9f7e4fb964e5034b51a6e0b1d046ff653333dd784949c888d96b098d51a6b62399d1606d031bf3ed375ad0665e292eee8cfead80c90ebf063f6d156bbe16a1207075d5e82f2772d76b6dd967151b456db3377b3d4b610283f6f785ce9699226cdcd868533fe1a5db3468d111551c447645c576ca06ff6ab9aed566b68c97f08cc5a812819b2739d9b35aecfb16fc5db1c3e201e75acb1dd3a2775cd59d4089096dc72ff3c9178f69fd95de5b9c1336b720a7cb74c8d813938c0e71b4a087958fcc00ec48f6f54e8d39bfb323e9bd9e7d132445a3d26913c5f690785e99d1cec1e8644a985e3fb7736c3bfcad8ddcccf46774e3ed7780048f90d7cd46e702cd79740e245964332313b5faf186fab7041d5ee145837c51d16bbd153b717e8aca390320ef55d6c9cd481746b7b6ad829126557906031c10dc3bc1385d40ef485a1d43f085809b5905181654cc56cdf7f82baf73aca13fb69ab933f8beb6c49b6fb2510049006ab83a81117dd9305399ac9d9d7c7380d6fcb916d7fd9b0e1ec930164ec931378b1c2bc33586f41fd5fa75ae122eabc462a5262208760e749c5b6ec6ec3c86799e19bed44698dc71213c33f05c7643970110d718b4e433cf15fda8e13831732edd8513b3295e12f3e69c1057908241df4e877dc542f0d32ba707598d6e1c6263269a4ca9fa9610afc582392a01c9ff37698652976b9492fa8ecac4e1d0fd1af1fa2fbf25ba89e6224f15087ab130de6baca3a825e0efef3866b5f7cd654c26b4ba8c584552e5008db9b048b6075ae9e13f1f79f1d534f1c500420fcb06a7e2ae4e639951371d4f2903fd7aa0262ddc4f324dcdf5f8a8390c7af43fd6633f6e692d18497ebc8c63e74f59cd6110ecf672f5ce8646adb2c9c16bfa8ddb931ee20423ab78fe479424b7a39ef5795149a0a66df5d84de0cee761d712fcc4ad6d6687ad74e9ab239cbe773971489d6e3fae270aae1d6ac34717fedfdda67b22d4975de5a6c550c710a9882451c212fed6f386f85cea85b56f45adf41cbbf53ade693413447e35c07b39688de5610eb73e123874ba3a412e732774a5f6c84faab604db2d0b09803c7993b0edef2aea9e0b183404140fad95762e01c09322b7254f95da90a36228f0f258769200746d537a336eb0854c0cd84e935f23e8ceff502b3d83581edbd5a1089d234c0e8a3b2c3b6dfe12f510ba2402c23495cb577f29af808c33627b672d54bdc5cea041bc200836077e42c4d51591ff9998b85a9dd3f626a9e595eb2777b0e92e3011c17e534d131779ab1d52443eb68d016252d7d22b1b567131cdb1619fdf5f4d6784217ffc2665244d3253c64a78865cfd5dc2ecfcc34a1ca3e726eca3f272802130abfcaea3333facb9d6992aafbf7d728c66dd715f40513e042ca8d2891092012fa24212abad07aeee5e68d824b46dca0703837efd43c92bec185e7a0d30f896f420a059e4a5c1cc8b831ac12952191bed4596b55e5eb26423a06cbadbc560a2212026cfb80fd635a6cc066bc2e9d610b78dc079a45c7bf2304a7e80d2ba9a7b485939da10450b0ca50f6eba458fca524e0990f0f0e73cd18addab04580a222937c841dce1b52f04ea9b75e6e03ae3485d8ce83b794d37bce300fdb7affb190b92bedaca0fb36f9b392965ee58981571db092a9e0ced98436c375b6dc1317661dafc53d4e11770cab8cc4d1ef366466d32199982c8ba59c6afab996eefddbca1850af4e93456bee55a5b6218b686cb5bf140e4302fb93469c0f22f5809acc03a1a519b4c09b347c370cc3479ee3f28ba95863385e743cf6388ca53d2353616361cbcd1f00cca2520b8cb81e49340760764b2e16a678ed0f5036dd445e09b5d4af1170d093f3f13c0cd2d7502a622cabc3c7a9b3a9e38eb776b1efc7bbff72c04e7aaac7f6dd50703e62f8b746b5e451a24ce740fcea87483c1129b4292ea85c4c6b50d4a36880308756117054df99bd662ade694170268fa1361ba95a7696399206daedbcd638b43a4dd75f1132b29a3e941c3aac79cdd24950ce7e6ddf619491aa9e3642c81e46763a5f41c5daf9963d8f171bc3072ac5c59cb889daa3fe592edd3bb133bfa0cd4f3edd188a95ff25ea5843440a8cc8b5dfd0fe7e9365cadc0de7d707bb99501bf868499e15f149bc211b886afd8a85f0a8de3031f58ef10e50e8487ee2ed2bedf0521207bd1e83614a95966ad1faf7e214f4fa4cff2ecca15a81cf9bff2b3a39723d2d1f1e3125360e6d61debb6df89aa7502ca68fd38f03d8d05e5936a609c303447569951e5a9912dfd4419a72e0221d6262f185ed8c89928d4ddb6b677dec597ebd6d8cba6f5a777d6b2a6ee202d4a1719208cadd11f93915a493eb266f596b4507254e99ec011ef3a34a98c3fdb5e9c5f22e92c057f3591e9cc019d850401dc9d493c2104e84cfb46a1592abaf48f08785614ab92bdbea9bd34608b3b65352e4c8b7deca54582973f5ab5668888e1cea434f6ffc38e89d1468cc2b085f4dda6e090f7d439cf52f1329105dd68d9f44095ff9e6012917d41f7c4b7b70237c76ca2ca23cc1bb54fd9035c59b0f44445810cebee5e1e06fb093cbbb2299230753828905a2ebbe2446f2e90b4b6cee1cdfc97fe654838a9b3731fcee0248ee069e22d09df9b21d7b1bc1597cd89a548f3484b71b7dda9e3ef046516c26cf68b9699c4bc060c7d726586a8c59f6ae23eb64ced2b79ea531918b0426c7fd053d6df327beed54d8cc4b073f95d5213c71aba9bb4c341b6df51021f422473e50b47e54f006acd90b8a62c48977c8652ed564c2b7be1e6748564c1ad316884ec3a5dffcda0dddcbebf0eb2692854c0b27b19c936ca42c3eb5958d62d4c2b5b421f142c03957dcd20d7bc13e8bbd9551ca01c9d2eeee36f69d07196d93ea791690a0ed01375eff6940cb0716eb4805ec59410b0cbed03551013c46f0193c0bd27fbac18103ca8d6e5e68e1aded5bb0ed326ce4ccd1dd11c9019454a45e59f9ea9aa7ccdb747dc925ff489f7283232075d891f9f9731b7704941cd38507fe7a006463e9797ed479e3448ec0d183831aca8e20d3de4880c43e3ac23771c70d5f00c8e84a66c77d31902727a55aed73629cdde7de01c2e18b9ca950c3a2d5c3af1131c555bc16100ad40afc6568c59bbc5ce950b99accb02d137c1119c5680addded5d09b54ac7667ad008e632be6d0f641138d541c1dcaa252c4f4cff5d7acc234046468e0f240b82c805d79c5a88c086862a706810edfe0c5685fe3fb80c052aa0505a6e78e2c2ad61a9479abd1ff63d9909534c54d26a0e617e1ba9d27f1835fab2fd73ca04a84b19aa9084573178f7bbd929d7e10875bab83e2b3175c5b112aee77b4dcbf29ad988d55ab0d02018908e3bbdf45039bd7757fdba1113325807c12bd79426b73c8673ceecefcb0e3b8573d20bc8e0469ee7c7ef44323ff1995a25632c632dc6ed14f3adb2abc211838c8e500ab639319b61453862fae9093255f01b67707f3c249eabfaa4cbe89c11825d5f1ca07b2562a5951325e9aab933d2aac0a8bbc3bd323d9fea283d3e69f39e4c4f5b7bcfad847cc72aa8fc1322b1466c08d94cf8f1fb1c3fbaaa714d61a04987ab172db0f270359e094d6ea886c46ca4198b8a6c034ed2ed6c20c0e4733a6bfcba5a46acfa7f6c9ffe9aec08a68dbf824038bafd49103cbec2a3548769d2b989ac5deb67f6cd87cfdc91790d64ac1ec9bf0925a1dfdcfa709374164916edafc88b02210adbf7b2f61795e319a61c0a632d31576fce91ab70a8542e197578a97e41829d5169a35d191d626be9774ad676b1b0ba8387155d7b9430d227cdcbea5196cf0b044aded0376aef8a2b2f58247574dd85e5b0e87cc98f27da37e48899a068a36bb5664602002ee38a39b71e7ac3faa40f65992b32198b195837faf56667c2bfcf15cf41ff95ac8a32d386e69b308dbefcdc148c1ad002f548b0ae106f7a5b3fda9741bdc0f49292eb9a0af3446dc403798896a6476bfdbc1bd9f98047b0b57f9391b50b1fbffd673a732ae3c18b83eee14fd45afeec5e55d47c1dd198a8955cb96f3ceaf4bde9799e3fc2e0848a508857cc41c407841f68c1cf8cf688eb999231865539714c01c14c80f44702ee34a61ab78f2bcca02459c03903aa6aaad0f4b67c79640b51d63025400ca5505835e91141e360a42ba66e30cdf7cf5313e488aa067747ff733f9aa1b973acd20bb042866251b0b7bd7907fa27e8085c40f6aae8e8a2c1f1debf5d0bf946cd144eadc91a3449d862eace21b7acd44be47e33673e664db0a36066275d4ace61e6cb47ee75cc0c3a02eb055ca50fe0638dc69edd7b8d1307b789f65bdcbca717a9d910882113cda9b49e8a13771520a15411e7b175885f6b78593c896d229547f642c756f6a46cebad5c56f0f8a28e55be41ab998930d8b0bfbf202f4aab6e5daa4c4d28023c84a1336b0ae0c9e34abf60299057a0a616e58287ca74893b15aec29e1bb4d82edf97dec032d9650e307ec59bd44bd6d5914566fe0e9cfc3687e2174ad80e813619ba0318a252f8921c239733aef86840c1755610514871c971ab640a8a2f1187e1293f8ad52363776b79a13533860d9d5bb21deaa9ab0a0eeda29b2bfffd636554219d58f68068a5e35dab5e52303317c7475a6d5e313a8688077758ca382cc6cb13a13ec63a611dbca280822a02f47acb1ce9d8602771442f4e2f48725f7ede77a4aadad2f797772101bbf1fe0c20a25d201c81420479f5a7a0a49417a84b75712f3314d17bc184c6495b9bba357e3a7baba8ae924883be57dd519d59df29b664e00151d451309a7fdcdcb1624ec4b49b46ba9fadfaa46594a419436d1fab657154672c599b4501d48de3b5ef8e5645f14725997c3ec19da092f2855eba466dbbba2927e9ed91704be35d23be68a5998897fc64b6240247c2165793222fadb46a9447da8bd9bc30f4337366dbd5cde693401b367e6f9b522f36f304cbdb8f0673197d9fd030293d07e59b08ef869615d1a70b49637a2ad8f4652753dedd69bc9a09cc5cec99eb0df5aeef0c33968adf73f4192824ab3bdfde3e0775b1e0114688da9957c213aed6184bd26c89ceba06183f4d15053c29921170e07232f4e43993370993872741bc09d4f3364ee94e38578d0e190e34e26d5b0bea9f434a4aac745a802445aa2ce15cb58762f440b32ae5c1c67d101e4eee0226f8670bb1831c9f4cc9da1aa2ed404a1af87cc2abd28e8fe85f3b9f2e8d05f22b645b0366184c6f29a024d8893c4c8290abc6436aa29be3b2b59e24dd475227e9e28fc89c9f255273e1b86fc9cd5169e31cbd831328a3a099aed3794bfc1029b9b3aed84d916411e459767dc911a8485eb890fe5d1e0c3c2f26de2f1de1c97a7cd9c58d7c82490c71e24dece75a72028345032d217cd6fb44e72b50f46eed2d012a37bd9a2b52ffff384f9648052a0868ff9be0acb2ec7aab375bab1526e3ea6b70d8a44bfae3345b5be38c4ba5b676f068cc6ab98e72e116c8a9aa1fe8dcfca1000ffb1a9975c30a2825ec7ee1b2574a00e47c1746c99a7f1a2c3917bf70fae3fe452e656119728d2be3d688226da8d45121f4007fa346feed4d3723db24c745ad567b7f40f27e686c7d16597f5bfddd4834e6899663979dbd4ef535e48fe6c59590a5df4106cc109324dc0eeeb76489a35c01776624062f801ed14429576224aa4ccf3cd48ede39992a35243512b21f91db68831ddb6904f30dab19e853de6652432cbe3bab51dd137d526beb657b58d7de54dfb555cd5cfafecfbe715722ca1ee4cced788cb7fc90f8905579d42863e468c2edf4dc092c6a7b380b5bdcb6f57c6bed8838bf6afbe31b8f2411223c8d9780bc7f3f98c7882aef709ea43a94c2b3c1c2d13cbf74db84b20ebf6cf70547ffd3773efc3baa3d2f4e80dc3cd06e9df2c7289c32c595af4291fd1116fc7e9f56b06ab5a8db97e3516c1ee51dcffd68372598cc846b673e4c4c5e39a52f3c1ce4a9a57b1d709d3ab2b246258b5a3f105bd3ac5e94c0ff484a99f490753411e9c60d2de41320d2947bc406f82cde1665ffa5ccf41fcd2051c5f8031c8f5ceacc83c905a4769d428dbfd4ad7e76fb1a2e83e55cc5d2246581eb8d84b18c5d9a2ca5d2972d07cf737cbaa45f65fc620b67289d46de6d714f2dc986e4eed40b82caa88d1406c7bd3b98ce4f2f7b459f155ae583f409c51ff69d5d18a233e6f5b3b1be6f265da4c4c126a01fb624b1092c3ef32585c46e9a41ad3e254db4238bcef43ad9ba81b6193594c66ff3a7f710a00ce21d9c53e013b2fa0d749e2cf6e3b7cb68485d8ba39eba4bb3733a5b9badbc9881a80c6ed4781b65a6d786b705df1413887cbc38c1b880e6f64af76e4931af9923306ef68813c74b8bca809963e59d20ba038e78cda6dc4701ead5b21cc6aab4aa95ed55e093bd4683d2705895c4854efeb7086529e46311c8edbab69134978a06a43331f4b8d7048b588d1aff5e3f17d9aa9c6c053f9f9e77bd411666710fe88fa0aacd0eaac023ed733ef64c7bd53730cde085dc2e4e7eb0220d562b11c78e3d504db9f1b16e39b9511e7563589c82ed46226d0e67ce9566529fb271449325b0aba3affa8dcb462bb3ae694bbc1f6db53fc1dcfb427b0a94ff32be2acea1633c753410123c9ff32e8629538c04fff9de90500b3c229c85eed9032e152ae18fd569cf7936d03bf49077bc199405c01632db693c1092cbf3a837be5f411d4dc14e68ef9801e18cd1e1e638c3cb6602cd2fc8572edfcd0ab7e6083a15b5746a5debac523ff2c8f94a4bd7f7d19e5339b10d269a6ddd9851ae5e55c6d578ea80e928314f77ec2e563fff89995bbe2cdc88cff7e99dced8ac53a00620f6362442a08d550876a1b27c52ff40dd8a6e50ccf849fb348dfa6c60a13db5495865243be1671a063321287c41d302645afedc2be96dc8337bfa9850a38def8111a51119f4c1d9903e4c67be76b8506addb1b176c977aa3f2ad4ccb33636c3d4529fca1403a1f2c22dadf35bc3e6846eae71840b1cad4873a602e0e1193d1c98904e945526919c84b2442d56cdf785c7d6056467a05dee094ef4970c6d236cb3b2d7f1e84a4e7869e4a248fc03aa0572328d17fb378b73607d519db69874f3365e46bbdf02a8641d7ff07bb699e3ee94d66dc5f6d0fbbe5d9c39693c9511de749044587b144bb13871410522603d2c8ce0d90e23cce929234caa150456bd1cc204cfe7ce2c20ea8906f7b3cd7e77ef6c25c644be5fcf8bd3a37ad14971584e2f3d97f08a07ec82545526f964843bfe336a9b7138c5cd1f2e1a1aeb7e25d7569314eb827c7556feb3047da94ee4f3f451c31402800ef7e43d9720555acc1c4df7e2229d36f2409792fc20b6aedb95914f0affca4f3bcd82552de98b671ecc157d489b3dffbc97776b84f231921f24dfe8224d9b0b831df72baec2aa1cb17fcb6c34371b3bf96796af471bb385b0f13e47ea7842805b0ce4b88c766eba021ee4f7c1312881308ebd1e717db6bd061d85df0d28413c765844e20b4a83d573052f90b1ff92328456fe64f7c7326e68680f2750f49c62ace91b8e0ac8e7796d9ae212a742b21dee5656021bc3b9ea85f3fd042a201ae15c13ec2739a1e93c291f40acd9bbf1001dd76d4d1c78b4b3c12452265dc8d309bb3024169168f6e720868ddab9fbe9985ee106aa914ef057d38dbda987e52ae3756663f7ee0a5170d72469652fb984b36d57b3874a3f19e109f112bfd23efe1d5defcb990bb8a810221cea0abbda5d56760013d2accbae35eb7b701f4588289f8c37d8ca572faeab11926c3368efb72cbcad878e802b746c33e5d269ba54488111278fa3051c24c9407f0f74867fbac80429a495e78892738371a39cf676d1e0bb4c10ef124f91273fe5cd91aa5d65bed557c6f35a6ba864293e32c4ebc198f00a001e0bd3f8cb93a34dda74d7c2c77dd4e2e57fa0c70256587e7da5dcfeab8a9b46ee0a333334d3ff366310ffeefc184d0aca512ab5527dd2338e2b83d7c85e7a8929ea778eb2e4f9c831c7938edc5950bcebcdfa6df2ebbfe67fa31e90a385e22d3c2a93581661e165fc37e8476dd9b73106fed9e2f4a51bd27fbc02879cdb2d35a3e1b930b999c0444c8fa6232a99ac90689695156b319395d39ea02c88a46d9c1cfded9bbed589985c1b815b41ea4c0e19e75db757f3cf75aafb82c40f05c3b42ddab9475cb3a329a4373667b61aae94fa936be73b2b594aed282dbd22a0c16550d9bc2e579c25c9ef969311e4c1fa16c8e80f13ea42427e70936ca043297e26d594be7ba9c243661a42e60e41c98daf055f0d139d1b571202f418c4cb76f20180019a2b2763ff2ba1b57716a4b37e6bf1d3af2525f52069c51c843fffb59e35271a47ce0ec7205702c9266bcef226be9aad29af48cdf7bfd491d1006f7c39c59e9de4f8754ee75bc64c596eccfa9f0534a6f237b55d1fae6bd5a8d4f2410f6ffac071cb863e5b78ed0e5d6c49e25c6061e37e508fad7496fcf209cc20cf583953bea0af1ec3f276e15e86427555c82a00e07345b43210b85d7ad59e2d1154bf5124d02b467d070696626af4e08494ed401214b62b6fd14f1f5b1d8c69a7904e982b4a7326c1edb98873e9f90325707d8dbf25fe97da01bee9f618b37a2b31215925c1016a5396ffec8ff2d770d872c5e0aa75273e1252aa43bc638141ae00a032d266ad4b58e932e4b67f99e06f3d044f74b342808546565be2cea8ae85b10d2b7f56913c511e4884f607c48c7068cde972bd94097140ff571cf17189421e6927a12cf44ebbe86a76de0fc003d19008e0e5639a6a26b7589893e182dc660fda43978ff1fc4af6421be08b69ace60c04a60632a50140f97e7d7258b3a9242e5676ac375518d7271062519dcad1aa1d0c780bf9201997914ce5d33132ba9c13496d09b02785a59950f718f986dc2ae3a70f19fca46bbd18b96b98166a87fea44437cfb98e51951ac638d186f8b451d0e1c2c4c5513870bfa35c9e22853733dfc1afad24c885a79a20b3833309dfb9a3f01747bcbb15cc544b36630ee101dea5cb6df6a46bb6078794393e44f13b2c47c194d7d85362f0a191a7a05c0c568146b147fde5088e05c91e6d69e2c4eea2e8c798467b26269c60d3bb02b24caa7b285526c2451223719ca9bc21073d10f35a8ed0de5ed79cf0bc2fa179ac6a492b415a01b4cacace3cf4d4531a3fc41f0ece87a9254c133b96a664de3e22c5dceab50a3e08fd7027bc8f1bfbf39970cd47b2eb4af3819cd7012d262634b2f9f8a74bfe84f183beeb27b531885026002afc08d626eba8d22623fda566f8157dbae0ccec20710683163905c8648eecf92e98876456abeeaf78bd7da357be69753c56485128d9e3d1d396c65f27e34101cdc42adc5a7162bb2e60a8d251099bd7c948472793b85bf97a27332d400cf1662fa12cf0abecc662be5c82eff2dc7af51772b6fdb8d4b31332c8da612600ca75ad5189c07d6e7650217ca8ecae354378872e3cd290fb8aae81e8059c883194191790bcfcf352db9a20e7a086bba5022294a9c9acbbc9046a5335949587a79d0a638df52531e2c61b24435e10eec53704c0deca326e68e9dff9997a279dd6cfbd2163388733f6a93dbd7c8091afcc66150479fd45c134dbf013bdaefcbcbce5c458c235a65ec79ac3e3f644edc5ab59918044a6dd30a198a0d783b3f53767c31f49e1b48301b9009c95af927c6d0caa8bb9bba09ac09b9d4735b663d30adfedc72b974ddcfcdc3a4e4989bd62e0212dbcd0b50c677fbccc5c2e1864e179f8cec4ca9d0f425683099f186a1f2ee6c37037467086e76662477057f2693b538f38c4724a1c277e0c75717ae59e3fdf21f68e59c2b73d313422f9b4ee1bd1abd2b64e12b7edad0acec7bb9cb5431b48dc00f26399d36c86af61969ebe7f0e3431fb368855f77f3898517648c8aaa1aec77d27a4f1663223938d245ca31c9ee34454f46dbfa9c7a78e547235e6904a98ab23b72f938f2665e312e0998f948161f3fb6ac1ef12b91c8bfcfe7ce634afce986d303486fab2175e3f08578d33288eeb374540924dfd9d7b8be0b5b4893e506c896b29d13b767b188e792c8f980f4a75506834aaf079e3e19d3a706cc1b5ae806d531c0c900a7a7a7ba24750b7e833b1e694eec67b126df710df8ec0d3ecd0ab77e79477998f5f3cc518eb2f749f0bedd16ae962b63ea7302ed7a1bd93d6c817d7d22799ca6cf9b30bb9dfa2a16b4f359cf3e5d23db02fbf69b4fc839a2a608557f771e7f24c08d3b3b8a5c0631e9917bd17ccef6a563414da9266e44417f57cc1dc58c39ed149c37b72bbef3f791d8714adead2fa6ad1345e99628a69672656b68a496fb41dde4c5f0573e747e767481b950c86a20e3f9d111a7422ab4e8c80f23f733cae1b67b766669aa0dea3ef117cab16a34cd030f737fecf8bd2ee4b6fe956a984c8adf3b08e55d3216abc179b401daf2358e47e8ee14246ae35e8f23f7dca9e40bc0877e7403b07354245fbd036d275460e5f2840979af54af7db9c1acba447d7e622cbd91fd7d11dea4f4ac33939311e60d7c641fcf537e21eed730b5bbd4361ed2a64f714b95baaa8fb1390d4b25431894157253853841d688bbb3abac514710e8471b4b048837a1352ac5488cb5f1a6082c43bc3e26ddb2ae5c5fc54a005813adacda5b6b82a60ca305c6b46da64b00f75c24b0a2dd1c4e674287031e3c263e5da37fd6b0b32740929e53316fb8ce795e5f965c70993e8092f09f02631a8acbc05a41ea698cb0e6f7a0654cf4ce5bded6d35b1117ac839ff31888ead23d2cfc252035016839c0bb330c1fc5226aeaaaca2b1015015a6aa0e0e68e1bf65e013ed50210f3910bdd85fbc590f0b29d1144cf8b8a70b7c5e8d130b90a9e49d8603a06e01bb275f6e6f36a44a8f78435","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
