<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4066921483f9ed44da07c3a2250fcd3642132afc247b0510fb323468e34f493e8ab0e565fb129536a443383174a7d9d6b4c888a3a5b9af8fce1b89c336160c599676ecd9dc146e2a454b5d5e387256ff3a41ee746edf94f4bde176007d3b0b6d4e75e3e134168e8923a7cae708be20d941e5b5ff2bacd3458a5b7b7a0e64c0dc3dbc1319d65589478126126d35d0626b539ed98520a5349fe26892e7f1d23244e1aead76382c0c59fea9144bd34cd203eed360a40aced337988be35ce8b92e034ef9a4ea3ad868a2c3ffb8fffc042e98d488b058a784e86b080614d48c64dde1967c3486b07d4e0fc391eab3e7da6063f7dd969e98f6266351cf3b8136361e3050c21d934671a5fe9a89a1a8d135155658e792d28db2cf44e29ea69e1875e25f36f03b7addd528a8b0d5c41705d9391591a549ad76d95c2a7e04dd928db712ea30677075d00cef96286e45263bcfd1073407ad599efa13b504cd7335636fcd84ff19d4878be115dfd54bc206608bccde7a0c565a9f85a26f68ff07f89cea9200c80f68fda0896b75d15345a98475393041a560b6faadce6498054d0b349c8bd47b41219dd14feb2ea5c70ad617a265c6eb9d3df51675f8b376fe5f5b3e7ce83171678b709dc4135e9c22eafc29f7ffe9c7fe34dd70f269832f254dc6188f97743ea7673bf11b349ca4c80417f7432255e65a9adca3e6fe6649b1fa30b1b6879354d999655642404cebe1959461d5f72ee68998ce8eea2541a706240044bcd634e9eb13898ad6a59f494cfb1c56d1cf91fe2171c33a81fff498939591b36340b084c322ffccf1ce274465019f60a6521fd62ecf299f65d47748278bebde5148bd9787f21e180492b35230feb120f3566af06b0386cfffe30a82b72895f2e192e62afe6f64db19e7298857b6c79b133cb88682b4ca8bee91573c033e6dd210886c5a22be04ef66f15722f743fd6289d8bc401462bcc698bdb22b2a457a9c4c935b9db9c357166bed26ce83a943d6af541add51eef2348d1976f55301068d1797a70ca66f0e4602ab0c82463f54b6f4408217b3b025160b66d045dd988d98ec96fd31844415b210bd07a05c72918c913bde735073c619348c076c0a1c7cf21fc4d992a1ad613c41d2722499e4803df99f722b8506278d1e666ef905ab21cf4df6d570f7432f19cf9cc78a19a8176b702af840188cfdffb27ae945d1aca32bb87bf0506f46f79e153c53842ea7e1addcfbb5a9f01c756e81b38c4c7e164de46cb35a35bd87185350580e72d100c9247faf123e712f58dad3e74b3d22341bbe12b9826e1af1037669be4f7e7e9cfc5367efa0206d97aa15bc5920477fec26ddbb0e8f2f2762780fe9fb29348555f15b638e78e6fa59fab97adab0d24d258f1e1e4e9160ef40548ee8f7a58e161474a77a07d244a31f48748c38f0c56ce9f1909014b49d6433f69c43b0668482fdeaf8a006ef580a24903e509ace59666d03f74e18a28cd10614f907784dec926fee3db4bd6f0ddb748b869cdd819e3efc942a7481980e5f756093849965f24923d2a554057d5e90e54a625e13e672471b801153aeaf04424f1e5af670c5040472e247d4faedbfdee8d515e145af79ad64bdca42b48ae73e8aa0db65043469f9afa29c423e59e06f388566ee3f61c427fc8764060e47f713b70380f40072896e403e56fbb13ce440e12073e7e0c0410c3dfbcee7375672a25fa02cd9dbf38495ac346c8e155271ab17fd93ec70554211d3e2f6861df3ad0d93b5c360f0c299d522a421d09c2b5863ac3ebbf0efa7765b035a29d98f5c7d5ff64b7abb1d8403357a8ec080ee26e4a4e097c3ebb8d9db1eca7ae58afc4c591c0459b539e2c1c2f046c8e4997c9c7e99cca03dc939f13a72e167f42d5fc719891a764e0f12d1ed25ff89b0c0aab843cb3895a5a19b8fa38da608cc726a8ee0d67c9d77ce1e9426a1888393af8f4fe9fecd1bb2de2847c3852a2dadb8353a6d156c8ece800d3cb713dec810d99445d467572d676ce1a87e523edb8d1666361ed9c43e02452fbf68fc1a6d88111e3d8c4ecd5dc7900361adf38d4a08b5b6990f7e3b1f2873b10d6d5f89a349ccd1b1b927657adff518a6b40f98871d3d2791a5d0995efb91706af62b7fb8d1b036fec7d1ebdce7c6676d06730184654f510a23849094fd713f6f616e7d6288c27cf088e42c6a2e8879c009e838c8ccc3b06465c30fb8d6c65ae782ee8d51eda1c1b817a8a83245a471fc21195fe67ccc687bbc6229126c662a6ad306036a3038d5307cebbdc3ab29cdea70b6de53298a4a0e80bf7847fe3e8f1156d0877ff0dc64ec5fcee90c43237119805889fc309fdcf664f91968e3c730fef9ad645bf7cfcaf95cc4ee016348097b82321c2de28b2e634a72256b4baf19519d6ea8c0ff2f620ab0b5cde6ec7200b7f139b76501c61febd05e71c7cf18ba9c9da9dccc3ff0c53955c11f54edb0e4d44629540e33bc5b9b104d3b05837785cd03f72a96f6fad9174bc2f762f4360e5c9704d08a50b7a79394c1e1d1d4e64f933430d2d03368c528106e12539951bbf6d6302e37adfbcc148dac2d1bfd9c41d0960eaf46c9afaefa262f123013528c9f087fdd709daf0f8170ffebfb1689520faaaf25b7f9fd0c555637488371c5965c66fe7ca010b3570955566968dbe9d21fc873a4da81e6d40f579056f92f587a54341a55fd743dd0cf594f066e01776b5c2e7d2961efd27b43abc6221e535aaaa2aa827e5fefdaad90162d6dfd19d6a87756b933267e2cdbd46d97f721ebef031984d69444be86e54ce363f2da1782c811519f7a288b6d97c09cc1534e76d5c3c32f50060903e6626d6978e43416d035932a1f0fe8ebb4fdeb6787df3823f7f2d86d7415fb354adfd883eba8ecb15b720dedbcd076cff94feca49dc472689199bc21af9ab9bed2d2454aac75211efb4b7b64c0aff8c5fb32f77ec318f6de1e19e278fcead807bc90eb3125bbb1aec73f100e300128de1ed0e485012412855c3403ccbdc59705514fd619280081df9ce0c70f0db0a951bfc00ea5823b4ec7e6370dcdb1893ee9deb5ac04554f28087aed56b2d1dd6e0a94ad35d5029a898b4ef3a8f2e67df92b3042c2851c7f157dfad4f41a994d1a518d9fc6c3c4295bb045cc60275261f6ce22ff210552f6379bc16888ef45864a681e4f8cbc7764d41d55aac8e9fe211c372e827458c15fa2c68fdb65236513b77c5f75586d2f370e950c4684e3f3594529fca2cd04ddc85eb8dcc6aabc4ddfadb69df7c341418e8d4be1ba9124a16db34ca14ad99d54c9ec67da2d5abc8b69b4b3878f7338b4e66a7dc2ff6b631ceab0286125deee8882299f9d594d87d378e9892953fd8477fc9eabc7c057dedfdbc9dd4d61a3b49b6cbf7d3c89f057c2cb8db21e7c75b10967750f9453dcb9c7f129a594604408f41b5fdd1a3f37160ae7783e905faab7623eb81022c6b297e460b945f0785f6af970b1e2b67e59d145361af694cfa85a5240297a1a2ee2f75da91ddfdd60e0358d6fad84dee6e9418e129fffeb1da5a6747365e2b36804c974f8365370a9c5c491dd46f539fe85e3997f20c41c80b26156b1975dd8a92747a09d2c9070fde62d21b7a19ecf55dc636446710470d9f601acb4e3efacd074eff5044bbffdea27b656741d03c0f81e264b83fc5092b10a94aa294c93fb401229c2054890d520c93abefff0cecd73cf2d81e6172d92a8a9c5c8e8d198c607820cc3392b32aae398547922ce918d0efabdab6d10653936b17ed56ef34a0a1d0d9664438e440b5cf3c09f0d7d17b0809deb7060c14d7c5d3fd8666ccfb6c1e582d1e7a48c5daddd98931983b6e18e6ead2a2c05246570fc2d62f835ef14bd55b451adac450441d5324ad44e9e230a4f6e7059e6340c3446bca54f3aea493e407f6ce2f1277bce5774ebe9cf4befd0a237b9c8e24f4bbbac2a51987e087a87f881f79981f84769d24470480095566a08f5cbd51d8469ea29eebf4d2c44dcbe5e36056f215c4c1e517f76e45b3fedad0354c722baba9cfec107b906bacd3c1dae677c781d528fc3e96607e8ee3b94e5a4475ebb6b6f3e601e2c9a5eb35cd1586e30e7f35f6e9f107658133ab0bbdccc48e750f4149f6b4853934fc53d99ed895dc7e1e02262ebcbaf09a5161624bc6182a5cbe755078f384709f6cbf642fac23463b67b42256a6f7c128af92845e05c52f5f4a9706537442f79bee32550fd8c23e88174a3480ced50992b35a15e3ec1480efd290872a7e591b13f08f5f4a325776c2e7e704e39edde57795994ff4eb48b6eb4918bf308fc4f89ad8176fc6e1010ddfa8454d86c4319824ac047e7c8758583d3b1d4f0a5a281f7787781a7f545d52d9e19060579469c5bbe30af1fcdcffd58cd00530d0633c19aff310025119eca7f72b4978ce6641925eb192eea7cd461c5ef60ffd9ff45d1a6a831cc8108a0e4316e66801ba7ed82ab010414b5f2685864355aa9ac3a6886b43d3b2621b70f36121440529404f462bda862707cad04af3603a6e27d511e01ed6d65c68c543e94d5ab1c3896b02b7c3d53a450391d76823150f7e094c347ef659f87e6c929a6663ab642956b03de9602f47ec3b447fae0b9e82ca6b119ef8691013ceedcefbb3d572b1c68f7ec71cc5e2966c9905928cb4db5ab46d7ab093f3d875b66ba52b230f856bf20892880c49b0f644c49c5e92dfe0870feeaa5aaf5952d859c90effd4be30ab5dc8bb490976ff4be9d4ad0b1570f2d4ccf4885f01da6b55b1fdb86e6a3a8cfe3b23e0ebaf32dcd91017537fc4bc248eeb33fd4a4e675ac993fa616db480f01bd6bba4e246877bb1e0f51f022774e98751a68960db48a5fcdc4aa40a63c2cf381f360d9c982d531439ae666baeaafbcbe67302aeb46c51b72c9143478be82e57c52cde0037d483ee8fbfac8ca2c2d77ec9249fba1a54ed51153d0c103f304a48824192db8c33919e07e054bf3882cab40170a8c40fe3f8f8e34c74c805f4c6175e67c7abd0d97eb12b888d47c2541f9a4ad04fb9a20ffe25305f23e06c0f880a2cb559604f6aa36a4ad28ca75304e1f7eeccd8867e0f993af0f9d57e4fd5d19dcb40e148675bead3e92042dddc38c01d0685a8f46f93ae76cc33d965326dc967f60cdcb69cb73f438736e827dc58974d92a69407f63bcd171c0f07e2d4d4cb7c39cb3449788268b95995106fad8e4c852b3e54fc6fe74cca5b729269803bfe9f1291a319af57cdf968c1bbd13408f205b0e4a29172255b5c025fbd24de11ec7dd9d91e85aee1464e080e678fe524eddac3ee7f4a85a6902e90796447807ea18d651a240564ab1f24fd2e44ee71d5eb6e796507523b732b75efbec00cb5dc6a901457acea91eec385bd99b18c64752a4bab06c06fa654c5c67dc7c62250505f09ac225b0c21e8a49083e1074bb3225c026e86fd56e0c643d9f0d13ea0ac37d61cb2b4f2e78ad601e3c4693f09e0260f801d1c63be85b59dd690032023d4919e7b94329f2b5c4390bfb7109cbfcf66719bd1ecaec6babe493f590994f96033ae20f597ce6725a16335e475e1673d125b858e30ad79116262e68fd428ce6b16966dc087721fd036e6cae881116b5a63e7f8f25bdbc7dce30c3c18349a9a645a75ba8a047825b119c9b8993b1159a15d14310483c75a5d9340ba10cbbe9949f05ee6c4323198cc3fcc55903f8e113ab0283ab50275a1b773555dd48792da2ae014fa679f525fd08f1ca721549c7334122bdac4b36edcb829cf57edff8047a5087fb9fae9b1d81246d4aa4cede98ec0c6cf3671340a69cf7e409e10b3a841f9914dea6d6cccfe8287e351b2831ceb329ced564d8a2b395f01751750b7e0966d1acd62367fbd436ffd45bd8d7f1e281bbe684348800de76f2708220f3708b9373531e25a3151523460840001e8e42d0135e4eb3b455078448944bc5489650e4676c5f5fce9020da26b59bd5c3a0da745cc254b6db8b7588b3dcacac8ce5eeb6ba7bd44a2913a3e0bfa1c14d4f553d58a0c8daf97d8c347c83322bbca35535d15663bb6dba2bddc7e0204afd1478e47e25519dc04a1f8888820a637329cc4575366c85f23c72731efe4c232a7339baada434235a16af6c8186044ab1ad3647a563ff36646dde9b61e97d89ef1a186498eaa38ba6416a220778114978e8b66cd04e6db6b8abc1371c3c10b0085d2e4495d9ebe98917989ec05451f5fffcac108e234bd81ceadda8467b0a2abb5b1591f06e1b6a7ba1faeec085998f1e8ec7d35b7bd123ae2d8f252b79c360fde1e909ecddfc4ac89d6e2ccbafc83330cf1bc04e05a9072b5278a2065a77fe75ce0ca5d87e08b387ca6585a8e6afe349c7bcb2fecf59e9a9c9a33c642bd40e44284d978b817e3c0218303c0d4257a3dc491bb7758dbf648cdf05667b6a4cb8db09084d2b1a3f611bb1ede46dc31d032e7ba03c636ad83616de589663252ab60390b136d7506b5f460cb893e3c5cf2ab8629030523d13f38b06d2dc9b1a1007e45646493818081e526783fdcc373c37284bf494095a92fe5043829585e1326e69f9e766c29ac715bd172c4ff032889e80297440752b7cac6e7ed1108e6f8ee532981e94429a23150651d0431e40467f694e7351be7ab2981c6ea1493a594388949d192d70c5809564c1613178adce77a3507d782baad1571d982fc2453cf527aba68a0352c8bc99320899b6bcf5f58a47945557a2527f1c0228bfc7543f046fd0f534585d800edf760a35bdce3c395bfec544a57470a54691091531e7b29e5287e237088c1e112289b8c9ebf98008348d9213257c5f3cc3d82228fa5fd177e0e24eb7b9ddf42984e871c6970604dcd2c7a9f299c83c75ccf058205cb4163661acd7d6868683bda72ce325af0dc114dfde817afb1918ca479a8c3804e5fbfa3ca2d5c7ece93513f644ced1caf48b62ff2ce5144c19f73ebbe8d96742884f32d869127fbbbbefc056b8c269060c23fd1f2f69e400a43f1f381143c4df8210a55dfa21fbfbc4b4ca8fdedb70f7d5ea5ea7dedac5c6797cfb4a2474c54e66c2e72f206926b6a9c9c72874c1756b7b71e57ba1595e62c24ac966fbb1816d14c864ea0485db87a061866c8c67814c4ff2a60ea9550ea7aace5db48d559c235efb3b52c9b7f0e788d6885c2d415d29aa7be8dcfb9efec50ff59cf6715da0a41aba73f9eb914a0b11a93658fa4d8526b61f7522f98ec083991d2a649a2d6937d4c2d8343dcba247bc0f86a4e53dade8c920d17e5a69413d4024900b89b22a3a3aa54d8edef33e3bb01faa837deb74d034c84e404ac8d599547adea28bc7311faeaa80b242ce4b1d2e7d14d409cb830a255a416a1c8e005682af1e5af119e6b847c83da8c05b1c85c439a6fafc9b95094fae65f27e7ea50ac11a75fbe3206eeeeb9f5002a553163c2b15fed2b23f1e00c6f2fa6478e924bf723814517feca26b5be9a943ee1482b9644cc6165e5c8f0617cb7e13401774fd19f5bc5730bd53a0b82dcfaac1a4610cd1d514692e7eeb33934ab9d21d4f9e45be7b9df989f368616ad0c8c39a4d1f0ee9d7182fdf27d26b56762c7685622e31b10fa609f5e1cc3747c77aaf9ff941ee3938c3521eb099b603b074a68dc6b2e5a1cc01caef05c1d460f7ba78399563af4bf47bfb02d845caffd8ca4ee13a35552f4edff9699ca25d8a86a539a391f2692014ed0b6b73a424a52f97d489ebd1db2c348cd14d6838ff0ee0d7f42b0187fa115d241d09e85fb66c7f45e52c827d0d5fe43d430e38525e722ed847117b8efd5c10633ae0416a87ecd030bcc080e3bcc8e970ac89e73fe3282ef2c4facfddc63a16c83bb35dd3559435df01807cbe4159dccc0a112f02e346e3fb1e0b61f2a7f12e8bb1e9cf75c96344d97c4f56117db8bef149be962015a8ff0a3536251c64859c09354466c910b53f06314e4b5e1d385dd7a00131c0218135ce498652fa529a4d443138835c1680f3b74e84cc135ad3bbd89bd64c7af2a32c1903fea1baf4cab30fc5eab7bb1e124adbc5cb8e130147d63a48769a6335983330fa387cc9aef6c200bedecee82dee76a82de5d7f027f2279778b4cef5f4d513e576eb4a15b4e70c07d0e914df6b2fcab0eb07e12dd87ba0536229a2699b809555e7d79a1235b498e8b154b20bc7a5d20629589f096d4ed4ca35f148f10e06b9607bfad1fa3a4794336759526085d9e2f105099dcf604bd42e2b220e0a83d4d83334e36f255e7793c548a73e6c157c0773890cffba919ec9759cf881dd48331f9cc85be21f4929d0f4cf08c78793eb3a2dee05f47c141b6672c17fb849308273351cbb453d4eb5db4312808cf853bf303c3d5fa5aeca6afe618124c4755f23770d19ebb948a837b9ff278d7aff2628ad169a9e5d378e715183e92404aa27fe73f5e0a36280312cdf1d86cd321ab9a45dc0700e06044d899a62a98c32ae32dcf0c37a4ef5913c01ab3d731df282df1fa3e10fe445ba4e6b2785a3c02d470c812bc3856716554f20b928510dfbcd89c0fc5d1fec3f9b7da3de5d4717951cb430c1bfcb7b7c61521312353839c5deabfa85383c761dddd8dd873ec35eae054319fa5339f2a7d43509284a6cb942e4015d31d3aa95e2391b4fc85ed528ade253b84f7d677f35eb65c91464b0331692ff12c52a12416c2031d90233b101ac0fb4a69bfaa53d7d470757fa4f1348251cc47eb66554881bda97af646bae0c3beeec6cc3511066bffff5efcdd557d0369ac15863a931c8b0023613a9170388a9b9cff618ef045364624b2a91e17178d3228822bdde71891b08739803738527f8947cd0cfad2e63184479b4dba98d64cbd45cca43f81fbc807fb5ec3f1986007f40c8e47eacae6ecb33cc9e92507e2a30c56c97884a6b62790b0bde0ce3ff5f8a672cc03404f85494168e4d70e9288cd963d38c27173170e42c7af48b332b0e89e0caadb1c93a3f411b8f197b44fc32f41c78eb5fd8e38e9ce92d85443249e44a05a0201fc2b8fda287a77391045c1bc1b546c51d0277243188ce8b536157397e13e6054b078118046f8ebb3d62e49a382d68b2fabe91d6c390ca0dfe04a0bc832211cb7964868bb78aba4db4893ccc1c0fdedaff64bc1544cfefa86d406e34416d5512a14a7e6ecfb806f09055a2b3a9f9688d229504240dc70ebe9bf48ab18644ce8cded7329e5d83a70f9c90ab496e0a572a1d800b316ee111daae3ece7871fd2527f639900b1fe23e0143cb11e520eb1713c8af32ff681cd4ec85a1d3e3fdb3c09edb51edb3e1def281447253f9032d5fb15bb22a58a097d4513552371406a72c931bdc40cbe3c9ccd9b7b778fe8efe19327a8f39192d1ee74fc8af54ef1962ff074ba36cb6b9ec4abe1d3e26eae9eb3eed7b48d5dab42c759036e71b2a844fb65a6bb63b678f1c44688a3f7dc08d0c5751db6d35dd7c926d170ec9af6dccaa6c3eb3ef4e19142329e706645496b7b7f77fbb83c495aa95d5042795bbee8b25473e32ef4884909470adbbcbf437ff33b4050783c44db3e15622fa0bb49b2cf9f38c70eb4804f919a98714098412a991b2add32269bd112e5a43e698c6fc917babf280a00bf488a782adffded5ff80045ddb8823ad1ca7ac14bdcb5d77ef30373f6152610359bc415020bb1d9f4b2fb57697d87a425f925e3bd792a85600eddade5080e267613f529ea9e1852e8854f874e8fc6dbdc71998169dc73e82814cb4f2846d2ba1d5137cdfe5676df1e67e9f092a8ce5c8d22c1b898e24d99612c1de8ab6237054a87fd0f8032080e4236e35091cf12b802c53e850509d8d3f5ddb2e6f117add8b7c6f0fe3e798520ec127265f03fc9471c154d8112e343b93ac022d0c1abbe21c7c7e950654046182c7adb3fa4d2945521dbfc1bcaf4497c54e93193e90da3766e1afa11db2cbb53ff2ba96cf1d36bb2f28a6f55510d539b437deb837e8e57e2e4a9df8fa6cbcb68c3e8ae5b74f886d7672ee488bcbb652c4cf1eea3001a3dd723e331f06b9281254755a6538674fb5571ba69b8abb358ed0cb3b497f3a8eaa80e0ffa5fdf25b1d727bd120582bd79c0c498e47e1bd519b9581e5ca5e78cc2301d4cd55277388f36b0665bc23bea8237039fee1c0518eaa1a8bfdc01e92fecbf5e09d26fb798984eb468718254e8da0877c05c51cf97826f5fccc3d802b59f063d10710ce624e8d7e16abd78486ca1889a33df5ae7c9aaf5e34a574db1db12ce3812dd0b439486dc0b01cce88ecc0bbc59e38f252e1302a3a6fd6a78f7bb7384b36e0c8ff1172eaa9f4525f1b1912bcb65209f380a2a2f69800282fff623721e20bdb357f2d79bee1480ae619faedaa300dab984f1bf7a42aca067057259624032974bd419e09ad7a5f3b3abe88f43774d9bd6a6fcb374f29f570f1c8f8237cb85f404a3514adeb2283b5a4ee68cb6f0830ca432fad23d09f63471b49fa84a9195a856920787d559053b1a9047adef775ffa4d2f17fe90da0ec864042c20dfa2c27a9ed4ebaa960bf117e4cbc1ff541081547b1a84c54fc7354cd93017b5f4727b737cd5a4b44046c47a3de55ec94d31472e49face263bd2223751b21cd51844c172925f7cf36055f16fdb91179c74f58219e754efab75c074af59e1b4f392a07569ea264160afc1c91c0c07830a91a497f61f22b64f6892b3c30e293215da5873abddd2789de5652d5cfcadb8eb0a18670bf7a6bba66f096ccc5c8bba687df83b4eea0b3e8989cd5f927f3779e0b40abda14843aa450727d7a739babd4ff4a1541f09bce4aa2fac85f6f747fe5088756d90444b3c03bb6f8057ce7e47a44df998b7f8efffc3dd67f62e46e37b4d021886741d4764f1eb13284f8d34aa048171b1f3c058a2c18089d7cb6d1bb767e61175842ff03749271cadd5b1b4fe8b88426291bb6f1e42e24e4ae449eaf3c86bcf64596e0453a5a5887b4df4106c6f255a3d3806943ff741204afcb3bc7830fa437bcba37a150363bf578cf56fe7141f23db121e3e491c5a5663d93b1424c6ea314165072de12f0279a8e96ec7e691f41e453191418e5d138e4c2f67dda5bce7bae07cfb2b93bfab26d61d44a33ded0356a9fb59fd8d1da3ab863808f74757d1abdab44dc22c4c9d0085ee8c4c1c83942722c7f76984b55e342066d085fc877d77a9f011ab4ce870029e9c707c9d8a69543c7af829f6ceebbf5057d62080dfd3d9f061503e4572a51efd53e60e6f92c68549bd9d2a16e49d69970fdf8e812785f090d82fc35cb5f49829422bd0cab803a515f9ca69b79d491d3abc43010236ec61e018e8de909e39b5f700d67eaa22c85509fc2693433cee5f0860470487933da3e7a75d61d7727d7b858d28b045389193a62edecefe2c8402e3913b3dba961a0bdf2d22c55a25aca79e2c15f2899c4dbf0e9bc244c95cd963beafaf0eaeb5718f67236efe72e454e1101a9c83ee59ff04e73c4ec04ce8c7936d2e5d8c91ce8c8f645bba8d02012d801a96098746d4ad85cb46e0af85cbfbb0f20d29c28fa458cc8f8abe3d963fbfcaa551fdce9bba6a3fa06fd0051da775103302f6fdd53c818f268566781700a88d56258aa1de65b1705dd974f254d0fae6b9ea46f202b65f675b8e149073ba711c46e996d69a6ca3238431296e008d15beecc1c17e7cfaba8466f012fc8c62d775fbfd5f17380c741dc337e04793a00c2e2e05fd386dee3d36ccb363b057ba5b0ad3b56245a43c9635dd79e79e6fad888a5af72579539b756cfab2a10aae2d030c9b949284393499acd1c238476bdbac4222eb527f94acae965163099644ac9278f6e6e5755671c8290950e5c925dec9b5b7d1b03d1aeaf3b3632881fc224c27411a746f3c2cf28fe543ac499b79e9a0d21a1b314884b4f0b50782e44b6c6050f68c926ab76fdd447505ce24c9e248d7a37043bd2733454fde8b5e7c20d7cd70417a5fe9ad0edea3073adf92087d7ed903b9dc5a7cfe4bff77d03dd743ac8967e0bb0af8b97dfb82aba2f6eb559c02494c724e1b7e8c73a987c4c0c33e4bd8f6d53e864040ad5ebeab0c1041efcd8a136bb06eeb247f02751724d2514a947004f7dad14af72d7b4da0f30dab33832bac03ae0a458d79ee4c0a46c5048ad1e7dfba90515024be39f59c230da981f23ecef4fb404ab3467bffda521572b598404aea1a7042c6b99d64d25ba6c9e9125419b3e887b0967080c9a85aaa6ba8dba323f5b7ed3fe493c02c877188941aa74dea2d14e72de601d44716d156e11f44a742080309e1c0e22e856f42ee3a1da57feb7a826759fb785e6339973b114ba82f55587fbf6eb32231c950d4689173b37491c96f060e518bd11da89f89a79e899af18ff58d0c057293fcd8c4fcdc440ecfce03b5ebf82faa773d5bdbbf4a9d70838f28f66ec70311a53082f6905440126fb1d467624fe835e15549642ed45cdb1854a9a937c92dc0853d190a52c24d1c21869ece3d1c8cdd94604a1224ba7cbe0082acb09af17a4ef8b0dd34e9b8d145a889dbfc084e7644045c87a29fd8c86dbd8affe679302b03d29fcf32c50d232f81996babd0d299c360d63d70e3aa2c626c166cf7e216e0bc0b57091305bc4e5e4696c057ed3423720066c483d270b63c38b0afe78cf9674fa9bf35080ff96fb61858c90b4364537b338601d3dbe8eb6b965b832e94c95e448095c9ad857d608117d8c4f53d71fbfe407c05fbb57cfb52d8d6c3ff17cb163cf9399e4572ef77cb065d7623fd2d052b698cb18db74b31d8f98d301441f4c70d167569b6ed856eb813f969ba76e5822eebe020b92566e50db82614e4dbdb6afb000b3e6b952b66948f2c97ed2d2f7645e598670fe4d82dc1d061d07485387569f3cc7af7b8cffc3a2ce9e246ba91f5b1b391113ffa4ecfff5c3595907c0f23150e9fc7b389ec2b081d7897be4e3376065adc66d8997c1cbca6c0ba549576b629c17eb02e0437f745f4068567baf7ad4528dece9395107da88ac8bd1ebd209bdfcdf83f7fe454ca806a4b751f6b2f81d3b6e7cc2d13b76752cc3d5a34cf0304083a9e1abd02ea8ed6c8c30ab6e1b47e2f9c68f10e69c960a0e5fe9a806b773ca19f0f725fa43e42b24a18c4f04f77ea8d54899417940f6fd82204b55f8c39510e26fda379e5c106bade83446b9712d22d878f0ccf8a489f95163b208fcae2bc4cdda6a4dc4519e1f83a25f47f09959976eaa80fc68ef0d3bb2c6c157bfb5c74aa64c0cbf4465b46d2cc381e3eb1b8021abebef8ed7e79b97997d02da12a906eef7a25888e5c96cd3f085e91f937454efd45816b73db32b4cd0924d64bc76949cf1d1451a8be971ce6ace27d4b4cf40e2002dab40d04702b11ace80656477aa7079d5a5858952908855924ff068049f3f303aeb424df268aec30928bc0ac45d6e840e7442a921271137dc5332d6946d623a36d7360a8f84d30c877d8472e071ffeca3600d25793e2cd8eb4ce3b7d075fe72de06ef47fda42330080966cde659e7a0621ab767e03c79caa5247e17143893e5e2c3c4de652f26cde3ff3c68fd11168663b17aec71da652da5d1490f3c38d8f9177149566e9b4e479881ac6aee8167192811a53db5a57216afa35cdf692bb2cc0684b964f05b278119fa9635bb0a3d700030ccfe5fd1def5005d9b4d24492bba2cf46736094f6942dd2e373cde863aa8bb2b403b92cdfb2ca66fc15d6cfcae82d5d740de4a7fd897cf89a3e9dfc5ee8f7b2626229b3125f3eb0399fcab1d96ea4f3b4f226cd29289aa269195c54aa7dd50d5b476c8f312d84b010ef502f5c2fe844c7656028d66c3300c99b150120db0447b10821fa2d81847502429987e3680902c9420aadb6479e04c694f9106398e947d1f5f39a5d2d1a3ba629cb5ad1fe12dcdeadcffa50f2d06d46c84d3110628ae4e3f4f17fbab065fa4ce248a615005f8a1717a2fa1a58fe0ce4716bc7ae3fa02e5bb1544c3eb40d9df23d5923868a27e8945b22fe6d15c2b74c67f8f4d4b061aad33856361287a0b9b378aeaac8abf90cd26a15e97eaada850787d4ac639c3e340c83541965dd3122693f037a4db5122d0e9e97b3a4458202bf1ceda508dbb621a30e2ad86d45ccd2ebc26ef732e033d80f50ce2c1bbac524dde0ba9acec63c13c456226e625825d04a91ddf42e8f5857dea53736890739cba3dce20598407be09a3475d339e2a6de9dce86e4d5efd5c2b09dc31a97398483337943c198dfef024b7ac1dde67c470079c8bc4323ceb820ddefd45e969307337a23a96751ada3547c4abacc1e02b3623b1c5c84478350c68f1028c14b70ea85299440d4c8536c841b6c84d5627120299a6360c8b26a1b490e1efc548f14ca07852a7a7cb47494ff4fca9efc5e6d00adb39e5b1d4364883b9772d61f7e8d3337f22f1538db3afaa7ae39b9457d104d52b87fa45f475a510215fc069e8acd77840a5eab901153655cd702516384eb3eb5ac93b7a4ce66073b7c1bff11190643be47f96dce2eea1ba0d210fd46b0e87e97e573c15fa3d746afb4457ef6c013790087cbae165967b58154e825addf2b0b9144283eb79b5614ef8745b7bd8cb3045263efa53ab9de81cbed110a5af44fa789a3a88d1a230ae4a97d6507a3af55b6260e1454ffc2fb4b751bb50f8481d4dbe84a94268269df519094da0dd0606d7dcfe7cae1c44abdf39ce51016af6f7b550e55eb12e3f3e82c29586f65a645c9ca927518a571791fd0941aa759278adc303395c54b8ed19989eb6893e2b7a7b4fb4d5811a434edc86f4176dd23d9822c6c667ae3d46da2e5cfb53d18b0e5b781840d06b25f9e3849893c0d375b23f615aa11e0ecf803c460eb71eefbfc48f051e50a2c81e15a27d8afed2e9d578fd595f63a38eab5199f6ee8fd7b16ffa6629e9e199c1917a643f4673d4549c43f6d8c627ee54a43dbc204d760c6c18bd35f9fe9357a465dc955ba7664ee326b76d8261bbd2020ff3d625f2c288094819f2b05295846ce5415a1d7be30e66d5a9503a3f0e336f01958d69b6cf6bb4eb47f82b5ad034eaa33093ab195693511baa87f6c6cd598846b6a9173360c8a794788089a3473f28a09889f122130098fdd454a29c4158698bb7c4d664f916fd327db7ec779f160da14901c1adda50c32f36cccd8503f9b1f1a437cd43eb309c9f231b9d4f37f342ce393ebbd4cbafb40ef0fb211b51d87b5a8026a03daf7591a027d3bcd742da76a4a9c69028c7b8bcd63682096b2d97570812cead5ed0a22e8528020580fbe1bad4d045d7760a46bed05c07cdbbe2270db6f072ab4041a0daeaf145bcfc87a2b57e84ea5ea0aeacb6e03dc236e9d61ba8662b779e8760d2f02af4f90f6603aefcfd6e2ad726cfde692ce8edb01a59611e712e6afe6505cadc4211beb2f65e54a7be90f4e44c2be14c43f296ac64aae31bf20a535d6a4a144a70d73e8c6201efc8df9dd7c6ad7e1220a1fee2c83ec733b444f033b32443411880586166ebd0e912ab45df63ee3e0b6ef983dfe2310ea6854f369abe81abe46b0b7d68770e098a9d0969e8a7cf4fed18c3ea3eba5782bb95a38f66bd7796a5d193e9db8837ac1ec606047044b49e20fbbde5ef2c49787d47ef6b164b1b184f80344519f059dc1d9e8661ad30c4cc172ca3960dac0556e03b467ccf726ad028fdb6ab137db90e050c1704dc0475f807111d204ee77b1cd4255c22118eccf8cb583734a2465b36ee529106263c99789d817b3881bf73ee693f688bf46b41023029aa9d1213ca439478f76560e9e76878ca87167e5f84df6f0dfa0b209cea0ab3b82fd637aa5f1663d81db7a395be72d5431a6e109bc5907c025bed253a8fc2b2fec0d129830bc688993bfa010c42784d6ff28017aef4aaea88671cecd5bf54febc01154279a71dc3c925d74c96428806556395b0402c910bc2bd856c08000a8dd60783f8fa3e4f4e7bab27a3613e89f62af4e794eb8fb492d174a4ff044db3640cbd0cae5281fb32962757eb79ae509beae73336b11e363bc69a563e0f0856823676f02238120f0af6d0cc00047ae30bce7b746cf88af87e3ae52a81c10fbd2eac1fcb34876bafda0143a3b06b71b76e3ebdc6b140bce3ad3acd5b3fb439351ba66da40df252dd55d18dc8b07abfda7b4f4a994276bb442f10848bd4dfb06ee921c9e375904589451eb608affd038bf62fd44226649336520429c1c3d689551251d1400c26d02a97a3c99582b55d42157ebae603efbf237b9fac36fc72c59a9945d55219b15aec16e0386365e531298459bec7ad59172b55ad7a3c3a86654af789faf961542ce23f99f0da2b8ffeb19aeab6acb5df666a5553ab0fa12dbc9ad5a602fefc0c503508e1dfe56b89d29343314bbc464cc49e14e35408e907119743c25ba41fcd86cc470ab97a3f4c38f37a33c636ccba1ac0d1ccfaa6720c39c128ff0727a626c14a546efbe5322b7476d5df981f5e6a25be81b0c1d7b2dba461f58f6c8222d72bdf778c512baf55e06a485d38460ef432ad43b68c27e8c63dc25590140de62c10446c0780015cc652bcd8f8068e01db35732f934dc6a796e8a8c28ee2ec6b2edaceb14bf9edb45491fac365e66f42c723d90aa642d6ba4e24fdc94e951f11d394fb1f1247040e9687d7371b0b8f922ae05174b0aa93a6ec29eab10de19a5de69651d19d07c4918b87611d0d245435fdca68d096f67afb42eef02769493766249d0eac9678cc413aeb6818f5f6890fc5970ec5ca833f13eae929e048d2b694d0bef24de59b02d3006ee23b59f4981cf0741bdc0302eae9efcbcdc19fb7a3947ad237ec6a21394dd5a69069527ca2ff7716d6a941617d879be9ade366f0c6c6e2149dc91cdd3700405a3803eafb6677a5d7d26fa498833342cbc65cde8d9fd2676153c919cb30ee8e3515da4e973f028f89742d79cad7be10883d8116b7181d8e5b86af7499b08699e378c7161a15b383ff7bc64f6d9c911c01d272b1a3ce5b9f404f2442b6d7638564fb575f49f869cd8fd481f314208558b0ad102f702fb75c593d5de75774997528465243ecf8df6ce14b8a4528c7d1c3ea437517757981ad968c6ab64df4c0ecef5f6657fc14bf01154cab055e4a1b73e689438b3deffd2e86768c05f96a0f13448aeffdbe1214c73dd42ef5178162b9e2473f8175cfee5bc2b395bdf83c5cf71bb2cb60c35051ec39de6124af2eb02f7c98ae32c7840066c242ed3f200cfe7241fb10f65836f13f1d40607560a0f2368f0cd772b0e5ce3cf96716bf19a7a53a865369623a206484c831f268daf0e5c664ff996b693445c74f50a211401f65faabeedccb4a32cf3701025501b34292bd913d11244b94580c0fdf989a7e38a9aac4a49e3aec07c745a5c07e32e6258ead04e8aac7fdf2ec8b7e457036d78f79aff4dbd60286fa69a664fc004e1b3f64ab4feb8f96cecd0d2d8ccb6958edc73253b45cc6f0f36327f638db7f08bb6eb197f17bfc1be5c45916fdb79dfd9ed8dd7b372b6657c4e0635120cc9a6f4416cd7cb5e892f3b02b2574089c5fe0b6a60d7248cf45ec93196e23f37989800f924d4ca0c973574c262b4fd05fe9528566a88a4272df92739aaa3bdbe323ee48eb0809594312a16183eb8555dccd4ddc94d7e3f35f63d2adb76720c03aba1237fa33143a65d34e0d5ea74ca79e40495a029f73ae3f37b39b67b7873b66602bccd42a319117f0e58c6c8da2a13da8f8237958fa11f58f9e85153f27320ed8b4eeb17c3b03c215c56dd05220b8697dfbe6efb88980d29da2b45eed05b53ff9f25f99d0e3fa9f505605d70f98aed6b8ec233504cbff8557a3332a581e0eb7b28a5336eef6d192407d67d64dca6a800c4cb18f360948dd137886edb6ea32b80c09b83ef4358ba83a022bcad4ac26c783811ddc8db0bb3f198d7b298ba859a2f3cc4e08223073d0bf4c72517152c63fa6be505af3ee62228f44478838d243fc9d529a2c07d17543eaa3f615e3e66ae7024d14573f41d5e96bd8dbe6f7d2ffd1f87808064afeede8dc10f5e3d9d09ecb127d87531a920b9c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
