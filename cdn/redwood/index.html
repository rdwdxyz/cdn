<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17bbfb6beaa478609b20578788c42b1e947b96346ac3b57ac5eab93ec4c7c2db110bff95a908e484866e45d34eae15a51f2bb553ff4d8e0953113e11d3e645faee5fb798635d05085356028a8f6383d2cd1ef6dc8abfb3c7708f506999f2cfe22307cacac915bdb953a34ea418fceb406de236d9cf871ca120951e85f4b4dd734e74aa7ddfbe670fe80587fc1066968fe4ba3010a000051bbcadc3a575270a02b3e6bbd09fa25a8a15398692990928da565c92581d64fe4cbeefbea06e69230dde0ef009bd36c703706d44547f8e9c967b98066bf1cf3bc4d662f9ee45bef41af29272c89ef3468b099c38c555003a3bf423b3e0062e1c3daa11297f3e74cb5adab69a24e03248c6d20ee5924359c21e95b0f5f523673ad72fce3bcb6ee8180a873baa8a8f1ecc2ee09850e059a70f3d625b9a1260a6b159cc3c4890f2e005cd78979faaad8484ca885fcca051dfccd0c594eeb73d14b220f14855a36de0f5e4f34bd0797ecd82824f4d2b6591bf1bc4234fc68ad404422b75a6d8a35dd0a2f5e57bfa96cf84d6b0311705467892b18b96bd00930ca51be07019ddfad5fabcbffa6dc12bbdce236834f064c3c1fc64d2dfdea15b359f51bcf3bbc1b3565bf5f9b4dc0dd820a4b2738c4a0bd63360cf98876eb6e69cfe8550afba3cbcc5d6401703180f0ae0b0a634bedd412d46faf3078094983badba658bbf0e7d1fddc5176e344f21e5147e820be41312b6e670336967969852017e8926097f33b9bc254bb7d7050f2551d457d4d92630b21d2c1fcd3ea09276a8e20f0fc80713cfbfce77ad2c87cb5b504d3e0b79d9768f95cfb79bcaffee587b1da6e4209eddbe3799e70f654fa4ee0363728bb0c1e6afc19e6e1f40c958e63727e4391b2db18de98d2df8a46d814e96f9930a4a5a68e1f5a43d994a599cd7f01cbb56a6d1a688b9be40df29604a8ed7245d76faa3c7af955987627e08af9d525898781ee3259dd30a5032adff2b0a8d4d97b70f2f89fb3cff7f723a5cedbeba2e049c9262cc913dc1a1ce98e7248708858beea1aa021ec2f10911472ab7a66f78ac34699de319927948b80b7eb38e57162914103e5373b2c4415c455edaa5a89bb97a2ffaeaf2c99feb3933e8fe6de9f734857c78b46c27046b548a4cfecb9eeb88e8d8190cd3d802eebbd9e88d08f863a3bb78c9d8910ca7e0961fb161b8666053b4c0636950d5bea892cefa5c6c9249307ec731946fecbe3454cb29f0e27e2e923c37b27513c6f1957a7f19f40c1659dd5ad8e1ca28628f72690300563cbb10db8f6b9dcd7e6708c2f04a7ffd099a92f93893b4ebffdcd67cc69e6d69bfaa8fcf920561c8a7d4c52640a1498cc4365b846127f463db90e777bbd7f45f22973b3cd4cb293228c7868a5894f5b9b76ebc7b6cf4b14ca3c552e6d686cbc04c10626ed5c2c08a236400e1b065bf87cffb2f09fbed44d21a33ce8a307ad8e668f1e1893a2c4eaa77dc32b5c38bd2b559be42b73ff338f185b98087a3abfa0300de223609f13961218e0a3fb866d6f0cd99d3e0fe106c6c005d571a40592e6d86e90aaec0145889405a7d81892c94da0ec3e4244cbc9ed710bc92b284cdb273ddd7ed590f4f59a54cc239da2c18389c620e06047b92021354778700866f11b31803db7cdd5a947c2a3391fa482fd342a9fb1c5ac5d3520c1b57b06b1694fdfcdef4b4a487dc06582cea2233f007149cd13c15afad7a14ce2ec6cdfe257d4068bbdedc2d3e8f02d4abf5ba6b719c87318be6a37deb39b7619615e8be890d738e462491af1183e136edd628e2d3b9b18435d609fd5e00f1d02ac75ae7ed6b25beab9a1669bfdab132a5575798a3ab2e0d3773008f877ca79a26f6e5fdf2fa619d4e8d13986932f801a772fa7c935a5a4313a96332f84deba8d7d2667f59ec39205797a60dc81d4d88c3e03d4ddd861d71910b22d54af247b99ea447e03a22a3bac3623775abbed2b6e670bbffbf12a1de1280b905e57b6fab7001ce19eb5c442ea0091f1c669f760ba3eddc52680345257f28eb10c7bf4c0b6ac4e7e758c61017a99f2b3718580baef7b733ce1b0001a641c7db3a8691ac6aff6120fddb6591fbdb698ab818c8b5307f22cb1581df4d75e2b44cce5c5d9f85be44a5067bd933325efbfa7183aa6fda6fabab4e047ac6deb6a10f139783b7f3c2a2ed8dc35ca56ae62e7f3637ad74b66c0dc95237f187b023ae0bb1cef932644da39c091870e5e3e7af0a1e7b0270280a87143d9df142551bda81d0b296c6f3e08fd521542dde9ddfd2f510d81ca9a111bc6c9b295266bd80956d6aa1321775be7056897be944064fd1ee4f13de5049612091ae9d755e1636505c26287d428f706fac3dca1a4eef9424702f1fff05689a4d94708b8458c2f808eb627ceae0dea1fcd03054dd91b3549407df5da5c04fbba95e530f885154e5faf9f791a8a77b76e2e7002782c5e6f9f90e9b0c829efe88657debb81f136545b777d31dbaddf0d09d2d0d4869ebb807f7f16b35ba8d1bf07c3760e4712460f54266f599725f7838fda632ef41f3adedcba59ffb0aa4eba479cb6c594d1e460b92fbb841ae0ce2ae36ade0bb4639cd7c429034154aeeca731db999b6c13494dde36476c638af42d83160990ad3f9d6cc64a606e5f0c56c2626a9826a774ac1a4330388f03d5cdd3a8e719f26962a5717d0db7bc264ce508b5a3d62b99f3f0aac3688cf7b435a6e5d0d2c60ee850faed0bdc9053cfd0df8f6759db43151b6f2e0dbca8490e4d02b99cb420b2ccfe024feb91c1c952ae17c52fb8a57367d5298519cdbdaef51fe66b89b97040570c920f684c39e92b41ad21e7092e564a646ff2321de4b37011748ee5adced3c2c8a992c27f97d59d3677b74835408bbcc7c3fbf096fb1ea16c33acb1f7bc25528a1df8cc61a4124fc0a5bda9412a8ae401c9349e190aba14b5b496922e222b4285ac3a0439f5ac26a1a6340edc9b8b2d3ce152af9ed4b1bb632078f3cd5e8de18de5fb1bdf4332b953347d9ab8f262b786fd89ebbdd299a2d4c82a266c89f1a0d176b9f2ae28d46abe31d38b9affbf81377bcae005b19c40f3220e1756d02a416a62af0cd73cfacb4b122d20d2c3ba8488bf4f45fef3d77b587540e38b46beff7f01b77ab330cc979ec362ab14c4aa6df1208c385a0001f1e7d09a47e390ef4c4867319e1de549ce63322139b477cc3ed251194dbbbf102ffc064ab47bd7ca4d7c6f6ac85aaf15f2ddd0e7d8a7f6807e22c804eb77561ca5d6826e1b3991ac3e51019be1b351df06f1718a1fcf039b0af70c90a337d2e7d5d2309d29e0a648c5d3fc8460e5df137fc300a2391bfd328b7f3c123d0a862266f10b91c508ac692633f88b38883879d8563b77fbf521bd26142c29bffb457673e6f36fd41ff7db8fd5426b77e3204fba8282c829a2ea6041bb31a2922a2af2d6a4d1e4cca861a86367b4231120f3a96a464a1922dceb1f11cbdfed6923be51cc792c0b4395576c76596c0413bd9393f57e96ad62be904a523af20dbf638285588d1b2783ea197893f4a4f9e628fc52bebde0260151af14a5616692f000c7804305f5dd12a87773e07ad4f0ccd911e3daa431e607a4d60b45093e0d98c1ae238c1f3a8ab1142911964be9fcac30eb20954d9a27e7c3aa84cba7b43d924208a03fea9f6c9ffe2a792c6ba0b3c6a05d428eba7741936184766c3c173dd577a100b48ba4f489afba39fe6d7f61a940e3ce606fed9d3ffe08149a345969ed74814aceb95d6261b071a9232e8a6f2302f507d404f289231eff49f01321084532df33283c389e55b2f55d17eb6eeb9d50c293903e9acd06d0f8e39b9b6d69f0cdb6e46b16faafd27e2106a0bf2cf604883420bc612a8833c62d01e2f368e808ddc6fc4198b1cbe78a882b584ac92f95289456a32804cee58f07682264a9a58d71a0cf7a5fa0554719385092616b3bc702c88f6467efee05ab6a9b1bfdab1a5141d2448a8e77e32835eb45aeaa29805b4004448d824a668e868c4c157a28e4ce09b315b3c521d979d02c5fc8ce026f83c4f45abcc669b353f35cf18327fde88ac2806916059a538e78b00163f8504b3b29e8cc123db91da46ce36406994a6679a9855aa00a8f5e8dfddbd66e2be271242ae1b9c05cd8d2b00e9b1e4956c4ce3aa3402c9aa36c527efe73459f3d03e63bcab997a147c1b19eb506e649d4f1032609c86993b6778a103ab093f4aa754c8bdeb49d304e47d3eeb14a0ca72f9d7e22eb1cf6063efa16671d1c7428fcd3119b6fdbfc8cedbc6420d0eaaf2a088f94c716030a67355a9245df0b2f6f30f1423a99b54296e5a47a00bf02deeb1b916af13d51b31f83b8c7bbba3fa6a38efde39fd45374680dde629d936e912a0c574a21f9b3a1cfeab667a349b0d784a8b40d075f11a0e173a78f801625509c13778706b9fcd78933901b6c1646c58f723ffc1282aa5ce10b2fb899d54c74e24f4b873b5255b0edf1d41f2317ed36007d4b643cea63552dca96cea9ad6b0840e78ffbf2fd2ca1593db4e7f788292f388120e9adebbc9766514a1d828e2f49b50e3b72a093ac888053b95e765f4833becf6590ef012c8d6fb90eb695c2f205339c582f591995de2840dd45d4ee8974b8ac7a135ca145c2cab29bee2b2e05da5943aec97132cef352c3949a5e15cf189dfecde5fca2d4af2c669adf16a361c8a517392c529a07ae898a067101bc2399e977ee9a1dccb2f16437127956ced7c576fa391af9f8815a5942680177dc127c5dfac1d112c32815fe550880b9a0927ba2bdd44b6606736b610f1024e5db6fd025a2704cc1bf463cb64a08ee5bebe678b9da09f79932d301e8e94559a5f50f86a645cf5dd45aad50b9c85e77140cee88f8d4c4965aeef868d6803a1d05f96fe3049532b18eac61f5d2a5649ecf7320f8c6a1b4c302edbc7f0c5dcd140560df195fbae2ec21674b346a073fdd9a154bbba75034d57557b8d4896def20de97195ef861a3cedb3b84c96614b45708c80e9ec2f96434821fbe599772415936c861600e739f9d3286c82a5463e2a7ad0818b2d203e6658327352df80a32c48cf522d1efd0c6e5dcf85a7a94a406d3f03a537c0f08571416f6e09fc5bf9234cbed2490d9418f3166e89b5bfe868db91aac52174cbf9cc5d0856ba46e1551af937a15e9b934e9b16eed1178e023ff25c4f889dd597de56f709fa6d252f81ceaaae5b0ac250adccc8309f95b3c7b565169bdcf91182267c5788e081724f41d539eb6831c22451c7fb71b37084fc68e820ecf8a9d438d2ddf1b4ee305d88f3e5393c446d7157f7035528211340f039d1e723e5bb29f3a3a7c13c5a96428d13044df4bb10cbe16175921cff98430213d6b133653f7ebf4a87c38ded2e33389f6766d1d6c9c09ce6e219e85bdcca39bad456e5e655ac56fcc793a186fff501548cb40b6a69b82ac773ab94d6e9831f8c9f9cbf37db90f8b64b992a945de31442e3174035c11a8779938965a107c63379bbefd59c4268ef21d0b0d00ddbee09a0b4511d53b703076caecec46f946f3d7c9de83d65e370984d80b4e75664de48a3ad788531c42ab7cac7bd198bee691c23e2a9433f06eb1c57d779e65f9e6f650c4e25d6eb9dc38c54dc9e4e2c1b0dd5182617a06a93d75910430801fd786326101db55d034911a45cd6955eaa9172e23705ffba159ebd7a49f604d06eb7d44dafde1fafc789cf31e9c0007614b1a5017065efcff007fb89ac55a3c2b7cbe4c9d984806e85ba72585be972cb9ef82c0fb17a514ff762079a3c15de8d00fbec5176c7273bb4d4cbaaefc708c28648d20fde307537b6cac7159a54225a915769d71da8bdffa5b841bc9099398efa78ef17420a2f5d8359e80f9b5f595f3141d2505294895ec0d52c09b2f0ef9825ad1681ff458cc617f4710dda98be71ef4f7743aa93df70ea4dec546e6d58f26c75eb93a731227228e44624c7681bb498798cffc3d73db08b81692ebd890ddf79d5fc94ec086c1033d4aa1e61560669d454ea506c8ae21d8e9309c90156aaabe3445fa38366adf3be469abe8fd158ce0ad5da6cdc20a5e9508d31bbc86e2bf2597b8b7125cddf85baf318e0804c1434c5be97351fe7e2ebedc60bc83965c4dee24aac00c842dbcf157596b40aecf9de5ed1916314dfc610e94573d2fc0d5a8ea3da64b1b08dae597260bc963273498b98ae4fd10c1ccd19135c4ff0b273d35beb8deb86905816b82a0476e2fbf220abf500bbb7b55ada7f410e8740caf4eec595ddf3952a33df2fd19631998594cffa3860db83294a2900ea43fa4081b395a98a0b88b19c065b770f0e634930365586b31b95e5c6fc26183d265c7c445b47697c38c80bea8fc8fb9f4114a5159ea758ea75827cc60379863e71273678269a97853aec2c68dcb89adc114197885e0a92a2b4ad1b598bf00847c1fc79747ee5f2aec43d70083e583192abb036c8bcb51669ba70d5f30c83c47ceaabf4abed582d9e1c871028a7fe24319b8ae3ea0d994ac6200056af8098449b95d8b0b4d8cf752a802096a0efd2f9750ef0844ca81c9c6aee3863cfc6a4be9f5cf4ea0ddc1f83272d933639322084531acd8327594e956b5e3a945200c1756c64d667b6267b1b1330eb967e98a41c93673ceb27166c70f731740506d9c78b6931952ffcdf98cc1d27e4e26bdfb1a8d45bca45ed2fb2b2da8067c7b9a40a997c0c54a10e7712b6ba206359b4d1c0027cd7a78c1d79af3a09992688d4e13c1d76d0d0b58b45bebc8b41aedf7734e52a04e89fcb572fbdc527244103b371d22562c7c4e5fa6f76b6ae1c61a8713d859462b0f5171bc9840ccc342b8463cc0691324f00f05af9fec603119c467bc87c4d4b80758649cc308d9d6424b77c3383fb8c9c429d8d01a9b150d600e0f70cabd58ac707aadbacc473c12fa5ac6bbd69135d803318e5934e13f2437bf2cd8ef1f6da28eac8bb11d90ff3d04891aa32e2f3a5d8d5de26fd6988ef0984ecda8be15a2687c243d9ef257bb7a172616087af66bdb7b84993f71b939b99970b29cb91666f2e6fec36a6225a7ad468d41826c2c36f828c837afe6fcefa6413aa02cd8f7765a4ab943f8bfec6e6d50f07d2492b22ec08eaa18605815710a515da7ea73ab6e155560d375732a0250c3543179b6b3acb5fdaf203b68f6279d7a18a02b7a84c63fa3918d438a2e31fd702555f0d6a28b0ed85daba4db7ff5861a00d0b5f1e353799959d036f61332796890a957114e49feebd964c209f964103a2a5447a7ab10eb34bed787b5d9e4958c7a1c0df7befa0aa53467f5e3dccd7e963b98feac87f5021bdce562fc753d3e1c000604fe497bd08d748232d6a31ce5025588e8b79ed15c10b94c5911070d2b0784244c50710dfd2bc4b07607186cd3cc7e4ad1dbc10d0fe3aec59e61b4873843811a54c132cd2fc0600f8d2767dfd194a75995e6c237809ff525ff1fa38ca7ed360bf4e633d06a101028cc18fdac64038277aadb15f513bd277724997b9444c489eec7b2ed522e508a7c81bb02df65730ffbc650f62970d9048af769bbcd2a6da84deeb06b5ba60b066fb05d91b5f16ba061d601c27b484af3608daf18fef304895c7c19bdeee992633f488568b684b6248e406acfe4314ca1d70d4d2ec81d42b148f4543a76a696d5861d4a02dbdef69004ccd35ebdc75254681bc6506143c0c59d8771ee9c6fa4a1d1dbf29a1350d68d6b0f8e5ae671974ddd41800f36cf3f0c0014da24e3d86bd8612b6adab147aa71021bec8049fa12a55ab88a91a4672873854aeebfe807ab437fa801115b40336c77ce0364dbdf1c1096bc80f84d0569623400de04afe948feb179778505fe0177bbbb8f0ed5420989d128183df055d00806b63825766a8ecd93fbe296c2c5395ec8afb8de9cf7c5d55a7d65bbec7288dcfd58744e7256088ec1e325b8e7842d4176a169e0652aa79d36d6b33d157faaf535b215ee53efbb6948fcb61729addc06f57454d2ff8e8015d2c027c024bb847b109696327206a32f8e1e60a24247492b6d961498d48e9dde9e4a77023135c1e60534b40ef025547bb747d37a09abd80ec6cfaeb8ae5af1313bf018445def83ff783aa087b877369d69a459e9715038ef37562ec2a9134f307fb127e58852ad4128dacb8a98fc1aefc4cdc46deeb181cc1dbf519f66b46374425f974fd7ebb3535159c639d2e63b57ff9971a031f443b2d58a30d0d0b88f151479b3b2b5b191f694e6953dad7704970449c307189ae40a01be02cdeee11b72c77dfde8e75c0ce17be85be2dab01306657a9a7f6a21e57a8fa3f9b6cf45b67aaeb8a5100ac38a5e369a9e039a4fe2658caab9d2cb4359cd2e59e392aa78eaa37ee9602501f5e7af2f9cc7d3578187a3334a4e04788cb84229885f1abe49202adaf8ff3421f260314b1498276312542b8a21a14480e39eae26317a18dc1714d2b01f58500d937472dc2d5d339844c0405ee531aaf873659b164bdb22eb6df8c02fd26f22b59fd048618e0211d77b95cc4725ec1eef1c056cc6fd3b199754fbcaf799b40ece2ff528b3df6c76e3e007561af9deff104556a2ae70c07756a13a4cd28722646fd1e698154ca8e52bc3f1dfeee5c9c6f72ecf7e54937f60a61560b3a79126bb835ca2fe8be465e8c707fa6a550642ec3499c9c2ed81fc051def86af22957e90da24921bb24a0720f5eb0af89ba3b0d51acb4d9c4f1324860b580f590c65637cacc8da2ea8cb69a24a9122b71d8731e87f3d089240b2bf8d8015645d02484f267cfca7bc03b32cfbf93376a3d38ade4be23e0de5f176f97b518fa0252e64ae5039d68fc1a53f86158426e3a4e51ec088437bbc1ed3ec72a1d120ab1ae3c2940bc7ab5db9d891885126452a18c1af3ebb8d1b6d61425c31a7f57e95df13c24d9d3158d16ea9a0e2a7d69e3efdad41c6a829a5ba724b4ebd6d0f023c9823019210305b7fef7c663a0ebda28ab40e81dedbb8fec10a1e215909b1b8e76422d62431cf572d7a2862432b0eb1f34cea685d543a1cb64914086038da24f41e65c6099652d0d3973a222a34b0ec92ebe679b144f5a890bb06852821083e50bd98943b9fa0b6c3b65886987e6638ae4fd4693d655fd48489a6cb91728c70dd102ca6b2524ee64cd98e2e5b57c063c1c6a54583db3d1bdcd664e7bb402b277425ee725b342941c060a8b944d28fd622fd18629914ca40a1f0388f485480b7f650fc294a996f379556cbd471fb12556f802c55420568f4dc8233e6037b12655fe50ab7e8263a9ba81a0ce87795db00453549a5f494a5ccbddd3fa6dc38049be18cfc9c4507d30574cdf298e004b952366df795a3f53dd35223ae904ebc1ad54ff42a0c2aab8cac659ecf0f92ac6ac80331366a6f249d828798354fa1ac8426cb206362cca4aa05b4987e1150e5f3e2046230a5432e58eb92c6becff057e78e7041d23571761961496d86e4ab1ae83b604d9949a38ac574c8be0bdde605b741907204c967e8146edf9e94af9d6d62c2837f93a5e45ea2df431c7c5a9329eeb1b747fb12ecde34877bf960a9428afb0249469fd565b184319cafaf2bf080cbad7a602625fad060c733f3f8e032c38aff274e398cd35710a231e6040ebda1c5e59371e028f2e67bb3c2f3c8ec3925c1d5d7552f6570f2086fc484b3d7103206523369c68ffc216648bbcee76e925f6681ad52c36df10d858e331fd931af53a66a2cb1c7a9636def1294a45801549a8633ebc9aa8bbce205eb779990c9b85d4a1aabde9269e74d64bd54b3dfdcef3d422713de3cb1017cb3c9bcb4a8a66b3383b2c678e73cd6ac549749af9a2b73002e30fea0cf19fbcabd9e830cb62f7e07c468984d1f14cc826b11614c5f23be09a13e70cef1ed940a3dc547f7cbef2e6397b87b72163e65f18a8b36f7a46a59824aa7fe66acc69b681e0d3b700207ca05664d65cf804acd0a99378fe2110f1d216c06cfe7e0fa7b2ea84e152800956a10eec82654bef6a73574fbd79843616e4ee34857812558ab25e25e4791e08b336bc288469f35be84c03011a58cfe364957afc80311f4c899648bfb9135e6a1e0e8315c1d87b4716f068ff32fcb738d9854fc78bf03f579000b1b625090ea76b1d824326cf1c14684061ce40eedbace237c088e8742a7ed8b9cb1514e76e10451ee472b26b7f2798d1d2597a3b5ac0fe0f595d93d28c1c82c2a2cbbbe416eef4b91300f82d1a5ed2a9cee1a5dff10aad92ba14569a8505831dfbd56aad23c34f7e605dc0c8ee3a0bcab0e37de80170729ad2f92c899a6528fb6d0ea6386fbf348a6b88f797bedbd6e9ffb51028ed30e84790341eeb17cfec2d5674baea206b46d75654639a3253e795847b4e9a28e7dfb98795558f62b57c62b5efe217a6ca6658339446a00383c47383da99071d0e80f8f1a8db1ef5b6b9c8a1c592a5b26bc06d76296d351fb2bf3baa0163eb0e4d9aec3d959b6db4e44185defd6e378c8a6619da6ff17f383e92ce314d315d84d8a483084a328742cee080d6c0d9d7989d58afa62890e3a1756deebf89ca92f5a1cc21abb5d5ccc2d6622ddbe8ba8a21bc1a24ad6cc4ea7186c5fee492b6205c8f656f7c5a70f84629f8eadd60c03f22bd5ed66a238631747e0c5808dfb315b0396a669f83517370089b048d957f86e76e396a45203fd8db07553c5ed407b73b1352b629bc197408a21da449c3c9b4703df161b7bf9609df0f83e8ba0c9404db11e37783cc48e066333a4096abc8f4375b5a5efe293b893691feefdec348358e6e4741871d9b9adefb3989f8eb0fcdff056ba06ebb15b23b0cdfc69317df8a5158229b5bc64ea2a71fcc01c38f80f2f18451f4d604cfe03a5b4e25af40ccc17affcb5de66303ed587fd29212da5871910679d0d7024456d30116947e3262040251382cc15827358cbb5cb64084c67e8df93b153abc2d1cbc32701c704b3022865ffaceb5f954ba26d58de45d824b3d7d7fd4e0b434457dacfb68653a797385dc665e672b771170c4819a0ff9ae21b408062132456cda3350bcb201970bca8cf85ec56d81c7e46a8c70bee3e35faa949d697dce9b56816619cf877256272d3c19807f33b053760bd5a519997ca9efd80e659196f46e35eb608d7337d9931a95028dab80ff111645c7ee53f84cae0278c9b4a1644c2299062c5c42e5d1504d4d14f72f3baf722c92dd8022c251cfef8ac5f821d7ac5f3e7697de133d7c18a401c6a696de1402fd45b5c86099f407e9b477a7d3fe4659dca533398314afdd334814dee795ae0fbbacab810f4d5326c712a3b08a13b89dab1a1e52173c2496604f4789599b6a19ebb0dbdef0b40a64d54d3b0a2f6f42ac8ecdbc316d17e11900db09b863681158f57c41b659dc635f0ebe34beef2e3963b00c2d10fbc75ccc757b2d12ff2ce8e8cfaeb25c84e5459a0793d349b61b9412d9bbd51f4a48378e09d3f721b63a595446fef229af1db5af35c92f1cf841d5175e214be0accb37917929f00b2c9c4fe39e37fc886069b0f70894e3af1a1f3ba048ba0685ab89e229cfe1f19dd360d5fed51cebe0dca7655de7d308f35d264266ae3ce006be1d26d736f67421fb835aad25131d4c34fa2013ec079cff154511e953bef9d3a9037e7a46c9b1dd3068bda9cc6dbf678da2fe6199641c918edc98e738b4ba58958c7f325791341ec1a21bcd43f4aaab92b349ed2f8c73853329fec247d7d6d7d54782d2d57fed9775d3f609252c5e686e618d141e1852d41777de5915d8f3983e717cc17f9acda42e0339622c5f251c72f5662a94aade27ecb38f511f1db5592467d275aa6942e5c2645f5aa17eba93f8a29d29c151fe2c54542cc1e1b40e48f0220d241f9f775752a0560e559308713cd3aefc6a7f1e199b99ce09b4520be6977b4de1de6cf54679e520a2d75308d196a081c64537606bae61433b31d313cb318a6774f7780d5d02156650d09d0fa1da5c32819d4f55abbc9c0a52e86b1c0196321ea35b347cf7919d3744a3a60f49d389e031a0862a619efcddf90bb13d7cd4ab50f0d9fa6e975b014f8afe1492be451910ea6a18357ba4676a96dbe58f70a495a86afb36a398d68b4934b977b316e997cf841d1f8dc656c32aefb5dc0bfce7ee1ab2a55b3ef8655af00572283872c1b1679eec7bdafebba94abf919fb66a8fbc03cebeffa70ca736ad727d7cb785bb6e4e8d409b16bbcbd25c24a05cc7018b04e2c18109538a87cbb3be5c60c62aac06176bd6c99d6973f401334d3e7d0f8ef27137b13fa6559535069ec38d99741b2611d696b2baedc50a2523adb95c23a8658a54301e13e653a68bb913a0252279d000e13b6715216a7b2b33c2e716315e01d45d67f07929242ff6b8b8046cfb3534a0ff20140e8d3ac66c2250ea6676888a02d7e5ce0528f26291b8ed39ba35d8a5a39558c0842ea82a883d12a27a9393ccf2425bc095ad8fa9e8780dcde46dbbd1145da197542ece069f0b997aeab9e54cbde951a81d175587f6f879f1f55514add74fbfc5f6c2615654dd84dd964ea34b314c32109ef3d3e00f891c732b19edb2fbcb875ecf91003bd5f27995e9c0e04555625425188a52a2bda1aea855e9cc7254eedca9624c2410bf70714d27e1c3adbe640ee4e46f5a7b4528cdf78db08783bb5e7b297eb1411a3a4f40bee2f63effa9b6c6f588e388ad6b996a60c5295073aff2d07adce58f292e66ca4531d36a3f97709b27a43801a5ad4941ab9e7698434b930ab9fb40037de947eb72f7798be8f6837691656db8c28ac7f224551b55d3c66aaa06874d98d6207efa5179935343af9ebdfdb77fb71b1ecbf7d50f6cf85901ec13e2b1baba2e788a18fc741cbb6ec2759752f37ebee0b60fc0cf7a2d1ebcb75fcad9bc81b0e72dd1aad90456d9ac6145a0680a6ba8fa5e5f6b7927708297cd8b9aeec6f07a563bd96ff5e4317a95207dfd0c3b010a1db16bdf3e572e9cb2d062369fa172009995cdeef48a569a86d0c59396c57bd2d1cb2192b34f993cf237064aa4363bc052e073e8f4abfc80543f5ecbb31844b76efe6f0f789cbda86523d85ab9c807e48c9c70586b133a1e9c686bd82f3d6e0cb9ef70dd701c7b4e9b6c9e5815abcc0869ee72e02231f1f98d98b2bfe8a603a8e5a2973d9bb01e69c9318b768176af7230f616fa23289332e3e9cd5170003b59acc5d5dbaa48f24f36be957ccea7cc830a32aef7bc767a92eff2fe03280b25341647124fd77698380195fef60c79cd9fcfc0d848f99786e33f9dfdd8d3e1bfb46679af9eaeae1153167e30c2f9808ad91243e8ce542468b6a995594881e5111cd53de5a3a3951ef97a7fc803b068c085101732c930eedb99d2472a66c4e9b862a4fc07e8791b9b774763c6c230e8cd2c446572d0958cd21e0c3302ab3f8a30f1053bf07b9b3a5ee20f63bbd0f5a7708d1dc90176924f0d44e73df7be47d71aa52820c105bbafb9665cef16351c97048d95c7fe37640978e26f58f964b71396e7128bba8f7a17baf6c62398412f0bf9acfd34526db45cb30f77e29092d18034d7e0a69c0855b489a6831bc2baaf7ff377c4a3dd3f8f6619715e36f294cb71df2f2dd4c3dfc55d59d099a4d6b235e34b13d0baece864a9c19789291ea320038bf9f2a0389ae6fc13a76642aa244c65e1707762c6176f34de6617e91c1253a13332663b90b354535621e80a74901cb22264cf209262b90234641df2163dd388c8089d20f33242a60306f02005d4e242f42eb13ca44f97cf34981b029017c53f434a2ed4b64cf80ac19fed1922973490270f33b6e17b240190b8cda0ad6c245d8164a7f029736741acf089ce59fa04be9e775e237160407faf5b84357f915b4f6310077a08d7c72b1d8c626d0c91ca4e38d951f28059162e5b8c2afc28bd7dd97734faf628b4e431792cc6bd9b74504c000c7c3bb3a2acab628736ae667a38a6ff065f6bc3882f6d4089f7790c9e5afebea35869642b72b59dde570e17be3b464963621fa77500a35da136c0203aa5f15b002515fc472d6a4048a369b9c4bb180b0fae5f9532266c1e829948bc72617e7b09047b18b48396e47e8b968e128a3e38831cf0f6d8ac52755f3ae5de052289c8317f0b3cf63a5b989bba4c556f3efe42463274098b6e396a721264f5f73bed4f54de0bbae311dff0b1f9de4b106ea6191439814543d894eafc798ac7668a216fdd2041360adb36bcd33d81aec1e93851212d64bdd9f2a5b12d15d221c92155f2a7b800cab3c00b5cb7ca66ba1aede1087336d918a400ec03d7e6e9df225fc6d72b9bf40aa2c4bc9b3d7fe07e64f5b0cd6e5194bf5eb448b60edd5988cea1950621d5dc12bd09219dbb72d8631f2be6d2e12bd086527f8daa206b43b5fb628d82754a910d32c784a06b3dfcc746ff5415eb2fd26cfbef141f2a275038124cb9052406af5fad01cd1b43a806166dbfa3a4132051cdadb3d1f85420d8941ee7016ceba97e24d9a006026c466b4dd87aaa438f0e8a5879491b7a13fdbc92e0734fb832da2ebc1ae7369c4cf178707a604e1f772697b4ce97b959529d5b368038efa8eb1dc3d67bfa68fc0cf564788f4727760f47151eb64af5be139d3afb9e31a1cc32c958d5340042d6e76242bec7f4aed82ff371aeb33f7fcdaf2f233c6f770fba162d0b5b02cb1b2f2ca4da0f29531c66e8c2a7c49649f7e25e68128b6ae60d6442037efa4fef85c2a7723de0bf258b051330cce36da29245a9f72858971d970ec3912542bbfed50e2cd5c0aba3d438dab31f4a9e6f8bbade75d5a85408c1bb8fc4eb13f43a5a841516c1b1687b2b64a65d3f17525a684df1671305b1263e6582ce3b4cd6935857bc53e7851a58b73e88bd10b02b06d81ef7f74a6474ba88716970c62395c6a2feea4c6fc4d1dbbd3cd195efa0842572b024fb69eb0bd8dfc9ccabc6386049c2b837240a607704d825b09e5daf87744c55eaeed52fc2c001d2da01297cf0a46fad61d2d29b01fcf2d1868d0a3a96527f05a8534edcfb9cf367c956b38da747d5584829d2309012c76315f23a3d7ba97615850c46905d9b1a9d0998a44cd3d123e99f7947dada3f24c419aaefe4423673","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
