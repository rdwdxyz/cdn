<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18fd252262e5ba6517c55edf6a072741c8a77d067dcc39094152102508b416e860316e88e02e7d5d64a65274cecbb7740065d4e19ed3d225338824b476679d5c2728bf96d857f32d43170fa6b4d708348c8358dbf076696ad46e37554d67e60ab47dccf5b765655801e9ba9425d8afdaf90486a5d04fd64e26441e699d615af4fc8dbb48c6d189ca7733d315f55a9acb9d589f34c035051390b1cea259e3a693259ed5345bfae325e9ff25d4fa3036441ab8f7c5c61108d5c5330f39567a41c67c0117dd796d6e1ceeb0db1a4a4e25e3d26e20d4051f83a12bd8ae21ca3003761ee170ba110451f96773e45884e238557899af2c1969feb5baa8652f97724925dbfcc0e98d9d5c926cab5e917150ed12964c66c59d8e3b226caf9ede772918ad258a8b2ad184c07e26650c27138643eb390eb608e9d66c3ab5224a9fc55529a2c70c1d239d75158330b745068d3d6b1323813a3f5a6f5d8c13bfe1b131ff1cb39175cae37d8d28b857b42e7f7d5548688c7e74c4339fd036d0003c1827c0c1df0cc0ea12d983073e9d0a059f72c75246986df3ba8d4f33b4373dd96f886f75b9cf079353e2ce544c205ff7cdb2e8229e930a1ad0d0969ddb09f475bab94f47c6f0934aca3d7e4931f4f78031e7c987a25719ea6cc3f6e8096a2bfef305c3ee7231fa0d25f6772e6b61d70b8f19d3cce64a586c4633cac1591c3c4ef248d0a29e947445c0f0479cb29be740551e2f7335145ba27c02464971592957aff9d2bd9c9edddf2ba3cc6a552d9fc36ed538492cdc682e0a583ca88780196708689874e1b4296adbfa442feb2b6ae79ac75618722dc2d558457a5efe5b60b01ff956065f3ca99078b4f614870810d5bb1b9a67848c7fa154089438025b182c0f8bb1c76db15b015a948a343e3cd9aaf0c0038188fbfca152ac1c26009630cc536238369bf011326f3b84f9b54767ab0537a4978a49653bb4d2c61e635e255ce07813d9c79b7fb284dd9346c528c6adc211cb746c4d8b07975e5586c9daa8c5f7cbbc339503fbb1ed9ba890db32413777c6bcd32051e44d5241fab4aad8fab9b4b81a4b53e195b7b06f4a2394fa94263f3551da5792657b18c593dcb0b12496afba6eb09028a54cc5d3d655a99e859271ba9ff148ff42e146145a66e94d8a0050d9e1c2d0dca15d69b83c333a3bf731169f58695c00fc6bfa44e2827e8946134f2074f0d01e873d0e49cda55b71a36a2fdd757cdd7204f4166430a387b44b4231f81ce4b294c1777a16aade1211fbfb26526d52e0808621a7d2de0020f675143e440ae21e0da3a491877f48831edaa6f0a6ef1f55b4dc6c9fa49f43459f5117e84ca9ee72d8b305d9e1876b34fc23bb0c2b3b36321c0cbdb06dc4a45ebd5d8433d5cc57cf46d87c5e24032527c0bf5e99ed03cc7a48a779503d2ecf7d620419113ac3473a11be4b251ce64db9d30d644e2c16585aa2bd95bfba780bd62fd3da0a1fd33c0e484580e6893307449dc84714cce6a8953cbc97ab034477ae3fa87eb1e9156e8acc59498d20ecb57397566666a80054f7b8850e3137f87d680770bbe5547aee6cc5c758b6dbcfdce3f7d5c3c64a5f1989858b3ca3ef53234a025a2662c672f57c81935835b7c194e3ac2ec7c27626cc07e91d29f05677fb7f41a113050f9dca6e798a77e82f0bb46c052ca96a715fde73d45ef427d2bdf4def825c884a502eebe96032c65e41dfbef79c167ea15de47e86beaa330205450fde62f61b75e404f5992e8b965a80eeea5667c0648e79a68321070054e3bee29947de66c3758d154a1a4583e67489f63342c73dec2fcb8c4c6e7a3d981aa14357adb9dcd21fcd04f53d185afcab5d31fe446f12d91760ae9e771a10a7ebefb2ecb7d004cffb95478fe440a1e45371296b797d10c68eb4b858de645ce9ef46f6cf547cdcea2efbc5c0ebf18e0931b910ae5f17edad1959abcc4b365192015e3d2962fe12b1b086b09ac836673ce27c72e3f9afb8d119bdff299a7bb912c014431d9aeaa7dcdfa42692cae936a70071d6a14f5dcc14205439fffc8734e84f14815ed013bbb571b2d5905e78808e20c93a8c1269c7ccba9fcac3fef9d9ad5f1c13d8e046cc4b49d743ed8aab1bff050e6feaea125b6dba55e7aaf259397126f06011639008ff31187018de2aa84a5d7b8fab58eab11c8d30ca3c6d8b794e79e35b7a937a86e1c472f6566bd491d32742c723ffa4992f1985f33f5690ed7d1892446e3ad3929c14fbdda75b143a488104a136805e810767d18fa28758aaff15afab6b271fbc71b5bfed0714d7356741c397f7131bc230f1cdcf1464d6e22bb0cc284cddaebfe41c5650dd07b5ca4573b9518f7805aa3bf4786903bf0d5387072bef4a58a2b75e9836e60c118f988843d05f4e777c54114199dcb2417604da84cfb5743ff3a7c215147facb9742535b802300ba33980e06f5cc20e94e91ae77532383b9cc56d8e75c6b768e8ba14916f325bfa9c08b4ee9f7bdf0b8918c337d8bb1fbc3cf8000e4ea1f640a943000c6636d453cd96efca7ba2e315d303c80720d11122a3ce8f52c6510c50edf0e6ed2ff36a97254fce092ddf69c703b1037aaaeb81592634d75a798615307bfbfbe9e1183d7718f2132da3a6166b4c809c764fa5c657a5870f9d5da4b9d122a30a92bb7b65e731f09f6cb09c6a80f8369083451affbc036331233d15bbf4762b67b61daf7f2e7a08ddbad82e56321ca170775754054f388b457488573a293c3842fc1e796f82976693e4135282280503651c716c169931947680de3eec00473b7bb585aab0b43c9054cf62e509bf696ee082407422431614703ac9eef4d11321d4f893197b20664fcd4baa6f806c3584595209fd680d3b21e3391060370e306e8af4981d90e1dc9d3bad3eeb9dc0525a8e7cf9c8a61a33b5308a6b5b5c8a6062391e4982f41e883bea925e084ba21cf1232fab5d20a36d86872813cccd015f83c4a16dd82a4ff76ba5c33406cfa099a089edc1d99733402392a3c71ac81dd48ac77b483e4c2c5feddafdd43352d5c44dad23c90cee62595eb14a0771ffd0a78f258fd9c929e31656efe5e71554f9482241b28c887a41f28941b1df30e879b1633dc36a14eea2b1a3507169b1269950a9d476f4fa08c3ffa8a6829349c0d2d7c0884081981a3dd3c0f1a673a0bfae9485ef018638227a4ea88479568a7a1d325822e588c266664c806923f95defc38d0b540a94e71d8353891b2aca6c66e266950b065b5ce67a1b14084420ac7b3b2acfe5578f8d6fcffc5831d42ceb3eb4b3d6b1c95d53178f02a244885ae96a601aa49479135ff4876f298691822ed5eb9649670ebc957f1253d66dcc2547a60a06630630bb16229cc7c363e401fae97bae52570d18986b8961473dcb7293dbf287915a9805753b9f2fc3d96fc6114efa8440c1c3abbf1bb0c011e041f1dcac849dcd490ee6d3732f615613dd740b62a7fda1b7f59d66357448228979ce6a05347891852a07b3b2455d3a32a99d85ebcc153833a6998983751444c67c78f4f7eb302e5c3d94f5f31176ed3ccdce51888c6d0ec503ed1d39375ef3c20bd9fe182d95995ab1dab7c12f656456ea8e323d3cd3d2f2d03172a9eb1a31ad942830e326c8c1911c5c494190409e2af89c53ed6a99d6770a5b9a06f81e3fcb8388d42e60dde78d95be1d6f872a4981dd691cb58af1e66db88f1c92e065befca786a3b405f874d16b70e0578929a3c349d5e59e328442e5152289b6569f95642307feaf556d06f22be181122e7801b4f519aec9b756aa0a8c5fc71c435a94d70ef92d2200f408c31c203bf0df6d392b62dd1c4de78ae1036d90a34060ad93ed76940997593dadd1cdda467f512b3d1465e68d7ac725291d348978ef6cf6b313e922719f01535608a4552fbcc4e0da38dd558ebcb9f209de8852687fb1908ebe35e7b57fcd8e96a0d09330eef1900ac7c1c5e209958a956b3284e28c34251b0953425c0cdef0f1b6912be1f95d02a3157598e4f6ace92662c21055ecbf2aed0136960bd6486af19b70643deda6b4363a2100dd1df64d22351df498ce1afd229664bc941379da0a38228abcd28e6ce44e4da79c8e040405595e3bbe828c98f1287286dc715fd34d2d14154461d004820b2a08abed6be76b4f54249ee85c69f8269c4bb4cee79ebea06a2598c58ffc18613d82575cfe61c7aa080bbde0e604e3edb69446038612a06c6bd6ca3f88b212bcee49a75fae7f03584a32246e100c83958d1d4f6fcab2abc9bd3b4badabf9ab1fe80f190375a16e48ffad722102bc0cf07f1bfe347ae957bc69b2731c012dab1cc82ef31a3d071b8d7b887a1a84c29b4fd4621453022a329d35a2abe92f7e9704d105060eaa80156760a1aa162afec469a4f4686610e3eb3ae22526bc85a8bae5a669c5f9f04a4c385f2aa3eba9f2b668935b4ff00015500fe5d03187cff84b0e57579fec4abe45295eff89dbc44ab47a04d44e4e978592e44d9b9820a8a3e2eb041bce74433b85bf29b46a976e6db2f52db90fe4adc22b5f8840399da10a4c0205e524e088ac1823ea7dd375d65a8a05f98d2d94df83778244e02e34651ee18c18855a842e403f374715f1b6ab74dfd93fadd7effb03d81f5cdd1b6886821f58806fd6a6d9c93d8381a296af3610799f473105a509e998cf060e33d2fea744913e8a0f7ea3bedf29ca3d765e92d1fcee8e90577bca35424aada9deb6d92b13746b57c6c15552f47870166766b932fb008a2a542522959cc3571da59a34a013aee32beae9858e9a5ae3561df42d16d3f785710f7415d4ac636ceb37396dfa6d97bb0b96746703c75c8745c21a34803b795150211eee911406397efb2dc4f52e000706c5c58629be87cdcab7f3402bd10b2d99e514189264ca426d6e949cc951c74f2177b6a5f00756eb07f9689fe6ced821aa8f2872f95c60ecddc0c61110f0dc3ddaf67c03661f4f5275fbbff065fd4a90cd0685b74e971575e36d1364b8a27c515c331888777982f4494556e032b949bd786bc1fe43fa8ac57318c1d9999e2a972fdf8d5fb96f93a4f58da9f4d4676c8a0f90235207f498a24add95a32bcd7a2f04c285e628f43e1d50b9cbbea0db302e3039d9a0399c046c6d48b4b0736d62473ae6f15a65bd8e17a72e49e816fabcf811e49df958d4c4f498c1824d1ba71231ae16bf7a7137f84204e2757e346dd4714e359f430ddad2390d586a81c43365e08af9a681f2938dce05b514b56d27492ebed11109d4dd0441b7d67efb29effebff68403ae2f3efd88ce216a6644859abd538824abfe6b2076967490f2f4ab4e0779a151a9a4794bd6e670131a00c682d71023a0a36ae3dfecc58fdbd2463bf54a79914f31b8e193eb2c9a0f019b2b517fafe6665ca759192f8fb9b1f4a3a730c116ba13b250fd4f2a64f2bc12fb6ff86600064fe46b7b5a7b73344d4b3d196802cd4fe75a1481e31d4ecf4365e1a6347c3b1ce5bf25ad07331c78dd909a090e947971e03c61b5fbd4ef0158ba6b198b9f185d40d311613ad93c4b9324ab44f9e4a1f34886c5179c5daeb4d225cea262a332920a6c893123d2dcd95cc265cf4d598e3b10ee7cf1527f71e3b130f20204543cc2b5c15571e51fa4c50271f66f4aa33f10a97523afae20254c40c1ee91559e9ec71d75bea2f581b52ef87014f4eafaeb4e0182a8660f1bef63981f09aaa195e09bbc72e077531b965f2c71055240f9f216b75fb7618940f965912e0acef196cb5dd0012dd77765f7032cf1b5ec0f1e7b75a0b445f45f1201d57564788ce80d9629acee33acaba8000ac76794a8f1e29fdc678583a4ba96070ab981a6a37b5faece023b9bf2218482d3018d3620152d6063ce5d67c95405087aec44936a91d3e2fa285bde25055b2466f1f7c28b7eadb495ca77b75b7ddf1a5faa39ef8efe01e1751bcedd86bf2c86a4f102d3ea4c8b0c4c286d8c61dffbe1b12de5ea243e54d4061c3c890c560dff9d83d9ae33b7091d6298455a2d24ca8bcbfbad1bac79a923523b0edebff97026c40ad52c16d4b2b5fc8a9fd5b237d8c01e37a584882c3567ce1b30295c9f63fa0349e053d5b844e5f5bda1df03a855f76fbcdea56bc90916fca5b8cd37cf0851a6f102da0e51c191580cbd28ddaf04e5bf370a38c2a86c26d64fd0b57376e56923224bf0cd493922cdf6e21e9b8c65ebf27897813340fe52063f247f7e7c654d4beb6664a40144bf516ee58aa531fdb3b8212798a35313a73b6b17bee66f99c4b4ebd55ec3a22d7bcfdfce886e49a57e9894ccf15448debf6891ea1cde5a6a2b99c92e554c9e1c649cda0ed7e7c59d9b29a2e876b49252456713d3fb5a78fd240307a3c3f81bcc036421dffba03879f380fc7f5057d35b6f25ab6c4f71786446606915d599bbd3640243c5e5873aad443eb59d11d29516be05f98919b0bfae7f158668fe6106f0f5f5b734d94151b73e8ed2951a3900d84f17a1491eb6229340ccdeeb9b3f1a78ce2a9d945b3182e2bde4435514ccbc630f663760835045545c863e0b2d5da60e29092756382dfb9d76f9ca1004c1a9faea1694091fe49f25d9222bbe103a0519df43be3fc35c23ca4c02801f5f7dc0ed334068be73092ea23d5ef13756899c198f8bcbb8bc4b77c0c22a0badb3bb73e4e9ed713d831fae7186a89d9177fcb34f40fc1b92b0f7e4094d0782580ac1b09471224c084779fbf7ce7963164992bc836451328f0443931533881151b7b983ae263914bc473ff66ecb3fcb20535a0f4355d22868867c9ff1c545aafd081b32d567a010568414f93759c12149b325f43212a2252126322391f63e97192792a2c3b4d8bbf50cde095acbffe6ca291d1f6fedb21e645ff1a9e6905c47f6fc177f417510614eed602a91707a001d0dce2e04db2c2b5c06622b39da5825f8c4c0e24b423336d7452a6afdb1ddbb5142847c14ff5c2f6341ce9677f41ce00ec0ba91dfe9a9e9b3d88c565968a24bf239e0b866ddf71ceca0b15b8160f2354a3861b2a21de8ad38bb46dbb5bb844cbe50def0f13340d2e0d457474084408939d475626b2ae600a71d3a2d24cc0b4c5fc3303168b7a3f5cc6855539b09d84a5e644b2401a89d55f79a4e2dd49f91d21ea02045508b4efe393f64e3176f2d0aad09d842b66a9bfc4426dd40b9e52afa670645fd38f51202f880a67e6c850ab9b9552483f4a57b57bcdabafebbeae2ef98b187f4b4e26a8dbcc0fef9859197d2679b437c16dc954b7ad93b9b41d2d0d7a111c5d0a73a9924fb5466fd1c445e3f2cafb15da09862f2195079b4b5bb1f86c5807971ccafae33de032a0302781bf38dc1eb2ac1a604fa4484ba2bed45b50d78f764f5c40e1fff66695c15912bc277df3728d5241aebdf124035b2a26bfd1bcc23bf6c7566e64b22f367dd60e967eb8be03dc390db2504663fed091bc3b6308d70858d11a37f354366edd008e96a5d2c02c12fce7bc3d0233ee59e683ce28425fc7612b0a83c004764dccecd2d0054b071d401090ebe2b438f298ee2274884c05db72c3dd0a3a7c7e8c7a9c42c281bb74cd9c6d72db08109758cd588fd7c0a8ae13d076654386a04b55f3161411831a4b463d45d0748c7e9447ceced7c88af1decf4fe0c3b97ae773abba59dc297cc521590a0b5cb9f70bd58f4ea4c7b7e92067596d12b1a35d6b83a0439bc6a98d9054fe1e0bb7fdaea6442059bf49aae0bdbec9dc92da1c2f6caeccac89497e14497bb2cd41e4a65b71a66200f0647edf0fd333b40265d37d0c2af9b7f4e0bc99a1e617157520dbf9f9b5326d3a31af04449ee1375ade464d23ace572b56b4df99881ea36f51b08c82869d0d95acb87d64e3036b9500f3b33f16b2efafedd4a31173ae92550e682504653a0ec266d97191a9e12b48aff38bcabe536c185ce1300ed0dbf0ccbc37d296df625dc787ee8f38abea5be3bd803fde42743465ce2f9af0c66d641fa79c26a162c186fb26f1b2e5a84946787696a313d2b707c1967c7e766b4205a7e8379d5bcf4cd9aa05c8f431a4198c401636a16f469b674ce83111700edd8c212576965cccd6fcba2638bc3ac28972c191675b44d5ba445e8baf3ab02c9489c13f760422142cfc10dfcf8e115929465e935c941dc88ff79771f8d6ead12660e47297618d5258991a307264e734bad3942ed43a96985316faf6ed57b9df235a85609e0995c88d887529aa801548d9b2e5fd5b2075d5ec7b70fa98b54eebfc923ad0601211dfc434251d88ba7092c13433304ded7fadc765de7708db1d6ac1fe840e0c322bf9dfa549e190bd444127c9fe38c0c2ab5b1ce331831a3dad3c0a3a51e83080b8843e5a8c2f3fd7cd95359deb4dd6c3e71408cf77e7b82af9bd94539fee9c8908bd7ec78ab195889fd3b525c3e7a6c07196e9ce3f78129333d98792a68edeb64d00b103ab53d4600c9d251708939f595ab4a4df57b4b84b98bd3f3a4e992f7a823eb7101642f19c2e2930d442244c83c081e12490541e0513bc6faa9e3aa1897ad947647e1d7e36fe617478fe5f6982cc30262c6ed3b5432d0c50b94ee5678e1f37453dfea2440057e56469a5ae73186a7fd0989969b9537b3c94990d9968da7994a2f032cdf4d75adfcfed3be4ff3365c85b3a4ceacd3f887d0dc2ae4b8ae3da47f648a529e8db6305c82a8b06537787535fab8c54569452d98181ed7861efa3ffc2337ff86a127c1cda24f520ce060152d0cbf5938a5e56d3a18da6fca7173b0687e0e7c8739569246e6bb09e26cd119607831f7adc9a32bf97bf9928e0bd3bb48f0eaed5cccb03a73a931cae20e6ee34ab841ba2e5b97f747a026107d207ce4b8a2cfb5803a6135232a22d2d11622e11eff613f3ae75ff4575ba85fd99b1ef9ce05deabf82b8affd0548a8a14937b93dbac5ce172a245d49078207f371ee4ad2066bcaaf7809e72df08df53fec8213425c098f69825197b56d4bae9c5abce1554e46d9f9783eaf7583d96985e2b0f969f1457cc195ccde761ab8f7a9efa599ef088e5e9521bcbf58df9d375c2bb03f99f861868668e9d7ceccd5cd9428aea2df1533c2293b8a7a43787fa8a6cf255f4e0b4659cd634d6d00805f997621ec0c57122518563a59557563543957ae5cc1c8d7afccca586552a3c1c7ebd0246978b025dfb571b0c08960a0af2ac16c90b700ad4636cc2ceefab3e8c82230869ae81a89e22bacaf486a5d8f46202d0db415210acfd7b45a66789a586e453366414d665080fdc1b0e6d217439893ba55e7724f0a928f7e31114c48428cd65b4b32138972498681052c32d4fad1ce47b883131c9baa605abd511312a1343ca20d8feac19f18f76a453366f1e240182e2fb95d4e215f72005e5bc5087005aca43c276f8842efe452ddc62ed06352cc409dd10344db148a1e735f353a164f902c94cabc6c2216fd27d07cbc5c7b8d0cfbcb502376554da03cecae12ad2e494315695528997362daf94befbddb1ff489339438c31d1a048f41ce84424d0f0df716a62783f2b2f288cd00ba3f738c234e6ded285f944c9a79e6fc484f65fbbdbd1d682f147f39c3288295967d2f5d32d2ce6b07609672df4129bfb26d141671bed19e057fa602152f0b1a7232745aee4f440f6970e441271ece89c8e3f4502f0f8c22171706e329b62d0617e4f42b680f52b2e7d12fdb37fe85931ecf65236e38aec8ef12f6e25d89b7083663c63fdded427cfd3647d249f966609dafff3aab2f398fc7afccdb372ac4f3934a630d26ea58fef45ba972ed8058ed5a3388763fcd5d999818ffd2cd6e467e674c95c178eddf74d159934363647f233edbc0d524ae8e132a7c5bfcaefb8ac1ca215d01c5facad08175bdc197d5e51210d6f43614b47ef938b18e7afda7ce25cb9a5b1684f1556da6baf280fd81217eef2e41d957133cdb3a8aa21aeff168b3afefef304b83b23a2eae141ee2c97ef851808249b767a0dc829f1d1fa4b7d9ac4ed4fbdb4a7e32a8c7c3ea9c2bbfb3db31256954f828ab0e222254ea2933bfed766d0fff1683bdd6efc6ac0ee1cfe9cc67216d53e73c33aff0f11e83565afb1ef77f2173ca7c8547348503117a3229579b53c2b0999774a0f458fee4d2651f319c1de53dcdf0cbc1e6b21a62f47e9441c917cc70c0c03eea78b02f3636c553d960646c7841cf6b9eda76bfb0ac32515a59499e124d60b13468b1a8b9b3656638c013f798c564ada6c3446213b60363e0c44fe54c220adad82afc9ec0dc49f57f810b5d116c654eda605d66c7bc2e2098c06aae787611b1f42bc70ca7cce09cf25b198e237df660a17507bc1a43c6a50b184bd821033499284a9f6ecf58a9ab4c36836e6055cf8c50eb2b12ac4f13d7a2afb7edbb395e6f8b2a456567c495479e9c64170a81475bff30e658629376e0c9886428bf130158d10769fe40b33e05c40341bd26b22078ac7e504b2a6e009b942cdbf249f669f183e990eaeb5e551ea3d5d4a0327d16b15bc7930d71b0da0b2e5d385272ac76df9879bb2f76201ef8a3880db095dbe7103942fa09bf3f5a673d8284fee95f4db18a19d37abaf33a569b300c67e2a5c3b0a3c02783f29a966cbd6ba25090ec597116447b550e29718bb1aa3d8e514600fb3f68baa52fdccb21ac121d047acc611c1a81ccb37d50ea3632c60a4762d40216b7c7ffcae6c2a62288529d04c247179a162db45ebbd30816b7279e48ed964f472bc5c49a87b1af2c63f5db3b6a6a04a7bb33055e59802d6282932df2c8b382569de53b1c1d028d5f1e57ecb86c5a7c7990df8096e55322d95bdf9954d10dc183ddc8afe1fd1bad7d0ee129211b1cea794064deec439e25fd752c445ea83e4e1e3181115cd2820af797c5625b7723abd50b876afc5332bfa58106d614bd5f541cebcce888698586151a55f46908288c65a570dff4cf36836b2b4b71a0a3c61aa7e910d4bcc736508265487d7f4496a8484f1aaf307d4875b46c5d48e40768c4c7304405d1825364e517aba23f9781023a1cec21948f74b1b29290c4cef8f027233f638aabeb652d570b3bf8eaee169fe6d69fbb926945843f172441343b5bae455108fb5fc4d04af27dde9e4db4855c4acfa1c763468811bc0b66ad8105ddc9330e5df14c62c40d91f8cc7643dbaca76873181b6a5694680d1affaf68904ba8de603810558403a4a4da0067ef6b751bb13791c74fdf305785d9a116141be9e3dad438b9ba28a2ea9d1f5cba959bdc80b52dde976c9f4e46d8c5c70c6c05dac13a5e0ebee608a4188648b6524953c97e31f536af6f5f29bba93db8b41b6d13a670a96ff7e584bc87a40fe5cd71abfe86cb598415c0a28478ec3ef84a49464e1592043db130fc4266fe29f044f539f600962ceff2f602ea2a828ded7a2df349ebcbdf75dba7443ac6281831caa599480bc69c1f4e3e45f63f21cd5cba65874c4d2ee1cde615d96e2c7c8d7888e44bb72899a04dbc22ccb3f733f2ba6b4d10d4f6c5fbb01f7c8619ad4216d817de6ee71ee245d695cd0915fb84a2ea18f65758bdcdeb4a8a253f32ce23a3f5adf5082189a7341b53ab27bc367a93ff51665431d9eb6793dc7164c1bbd9c074fea5687536f2adeaa305e0618e0a349afc018eadad3dfde44f33dc05583a521796c3308ef871bc6701698546d934cb1cf97dba5f9eddabb96f3074f29d1e64d25b70e6e3ae8f82c045b1de5ca7adda83191c14bf7989ddb2a2596ef846c1ad789689d05b8c21f4df16739843249d3b51633e57e1f39ab9d299a6e5d4b055b4bab1cb58eab699a3e4792360af0379875a3c9e4bd050c1eb881620629602f5246c3f577d3c18de2951e6d8f98317c89f332a0cc2ecbd12a498ac4cc172be521e2ca7deef1736e85ad546bdb3372abcb62c1290327ef1bbeb96bac5b5b1a02c89a8f6c0a3b0ddd7a71890c1a1fa2666c8fd465e99de71ecc214a4287127c9057044a9f7036f034d6d1048f90d878813591aaed4d9ab8dc55dea76130481a424aeeee4b26f118c7088f0e42bb0c302d74cc9bddb727234ba39b45a45863093e6d57e6115f659e3be7a00f4f2bf836848229eaef5d269763479a77ede8b113d9888c70c9d224efa9381d52a1e2602595aa42cdd5daf765de74226ddd223613d3147bd897048e0f26a976b350b2ddabc2bc8a4c4eb96e9dd1ccb2cf5f17984d9e8acb612d31fb181d37fbe47a457cc868ec3a5acabf3be8b9ee1590268801a22e2f214cee425bf40ce8ce8589c236ec17952b22428b04497ab6fce1295d79b4e913429f453d74132ad064f77b06119c2f327792980ac78d7e76d6977e832c96cc358bbe962af61cebbbd068d84baca42e8f8dc94385d7800eb8218d254a14363c463931f86aebd8226be215fbc5d8eb06a160c4b37fef46be660c6ce5966c930debde3439c6d1d44eb5698d29bc031cbec1fe9aec78aab84b5490735acc41cbc0efea2be737fce209f1bbd9d13003066969841b7a01099d1252c153554e22ab94833d8c7d503cbc3f31d4038bbc7ae5d7228e52478cea531c2dcf3b0d45a1d9d0fcbb7254b18e8827a66e371a8cc771ef14e6c1d7e3dcff6c0f01ff885b059cef1f1744e248bd95dcdc20857b982520946a215ecc812087a5beea2af47abde2aae69d23442457a7012af1b59199576d201e3db8301d6502ded70e28bd5e9dabdd670cad0992559ae5ae1b54dc901f9dadf3f99ec7ff38b805400eca8d437871caa8d2a1b63f044ba23d48c6e9db2f4a1c5766c4b588c293e1c58e1fe0009e81c98f85dd16f1c0590af42b7d934f999b5cb9b9e8c89d2f04e8cf847dad769daf008d5300740562b4024592345dc0143024bd9911909d2aba45ac884b3d47f3c87f66be7ae073fd2e05adaac1a94e0fcb8693088e2e45769f4b765f9b19157f2dd08b9b06feb7c64d24a8060fbabc8142b5808ee1515f16ea252b2b6cc5a8be34440da65c1428d2f1d4708b2ea42ae91f938f777ba12a988f020ba4d17806e35b3e8f0b58efd8f8dc839220eb308372ac85ca09f4a9b427587a10516c68509f5dc5a72add058687e6e542bfa68f833bde8985443e37d0cb11254ab7b6d9a8aa640f63cded454c2a0b0277f99fb5f0d1abf4983c57d3e25c58f984cdcc73c04139a793caa09c596027c606bc935036dd8ebcb70f6db080b9c7e461db10c4018ac127562df65c4310f8c11a82aff672bf5100e44dba84c916b220b3fb18ca3ee94118ca8e7a50414acf3b7330cf25eba84944085a924675b070039b8037da252a2b99cb04d64b2763537eae86e3a2e886f07757f304d723aeb9857d4c4313d52200e8f0cba120b93d39029d41d9491d086ea9572e8e925adac1f5cb719929ac3b7588ee469989f36391f91d2c6869c81516fd40e3423f46267cbdb36f22ec7cc6e19612329173288b38c5670d77cece0cacd30db698e51adef6c2290f0ba48a9504298f61c298ac9602243c8a16522287b056ce3169e6fc7e40cdf30932b9452be664ee850b5f04a9ce38ed4fd61ff090fe1baf68c4c2283f5cc3492ac45173835092126e50e9a5955dacf95bfa71e07a5e3ed989e124f80fe2c6305f3b6f49a842c002c043eb314fb6cf943b80ac496793c492c1618db1841c577d453e2120287abf3cee476dee8ea868dcbd1d51a73363609a95aef417cd4e785eb71426316b67c7b774ce8823a8dfec069569ee881c50717566ce9c0090f26abc87f809c34075ee063f9cc99bd8c56b878b9205fb199f0ef4c98abfeb7c2f3f302ec88b5b1e662d5d6d5df447efbb2efdfe0e3627dc7095e567ecfa6cc05e024996460c7f5c4be52c389f4f1fc6a3287b64ebd697861b391e03b8a3537c8afe64ff3f28f6ce7711d58fa887394fa6db19aef86aa4cbba143f5087d374bf186a9765662e9e4e8592625ff6a1c9aa58fdb9ca11da33726abb18713c970fcde7d1c01dd7ba3c463a12cbf554b4cb3cad9584206f0af84009b2a45ce4e0ec8f61afd92a8eeb2502feb44ceb5e1c6d378ab8d9c704085fcf72eb97fb62cd7d3025d8e332ed92020bf3d1d168a9c7414e36ffdf6498f733988411ce8227329bf27e719ef50dca333af0f7296cb54c69a3eb2c55718a2575bd92bafe2eafc26ed5451c03475adf0156da7a44f29a6d564fbb15b749bb70e0c90c7e5a9b4d5da017b3f74bc293d0d65991157149d8e1c5f5eedd48ae96ef6f47d5f5d52525e7237fa28e55bbbae7ce1c90653643215d38a29e0f5e4256ca6804cf62d0743d1b6fcf805c19154e59e01993151aac45dc14883efa50dfc76d80f31c003d630b1893a968f1c150e1d68901c6035389271ee703d45bbd0888727cd77a052dcb4d5d9e44d1c785ca31a66c14de70cebf63819c9e4e6b767b42b2729107b8ad6db3a84766c8cb1ee8ab7c79fb65d590d1cdf521c417b3eecd2e80904d120704e26bd1147759da2a41f637fec214f39c1c2bc3b14d70b9ca9294bc0a3c86651ab17ec2aea33b3f7d806bf3207f30fb90fe61f38250ab2143543c516df5bf9a29fec92a3a5c7766a8c649f3bf9f4a011ec7d27ca11e132a252cc3b2513dc1d9ec622c6442a5dc8062453b901aba638b6ed5ff3f9e551a8d0f819055a4f8c2d3acc4dc4726f09fe7afaa56e1936859eed0c430043bcd776a51afb0c8800d09b24bd4bda495313b30ed1a466420215fafb990480c49efd36e678eac171efe380b6d20df05d1e2a847ec81ce623a5c7258eef49f39ae9f2f9d20af04611ae11f5f9fe5f3b09aa7ea742525b9e60af0518abf898ddeb635450086fd52c34fad30184416eafb82609451f15119d3070db75dd01f3afb90e806f350d2a4dd7fc0e5319e5b6077780e332ab353fa14051e24b22c34532b7237ccf0a50f71f15a0dfe8231a439c507192a923eda326e2be99be189c4f43956b08f46d2ee42538cfa5568f6c660a9f719619837778030e094735d493dbe1707bf46fca32b52620e9a8de9d3584f3f9cc4c44577689d65582962c338cf126ae66373693aeb9d3ce76d80467d3c670eec7fbd72dbf871c014052963bf8a5b300e5e4bd6cf2f8a519bdb1953a4cf9fe7402356ff8ef11307293d19279e0cfb4944e83c16f0524fd2700aac9d818256605056c12185c37724e1c352f92731d0558fc8fbe9e8f96b427991ee4279fb1fff84e6b99960491b3a1593099abaa4f16f0d1b5563a30a82af0ba7930081f7332b8faa478e6d14a56ef79cf1d1e5be658ce341ea5765a429742d53fbda74b15badc9b7ec4e34453b6321582e36ae6535b575edc08abdb3a35d5205793707abfc52f0a0af286f55384d549d368a44796a8a7a758a0afa6d42bc33c3afb5df0229b084d177760c46e9e87f65fe7149325e43fb82bba21285accb9f4387a2fe681002a27e28d61dd6eb2553638ee02d7657af06a8ce5f623f92a182d511bca1506e122d52002af4e11b059f6310bbc6d93fd51a0aa4ab9cec3cf1b58387b117f1da5567936c9bbf4164828f98917f3d025e20eae32f5f4ccd3779597b2d7856791840c6765d1be7168adb5c6cab440fb58e7963af26093c27d61a7726be618d1d94a5616aa90a8c752a8f35c27f8daadffb749126f025349c71016a7a2ccc89efce6366fc4b80c06e38bccba722a5b1866396fd983b928407210f6552cedc0eb7e0c47f919fadd220892cf7f76b2395f5926c72c3860bf950409ca6aa342f40193fe78952e7d181235abeffa8ba996b0b422b6195fa1e560e1cc5d4f855d12dc803b4d95a266a9b76ef5fb3f8fa9b3c1b09a8803ac384b72d9391a62375290babd33eb57ebef6753683019a8e28c4aee02cdb4c0fd51834788cf4163d1f97fe02adeea5808bfe16dc8ce478d2cc8e6b31b54d5f658383a3d612679d88da21655e80a9599628d4855f93fed3ca7f30f54a491c2d36d89f3134572c7ff57c2d2bbab3715c7751548f3a871578f710e823a974d685c6d225f827897b0c1fccc5a2a2e5c05bd8b4cdb7f33fcf01534618d2862ed9839cb7f9600e3c32f17d6a0b36860dd804fd1a555cf7b0293d8274216dfebf74a612a989b3613bf24d60e9e783d3f765d118e12cc267b72ac300fe5ceabe342fe272c822032f15e8105bd20bfb00cc10ab1a5d968230db5590502944d80cba5ed50e2a460a78c3ac30eaba02227580fb2943da19bd427305e3563f92eb344b32789d5a4ba74402c4f742a1943c59dd609f6c5f74303d36918c1e2277c661cccafc341385ab341b8808a228eb179c5e00e663d77aeaba1be38fc4331e5916cb5751e89f131ce4baae55b460c304051b5dff1aed8f8e8fd987a702a7e7904a4162c975179b29703fcaf50c1c605fb4434df0ae394b2a8d42f8410bdb4c6914e88cf0c5cc4a6f6c8fe159aae05c5bb8720d5a29d6edc0fb62a4c2ce697e9a3da48a5e7dd0468e2d257b7f5f7502b474223b7b86dd8aa6bad08dc704f8a0b9040d59758022be75b36a68f5b24df51f65d987d8c260d6787e6cabe56b37033e260a04b4bfb7c4ca017d74f32b46fae295300a88c401cbe17f70e034bd0faea11b60ca77026de967e22d8c326dd589e03710b456206ed1bfcdd741b63c740cac2dbda2ea719b34f0fdf2932a74b29ffcbf235390e6dc64e2543611ab1bab2f8065f70db78be6b813c3c6e16a16fb2bc42008029e7c634777509167aa2fdaa4dd155c3ff16f0d08e48d751a44e2ffd63635a88d2df5d0a1719c72dd402c572b1795ab81a0ea035470814dbdc1c6973302ae485aa2683dba0b2418d25e11f89a7b8b08e13c3a4dc52b1f5b42e19b4a99daf2b167c81cabff58e0112497fd3cd4750070095e6179c0b5b989f340c6982482c65c6fdbc6d2e8d95a9cd3a9f66cfc025aaedf6113cfbc9a603716fb8ffec81420561fe3884ee7d143b23f6e2b0cbfb153596e269fd21be64f3dca5cf43376cef0c6e98abdd54d693f9caf2e6b13448ced48bd8cae3899648ef81ae5ec8eb0f5a70d6fe3ac02499b2c283f03c293ea54c223d2031dbacecbd32e45d6fe02daaba02106002d2a394f080eb6814b15548d22497fab351bf809b2c3c4bb42e659b5464f977621066d7b33aa2ed4845e1f939ff8c91ba67cc1b34cff30f02bb8893bc4b8bf17dfce26d49e95f8a7dce64cc0de661bb4b0e5cb606e8d92aecb6ddcad20d4cfe77904982232c33019ee75020c71b4833173a63da88a26711539e08a81a02ba3953c8204a8758531bbae01797a6390e14eeda95cacf58901ca49e6595527c8e59a4e3c7a444ae4ec17582fa08e34984f15503a8ad8a25e9b777153fdb622672ccacc89e454c530f33f62a057d58b427c9da1d0add34ad9ac661647c57e89f64128dec9aa63582b62251a3eabb662691f37a66010bbcef3df369c3b7619c6626fd3ef064816179548799c5fafaaf3a60acbc3750404fb4e968661d69dc9062e198e14adcba56624aadba27899a78c1036c3b8916b86ec86bb73c4a8007333578fa3766f65dc69aef96f6b95c28f9ab75078d1b72d1d29699e8a4e9c4eff5201e638554c1c6278655605090770f645af7f6acaacd4fbc7cdc909b9399ab5cdbaa928d50c5950e00e91f22df0299dc4cef0fe72ae90b5ae9165afbf9a6e16f2b58b1ac9ef1aec9b7d9bd9fcd3682d3faf57ee6e775247eb02fad71efeabb935c7813327dbbf41e8d2b03c20a1121383a734eeff8266a2c490a2dc6567e25cbd984b33df5b0ec8d1439b06d53194a51a90e80ddc8020bb8ecd36dbd07f413ca7539b26704d945df4bfad78efb91be4c6abb8430f6218b667189650e1b3dd8537fe06b0bd360ad49cb4aefe995cad6a0501e4968c36f9194c142ca0187550e26a70c4bb461685e7269ffa61e51414d97649ac959fdb6528560b62803bced6db2d4f729bcb8c4bd6469429d1969835dafcddcebeec5a8b0cda6b902871a335a508d887a5a3566ed9cd7f35184c476619b0e82255dccd7d7eb3aa651aadd97bb4ffb0489b574fca99e56ff25d8de45e895dd559f1338dd4d03450dc8a4d2f0266d4c809cb4f9ba631b490961a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
