<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4999198444189a4fadb2e84005f24e0d297454a2ba7aa1ee281396605633b76154b741b912fb57ea04592fa8ccaaaf6b3240c8bf2781ea37b42b4cffc4eca06022a98cb2fdc28808f8f526a16d613d34b4bf9a60d4dfeb7025f4244851cb1af0cdd2815982a8e85ccec5fa36d09620d63d3f396482a2ad3fe2f921aef0bd00f9c3a47edf1dd1bdf89cdf7c79cbae3d9557a13a7430615361a0ad712decf28215f6d89ca173825276106480e3f9aa2b2872037257563fd1ae933c1f0d0e6d0d030b79ea9f4e51cbdaa58f9cd0a0d909790a13aa504db425acede78f5b2fed6235eac2af25874a616c7d72e3a3148643ffcf5863045b110841cda5107c5ed5cada6c217ae13b1a7fb36189f4c8b050c67dd85d4aad6bc18aa29658c2ac9d15243ed7450e8035106ec834a23670523c680237244685e87c88553e9c78ee8e9ae414c4104e478a250b30518b76f461798f2ba90eed6e54b26c20a41fbe6253fd6f21cd344bfb48e9d731b13a34305bd9b013a499af72eb4bca8bf5074ffa98547b95b96ac0a4c07ea672cda8e3f9b2b9689f82d64092f5c0424f04f096cb540ca5347edccf54cf3b85607ca5dee9f373d68de327ecf9d65d581e293a23e5d641a86d8d5c95b2bc66dbadb3b8f6bc0e30907f32a7e3730b14e38858a86e2a5af5fb724490712051ff9305265425a5e68cb4dd8bbab27604b4514d76979f143f93ba671a88deb5cb1356b83bee7646157571ce37a88007062f7a3277336714f4a9f1f05f0fb7e0d383cd33248152ad74a22926e9bf3055bfd86fde5d8bfeb4048f313fba81bc102933aa203abd790b7d7c0f7bd3e9cf3430e01656a751eaf6222f487992a5573f6795ca195d72059b9cbe72872e6e1e61f6eb3a637d0cf3f7cdb6714922b1f372409be0bf0700a11fcc8ddf8085b81cf28824a5ed32b31bef06a2bfc8a55a23227dec975a1674e9d14c5143ddc91f1627f76e5ef2c768439fbca77b7ac04eac3b2245913630115d0a1f4cca1171a0f9bd6a9c90f64d8e6589667351d21fba1372661f8afdc2c6fb8e3fb789f6b3de954cf6342191970effbf362bba75c0a443c04d9596303f2faee7af1c3bbee32715526831e11d5673ce05d012187b5a8b3d330a7a62b4115ea638d686399b9003624cafd4604d47c696bf1b8f9aa2a726d65b57ccc542d8d33872bbac9a4f758d61d8a48ddae0e662dda2dd09a0799f81b184a5d6821cbdf3560f974c8c1d3789f69d09e1961794bbd61a672c7822ab4d779d4cc9356e6811a1e0ee817ad9ba4605b447fdea4e1f37b1f48656bcff07cd7bc8664c53f4969e9ee203890bcf185b4a480c166bf5e8f06e1372f541272a079e8a8ea7e1164bdf49f505d28429a58d339988fdc89a5553c322fd7f6c171702cf10fc79ac0ae398cc59ef93572c7d6fb78801a48ed26dab2753b57d3ebc1e9d8003bd60f511219f3a71397cb1d813542cce5258d756336c421cbf97aa3849a502d75b2075d0ada616c83d4ea56b6343b1e092491ef8c8b5db0a89716ad085a9b834cad9843c05dcb058b7f63236c8b2eb3480780e03eff358a595b371d74b02a2201172b9d762e47aed51e3fd7f9d5ecda2393947dc37bde5bccd60bf50d68cb003efc76c62570786b6c9769723c85b02d6141a9152148cb49bc2032ad6eacdee9f754d7eeaaffffefd60f0d7c577073b5889794ccba996ba18a0cacf4502b39ffc198f09d5884f06114dabd3cb23de01073bcd177c908da3f7c7676a11fc10bbeaba554a965a8bd1285a2d919c3defc83914d768048baf5bba6e61d08e8647ac70271cbc881ab05a23130d022b8bb4ab2d1188b27ef5b216bbfd27e2ac5e13895c5ecfde0713fbca7d3aa300f64d9735afd3a1b06d98eef44b3f4b4152c67da5a2536be456cb03b93cb441be93565c5f178f20e8e15dfdc07a23ac884867f7b7289cc9ebdbe5f023b17e6e1878c27ed7a0f6fa5218f62cf05d5e0a03ce155335f7a8be116a0ecb6c82686801234bfa11b5e84ae9f04bb6b006af8b379d9b5949070526cc28c9b06c240ead9fb2441ca7da8ad5e4c1ab723c22bb4538edae7b836d82f829f0814071c18f60e670599c12ce25000927faa5711eefa568932a43575102d8eb1929a013309b1cfb145a752ece7aefb784897e559f61dcb74563113cd547c971e7e007a2125d74533ab48269f48f1c2e5478ab3c6f26c43fa4ea6a7c8b9e606a73f773c57434a1c4059a55450d02198fa9deb85de7498216cdaaf5bde283e7edd839ca0726b9166b04241f07c42ab67d3815c0b4256673dcc011c94b92ddea414d272b604467e062e019219d39815826fa96ab441037e83bab9836a052438c80065ed92e703fe8aa4ceaf3cd68eb8004b11c4bd6858625611ecba18148ce16b1b0d64acb0b4f8579273222112721c354e059d415267005d48b05aaf54a1f589a54af9a401502d3b5672eaffca2391c00301f4e90c206f880180770cde0972e2e18b7527c6725d21bb739f8d196600ecadc131fd5abfcb7db3f5b779d923f55ac7c9da9eda96e3430dd84e3bbf0cd9f5bfdc6bdead7577263631b9812f60c2a9e0778f5d311f6e07521d0139b08ec95d51224a5a8f219c34374e3179c511f20d77b3b9affb2e2c68cc4f50d3a470ba3be5d38e62c59b526b45eb716cc2588998f40bf339357aa3ac82b751b0de972fcacbb738e8603b4c87c1bc939d53eac05866cf00ebb95e239dc77d2608439d0ba5e8ecdd89cce2814d01e21a99af059cd61553b81e4386658dec89568771613105c884fd0084a6c25592b3942ec22448d40a7693ac7362b57bd94a6df36acf4efc2d2f6d3431e34f596de9733edf4b921c996bd4bc50c9a1deafbe9340c3e7932f0bc63f993dd8edd8e8360312ea6759ce176413d2aeff9709323c11ac546165cfdf220559c6268f02228e08ea5c66c14ab18edbb870cc8b6ef4213d63b4697620976ffae53e7eab70aad94e2210d81f622cf0bba24a90ece1300672a2c2e58957800f1eb784a4f199da8a13ece4e129a221fc9673053e9085204683f150db8334219dbaff3df88f37ab6d93f7b928a3c49988c7d63ec69bcd0d632ec932ef7cb149f8c8716aa87e5f299498fe4a36347ef43c91f9cfc6f501159bad34e29e8e2cf20ebbf542d40ec1e0deb9da90774f7b2f74b701b328c3a9a61b6d0fa06b27748b99555186cfc378104f76a667cc263d44197cb3cc8fbfd31203fdd780a224781ee4ba670a51812f9389dc7a5e0b2d9fa3092846041506e52d624342e5569277a9274289f221bbb2a027851cb3dbe63537535fb2e523e89b9a292723a3c1111ec14a65c5bc18e99bc72d8fff135a9d7f9634e1edc5bc4111305ca261d8a47d0eb359110af181a43df448546c68961852723d45b4f79bac9fb1d6739049db331992890d6349753e78e30c242c9fea245b45d34e978092d29742b579e53b7a5cab131da847ffc6ec871377eeda8b4e90b95898956c6259cb9315de61e2ade0ca4a5fa2db92bed7450fba9edaa301e7eccc26b2e7b62493502138af14ae16bb7186701c94663083b0738e13e35597b07ac83c8476cc4ba2daee5fe1a80209f4696bf31372a6cfc97f18ad585085e0feb3089b34bd8db815f30f78ab6fecb839061298595b2d9bfb370e578e876c8925f84f50fdfcb931a7cf7d4e68df46eabb027543d29e3ed7e41babb64b8c0c7f5f2316e37e494f7bc4a81b3b71a379d78b1d9d1f99553c75c32fd043fa7c7316e26e7b3aa0f5fc8866cf6d75ee3abb39f27c15e86cdd3391d55e27f6deb4fd271a324071e1bd64f22850c5394cad5c0aea2edd1377265d8b95ab3083b2dd6520f7727141f12c5c6953ba2f62a79f31841418ffe59b8a4a64ec1bb98eeab6e20c0187469e833fc72332209602aa51f5c6c78fe5664ce6183c5d8970998e83af98ee9b8a31243339486a5dd393748d3194307bb2696ce3de9aa57ae342abe78ba0f46876bce0c6b29a50008e74cbee1f9eb90f3597235458628dc83814c2dc4619031bb540e306758e80b8a2834011bdbab0eeae23e14bdc80d7c6441f1a457fe0adadc91b102aadcb08e1051b3046eb16c831f1937a10a07f8a6e0f7fdab80be8d0ba9b5f2ca92606883f5ee75b59865e46595bac6031690a69df52da394f926bfcf8a5bc87924e068d96d9b9aa0f3294166308704b670546b9fe617b6202ad599c982980bac9794f364e6f14a0ee68cd7a1eba94acbe3ecc1da95cdb61fb68a2b7448c44dfbb3fe422cf179e328685454ced229ba9724ad7fd55958d5d10fd52a0ef246c5c162f6307a71b6695838f5e0e3351239f79a11989439af86ac48b83174a8ebb67b7761552fbaffa69bf5ef341c456b7b753c08f55d3ff6c90bed289d005f737fa10d8b81735208e543526c0db4197e8e06c65758ef5fda15a53ade1be671f5ce2fc21a8b27c55735653655fb8cd7e3308028886f1adcbea38d4f3154b26d16e373cf87cfb543d066e33fe3d642490ef51ad344a1ca7b9dc9759c3232be5611d1f413ee7ddfc32142ec7fe87c685d0068f1af1abefefe197a7d68c4e079902ccbf4686c8a6021b9277807124784a6ab51fd7ca55ffccc0978691503ba4ed62e87421d0f1f3aea45606f0a6ce8451bc5cf7d875401380317e41dad26ed614863f63e88e801fe5a890aaf3d520e8e3a2e98c9d67998a849e918901666593434d31fa8131a8bd4e2f8339ae8a1a2cff71586e63a75278af461d4fd72c586026c06832f8da7d5e3f5684d3dae81560e07551589bc352ad5bb6e0f14681dac6d240693b6403aefd43c0641bff93ee10becb16286ff074a0e85be4b81ca2e53ac0eaa1373e1bf6aa0c6a145c5ff88877f1de11cae69f5f7472ed33da3b7922be177efc626d1285aefb6a0e7820267ae39df509327710ddddccd96b746b4d858a3b287c3677de776a2d950071ccc1eeec676ad47e0c3a4f07c3d6fedc1fec957cf216fbf1bed59f64513c9a9afaad782e7a37da161f04eea7cff5a4474e632556cc89f7db9093bc74bc9378b906ae0706250310314177acf35dd70cc11dde4981dc1f2ebdbf08bec5b492a2409d0f85619aeb9bc6371bdfe930201a1a5166c4bb82e47f416c2fb7a244cbf41a0eca168d2f4492aa392266fd3956b5b803015977b20b2ba5e484cd4382e4b01ee75b2fa8b441b43237f555bc90291b133a4d687c6d09ca33b94e3341eb68389b57136c920a25078c815bd9ad83badecac394e36d3971ae0fe9f0568ff56bc3ccb0b38b502de186a2987902f0a7bd4c68f50435c11822536fe2679baafc4cc1e370521b3c53ad4c93595730c76aea33bda3c432f8398e4e1ed6d738b8e4906d07f261a5531f37939c128d75a278ad1d0aeb5391128f4804780c500362215db2838b9eb89cfb268aacdb609592881f780264d075eac44577227582b0d3caed6e65d1b9cb2e2ad7b3a445e63a3b0692a3d1727f30ee4f7865450aaf5760166e185f73be34ea03bd46443363824f869557149beacfc5e84b91a5eeec2bae236a22aecac8e7d8e4eddd384c7dc9e4d18619a430fe9aa2d5cc1383a0ec2070bffab1a1a77618ff5f424c9f2c3f4a9f908343f969a40708f39143f02691724765657590e60a4e407c29754561e85fb0c2e8b77387b9f1ee688c65f8ca5007c6de7695d2fdc6554e939e59cc02eea4dfb91af19c85339d2fa93fb6bd7250b7d2407ffa89893401e8406c770a4852fc87e7db7ce12c7d6138dd39f3318180f613d84e2e072d223ee4194b26fb37c511d6e6863550bcf77931d6fcda0ee4b91745570d366fc66450d025cf4bea7e4b70935eaa4937528236bf343ed5175065fea5f0375080402c1839852d5f698f13a08e150da67f54210c726f0171bcb2619594b11e2c2078ab5a043de7c018e26cc1b9e9e3db9e44b8bc733176b0d1d592386cd6b7d3b75695668b6f96d7b5850aadd6702708a9a9b7d86ed3a7e658cf39ddf6cf5a5ec011195d3bcfc572ba833948f35ce1783a7618c31d43b2c56605530736239b8c3fb8d207b06bf5ac2f807c49ec8193a0988c4619adb75122dd8abaa5da17d5d459b9c6dd54101bc35fa4f07f275ae66b67a898c52269e7df054e76af795a6dee92109b4f9c149628b1ee53aadbcd453201188597f663681a200906062cdaf4e4ebdc9d2e954b5719a02f94207dd0bbbb54f80634da77cb9e7cc850eb70c3a91479492765e06a7f9237c8744f6dc9d86cc6961748dea8f7f8c5c7e1702ddc932f501ffcef9f40d494bd1d3bb71debfbf28c2cec012ef7f9980857a35cdf7632961d0c07c64ec17fb2e09468ae054f00767eabf7061221c5031b072ae6bfaf8a8030a74ccc2862800d569a166ba15f5984acfd6ecd181965c95f50c1affa7909e035050b2e7de612aae5e474e02adca9c42f7b3fd8b5542c9f0f6dd55d308ef75e14e24fd277f4527be9ccf66c916341d3619ac3b2a4bdac7254b34d1b80448c51d53898f473030e88f6c31a111a5d9f72fffcc57e5fac3d7dd5c46c1baf5bb4044d1a0c579c4adc30a67db604c446f96af8aa4fecfa182c3388a4d5a13f444062655217dd176739567d2d7cdffd2f2ce8b2630323f5f9a4572d736c3a3e9ac23ca93f2ae94bbd7ff26222ce7f9ec0ed16df747b99f7b3295ccad810292562fee12cf4162442723acfc62b74cd284ac479d8b48a17c451a1047a44bd0dd632657ac5958906eb7755cd6837b4a217f7de80a7157c5d4faf29f885fd71e459fa579e7d963bf318a4c282764d509994615bb63b0222cb2396c91d915d80f275bac1df924546471f601ad4fc6288adae31e6c99ffc305f8f22d8ea9c653f9aa471b9d6e4e1b23c9f63caed95dac2e6639f7799d040989fbc61ee92cdeaae0695ea07b9aa318561f5f22b3fcaa19a1b01a55d9d81183f58656b440d009426185050d9225451471c9234d927275c2646d752cff9a9059fadbe0f157b5e8c4c3b743860eb6dedaa60f9a529403f377a707222b5fb0529c1c1ec175fe330007c3554e43942170a33b846af0f193c043843fe13e658df4622582305bdd4264ae1b76190f34faf180c0ee17b33f651eb5e0543d29b90469ddf3529f6e1113dab2daa3c3b63d40fde1c95e597a9550a56a082ee6a8a9dfd609f7a05a18f649e75a1efcc73972878fc07ff02105a39912a25b1ca83540d80b87a39b524e54ef56a768c951b8445e7f0b61f1a8d82d87890fd8dc838de7aada0a7027070414af95574bebec90267947b5f4be89ea4cc24ab94e146caa3a71604033620b34b9821bbedffd59fe3e574859b8030ac1db7a6bcfa870cfb2d50d06c2e21cbf6683b5506b419008602e6542603f48424863fc28605f911b0db21570cbd5a0f9e177f5fc06ddd08ad3eebb24e642d66c3e91f9121d10caa1d1a32bcfccdf4894d596392c3e9c60f27a5658f9068722b812da65503e1852b1a5878cf43cdb7b766d09ce140bb49f00ddc8b7d239d9b67f54638ba0d80261ea74fd6327bd66ef99b1a4802f47dc50e21183dbc58ae6a9561000cb117771309effc7bafbec1e775cc0b1a80e6f5077c14b0795dc4bf91dbfb3a504433eee7254f907935b8884acfd43e83d727b4bd160073467de40e17b68574eb8a959f8be115d4d2ed514804ef8d72714f58baba640c5874a1190365cbe49100428ace007f717583fe8ccf29029e03e642b735a6d42a770b54d748b99fa9da537e1d5645e5ba2ba44718b13334b17aa22686d8a9cce6a539b243f11078fad75b19190dd3d84e7a257291b122fac7055f93f11b675586d895e244567164f51ce4d99b9b5112b58169a72270fcdf4481c8a5282b8acfd43f0b56aedaff7605168209938d72130d831ca1e938ea20b9d2f17dff9259646e5cc2b614e477f5ed9df8b788200f55f5d3514a5af74821f0d4faebe55cecaff030a1b2418508cebf312af1ef996231ba0c6505aad40c479a02d23ffd45a72bf1d845874bfb8ea264423e8e436c209081e6859ed66261c54326baccc60d8b6f8c725186252277d4491cf0f1770d030df80809278f306abaabf798564d46350de9081e4d65d1035c1333eba795dcc5964a0cd766efc81661c6f0e96ee131f4e883d65eefdac7063fd9cd7fd7b368bc112b46f2ee2c9cfa6c289bba5c885acb8d28714efea59cd47932737cce8c2cbdc8fe60ac4be4f20eb68366875f027713ce89721090d44c41de31fc4646ab7d54207318a0bd36c79fdea48e59f0d2d53b0f2a685cd4fb46c620534d264a727b133d7b7e4c0e290ba8ad8832f68e86fea8b5e00d6db2ba4d1a8ba1fc104484386fc8be11641352d24f067bbb9979fb2deccc363eb7a92773347d09c121acf010cf7fa04b6063d7172d5f27d21bffceec2659e3ac034e0938e0d910b4e6e799d0130a053fd5530fd503f13aafe2c46ffa4804a20b72b4b5be9bb782fbdeab77c45d9f389a2a9fab4d73ec26aab558b2f3b28810ddebe9c4ac956552637900c5d9c38a54f99ec619259ad40561e7e258893c23ddfcc23743247e9d31c752af7e8e8cb3678875eed99554a623ca1ee974ae037256aa751c0c603401226579c14363e902d33497a14775f7a270daec238ab8ac3862cff76297ff423be124181c113c40f9d4207d67d726b1499d2d95c4cf6b5f2b4b91f56f4c23b435cf4e769fa53c5891fd92c40f9fc481068105de2b2d2938910f6c9b2a678d3e6012c7e2215f17989afffb0c4da607944c5239dc0a070102f200d0e8dfe966a69ccca076c9d485aabc88a1247bec65b33fd6f0a16b0b52cdbe49012276b2d908660ed3b04a1ed07a76b1a13f91e333f6f47e2ea2f121689dd8f8b6d1e582769afde0c79a9ac6725df4e4ed87d5a46b330c59b17d76ddc1449752b2d8b8ed611a36eb06e9acef3da2f3fb709e7df755c8466ff187df5dadbb448530d831d82f490883bfe8722fb99cadff5f3a9be5c908da50ce5922a9671d2f437d55f79ce74e130e2bf49cac3fce3856d1f597895ff6ce84bde07176ed4cd05b2455233a2cddabac374a6694b574713b86e6861283b5a7aff0dfcf69b7a2fffe09a01c0359e9085b75a42d70e671958c79dcaf62ab12cef86ff7c9d005275afbea4fe2e5b80c1d37442d150ca1da6da45569ee5902a767cec472d54f8da775ae1c41ceadc688a55975fe5a73c68c787579bd9a3d80f0613262e8d689209ddb763c844769f682c29dd5d51af9150cc5fe9cac6a50e3f33b66c8dc3d7d282a9ad6019e7a0167c424ee08ac955ef366b619487fd04e4fa0527c403aa19647678974f25b6d78944fdcdd36d5734de48042aadf7e29577758282441e3443517e9d54baef7533e9254b4ad771e3a14a69ffb42e319a00a4562a350fe1d5c3247703fc6901f8d06b171716ca34895478032305f7224b9720410eece502724616e5930f2a565cc3ee0d2d4c964425eb52fee77e838bba6cd5b1551c9fc2a502f69be50a9d33767393a66312aa9266fed02e5b98852c4bc3831983035058eb53613961edd66a2e6d508ba5a603686b3ec78e439142a85193186fa42cc4a6aa083d0367ce637610ffbc30d079eb12b5f8fb43f09c04a6fc19258ec8f0ecd398458e2a11b8cce7be24316920aab87bbbdd2fb6b1cb110cbfde236a8a4875cce4410f82ca3967f91bcf2d8e5a04991313ff223977a817b0a9441ec5a7bd64d4608210b5663b7c306c31cea91d8290ba37a745a076aac310166c4b84ddd1f695a1be5f34a05de7006379378f34fb7bea9075af53ed328cadd55e0af9bd816d44da6261f2d6e722db67961ce586b45a7bc9b151f94e3cf22e719de6d0715f834ceff7cb9707b333d2a143e4b5f58447ce08a02280aac93960af3da2ea15462f09031dcb6347487dfcab3f00513953d42308bd87a88804b2382795ef5c399c727f10b3658c6e09040f09f8aa1c5d375186f849cd65009606876373352342d2550e44c54561dc63d5d11aba5b5adc9b3849f85008ad197ee92fe560c552519d9cd92a61944c3ba825b7aa0d2fface20e16f496c403be18b85709909b2654a2b9be96aa8a8a76970db0cedff3a266596cfaf429147f7cbbdb79410e2e9f2d874b4abe4440c8647a6295ede2b62de5d81e5eb7f514984976ac00f883954e6d434a4aa887d1805fc43f20a52481fae797e7562c78861f9021a4f01ac819bdce818895dd3e73ed6002dd02bfb0a2933a04dc991defffcb57ba46125d5f27620992a86b3328992dd2f93085395db1e2268f6e6381eda30ce146e30403d96eb15a3293c40ecc7d2b0451fad16ee67d8ae5c93f4dd466554255de1f3326591f23ecfe39ac4c7bc85bd649f357e950ce2120dc32a01a586598068aeba23c0871cdffeebba4d35d1a2337b4a99dcc3bce535d1ac59b9dfb3e94cd47d073c92a88903c8f65f96067a7d432b92edc09deaeb1e91b919ef7a335a94bc49cd2a5177d66ca6f677719f85728cd85cadeb7ec881a9f6f5afe9835d2889d6d99d251a50c163ecec6011b8bfb7a3b5c22fd8450f0d670c7140ec13ee71627b954681a68cae8f8c8c5a318f92fa90c1b4ed112d3832237388ea63e7fc11364026bd30b6be49d4ed36d9979e065c96ee7cd3d02fd312dbc81a7a57a7f36a2c24776949a54661094a35eee043e9efd35dbd9251e601189657e6f9cdebe769248c68b61b5ca731064554b45e90114d8f9752ec9ab2e87cf1fdbc6a19800e8499ba39dc1f0282fb8d4eeb29382861189f54d2c64934a160c23abacd5ee77de27bed29ca9e6cd757b93a4ab00d41f85a89a9d1b8aad0d06c9189d745f973eaa315572d95f76078acc5e5b4b57dcd8a47d459d3389647f661389034092e6803bb40a5e316e2aaea1fd2b2020aa62168426deaf0a4420eba06c2f568ad07df98f9e23d767018b7673ed597d00f657d7d4886681bc401fb4877038a2f465879b8935dc782d8bab557d097408cb2e72cd851f7534cd30bbd7748c408947e35f1b458e5a135219f6cb2dc122c1de030c5c912eb0015c5e11aa8dca9614c2f16784269dee2cf14aaaaaeec8ad9172f38f0116c1be8644208bc1d88333f11e10a2a0d59f2324f0041b8d0b830cb094f47849ed8351aa025e5f1cdfb66615f3303003af8ccb954a7d5e10e23f6348d0f4ca38b3540660b02c6e7391a238bc23b892c2f6e99de5b9474a46e7c3de093a9966daf4accf80275b076df20c0735276eb93fcef1047fe51058d6c34acc4a6779e68894fea190bff58627890b5025fe5a3a297cf4b46daf47478a9181b684b40ad81a1685b12b021e635ca883bb0ac5852673b7690015f9d970225af87e9f7ba9e84ee69f4a472bed6f22225e2009b25cdb16b9ced5d09e8e6716a3bee1f83409e43aac5bc01b81d3d2ca7ab9aaff369bf06ff663e46978a7818ccb541aae9135f50ab756e6acf2180d4a092541b0fbfbd7c36927cc9dcfb5dd75f593f048b058db36aab9ba16b796376ef88caea69600f66dc6d9f2ae1d8b68bcebaff4a483c39f0034876948192cd38f5a46c827ba5f6e3d1c47011f13bf28a8b84ba0898627d46f5dc4004c8c019494acf5dff0629350124f2ce5be3d1a2179e22b93b83db42f776dea8ccfee8e7d31e7637e01ef334e481572cfbe81306a223958f1458b2fd0c232da62f17f1812b062e791e31072001b1367a09ec361f9e6720d35b05df408af2fdb8559a68da50ba0b8f0deb40ad4419b25dd545a73fcc6e045e1ce813d7c5427e238c13b640e3a9ddfad0efba3005d2f7b6717681b8e015e3aa12e5d671d9ce4b29d2117f0c1f81d2a38d99a6c496a8ba1e1c3a220c70166de2f067ac38fc38769b14d4a26141bc7f81a1b16fcab51960e91bdf5f3aea7b6ce6039e6884a89c83dcca85a416c6fc53fdc766f471016ec69dcc3af080b61fe2117fb9acf0ae11c7b1ca3ad15be1d00447ba84257f929b379f3760365b9cd1a8512da7cbec328b0ac1200274fdd375a89386e7f04f354b3fa57c452e815e226a56575f98ea5d11487fa834714a770ffbc226587e4894072218a3440154ed90a772b6528f03f926ef387f494d2a706d9e29421ed5f243bf3e07e2c900a04fefa5d769bab0712d906774582db5a4eb22d197e5353d76a8a43085a5b4612b6de817b06c826d6879f6ef2fc845aa8f1bbfb58cacf0380728a2221c62f165f1ef7ef41a1aedbe7191d397a729f1db62b726885f9c8c514f1d7a046d3a85acd9e5a765ab88fada60925014bc2547ccde0c42793447cd0b886d9279e6215d58bb55a85bd692d4971a2811989d4a477212ef54da49ffc12d18d63920b486273a4341471acbfd7916a3b23d6a496bc5c106882ab8652565940f26b82f4acad2bad6c5c1b058d0d4fe7130649d3dac2d7cbffd9acdb609b98ca6a259b73d06df800e511489a84bc3a806ff11f585115851bed1fee7823815ef64186d15c2ced69ba3ba36fd0c11076da30f1ae2bfc55c48556f1c6c3ea8420302fbcfcf1eddab045c177f535be09c78606a4b7ebcfbe6c56712697fb945568c60eeadaf98394ccf4a2df18bcdac1f817fdc544b56a295d6c35aa3fb5b47ad72b811c99c281fcad496bcecac347affceb69a23ea1ef59be193cda38ee21a8016bca307f6d53b7ec0cd86ea87d0ef6e9260e8e7fac33066eb109e5305a4719a19ddff370d21ef4728d1dcd8443e1f239bf6f2129d8f16f92d551f56f2a6d3d6187ee1c45211c456450c06187301258f39e80d6a89604e1082d53d4aa3e4938bb6d48d584e64f1f390fda55927563564aa2d685d4ca03529a632fd0605ab6128a09bf9db301d5fec64ee73bbe0be0cb4432404b78c0936bc65f3d921a00834f2dfe2058092cbf5cd1366e9bb6fbafa317b21d734574f5eb3a33e73f418096df5699764bdd88b16c555abc77aa19af55b6e1b14f7838db4c0b0fdca3ecc6071c79ee2bef27b7a7207316e1499d53b924a66bf38aaa11516ee619a639b29f210097b597ba062900074d5ab06d70850634ef0729e0326529cb6af378402d5b6194045a976c6f9962bb997b6e37eedf80f4bee09cb55485c3570402b519dae2c248d336ee0f209276c71a77c427245561f3697f8b8f67929285561e289d4cbef16d6f0cb4d89b9ed6a2f23a02ad80c517c800a79b082b4fa10115e238d3fc20c4356dba2547b8be9a614e9866735d4ba4202153b58410d0ea2b8905c5fe62fc423cfbc577771c5b206fd151cf1b8627ee4ed168daa382be0d4ecf9b946f13d4a14a09e2076c059730ce2371de66589f4ae309ab81ef5e2b7c061af2ee7d4f4c26117a4708295300acc104b42a1e5aacf0065225954d7f7dd12ed66ca8826499e7568711371dbff5ae3c4d2e366ec7030613663544256e9f86298be195a02bf22ffe5d8cc4759e14551039e3b0bed595117c0627430b1eaf515a7c662b9325becccf2034fd2f11434df95c8facd7bbd47a31d34c3aef5c8e36fce8b8e1e19201acbe832683137ee2d6cee7f8d63b085cf201c0dc630714f6fe3416e6bbe65e220679e0fc1c06ba73e32e3372b011597c946402ee84f4fd05d35b1ff153123a1e2236cc5e16b201ac3c2b0ee97b37df20e29517efe7156759802a2352d851fea9a5994f3bb40555bd1b6cd00de8c4632ce4833ac8c6b2cc838658475f6cbc4526b4039c9bd1735c1ecbee985dc9e8351d54b51a743c669c15ed18fd21fcb4afe526d4d7e1b7c51a3244eb6ae05e1ab84de2616e1cb99753baf7dc3f8bcb9cd95e0fbd325e3e40433da8f03ea9aa866727e1efc5aac3745deb2b7741ab16ed479f4cd1021d8bc85b0a19460f90dac433a38bf845f3aa326d054caefba126f16c1fa1a447853a59a354f18abb5dc62dc42af917e2ee07550d4a59119aafa7de2be0bc43fe1312edab5ea4cbf087a3a5f4d9e96ebaf3e654a3faae2acd809083c4a7fde583c90a7d034fe483371e08229cb51d602b9235fee51bc1c7fcfbaa1cda802e032c288b70c6f0dba23a32cad9b13ecc363cc1e4ddeccb3366ab4590a3236e30e717ecded9e11de129ba52a23acaa225a2f91193821025d5af04945d5c6226a4ea0ab64383feca8fce7685fc4e349a44aac30b562f9f7a3672e6e41fb08bbede389bdbcdf91413cf0392128095e52e5ab0643acc4af6c79967f69f287d5c09ee3ccc8763e26657fbab0c209afbf49275ae25acb810f3163d1fd0e6335d3eca922ca858e6a7d643a54949ccb046101692bba4117f7c9b2263692f9a6d38816880dde58e671066b4ba9677c005c48cd94c66837df2652ec12b8c4957c139547c66a7d5dceba7a232980dad8fe6ba5f74484331ac72ffbfaf621e45d9455a4d8977860ccd8f3b827a4d7decf61037252d38908610376deaed164cd1abdfbabdad7b2f9d539887f2c930f269a1632800161226f1d741f6ca5053e4bff588939cdea3e3b4afbde598f38c6716ac26fde97a7b02b672bb598cd6d4845395472ac70b7506dcfdac07bf75d081b81194398b4d40b9fb9f8c4e9fc055e00adc006c5b1dd8ff287c381f11fbebf04cdd49bd3f34ac5bbbf3bc1cf8b41c8aece46c4856b4b09abb8cf41ae1f4bf71db2d92c93401edc084202e127af9b5c68f692621933482bfdc6a389fcd7b1dd6bafd8031a2e5f5b06f55f2fbaf9ff18f097a4cca3c03e171911ec3957ee5b3f578dad1a09af4da66983a6a160d154896d11933180e507fafaae25eb8138893ff3ae99b6bf1bccb2b89235f3f9698296ffc6f683c958af88e319a7872915b9cd653617b1d6e00c0aa4ce84e48df17ef5f84d2d3e89131493be00c630f73fe93626f78b3c64a142d60dd786d409d482f8492b2f4b2efd7257c631d53ae196e2a0deaf3875d2d11da6817989cd98735666c27d6161ba8a51d0bc87ffc6c92c3bd7bcce9085646467242ac496e12d6a93b37f7b7c1479e890a4c65aa5a54e89f921c4a7255ed677a41bb1f3c69670b817b423a00683ca36cd3a85a1ee8c256c4ea04f44717b05b84af4ffa48ea36f0015511417dd7a9ae26bda3e74d354aa17c83843dab5a371e1fcaaed03e74c027e9c55f918c44521c485859b42b1b4eec73fb99b696000b4f5c72ee5c54e140f8c2a2235514e832eb40953150d5e70c230c007cb5ecc716606f6637380d551a87bcdec0af65a9a9d4dac56e1b8503cd7cea8550f972d395730239eb039fa35d9f781483e33057ac6926b5e676ff872fa07c13b2b1d4ba15d3b85ec040e01e2eb247fc9bedc393d00f61542d6d16200335aa114cc1b6f729944b31e2f6826d403233bd936ca9ad629473cbaaa888746b40cad0874cd334adb411446b18153e4de6f37ad02d134ac497b96f2d57df9f9d1b1651e061930b228dc07911f6f009bbc9c9dd0573f7ec004ab8045fa4db242656e227a1ca36c8550fb3157ab962f91a47cf07f83eb074fc74432ab67356155ed5278e097ec93b87d7a96101ed895c78a201f8d75189a4725b1a092627f9c267978d67583a81753f98a264990afc4b232169b031ecd4e1162db59029ad4d8155cbb221d691dab1a3fd9e6ee51b7fe72b06944c6922e596c2e99c95c2634cde68a4cc00a45c9f5b0d5198735177d24e8d53d4e9aebf948c511e48dd6c8c0454bb86a01e1224c1ee2a9b14535cd237f281e0b86bb363d795f665b4c39923a91267fd9f7ce376dfb0d7a3d0f7a348f0c5b6bba7fb90a8e2ee50f6b0cbe4fb4b59bc3c329da3dc185bc2e3aa554cdc88daafe406a558bb548ad4e99988a40ad1adce6e647aca373afae2a5ffc4f3fa2f9febff8d213012a26c9bf651f3e5a01535673b4d59e2246a3244940cb1ffc52fa01990853233fff79eb5936072e86c2018e8d18efb0f29b791b714c1170c88e6d0f68d145ddb66b5a477d69fb2e81ac3a4410c84113eb1fc1883129a73fee0068095c25d8cbbf17c83a2bdd8454ca8100eaf51aae49a49fa754f505ea21dbf39aa9ee0af5be2213c04f768317bceb6942dafcec28d1bcb372b989b3b4dfcb140f29efb7a2947b6217bc3310ed643586cd25605e8b1c48de7b8070152a079722d0ed49af8ecd01ee81814b270e9f0b94211786c1625e4a1efd15ad28bfca7c9985689cae6669db6769ded2e1192f508d08caa09786fcdd6e89e653d706284d5a929e1c218fed1cafa304f28959b52dd5084cd0a1ca2383be4804913a092a3ef553a2b3ff30c6a6f92cab4e3c0f9904a2e8e9d434df44a0b1f30a24367b31ece12baa816f82e0ed1ecf0b59b72dbcfa52461ba27995a49d8d1d6cad39d302a77f3af3c050baa1c868cf100d8f3c9a6dea208c3e5efc6eaf9dd9b4041251cf275590ae96ad887f347eb901c75322b80e5e75a04c0917cf036d44dd56f5dfbc281d8b79ea84ae2fc669a812c3724132887b043f2e2673c5780a7bcb35163a116a3bae95145ed5c60a643e3aaa13594fb605d4059c091e4f284b8a205244d1b39423884c30ec38ce7905d9be886ea71eeba694aa1636c1fe1186e6f534cb66fcebdd51fb74194dae719b5e893dc9263756ab1dbc13892cf4a83050571ef64d8fd3f08ded89f3358fc5028a86ca6083c1b95ca4bff4b60d760ff57ede572518c7c7c3ba3d7898f4b58759c6578476c9480b9ddaf86e5731e13babae6d6b64e2cb6c1f1cb60ec1f0eb8738f42fd45761dbf9e87a9e12cc4e37cfc168f6bbf7f9425ff9ec0650ab425a674f0b9238c3ec495ac4d48fad221b29b2ec0d18b62b79b0bc078a3cb9cf0e38532e5e7822c086f43b978b193ecf68ca51a86224d1ff121fd498589a4f398d3de0a2db2314e699dcb534087bf5c4efd01f62d57d5e20a3a041d3cd2586bae5c43ec2b4bccce309fea2effac8a482ae2dcd949838416db158216bd5f4a80fffe24623b367cfdefdde9e4826cd138995fc4df3e0ed8ffc68644e82679f66f2bdfde89111165444bbc2301b80b896da27f275feb7aeefb6ebeabbd7c4b8f4fe0a01d8308f302e2174942980d472bc47d4d6686b366626fdd77c0433ff40fa85a1a712e1b63102418740dcaed02bf6cce942d195ab7e9f5a57b34c0f167d88dad06d7f9c0a89cb021dfa6344b98bcdd44f1b69c25cb59c3c9e2d2410136c3c67db2538c43f78511958fc28f5459e8cd2f39bf2f5a099e43b49fc43679f7bdd83573fcc764d520b41bf3f360fd11048c77a1cd0e724c7c2c31447cbf2b77e8337b5bb166d04954e459c7e491d2545c2f19a24e6c218693c82766c98304b1d8eaf848a3f7716a783a3802d09630b7fa2a03e1146baa3f58ff590e8c35a05a9577b2d13b356e075dc773c13a3d3d17b69abf07b02498dace41726e0ca36900be4630ce980bddfca865e8366ced49931dc2533f63c6fff1e0400cd71dd210ead25df11b3cd5bad097e8ddfa4e694a90625eb8cba509a778e1308dc3ca338e4faa1475bacf7dcf2f08a2d0482ea1c28a3b56e555814b7f264e1969d9ead724e2ab86eebde1287e1f7dab22c593a099535b397c2ea4e119484703fc0fa66aac697e8d9f956cbcd63e761bdf9f971ec35e4c66446b1bbe9f87786351f22080957c16c51f5bbd179424b1af5886d414c67b1870572ea99a5e1e531043c04b549bdb27cdbfe62dc6f378e54b42ee66bc3a707b505697198b163f34d44938c4089fbfb21c59ab94f2677a2d5816f05c6c637d421212113e5b4908e5bb31b7137e2c940816f9876bb39e840d3fd90ba9e06afea325150e65a2656edb17f6a0150351d150f5f1b6098bf4da85b2fc2753e0ce379ff0b57c4af0510b65fd3d25a60dbaaea4734ea9f3b364d622dae159c23596df2e263dc1b96e528905f4b558134412578bcc1360d8cddacbac5812b0cd20b0728787d0e70f1ef18f0d629a1552d04ced8eac9d3de511096804de707a897a81a36db84924caa18f9715801c009185dd6e40c8af4a843385099cd0d8de6c726b00decf04f41ae13b3194c33d9f90514f66ddae343c2739fc22ec1cd35e5517e8834f111acb8d5a29788c6eae0cae2ae2899f1ca50a225b617162aaa031782868759ece01009caab8ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
