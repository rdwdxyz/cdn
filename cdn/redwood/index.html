<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29705679a3ed9ed492e0513d7036588f50912959c5490356085365afab827cbd4ffe1f58dc7b6f8f5880e62c2d0fd7f0b159a9bdbaa877fbf39c013e78c73bab106252f997497838eadbcba0d011f2581676ba0a62276de7c665bd9aa913445c0cb59bd9bde8cc70675a2d86730fc4d2da078e75f7e5f53d0b2ace788a3adf2d2ca16aa5178d06e1bd7203eb072ecca0f7845e65d0c011b79ee367b411adb24343f08cfba6ad31718449f1ce169388f489f003abf6d6025d6c64541ad31b725125e5382613148e2e87afc6f9c7a9c0f499bdb69283092793e59c311569bf165acc6504f393bf9e64c7d6eed40c3c654be8c852b963b43e3c13a06468ff5ca85262e84d9ee151e76c41af2241ace3627cdc08be389ae71dad6e3a9f0054e27101eb77723d664852fb088fde2b239bfc1d6763a22f46c9c94f81330158d5d076dfd69af9a3a5345051fd698d65241c7cb6155989f93f89c82923fcdc01ebdc8d0bc76853c4a5925bdb7564c3e9a29091998929dd69f57c66d5b020797a76a08ab74afe4d9394ddf3b52569239387b37552ebdbac761dd27f2cd29a58c298126630e0a06c5e0a2b29f88382ab701848172b5b3890f8f375a4a98ec04753249c80f8faca6bf50d281a9d1adaac2b19c80a8d06c676164fddf53d32465dbaafac64074950ae486398f25581885a7c9dc4f67041a59880265d671d04148bc75de26a97990fc0197657444ddc0a7317b3b646be92e402b7cb0072eb3c59ad73e811a2b3fac1f82e8f4cc9e4394519a4658281c38197f40cc19a9d3f16aa9dfc7395e081c931df19b8c2cefc49692d595d906c6246cd85266278a0c29b0b604c0b3aa8b33aaa484c8d60ae5d4d9e86d58b819e0a3da24b95c027b0692aab50fffd8cd4f01947f940d490f294c73dbd157577900ba38db60cce71b4138815ec58f71c9280ca26985848a5189128b7b54824a57ccfc428893bb1c0486a48e4717e5e3dce7b12e975ce6bf8f589d0aaf4e647307e6c7a3782c27d026d846071b4002369a6e9c863f844ed10c67ff65f027902b7c88cfa0a52fdd1d4e4a767da7f04ad88d5ce0232fcbe9beccc2ff26e3f49608658d8199a1e895983b8870ae04e5d3414aaf7cb10b40dbb91b41ec45fcdb0c195a5a6a82b19aaea7a36d46554325098c941644081db9bfb4dbe051ed1f45646ea5c3499075975d7bf8004f533ef941c371d6064414e4db6d25dc94477e1eb424bf9a48776a12e26cb612e49445dfa73a562ad8b95a2210e3a94205dd9e1be79841b69b25df8fd9a4bf1d4a375e937d8431892febe1f2a397fae5a374371769fbc4b733a0ee5206fbfd4a4359e250b730d731d1af72159601dc440ed1dacb9fd4bfbc16ac01b296570f75f11f9ad1ab37171ae5ec340188d1263ac31007002f00d353ee06a09f3625761167b742e498297c862b705e7f54c4485ebc21bbd9a2eb8a6d91d623f8ccc2f2ac3e0212e786cc18228752ae4a44d33775388df5c5b90fee9611a15717164630793bb2a3319d001c5d6edeeb4ee69bcaa27cdb540d1deb39c17f11c0817b231af62d63a6734596a71b262af5c7e4ed6f640d7d3845bcd28d8b54e81e837cbf71304ab0cd0d69eab4e2c2fa7e7be2d93bb2b46f35b711a08bd70323afd892335c1b04af6e559a4dcec762a616266812f8e4b38236f2a39291d04df388fb85f7ca386cc799f1896d76bd477f3370f92b6696410025815e9479785b0bcd70f60f02bc5c630c4f47f1a1a229f99631b924dcdbf259304c00969dd5c2f522b7bcb522c6b9764792f7d1fdff3bd8837c0026db52a2a9afc58138ff49d463bd88ff3c75d796a096d5acb80bdc1d0634259b1e2d2e72911e291454830493a6665470b21ddca2931c3950b3a538e39b2c6d9317d54b62a5f5312bdd43e55fdd97802c8362b48ebf0b0421d33da93203e69bb3df20097089cf0bbd9e16a44bd0d2769879966e7899d2b835f3592468f8d3c3fa3114619d27de3bde4621b96eb8443a10263965fc70a7cef8d402bdbb2439f586abab760368a10f0cfa40a2e8fccd2eacf6b2dc63876d807548a6448da7de3e0c30a687c89b987f73c19aae2b3f3fc401fd788c41f10d05550e41ce49d845790d7bcbcdb1ed3c1c14d9d1c05078b2d76c11334497fb000d522dc4805bb561c0a9ee8875a627fcd8fe6b4489938660afc7b7ade31459f7658aea98f0923516465b3e7c2af93050e1d2557c3ec8614053252265072f0096ca6d21d672a858c1d09fe4cf20321ec0b43d62dd2d210d66b9598e10747f1724fc0b5c7c14f282c00c58522685bad9780b326b11b3e02bcc4495d233aa83c88bba9adcc9859752c3b62714dc495f1a05db336e8af6de42441383bbeb83e1a238d154ae26509ebe6a6520941ba817909806cb2c18718507f64eb52a35a4281dc1d910532b6348cb65865226b362c6511bfd7e81f4a9b5b34c976325521f2cfab69687c3ad919d64e6bed8ad7809933446466a2dba97febf9e4e79a36eba8b273ace34685f4df1fd3644e47506b95a2337b6251bf631de303491a159a459530eb8548f5e76905198a0a90e13470c2c4b4dc470374bb4af9471d5863cb6d59c5628f7f60e733899e7c0bd63da0f8ea6aa09719a3bd9e6c288c5ca01b89fc83d8801ec46d6f4c0b0cca90330eb78204400b14c755a0a3e3a2db62c053af2611fff66b95195c39d324f24acdcff5ec3e039b10cd2a6ff100ca676a27a2efc1b06ac8e5fabfe867041b543cf6c433e5dc61953072e4afa81a953ced8bee119ecd244e2bb82f60b8d41ea2a23300d39d522e8d804cd0b84f07f903b865bc08c5478e275c4d736793c68b82bc6643692c1af150d0a70907ee360db0251ae1931e063cd05cd40bb2c77af52c7a453249672cc64151c0a5f45e06783c4c9fa94701a943362b9296eac2b5810db5fcc910b87ec40828c5fe717783d9b6fd67e1ef21d7ca55f25ff5d01718f91f2a5e0c0eb055de5008d35eec9daf5693f4862fd2e9cae170875798f8402ce465ebcff5f0ba71cc9d60398bececf04e1f3c9f501f84ba84a367a2c52ceab5a49434d463603d10db21fc44f24e8f2f1d5dbf024c171e9d030e127aee9524349e9406bf739f3d76b0fc9c09640f58695f87a2284c60eab4efe163b054faef73845e62082df8a9870e8693543ffd9525c352f518319fcfef5af6265de0736dc75d008b8b1f0a83999aa11e98c1af1f2a3dafeb677c9fc44e674baa172e35e58891678daf01ce8a68bdf4623501a4eb1ebb097565c896f885a7c340698f8ff54bc0c097743a53fe99b9b35dae642a0006cabeff6f1dc4959ed03f8e5193b708817ccecc5f5cffdc4d9eaca402a1fa8652f53ce1cf62b721c6df4fa312b274e4482ecd0ecc3cce19d3e7537f977872611bbccd33c71e0ef5a966821471a6a671fd2149c42eb044b85e928a2e34105c574810e7ada0242a19ffa072720d528a3edc33cb22370e946fc2f3776e521abbb59293cae086afaccf795107c68bf2bdf4a911bb84036159555e3e7db8138bee965fca5ce5446fc38e6abc3a88b50da7b79bb8de3a89b4ca9ab237e9b1fcd2f7c054f4c14e813a546cac54df73db7d7b5c3cabc90ecb8079c05c8a88179a23a6b8e9733f887006e33265a21858fa7ad87bc58295a14b36308fd2e16fdc64bbb5cca6e98d56b862b4ec572685719638dd6463ca77285c0ce2286ccb29dc18df2791ef0abe2ef4986b19a33e61f57993150aa20e6fc3d6bb70e3916cb8481ac758c6b58ccbfbb8987c13376c869c5065a25a859a8a2ab809f57fe34703b32c1e32853528a3d1a4209c07466961968e9cb8b10d7567057d1f90f54ae74991e20903433f589671603f8fd2db7b3cddb7b4767038b83d1c7d378577dc169dae085bd4d68cbbbd78831d12206c26f286daf9d6115c4130d51496245a8147b1deb512bdd0418bd427a2c5e893b229cf27ed6406eb007e4cca4ab68b9ac55ac0ffa9fdbb6df79196146338a0b9f0725a6bc0b99f02e157c8d5cfe1127464587fa1d4ffcd13329aa49e8c156e45422f6b684262c3fb9c1f5b68f47edc701d9bf3e30bc4a2409a4922b421054e1e7ec508b05fd107be5c1ab6ee6f7755eb8a189f78f3a96eea2848c8b1ff57d44708d7d3b5b3ccad6db7ae962f5930d62d0eac6c539e3e9b1de624f2d53bf81bc66daf8d07b4d24d7cdff0d4f94e66afd44ea5cb1b5d021f873b986f317c886d0f18a7d4043825b53663fa78f64c03d8f1db8ceea8e66eb966ba749fcf84277573969fa6e100c1eff2029556e4bf0b18fd398ab4d9022f8b77107d889754bb26d939ff8e521092e1d801b59c06373f3a9ae5a94f97429fbc1d1edd107a24e316f8cb52c3a38545e4a954024aaa447a6976dbdb118fa318bd3adaf7267051eaf4bd5f6e5e87c207b1573a717c88903aee2860af2f96b2ab7990212e3fb35d3ab881baacf5db029255d1f92f839c29c8556fd4cb425e1a5e16d88c34bd64eee0fae8f7083fc48f353b1cd14e9437fc8ca784eacd0c5108b54c3dcfda3d620f9d3d38d8d0809b7127e7290e6a56318ec1ec5da1d4f4a038345d57d0b28d11a59f74501fa3cc176df18877ba667cac9d68db7383776cdc7d263486c5e5153273d6010355b667d7f66911e58c682f768c5ffd8b7063eadb92abf25acf35ebc6c89fc5ccf6efd2184f19b281b3504edb60932535a27a4b07fe096b328c373dd3774e046b8495f84652e58571238cb91ccee3a04577cf969735d0d371830551c4d4069ed43e5c97bf0266b1b8add2eb54b0c1c07b6faa7f86e7be6bf54eb07c83e24b91b8affcce2bfcd4c3b4cbc175534440b18204afc19c3b7a8a28b733e816ce4d685cf2dd85c6da8bfe4cf2af9e5cd1868dbca62c5a1e6bc3b6b2aa071ac4c4770252de49bedf4513ccde711df6fda72e426968263f6bfbaa6dfede710cf586aabd2653de5ec063bc746d5dce33e64144dcbe9bd2961666bf41afca3d00b36654ec88b799053098d0cb2c912a16dcb5497998d0997b39939318f9691cd73c2ff1eef435afcf9dd262568b45d14f8931474c8699b30a2b734e13d947a258a2ecba6aed2b556731f3e205a489965c76b6bbc06ff4af850ada91f480c062998773b814d389a71c2e2832880f237a9c3ed3e7d864d0d684fc91fcfb2def1a6e005d582707e1bab704ce34a1debb2afed6dd75af4abe0aaa731cb7e5bf0d63e0b0236be9933e25497096b8a37c10267f8c7d1d3a5268f2e2095659e53ef2d255d09a344b5018a33a438f9c231e530311fcb4c0b06a3b4c1f9eda8d6d21a5d566f7af49dba4dc422b41ce28f6ac254ed72e56a319f280a26d2e13dbd31f0fbbb8961af6b0ff734ad59bbbc2493efc4d0f3eb473920db6b9d489ae8213dd0b16cefddd85a2c705ecb19a703b39eb194070ef5af1b5c2a73e94ae2817f4efa7bdfa7559d28e1382692295e39abc892d0dec123bfb2fcc8b37bf199079606d16313c75f719539429af54d5bc18af11cb14dc48c70959dcca027747f420d9244b6dc34a3a8cc85285519452c251949d8db0a4d58c538a33b3fe1d81cef4d79eb915d35cd71315868aa8731bcded29f54d39ff220eea28bdf96accd7feee34beb2737eed8a8f86bf97bfde73a2433c1e85f36922f8f5abfb7e9c43c6ba5f5081f96671c6f250846c866c3a28836d4cd9fc295065c9bab83bd0b2a899915638c87e402dbb46af5f698b24d9c357ab49ca34bfc35c983b30c3b1ad431fc1b032f9adb0d3add84ea2e365a875d837a12dba927a89a0e4e50ebda4eb637178680646df4919fed4fc7828f7efe25b5f5124b81493d43ed96d409e2b611a46d8b9f4b7fa0fb2a4c139f034fc333d10786a18fb9e9b0262bf7653492fb030da8c0f5858e96117870b4dba89100241d67e917b29b2f544c5cd4fe21c7aeab7867e92f2af4ea4a9aaebc786313827484faf7719ab1474b642049bc8870f1cfefeb996f24ec65d8ecf3ae64476348abf18ce6aca520d7632a18c9955e4c75d82f3de49b637983daa1d422ce8e6853357781380bb09a8f53ef66340367f6c913d0a71b47301085b95378342fdc5da30b3dccd710c3ac754b0f12e9aeaaf4c2c3b505e003b42583f9b947780e93f774604d3f700377fa7da22f8efb4aea682eeaef3d29c7895877ebba276c07b4ae58cc0bd5dbf60307d9480501d271d65248fe9f8696eb5822a961f485be75de7f5791c3d307f81f7ff03730434339eacc07480797bdfeecd3acd407a99df1d0ac266f0d160458cf9514cbbf43585315f91055aa0ee0a48907e420c448195cbfd5231332e2a9da1b47eebbfd3bb733be8020b3e87e331abac1775fc1cea443d62367aeb3e6833e2fe170d3c72d30ff426999a3a5f5ccb305a8cce5d799624d3ccc7dd1b1a1ff4cc1bedb05248d5012cf84d357de9d0164b6e0cbb00daa9098ffd2f7c0801b6137267f0aeaa690272513044ac6a13270a29dbb7e9fdfee6d245c46492ddc3a97de070cfc24a0fea0ef2e075ebb7ed0b7e6d68a1bdfc0c4354f5a84d7c5348041aec03bcd71464b41cbfa07817564d3b476996e5e340664f5f58530d8a1e6a10dde23e63ac93c3f5cebeea1a96faa904e9e6378e4e4a30ce9a3a685709c79f1d9c77edeb12935056053b762c006a2927242fac3d81b8e84f52b67b8101efe9bb7697adb1901ddf8e6c6ee1dc3ecb8cf9fff09a6ac02e44361c1c46355adf301dd27a86006adf32a3d1ed1bfc502a4cff0a2a1e00f2525955d21d975d51541220199d6da8466f1d30b81378dc20b467808c2444eb49783e6b1ae5d08f2055dc1e94d4d539c8c3df23696bdeff5e3832d1cac03301ecb93453753a3d18b0713925031eeb19d6730ee497c622f50bb022f591df54e98e6f8ecc6eb862a9ea396421854dd02e1768ffe57352461eb3b80ce17449d4b01b6b78054dafc1223ce0f2e71eabbeeed689fbf1c61ed3dc75aafa7cb8f908b9dfb2de591a6af5daaf54d40634835ac9fd257699159adabd98cca67a3bb8f76e66626011372cc8da7e3ba9ca723c7a9703b0bf4d2118d3b7a00a69f42f74636d2f00df5a2dfb35e82ca2c51e52754b9d8b2594fbd80c16c94a85195d0ff2fb2dc010b464b809bc2d5c1db9ee410e10187cfde03bce8123a7f010a997b8eb005daff89000358fccace2387cf178902f310f368b004fe99c18f2dd8187d42158e4ff004b9d6255cd6b03c895d0546e92248c00a6db6b53fbb6f612c8a8c42f4b49521b8d1d701cccadf4b704f41c1ebf510b1a5d012618073eab5ef649039c1f1839106930bfa8caa0ef3ff32b7873c10a94eea6dc274fc514b1bde3059f0d4e731e22be1529efed285f27d2094c8ba24bcbbec4906438d813caf9ac91e2852b10026c3eef02df1eac3d0fee6f318cc24f86bc9b10b58c08ca1b2244f30b655900be90240e60547e7f7b53e720804e459b6fd84e57dd0dfb45ac8a6b28abbad8afe92fed5070bc95a11dd5ac1f075d82b4c63123057410858521b7f2c755b4abc03fe89571a91c80c48f20cdb42faae7aff49cc729de5e9cca3c96376614e8f27ea1677e802520563d535e6fc399e8d0fe00b63a428a951700d7a6ad194b4aca5c14b0c7e4eaded50b5739aa16e566b79792b9bea87164f021c734ba7bf92d060fd9f925aa476340a623a925cca161636b84c07cb14205581e340112fdbe0147019f0887a99cab797f34b7213266e0d37c1a64e0e98a3f076037558e1fc1d69374fcc1b5387f9197977fdd32917bf05a5b50e5028d43cb9f52b47ee619004bfba74782c20cedee9f8d0295719239239b0d0fc5bdcae1481d68b9d5a87ed944ef91332825329a63ef2fb1f8c5f5cba36b4fe8b8a9231b72042170645c283634ba49336553cbef76c79faed3949e364cd6dd1cd4db1cdbc0698e316993874e3cee766d2414f6f5af8e3b3533dcbe9c8326b331aaacd0cd0f4cf5c36fdcedf1a0980fa6fde7f6726bc3800d458c59d4c3f65ed5a2dd42fdd6557c32149619427f91fb277d82bb1a3a4ec95dd3ccda98681d72bb0c34a29c4426658fcf33a1c2ebe8f5666b84f789a85217bcb9b8e1a2f29edf982ca6b53cba863d06dfd61513a9bbbbd1112bdab0bb2332c5f0a533cd188019d75cd00a4c3e591556ee569dfe1da0f0a09d021fc58898d2ca692b7b31ea74c669bb5a0a54242833e416ae9563220c38e04c9d9a097f901558ac9a1631e822e9194126f6ddf68d2a67351c6bc46229ffb19c88ebf86221d082d0557da8ad9db79bbbc3528229772de01be48a103bd957235f19b5c53aba4814cf7c7ac075aa436b118b2bb947ee09a6f5196517380c7690f1296f6ebfed437ab74c91b4cbf1006d7dbfd011166764229d6a9aba558cee8d49313f1307942f8026b222559329ff1d2c671fa184f3d2d80f4313dc4273984fd5fb9bf245d367a4986af4a40827ac8419c25d95fe948d767a1a795062f1e5ebcb70a149d898fe351d956ecdb8723438f4f81752831075fc2b8d99e622e2404a56dfb24fabc6ccd3ec1d23b16d3149f6eb346f4a560b113994c1c6b4c7562ba77a999fdb2316f9023a4478e8b020ecf32d0f5265c62b35396d43e12794e2f0e3eaebf0e8a4e7a447eed0962ccc6524d6220e85cae8452c4c5351c5de9a505b92c7a56244c5d766b1b5654dad2a31f4ca00bc7f8407b41ad57b9c2fa7c30eaf737082a522cc068d9a0f0fc509a7af9e89c64487505a83f331981941f406675542104b673eb397cb63e8aa836ca24a5f0aab67f5442c84d73193ae7e0ce9a4de46562d7e7e251434ac6cf460188bb670e0bd4aba3c6c14194d27e6d2e33a1ec978deeb3039f1e3226d199188cfc5a13a2bcbbe85f529bed1011a585c9c732be3a5e11cd5e11d1e6237cd7905965bd3b30cace9ae3d8399c73a5f09082a53f54520ea9fc23f6e0e9d9daa1c307299ce804330cfc1ee9dc1a8ada040d58133f11fcf3ff844c766662f6e8094a4d5bccbca4aeeb4caaea2a65c07642f87ac7a44032662269335de5ad25cd668da48d23c119265229df75a928f74c66e1bd7c7f856d6ca5561cec56b4cc53911cad082f999561aca7feb3ea8f29f7e92efb7f9bd30c9eaf0e8b81230e9fa2f5daa156338f9f5f8b9788edd3d96e864d272f8af1f4ca1ec7724170f5d28ef799551ab119fd75a73d3ed31ab2232249eee67521ddf82957d52ed1e0aab04e5669bf5fc5c841144eed71839791f5917d3b852569c9fed9255155808858765a77808a9301e94d0c01be4b55f326261cf147043726789797e52d82ea3a225d2ee26143aafdb11a873fcdd0bae5e8e9bddcbb17e89eec6a5b396700dd7227123dd62fd4784a006106c8f48e40fa1aab25a71437f4d788914a468aace0f997dd33d4f7d7ce9639cd47538befdff792fb7eb65cc2cd196a8fc62b649bc7b99249349dfa84534df55a7009e9859db9085d725fb59a8ce4ba299b323e2b4ef9cec111b78c5e20e8fea793065f4d320be067e0ac10d570ee6056c78bff00f858352660b1ad49a01d8067b57464d2360e3f0d6b802cfcb8614ca3763b4c73df917e2fe2fbe6873c1c34d01adad05031dd4c89265d778830d64ce525683d4d681fad505d006b62d4a669966f203b25418e4d832b5eaf27ce2edeeff08c6f813144de8f81a717d329d108be7aa053a34d37a9ebcca092fec5b66b3877451ef92fa2420488c82215dc7dcba4d1cdfadba7344be56ee61f848a55ca3c3656f72ce034b1f189c1d972ed56a157e78a11be8214abf7a78616849679ee3153a56c42728780773bfd2c4b6a26cd403ef29e8d243fab6891a07eb43ebe974f85bfbc213cff82b2b336f748237d628ec902fd0fa3f72da1ac37c94b3da8e0498c071a7938dbf459250be17059c1d7c0933393a0977af003e6e08c09ff6f4d464a3f91cfdc26018c641ee6c9432d740feb01dc4f52e830b681a9875e1c60186b3a10558ee984593864d21cd6bae85d389eb188116b3dd6dc56b187a8923e36e773dd91c80363ae3ed55ffcb8d46a9156f84ddd3be2fe6010a1f9927be6d4824c6bfc0de7ae7c4baa7021846605e025c33e06940f22d57a317478c77bc12d9f3d7539ba5bd385e51e0f75cad29840dee6bb31eaa55fb92cf20643411a75ca6daf82d103a8abf97eeac19d613048fccb611849ca11c13498868e970e2a6a6171d99dbb7559661038a1d8176ae89402247e3d0557dec372403a84a81889f20980f024b13445dc932328ace1ee20d9c1630ddaea3426dc1e3f650c33caa5e9a17b3cbb09513ef4b6cecc2d9b2a9d48d36b4c8f94b214ebe8b74323125fcaf677a9ff9806028a2ceb5fa68ca973ed06686ccae704bfc4c97748088edbd1827568a665fdf1948096b67e4c7c9386cf18239f25f1aec3209a1b08d5d8e37f7d2c346506db728233b32cbb78c909f88f00a774ffeb5cfd2a53014a0238f4168a8f7b6b7ee0064a01db4aa181df9b98c09b9c90b47fd4975a50cd492d89517f565492da2fdeaeb537553de6015d143da4928faef92ba90d985bfe4e49de8b29d341c7805f281844dc0c9892ccd2140b2b7f01fe934d5c79eae938cf6ea7e52a61b48da60e4dc0f8664d58fbd7d336d98206a76a681479eebb49d47bcd4f21326721c4ef8bd403b14c0e336f88f22616b075fadf5ac2d9c27f9fe75bd126e609b2533034252d8f3afe5e17eb1324d1a8b4fa05ce8ff24192de337e217e9024a9e0d07ede2b1ecb5cb9eb6e7ab699b835725ac4e41175b4f4f4095f9e44261a04850fe75662c9c22b9ce48c9271e4ae4cab2ea376383fe33a023c25ee0039c26eca718d07186d8cc9c12f2bf87f6116b1600b109712942d37c1d1eba8acc271261ab89a1acdf415faa610e373c0a848588c85f084b1b74f6a5b282d6d0333e44277493f3545846fead580625ef22699792d2aabfe2f30f65a562d6ec8f59461e1962cabe057faf5f2b3f24c6273fcce32e4c550b9fc17ee31464b0dcf02a19ac9334773551257d2f791259003831460846a1031c1b189a674854d4d2d3ba5033148665747664b1b33e41dafedb81163f41bd0637092665d53fbd0eaa3aa8651960018968d55efad689f1a448c5d388a9a134ef11a938db7e964d7c2765c5a523cf1ab7048e88734ccb340166c0886f3283ed7f09bf0e27371811f5f85d530b3511c3eb4fd913b1b49f5c63477554f2decef5d6add4f91a6ca1fd218e9aa92590c7aab78a3eaf387c02e735038651571a618a2c54edb23f4b55d1a46f869034aaa4297138a2d8aaf2ea08474b22ac87d3a3a41389e2c92bfe14bd1d1978e97d76a41b8b37defc466d781ce60fcf9e5c71e940905899864ea38bf60dddd270dc371c111cd713a669f8bb8c3bef376ac417c68d3beda02347926c96d1aa847e1bcab5dcd03a7bf1782ae12873f94e9c798d0a07d2af4cdcb935ff6f2f8d577e4c8b69531144f3bea4a0cd06c593e78e9aed6720978cf774f08c943ce371ccd5ab2d69b151c37b8bbb93499175255afb4c06ac64ed0e0d4fe0116514cd1cbdccf05cc4efffc06ca05da4f1a3190ea3ea4ec6237976f42fe8044c451288cae7f4f38cbe1ac2b2a436638fee76f8ee266a9058e60e075d5837584f6e4d1b4d80eda4797d398b5f91040cb5db299f7cbdad9e1eb61c92885028ab01b6517db73ad2a8bbffce7f9a1326c0137e158607c0e7c145668ead57cd136771e4e3ccf97b257501d4870b937a64654eb20074719d02c160dac4de86f392d3399f1bcc8adf5068e5afa753a75aed915f91f3b7587192f658c981bf6dee69a9d48df1add857dbcc30c6a9f0c4da0920c6f5bcda69bed5627e73b6067905b464e65c3c75d3a09c3f8f92ab823f37e0d48c42277fa075cf9888ff3d359b00b1dab48728c904c5eb1c4398c66273779a5b81d2f7efd9fff90b96cedb1fad5b1aafba0b0af973c9bd4034da9bf9c304d18ba050e5b2ea1a4485a11d3d2557412930229ada21b418b1631e97b4cb2c4fd4a60be0acdc0d5aa01134087ad689c720909a49f2f7ec1e2fba561641ef8ab0f3882440e21e147548098f2cc60d25f4fa932b8fefe50d1116b68679321a65ea3cfcaa33a1f1b925503537774b170ba7125231df35a571429f88d9ae96164731a43d922f8b536da14b121fcc27aaa6438dd4e5dc75c5c9bb4bf54eedcf5c92acd860689db3c88c600d329306be030d123055d07012ef05e8025b6383dbd69c05af96c7c88c1cc55f6cb00db7c1a94fa06ad52018fb0e212afcb8f6def5cf67cbf4836dd5fd74f1eae622508f42db185a8279b658f40f3a70d6508558978e96e0f28b955bf7be9dc14cf017e63d96b2a8e6f7a5123e2d416a103fa7be63be8b2c0f238cba2e020b19225b3ef1460c8eb351411953b8d962ecc6609e4e7504a210f2026d173e23d25cbd1b2db0d486ed90d9d7b11f10fc9d4b52d3ced66fba1c4711e9050d1b223c2b8d28d69438340cdf3cbcc22ac789e2b5c363dbcb17766c903eb16659bbd97d0ed9e4d8c22d5416a7054585d9b8254d67e20033c8e7c68519b740d1401ed5e980bb7d60623d96253cd874757019a1238c346397c547c33316a5662653101412353d7f2d27988c61985895272582c04937954b2f8dbd3291972b399d6f149e609d451e93735c249eca73b3fad90033a0e849894d96556c08b00a50d409d684af1b3e50ffc248753a400c2406e1366ce1d6463eda302f7d7a64aae40ea0a11aa3876d642ac4e3c2f87349c471d0defebd5f5cdf1d3d25c4d01766606b9dc12e222070aead0941fd14b3a01ec2f257ffb319251c94a975d1e920a49132fbe3455198c30723f38e42796206a4f6eb7a1fd5b203a3f85a2bb21eb45b39f7e08a2c32bb5a806d8a23f19c06a85a661a4bd212164500421914712144d255dc9c89bc87d30b373a7116199ae6c9a5cde83b00d17d7efc012acf6a5d7ff8aff9b1ae81f92866327714c1010bac495ccfd6bed30f187832990978339329473542582c65753714d68e5ffe1f8d3c46f3887efa8ea49571772285d11a3a37030c665296b6400574c83b28d70a615edb07e23ea06d76db9bde43fbd4d1d9e2ebcee36420bb599edd01c1468b2cc0c8bb288b499dab76c49557f895918b7a7b616deb397e5751c6d13acfaf3cfa85b3d79a09198df2849122ab9f6a6012aae15f7cff99f499754335a4527c3e603de02ec72f7320b69e10e42a4f3ad0d331210c2dde48d2ac2f0f3d8c69ebda64a326ac4dd26105a7c9257d2e5f0c723bf0011ccc24267273677181b11c4506931556995dd52b5a8b312ad16d63cb162b9cee595fc310169641f6695b1f13330b8a004981978aa699b4f119e00633fe481ec8fcca53e5e46de2c85434179912fe118dfa2c4c2c0ad8816edbb0e16c77657659ae2acbb8ff3dd7a5c7e3148acaefc22523c495e3360cafddc79b71a5656139b8edec6c280a5b87b2efc196a5f95a948822d6282b76aa987c666d18823fa8d8cc03be88e69bb987e23c4c2b731b2393080b10a904489c7dd9e7b73147f3ed801bff0288f878d1ad178b86f02a9c0ac38c523a7d7dbb8b7a2e7bcdf9b83cd49390a852809a40946aac2f8d15caa3ce3f01a5c6f625a906f41f3a46d3dbacd6a3a5178f4549ef9f1f26548fb5168141a52bcb59bf30113330fede8c30984a3bd74b24c1d8cbf19edc55a08ba05d3b8e8602c80422ef3d8d6b3184b1011f0e11ac9168c2bdebe51e7ded8599cf382661bc562942620549bb62a2fcaf8d071876834791ef3204d81d6e0823245c31ea48c55a3fffe745e966b30c7c30a5ee7e159127397150a4cf0ce6fb1e323aa7b07186763ff43a83d097d416c53f784fe500920b5c9a28acd8c48516a4922f8ffcf1049c30b44a8533779459e47810909aec0f28353b0f866dfa4ea544526f07e57448f454cd9a7bc0d1ec579b1100ecd8cf058236147c5e9678a528320a71499a6078d854cdbbbfda77f478f7b00b66ca7710499bcf87f4b7d24c0e2485e98b1d326a6dab6c8912c38aaa409541047529f1a883a3157e05860c30b243415e54d0d6c99719bf65162102a50389be62c0c632ce9db675fc82aae781da598b5f59f2b7a305bdfaf56945a6cf6089ea74da72100179e5d468a32a4d57e98329b7f81d913746c8b62e2e7d582082d51798855e91b5ebf4bcb8221846d3dd5e66062a2d2eacdf1174ac07de7ef79a807a58835025569e8170eacd11cc1600af0e505ce33ae5215c024b5106844e73e26f6e28aa7162c109b0c1d2bcbd9856d22a35221e47c0e561ac4d0ebf0dd349d3d236f1e79b99e6e00deb137da0bba86aa570381840f871b5cf95afec39fb9f51da671ea4f1def7f31d32f673cc8a6461e333b19ec91ba1159971a32f547a8bb990136111992e03f81fba4425828d377996ed9c976cc96d76c6133616d965584b1ca269b77fc57f7482445cc4d48b15c58d72dae3c6ee79892756cbdb579bf56566433260e9051a8d6ab754f51edc2c82fd47273bd8c28e89d25dea9e07c4ce0cf9cccc35c08065dabecf3cf3740f3fe1f66f631b30e06b5b5c4ca3639507a54b6425092d0d85a6fb7a4bf787588fd2f3d941824050f0b88631497dcfcf4f9855d65138221a3311e5620323c3c6b6e984a8f9225972fb257537f95d29b79fe0f1499f30c0d73e1fdadd2bf429e8200886d0d75818c9c2d4e6cc8b2fc5371a549baf94121c8369152adf3e16cd55d60466535f0ac1e1c87afd57ea3aee0564ee3e142a8fedb8ce75c248cd818eb8f6a8b68ee8dc37d45d45a3d56bd461489e161e524cebcdb63633d5a12f97cfc5a0f5defc8ce2c6e193e0d0a0ebb6124d043cb59f3682b6c8b347a4afa1779f8de07b766a4c19f849f7d20c7c6434db6ec021f2a1e0b69b4be7d452181006b6d03de2681e49444353ea5c8ef634c6eff33bab11d7c2fbfa9d567bfa816be9ed42ac36e9c4662744fc675658349c8c276b1c8a5191b66542bbffcd70d9046d1bf8e07120e16ccc8aebe816f5dd8f69f5246cba4f3f5d4601faac1cbbeeed280ec1e24fae8e08632bd67836b287f79384477dbc49d68cbfa634a05372","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
