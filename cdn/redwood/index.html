<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19cd953af1164fdfa0c3e9f9c1bf0ade30c15f478e779c5ca27b303e2e07aaff5cf3a809696e0068adbc7e569979192cd056b97de97ed94e994ccf73e87e699c6edf6ee0c095ea4376c3aec67e97676ee80d0c8a9801e9b08372924e7e8a457b9e3b92e75d749d4488e964e31a574fec89efd16086adf0e064f60b41b8e0360bca955440d845f4ae21e100612eab14eef74caaa166689dc89cb4b5afd0255b98bb394ca82d2ed4366a429a67607ae204fe16b133028bc144fee09ad9f78dda7ce6158e455ac816ed8acf89518ffc37fcfd833555d6d8329c3c6f1f3a44d5746635b54f91f4fe08956d6049adffc212692b588dcc800dc249da2ab58f505c77f03b99c45e297921f7ecdc151e3548329928ae48a56941b60725b5abbd5d03e49d0ef6b4667f9ca32b9b802ef0b30fe56d9c1a19323df9f90d6e817ebc2a83a694bd5d4df3a5723e26d27f8b9d7f76a579891a39bfc35e9fbec00c67372139b6703c294906fe66c1fe60f24268cc0bac7a2b0026974288eb68219dfaa7428a74d54860e1646941b561b66481dfc178b81f6ce22c42ea80c8d94bac1b962dc7e199bdb0c8c78b0af02a5879edd6e4fc35a0ddbd43b2eb01ab663ee1c6ad981084dd8638d3e7cd14a5b03283bb2a3e28489a877476feb4bec11cc68aae8ab7d5fadfc048e0478bb79a410c1267ff0af869e5bf1b981104e75428225f05d924e3c0704bf69c7b7ea8ef0fb020ca46837be8bd0de3ed162976d696b82c2e5d97f7db5e5d40777356e61baf72d3ee9c47e167a2c453e1a0c06e75a3665e8dc93b1e3d619c30418fe2ca93375c29555b1ae22c7616dadf025a083b2edf34b8c0ef37f56019389774103d6c989d9849d77da96e11ce2961d73c583cd13f8ee9f3ba572aacb9f1e7075cc7c5dbaf7c61400e47e061487967f37fd81c1e055504d0654bdcd51fdbfd50c7bf0b330aa216fffcb3caf7a0ee1daa666c82bf0be4b74ac353fa9c203eaa307c6e1f5b903a9ab1bac180d0248c5f4b3d9c3d2bd31c7824f0dc128a7f4e5f5e8dc6f07e739f6f5b19e29a3181463795c28101f15e5f8ae283f940a71644274e8d6b929d89c04c6a04753237bfd529bdd119346c6e7a3cdac044d49ff0614ad10409f614234eb0a9b4750beeb789e6c84b2480c236edc1503b87c997c4e4f6d171088a5209bcecf9e03edc8db88a43d7b8b9ae5d4ee1e33274e4b23631d5765e7600f938342eaf54ef733c404033fd4bcb0f2abac7962609f9882afa9bfb06f9974b09c935f8490b0470432fc69623b709e1ab20a806e0e23b78754d77fe4521e3874281a824bd0ee25d7d37e3bdeb57c36be2a025d8f81d19559b87c2223b1c63cce7a1c694a52ed3554dbce28f713a83810b2298290f7722c9f40248296b5ee65b2c12befd77f91879740cc831048177fb0d5f5b48d082514e3c96861d91c7e84e030796b95d1d3482e5e9e66230b2fe6498d1ba0a5535c8a13411957146076f00a59a86183850575c4419ff1d560ba10344f2049b73b4f006a095fa7745c86212fe82e0f7d6482b0226f1ba9b04724560cfb94bd7da519e23ff5bd235accbb5eaefe5f04f19993ff0f895b20dc41eadfa44dd743c99180e8623f3283fa359ce738b09eb29149af67bdb3b93a02866cf2e35e5f5e9406c672666866011e8a201de30ce220f6d72bc63c39ea66f4cbf0aabd73250f38a2f9cda4d2b0b323077ce3670cf8d48c5f0992a7b1825773b04ed6a6262244bfd2107df65ff7d73290ec99f9fb482d7c51ea944ab956dd56fae92a211b539f5b391d53d74878a68e4e0517a878f1f2e862db2dd9a2d61bbebed6572d28485a349718ba080bc0a1e96627582a55de91ef6328981c39cdde411cd91ffc6dea05c50afa54c627db32265e96fd72dd1b8c56e6675f86cbe1c5c8f0c6be8ed451612543aaf1a6b1c1f4e6b171d5853392c3c55c180c2d29423edc70b8a36a0841a57c767e4b04748aceb2d3dd898e4a46cafba3911861b3a94e88ae26a5083f08a9e752caf5cfe29afd87b7cc7a10281c0d66ae38209a527f6aa363d866ecbcdee5ed9582958aad65a4e9cd17eef3bbe14cc5d59dd266f393b1081a2b6b38a63c9fd8423c83f9264b05c2bc67bc4a05782b8e03fd697fa157c2bfaa62303b3859772217d4b0c0007b2798d137af2093f3b3b71f75e7c0d4783815438905c7e85611808f5b7a3c489094c57cfbbd0fe66cec355f83fadfc7b2c42ca786220032b99c1c7831204e4666bc048e2f9a5b65fb5d85a9673ca146b81ec273a48d7a248fd6230343fad68fe395fa86c1bdb80344c31bbea67763a8b8bd1bedd39b9d563c27f34ed7c555f329c6f76151a5c8c6c78027340a9c2cd0414b5ca218e1576f44d790d4b36e69a8cc8557e146f3cbb18878461b01c976e6eaccb280010928594978e290e6c5df19195ebed6eb801908543e4bad4ca19aa40ff1fa9ca3addce143ab734a75092229db228c033095f0f8767d7b2148972222f5df0453084ab4a570cde5e527d47e5e8ec8b2075177b11050b91def6b936285b8f1b4f0cd3841ae9ab1214cdcdc32ddf1598dc19bd1050fe2112932534286934c6bdb179b74adafb7ad0e29202400465a828373ff707f726c784480d1da3f4f6a77b24432c929bd2af22f10b2938646bdba05e8243866a566c1006ff041f525de7b77b5ab9ccaa02923fa782ca7619039172ae0cef04086ccadbeeb86855b0eb6537dc99c977a32c86d961c3d94c1e2511e45508f623a7516b0414aa78f093d2310f54ffde118275ddfdbd11af2650642f19019a91417e5c6c8c4c4cad0b3aa03a59798cc843864f120372b684da3c2fe0fca5d2d66b93da6486f97225a71c275e9e84683d58c2dac56cbcba1217160c4b9182bac66a98e820a1cdf675edf7e3ef1a2848506cb0426b0548325ff058d4483d58dd9136b62476b579f8ca09a5200d0f0144ebded23952e77bd24166f393556d41df526d79971d3ebf8abb5605931ba9685aeb1353360ea09ca49387474102a3ddc028b6e9f9b013922fca3877f586d6f6b32551d432947c975c61912938a2dc396e4280903478c9c98ec11a4efc51a38e426727b7cfbb0222c3350b671e115ed965b8788a42ed32fb167005817a7c33737b2542d28e0a116ab86a37df0921a9cdecbae28eb14491fedce4a1c5d21ea2400d49e7648c71e9909e712fee1b89c23ac78d540d985e395776fda3b91f436f5e84eb0add4689757e59a3504e1628d00c9ce83b49fc96cf349ed410c02bd3f2492d97a7d03e1f4d4d0837532e9c71e71b00793eb02980224cc61543523d0e97135b3599d427a0523a96624c1ecba86e082c7be92cb40ca506ec6096574a0f5f9004b2fdfd6cb42acc007ee3196371eb598c9093aa2f520fa723108cc9a7cf0a84b9b64c0ac3ad4415b8c0d0ed470e35f9b012bd53c817f0671318a105b21c255650abc5b981232dcea58a952671db58c5ee1b94503dfd0ba48f0eee8c734816b00e6ad839d2b46e106e5f6387aa2b80852674dce78e36f4df11c75377e712c2429e424b5ae2e9b182bafa81a66e10e4df034a068c09927967ce6f2f16708a5b7830bb25f5e14f417402d560e15a700eba1c6f71989a1c58d3381be01c0087bd5ec03c0518eadb3eeda03ce2f1626a4f787a902649ef74084a675dde695f505bf0d4eb710a42eddc8c9b3aa68bd06f009cb5acdb6bf81066e34aed54f600a734e392f0880595b970397edd5fccaf8808dc561c782e5e5e7b6ca7b4333dacbfff1201987e4eb7c5626b29953282c9bc6aa1757e308ba7d6c311b074722d219be29b862eeac236f18fec84abbf09250c60ca389ae50905db617cccef5b3afd1b99e28fa1b36a8ca0e6006c1d0bc46052435519b1a45a8b20589ad5d32ef70293b6f7622ab4ef43e56945d7179ffe45b3139579bb0d3d349c468a365fd29fe01ba083c09afcc3773c55b89722ef43561aefd0264a31cfd42f03a5474561fb75bbcbdcb8e91bb11331884b737bdd4b125fca6ac2767166f38a77660c1d8e2f189c38fc7261d963002d6122f6ff3f752715a73e3c4c89c52aaa086b7aeb73cb45c3e30898621a31aae0db5d80a023259b74bc19f386374d2dfde0c9bfff9c56c4b8e478b1a2f4a3b48dc6d6f99c69a62ebc589e94760f2796cd1f8f3d489636a0525c20eba030b51ccc3e79ad875266dc62e136a04141e85f0d501ef81c290dd133f3e4c74f6bc4cb038ce6a8f199b779f6981adf7891552cb7d3479365385d6f21cb1451d516a35434fcd08d12889d95bce5bc63ac96df9d69d0fc27d8a85601c813fe9be0fa964d57c5c3d0c8269501e2a94c8e9f78159b9ab55ccd33ffa770741616d5376271d2b4f179081f97c60c87bae3185558750544c3ca0db9ddb6f2e70acb060d192be6810f88d56af438ae3cd0396d09c9cb05c6657accac1f1cc331b681d38b734284c058c3101f38d80036e18093003f13b7566ba1263ecad7b5a0b91fd9a500d78a1df37ca1d2d3aef93003b04156bc228213a0a8997c5b01ba5e646c8b5dd4234ccb9be758b00659a837c11cdcd83fd6de052689423c148fe431766a6f7b5dd6ecb1e075b3c70d05023132e4a051170559682e2662258c224c5f2df3394504bcba7a65ea133be6b3bd8e556ec34a0a14abce25d4a4309fa18ae3846b027de739dd879b64da21debf455393706f57c23808b959d3ed90b55e82f3bc31a6b39ec167a6034a415960bb058eec08fa9d3e376f4bad7f2bee791cfb92153182d5d934e889826447408be2e346836b901ad81ed2a8ddf608d11c56837aa59e2bc6ffe84e3e89ccf7627a2f6d277ce6891ffc8476c11ebddcad82d4da89f6ca535b56d0135796701c089fc5e9531991eedd8b590b3250f9af47c015438899986339a3dcd0dc85a3888ed193db24c7e2f9289756bd4175fd5472e79e13414df66d53671d258596343e322774a6ab1e88be05f2d54caafc8c95838335cbfb27d06d11dda366c9ff766a8879217db860a7219fa804bcd30b389442a9197c52ad3f18c03336ba7023a69f8b6d01343dec6123f4b23d9d41e6659c78c2b03b2f4cad11b60bfa463bd5758b93b13bc12b0ee126de867f061461c87109ae3ee57c92758b92e53faf54dafad43006173ab3b0495469cdd5d7257eff8624bc54aebea68d0a0f48c11c9174d916c98a6d945e2f2c7fc6a5d1c45d8523c16552ff16b6560dd88756b4bbf59a1b1390605710367831bda64843ade1824e04508f686dcf6abe1abc42b6a4ce4578a05dbcc0acb842c7ad2978f1974eda558528f0e8f3f7f167614a6d3fb60b3828d7e190fba7fcf462ba417ee9f845692d512e35564fc3613043a6ccba0cfeab91e645d5cfb5d27090ae1c5ac78e48cfc9cfe996441079d58048caa033f0143e86887dec9dfaf5d64bb478c81e65138a347fcc4bd0bfd95a1ce0eb1ead6f5021fe9dcaf3ef6a4c21b55abd6427b6e155c418715a9cf13bc424eac2648b120a226f5e8daa7d83d0a98a3da41b8a03f4d7286ac11005c09ca9c7ac6029309b7449be5686807dc19190d46e4a99184b884128cbf4e9ee7f9cb7ea619c6ef134c1391925e80232a6921090b2f72629f47fbd882efef56b8fa455806fe0ec7dc1214cf452c84f25b435523a96635c7331255645d69a019758ed15632f2046457bd1d6b0f72229507aa0e906cb8f39ab0580fc538c2e7a35b421e8f9248f068f705c8b6734211a9736ce2a113739a95c47cd4d4cebca4ba9d5d44c9e5b977dc5b65afc67498db50f73a9033833826d8d45eaae53dac2f00027f0f7ef7feecbd0b38a3a2e0b8aac08ebe110d444aed7c75f4bb156251f40f4070bb4e683c7def50d0b372f95e1c780e09a3b42154860eb77f0708fdd2e8ca90e1eaad9129dc30f48b7683c0b7c34cf67aca6032408aa3c5306e1e2bf123167102aa79de8b588537c26a89c7481fbc9ccb5ecb31c087f9451ff0ea8d6f9f7585011c6fecbdbc1a6555fdca5406abedd39715ff61d4d6b3692ddd55fbce276aef9159aef75b14fc116c1bd32d64318f795a90921f62013a894f043065ee2c2dbefbe2b87ae61fd178a65d57bd5d31a1ce0b61d78b7231591c7911181c5967ea57cbc86d1137fd2f9a0fdddf99e4b51339448cdbda01a4940f8b475a460249b93656a812d94ca07ae74b461d9a6be6383fb9b4194d318819f00e5c3d91d6dd8784a605d65906679dbad6cd528eac78526b00058ee5fa4f54b33d8cccbf47c737ed40fa510505e2e0c6c9e0cf504c01a0f9e59ae149489087e3a47cee649da2eef2e5b8ab55ccd67af8525a3271d7c837c08bdc6cfaa7b8205a884a40283d941a2da45a6ff4036ed76053234f276589c6924291e05ae53ba9cdadddf9aef25dbb7367690b9a12460e039a248a6b00a2ccdfb947610a12db1c6c02485ca0a564c3baf759b7199f82bda9f366ecb3b5f13cf0e572e201acde6aa13d9684f47a21e015dae49e97d304acd71b3d039e9b01aa34f807269fcc8562d93156b2a3fbe391a1633fd00aadfa5953645e58a4cac0e8017f639fb855cffdfb7653617ead4f3384c277c3180049f959896f2f148eacf5446d2e766138c7d0282a2f55b309c2af616d25be7dbdea2161073e964176f03caaafcc9a797a82df20392304cf125ca132b7db85a7006dbbf2f9ac22077a3b89718783b2a86d68b638f276a8fb27ba098743c603ce70c7ff21d9172984093033c53049ec43bfd1683198589c48c949bb0665c78494e6c4c9a8c6819cb3358e2c91023b9e523e1abc9bb8e67d2c828096c61cf68e962b0ae5ce5e1fde46dc5df8c28d3eb15ff50111e69dab174797321f6c83cc1421e7f7d4bb2040bccce9bba39951fae4c53006a669d5d9b237efbfd415b3ff91c4d4dd29a060bd0c809e4b6bfcfcc49d93b7452c65db9d8a9856cdc7dd06465fc8687dc6134e2ff8ca6e96e394c112fff4347f0e0d3bac246109c8f07605317fd9d446e8a95b6ff56b095c957fe95c3c0420b1efeee571a450fc2d2bf8130dcfae32ba2bec48cb7650c785c31330d3463790db63896788050246cc55d3d254785fce218589eafa25e761d1fc9d4bafe9ac71a1e4eaddbd033af7ecf70b74889d644b7c6aa9fe725e2dbcc7850fc566014424f488a5c47f7a5b818f5a38223b8e771d18a869e95bfb1829e82fbfd076e0ebbb873824b90e98a892bebbbb4ee379af537946ac6cd79dee284342af87b6e8db94e1e7dd300f5d718bf6f0b75783f58f47580f46ed919c46860f2f6c7814dd02688e21fe71e3c26493ccb4418b829b9f07a767ed7b289ac5dca3b370df6d4a0d34aa5f3beadc08cf149717f7c6beb4d4d269702411d365e69cf3af8c01ad0d212aaa8d711584d2a520ef92f17eee6b0f23d8dc9a0fa8bb743e9ff7b82fd828b0fc1d710a0fbb3b1e8256612f9bf21a45768b2408aff6c47b34d4e00a888dbadaffe56323bc81673ff6483e25a833db6480067891cfa567487ffb0343fc410de2e5a072d0bad53ac2cfe68755b613357058eeb1383b96a59631577764a35f4a33f22dbf5ebe231067837381fe367c9bb4e6d72d73c3d401ba6f723a064ad4758a12079ba4a5518e0c1150c8dc462f24346ea8088ca47c669a181ff67e31203ea87b1ac9d26e850fb358864f7f053faa091437fe51d9d931e3946ecdcb9ebae069af694fac80d4f0517454797cf991316a6ab686563f3cfc647f3e75f9acd322d370116cf0329098ec32b83561ed411ca36a4f34d42f7fc9efc6ceacfa4fbfa5a1eadf93775ee9d5bee6017edffa36d04134fe7b168cfef3d4420998f4c02944f77c57b3cec03b1714a3b041e635ed4f496767b6e1f2acf532e0df0457ff50c8e5bc371527f5967306797e9b70de64e49a2e06ea9ad9ff8e79d6a57be35d596c6bf61b0075dd3966336b241d3f3f8773a976d20f29bbf79820435d8e77f05ebe824f8fd1fa72e07f88ff685dd7f4b61c87c418c5dff3359d211c6dae57d6e222c115951f038b23fbcc24b2b2185aa7c024cedc701f8fbd4d1d1aef3c819e4bc370eed006d2638db1addda23628b053920a34f73bca1d2785c0b133629efd9cd508a18165c55054b24fd821678d6d031cd2c4a175d67356d96a51767c33a4397c6d4810e21ad2e5a1225476327d9433a3a336e38eccabe8b5fcb611b80a02a47cf8f5f46d1c4de6d4be4470fab19f2e1fff3719d329f980f58ee1f98b6611da3fcc1f0fdc01334d992748b3853f5c8141f1c7d3fdeba270e103e7b9cdd1c92b86924dae049d41e2d504d3a8705c92e0195ab9c32f8e7080ee81723f0fc3b2ab945cbd71571a60261d13cb9f44787c763cd567a3ce7dd3670603a4d9dc707824cb5746e503fad4f43edeefddd0b141ca3b2a6375ce287b2f241fbb0a6c5ccd02d9e2bb83b2592144fc476ba4de1e16ed356d2272a09e1f2e4390369c0ee8d9e7a75f6d81140fc30a11ae7a41b93a4e39ca1f77d871fad67408ccf1962d3e9ba5b796908cf8b1a00aff9f2abfc30b1891f2a2caf0831a03015b783d49e5e82d339f00ece2865125f30ec24e1fdbb1f80d3deb12694d1d8505cbdae509d82e8493c75e4c1233f2774ed41c304292d5f5651e39924691b6d12171c0a890165636ecf12161995da5d62afdc49e74a39f957ac8a92667573dca0ff32bd6a78da7788f5dfbacf48d147d602a1948db24d02a4595a9378c0137f8e91f629d2fbcc676b41221648705c882117b588243e509c2768e23fb2029eed7cb0b5b4b1b3ef7d3c674c908f4f17e3940b7f1e75d2c0e5c33f8b43ca329589ab831a0b3f97a06227b860e6232150ed5e18d7e82cb62bbf7bf3a48b9e9aefb5088700ba8fb2c06db0272053ac175a9a22f6d927a0a471bf7ca1cdccb6d91c7e7380bad9593ce3e39ef72e81dfbaa88f8c119dfc88154581fe6d5112c59ba47ed21a89cd110d81273d62a56160fe0f29001952c4964452c4e60609002dea5d164b870713e0e69e8a3513e8dc397b03157bfe080318ff7a4e7d28578e4b9562eadacfb4da7bf24db71df886903aecc42b39f8bcb9475c62a014042d1d0d367086bf28a44ae1b4de29001714c60685d64ed9a250d0d3efdddb6f4a2f6363d56ce7e7915046661c6ea4bc422507321156849b465fe06e275973fc0653750f7ec1cb128159a3217843d27f74bd33ba721f5c3eed6ac6b2400a11350af3bc934de5e7597f5f2378f9f4144a136c93e9dce5160409146812b761dddfd9112539ff184a7658d592929a640c9e7004b48db40db5ba069ecc3986b3595fba9c284c76f4efbba3a9ddb07c04eb0d0ff2cb5dcafd4e20b6ef1a20b8256a7e84690d1694d2ff5b63a40d9c8bba938f264a0b7b45be90f2aeee705a6865434033894867032cadf18e677ef348219d0ee5440a716ef45eee75fbdba5c7d8bb5988e4acfb61a0279b94faab74023e20e81696e26954f8e0fdfbb4f9fad7b7ffde9007bd0ca0581108cf1c71e640f292c141b3b1a2ab454d04176aff0d548a6a925939b3b441aff8a6707e7f9beaec58661b00dde80b94b13732f90073a7ae80ee21b40c65c623f1b9d991dfd1862f19d3d6ef38a4c67b215a2ca19d354816fc54fd5079332fcfd34cacf77e5c120a5f4c3a2e656197ac7f87c414fbc90dd6ffebdbcdb287f875855c337d59216d879e3b8469a3eafbfea6211ed093f41a574e7ec2c7e97ab47ffab0de3c44ce8634b32af776baa9a33a2c594b4e8d8437fdb73cf69a65c2be3a5ab8e1961a295d4578929041339cb798b74d73317b7828bbe6a4e2f28bd0e6cb047120c4e21fbe2cf82f972ad3e7831371128feb19f52022145fe70c376ff30c682fe947745a6f2f9f76ef338fd01366f7859c710a47daf8407df05f2e14e023c724d03c9de5ac37814631456e15812f407b45defaaacfd4a2a14b5b1f13358fc7fce86c81353e09ea04ce1e52a5aea3522c649f45ab0ff5f48766d39f9d48abdecdb4e1dbb83e9e08285022c7ca319f2b81c6989173ec69197183f43de467e9b08441ed82f3d8387452ee1cd840eb322cc0c609cead6c0a0cec75ed48254f315f6bbc5d1db29c68b7500149e4b91cdef20bde2bdab5c378eb2ee2662a3df9705cd968ef6c1e048890abf79bf64a70da6560a34ff2fa9d022f140e92f5b1ac8c77008af9e63847bfb4c567d967c87d27f23ba24b82e196df6826f90b9aaa4122e676ad3014dcf242eb32368e4a683809d912082eb54ce929bdf12f0e99dd5bf10dbe6a47eda6cd75aa871cb8d2bea916ab59f6038e8bf81b106fea64dde65a62ed4f577a17c5cde529dfc53b23ab7c31bcfa032c63bddfab77bc8f5f99e0c3efb3254638960e54cd0edb7374ba4651cf8be5f45a4c209154c7485727195ea76a376d2891ed02e6eba82748b88cd89086909f65be7f52ce7fea307c4621ab46dc8a3e6b5ebb8b214b75ec1caba6a6546ae70b2eac57198fe78e135292a259494a1d5929820b0f22b79367b0473872a2b0f6a843e1c01c9184437199530ab21367026066175eb1c6cc2d42c2bab558faa2911ea23d4d50d53a8386405d29b8abf6b66bdec13315917541e09f16f770410fb265cbfcdac737e06e8b6189e4a946f2208ac203f23844b52e4fec772644f3493b2f2beac2f3c36d0745d83654e419a43c0469907602293e2db1ecf3602ba0a2516b8a5f4e2d05500473c49e108cb9bbf7650f4425dcef7891e72581e53943901f561c6b2da0040cf168ef345987d2557a3469c4cf433f8f306a18a94ef2ee92322ebb05c22ac87916017b3ee706a1532e441d5ab5dd45368f19f50e930667b086899931aa678880fe192d8a5535f9e2766cca697ec4b516dfa50fd513acd066a6fa85e23b006c6447f87d9c3d0f31e10e8cf78dbee6fc174f4aacec23c78eb235965fa0447239a71bbc7bada31046b859e4eef2595529fa877bde5a6c604e4309375a4295f5150f8f20de242044a7fb44e9827269e22552b07236f3b051c9aabdf5adfa0d76b4a6c10fa0c673bc09bafd81ea3d1eb49a74eb5ecd8bc285bacd496e1b0f3d833b321146d083042bace42f710dfecf7a61ebb92c73832be6c9b7711e61c18752210e5d24b0e143622cb63afeeb7f7536ac3ca887a2a15f697d4ddd2f84d18e34fcc25f94927f386742b1b65655a165b92536e05676184aad712696eb38ad422807e22be321d581e50c2974d3cb477970060addb7e54f02affdfc1ba666709e24d3ddeb531349c8683f70458604f9f039c4fe0d06bbf1550be13aa3260fd62779c2689e0945f9f728b4e0f7d2c27c8e7a16d6cf0d1429bae5fff8cb7e2685ef2b761ae6bf2db7d7a43507df45dc89386a2966be84eb9348e2c7b26a6ca1c98177841224bc1bd382dc8e4ebdcbe5a0b9994266a6fc0df9b8982e4c36eac484c4d994c207975f2956e5f7fdf15af53459e1f378a3b80514676f9a8fde3c6490fd09f830fbce6b95ba3c5747d49a57b0774c734e884f37d572659e0385b0a145bcd9ad9cd6c020f4d1eb0e7560ce2f7555f7c66985f9017edbdc7a06ec0f181a7a8e0c4e17011f331236dd937b1b8b8731b0653d89f3c548779b27528e747281677756f501f31efcda61b95727805c8d26e81a1226a3d1202da7602fd22219e96b8ed7a10cb18d99129cf3a850144663281b7720e3f0b8b747f4178e00a93abcc4800e2e9386515d94663fe17678eceb2a455222ef96cc07f3ecb7f19daf689472aadbd981e5629982ab6f5bff0592a3a9538be8d76c554341e04982f692901eef3221c2d92e5c18f1a52284a4c6c2519a150c05097525f5da567ce3958be5ef44d97d482ca9bbbe6a3e12cfc0835c2258a102b27907aea9c98d484088e8b84d68bc5e6d8d17028b1c78ef1b37786480c15d1eafc1a0c0eab7d0cb676f598d5831183d1d74606923491b4bde0948bc9a3f0299d564c3a1370cf92676744e153769d7d40781045ea84db3d192b5fd1af7b2399f38b79d98b229c87aead159e857158335dd514d228230a0e731c791870fc56dc00740ef0d329ebc46e1190183113ba0513f287983e9c795582d68ba6bddb72113d590c8d744176d6f79cdaa694c6ce02dd1f433f0596bded4e9a9ba16c873c81b1b84ae9999216da91ce332c087c5c4e6ad92c049da0a024bac62449a9d89f5a82432e634b50a82e5cdf80b3c63e16fca07ecba587c5bf813a168fdaa58544af7b8efe4121979827e9ffbcf2b9ad23f76ef66e8fe44a52fe81de6f6a6e8d6177fae52a8c10664f9842a8f79ccf9809a6bd8ad4db8ca45c486a9bafe7a0288c000b8ab56f88a30e91a16ce06086d3b42e750eb58ce1c2ee68d21c5728a9ab42bbf0758197ca338cfeba7cf38e1f73572581714f9b277d8f99cc21fef7194d59a46b5b45e72c6884b3e615c98d7313334248e598f5c7d5d1ced37728b835e79416e263bb649a85ea2461ee007a5902f6fd95c0de3f07c4c252f95e9232b05f636e4874e9853eebdb9743b78f06e90595861939b7f5b305b9501857c233f7ed7d629f6644f7237a6a7e99e627f1a4975cdc6980265ad14c8c6489fd86b3aad5bd911af4a8d3b91335dd81b0657b0a8905228fd4254ff7cabb3676d0f6c614895c4cc5988af7d2f349d4a99e984d6b34835661c09d6bebaee7f332f870d885cdfdd1fd786ad7958c301ee8de05de266934d10eb7827639f00fa3b4c96523a71f39fff746ad48fa2e1678b4c8db70bd882f74b171be1f9e2616329493def910bc185008697d2eadc4c75652a360f9fe58826b50cf749cbd8bd6b82ba8232655fece89222083a676283185c702a916695e42c45fc2e9e17a5a1ff1bff52dc25b3ef6157eb6d893266ed51b5b2bd641cab43fe00ca6b707374f772beca438e187ffc0dc3fa91f58f33ad1463d32dfc8ba6af48886d5bf0770aa2d5b7492212968101c38f5fb6657aa78a9f23d2ff2f6997b507206d5b269223d3a8717711d1703cb15dc62f14f807deda24f48faad8a74af8d7dbb4ed8cc6964f51da611f2423e7d6523dad1d5177a5ebc17695187199ca346786febe96b9e6b86d4643079f98d943da6ebee281eab2884ec3511e7cc9b4da84b87fe8df45a0864f5712ffc335f9343db2dc9d96472a5411b37b93ddd3b78d555bcf2b6441197934379705d869433a0b4a175ec70ac41ece1d2a9464a54066fdfe92cb6d8674694180f50290d44e0a36fc8e0f37154b7d71f90358f06a6b460ae2ab89a646a3d395d32452e8c3689ea783893b304aeaa694f6ddd82beb98cb0ea0b0c9300686e1961b88d30bd1a2915384cb00f414e333cc236b4bec2dabe1cf99f8fd4671628944676c348a33fe4e56d9f36e0335b4e9965756983eee0f7a28314e00c6d834a3344694ffc56fe0bc12280f028afdad2ae43fc6b89c55f1439a1ab7bc949cff0645279006f41be25939c092f80192b7f9a7685c63ca70adb60e42273ed215c20385e2e301b2404feddbe9f0a05b6e697c3c1a266587a0c2279b7de8fedd2eb1e9c20ecb2d6c8c307d4a174c8b82e4f1126aa9cab776d1b2ae3711fa7736ed6ec08daa205fb669e5988f80fbeb3bdf221ab5dda7cff09585f9fd06263ee87dacf17869a4dabd468e8253252074ed2d70927bdafb5f3f03fa538703151b6f092b7a95bf8b204fde6503fcc359d114b21f1ceeb31d73c5b8172898242fa8fdb59925b4ccfa81b77f1206c4ea7285254004f93c708353bd2e87d4883c9664fe7591983963732db35d6b3994efababab92be6f69c61bc83293d63316d2c6853c1ec9553716cea16408d716e0980108ba2a35e11361f7b136e938f3c066be67b7837f1839167d7b2e8337999f971b14e303d5eefaeacc14926481e855d0670c77e8aa6b717898885fb9128b2f19a5945d0336f88cbb9ee332348c77f805c4f8728e32cac604f61fab77c75d81869361725a1f3d9fc0ea9f98b15798255b9befccd7a2c3d30c08e34940b9bb08ddc0ac3a480bb2b9aac3a18a8f5c201041828289d8bb735a2cd841be6db7be97dccabdbc1281ffe30004072187287ee9e5b07f8c8afb3f6bcc84ec43a84d8a7dd1c485dc6c8e4615629af1743aad69bcd507d7afa93809733bcc9167fa949f04532350164373433f762a4aed4374a80eb6add1c360be5aa921a457c73aca4d4e32b1f0c289bce9ac7342a83d16e7b26bd102ff68b32712c2d1d895a9423974ebdcfe494c2a44655395fb32dbc17e4387b2529523a094a4c4801628933d1baf2fa481ad1b67c1bd343d05477f520687941703e04a68a2f4f4eedff5ef6b32721fbed0c44b67cdaa80cafc3c4efad5e36cb9610202d32ae83081617f5f4d75e074beb861c47c5502ee24a93e7fbe103bbb73460b2d53bcbac29c026497531afdc3d663fe655dfc97fd223487173341c94c7a7ea68bda7c5846e5ea3a7d17e4fedb46009e131e88682413f6a2d017367528c404dd76d5fd18643fa3d44fea8fa29832fa5e0620240a7845e71c9a62d2e45d19cad25724ffb7949be23fa11027af33d1ebf0e2632f66c26b8f0ac8148edc4b3416b699f9fa97de3bfd01e87447eaa4ab60114e3a67cf3b8aa31f66a8a37fbff95f90dbac1bb4621ee56445cbf1843f2fce151c875b7547b2052c424e96a181378a0c5718d7b0cec192d8be1149ed595ba2319e6e31163f9d70ab0252d90049074db35dd4ec211bd2761201f5491cb257cc652835e68ab1059fb9669a65b90de619af3449701b07af03882312a36a13379a953ac778b68e043fa64c10cbc1284b635975fa85b4ccc3be4b167cfdb5399171d160c8fa4019920a7a618573add60b9eb3b5b3e5c7cb4d6cce1fdbecf34bf4aa7ab79489d267530c7226a2273b33b6a0d57db22e3118fd9f01977aeb3036736fd1273650ea8d434f9bd0bf3c923654df5607b64c47c865b79f0053623c8d46ce3e77af093d9457832efadd876057c89e2fc305c78540d8e1820738416705fb6a67e25b72a891a188967378b2928dbeeaeb2bc6f4a481a22eb2b6fba1b9deb696b6ef7fe1b9d3081ae106e74d9c865749226fbb8a10beb9f5f8abe86b0480d9e17d5322a5fbe5dfdd299e08f64539321c6dd97a069391e9c058ed444168753e18007c84eea063f713043d85c67464e32a2a9dca50ca97a6f7295409c688ddc077830dc5cf0a95f939d2e31866fcfb27c04a96a6d02294aa4340e1b40788c619257082e2b837b08461d4585d63c95aacd53946a77cf3afb5046db267cb8036ba211a2ea14f0ca731d1d3322a8f7cda5d7f89f568e9bd9b35604a4ed615c60d792382957acfd28adb545a41b2a235edb4a6e347eb7f8dfed01c50a0edfa78f043be2b43e45fc794d00595e679b7ffcb241b27ccd13a8f716335efb4d5d802b054b82a88ff6ea15c1a22fd7b3cc51fbcecf4e4c9d156108ff6ac8aa470a25c124822b6a98b5c12b9aa55733fe6d72e45b5fee35e2e1bcee2fecf56b5939d94e7ba940deb778f9bbc40cc5c9dcd6355279f4978881b75ce19e4f9629f64b918ffa467ed755b3bce13b4198662ab0b5b2f34da0bfc3f8ad8b5da66f3fa01c60494ba10d91f5411f4bc0c3615850fa272401bf221c0807e41e9fbd68e84654871f9dddff39283cd97130271fb82fdafcaf4765836f48e4bc9008b5cf3b8f75d4f3cc9b6fb76a9358bf0c1227e3b351e43af0ab2a989b836872327324b43492ca06afd278f1533f46bb5ec3b0731c3b0eb4b741ab277ddb00e7f53004557c8415f7662813e402b850c52e501376f461ae96dcca4ae7c72a293db38f6d952a1d28930fe84d06829d867dbd66fc5ff15d659c60e8d812cdad0bf458caca50d374342c3a44f035987bd4109a4deabdc89167143d4f07098288b5236a6e91fea79705561c2b79b1142bb6ae3f5984d29ed0752c34ba3e6e24886fd80a1b677ff6f19b4517a61b37ee4ebd26362cb4b366ce832ae0f918e9d701c6da7d2eced6e5910a15fd7ff843b0c4ddf43740f7681b61ea8ec72c66ed61e3439d4549bef0fb4bf94416006299ef3843e3e0f08aa752f99f400fe792a6d2577deb0078a98d19e289dbeb6e7f0670c63f56189998a4ad189e89ff0a11602db6926d2f5dbb1a2442677be1be5541e66ec92efa3b92fecf2f4089f40c5a902394bc33c788702e05fe7441a0e3cc58eb5a3ecf1b7cbdc58aa2e78c5d7f9db91f2a11e2c8bd696c48ef1696c977806e2a44cdb33df5c994d31f1ccef6bb78e63175cbd3606a87f1c77d2c7d9c365f46447d73045fb94d1b7e97e2359aa6a1aa1acb300c95f3eb9d802f018096f39b109f808835b18c8bd7acb0e3bac24e58efc5a47bd73e79586c605be06d83f270938f26907286cf466ee8ec9392b49757a22c9f7bc185fdc4b06ae6e7431e56b6640c19a31d390c200571b32790afe2c9876fd4f02ff416b8980aa2ef74adec8aaeffa7a5d39e32cf295e8837f50dcc43d335eab0e9d6e15a995a7bf7442579903b4e0519cc74f9d3c6bcfb9068d67e02da2ed97aed7e9e12281c116d45ac9608a0f0fb9ee5d41098a4d032fbb04a736f4698fce57d1a5173df1d31921d636e127d13a6a1d975923d7cd03e4075a37f09c8a9f7a3fedb58e749dfd71bae40f6c4ba38c7126715d96c4dc2298b630f7249ec1078fe1d4c7fa1bc37209961d5ce30e99d73b8e7cf616ba5dc54530a867285e4841ea45d351bf9f67bd37ec6337ada87973c71affed798182cd7db84eba73c809921e7e276dd583c894669819b8d17f7175d2b0bf1fe2a5dcd7a78ea7c7d06bb62d655cf2ef31ceba9a09d5297c2850f2cc7e46f4b828269f011fbc219f663668df7441e155b4f0101b56d006010cbf5cf1bf11355cd4b92d31e609f8d6dd12013bb902c13a2fd51da07f3a1396516b789e44eba9c8383e0d7b2425467ea6570094ef1a15155238e5e8b91c6aea9e006d30950fb0b2b8e325332362fcae8c3fe738a1eff793b7626095e2a9ab952aab3fccc4c74d41da154b04e257cd867626d753f6c7b8ec1496624c92b2fc168cd2cbf8581298564529ead843fd52b30fa6ce68a2fed3f1b6818bb3fc6beac752a8c86e8c42679d74d0d76182c638f4e87325ec435c23b659ee45e7c2c9a5b4f619fdb29e7e1962e355f7bd4c4cdb6b46475bc4cc5f0e7308eded199a945119d8b331910c525909af0c973e7e8753e94e8bfab1157e4528e38e53fde92e5a47f7a12ea5617d3498c394bd07455e8c4f851eb61982838f0dce959477b92ba2d727c69110ae18bf6b8a5b5f3af3f93ca46c6895145d6b55bc637138e9ec04401897619624e012f7395ee1981d57bca88cf569be5152743042694f4ce96db6311fb0d82126309e2182e3ab9090b48ff63a586e06b6723af9aa625d8658c81bf748e8cff03bb33b7f55efb82e4921a0ced3a7d62cc472446d4087b6f3fabeaa208059dba8f89051a9fd0d3a6eab3d7d5c4b51fc08276ae1e7187c77e86e84444dac693d9959fb177596ee22766012a6a90f13be72a4db7613bd5db612a0b3d6c496e15fca0fb92a1ca46129c2b189b4282a4e5a06ff1b56b4ab68332e8cdb0ba5ef71696d5d3e3d1f13ddcf9283caafe9f3ae69430fbaa2aba46eab2e582b7217b6138dc079321f616f28b91d6868fd1ab46692d812cf6ff76b74d75ad3617b9ed2b1630d12826354907896c2a8afcc6b798557083bb8f813ea5554d0e38516b3c1d8228f64c08ee825cab58e86c561cde42cadfebdc8b5e8c57493d61de903ae55acfbdbef467d84b5f9eef16f0a11d0366cd75837b8c09ce3687982f3599ae9d51d0cfb4189ddab8fa1fb331388cb78e268bd73982bb5cc6dec7232135ec5b3601763c853ecf9f9ebe02176dcd2946bcb9f86f4d447ee9ac8ac4205f542e57634e5e9dd0e897ae628a60f79d4b1a2c84d8cdf039bda7e89ae1a38e1e5d4f52d64349492c4a682ce374b74e5bf88aedc0b99e513d2370513efeb261d29330eba16a1dbd8c8ab55be435f06c23e70aaa89f8917e30f5df3864806f47dff024a8574f1a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
