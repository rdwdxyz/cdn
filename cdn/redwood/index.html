<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4db53a4e5ffab3803a65c55cbc3e98fa0aa8ba839d1111e0950d4c287f577c22fcc7176850a7e2286a55e0d22cab819c777899cdd9f59dd12d8889c75e324ce0bfa21dba8e1bbe9e7f5081a5ef8c701f0917177f894bf7928295531384698fc9d8be52508885151a5200150430bef618a2dc3a25524d839d66bdddc941cfedb74558c0c41ecf7f7e0b58c429062b0133c69f592856440651ee45316143abd324be603652ab3b142b00acad319054d086ee187ceae81682e3814aed2d0f74c383505226c7f2a0382602223452ba554e0397dcf07cdca00d937489c4df95805d5dd5b387295cf16e2eb576cf662af091d1e4e08d18610c49252b4ca69e287778549cecfef3d6f0975e4c6dcd69441fe891aba0ab4bcb1b06227c8ff5bf325461891e4bee662b50f42896d4cbfb0502a169f797e9d139fa178d3bf9558f63479d8588557188e8d8610755686e35411e5484fe2d223c3d26b9eeb679ac6c0cc741ba4841af7971b55322c06ba6fa4e32fe7b3f958512148cf1078fd1e6fdc449666d69a90184f8c4a5dc307bba96a1aa64c6837fbac03300c020622ceae754d1bc8bc2c2a86dd3ad109b5900cd81ace486929c92a24c7991cf9115928d3021ac02401be4e3f2d3babc160681b90115aeedb1d577e8df56b94c43db477988b4e2d7dd0abccc5c5268a0c74eb5299bfb86f291c96cff41e15e421d68a23459415202176d3f5ee06fc0bb5d2a853caddd7d29f861f88232a8fcb03938e70e5b237752f822da718af5c7a36513c7cae517b39b81016b1e126047e924a5b899b0bde1d9acf1e6c33c7f204e91d3c647b74f3a3448838e1ec0139ea3b05ef548f02dd0c29dcdd5393e88ebdb66a28275706f51bec15212eddb7e22fafecd1340ee7cc2df48e831d686a19805e79a1850d31829729383d5071560cfa62ee1b3f555a3fc4006c2cae701559addc37b063a0cbd11a40d61463a0a6f2fdec20b732b03712850077add8619702e8aa6f6be65dd88288f1ed9552f9230f296f1e572f8b10868cb3b2e0212740c29e5e37c683527c23432b43e09e2110144845a151835b4c5857b2aefe0966537b36e8fa7833fffb9ac80009f0d98ff7a5d4591ec3d54b4cf45572f7e355a8e546b0fcc04cd0920a6fe9e0f2d5750821bd86b795a9e7ef581505fb5e73e6e360209930523cc6c7ebd8698ce990d21bee3f1727a5826b0f84032b9a96e41e28e0ff1a86b6f4bc68a7fc9bf22e02fc1b6690d4c06c32f4306e5e7e8451e6307cc5ea9457e41a3f3df214eb13e0cc1ab32add6381e53f789eca409cbe68fdb3f399d1645d87b90162a847b5dd078019feb569e6f6b0ab5af4bce0388c511fb64c18c26c9f61338b498edc0a4354ff571bb8fca9677813ef573ae58977090eed3cc761809f2d194e0271218e4bef734f5a0e6dc968012532b1abeca64b764cf365c4a461a061d45b5b3ce32d546055e4c75d10517b1a44b8389e7e8bc4eeb867f71332f977432558c685fc9279e9241f29dd1a330f9d822b57f3d4cdab43615384cab957dbe1db6e0e5f5c60cad628a234c8cda1bb7d1f7d0dfa73360924c0ea60a7141db4e84e9424c0db3ee3ff6b7d0f3b7ac0dfdebd02c9421269235082a31a89ee787b50f34f24b9142d6269fe1b8a1a71486b1fd34fb5fa890c944f188f25c18e18fc16cf2748251bbc08fc098147c545314285744d75ae60b27ab360eb553559f089d881cebf261d6bbbc8b4680494ba7bd60aeec7cebdc1fb0badc69fc16f3f21d30fa4eacb0e5100cd5a5e6be70a68c1f7138ab9657c3ed940681780c35d07bc13c02d986eed18d5804a7df1ba0e21cdbb134fcdb2593e9e7def5f7fd734b61def674bb78f30b82c09b3ff804f065e048d7c0dc1e2870c653e55ff906a3d137d0f83046bcddeb09afe58338292fb28fe494908e1d1b04923d4068d8fee88b06b65bdb031310b77bf9bf401db97bfb7684584fad2176202348203c8cb02746dd97e758e5efbda2d1bcaa1ed08976c6ed059142020a11ad76e9a2e8f13c4fab20d9e3f5849ab00e73d12f5de0c67b75399492b9f7fd1aa604b8e1990a9faa086f2b14a6fd64173f5d3c6f01c0b7627f8fc8d82276cb45754a3b539481186137210274cd1714ea0b09f5210ff9cb1c59af521971115986384ea1e61f5afef300804c2f97674263acc4b3b3f0305ff9ad3bc3c3c0826334df533b8801c88b0fdc5dd9b255f0d527253ea2944d028665e05eb787e64fd70ba221d02639d9e3eef218dc8f9c61afd87d3d25b3a612a1f5d60c5274ca01b2562a61a6dc7d6f209acb3bfceebdc4cf2d7aca553901686bebdec4c709d597d2ea125d7eb34b5c158f92b91c770e88f8d192ff1690dea4457fa92c8d83402689a58de9e94111797d74f8f528c15a7a6b3b7a22f5b7ce5ce4ea31640dd96268709cdd700a54f793f3b40d4d7818d384a6c37f2f5ebe2e9f386410238f9c532d339ab100a0bf0e65d5d51cb69a76af1e1502694914993af03de2ea78d11dab9af5efb13adb06b5f016e6ebe9065fc4fd795a188453095620fb04d1b091fa0a13e28671eb716da70fc312c9463d21d9c8cd33c7bdf053b7f87b93aef5539d510f9d875e000a29e3f80d3e1ddc5c050e2fbb546eb9b1a75c13be2c18cffce75edb82d16d40b1ebbb401f3373a93f32f3ef328c2793376d3c76a6eb5daf09e40d42609c2d764f680419b4ba25ecb6df93958209610c3fe510afa34fc8f227121560514a6ddea6d68d2aafac9ec101ddeeca36444e57e3a57a605d7d0ae6dd88dc5153c5633160893c068b3fc3ab6b69d3af0a1b94e9c5d619e8fe3ac843aaa3e662cfbd7b2f694d74b8b6c4db8a61fc008c9056bf01400bb6e677405780c780d53e01206e4c53f4df9c0db3e90801323eb1011929d76c5fc53adb5929ea2fb98d8e19d157702347ac178ac7c5de349d9412844a63616e80158c278bcd86740f034200891e1dfd009204cbb6aeae0011a4948c36e38a0e75845f9650f63fe18ad0f3659664ec8f5cacb3245e2e46f8412863c8fd6348627a2fd0c216380af5e3b44172a8b3a94c511b08a149c6f94cb5c2d0e3510c5dc6290746ea7e5e64b72d8a146b30f80c934d389f81d1c647aabbe060ee159d58e7551db59633e55bd406aaaa2090d466cb6e8a07756a8df7a3e668c66072c7c09dfbbaff4b4c30acf5f69d4948a44ae63f58acbbe443e74507428855c174b671133b2b35968aacca1927f6630324b72488a12ac7d50abb998a569646fcaeaaff196ebcb7521d3cb90f812fe63591bf661f647580b82afb945bc9d38231cf2d9e03af6d82144016de7a0df84436de5df03a31781f3197ed6b597601c076ccf9ddcf107d612e67ffc485d1e73cde7b741d8abd803a9aab6ecaddf8db7a741a189d89879998bedba90c0072e52f79eed771143d85788f8ed5f5e8d0af6eb91940e38e7e5d7e0f9439484863c497eaa90a11b6a3e3dcfd4f660f367d9aeac064861edf46a34763160932c08728dbc87ce29891e09b41f2570fa05ccd34139762e5d8532bf7f8f9735b46531549b362c7564de84f19c1be4902b4b66330fd87bf6a5412045b6ce50ef9d7fd0c3f952e2d1f9e689df435e222f1ae410dc1ff35898ac279e962b301a98b256b3e767859a9a61e589a2083a81a001a8c8b038ccf4ff75aab3210bdb9e44d7922fadc3c7c9abb8773a3d5bb8aac7c8fdb21f421afaaa58b68e31eddf8e4d9ac2c4ecfc1bb8d898e4f8e0a7245a568bb36833d0fc94edc828d178a84c1d863de76ddc31f4881074def192cca6d73a9b346f87dccb1ea7ae3a21480b425d526e7fc5354f3b8a12a090a1e57e3431f516b3a53ea59640a0fe9b4c501f48d8c190133a2ae86372abc5ad5c27d9469b979082dce6bef973264fda024e8c80ff01eb96bc951f7346950f2a24f477b6e5b552e4c6da183762f1e8cdb3194b4f348d09176a5bcf89a49aa91af57a8020765e02c909453aefd987ead4c9827863b189a0b2c22ba19e0e2f167cdd6e2e5cbe649bcff20e995e6657fe4728a872caf3460a7558fd284b44911d1e8f0dc4364e20ab8f0aacddd0452ca072916a80db2dfcfad83f3ec2204636b6fc93969f7d32deabedc23f5f823d59bf04efd88f324b5f52fe7c0be8d4d2c8764182823eaf246d242b04cc9c012b579fd93cafb68a9d933636ba2c8d71f649ba1cddc6a494bac97c3a045133fdc20a852264f25e3a54b24775a2c5a63044dbba46af9b77076cab58dae17c8a042f454708df4738813808c64dd5115901139cb876cc371eefbed174a5e1c71a4dcbb1fda2866aefca97f787f42c82a51fd9b7796d92891a756ba10a417c54039c77f4e830410ae95f296ec5e2918bf5187f122a3af1420f87c483a4421c77d66f34739ec5abe59c0fbd0b243bd9aed9fe413e40f31f7a3e762f9ef817a5b5307e6f4b291989493703af8e264044f6457bc637e9465e89997675f2bf9a36934074fddf0b61bf3d8feed79e81876cea4853707c05274af1cc5b36ec3295d056cc0ff8d60dab4936993d1bead019e6a1d7dbeee004caa0a5e5035e817e6318c82696eac77f4bf474daf73751d9313f93b0690331aa9880e10be418f29741d07eedd6dc3238d26ea39ac4ece92590a9155ade87d1619fa8115427f4e710b6d1d6e843ea579da579045637c6f98a4f9f752af750e29ce21e36838b0b0cd9671c672a7ac69d585fdbbce018750e027c6645f93d60e8164bccfa1df2666eab75b282212074ae924f8b0548e1657fd1cabc7ab0cef98e5136b76d1d70b5b5667ba0b8ff80b73563734ea2b1cf9e9641f885a79d5ab3ee63af3fcdf45575b069066b65b6c95ed2f4f462023f83deebc6df82e0baf5cd29e0595cee2622f09f11f887234e295ba62c5f8372b670a6b2717d926d9f3e103a8dbdf6f1053a3fed994dc6d6ddede1565b1a01ec295ced3dc496c1e13b5abc75ec8267d45f94c2ea9a1fa0088790f318103ac14f6fe9ce5095358f390a78c9e0b8bc2bdb08b9e12339922e7859c6318c0d572a963ea1a21f88168de10feb12da17ba78de0364be93ff76aaea466b58e48f9d2045c5287dad71b0649fb03ce4ecc3df86fdc8a2e4857732eceb5dda06b3069fe04e97d0fd7d38cba9054f55d1445a55a524b33e237ec6bfd7c95d9cbf14fe952b1bcbdd8e7e03f0fcaa53c9ed57022760ba5ed6d3e9a39e4cf2dfa3189dda0057414ddc4e9720b64614c45857e626d8dcb768f871ec762b2ac60a815e9f15d8310b53f12f1ad09009f2b79906eb3d3d928e932873f6ca01bcaeb8ca636d84c2a55aa7d69f9549ab2b3b2af583119bf48934855f953a4cd24ba66289466a7f475338f5c0f57dad4447cbdf68379f55aa2748ad4f9939e0499748d5801afb4855476ef0ff4a6c674a47dc102337c6139b0cd23f610d1967af506a78395e615bd94981789671250c67544425a1dd9ca68e2d9fcf3433e41b9dbb07df5cf8900e952d26bb35519253631c4f9a42be74564928fafb7afa010d0c114cf2372819d50e7f5eed7233c89ce2506f7db451a16bcf951face8c884b206173386886d18855909089c7a6b678811b403443fc5126f09dd447c1505b0990e592bbcd20c5e433ca63aa8d552761c4bd7b37068d0c3fc0c0e95102f6573743da5b7a7143b4f60b033fc9f5a45483b667166a07773756fd7b91d83169fbe88ea0d4d5bd835b3be2aaab804c8ad9c9c5c88dce0ca201687d1ac8137be7140be825c8dd9919a56db91dd6e26d9d24e17b6a1e705b3fdbea2f1663902e4178824bef6a011bc115948136df31b0b502416a35a8cd3fb024a817c9ec84c978edaf7aec961324f48813ccbac8b3246d88cd0fcefc7d667750cd02b39ca34c9f68ea18938b3922e6144e9ce93da3bfae4ddaaf6126d772058f6369d31ce0cfc923477965c0ae81de758867ce011e67620cbec7bc89650f4c423406b79162a377e3bf768f01bc2fbcee43caa8fe749335ac4965684c8e20d354c8d167e182cc8f27c750de5fc1083e8e4dcda577aff711d6f2748437e0349a00a796a9980e45e79ac7f44f65824433e3d0fbe0016eb850c1eea5a3aa0c1744baaee7fd0d7c3999b2a5571983634c9622c5e394fb061d0c8e43370d31a4263992de4b6ce8fccd0f92a3fbc6f155ba5708562f9e29d82f4b76550ff92c1ace535c2457e90861ff954a429ec08acf95d7a5f8c927360632a10793fd6e9832060d9d4843ef02dc1b64766a142ae319747e04791d93a05fa4429a698962a1c8e8ff599eea41972c351a6427b3ab21196bf3c85bbbb51e74c9d28875e892e5f7a4f6a44c509c5387085fab6a8e93058dd17f28c33cc114097d250b7887ad67f149985d05613b3e8818c54e33c28db17533eb1621a31162dba100a4f2a362fa70d4558a282124d89d2cdae26c72b6b4c79bc7bfd63ca00fdb997e13a08df47eb5882583f4158c462a5a0bee9828e66ef4de9046ed5f5bc21334594e2f0b3dc7edf0d609d790c883f43aa4f736a901a2dcb17af6fa4a27a4b5591ecb974ab35b79c0ad4372f9fea72c60ed9ef45c160aaca8820066d8aec04972aae4a32f007bcef665529e8c450614e63f30d9888d0dac88bab0a63bd77deb14da22d4f905d0ef67e351510ed6327af28e83ab5eda67edc342bcf2772ed598fb38d423110a4f74a013a1ef6e2fccc4aa0fc6a8fd10919feee69a230eff9c6d555b0923085dc7f826c23f0bdebcb344c43c3dd31d210f92f925e0fcc3f97858236df5a099d95f2c9032a6f55ae47268493b1cd56b070baa11f0a6c3324dca4b49f50bc057e2a1d846a3b99f0bc75b9e8e41e99b9373b74a30a98a73a92f988d2ada5ced550ff6b514591d02289e15bb2c1f406cb329552dab815e94ad2683abb10e537cca6725b9e7a7d1fa09ebfac2d42e92890dbce9b0f1174f6298b82d5cedbfd41a9289f396609e3c34b529347d62902ad315edccd578392aee3417ffc1c30fb16d66b961916f7499acd0e4838ca4d523c8ca7351cbda32c9a610fb28970949935f8b2010d88bbc2f3ffb5c07d579f32e25b7d2c46312731952c47f2d518655e0f2baa75a54783bc079c45a97b0e926c93b23ad55d59e11f9e59ac3eb484686c8ffd648e563988beffbeacce816bce1686d4f6611514fcc52a6705e28ce3474ddebd086a7120fa4681fc159602c101b9f4faf4ec63e34dbd1c0eb282d8b88f6d6d010a606ad0e8bcdb6f483d6c906bf2a543bc1caa8549fa709813db08e35228ceed715f84b5f96d3aa5f8e183e58a03fdf1e3e9e96118583a2623d0364b32aeeb2e4d79a53f54fef2007fc7aa6733818a42a28e6bf707804fe638681482bce873950124768047661548bc537e6ed7b3bbf7734b0b4b8018dfc077cd3adee4ab32241cb237ba35a1d60b3a73ac08b78a86c50fd64bdb6c3f99109280d2f94f43bfc11ae4ba42760f7dc2150f6e69b9813f9203b3c2d3db683b4ce0e20bf4b9d7239d874acc6cff3902081e279b5c858a7b30a81a9f3cfd22117371ac54e888c2268baa90d3047b09be139511ef1c10d53fa8e60fe85df60fe3797945feb2dc59bdbc015fbe34fa6898e9aaa59177ec225fbcfe89eebedff2b43023e027ab5e3e20f3572dbac4b07ae0588c4c9b771f14ecbf9030dbe7a99ef4d1b9750d7e481bb4b87af460d6bad5585af7c72d9114ef446d0c7ec770360d37972c6b454ecd5f4bf56139839061f29c946efdc0b5ade843d0e0da712c9db029a2fb3fe3e8736325527b040ab08dde11c67f68f693837bfa752eca65eb1b46d05ce1726f787fc9a95d8dfa8af7dabe903f6d800d8ad6793b7d312331786b2acb25e7b09cb069a86390db91d0ddbf045f63b60fe87d557686b8075709fbffe65d8ead0f6cf81d4e88869dd44cef43ede97f71e4ce2f284b7fbabc5c3da3272270ddca48257e4fb235719ee55f521b8fcfbad8396ff25dafd7f5d93366baca01ede092517724a2bc4ea7d5dcdbbe08595c14c30c34a5c31040ea1803ed39646ab21c7a1b7c550541b56086b667b9e74892ca49267752fb0fbf1ba4d3a433f6254a457765ecaab4f18731ed0093e2ecda49ca708d4974508fc9268253b43090a9410e1748030bfeab904c72039d6f6c0edd7c0ad35b21b1042cdf34d67609bc1144ce1f15bedf5a6ed4220943ddc6028354b0ea13cccc9e216ad403787159292b70faff1c060456968361afebb65c1d53151a683a1022b7436c3bf1def1247e3b5b76ce995694b304c77dd5a262cbf70ac9310a195071cb8ec3252092218379fafdc4fa2f4c047b2322b6fed4e98386d3f834b3bf3a03d2379fa3a4b024e711447c95368b0b05f7c1c40545a4e50010460424fe78b0ddb229dd07ea7d0e91afbaa16a63e9dff0b9a1a4bdc01cb79aeec516e93432f4cf2fd2f083b116c5df69ebf597916fc17202b2c0a80e84afb41366f1059e6b2f92b7a8ad21908c7198922508f4e6aac14e640e4d8815e63c88b0bbf7540706f0f75b9bd5d8dd6a0523c355b4507e4380e93df4e1949647a323969da3dc4e036b7b381a18daaf59ca9358f5be044184126329add96f08db995022a65f79ebbc1bfd3dafe5502f88efb925752645cb943efcae7790d1c9411ad2b4caacbed2598dc1ef10723f5c37dc86599b9328564ade4cf48724685787e55cadecb1c9eab57bb78f4265abc6e33fbf4ed1199511868e80a7f90981e92b4e2f915405b3cadcf0e95bfcb74e3239599a17e22d8ec19eb91df497969e66003351e426793828f8d2076cb76a346fb96af02b04f725bf1d638460dadb5a80252665408007b6e1c1aed55c734331c1bf1dd7ab330822cfb2d2affdd6224ff07e01d77279af29aacc402111bedab2b12f535e7b842d03a253ed93b87965da9dad7ec3c53f9d0f3ca56e849a66b9d05ad005e266516d8d7b7a5e344af5d71664550106f643a55aa8767dc42700869f824e9efad2fcf5378a532f9223344dd673d76e4aef2e739bed1b8ee9ffbfb85676a93738a5c5bf1605c4975d406f371cae9fc3f5738a3aed5158a84601909c8f3b16c7c7265a467c78801d75a82dcb9db8df938cbd7ef2973b830d22e037f2de36f6190291581b1a30c839d5666081291552bf80bce0fd7c2eac32be85da6b2ede01606e3276d021ee70022c7346c9829c9f84c73f3bc4148c5c40a39c1f8690c42a7e8b64be131e056f697c62fe367eb7f2b45d9e3adbd100a9bf6328c5750ea29dd829ab9abcc0417773b50eac61aa973455330a71dcebfc2252c0656fbd9d96aa738a3d0b7122b1f6ecb6e35636e0cbd4e3949feeb2c33da79353752a35c2647c7c95db6884ed9883fb62a6de1e3a381dc68dfbd432b92b0d94a90143f8c4016736e732269c020818efb78e8044f4468014d02c1343d78f941fe4692424ce78ad96af1b060da010fa50e4cdc98e435db2e77d987e65bb90fe10e363bbc6aab4a7fb10c68e3d6f7be9feb7b07b736f8940e3512b3435fb6aa2c4d0acf1d39d196196c1600361a668b1a08d89aaf7529e4e5e319008e0a5e5e5e6297ef2532707d959e716aaeca03e6e4dca5d1d764d7c9a35356b6b853afa0df850c8f5af429321e9a0ba25dc3db4245f77a1e05a591ab5b8d5811804211fae94ac276056309d09066ab7094b82f864d000a53884a325ac45575cecd656123095c87e235118627b027cf817400bed86ac9b2e50596c0619e2976944e07b59717d16eb16a192d0c15f6770ea2f191392412dff5af147080a9fcafb550778f9d2fa1bc7f2539d669e7dfbfebbccb86b12efaeac6e2254f43e78c7f58796e9891b75ddec5c3a6828422e9c240346318e49499bbc59126b4f38f2b8f3eb68d8179c940d0dbfc63dcf244944abdaae19e01b5042b51b20e9b8918657bc669a89cbe013c00537af24af034966a3287d08dab2207580e5560ce0bfe870e806c545033342b39cfc443c631fefc4ed36b27ff2adc2f364f9338f5a492ac61ede8363858ba12514f567f5849d724ff485a2ffe49a6affab42db4426cc7242d77d70b0f3827b8df623d55b70d00d8bdf3d7a2a7bf50f180e9fac707d0598680b43e1fc739698c1944562201704be82cb73c7a9c19461b79a200c7421f9f03bef158cb268a889e064ee2dc7c56f6ef6247e465b64541986775f396938b1cfb5d18c5588e3b1bb4e986b4dd3f5d297de68e8c59fb46023f5c2e2ec96573f695dc5cf0ca18a5da5772d919a927e0eab5c15f5147b6a81a6c60f47f77158374d590d0ab4e9883e4567228103c88ac323454b584eb34708c561e10cf323432d6536c8725532ef5e3c97fa2c4691b8bd2fd1a2aa2ca010ccd7eb2b962c32a137a3aecac19b19a6d04e52419e560669c950c1d86df3aae63c6e49185c5e24a0c7a93cff7143f4f496facba4555191c285c7be122dac786d1f9f49912eac6154dd546607b182381a7c69e80b7ecca5c77c8cd3f03abb85a952adc6291927dc46a049ea7485d49e0020acffb788f31436c6a04d5970d34333ce725f45d0e3b1690fc7b8f433ee50cfa399a7d92fef23464f4076f41e0fd0b6bea071a5bd284b027e1ad3bda68a3635842491100470978662db4a3d8decaf3ed0d6289be6197b2367162bef1dc937cc33ba53667edf86eff41fd7a4fefe4e636a121fd2e7f414a34439af6d8912c36456d1bf7448c16f02abc216b454ca9fc737dc789a1ed79101b1666d452fb0a7211ec6863389c645987e13729e8f8480bb35dd51b6c825df4949576f52146bc0b483f5ff0af5e65b87298e8ad069de282d5f42f461f36095b875cb0d32f3e1a8a58430b4f8e7bde80eff62f4f936164677312866913fd49a45e28c967a3ae5b5f0e0e198745698c849d6787cd5bb3a926306ddbdcd308ec99981fcfaf411cca5b55bf8b9f2ed511bfa5785fda527140acbf13dc6828bed0e54af9020f6aafc47e4d2650cd499194d9d206740de5de6321a34a268b6c86dc6861d1da5fef479eaf9493f2aee77c5b152e690f5e94f0dd3fa493ea3e2bb77bc90c916c4c0fad726e348dab9a3d58e7ddfd819c5eee78764b5a5c121a92b7e3a5d4bad7a6098bce5a8167284000b014de6ee676e81a2f2a195c8395ab635d20efb90c27de5d9a37221e442eb95caaef054fa960151e51b16f3adba56b69445a04cd809b197bc984f7a834599262a9c031f5ff5b8c4553dade364936bcb9d04f386e434f3ec9ee228f0521c932728286c7d61ddab3794ec14a896c16a3d7b36eda8d2aae45d0036e3ed69a0e8bea9c8cfd0ab0e73a87508c73dcac238761df80381717dc992b10e590d2bbf6e5f1428c880f053852b7641ced6ce9415f5d4fc1243e795ef08aa97ac9103e5011ab90f03f982a2837e7326b6e194fe6ad4118e97a826c5926a01f3b91405e2052798824074213640a017cb307b3f48809792d87103740ef8cd49c941ea5c8e84e1194990bc9a9ab170c94b47efb7fe1b58f33fd485e6a14249fcb3e61e18916fce07c484025d17384fad24f74ee88276f3d2d70cc74a5601133c788d9f1d9999f6fbb63e8016412ab8d90defe86af89b34b03a9dded79bfb508c242b87f467516ff1e88256538f6f5ddf861a48e2a46f675778cdf736121d6afdad5bd943ef15e824d67dcc1349ca07ba5d226bb3b1835dd5914e75e363d92a5e5f51d15b90abc26256ae56bcd3b4aaafcaf685b9dca9b8b160b58c21bded94082e5d63578e4877ea528e1ee08bf73ee0e7d15f332ab833d1174a903a081f1e49425f5918dda160f00a642c37d3606dd0d2e40545524adb4a281af038f6b0db829b659602942b0508d1ef8912932c8d7ca4f9e2889fb2f48c4ac506cd509b76ce64010c069faf7f22c99b0eb452ef80abdc27bef9159579f55aaf47fff2956b959bc9c40752949c3cf0ba87acae8b45cd0a9ba04c0518512b7971f1f9ef00df7cbc16b3fbeda34da218e6e76c42df34aaff5951bbf3fd9107f035cdad85d89b870731a9673a0b4b00b315b9ea514fe2ba488cd88da851eb9054eb257a57c32f3d20dbbf0d9acc87cf3566a0d829bac7d7e1202ce3d0a2088c78f03f3fc5e0e50339d7a80aea833e7f9994ea737c4200ee66560862a73f227809b2d373b0216769f52aadd27836885820463b71c60fb27059262f784968cd6cf6b9a68d8e6769faeb5320592458bde158de89133323a3e8177e11a6272182ee82cca96717a43ec7d45cde786c493a8ad8fe226cfa4d86725d815283ee1be65be96b3fc51a5534f89105839cca470c06f3eb9724c276f5339fa7d6bbf54a7d73f765a509dcb90059cdb071400c81785ac2e4977cb5f740da55c539efa66134f89d75e70074a4f0852e24eceb3b265db6168d065c6d76d10b84a24477990f0f5eacaae0388be0b7a166551313030b4401c2cf1ff65941d7d39fff2459f42c73aeb678160894d7c92f5c1528d3e150668e5b1e7fb643017fcf27cebffe71ca901241c0fb00b51dd6df58597c4665ad0adbd4e8f4d60249d0a931788168e707d193c5044986cc5bf26cbd4e851400792a975c92768d851fc36c889c0b9497ed57dc580aab6cd0ce95b711ce8ba1eadef8fe91cca6e7b651288174abb40218c1a4027b7b32bdd0af1a24277cf9d6e67aecc949f5554575ee24f7a1796adaec978d3990e1435a73e8f1b46f9cbcd71294035b51e577dc3fc855fd989b7b0465dda7b638acdf780bd4e4f64a32441749fbb0f78181546ba00752a3f5032f87725e6d49bd4501745e3649d67a9636fc8ceba85f18a032372d82bbd3d98eb5cfbc862fb14247737396068461e5980dc6f2c4488c4ef8f2b1436dbb15f65fdf24e8b94088e58de1f92d95edf946d1b840919776abc09a8f8f7097e75482c966655f78ea58a5010cec007b6ffc8f610a09bb55283c159063b461a3774262ee713649e61a4bf1c6dadbeef9a3513b80bd9c297f696ba0d1d2971354d90800074cadba44ebbbf53af64678bb0d1f6446fb6b96ac751b71ad353cefa9bda57e9024140b93799cfe332759af6ef7776241742391feca8a0d5a42574edee5b870a748ee222b212cfe57cf4c6316cb3e196e20bd1f953e3beee2ff7ac775eacec9ff49b4ea4ab031e65b268f17eff19007b7dddee98673fbaac007a16ad3ba316c883fd208d4bddcf2fe0ea05135ecd729267ac860421bad6ec3d57ca9b094b61302fa0713197eb32734b5bd051a9061a4d268271c51bb14484291f7ab70b4e221170933d32e788ff20f8cbd79399a7c9123ca19d36798434657b0d998efbf4cd569bbc4cf31b7ea3fed5736a1aec2a60581d05e92e5dedab17e2b6f652f3492784f62a8f8d7320d5d8ab336d8d72d284df2caef9a192d2f798616f96a7106a78fc306b3a65d4f188e02831adacf172f57bca320d39a0c250f3adece28cfa477e782d67978ac8f0a706b3d0a552f1ffc4aa9f516aa424d735412fbb6d4164ff57ece5cd6fdc9666dfcb5caab3d8bb571636403b5e53b259d57b7f371e40a451830e18983271abc5837739b0acc9e052e90f5f894cbfbf68397538da2bede04d55d13dd239ef8436e043cbbaf76fae81daea3c0d0a1f12c2006d38e8b18338bae6af4e9927dd73fc253d27a8c0e9b5a2bfbc59b7b4c3b722a819b06f0ecab26a5ed4b52639f6102fe8f71fb8868b3775bd2411f16e29c561d372a2ffe0bd2b88fb5b71d81b9f9d6f6eab59b3971bf2e0439f783f07a3dbfb452dbf02cea3fd0fc835603eaf7859e9199996b5bfd5f3181f0cf00071ad8bdca203cb9318c63a1059019f9a829bd5d7a6ede9258c0c2df42a529ea585dea0814c2ba31cdaeeb9ed34485dcbb740c5e84ba4ba287ee1b2785f85f2742354b4953e309a883120f32e226f6b6df47ae23b91630316013ec1af4476b202aa3863444fe9f615e7266b149c5d4b6edf738e461a05cba7f433e1bfa3ab690ef3f8d0ab750200e1412f15cd368f2f45d4b41b982fe061e35608a39af282fe568969aed39b50b0ef2c96da897b0930d06bc3a3d071dcf10c5b4625ddaeea94417f6c2f386b1d191caceba96d799ffb674b8696f588214e6ebfad0270e20a3662a365df126972d430d57c0a697ad03098bd54e69291b452cbefb1b12e9d3ef15b1ce1a3860893f265324d1efacf6d409216e4db4353f48cffa919ce5d2b3bda15e89d9182cf8a956f4714d2c2612a07d6d039e7d969b4fcbca795ec23f2100e5815cd7b34747e686af94e4843d5fd5913424ab2d9b6611e513929fa83975497b93f98f886115deccf74e68fc04aa684d072540f366d7ad15dbe2dd1e983671d7b1e5fdffccb6fc5e63f421096f8c8c1bb349528084666ab7973fe6bed79bc548661287d7ce437f4c2549bc9383ec142d7f47be06e13d44f631aa4b6b11f446004a98ca56a10eb7a7d74e9a5961709d656aca28b51aa4e096ecd12b9576c21756d54f4e5bb396d9486229646d39660439f7e9b4efc05b6e629783e1cddba061c8f66865336fb978fe07055ea73174ce0d55fa7af66154918294d070c93e1c21ce55ea9b13f8a73ff7f2443d134b1b6eab2bd0c3132cc1ea8d018a32e50e1a8480af0d96476a0d38b5d8d14074d487fea22bc4ffa7f18b0ab4b6f81043a1c3cc80d3ec66c5c643e7f355c9464eaa652f3c5845fffc6e2f5e1c15f244c0cbe741cd79757e0a0b1fadbc493b45bab066d0a577c3d0d4bb7768af9e2dfb31eca4e1e5031308d501251b694af4292067e34f07b74963fa87e1a31a24b1757a124710e12c0496b79259c8498795cf0d1ef853f35451a419d2d313113299f01e59b83ccb1f3e90b7707e6d7fcb5051163abe69b6ba505ff55f68007e8c1a9e3cb0f7cd3f0bbf653b521860d2cc30800e571581e52eb29e6eb8b5697778b7af1c385570c6ee4940e2b58a29927b2f0e6d1b51427760acbebd814625e3bb7791e32851e8b925d3a34878fabfe58a40eecd482ad6bf117e4b9c585be30831762131e6795cc2d0cf0e3ed83d086ea91ce10bf681d9e12706d9616d9e58e89aec2203ae11c9958688e6ce14554e76f468f811e8e2f27fa1af7f66db701bec77412f0ed1ed6a687b82e8b50eeea44af57ab8121b95c0f394518e4a7475245cead9dff8054cf426ef3e6e421875009c3a298c3bb6179c5a1274585c3eefec5915da6d8c8f446cafd6410c9dbeeeb3f063d73d5b6d8b9d6920ed50f4babf3342ab8aed62bdbd23741936baebe27e12a3cd8588308624d076bec3ea82cdc3193de44d226658bd11c81cd7015502aeb654be9fbd750cee0686a4daf536bf4f489b0ee1070d77f100830d3739acd16f482b9f709b4a730cdbabb51995cf4779568f92542082195f8c2339f8a2652a1da3e30125828a995af43e5e2cf6faad762d129df15b08b5f635e4e74f6498414ef5b666de7ba0480c38974bb803f77e9742eb11978502653f780e8065a5c1eb670402284aa0a5cb49f89b899c512ce73f610a4110c0be2217726eda02ef4e0e06e6fbe3ccd5c3614de5b1b6615a842cdcdef7bcf81aa18de69c3343dd74030d0ffdf9bbf679afbf4fca33941009444e1bcad8e145b053aa6abb15c61c10dcb2cd8642cd30a6954da8beea94821b226c0996809b38118b7217d3bc66103a7b0a409c6770bf145ca14babf5ef9e0e4210a2f0149cd20a2df642d907898da29ff94e62aa01f89151debc6ca1f6c23a6b59dedb6969fa2e1351078a4ec08b64c113887e9e8b537212b9b4212ea362dd8b848353852ef03a98ea5cf12278b5c61e9b93470885f30b333257718dc34add7b8b7aed084753466d3c65e93d9c55b6c3b294e3b76b19aac60241e03a556d9ad36068b784ff8e89e23b5e9cca3c9fadcfc93e0f1b8bda32e34fa721c41b94b3171b7570939c274b064b6cd0e6f5a2eb52b6570ed7ced9fb9c77412b13f28d3c5488dcd68797ab80a4ccb0ea842d124d1f0712c380308444eaeca3dddaee873ba96bd1752333b52335676e9515b777a43ee01e65b55814bb7d0ae945a2d603bde5dad67f5d102d1a4df8d863e1620bac3774d6431abd7e546df9dbab6c196276f98dd23a68a56eb32670ad08a68cf82f673488ba1a5a091b1c18ac0427074d33b93729b28288b2a1c446e2394d5e8532e5e6168a4cab8ddeb2fa64bbbeff1d1ba5e36aadb87bc1c2dc0b417cdcf306acfbd6b786abda45d643956e111c3733ff78a934997a22d6e84682b418c4edf2afe44fec41673614566ae0b1fc00f1cfcc65bdeb7adc6e564a01614c79812bcebedde15bad89121e59800d970354c6476da68e5f7bfef412b9069c220f6fb6913a8bc3ec8032352ece2e93dfd69bf25b946fb7307475bcd9969902154f39aefba853e6ce3a56c9f4ece68d5b7963a076ce44f0592367ee28c18f635cd383b475d8969fbc9df15cdd92496b29d3861a4c2641c4342f97f787139c1c9af8df716e1efcceedb5c7f6f52f94a01ab92bcdbe5e1d169dd30e3a1aed254929fcca15089731731eb3fdefa79b05940c28580a09dd7e861fa03f95183655f5b8b1e272f2a228c54dd907c9aa58a6deac32f5585993cb2a8442bad2d1068926a5b53cf77754dc493eb8355f13ec20c20d72fd4fdb825005cf2351252f89fc5703ac7e26c19d91527e836ea56c40fa3a8e6e09aec64d9e6d680e7f8263a4057c5f23ff7506a9f04b081140078fddfbd699d5c654ae9bdb9e192de1733c82ddb44b9dafc5a1977c209a2bfcd0de40092adb7e411cb1438c2c5a58a563e7f738258120f1da5aa57833e3ffb4fcc90e3338fc37c1f00a7cd2aa7007d0d6a4761f6eb99bd2b01f35a85b68c11c49978d70ee2d297575c63e2e9a942bc7e5c09458241f80c3c74cd82cccf07f89612ef6a25c401a745075f67977cb79c035374be404ef2c1918c52fd68c866cd9bd5f25d4ac07bda91d69bf85cddad2700e9b9df47b629406747d2dd637f85950a353b8fcdefbbf3bf8fbf2b708e5d0848ebe167f787d7cd35e6ce2020984018b09c854c5367034d7ddf5e9c168d0293a08d771af30ab8539462414a067e69b2a9d5e8bb266fe6a5dfc01a562fdd144ef4f64c0b37be5550ab272ec53d2702f4814bbb61479c4fa10b6d67ce91bf02bfdae5946a3d33ae573505a4ff07a96389630855db1b204a3dd572138a814de05ef136301410beb2ff55ad455a4e5454a8bf9d0ca756153c9836aef49f0641af92eef20cea0d8b33dd8bee17734ace5db6c867f480f0317059bf03e10c975618319449c9c09e1fe076bb901462af4534aac94395ebd37723b2a97e7c319b17ef88ecf7d065379c4107ebd9d111654980b759928a65111a7572adbdd2cb44b70195174fcd20ed10df52f413cc3cf34ed52fa46d2c01650835dd136cd10746573e66c828972931d52968213013f6748ec9abfc287bdcd53685855edf4a83d245d4c6d0251e9637259fa04dad04f49623678b1dc9476b712feaa0074b05727625fc9b9dd00faeddce2a82b74259daef6bd9abdaac3f6b0ee685efbe8e1680acd5437d4f8abef65e7310eaab6be366548094e5039723c07946a6bc96da8f12c3f335118ab2e08ceb72eb5d64c81bda2e07075f03d1464296463757c6d9b1276b9ce142437f6cd7f02707a8a978335676c38001f41be606ba42b10468b3d0ed554de85934031f2dd47a2aac35cb92f009088c9fda4591d390a49f1a97b3d79cb0044aa641bea4226faca56a058fa09797b98e3f1a4d061445666a769094783ef1ebc2524ff781e48d023a729441226cd14fda86136a35fb0f08745a897f3442a273d5da0f87bc511c327a0d83680dab465e7abf9d23f850430e19163a2fd373817000eab386b7f03f4c86f211c49e27d2386700b0b2c1307026f90c8d3f758fab9af4265f029d60644abd0c5a0e97e1aeb0ff4fe7adf1ef47f5318d95a30b372237f3594bb53baf198a8b561c2d9dbe3cb49fa063386ff0dc5091f9d7588a12ba77d4fb7199026afba6c9430cdac7311c67f75052df0d26ae3714d14db398a6c7d492ff45e919840d66020a93b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
