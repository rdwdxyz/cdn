<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"014e2942692ba1931fad19005f4a9bbf31897fe09912534ae05472d64bd4950f65b5766211a528b6d2cab2c194ded478ba255759bab95011432b4e19fe28fc784de4af1314e301bf2f6ed12b04bf50a5e6f8106230bd95d71e3f26c9a73ad6e5e2ba3917de7c6f48eb0db1d7705f51bd4ecf6c6a5d605c7d7d0b869d77f79d2686d6255303feefc0f377924d9300c9e210bf40ce49178d5ca5224ac2adb8686bca8766b65e4baffaaa70a099a00b734791cae2bfa7aa3b2f6896a3aa0cd4be15b6e902429796c25c329408e6c79f456267179e7ab6d94ae6d61d086834135a5a76ce7157f7f0167a5785086485934b9b9a9c2f486c72b0055423ee6da79fe55226ac19dccf58a2104e8faeb8cee3eb2e987f7f61102df30aedb2628c9449d15b533f9a1d7992f80115e0a3fba6298b7b42cf1e113c73e797e1861f1a750b1d60042fd1d279c31e32a23d811a0a37533876cb3601f6e01ac699c1d96cb60032236b6ce881d1d9b61678cc5403dd438e0c2295d710fb8e60931621bdf91afe182f2d7e8327916e8f5f3d7ff551bc851eae0b3d5464449621ac784ded155719dd53c824d9983fd69fb817ec3c042508791b9fce16861272831e674b9ff74d186906a0cd236c5783c7071fdcf5aceb8d22052fd6f864a9b7a91a421716b6aeda04949f8689381b613d68a46f92a8d6dd2c58979036c7e40123d9fdbf5cdba512541fe98998cfb9063486a1d1d5223a915d7b34374b8b3dfa0c88c6ed16a92384d300e0eed40dcfd42b2c7f809516e638eb6b266fae98a81d8d8bb1703803b2bcab084ff5fdc7da442ca3dc7d27b113aa991c8b5f08fb0f26cac50ec93bc2baf92002ec018f069c315a6c24d5ecb0e6d3220730acd760e1f9327247702be46cc4a7ad3fa6909165156bc08aa7abc93c09a4d620430b954428c84fd0227df445d81ddda0272dc55150324fde6afb0278a76f9a5775a4fb65e6bd937d99f82428cba0bccac423a37bc6e1ea4355ac17603d3ec97a40eb2c33cac8c58f2015721e47bdf58dcb1e3777c0c6fe07fa55e585882817d274d374d477472bd29722caf8ca4909882fb0b25f58809b172d5a785cbb7d5f1fd6629063a28d63edeb1ab5da3f234ff7467e96a3b108c92230e75ecdf9be611b669267d962331c15d08dab4b4e6670026ed2e605035b446c9bf0e972281f646ead7bbb066b75045fff5651e8f7ee23f7219a124d5f0bc4519438cdb44d1922b1e3bb3a3af8488af9a9ee701fa6bcb08961e5aa5e3a0942560a86ec3651db6715d808a8cb7ec8200d51ad2bf1df53890d2a7981d68a933661d04b3efef97535b21b0773a3609563966f3877ef79a2ee299d8fdde9609f1f0b03063a67c610b8f4cd4854f65bb28cb80cccf752eea0158449ecab0378fcdd9d82d580e28f4bc12e05014fd52f62a4edbcd593b5b93127de1ccbcaf9511504a7fd8656276ed63aaf5a9aa2f7d6811b48d9747fc207084ab1505255769b33477ea46397fd3b2633f99be931408b300cb4982137c14d9951a22edc1b23f03aba4cdbe1b3418badf96f2ab5ffff6e8f666c0fde20032be337c78801e9d8a1eabf6572f69f77684fa6776b3d2458b76e5e398b9ebd20ad3b3db44cdd76be4010f195cb242f5bf5fd076f0e3cbc33363e722697241afe705c622ed67d42879928533dab0dd3cd8020d04857810ae184d5ba4f23f1351da08ef40e3bbea5ed19d30059d4051dea79f6e28586b69c31aabc319e9bb57bc5db50447d599824b7331ec77c0dfa0de026b2552ff4d42981cc92ce27ed1830a4d5cf07487055b7c787a6a6be09488553562500229110479a5f40733c83f0b73d11ccf3083ffebd207647f5b018432f510878d77113159bc1caec7fc385a4d8a1d8c782d4c7fa58b18bd011655dcc23aed0605703fc5f8824a7a6064ea43028378fc0baa0a24b848cee6bba64c19e803d204d7cd032bb75f3f9911e794b3902e7a425bbe60d10ad4981c7d8364ec22f932f495d14dc1655da198109baf6918d7264e185ff6f08ab3103df5f90814fa3e754b813ab0f2b16ebfaddcb47c57983cf6af815f6a26701983e6772a64176d442bc19674e9ffe682ed5f59db106bef51d34a6a5b8d08b0d854b630feefa2f70ecdeea1f5d09b14fc8c535a09c59fece74f9cd9278f0d6987e576ce77fde71df2364f40e7daa4c58fa5161752bf1add25d2ff01acbdaef852639cae6427f66f2cf1995c3a7b9366059fb4edbf1603fd40b44fb89dfeae005c256625739e3ec77c2325fcf334420e19be9f5016a5cea13a43fa24009325e60ab7ebfc808cf82e0bc6f421d9f1d8609f7f4ca4a6cacb837223f70dcc6b8489337a415fb3e0234dd5201b5a345b5ba64e5fdcfed8f66c92b50dad77474875a0c8e69490839325c606382870087b60bcb628d1fac82a7928c91cbbafa23a44214f9a6201e0ec1ebc01c61f22740ce192daae6fb2d9deaef27c1080c6e68e0746384e1df09c87b4c821458584c2f2919d664177937d63a81da93a9c0ec1f56a51b4bd229a775af19938804d8645c922a68858df0809f80305aab2fd3d5cdf0ef928d5274675fb219b51bffa700e6bf75a5475a9847ee3ca626321730861f8fb6cb38a91714a604f77fb221393bf88d15b0ac9c6d20cbea8f5e1ac9c3f0cf7979fda2511366653612ed667981a7cec62752b6c61da7557a75069472db7c5074b7135184e2b887fb9223c7aa9ec099928d2f9ab0cd6e4a44fc7c0c105d4608768aada4567a7af134f9ba543732c4635718e02241bfd4fd13508fa5602803d6a4778fe92c1cec1aeef54f045edc3bb7e520c48515c5e2a7655182d9701deee697922c3f0e3e6f92c41345252e36c1d29d6f7a810f5c3ed8b48419c76a9b7d9af1f57152a0a08352c3a21296441adec6d23e4dae67a1a092f6abadc3c3816536dc5de01ad543306c9c8c27ff6006f45969cb4a2ebf20205165d77167d3c264f9a8230231dbe908a571f6490316c0dec5dd4df5f6b061cac7a84a1d9527b68b829dff41b11616d6fe9051c67c1a85dea93d413da59baeb8ebe916ec5e620edcc7d68fb3ae1a89e675511ebb26e2827f0aa883341e088010ce4501f407c32bbada6bfa19f266343172757c72621155def83b6f8cac751d21a948ddf7c50fa157bd90917ce6276cd200e9dff2cb6386dad81ad026dd4a7fa900a4545cc02450a800c86909ddb7c1b3d945e443a7fef27bd795ca2125c15a031f7dccc3faabfe622bb4f0f700cf6eccfa001d1410c4a8726b283c03967ad2bd8c4ea8f486d6dfe6ddad77205d486ebb0de3b1fb596ccd8a372a5297e2a3e63d14c342daf3fa9d16fdaa7cc7c682783ae38894e7f0eeecc9101d7ee9d72549c305e92c23004f27b07b409c0aaa6e20c02feb7e121ac985a8ab6e47ed335bcced1e26999388fd28807eea430a72c52ade7bfa98b5ef2ce14682a2e562c97483188f44d138809a948b6cc4c810dfe44a756502466f23a2ffb8284422439b4855f1a33ce302548a3cc718fca2412a9350a372850000a5548436392cfda9429270697f7760c5f7f825b0db9af921f54871a3cdf269e20d9bdfad743ee3024873bd1ca7c1944eb8f115ce69ada82970432b3f79be1eb2b1c3b25738bd323965ba00597a7e5d331d38ce1abef8242dce408389984073428443b1bbd117a6b42727c158badfa2267a08528c85ca4893e416a39960da38077503e230be337127ce659fc8e61129c7054e6327a91073295e1afa752cd565c249a803f90624e243b4c0d92bd5736d0e52a1b2204b1dc9f631096e4ab58c50368f14dbffe5c6bfcd7701b361f7220249f928341c7f26b1c8469e652b27c44acd61d83b3bcb9841b173c47150a2dd3a7e640e9a41f03e18d1883377517d511209abd0253d6f3f90a52f1dd858136de25ef31f17adfbf05b21ed49339f21627669b7deb046fcbbe35a100660279a30687fb7fac31b55dd01324bf1b0d8021bf18e73a2c219ca38698e3704cf80bbe3a6fa99a5f9e8a4b6992d94c2be60fe08fe2f017ca29e4f748e87cf1753b9941f138b4527cd8eb58181bae5526f6c3cddc80e9e6514793762b772fa5773406603d4a889ca6262ac5e89fec0133a8a8eeefa361f95e0aaeb062b57034db668a57eec629bfcbd010c70222768307d96ad0ad06b9f4805c7a87bbeb359f63417346648b4cde982f212e1d3b257d50f492b3a4dccbc9d85b44db46b8abcdd24287a838210216a29a6ab3a1dae9cc38d4d9ce1fa80f250a9dc4f12864b65995d24546df931d0f32e975ff86cdc903cb5eabc16b61f4ab55f2eb3f5128d0f16863912933f3e87b5d1c668f979b75181017df74d63e9803d75d1a48f0bb4baab7dc1f01f0d5f6bb9b9a7a5edf5e6719686e3b0b4b032626cf7133c751da2ec057597eb1e09d40adac9862fe07abd0f9cbec269a0703f794555be857b9557d27a87b44b75b88d4db48f22a4d6caf6287eed19a711eea91157f181aa0ec8d3afd8e607169df619e08902e071affcc73b7c34d630476601ea5a79a1d48531f5d043ee8291d5f33b20fdadb4a837346e23a15b40bc8507022ad16530119649f2ae808b40516c8cf463ff9a431941505bdfd35e00fe87782673b5f364984d16f7bf93950db2b364942c5a7eec76a92fba4537bb75f27f308af57c4bc762670dedeeb23fd8262ba7a44324b356e3baeeec4d81e7f65bca2e04a4ab70cd568cd292b55c57badbbc43f958e5f704496138bbab8532a23c8aa3e71001fcf77437ae0bdade8ed3b5500535c93d09ff5be619f7698b39f672c4ad026341136afa949a36467507b92a41970d60fb03fba5740b09c28b866cd8e3d9734a8bb39c062ce041925dbe890a88b512e29db34baf93ca2ca1fc866db55ee2f1eec14109922b7515f347373f0307c38f293416d5e62cb96ec90c0b07e2c14febd2115c1c858d2f43f3775c064e25b3290e89a39da6de235628c32ea213effa58df498f34888606fbaa680c00a7ca5fb585ca8c4ec86b540a8efe445004b218e7ed95559c67cfad9b49285fe56e7f5beedb15fbad1bef5c90779a8a5fbfe9da173a706f5f4069d9ba10110325c04dd5923650ab737c3a3a9d7a20bc1e79b3880a720f4468fb7d5a3f63c7f9bb9d1baa60aca1f7553703ba172c369094435b3b3cacfbebcb459a8da9b3ed070b0408ca1a099323af221359dfbf222c06be757254ac8304af5ce143c8e1035560a8d65f093c04357b02eb97389c8f90a29ce55b3cdfbbd8fab3257c9778225e01680672831e147692f19d3f7893e565e872ba31ec875b7ecb3106c63e88d9436470587f7349a7a90173b9851f0f10608530fa056c24b7272153460cabc3066c34f4d7e9eeb4ea7b95628b46d1bf12b3990855daae997579544d61ef64d99252b50b65dccd300a5409ad84689f13929367575d4ff75c86e9647307c8a19d1dbfe0c668a4e2cc48847a24c50f8e35dcd0c3e9023534154dd410537073269885b1bb45bd8ad72d29d78ab7073c26f5241c1c5bdec885e3bf87ef678400a462f439c87b6a5445270d54a6af33961332d5f6f28c88e0dc03afedaae7ccc5712bd14665c4a8d6dc1e3a4974404bdc3debe8195131077c512fadfada87ea610ee2a400a9a5c1162244a4019324fc3497fe9aa9d9aace82195420d3d600e9b49a17280c6ff42cc9afb0eddeeb5695c9133ca37a9466d059bfbf51bddc1af74ed537ab3f9a7f0dbc75c230ecda29ad2b4c8102737ff1241435717a7bdc39cf48e7ba1dcf0bbfeca4ffd30c80c5699433db2f87aea385af79c13b806e80cc42868ff94bb658133628bb49853528f92c1876c7c89abfcbb8c31801cd6660e6036cde967195c60b1a347a85ae61414a5145b564043f5a6826fed2ee49a4af5f4d92d896e4d03a7076106781bd311285249d8b099b87f557937e8ab5b4223b08bdbf2d2b3ed87ef684b1c392d46a4d9be7437949f5b944a01c48a6baa2533eead864e2d7a6964dfa708e5c33733a4e0cc8ab63773341008f829cd0594889ecb8ca2833750ddc7942b82ba87f9a896ff5a4b09ff8ba74b437faeab147566668d5f72355c0c6c29d599cf6eca1c3471de79f645a943cedb4e9bbaca2283a3191683d9234dbee5cdfd36a742e656c4c84879b0e120cdc6041d4b5e285b30117939e6475d7d7f4898a1e73fdc6c839e98ad4f4ab8406e72ea6f601d177ec545ac9606237c1ac335a5b18bd6e330c2b10d0ba894bb9e17162916ee485bfd26941adf3e4f0c4e0ccb19a5d0654681a355744e3891e73a5f88e922b438f0373901cef56c129c56dda08c8da6f2b74fb510ec3f0e093326100eb4702c14a36197c3a6c464e3c98408f593571147e8b2f4feb0a4649cc0a2e01ef0575afa2278c45bdd5b7ae9c1409ef5af1c2edc6d351cb7379ac0d477c91d452fa3c1cda7eac2a10b55a2d1bb9a8cf791b95e63d95b1ff77dca47cc223180a337f74242720ab1df2c4f10a26d81b16f788c5c8b88ca174c8adcfb15d0f96f70f2b2991fcc4052ef4cb5ad9cccdfc173b2fe90d5676b62b7a2e5d8541a3137f86dd6c6b6fd54f378e355637d2406187afef1d115c9361075d43a41f41a51047cb1a7cbda9d5155aa59ce1c8bcb9e8cf81d6ef47bf1194dccd08e143764dbf2e7519a4264d77c25b3f9650bef9703c04174089c6f4c537b86f37956b8130e611fe374080304ad5decb8a01d7061f22efaec0e20ed1c8d0648d8b8c7c7521e89aef5dfe9056495bb819f62ffdf7d5bfbcc5c6a453d3728076e66964aa9b71f756a088d48f373d2c47ec9e56e15792a6a42c6b872d7d2f181eb6d87e293a5379950d4aae4c573e854c89297a66c9478f5886b6aa6c2c370432aa2e200204bd1941b229567cc46785fd63eae1c9218b0cf96db46648f92916ba463f0de971086f0f1d36306b79e5ecd3e450b31abd21d18e5be8c6dfe3ec1b4e2de2b69bb02dc753022c6aff0cc538a074e9e5b0b099d4361f5ff88b8526f01331c336defce99e93b8c33a3a28ca1c6bf2c45b9ab3a4e3d41c7b4b7491133a137b1f13b290365f675d715346fad22ca0dd53d936eaebdc84df3b891eced100fba98bab96ad5c70dae731319287a6446b1c86eb13ebe1a69b593ace7e444e822d273a5a5e0c25b2d35f00c628fed65ff62f2563b9bb7dbcc44d6d9bab6d0a7cf430868590a1320d988a414a0843c5244cda2e9cc2d84395b0529b2233b3ca296b728a722ad9bcc0a909f110b3ab1ad9eee893071e99a9e6b7f52a7036c01943ca2fbdce5515d3c94caf62c858e62068b7adfc2245293cfb2540dfe505a58b9338b3a34650af6b9d7de74ae21d58cf111380e06e7093740efe7d86ba0a68124b100cd6a77ac1084f296c0c73cb2bf9d3db0d70faf75f52e35496f85e6f816323a47ba21edef821af0a683bc26ca861ae240999968aec60f526c3ae07e74145635b9e7f3b604670e7461c2f8038e95ac43a5d014014f31d67a81f08e051a51cb581e3863c3542738c70818606be585c170ae5e708e3964d245f06f2b6f5d2ac311b560ea9e014c6abda0cfdd769bd0db7f9a89863d03361ce4bc65e9b90913fb7461caf754388b3cd9cf5f653d871007063aa2cfce0e0d55f31f8f4ff56d23d5e75252728f786657667371fcf00a1189c6396b184f1b65866c26f33059b47ac22ee9e83e9c7b1f72b01d0182f3f617e29e22a5601dadb5ba0f92ac2819805cfac6bbfe25109ac588e3d2cff96a434cfc634a6477e2718d5645a5a2d323a9b59791e89567d947d90e01d4dd7a79dab23793cdca8cc97b177f30c82e89acdfaaa283de958e45b6637231e0681d43c7602d62e6650a91b37b7cf7408a5bce866a66aa730097acceb9f77c294a102d08c4a8944c4c382fb27ecc9ad9c2f1f8215ef85d200d79ad4083b26aa4236ecc7e098907150d919c3787e769fc15aa4cc54d5148f1612e7d3829e778f4dbad9ab194c92f788775dcc4ff5c42cf9e864e029202ddcb53cae8fd6a6026af340f5083fc83e492dd08113af0985c1f3789891618afd12a5bb2553ba5d0111844cf77fd12b1e12aaefc3d48c2ff951a6be81c4bd37bac8400080e8f3675c429058a12f399b77f1ebc27e1f28d9981f1e57f880147c025678f8db1f0df0f7e109ad6ccca121dbafdb4854c12f625dcd9c640758e4d2b3493d08f2cd422ab9612a2bf3134b9d908e1c0447f100735fd005bec516ba92d8173c10d5976945db88a6d9bb3dc0cf446149a3fa850748ebe7888bcf61e0c83cfe51af71ff3e7648661ae3bce390277246f86312bbcd79e69a39df9b6a632dcfd090c272c4b03a03af199d2bb800fb1100b804c4799448f0c817830c796689d8b9ad81fbbf9d2593951651fb9523db52e497b1ce7a687aa535f6803536a56b5a4e7c05cd4092118cd9f287cbfd80a96a84a9e889185697779a85cb830448813107bce17996a2119be8718ce60eddf7e7261aa78a344ef4558a637a12d2fa8b9722c1b2f47273ca37150935b398572c6e7bdc833ec48c5389bedcd8685d3c0430f38441fb474c186631c96b4cdcf269c52863259abc25d51de6f5515a44a4fc6ee5772cfd87b876c4d02485858abfb6d3b8e58d86e792250f562c0b8dde4cb1cd597c5734874abaf0f227db18ab69acd33de8d2f88ea7c7ac4a0ef81a2aba4714993cdbe18d4b593f6afe0ec9f4b8885d797c7c8741213fd44efe15bf0270ddb81a74f0633cae91a7fd2a65bd422bfd4fb25af73ffcc7c89f1d41cc1969aaa4b684f5e54c755cb11ea2b93ea9b31d6cee5b0017e367222a548f6ebdc78d538b7da8f5152d10ffaae56627e11045e6feb06e533b6116d9e830161571b98e97667a23de37ee966393214826d7954534e65a818cc99e576c72bc59b332bebaf3b363e9b9461cf6e8cf46417bc1eb055d7badf29314d581c61c7a585548489861caed94f443aaf579a8fd86e14b0fe460755e85c11e7a8ec2bfb4b6690d573b7d04e315a4263425754ce532a3e1ff4b551cb8deb4ccb2a7ec77c5b21b8cd77de8c2a9036c38b7cad64b27320906322e4c15701933bc64e72eb597ef7b0261c6e1ad5bf11dd42e43ad224bc8e08c79caf59644e13d63c75fb3cecad26d92b93270e9eef71d5baa2b8a4ce062edc368dd5ff4d17a5d86ee60491a4fd7d4e8bf54eb93adf98c67be5b5feb4934dd1a5c3259846dd3479cf9ff7f48ff71301feb27d841216c5e9d15e53120003d2033e4cd45c174d91156966a5a5a941099b20d08b07973b9af7d3cf2b519061e6e195f8176a3058b853f0e7cb88b480136384f720f3e13bdc82496a05e70918fe58c25a5ab1967a75a0cb675d78a7d663031a13ce35ab7e1820f79780610f8edefffdc9e5484577c1af2d75bfacfad635e99370d2b8dcde8761b079d59ac01082919a29826c683ade95e4dbd0a3e182602f7b9ad38c406b1a8d038451044ebe552d74aaade1b8bcbc2cc7fec081090e5898abb72d2af01d8755038cb28cc1244e61973e4510140dd826cb575625e31378adde079a9b60ea0551a85bde2cab82626acb4af676e6c8a87a47675a427b67c4b48fa9e42936da7f20a6c22605334421b33dbae6cf27d2f6afa622718e6bf399c9a827e3ab4c4793bf3100c17c5a0c785f49bdb295267ac2fb0a0a6bc85d6e0fe2519a17a98b175e09796f74d372505290446a0aea339192e3c7fd8d957736c0bb28d8e5dd03f90293786209edfd71de93a2139c4ce4431e660ff2f605194b895c701fac749fc1b2c18f59222c5e0e1cac0ceace87828ab438abfff8d68abefeef8457ddff21bd6d818b30542ddf36538f6d3b6be38c835ad46859146d6d7b74588445fc894e8cbae06b8ffd80d50030a6c7dce99ffbfcc1cbad176973e5bc10fee247d6eabee146ac3a805c9919fb5e94ac42e7281f2d4fc656d9d6107c8dcc098f7d2e925a52683969154fb698f03c6e36d538e7da7aa889ceb8e418c5ed1f0309351cc199a2e4c5541c0fe03c20371b08f7e0b8488cfa5fe31844751b619e0925ea675044a141975c592c22923fe79cbd345a9c6d8339117686ef852d06b31aebb90d384ad8afab9c7e833816e492596b10ff2d1c376964a9643dfb635afa79b9c09335d8e905cb0f039178fcd7bf859b127ecdd0f1478e4ca74243e1b6d49068c831901f2ac58a3bcaffc9281f09b1031bf8966e910c85ae18af1409c4b9ee8fb9beee143c53f44b95648016b9b46164cbdcf3cb2a5e4fd7e1b5c4c1a7253854cf8136fd83bbce0309f1fe85c43a0e1a502f429a8bf2ad22c956a07138e6ce27993fccab747394cfbeef0a66541ea19e39c292c9d7c70c484735fd6574f851fd701a130d7b1bba2723169513ac068ef372e42bc89743c2687b8132578a6e6c52d5109ca213918907996026e8942624cc6063f1a814be57a57ce7ee00e17accc879f3d0b1ee5ac189f0a1342b7b1726ec77b3297b615bdbf6f3c15d74ac5df156d8754fde61d7d227b62fe2a782525b356d93d41f93aef505e6ba4221af4fd9f00aad00ad48e20d3d9156a47f52142eb3c1cc4e65a2918b9b0284c80469b0e48babb8d68a3093568d4c61283acba7f9d1be192c51291a819779a3699e551cea65ce924c809a45a7fbd3b91b3d1c20718313636140039eac10c6da19a98f10f0df5f59f8e66e0857ecbff3c2991345028e13e65951543235950277d91bdb29951cc95d5d55e31071bfea5b09da9bc60588eb53d14da28065e727374adc91d8e24b57a23fa05bc98dfd9c903dde3ebf8f4471a39442df6c99da50275b1fec073b70aa79bbc947443b8016ee4aa67476fc73fe4688cd25061c6558af1757a5cb49fb8574e4cdfc1f45671cce561aa1ae792ff851359b94cc58d95c5fce213ffbb1da9d9e9c97e8e8aad90c984c70871c98094ed84618a63d182faaac185916cf2fd8abe3fe12df1c9a5cec71813a7ff4285a497553824dad4ce4f6de5f95ead15f12233d250e8734cf5faa316e3615f3ac1b3df1060f24b28561738c114f391ffb808e1ed126cecdfb715148bd4790f6099bc40859f3cdf4f988ed07e25430d0bd2f2cdb443bbe5b900e610fe73a553201d55c722468fd02d0b5a13c9a9adccaa2223d78dc9752604df9b95d320cfd57b431a92f1b3fd1d46d944f552e45bfaf820fe8e87b1b5f61927c644a389e81b7e3590a4c811bc366e00d4bf7b8520db277453e8da850d31e2a557500600a3b11eafc69949244489fee838ae33ac398a26b79bdc53aa65b027902c562c04b0275b631f9950508b97fa4274d38f1423cae9902acfd6aef83f546c5f1d7ab5adfda0c813e3c75af7c6096325769abe85360fe5b5f357284c4bf1ba365e43b55cd89bc2661a939f2fa078223e0041aaf5d1d95c818355d04daa1f80efd6f41240f49322660708981b5c75575d5186f7d0c9c16ac1f53b1b87232df05117a9082c3080929f8da8ade4e7b949aab3c793f792d845dd9f23d2b562d40a724890256f0d405ca14420223722d82261ecb198873e97884ecdeffd735098bb1f97c3002c47239f233faa9ac48f468d3d03870e1f888c203637774159b033430f6eb892ca8efff87f1630ed389f55c8699f9ced31e69ba6254712efa8bf363380833130e8260610919d8a22fea01edc276e5d5ba831afddcb733907abf185773cd5557f1d5535448a0a3f111a0f3215bcb16b76409a4299ddbdcc31aa932be4289505c0534c8edd50687847b1c22cdd08ee50e20d09664ec530d7142f5b7cad015e8f6d68663237fc3ccb6054d9d1752f42a90c38a967e6a0cba65ac9141c85f8cabacdbf8ec26d2741d4fe3f11b95de469ba4f62c273c76ef40d0029e2c841ad3579af2de9685f0d3173038674077f5b907e5d04bcd34000c0d165cfdad621f66bab8355721ca3f3bec615cd6cefda5ccf4ec8937ddb8ad514bf4f16653934684a1cd35eb0a6a0a22c645625a19abde88b4facca07112c850709669cb1f3885812d112de42cd6f2f213d3141adb7833d7ea0a9674b3f9d340e7ee88c5595a30001c8bbc17608aa2ee4829da76b48cea441e6406760fc53ab42ad8d0b24e3c905d9c1f2bc5696c4c90f3e874f732b88b362391eebb3c6a0637a3eb74633f89bf0761b5da6d51686614893001d00e399b7737ead3afea0978cb965acdfd05e94af7edb454b2e06f8bd633b1788328efcdf767ecfe679b62163f5f3c547bf689ffa477cd254c438a31204d604aed25f0f7a74340d013020ad2b96bc0d6579715b46153d62200ccfa2435a6036f1901d5f98ccc5807fe5a0dd6d562d182eb28ba128bf49d9de5515acf897c375c64542267c164e9e84e9449ff052871c2f443ac5e81932a9720f2ae14261def24c6d79c5a5f7a4f6250d3d9306a6f90c649007c1397c86e42e915b9d62322de8bc9ce595aa76ecca5270460ac144eaf97ad9f4f5dd0231df0e0a2591d09bfdb68a5f4d65ec83b3c026048679c9eda761193a2f0b97f4b64968379be4410ac5e2a52e883c426a4cd4a8f41d9710613947e10cf6557f7e33c546c45a7b50d911d31740bfeb50f10227534d3ca6976f6a5dc0ea70e4c743ad55bb939547eaa73782b4fa4f36aa79e34464fd8dd82bd824397a6e5e534d1512072f45ccb709399e83107f3017119c687152cbab777ee0eb8c48493040226823fa64c3e4c11ca3e0b307eb423e9dab5ac81d6f476784b907d9e8b00e40a1bb1c7a3ea8484cfa6bc5bd6b3b9ec50441619d8a410183ffbee161f147fa1b76cd4e79b87f6d61fb51a8cc1910b52908187f4db81fe5962df74210a3acea527a6f95a4d8b62fcbbfb8449a4449fbc929a65e5fbd0a51146053018268858ec5cf123f2e7d126995fd55fe56c82e130367d0fe75b9fe8fee65ecfa1bda951b1efcdfa37e9611a9cec2c8ee2ed94d8d8370435124e5f7c414640189611a271f3e8f9864140ac4f05f8a3950680b83f82004407abae9445888080d5f6f8f1b549bac967af865173bc4f7f581572c8d68f547ea40bf9d80e1dc10c7a48651840a41fdb787b1c0843a0ef9ffe9e8c781cad74c6d26fb745511d2f1655bf75aeff0265129f7710e734ffe82cfaaa44e4b3f0a802f012db1a3f8be0670f4a366475b7c67d99d47faaae1122f79adf6fe9a1dc5ee666947efcaeee1b5059e8308035b317e46ea5ced0545e8f721e6a8ea6fd83df34b105744cda21e94d854f2dfa1d866136be867d9ad27071d0ab8b6251f21458bd3fec132a7ac3fdc00bb9f0a1a2e98d72d89d52ac957e9bce863118c3d5fdd426e36f97a41ac4e73236bb3c48652296e1f17cd3c37df66e53bc313fbfc9656948d2caa3b8a49f3e59c26a00d77da76f26ff016d7768b2cb12bb773d186bba3c4009431b4ce905c32c877406d96a263e33c826e7746768e26ffa1debd45dd44275248faf99ec970a870781022a3b04cde2159d71d5507154b76a366cfe04e8c518d833462055e64dcd7bf19805be7a7749edf2e8cee352f3ef525aea9bb514bde0520162180aed74dc5e33a69eb0db2e7d40bbde01ba170c7f6346baa8f70f1601e3944b2f936b2346b0a519a935c396b190e1b73854333425978fd153fb19d6deaed1ef136ae34e149de12457360d14dcc5030202628a9ba35092c8a3451ad097e2902ffe3ed6d8fc73bcaee98f8630750ff88e01c035385de93a38b5d4d30c4c164a1d577e71843e13ae1abfd58d13744be08aa0ae7397c63c207bc08c24c972ad93167f4454c2e1d16a961fff34dfd459943bf33319ff07636c04e606118f0177089b90b7e894d4e0619ece347f7719b53b4464ac554aa1cc86926516ed84366655dcaa34a68290c4200506b130997e6f1d1849f8b62e757138b2d46e1efca35971d420f57e0da42e121ae94d8f7b257013d1f466047eb3f0c1b2bacbcad051b017c107296eb0d87562eb74e39c91cafcfc4b1e09c87665642d14fd2337adf263f2a9a438263aacb8af716a7edca0d5a278f6371cb6e35e5b8a93615a5e1c27a3b656dd83e41ebc9fd2553404473afe70ef95666f460ecb358cfcc557bbedbf866e82b2f485851ad3bfe28e7ad8f474e86c55f6578f7c7ffa7b774d341d39045facdee3d45cf7fc22a8f8a19b218d5fd632d8a3cff6e03011fb0647af26368d21ba76b6b3295ed40479d35250c61f945591b267475d2464f95988c237782fba14693d109ce6b5d3a8ecef9e3fd053a2a0d080a0599a906d8308f8aa21fece4d0f36b9bdba4dcb8ee129a426c1499b29aff779e748402ee9deaccfdd0327c5774f28ed757340abd91f8719e442b0c3a03451b19bae7f3b22a051b3013c9b6805b39475ae9fdb3c61cd0150d9167b15413c611fd5a170beb54aa6fb61697212d7fc827008e9a368ae710ba0f813dce4b3ca10913d6430d9c0956c4a7cf34884a880e1b59274d0c7d5d6db65d2a475fe6a355626c9a00e1b7377f6387cde8487e64119e62c89bf4b794c651e7e7bc6f87ee6977544146de899262e3345dd930442989d62d26ef911ddba8b54b59b8f35a856bacfb8e2474d9b72687c6c44b4495b939a1375788545a95ac7902b36dc0dfed5cd63cefc5882d532d4121ee28f3328b61606d2496df779024748603d7c819ca9908d5451293fb3bdfb72114e526b714fb57bfbf944ede4be08a5c5c9c2fb91235535ded948e6c13bfd9adab9cad989b605cb63d07d83da7325ff455654cd6a35d0f0322c80bba89c8529b1cec5a6065d4b7311d682713104642367fa2289d89422f542171f2c6e33e748f36a682d9e16ab2a185a28b93c4c47ed36f0e2f7eee913834ea22ae88aa2086fc399f365f9e16bd2b25d036a16ff44bcc71a7ccced1ee231a803f9cbda06cadba870585149e9d53dd5e2262b4c99c4ba78fd25f9fa5aac32f3ebfd13bf5ce3fc1b99a85042210f0e4bc57b925987c08c317ebda104cb898405378e8e435fd58d230d788fe6ebcfd9a7ff805cb5bdec372bb8675cc20da4c76858830a38dbd4071c6cc08543d804676e7b91d464cc2029350f44c767dbe38570f86ae6435a3ccc078bf436dd3e20ba5c0f1c73ed1fbe1e7618e4eafc26a683bece08edc384b3f95209051","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
