<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1b3e012d992f8a0af12f256028cab1581b381d7a4b3faba6150bba12c4329134d5af0fe174cdc0d5e1a9e7880d33a8d32ff0a860e1882e61aaf1e7daf4ebfcc38d374e016079c049b40dfb8b29eb6d9c459f505feb7388c0686f8d98a7989721c0afa0fdccefd6379771b294b63f227cf2121920c4aed0285017ce22d471a3ce6b9c39a46e5f3d9c16b8028858934864273ce7796e0d7e16292863d2deed1d943783756ab0e9e777ef4fb66c8e22e290538062be7aa9dc35b70cc7915d148faa969a0da0df527467c262634fcb0ce7d4aa187eca2ab1248179e0bb81b97e8e41cd9678183bb0dd1b6cb7d8d266684d9f3f4dbb2a54345d9229c56c908f17da941585abcf6e5279af7708b8449831f572e439a1a2e50b5942838a641e7a76559252ee3373b476b6f0759d8408a551f93318e577eee943268afe797098ef83d7787207a4b6abf77a42fdb3a08c71df46601899320a5af26e7d412c37f90f9dd769bb862e263ab3a2e276e93f84c257cc89dcf8e53d4211c224f00f3253f4f777b2bed23d8e3b30bf580efdaa1c256de33995bb5c59225d497c30ba1508e42fb5fa1a01256f1e720b2450a3be99d36c1b8bc2563e359c4429f970ea8094a748fdf5b487f63bee2b9e619af5b8a00d561e4b264d074f828037f9ccf6261c019cbfe8b3ab209317a8e04cfb7e87627305103fd15fbc95bc33239ba659fbbaa6f65507d1dce7f80de75a5be7df1905ed72af4c90628a7fd3b6d45b6221f5f70835c6cc9caffae26650b6a473b88aeb35fec0a016bc67f5b528b58c7999118799e343353d38d72de91429ce05d73e312cf3ddca74edf4526dc7e651940dab0172c56008b19776e013d3a04fa4626f027255ffe497bd799df4cefb15e16d0ca15d866d29a1e0a8491ea1fee2e58d8cd45907756aaffa9bbe60a0142532efe6163c80fb8a915630867b14018b8c95793395dec6b0fe077494540297f7c6dec22fcaae36199eebc8adb020c2c296b3d20c8f8dde7e5ee9a144c8c0b338a1f437e6c026c716627dd0230cf24a1bc9efa6bb2f079af4856946159242d3d2ca682f3e14609249e4644a1e66afebd745c825cbd0c6d7b2e932673884618a397ac300f9d98a51c547173acf0825ce5229cd402c1fb3fb7f5fb8ae61fce45cb0b81d6432332bd08ae03bde81709baba9ce18747bea7778198a49cc09802b84193371cc64f654b752f135201316593dc2acb8393301b5220510b5037b8aedefc3a9f74ce43b84cae3ad9fe24b5562063048864ea770a35acc0cb3362b8d5b7c33e7222181960d85aa1cd2dc4176e6ae55f9d880967d3e2de615318b1f046a325aa07793b2221331842b63687580138dbb944aa81c4eebd6fea69ea35aa4190d824de67355d018f8def76a52848646715a2f1d177470e46eaeaa7fcc9140167269b4025ee3d8b1073376c468bc8d09c6b6f482e3fa09f4b2a5f5a436a7399ae7abd771d6735631eb5e7210ba3bbd6a623a207130b6b59c4633a8541f69a5d049b809da91e6ca79a453edd7e5f5afef181b5e707b7d51f4df86bbff9a3ae1863e6e125cf2a29be70bebe490c9c15ab92e190d8e60d818ef57a783a9b8ef123c6e1c46c87e00e6d4d386a1ff7e7235ea7530f0860721d31579c2e37801d55ba42d1b5010d3cfba70108c5a413824d1a748cd981f817b31816c916e88f100255d18208a24d20f68bc0ff2f533e9a35cdcc08d8d38c94b917e31dafeab8848a761dfdadddf7b9236d9463f80604cdf416cfc5669ddbb8a67daba4a95a82bac684969db52c1f2d85574d5a03a834b2adfc3cb650b0b79580010838bebe1c72269142a8af96da194ba0e27186332d7200f653ad34f56258445d07e34839bd51c76b597028e2f02cec31d443850d80e4c472decf9c14f249a337e7b9a6dfc5fda04ec81b963cde9390e7c5149e41937bf1a2f1a1ecd4cc3d01eaeb48e76ad09356b3914c421e37a9d04092038d9d6e0b6ab93038c9d1d79c1e2505f16e9c8df2ebe37480e3eadc8afb70f8fd0242a7aa0258c6d7c4a52d465ef0362353d1a93d4f868bf730c324eafe5c9a2b52f00f7bfddc7911227abc24924e6cc235c3461c77bb5fa3a930bfa7965e76e119966a6a71772548ced0c83aac9a4e036ff40f7e475b8b3959b4750d489a8965b074a70dd8aa3397a69e72fa3cda4bf2e30ae6d8bb11923e3ebbf39d953dfd9a1bc2d4f0fffd39319d460d22e43a0814230a449169945d3968ab25a088899d3a654f5279458eab253153125c72e5da3016798fe1e3b9dc3239c40d56861fe75be3ae27edfdfdd70e104f1d5176188b9897a563e6f3f2b20b5a3c3a324c39ee3eb7ad70e595404e9eeddfb0932bd1ce3c06c5020c86de539605441fe27e8cd1b3011f094ba0916493278ae97cd63cdc4864eb8f704a2dac05dbe6551595d475117331d4d1f73fd8a142e97647f221580c824988c8f8573fb21a6cb70d9e75e175e8ff6426b7c75e42625198e4c21c7da91f6a84ac6548543a4606cb1e435d6d38858a999d1f5b32fb784c51882059beca47f95a126e7fb04d0eaae74dadb51318247d79acf8c394fa5697b11deff94f1fed7db58e5f6bfdb84d86554bed1221357deeb773af64813dc0d3b3c5f1994ecfb24aa5403b8c5d9485c98a553213e77cf683cee7bb9adc5a5f8498bb42189c4cb377ac49b7b1a82af458d1035d66e127b31d28f3762995dddc2ff3c42a9847e5a4f4f3e4639acddad13ef8222c6f4cc48c7505924005940402c8693e2648a142060df22e0766217c227f6e6a3d6117b7ba34a567391d7b27dfea5490909cc1131d9d7a98d7e1255fb011801728940608c4e21acaf788e39db35623b5a655e3d58da01eec74f995774bbe78d2abca1a2c8a6fe7e6491a8d2d5567338ef3770a3229fafd0c6a2717ef97b7dd4a60d2d648cdcb3d57658cabec50eaaa7d13a156ed3b719413774a5b70188d68d7f53ba7071f7f35b0ade9495110844eb6d0e38ccc4dbb86e704de64feec2362e1e524b2ff6348b8a4e4099a02e498b300e67e8a3039024bd452db2fd84dcc58c87fcc151bb076c334a172d50c238455884a6acb70119197fd04ac53ac00a4a51c7ff26de74ee5998b859c2aaa152e21755ac08437d87caa86cde58a5fa9d5b15a0fa8f3be0284097269602acb3d22d7cc090506e7982d39ae1882dd1e92ebace7ba67dc8cc3a929aa4d9261639c3e656937e3ae8c4fda816da2e6d336b8116582860504cafecdd91d4a918a5ddbd8f870be490a25d4c607554000b1bd0c914f107367769315a0e3ce85a222d60387bc6c60d443ac893480c87d361c7dc79bc2c009fcecc11a83522a7bb62988c6ecab235f489945f2d8cb11bf656bb80d099c689cbb862fe6f29073d32b1073271fb67a9a6235b45d61aabc02816f8e0347c465f0decc2d0bcf54b5bb0870595b887b6050a24f78721e547e83799ae563f74ffa21c33407e26d554f75863838b20119ba5d51563f95635bb822891fd6e92b28fb0ef20056716f30a43f9a5975c04ee0daa2d79ec551bdf3805d15b792ecd8577b650729be4f2e798c32f5e3cefac345ae527c5183d743010808625e88b813a4eadec8fd8559ca3b2896e973dc0ca9dcec065b6dd34e8805e8fc1024abb3307df70986983332c164a00d4ecad410e6654d530e6eee1c4706d4f63fa1952dcd587da41485c804de11b4603ea810f30136e98f5f8f7e42e584ad469253311f87bf1b4009df61398cf3861d70f5804883a142d58ef89c17c8d48c060a11372551c30ca43b22af0d216dfac088dae6766c43e84baf291898de2e4235cae6efcd9484071ada557f7805c1081444d0c9c6a8579d7a9b8084174cc457796e6c4bdd3531def5e52ef46539fcb9114a065653e6c628fe612c364df01544096885ec25d00d29b85c79896c7a505d7ee63ad0e336e26b277de28108c6de171348fe2b9aed719a8b294f8be27426a16f20b43310bd42d37b159380d48f953350c542c2c2970158a621dd762b87ee9d198dfa7eefc683c5ff27390d2f091dbdabf848fa29e66aec64d1fbc06b46b9afcefa26d449fdb8fee18848f467da4e7ab9bb9721e50fca1308a5e663100d3d90d1e947c7f4aa5970c10abe497967632bb249cecd0634e554deaa32862c2f2806ecfd36b2326c284e1829d78ad20aced4ee24e9d6d11211b7c5583756ef48379ef57b0afd64d4193e435f6d7502e5312a51e9f0703013aeb4a468a5143042c053f5ec80b41089feeb9ca05408af86e5616d95e907fcbe632ca59f6dfd2d68e05ae0c387d9b7bc43588e486242180ad636562e652ad1b0b24eed78a21841e66acabea808d3a9bf1b8f656730c6ab779f811aa1b0c3baedcf2845c6b6b2e3c851c97782cbe5cfa482a9c34e8c0ba7be8e7f704395d311b6fe9dfdc14fe73f305cdeb2a7eedb8590e07d5f7173d81f6d49f4094c5990515ec6b74fbb3d1eeb6c1f8ce7f556305dfbd0c38242b2ad08effccead9bcf4eb697db3390e7ac03d47286d430ac707c689afcfde9fa59c6dd0678961c82dfb3adfba620c9287d6926cd76067344785534f04543b4425bca4c0a118b8a0e797a2028c5b18c69621c8381fc61d7bb87a17657aaa15219fc7e202e2961c587f64c51e5107454e94cbf482ee56d8530a478cdd4c277788bd2a6f7e3124f171be426e138b1b7a1ceb127f98f44c96557f71d312033d72954d07d703dd5cd19f388f847cce7070b1930057808db77005c8898a808edbad4b1fe3e288b3a6b5ebf8d6a34e6645bb3a58d2fe58b05e69587830dd444180661c0d1ec91bd053992bb09da839b42bba4c5625957d2532ac29c822c656b97044450a884dfd160d5bef33ec5ae10e25e936881986fa51808087b70424e41fa1a3a060c93fca7b56d9fb044ebeb77087a0e3eab0681224e124ce09c47b1c1a6cc568a893dbd2627630501977ab8b743a2876ec6c8e848aedc0d2facdf90e45e1f453985ea084e879953275e391c825cbb7d95b85f450684d8bfadd2cb8d383da3071344045deceea79917a1e4c96f4d0e15d2c30083d291a8ef3679230fca79d68783478e93bad1cc562d3a377161b6cfa6595a22f3a29b99088bb260df17e4a8dd7ec042d9c0bb639c17c5d29956a5eb8a3e132c3a1edd3c325e290d6f548f6ae73f839ece8813b4b5e43427ca9b3ad23bbc97a17017d52772bba9f86172e7a0b7a13a76867719998da83cf944468a56ed110c0b2433fe8181b1fa6c72005c7faf7a144840e2b6612c213d1d0b9f3fddff5ccbf005b9e4fc07a03164a2a226c4d54a9a36ebb2fb4ab15e0598819144ee8e33ea3d9210e3c6fed2d80eaccadcd2a6bb9bf18fe26800060e9aa565f46cb0c4d1de560d2d2912beb87f61488a2d4a989e4183c050f272d217301b34fd3eca9fc53d28df510828ffd188c72aa1ea6d2626a6744d9543901c1bb2730208b9b85c66b548ffe134c2383e85d9d2232d2e28c36656caad5025c5a8af5c0aa6ef0ea57e2925074cd96f61f35d2d6898ff39873c9439510a0372518087da1bcb905ba5f34a5c7a3443d2dbe894cc8043de7955f20ebf5890301a9ea07f87d6499fe21e9499b6a20206e05c9dada679d097be1e9a2247881722d5c081a57aed24cba87a7c429d591fb433b56634b28c24212f3b80269f9f777d74f0895ed30505a6440f12e8a0b531d8bce6b1b7d6e88c567f822dc85c095d47d7b23217c70c10da7c2f59a65215e0d924b6fc9065a25a9b196f1113fc09014f3cd90de097fca635fcaa243643ac826b10744b63e8d116825d0b802ec8cd47272cdb42e5600db5e0f93dc683fea8172b9c9f4d8dd8ce5116da4298c27c1c0042afdb00725b73c0bf98dd822d4b972c80cdde74e6741da1a58cd4f82c4e6742d0aa567d4803a2ea7141253a3a974fedc8570d9ee7da6f6233d775ece5fed86300890086ca78726479a75c898684e693f8abf69ca91b1489bf5f48c35130ca95943053915aff9b682e3e190b97bf04f756ef4b8ba87d520e3471f05d9aee985857e65711abb1314062058c017f1f3edd8b51ebf548cc701f57a3f4366d85f7c7d1fb3657ad75dfa55854d7fe5fbdead5c09365be214dfadda01f0260cbefff1971c59daa8aeda43c0959eeba7a11f10df4cd3b0325cefab1ab7aa9af5a64d660ab9d1042f1ae308978a7fed3c4b5bccf765638710fe3fbcdfe08118911fa6ed80f4a20f4816ff86524a7426282965fda16693f7b3494ac6bc54e7a89f39476514a0652c788ea42da0255efd77ce96496a3f6332d8100492f4b79c4cb8d92c7ad16c46dc533f0d936c12e7377530bda89cd218d87534febbc892912e737a2633651e57659e90ba9e262450045e4ff6a48db1488b799d70fe008e5a434b7ab7c8545e7bf1f9e76d29826c8de786576587c7a371e8c4f50fd3964fa3af31f3b2a86686818f956f8cd1d5a3c7b3c507971aad6a01af1b7ef16231bc1f9a8d3362006698e6b27143b4e6d397bbe8fec7fad7392f69d1039c17db4557f0ff66da4a49fba516565a9140927dd7a45705a29b0785648f110b803bc56b9bfb7f518831ce38a49a6d6bbf1d2bca242dcefb58a4f2a998c0c606ec05883f2ed935b2b9de96fc2b80f300b5c814adfa2fb8b46c99d5381263c33815100978c01091de6f9938bed904770ec006eefd1699b0a3805d292706b4cbf9b0cc462f5f0c853b177465252231e96c30702cc5cd72f5ff3d9f33ad050b0ab14ab7763db1edd103aabe9754fe5f8c96412a1831f57442e1f7767b89545600fc40a7b7938262854088f06647105a442b99789d5fd6bf9917a450f1329c7cc46252c65b235743052a5a23cd6cb2c9f0f69c4ef6868b91332dbfda71633a255ceb424058bcaac798a4a837696405a3f2a3c212e2f92f94d04ca98f62b81640532e225cdc0f123d4af18fe3e79154e901dbbbbe72ecba2e7d409d93c62defd9cb40214650d87e098ab1a4c4d0b035b3e91abd73657f3047c3b6a58b262ad561fe79e5caa99ec06968c69803a057e7699ea68c5348c16784c44dd0d11c6babe253980e48a20edebe3679fc7afb9cdb217dbe398517eaf123cd314768271909ea3694784c225bb47631719008c2741dc6a28e15ec35d54422bc6478dc1d35a30421f75666edabd20739e2e76d8aef684c98e0bee8fd10c49a811510293b314e2076992e34791c413c5bb91fe2818b3aa0d84650d4506e132565930160103fb4f86fcda432323251c0787dbcfcc59f3494ec1ce19784324486522b4519a8cca7b382f5abba4aa97a593adcf303ba503093a4ea15cf3a4779f77e98050bdd61c25c0e19a70ea30455b7783818c209b95ce8b64497877387fff366e6d1d9078e79a44125e01308fae17b191e410a551c1884f9e9f670feb66fc3d5c3ba4f94d6ca863335f710d2bfe5cb5f6fbe73141c89f3603ed3da883baa70cde0b2f3ffa3e53b22105f92766bdbd65d3e1fa63fd97f1aee612062922f4d435a786a612ab4ddcc81d1fbf97280d922b18dd16cb27221ffcd844db0f75f4bdc57fe2d34a14b48c85783fe68499f4cd360b4e56ae4d42cda67863719246553a0c1866bd5a7644f21a6a3a56b8e85d082da61f03e07dbcc152e5907f51049952b0c56e44c040a52515eedea11a0e5e2252428691f174ab81381963cfddb915be11fc0bede668caeda7537ff7a36e88d54de65c201ef82631e7b1f449290b180a0ece2c34b86bc03cfcc417d075a09dd6c039b598544253f9d67d328d330843935d3aea389734a13062ae96688b60902c0485759fd5e0c346b9bf35e0e97210c608c533a2d8a557593bd5350a1d4e52099407daddaca0c23f0b69cb9997886e27f699168d65dbc8978f3f552eb991d97799e16ae4b6bed382fd897133f7d4897856c9ea94d5edd2f20f7fd850123698af51838789a8bea5e1a58f0184ab33ff2d99abf328f7b906c9b90f2898b5ba5ca93614cbcea8ad0494173841d2cc642b0564eae728e88013e4f6ca1392e6b5af44aa4e48c7302a6375cb7609d36d56a0976556d38814109f11219b011e914bfcc93cb5f7afc833b795f81bb2b401c1699ed5c3aa5f07112f0d644e9d5874573f6fe4a8260156ec68d45b94778ad35ba4fe927797ad61fa90ad46fc58386cc7c32b4eaf28ac55791ddba8bd6baf8da2c01d26a45a269e4afbd66991d3f03917412bc00ded5cc8bcc203b818e0fac46ac129f153306f71dff04e34c17133f7c717486fe15299b53f5dbc49cfff36234a454d246c652ff9db1f1de30a4f767e9ad0e6b7e6981c321c9d7d90eee13be06cd4d2da1018ea0d781ab48f068e095dc82ffa041f5998c36507148d6a0c06d7977713b965238acd0798a132c0af3c8afcd48e16764573c52caed587b47bdf4f946ac919152e210cfbfaf3a8238ae5ecbbb6f02a5a7d62fb3efd4582658dc13f0b0b231feb305aa6e2b5a638a81760390d8cac4b87f9f5520abf72f8f6ff20380d79da19b868feda7e6d3e714a5d2075788bcbb37cb706990a07256bde53a93343fc89adc62fbf62703773cb96418bb0867669a3b01b1ce9a279d5b30128d2a43267a27909b0de147a5786e59a23470bbcc948df1af4bf7fc78e5b5280685d9a1fdd79973406a75018088e307305ed5f64bf39ff737d9a9ae265e7de1270efea1c638cabaef20f2f9b548e86393e20decdb5902e700a93906c04d7687462cb5170dcea8928317a61f1a5473bfec4c664d2b7b982c5b8f80f77cdb80eea0708d3e62a643af934ea53f7e7e532459f173c288d25068fe3fcc9ae438d3b7ca6b5e9940594b833462e25dad2995fe7c5abbb95aceb4047503930c3d3e1cc9891be6a42632f75d3fd30ba62368268c20c285d0549feb8ae763afcc036faca7f1adbc20970eac8b440bb2d488fadca81d178ff491d31c7c1c199d4abcb7a0b0b3264f3e88b4815da477a8f7b70988d539353f69f8de3315e862bae3db3c0d3d8558a18c9b5da8a1965f09b348a0a283f8c5d18544f9f25a40fd208810d2c841a446b89f61648ad8ced8721505c4586237038f1cb701c2dcb5a9e8f2b8ec5bbc6e0ca72df0c4f5da3cbd2634050b174873341af68dd25f612ac1507d37533facede03d5b353838bb0eaf37c3c3b6b8f8d81f42db83767f3038e90d41a20575c6910cba1e0452bfcc9d69621306760c20b0837ec8c23855ffd1ff57394124f455321cd91ffc0e5847c0accfed9f3b2ae58a6a108db223866e5c47ff671eccb3baacb61f727774a9bd3d7af02d46b27ed5cdd995c877db5cbe308f80511e1b26ef38ab8ed22794c3db2889b7fffe2404dc40f9ce7dc261fccb42596147ea041e7e6850114c81f509fc5e7d8a09d4441423c948a3d61869525851fc09f908703bacfe7121270dc0543e788875b2cd4f473b744db96bb5372ceec0ee3ec3a070d588ac3e687196e9b236d3f870155d3e9abcb9d6d208df0d532c743d56fbc8d45d31eae0ca3bd14216dc435c836fc85fcfa7df810d25f650464da0877896fb9aaa0f0b0727fae61930d49b0f532c8aa4ae175ba39102fbff4f3387e9ad73b40eb5f81dafe9b935fd901340991f85d1f0189e3f4f6ea307aa0e3d9b9b6c4ecbccd28256ff0b6f946710cb5f32f154ced0a1e432f60f73732582b6eafee6fe6f54f842584bfc10adc981681ee56978fd2cc2b90e6d2b08f197caea552fc3f09756122afec77b48d6e11013bf2ad926db48d1f8ffcaf97227492f1184ae4c4da28bfde025cca75109e0dcc1494455367e0cb85dc9f9355780e2377d92004b5141ff31dbbfa4afdcdc0790d38eed9491d3e463bacbd012a42f7f6ecf3d2535579e9da4680441c78c88d72683adc8331db6caf12a25ed1ad10fbef10cc63d0cd037f3662dc5a3400f5d9c7a7227bd5a07f0fb12fb86cea369c069c36cfc24dd6aa31599dbf80d78f340163483f52199e9d71181a881e94a39b227e883e358ecaff0d2d73276c57a34fd7b7d10adc2b4610fb71bf8cda7307be5e90e381ca70a8abe265d45f99456a214528837cc0c09d8e0c2283398c82ea89d6b16ebf57421ac443df55384962d0393c5e6b35b5d3456f46b80504c63490e42de38c81c1b725d326885e178325c2c1c00f6d9dc2510fd0bcbcbfb2b95d9046c2968eb4091b92b983f48211de6df04306cb42972224521e2bd6bb04c725f089897e8da405b1c19a1abd39eb6b2ce82dcca0b9a0c0312f2583d8e7f7576ced61c66fef7d012e631e0edf423ff1d56b46683b50c09010f84e9e61c736126779b823f8a7ced4ef61b433e9e340e35f51b174b547375aae2b1915e2c8fbee4ee32f1bbcac69425067b9ee40bf983f5690bb9b30f6ebb8432f4be9a5121131255c2f3b6be0aa6e01c885b4f4343c8c52f432f7484a63050720ada234e3619f08a8b630ce1285f88edbef441f515ad66f60dd046eb37c539141776f9ca7ec9576ef1545f0aa612c76ba7a47409ccde4a880aa0dba354e5203191f8c6f52a4371766f5280895f6a8b7df64c267b684b3f4545813ba371e17cffc31e50b0a90522978fb535e6ff7bb91bdb65ef4a491da0bc24986a405c6bc8ac96030e2f81d886722972180ec33387978e12854b7d5db637ddde4ccf198f5258294f688a600956d632e0b4f917d2bcab57adc7507f4f96f4a5ad5c50c49f4a5107383660c1e72561e40e77238a8f6fa25fb92dd9546607a4b0ca908b40241ff3264343802486799222f5c6afe12c4f137c73f2867225bdc65d9ed73b97841599dd9c111c1aca6194f1502014dc6cac63366219e8bd8e276168065e4fd8c8caaa62332264ffed72b4430e610b2d59a167c9f80e42cc21ac82c3593ac49843ec6cf6dbdb10401d12af3ba0647d1f18201dff4cb2b7611ac93a5d666c2d335d236ae091301420f58995df79eb21379c9adf472f8e1ad60fd96c255212efb98f6de7e148b969eb56cbdaec858d2bb6499b865c2d3a6194754633ec0ac469b1725279c250c8e0c758d8c2a3933049a102171723017a53e8c25136a0319146846024fb8b6ca615f237a40c0dcf0764675ac6ee8361cf5ab1443e9c87b81ac39f5a103c233b0c635a4b423719c81fc8967d82514b7bcc81185a31352965f3507225ef7a03a22106914819ea01ec20fab98f46e9391a8de3b314fe7489416ea855ba324bce4fe2327efab2b754056b26cf2a6caab8c8c1a73e272fb4858c354f7ffdc1df9dd2944a605702ac81b30106cb584bcd51a8f507f1b8bc3f1f087f94afa561beb69ef47841d1c414b33e8eb4ae1e6793df4c8336d11cc89f0ed8bb840e1dbc7f505a66f4717e8e5a898523f76424058a009004b31103bf5e5105efb030d8ee0edcdc740407cc1359b000cef976aa0b89902edf517bb2279f1f287295f1435dfb85bf0ed9dba16ed576d502d56b217bcbc6fe5240ce8ff96baca3f13ac3b05f17ceee1ae28f765ec8d942b9442edc99bd10bf9db4bcbd02361e2c36783da8fc1c62604bf701d080a12c4cb736162d0bb49bd50faf84572217e5fd023518a881d9d284d57fb74ed87dd1f5a3276a3ecb0aad1d38f1d2f518b9b3f1747db013be79f3580c9206a520d424a5b4aac193722d365e3d39862037a1ec26d97f5722f032f41d97f2e05467f20476316e2098b9c25a840cf7f2305d8c5ad5bbe59936052ea6092a0fa969f463341154e0300fed57a33e998d9f995aeeb7b1c53e06a89d493976d7aa2c1cb4843f0d2be6176f5b97425831d08dc5c6fc9ce2609fd535d7b9324abb7b51994469bcc0092bb555aaaa4c60d142146804927bc0e18763d5f0adbad3aba6438800887bcebc54af11e6496ff1055ab88d0c18d2a037134f25f48e1fafd1e0ad941ed1755546836d3e8091c1c316564f5d6fcb564de6d5bc22a05e338c9707107fb20e6ae192827295bc6f1061b5b6abebc645fbbc9f4df4aa405b4d62b535eea2969e2685f857a6eb5bdf648a14579cfd61e3bb30dcc148294adbedbe78f1a62411163fc8e1309d8c7021021b9316be429e953fb550ac68c27e30a14360bf85aa728f21ae77a583f7ce5aba9f6d847bf6e704a443746fe50064dfe56effda6ff135963c3f2573093ee99774a3a4cd33cf3798af900edc98421c073e3a36d422e6958b43c65f1e16abe6ce65eea2c040f0898f4148b899d49b4045a6f7da0705ae5d87b91ffcb94b3165d2bafd35e7d7f26e275d02b18fdd0f3295e0183006722bb7d9a1c32a2fa90120949d4e28b57f4701530ee2d7cf45b16d928d2c78b0a0160bc00d8b3a2238925128db3700b92f161da94e1df2325b123499bbd8c00312d0e1455a47d536179f2da05db8074f3389d78b4fd10cf0fd8d9550ed29146d6851cb24cfd4c2d8aba20b4b8c79182502d94bbe98d2b111482de0a04bc462c748fb98e4b72545dfd43601422d5cb7a931d7ea37bc21174c5ecacf1e138f1fb24efee430ce8718425b6ba80e4f04661e4c20a7f990e45bbaf79b09c8ae9e347bff2cf97d55c17c5612ae82408cced4bb10de5cf321c3ce7b4cf134b14c44a9fcb82fe71af09b4c81f33979ff444d4204115c5a192ff70dfe428f754762b925a6aa8e4844c4a35d0e1e04b116fe0bc04f8d5f7fcc110fb449e2330d2bd267b05db2d2813e19854a713be9f4a960978bad980374523023279f7a5b739251bd373884e8b208018a3fe648103ba29efac8ab6830bbd42099394e37bd278952103591956ca3b2265a84586f08c522868739cac580b42f8ecd93f583626da20c923e6cf1bd8ea113501a031fe6b441830bf5315d2e3cce7a9339b148089cd7fcdc3cbfd02c0012f253db04226b4fbb54e19e2b147efc362b39810cb9482669479d5f149fdca2076a139c7c457b693188b5567f32323261bbf27578176daaf0397020d68551e04d62117e38cd901b619a3479812e0d4d41d64e78edd1eb73bad4395bf2b90a49efd6a8fb1b88d72a65d839b160d660464142ef528011e74d07e69df1d121399c58c42963e280819abb14369b8af4e641abab9de66a6bc0818d40f2b11b0bba24cf5cc71b87472cfb44d2316004c17e43422234860a4787cc7edceb14c78ef5f175c92ecc2e5c85d50ec66e794d055b9044a04a5ab51f7d387418e810f5078c3e386550519d3aff57d9deb1bcb6342842239c08947828fe1e947c2acca399bfb2dfb8b348e053ffb7ec9fcdb9182056c7d73c29c880c59731c61916086af1ad429e0cea3c16f70d69c215930860869c712ff28eb0eb2c3748083840de0759236b30c33dd71bf66cda72dc88c6ff86d6c98688a95f5ec928c5a56d9413c409811bde841aee5cb1ff538c460e7f3f46395de1ba5a3946af8de804c95b7b6e3fe9758ccc3434ae406835f53fb1b0c516bd2c64e7f0f1b36b5117a4add60abc1b9008279fb23842534200b6ad9d337948b0d25b33491727dfb5fd84a5b642b7d900e6318cd52da7a25f0817963f6b5353ddaeeaf5f68f5ca996bb5db30ef4b561d825af3c5520fb6ff4480dc8ac6db1747d32b364608e6c2756b2457e9a41b10b101bcba29f720f4f4d263adb65ba98b797581bab815b5df6ab11e72cab5713e6cfabbb6ff9bb048009fc23f716eafa7b6c3e8ab0f04771ac58112f8c93ea55c0f2068909b9c3513e2fc2bf637c6ad25b46a51cd5c8503bed5752be87833b64c1eff000c8c32f255c253a25c1a7bc96e41d8a8be4cad3c89ddc539a7629e15c1056ed15c22cb27bf0964565bfef07996770b0b49c1fa069789fe44e4e517423192bd9ac88c35229b6a630df4f1f32182402f62728654a2234d986453f5cdda5c84e888bae0618ed2b300b386ae033bc2de66cfc735d1c0d630e507664bdb188379851cff2517b319e1a73123dbf0b10afff57dc3eb50a43800cc9d0f9accc46f6aba323c7bdd324c641373ecfa502430be92a315be5bf741f643cb8a289fe3ab018d96acd6b4ff10737dfab33f2dd37060bdd23ff3bc9671b81c72856ccee0ca4aadb94772d74565d91fe7bb04715731d7418b106e27daa07b9700ee1a8722be9d2a2032bac0ffc24c1bf6d9c0fc7445afae5b14bd273ad2b5f44c3b5b224cc93e50f9648ff542f3e3d84c0e119be61f7b5a9962338836e41567168de1b436a6b713077fa2253ad566d308703c52de385ae5a19c0f35a240dd2fd0812cb34f30bc842c79fdfdf2903a03dccefa769cf98112395be32a1e38a6255340340203ed21ab7581217c790ef706bf43e5a8ba97230777fc4567fcd4a377c2388f17df9a5782b774f45facd612b4dd2975381ddfa47d7320310e57976df636a5f375485c997c2287cf17c5f49e0096beb0d6c5939b936a0ca943d7e5f4d383bf0a4daa1c7ca614698d0813110071d95b2f8205cf854d27f47d33e45b0b24fd2d8262956828e9cb2f2743376e757d4a2470174c05ca40f5b27a6090ffb20b604283b0b7f3394a6206a6de9f5b0e7c9d2bf9d8d3dcf50ccd2840f1ecda14bf1921e625d7ba3e4d3024e4f4edfdcf08bb85020302fed1a798de143ab88b2209e7eaa59de507fddeda29370efab52d692e6190b788231206b7aaf9564a87587b9e898776cc35fe415b9e26574e42bcaa154124496fb7c3e99cdebb0999fc2e8998d9e38af3a109ed48ee13bcb4e6bd5a19b07eaa87bc7083eb6d05c7e719e51c57c3d39c652c51dab6abe91a0c97a89a9e8bcaa429c4c19cf419aa845211a68065bccf7ed40e175cea4b6f5c0b141a5c5f48ef9c619a4111f87542b9320d171ff1d8d14feb2c2982d3868132d209ba0691a1d76aa70f1d89031155f8ce582c07a753698d23c6afa1f9d07dacf83d8be6e610021774906db2410922da2ac66d92425d5c45cf565f13806c07dc7b242614a29e11093e30d369a369c55c6930848b626907a868d1d8ae4328b31e16872382beb8139d52860a37ccb69882ec72fcca8d7ef40252bfccd61006e40a540f682f0f2a84f160f30581b24a3652e95da3bf0ccafdc08fb4251099b7003533cc94cb6ebf5b938f6c78f6e6b54156d2f71f619d018fd1703e801f4e33b89697bee4061afa896e219a9845e12a74df312e089c252cc4c68a565d065c6ce9bbaa6f1d4555687e29df98c92c55e9f0132bbd555ef55682795fee24dfefccfe80237c6c392f8adcbbf08217c52fc4fb70257e127923e6c0747d0542402fb1937fac7dcd7c4a28c47780e3ec03584f2f03860204fca5c41de35dc159a538531dfabc5359b31464dcda341634a325bb73426eed4c702b9f0dcae6dda95caedf17d09481b3224e9448b11ddfe534db004df873a900dd2d57bfa3e893e1c942cf144b46fd7d7648ced2a65af293548f94359e7a4913750ad876c4e50fa88d3f02842e85e49ffcda56c7775901903df39221e59da341612cdca822d7bb1d926d346e2552bc48bfd7b97eb6c0afc51db203949bf5f0f8568da2d5a5ba4c9acfb63ce41159351511879a7c75734c21022cc73e4664dac674217885000a5ea897ba2d1cd50947fc8b20f3e1623a5636e92d5723adeb871e61a5e47e7492a77a5e29397d0d7579cebcf86b03684c061d547b3294224482b01d2ad3dbec375ed896b8e90deaa417973c6a74226d3513674a809f6b9099c7d894634c9ef7270c38536360da3e8e866d78acef39d2ae61ccd5b90a8f3c18d7ceccf0c4b0e5b0528c5217f76726badf7b8579398bf88a2641569d2bda71b23cb93cdc8a6ba1b7d98974d8830c0c36cd51f5e49a9fa26b34bca2d699553d7dbfc0bb1cd33a60b8312e92acb2915a367cff500a0003432d9f4b3d5b10eb6d3615af59ad60e0c7e41c646e11e2e13ef264b72d6bf31d7c614e8c08376e9c511985ed01aaab43b4c28e52fbd587afa1b8ad9abfa0b1421a5c7c23f603ba6abdf88d9d5983079ec5082b61fd6909a654e396525c2f1fab8bea5624cf9ae30cf85ea55e9fad915d5f36f9f7de2b4503344c82ce2d83ccff086d437553df904ac39bec6074ebe12f2700d32e5c126251b68f95a131e50ad93c283a059187f7fefa4e41697925f9541e9b0ca4b932450ea75aeded9803369a15c4f51a12095122504328facffcf1b7e047b51e1e85482bb48d9b6a59aeebaef99d099021cd2951903fb5af66d2b7e2818eeca8226487d462bbc2ed8111782fe3f7ee8a28275171644c393550a1e1318354293ba084ee0abaad633c3bf4ce49ff325a5ab5a247c7656734fda716a7e15db41a9d5fe2922b08a5860715fd718cc3df1cf289f85b6fa14d1264118fb7d20c0e5552ada01f1d1a9b0497e9e839643fd064d31af1f1db79b65bcdbabb41dcef9faca1dc48e977590b8f0bdcda7fdc72de4ecb2cc84b05113bdccb5539a0dd8dd1d9453a0efe5f0805ba65cb685f266ba640cdadfab9fcc4d7fe3b351032831ea4349394bb9248f80a31d67c0a32d705e6748ecc569d7467ce398dcda2d357a5be2608ea83ce0b6d6ab36de3ac6a5a956ee704ad2a704e0327462cc0e6a752f5250d9104440d4905e4be468404ea6145ed51755aa099657bf8d99eaf174217a30ce46b637d8df65a6b3725247c6d8c9e1e2be745d0bce83b64ac80d7be6053577a16e333e3936f50a68005e7b374b9e275ac4a70d6bdc404857c94c4b5966e8a4b1aa463fbef81759dd52e5e242f93e43cdc037be7eb1fb3e9a0c582aff123aa1b3bbbba12f93b4544cc69ed9c5baec79ef224fc8da0108058ebd1d1045b9c3ee455878d77e846665a86149eab83b28a7d1d8386e03147d1945c06fec180c29ccdfff5035484a5214d40ba408ce449671d79f5c6b13cccb86c634e858b4e945af414db50a0e6b8b54b2801497861e0b3a787999baafe4a30dfd967bc728f6999a8e232c5c689301f8a60153639c55ff3e432d69b8031c651668987bee567ea39dc766b9f847c2dd5d0ac6e209ae441a368632ac67e54898baecb2c0da3ac77e4c87100158474f1e43d3c9d84c8618524fe2c973b5ce7e7eed93fec77e1e364f43d34c4b7a23d46d53834a2454e6d2d6b1ffb239148b2507e8c7551257bad163a35645ad488e02bbcbeaa93f1fb5746627b86b2a59971b4228e8917136d034fc53a0fed50161858a4be1a22cf8af1e996317b6cc60869a3c739d68cd8e1269d3269e2881cc224502e4f2f2ad814b3c7faec0901dbfe5a520980cf4d00f24a40bdaacbaf1bc50a3083c0fa14fdad598e0db0ef7795b5c94b8ced74651cd2f8407e6b541fd640e6fb316857100976e2f63520bdc14e9c69e7949ca9f8cdd742f08828abbefcbf6b2d2db7e987c9818c5e0ca9d9517236ca41c51a1d1735c661330ae2e3e031d5c941e0f818d32d2db0104f828719171e57b77ba87214ce8e3515ba5ffb62623eaded61eb5e48324322ccac792d37e3fc5d2033429f8dcb6d4b0ccc128772b814c62ea56b790129122d78a70a5303bed9489015db332647c129fff839d6214be7c0182267c8bec93020dc9ba8688425508ee45a217f4337ea9ff8c395320ea6a997cf85df73f13a2df835df132e01c29565476ea418c5f445afc613a1fd870e8d9f2d25be794e76f2d56f5faa2d3fdfadbbabeff641efe2789e140b2a7d6d3aa4876ccde27b6c6fca16211caafdb14ac047f05ceaf3c18e25ed8da300c380332e385cf7643acaf1ef6a9cc317fa83bf8bc5d348ca4c9030d2e234c6b1d99d3fc8be541812ae1a2862f1aae94df5b4f9e4a4bf01a618b11beba98914f0cdae0ee2bbe9fee6a4ea12571f44098ddc2fd79e40534b89f2369c1863bcb0113f1b6c97169fef4345dd5bc168c96fd1f34c2fed5123c431a8f336bdf3bd61e2afd24861429bc57917e67afc8bf9e922cf4a77d95d1c36b4047f3f111fff3b4b6d4efa22ee03cc1c46984025a7ba543fac3fbb3c0302e8be276197ef00291c65a16dbbd762746332e46b7cc9e5ca18cfb23e75dddb72d5138c13006fbd409a890580ad0f64c66db67f0b33f46e84b7b56ce3483918ad1c23c77649b1d3d7fd645c8bc545239643f33707bc5080a8db35a60265711a950162236ce1e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
