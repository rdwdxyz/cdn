<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2206b66039dfd296af262d69e2f03c64373d96f777899cb6fc48e3790d43fdcbdef4a96c8b3c61f959b0aa5bf9a87f3648919cf1b4a0f07f6fc7945fb647fb24ccd2ba1ec859e18c0cf3b31e922514ae8717e22e4ab83b184594d5b2aec32d3b6a1597ef090da795b88915adbda56a9fe0022fe9b0c37891f22aa6528d1f6942de2ade6765df03ec3c80ec7c504e85aa9c6e0703984b33d202b0370cb1818a208ac33684b93df6d1051eb4f9f4c942370dba85dfc125ae974a97c087f7a89d4414af78c0fde68c0bbb3a1636bad95a7f498dc6568723b939b779a6e65c2226d9dabf1ec85c0ae829d5169b361ad7e4f792817eb16631d904761aaca4a5850a38818294df554694e8ebc7dc4d910c8da20a0411e4d9c43cf3596d4f865d0c4ec404b5cecbc1e1dedccb464d26dc266d809b36596aa6c87b9158dec928092ef7badc8dc92bdf0d4f152dc8617e6f4de4a19756f9561da5885064c68feebe636c911d05279c251844b78219137ff7ddfcc49cf510b5242d7e0fb14991e2760e7432cad56101d77651cea09e9fde91d755c988bdc223df7d2a52defb53f59c2e204b01552ef08e89f4f53a05b78cb82fd33dab677239772b9a7845323e9fe3975813d1c44e62afd0747eca74be6748f2ba21650e622ee8f8978856970d9b87fe1fb6e8b8fa94af2eb045d1055562484a086e35f28585a557ec59daae26d20fd7845cf233a8684755e1b0274470f16f6298a3df992fe74922d28720707a3981fc6c960a52ece1c7701755bc4f859663b391d5e609fed2e65ff322da0b825964bf7b6fb93220e2dd31d34973bfc9dc3456103603eca7c9fc2453c3828d110e2100bc70e449065628eb37ca8bf6ca8f36b9824de16d37d26506ae6dd2bf5f4a678298caa2e346fd1dfc60774c7f22035e2c2b6ef83471c3733a4b715ac009ad8a56b597013b2407744f60fa3ca14e7b4a186861c407d891d3b441891b3a2cf657298ddfb6623c613af1b66247dbf046ba7f0341d390c799f45a1f99cf71a6f02f52c70815b41e9a3a4aa89043d42d814a24a80f6a5cf423401b61a2a0c92d6fa4031be1f234549679c7caf1f424e1eddfc3c6229d4ac8ccb1a7992887d067e2799ed26f7e37d513de115f6ac6aba644c58d7921a92be5e03e3ec3ea1d8d9b06f46f7f84088e749979e205d5d68887a355c37ba84e16d9a8bf5308861dbb4773c36015c1c6c7a9bc3fba6d1fabd9994f8f807005a98cf81e068931d16b334e497bdf19fd68fe58d3c50ff28cbae6c5238a5936bba1b27c3d45422a9ceba59b4eb3645feaefeb42dbb371a826fde0bfeb3b26e61395e92bc399b2076907624aca96a44943c69cc38e80f76fa48b005082388b84deb95a93c089da5d5addcb696cc3abe7a9fc51c3ac0b36e829fabbc939f600b1c2572c7fac9b3794b8dbe8ac563b79063583f5c6f3e59e36d58431b28eca5ac5e93adceba198f643ba6cdda2ff137e3eeb48042550b32ae8b24f27c60e1198d326b5da1870cedd88a4a5e44e488ddac18cf00c93a1f93baf63ac9c92584b33f0f71b272c4b04962a928ad6d77f1614408cd898c3b1ddbbead7b9c4dbcf86c90f360adaa7ded86af25c7786b236d71d59a1661d4366754ad47ce825b66b65108d8dc6ddffa9cc90fe90ba582139d799f550b82279dc27d64f59ffedff10b107f82dd630040bce462c9e03f1de903b43354f7aee52b11d4773c3cde089d85e2bdbb7060af548030900c997fbd439bbad5183478af93bbc76b65aaaa6592a6b83dad8ee71ec8dcbf992e74173dbb6fe51934e383de38f91e5c38b83973d63c1c5ab31c6499d7fa947a4d0d040a1a4d4a8c9d14f4e9ecd87c84bb06b294b5d4227071b1aff510c2687b9a9549b9c36cf01e235fc77d30a109e5c7a9b580f882dbb9062d3fef272cbe6d94a83ebf3f02947ef5d08e87f5c2d00da13715e51e42c767186796b40ad18d233e938e100a6ab2fba16a1ed72d77de729c66f38dfab58b7e71d42e54fd6f4dda9754e4cc1bd658404bc19add34a6f29dc71a2048d5756c5955f6ad65df52e2be182e8d2e22a4c4762a5121f408bbf4ee509cb7afd493e6fc2849139abe75b930461fc1d6759a73ef61bc4868110b3246da34a5477435aa1be357581d4dec0d31491191e58921d45c043c81e3221ad7b41bfe0c7261f5e43ea28028866cbb3d97efbb0dca7729dbcc15e9ea47b35a6753b4854f0e8530382f38ed69024bcfd17d56f3cf74a6925344f501c95ff5f2280ea463cdfc4dcc0f4f83f5dbe6c8eea9de4c0de4a5fca416661e0f5cd9ee899a41a8baa43a1f7a93f071f166292dbf7a5cc237fe2c8cfb8a6d5a96b9fc35a2ef4edbe24bec8f58242d77857abbcdbe5a920f885ce71d5d637936c5289eeec1a08437533bc33ae79b24e68095abeb3bbc91fb8c5382081517ac1b7b7be81dc46b476b75d6d066bf51b1ea839c60334777ca6240f125b63bad533f20d52f4d8d97952b9297683d65376d0179d2091d54808820582838d26e6a7f7349a093336e5455c008d4199035e099976e47496c7b133c9969eeee292231147c90fea4f470774ab4ef42667727ac6ddcfb5e4da9f850f51dc92ce470c18d989f4e5bc7be2958030fd13f7497b15a6616a5ecbcd9bbcdc4629ca98855ae554247a89ce1dfeb937f3bb178c4f8b4549a21fc90f9517a58059f78e23a1f0f4fae1ac9b1d101804968917d4a10da796ad89f9394bc07e0b92cb65ab11c4db0208a0e73318e57839379710fca4b3d6f9c2a920b951fdc62a4cea30926a26bcaddee7e4c8e791642fc46e278f2b27c83b9cac7d1e9fe71ec7a4c0979424d3257bbcd0792eba080dc7b7ea2471b24b562e47d1a22ea78ea9e3cc51b47a15a47fbf7a4adc8e16a0ff03e7daeb23c48666b09cfc33933725b36c889165c58e76361f5fb2578ee8b196ba4a8c114dd99d39ec681fbf709a31202a0cd93a02c4bef68ef9a0df55d63b6c26194ed085ae5547d81e18ed4ad4384eff5fa9c7e15bd86556824edcb6c3a824ac62f95a0e7d07f3c7567fc7d8b70ead1538c1b255ad2165587fe3c6e6da8989057260f65d9aeb543c415df5cb3e554b6e12945ee5c2012795c1ddc08c446311678ea51d5f292ef53f7f6e8a60eac614f732bf93c166657ef2caedfbc9c24542b595efe1c5ba15c279953561956b3bd38795967b63b9219cbaf3baa31a9598b13ff0b505d1929fbac5ce0b16e7c73553b7856a3ae10df9547c7894dab71b622259491a90852cb0238dc4f07862eec00da2f032c07753ad631e17fca4cbd340d5412b74a4e3868cb6c57e0675c1205328970124123793a91e855ce19719246363b0db65247d2f2b1c84dee2d4b1069d17d490b848a6bcfdf4794467fb0048906dd95d9afba1dcf711703a8ab879ab711cfa4a605a0569a577a7a22da9eb57a724b489aed8cacaab0c320868019f08a9775a6694b5c474605db1712ee23fae8e6b4cfe1a252ccbb64e8d66de09326f1f0df3e19cf67f519ea969b4a1d1292288926805d7ddb8d2835f8331445032c8b814c7131989ed6f52a5b75cfce44ef6ae65ff0d2e0978f5c55bb542db7e9b0c1cd020d432587f3eaf4f1ab220e39d4e791f6683c221c5a94dccc22c9a892d2c2da00067be49efa242c0ec0db86db48459f41925049897c09372014b5cd624ee06faf8b3b7afedf3109a07775cb0344c4465fca52f71ef1e443485c971c900a2fbeaeaf21ed933c8e933f70c89d344003e3fea33dbe3e5b785bd133f5734e1d94ffb0f2d03cff2f24348442a5ecf155d06cf9f4d0f0362e5e88ff4683d0873d7241b07a9370a16c6c8609e55893fc09988964938ff45f52df0a6e5b59c12466b79a1094c792e32300ae746bc415e402ca2f044f77c0725963be9eb892d5e3de67a9b6c1aa6a39356f60b2f621070c9bfbed612ed1600c15beff90172051c073676af2059b890772a8f1c8b1ab013d7a5b2472614c67228b50a341d6515cff2633e2b4acf7493e3ac326a69ad399d4d095dfbbb7613371d8be005aa201b6ebd6daacbcd52dc6e0f388c989426d87502e5371a5f7ddf1d38d0911f7c1187782c9a5123f561e064962c2cfa69e4ba5cd28b40bf1be8bb24880ad284a960ad44fb361f3d5e015e4303620ae466c2a953d9d4a1eda348c31b42e93ce048143cd48ff6d5f320ea8580f20f1384226cabe105ffa618eaa23c38697f8be09105c643906eb6ea240a996a28bb0b02b6c155ecf0def82452291a210967de6f0d333df709b690ec368448b96c25787fd826840ecb82bf5962a50c1dd73554e4012c5b1965700158ba1949aaace507ecc3ce01035fd931bca5a2c0ab2d12f21108c5b916759474a4df9765f2fd54abe3b9d5aff1b48b69701f2c4a224613755dc107b32dca85d37958a18b71bb7c38985979bd120411143ca1588d7b325809b628dd3aa0a9c29461bbde91fa8098422a240a4116fb8c21307c586c67ddba04ddc5f25bf2ba54f5700deafbb68a33a4b4b17429efb4d9470b8b1b2b5dfa13e8312614dd1ae5bf6b40441954e16d84658afb4d5a24acfb7ef3cb0fd6f875088e4989584dd2e0c0cf37a8733b08ecea3f3591312f50e0edad80c665a75ce02f20bc0b37252331cab5575db641533601a518469b63011ebc3b62166c03a2a6378363eacedcbd3da21f0c040f2b9bc7c3c7931bf04488fb63372a8556a45ea582ad1ffd783647230fabfb828c402fc77814dbcae8e75d20283570d65b61a54b00d7203954d5b884ab9cde930197a7ec66fb8e82c35c3a27697d7c57d3a7d790a1e5de7fb41976a1af2400a104dcb8258ded28dd88f2708ed9a1170925d89e1411f3b6f032ef1adf3f8d8cf94a305c9725c2ff72463420e7f7ba34625e25342a820bcf432df99334ee5f144357e236e1aa8d5cd068a1667af7a9327d29a4ec9fce893bd4dabcdc9c134c567e74aee362002cd474aa33e01a73e4521632dad7e88625736127b9545cd60c4d1350d38992dd7c5e04fbeab17f3133904458c9b409c3a2c3ef4fa5f0cde612380dd10af41f07ca84f821a4c51350c9ca58afd70ae75878c669d39c23d799a7b23c88b33b64874c0dccc8e47fe9996f3f877c38a35a932fee04ae6481004635f0084153c1dd5e1748aed0fb76865a2ee95265a7edd01b8ae2c16ab674f6a4ba0be873e9c3d644cf7d969a75de18bd83a81da3fb5e7986973243297a705841eb1cd4e6a27de6f97abeb6ed958ca7713a9cb24ee5b90f472c4e13c638eededd6bf9659a6ce4c19b438335c94ef0fc02e1be2305b7dd69519e51d3c29fb6ee3d1dcb2c970507df87f6f74854600bf62c39d8a91e0cba50fb6dba09e56bcb5e8d2221cd2503a18cb05f8a163bbd9c2011ef1980b0863d6086a905bde220cb2c796bb5321f4de32b2ec2d3a4c988bb6cf66e7301e37295534e431c5357289ec44bbed7043983c781a77484428d20563c9314f89b92dcd0a6808f9bf04eb42fedc04dfe327ae2700072beb9edcb609538484964e51d2716ae9e9afb833261ba78e6e0f67cffbbe8909fe55939bc0cc3a817e7641d199ef992a09cb35b1a9f7177a6156b467635bd3e0bf51efd6417d4437ca49a42badc7995d9adca52efdd1a4280238d180d802cc92a72690b8dd7931d672b260a1b9645386daa776993bc9d3d57016b2bf6a34f9e547ca9ae36da64d7b6c4ca24cdb07004f198f994f7f44692144b9621344f7efa1494adaae3ef76d65b91d36e47737e11539a7e4d9804f224cda19226f4eb4a7cacad2430a169f54402e427a06bab3a066141e4a5bdb6c568a0bf412dad4152a33a43a3043972d8145fe7ef527f3a8734982c1a83deb53528fef53e328e9f612c5e4539a1378883444c867c063e553f317ff2783dc2e2e8302a3f79fe1fdce91e1ab4a05f9f1c393ee2c995e83cbb175933d4a2eeb7e9ec533e4fb211e3868d99347950e25171e86570b6447b6298451903d7070d2a69fd07b9657041134f82603f3a8e08db5115de235e1f4584809e99771bf5e35c06924cbf7b2e9e8a7201a2e5394bc5b4c436b6de45f69353906e92eeba45ad2cd10dee1103a06f50533e11b876fb7e7c57187862e9d5fc4a3b653217c81294dee5cce86fb46eda26001ece75400156f97d8975b9dc39752b06df8d9610cdf1e119b22b6848f8430e7a4c9605f2db3063c11b4b71794ef00fd123ccaa6ba5f7695c38476d1fc58ff78daadb3a330832f60aa0b79098f6926ed063e2f87054957e9d5b8c84b2b153a181b5f9dcf7e413fd5a1ff99d0c13eab61b84d7538a97d803f5813a33fd8433d948812457789e2364fe951329b4accbd69ad4d73800fe6fbade01e7e0fd93c8c13b45e075decef1a1321949966a35ae4ab384558c0bf10dfa34e3c5589f2437157c93f080fa532aea4a4a45901ddb6e973699db1b2850df830c335844d31b4705d156a8b999cab1089e7060b6afa01bf75456cb948a8e25c0f2503450f563f934035a971793fcfcd8b388d4530fc0a9cf0b4a917a0762c0c6dd8fef1fb14c63ba8799020639b48ce52222b1c49a2fa2caaf522bf2951f9803d54d1a8ebd3e83696b91c64f07bc60c1602002eaabb8b1b76174589d75c419a5bf1692478a76ad3e1dab96ed21e56279bbdaac79372392ca258561f7d405f343749acba372aa8505ab106d6f2d694d791a6967d7826a85a08363ee406ef90a86f15a28061cdc0c758f8074a99890cfed81c8a8441a49010b19935178934d5a012178719e64d8f62e32d89f7d0958776be26420acb98b8f11e4ded717637ead26398046e51bb9ec297033cd285d5512970252b330d9181d730ac9fc1683acd7555c2ea0b7ed136ad5b67a545952ed78dd1bf32e2b532ad9983329cd9ee5edcf2ccad9010ec8368dd39de9f0ccb4455130b471296db36e4451b548d377933f7867035c5d1b44f5869ab2a0d65ce4106652804432c26637ca5f73449ae03684041caac8f12f7e27df769fb19789946f81c11c7d3d4b895d1f0aa566486bafbd413009532bc12d210771fc7fa59cbae2c75d793c119164361e03f29aafb1d580ecf0cfdfcb7daebd41a8d43a0f079cccf9879881c1213778dfe2972655f277facfa0ffea9bf7975573b42c379c58bf6576410b9b74edb7c99a35847aee9eb5a74a2d45c0110094243ea5493fa8328163e45d0d91d5480e0818d65c8f88f02bdec1b9e07fc66b7b4b01fb991d536494defd8365cdb77a7130635de4d1fc52a1a2b181961fcf32ed0761a2194f8199c4bce40d300ca65577d72efe640656219c217d1abd27d3c0236b871d8af74847809ce892f2e147195490ba30927d99c447ba2e17c2b6d1cc9cf261f396a1beebc7a9d934a817a99e7f156a97e0f815637dd72a591fac0e1381461c0b1f92f3afb2d61bea9906f40a3ea25544490a036d300bfd121ae81339fbbe2ee3a31f76ee0410942b0a5bf100345253ffda1c70c2542fdf1c6662e6aa8264e18ff51a5bf9a9b316af2a42407a72844e0fd6075170dcc888247c645169469009692231e6b44ed7e67c8c3e8f1a01f6a4511e104d8deae41acbe4c161f59e19e01e1368b2631aff2c981bf5f4c2d44c51a6edc2e5feed4a7db243087fed698d6a928245a659eedc898432c36130402d179a1e3ce56a4ccaaf9b48a16f1f6815e539332af930d9adf7f5ae3405816011761c703ac9861bfd02cbbd6be7d6bc4ffbc9172c2b0a2a94cd2a003255061f9a7ee615c35451c43dc1694c3344f2061b4b359f09902b3b392bb38763e547f0752bd2054791e0f8967cc488c0118462cac551002d5d2233e4b8f7669e87ad8a9d8d477c8daec69717f4931ab39f1a13eff028fa6803fe5452158a45acf45c44e76ba07e343728739f13e0243b43d95367c597ab06662a9edc4225c834bca46ebf0813cea16e757ae983a9a29f7de12bfa2a766ab8643d572ece4acf769bbff8ef546b2b4b249805baa7102ccab574e330a75d66ce0e52e9056f990392ed249818b80cda0912ebc945814e88bdcc75061ed2bbe4184bb25e9016b293c79b09da6888834a0e12eba207fb85f995fa8f3ff0cae5f54f8a73c66ced7552e8fc961e7d3117b987789bb61e67f8b4a08f3629ea067b33af683ed51957953032b3fb365136dd5cf63a69a15343f17b5d75f0fc3a484469e3d87bd8248cedd52046267e2ecb47539d88b23300b693f95a0550ccd444b8677d4bba099c38909d67dfb9454b9bade189d584ca705ed6be34d13850ab01a59aa3aeb98ba9fb745ad414656bbc2e379f1d53a90d5c906cb00f9d390100bcb680260bcbf228124c9b456a8fee2a762b2fa20b64b7a6b2437060e554ded2e5fe6fd95e52f903b855aa3b82f15435319614a1f95ed05fa6c0f51fc85da28148c2cc2210e30491cff1d59a5f5bbbe097e5826cdc721ae5b25342b7ef3a7bf526bc3a969fc66f2eac9c165e66adcfbfcf640dd7da77d0261b2314a557fde1f3a771e67e483cbadb100cb7a2cc84b2dcb0063da1abd737a9a144e0a91231676d68fc2c455f8aad155b31b6cf0e9d17f27d86cb5098a0bcc98ec5a2f05119951efd67b4fa1a026ede0f0bd0738a76143160f856620212c68a89b53689d4c4bee8d0160b5d0d386af71b39600ca5107786834d68d3ca8cd43baf3b209945b257f233e08db214fd515d1ffb6b580c3e0037d8551ea9e933c68ff387bbdd4aa9a39dcfefd27de4e695447b12883cf0b43b3c0d5547efb58e4b58ff923d816e605217fe727d300bd640abdad7a9b18447349957e2d6a90d9a1a1859e7bfe8350c29eb99750da7d731b1cbf2f151465ddbaa80144187d1ed9dbc0c075d1fc8c8ec3f7251da32eb298bcb945f6ca8dc9881333aed9c48a44cb03f2d0224f92a4725949f2fd1b032521c86b4e68b1c15c92561efbc3fbe8c5456e0872fc449455bec167673be823ccbdebc2fa9fcb8b92d76bc236ddd536b9232dbbe29a4794a6795cc8c515537b2c0a8d6cc9df96bd3dd256fc1f54a633cd0b2f5693b0ce923ab0ce7242f221f141acfe03e94726c538988c9f1deff7903a88d2ac102eb354e1aef3a940e4bb75c14177d64d3cabdbf236c0356390fcaa3a73ce4980cdccbd918d95e3b641c59dbd115a039cbda7d871e8a9cd8f12d44ef318cc4713e9e17008f2e125f2c163ecdeebf2bf6a0d1e1e5167323a5e3ae19a30e1ea6857eff5d7ebe6bf7c09928e10dc55f35eeab71e31de620c146098e9aa5b20a27ce4fbaef374f9584b151fae296aeee7636004877eaba5852dfd8cf7c552ed1fa2cf776327e488518df5ed839101fce219894a8198b41c72593b0ab130f9db26fe785bc6b7cac50c7b6407b437e6fa843e3e4251ddf9d887ccaa2fb94c0433a9ed341b66a3e5a7fe460cc0973b0f38816c0eb5ff421ab9c112a8e1740d738e549ddc0e0d43e93b9f33e0e86347e8a9fd788ef96701b0212d432b89fdcea6c9657f96c43c25e778db2af5f96bf47d71b7ae4a8ec9e85815dd1b0b2966316d1d467e2e04492e36d899cacbf0561af1bb5099ac022de710d8480ebadce55dde597a872553e39e5daf9db909a3b1f12143404ee892a1c26612e879be1c4389e522bbb1866004dfa92d52a4028bfb22564f470502a411965fcb27126ba0778e9d1ee0aedec5e4fb9837c949630acf8fd433fcc87888f38a9e2e2c69ed2543aa38d1973efee5198356077feb75f40846b8d81071c3b802f201646564f460462333c7ab4076c73d7074b0cf8687f3772a3cab5f4ffd1f8e0ec0127016f46eaf6b48baeb1fe98b58976e58037cf130fb10be557b0d9a4ed227b48825af57d13911eab46fd1a2dac281c9c645636c7c8a263553f3299c950cab11048352c787dbf8adae341d5e8878c680cffa502e9f64d79e490bcb7abadb5af262555d605e37040eb73e512a97c3d88a377d65ae8ae757c9ab95688fc5c7e649242826a46cfe28322903c240840d6e61c20f0482b1f14b76e8615f34c1f1fc40d1bd3e3956d7c185f6d9b8a525423e3c06499f36f17df25067808c16401096e7375cecb492f6c355f0e93569f909ef3c3cc02e10458acd0f1d19acbe4a75708c1ba14b6cbe5904112f6100b3651c8169260b4ae6bb5e3308dd38f69b12a73e0b3c724ba86652c815d6e3e58900e74330aba24a7364fdc9cd9052215e1860f55a92d432c1bc1f8f2bc5a5c7b5d8a162594d6614fae8c7a3409bd1375f957aef588ea3ba13c1b7a7d9b513dcd9ac382ccfff74b69b18702c5acdd21725fe7a1d406deb3298b937adfabe5fdc6fb0ba4578c16034e8dc3980023960e750c139c265c0251628746ae593696c5a29d796a30c509dea33abbbe7007feb639f2cface94ac5e2c618b28247ff175a8d1623805c536ddc8fe4e926375b5b046a95ac3b9f21f16852337b2bde881b01b95c002a21bd2bf4ce6b9048ad389d152a576e78d59935ced8b776e72754520999103b09f3a7cd82c6dc067f0a1bcececb28fb168314d4ff021bb27af88e4838a906d3b697719a8531560db583f3ade8f0f4fe5826294c8f89bc10000ebc139e3f1797d4419112f31de8a280b2bf458e5f3c04247fd1f43116349b6502eb713229ae259138e5475bba94340c8a98620591a677cb31487ce0c4052587510e900af272be3dec4b99744af7fe0116ec1093b1d7d8a0b0886cb5179255ccd7ced4e34e18a20d78e00ac1650cf65b6d60a186fd95928b19a6ac66e57289d66a5e2419bde2df0eb01d7ffeb802e932e0d67b90b2da6be4af30bfc620c085d234d5fd377523b3dee67b9f85945c1209358de2bc35a11b3bc9616be021930739df0f19ae3ecc6b3e8f3d06f0439726bb15f4ea48ffa47f1b74a160d41a17cf5be98a3a26f621c3aff7d6cb9984c87a96d5f3c9f871ea4dec289a98f38a6cf1bc75b54c88238ef000d2904a6aa546946d9109ef5cd2d50a91f09fb932b578dbadb0327db5c19142b7b9a2f9f6aad027d27786cbd9c0ac37c486ca2b727ebfd37bce48896cce41f80584df762d071b7d76c7e85f8c510b2412bbfce6326fd08751e841b4a25bd701c32114d6a1e9cd36e1fef77dfbaabbca34e6b5db930427882f8994da05bc71e809745bbab529303192d66f921e22999368140cb3fee63d1555f4d361b6cb0db24adf5dff66750260c4b20efb12a875d00d325fba1cf442f290699e6398da21ecf8ecbbefa42da94bd93adb88e06cf12576b115b2103863ed8d2c37517d2e12e5e1ee8b7c7048676a81c18edfd49be430ccc9de3dd180f43f6befc773da85182fd211ecaa7f192a1b30b8ad8ec91f3d28e9bfcad26861f79ea11f4ed450caf486a10e701fb72b66d6d92dc3a9df1344414ae8df3f534ccc9d2a3c63715eb63b089e967c84b16fc354438864c0b07653fcf1bf06aab14c575564548b2313e080d7007bda830397a6659541cd663bab218f84c6f8738c967a1525f7285ea9cecc09ba666d542ee8dab99dea0f785a5f3517ec06a88c805e882701be18fbfc0ca189e921c2a58e2c8026e064509b2deba154ffcfdf100438b55aa62fb23200257dfa6196e6e23828fea55c1fbe5780aff64d4ab4d0310e7bba415d92d732c0fd01b3acc36b6d036c332ef6d94f849abb6cc6c63dd33386d7456864049c1d75ace1eee5d5c81f0537020ce78c16a0375bfc95bcdc62fa273d4ede192a1b8fe42647d26072f6be8f500ab6283c99c0981d57d28cbf8b97118d223a7e27bbe1784f1b8bd120590673cee872501a367db724e18128a3651a305e5d2920ae484f9a86857110260108689c4ba7387d948bc7cd77f8a0d3e94409fc56a14163aa23724832c1e257232db47cb0d6c5348539a630f5e231591374fe5f019fbd065ba5f9278e82621f3671fd0953faf961c34f55450209e10f6c82ffbdc418f8d0a1b374fd66c9d1120ce0ba6f54f99170b1b848679795de3dcb0d4894f79c997fb6c612c1cbdc0f882dbc1e1a43c51271e400ddfc6a91b3eeed61822adbee9ce1486343f71c023ac3566429a6c0a84aac23f1698b09008eac92c9d2fe37d9f88c4dd84f91f77ba681b134aa6e63363ed1fd5dbd5044364100be35aed44c9a52ddb4ab86db237c0b983ae57915c119e56607d8d812893347786bfc63fff5ddde1cefb277ed7d4078eefd09397a742fedd573dc4d7e98b9fced8ecbe2c9ec5e7fc1218e186a84e1cd766ace5db3090b8d7293608c447041ea53ab3a87cc81130911d0be2f83876f1e99a49463f2959f556986aec8676c494990d7388298cb2c5cf0c9425b74527e4be7ddb2c7f983981ea65a43b9aa2d3084865248d0d893341e2ee665abb959142165ba5f53ede3665098d3e14c2161dc040d10b39b2ec1e8a38a2492b498418c48f022751404e843b9c6d01768f868f9bd1e48dff9ddde84e2aac69e613c877560524b079951c10d6ab2071ddb0039a73a192d0fe1edb695933f9bb5c6dd66192a8ff8dbc45801b4149224eae2aae2649a6f4a1e820432856e08796b7ec72a245db7633db80fa122260bddc31a72e36acaf6dcd35d6d0924b930374991abbd19ae2ea7b145431a7d80dde411606d72fb336b53221b8932071ba58c3212be5fb15dc06f6f5222091cf717386bc6c38b1f061dab65d5c5b97e13fd0b0e8c622e26eb121605b7624efc33170ddb7c062726eb1475da787141c87ea9aba9d162826546173b6ed22e38700fcc935db5a61efc80c696aa445e40146eca2647c54eb0e2c81153540a40096ed09fd624305f8fe5ad75c63adaf3f5737f663600627e96c4f7392a6629b933e1121512ba0525fff2b89cfa5598e8b01e2d89865df983e7131333e89605488cfb9b0620c172fcfe3cb31221c7c3f055b327aaf575e937fddc8ca334316624723c3f5b1ddbad8d21083f5a887b13f36ebe9dae69f94173fb1349431f5829531de7d3c2115f487f161349a30c9f8309f507ecd36a5c6a33f007ac3cd45c928a89019663833fc6978c810471f7581f62b98d4fdf64fe796c7a608b0d332ce4506332749d31e06988412cdf35ee9ac8d3980a1d74a9f8f77e4d463c9c0f44e5319fa87e054c40a14f0a792ff1de20a10d7619db99a0d3541ffbf7cc53498fe559ec86f026132e0c93598172c89711618a38073af342ae441dd90ba24245de70c4d3266a14544cc0f82bd21ffcecc07364ee6f482919bc88030ecdacc730f165832abef4e72be90a95785183e6cf77b9ef98af134c447e9a72d3d1ea9d123ee55ad9bdc8f52f502b94e18b36b5227d857bab30a288fc7af5c93fc1dce2b694d2bd4cf6e56d5b3e73494a930c94474701f8eda45a372061f78faebad91c7924281de1e8d4e59c37ec5acbf010baabf79e81712cdb4d83d79b38c12685e1d6ad4682e38016ef564fa2198c871116d7c437fba43c366f629735f6406b8593b91f84c793d1ef1426bbb8448fd5b4558861e8a4f04d071f95be7683e37bd89a1ac957c221f3c72fd211ce50249a942a184082db605c8494e2bec1f2bb2974fc0eb66f61ac97f5a026ed19e5a94ecc963a75062939a77e635cd1b585f384bd5b1c457713a94809743f4fc747cf068bef23aa29b2919b0c5320b119ba4227cab0d0373aab1e7a7073267b9be6a468007572833728f6a47d893f14d7a5af3cf7006527060b494b57f925ba16ffeff84d570d0110ddba052fcb1eea1f2475057b17fd126b39141ebee7cb39df7b94a14bd91e7894858933b8561de5a533dbbc164a01fb28bd9206574c2fae500db628e1dffa2f68c60701921f0e2c893bd5a34fe4587344ba913b3b324e95a16d5f160456a2dd0266599d2bb1dd661e942db714a69bb9fce112fb86023a3bb662c216ba2064cf3e6985b5de8bb4cf924d14671eb241fb2721b24dfba4c5cc552b51b7c57cd4f38072778413e57e156a66ca3c79c11ba17740e724f34cdcf5bb1cc07a412da3258f2976ca51bbc1f1584ddb65b638b9a81b40a64276e3f4d7ff353969b888983ad88ca6dc1dcb41e7db03d8da741569f90d75c28f43d722e90bf70770f32951c87ccea458998935dd7c475ac2812874bf47bf9018bed59ad01f1316b9223d7c140f93d2091613f50722b4f1fddcc26b459ea2231f3e5af0b7153f031b25af0e41877e61177df396c984e43e7901603504a6641b4a0484a990940854a4d6e34e1d299f084cc70d4aa617b70174bbc2e1ba69981c6bef501408a9cc2705ef1cdd331053728aadf2ad3d31b94302ee212c43a2c36bd8abc3241e1b25e50eccc8803f698dd0938fda777cef0564d3544418dc54152e8414376328c9217abbd1f497cfca6458f0dee4c6d7aac4b464de805af49bb8f4c2eb5d867010383286900ff3979e1af7121c9d56f8ae4a2a7f6e980d9e88964e437f0c2c4aecbbc022e2d3c5ab21ff3db11134f52feece493504f8a0bc429287eb903c49274debd80be01b84c804220675f93e76bcb372facaee390aa8dc3e85c23039df4557422ef810150bb9a3ae8e700fef9888438cd896aa478fe2e60cacc6c62143aba11e85a8a32ec93f22f630025e2bac0ef3a9eaa10643d6a6c1eff565cc6a9f9a0a8e4025d71dfe26e9a99a6c9d0df914ea4b035c9c5e72b1a645f44040fd539ee9fa54e246aa47b367a586735f5ae37f44050596db26dc95809299c7dfa3332bbf9dd24c9d59a94fff0340e359c5cc96079c340f42a1dfa91ab16ca313d3a38524e756013172cc67a4ba9b975089232f59318ab9829cb30d65a6318e17a0d9eba2876ea8acd4e8710f80a2b56ea00e9e28e1ff1517e430edbeaab044e8b6daacc9e9b67b72f80b8b18707d0bc05b58b2dfe218b2cb682b63a8550fc30c60055643c78ebe1ee667246f8909ff9c6104e8c528d18908768ef45077fbfaab7ef2866181d96dd39eab7f7e7fa7f28dcd3081789ca4e9cbbd1c1f5256375b80f57324f9e8cbf47995c3bbb8fdfa39593eebb9119107e3745628b9b43cfb34a593716ec5bd11e166dd22e1fab40041acf24561cf002eaa31ff5efacddba31d4a8c9ebf1158987ea38d258a6710e8469ddfcbbcf6263dc1697c98d29c1c79407acc3300beabb62a8f472fe71344542e4868f1cbc27f160fc8e9a4e0ef1f62715361c1a8f4b367ba0d2e2dd681dd3bea63c137388bfc528f29f5b873b60294f47762dd5e2aafbe5cdc6acfa76ae761c5bad15ca6412543602d694bb4d50f3fd7feffa4d2ef923cc7c0cee7bf66fd36b5091ceae40825afc7afe85429cabd35c8a5ef20263a4460a6788872fa853347b03cb1305157ae49ee1a739acf6b961cc6c7e305f0fa86b54856722fb205358aaa0d25eea46ca877a16d00e33c3b2be2af2667fd1a947a782b05478eba59465e32966f45839d3771410b09f6d6e0b97bfe727aeb3f8c4cf6c81a85b137c9517130f304d4d6d8a2d333adee6ce41828ffcffc0c543bf4ed4c15b0c6328474e1efef82dba6a585e603a9e67d282d89b816e0617f5ee3e27f9b662ed199d9d67304facaf4886c66ee7095b4697ff6c0919895184715759123006bbdcfde2d58531f45091349844e27bce029b71656453024f3407a047755cc4ab6f96561c999f66d02a5a6d1be09e6603ad4c269dfee82625a1a49827a0bcce19ba586608a1140644f3f60ef3e3c7c2b6ded894808767f6637fbc6b3b882a7396b674684c9cbd73378304c8329c8339c0227eaeb127c6b4ceb7861ea2a592330b8d1032f035c7c3e9a8adee7413917a6158331feedd0fde380877a6179e0b073387a65d353911f236e4ddbc0170d62228275151909881185214d935b08bae5ce4ddfd75c85f49350fa7622c867975240e542ea45fc58edda6aaeadfb39a5c316795456a1baf8f709037ada1a62ddfce59e2090ce3aaacc1991a736d5a4242c27cb60ee3e3392e7540d58675838269aa1999a9d258589fb0a62448dc854ecee0f2e32fade57e07d1cca6763054a393fd2c372dc81fcad26fb003db2d4e3ef38b3e6aabbf99ea48080053eb9979f9b0ee6f03d8691bba5a14c4aee39f63c89ea18244c5af19c4fe05f5be1537d660a87db0eacb1858463db70806fe63fda9e68ef6867faec83c9f1bbaafe0f2321436ca0421cbf9ffa5a08bbd19a124c350072825278fdd04acb1978df407422c48d887b31dd9a877598ece6964e334cad4964989d3281fe8b4acd6441a548bf800027b73032d81cbeda2036e8e946804186873ee72416b10aced1b74305a120c3089a375cdd111a5348c123213a9dc6cad962b7039b2eccd9f9bd280e8da14d810353780b54c8d1e6bc07c4cc13974f7aa519170c6451889194755fd3823d4d8ff39c1d3471402394b6fc41b3da13d7ca38732914bb8332122ab9937d9046a2b1e03f31beee6831cd0ec6446141cf20fcd21ae66ff4af4bad3d8294a1c5f8d744213b72cbd8ab2a168e11348981a3fa56b746e582fbe31b7015e4127191af6cf00dacd5cb1b424bfeb553467f780ad7acb31c7a2b142e7181aca2931143208c979df71e34956727ccd191c577eecd89b64d9fd1f21f9f1fbda639ffa89f66c962217cd8331a9080028b0610d6b7c63125cfe2d39898e67701613087be57e4f2055a44367cf593e4fd5e89f524a2d71b4404322a0cb2514941d4d51b5834991af1b163c13943cc752ed609cd1e6b5807fc640230f339d2b0d16098937a8c3e7f43f385a46b88466d8e5281848d3bbdb2728e79eb7d54f4da3d1a8ad11d4ea5faaf8f320666dc752dc48fa41657d7c0e5ba28c83c083ec5ed10daf35b32c884a34a1efb12a629c0743215c7f58e6d02c767052447ec5faa7dbaeb535e5937f2b1c54a973a7bf715d2d7786625bf00cd08151575d4eb42fe184dc27e8176a4d638a435bb402e62ac5e1b6972ea57fa944aadca9d0f06a75bc40758c5e84409232d2118aede7a4d4c698c9ef8965de9c7d64bec5859a5c3d8c96d3f37591f6e50a0d361e991fe2f12caa6dd951037d0f308e868ef6ce0c022ff090e1e418442ebc57a114057b4048c3c6a0631f9ef5cc3526cbdbf3a9eea71f32ad0679b43753ee47236c3b78e755905110ea75faac71150e9fa70db204c1be91fc7236fddc11e774afb141b2d402b5dc192a9989b84ea3b830f58325546c296ff1a695e5c8fde1933a00f2bfb1ff76d665e9bb947736c025fe16bf2ad27b945696cfa8a36a4efa0cd39e34e0852293215abb750c82a53fb71d0686ab0bd531a8f84eb9a0d060c8cc2ba954060d1eb136b6bb74f2800007de16c342fca3ebfed638394fecedfecb0e1f812bd4d5d031ba55de7f0182f94432c3ff3b48a619011d594565cce41640863b401024994e6704c52dbc9eb7d4ec5d58d067cf7ac5c91bb82c4b9f24632e17ed824d0e36c6a63a531ec667166564b2598145eb3dd64b4da0f002b72eb81421811d0683b58bd4a3cfc043c97f654fbbc105b7601edc2280f42220776cee26ba40b1be4b159ec1cac8b44c151d79311b0d46ba29e09b5595e20ba3bac504f6c6669bd0262be1fb5a3978afbe01296a340cecf9fba43b8f0ec80fd43de9acc6da2e91f9f33cefde0840c89adea2e1e0ccdf26a47af31260270f25878adbcd5d4d8c520ff0c4ba54cfd46c8d7b6b04f3e0d1910fb9e616b0edc228b3ba19d6c45b544c372c322d94bfa587347983d954e30a87a69978691fd6977a8e6185488d1e506368816e2d3bac2fab0387952bbfeb4488226dab8ae985e211445700da5c7dfcc7cafe3f8f1e1aca35387e5a8273ab3ea375676ce3e917e8a816d457df6165a6b10c1bdfc21d4d903e58cfe9d21fdd45bc5eb28cab8b8c4e55ab04a8305febadf9d725706627dfb2a381124c4a4cc631c6e3459d74d772d21451c93405f58972baaebec13d5f8a6510c2fd3f2383cb3011d50fb2518bba174f73c644a3054efb51662253e68f1af403315f7aaac8673dff48cf20404cfef081f128e6a46860521d7de2cc1fd3467ae14587dd8c6f68ceebaa39efc2cf3c9937a22baf750203f15be48a59e96d821a6ca8fbbef5fc434443894d45072","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
