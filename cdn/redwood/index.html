<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eba9b9ef6652e7998ce3d9c4a8081cfba7aa78155b8df2efbfae6541e19a764347f4c65e0538eb099c268ae54e6cc453b408a2b87c1a83808cfd30471bf4a172f502107e84d577c000e8a60fafd98a29de7c19d7e084669bdfbdfeae50aaa7ad0f5d6fce781d91e5f1f28f22104a8984fb139dc11703c41523731f2be0f2965d6ca2e4b93cf35a338b3a40be37850ead048f7aeeff8b458d3bd37682f28f3c6e59c0fdf57e2c00ee5d416741b7ac59a7ffdeaa302c1541ff402cadd5e2f800a482943069b13e57d77ec09b93447b842c1802ae38bfbfb1f83404061fcf762358e901b84f7e3986995073eb9c71a2736f35fabca289ad1a9a830d75b2b13e4991892952a5b33d00793fb414642d265f705713d8ae8399cfd5acfad721d76b9f551b0906a003ab7654ae29c289f14edb6ced3e9e2538f81ced3beb20e8a06002b7dd3f17da0263da23d56699595e8787f9fad280be6e831380ac5c518e86056a5510096b08031aaa21debb89c9f71f1674f524a4d8f1e7a939d9fef9fe3e7e766fa947442b2306dab51b7e1d2cc60b6b2a0675afbf343a8f8c05b8153feedcc4b671fe40011b7a0aa5e058c34f21a826a2e6284df454d345107d0bed428b08a9d051b9564b611bbca4131314a72f236c5b587b00da0b73009c266ae223236ab39ef8115e30373c8938b8c301f99b4a863f55cbae7ed2ebf2ea98a1d22e03764977318434e393d28fed000a6238ab73cda632a2b10aaac7941d9cb6472343f24975a910cb354387d6f67383c7c9f4a33db3289b5127355c204d81431092a824395eac98b639710c239ed339f47af99729cc9ae450cfaf089fda3672f12ba9a18952b49a9e850d762e159573a14f4115e039f6e11fb874c4609cf3cca3fdadb217a5447bd77e68ea63e683e612bafc304adc57c733aacb3bc34f65edca1a3b4b04e555e123af5575e3cb9ff8d3fa0155ad6ca1ffeabab777a0534429cc26b2502e7f14aa8a0ef9d35e63379963eb461986d8f89c04b7f7d0c37d08d057d3533397658a0ff7dabf798824073dc45c437853ed85c55f60d7557ec3411d84c4c0c032771d560cfb6e0df22b62ac26e1e489f5d240fae2546ddd392ae96f140fdd1017e9351751091a1a3b082eb39985b9b20ebad2b2b9b212def036cc360146816c1d3ced862fb5c60d9c0fd54ed68b35514d1f0049efccba28287f16fa06553a0c5aba44a4ed28eafdd26c4cc3bd21d2b8fb0172299b6195fe44901a0fe9ca63c5240341ef9d6f02fe67a8d00b3f9c1266d577ce4246c828805d5552fe03aa20b7a2a2ef2392c689fbb0002011eb000c2ae77c0c2788d50ebad7734bb8c058a51785bae54dd561f402ce225be3b3527b465d46192bc22a4a13a79b9d82b287ac841cf8df1d8808b3ced13b5ce79e2e42ffa6275f09c154d7524566907c15c60b01b436b57e869c393807999a31bcda9287b51c6f3cae2c02b7772c1c7e137eec073328851f9a28767ee73c29f62cab9d5de5a324de5fa43fa0fe1e5459e1b178c2feb65911daed926d0901a9d2f5767d9d0264a8d57ae6356a1444a71ed2c8ba0627075f5fecd266b787bf0b4e807c23abdfb8584dd772891b91ae454dc090638faa8c4790f291c9650cd93522cd10809cbbd121bc676f513584f519db6d7f6695708905f6daf37e78a5360437240173a9f792dc5b0f2b05ae84a3a6131b7b502775395958902a335f62f9ac45593e1c78535ac57cedc624e799cdda21ca466b219beb941b808424301807e7f8c2de618751712cf159407503ebe74cc457ff6ecf072699231cb92958411a6da821455c91738006ef32cf0dd8fccc6af4d851322ef72b3b47ae694b0a24b340f177a46f513386db2b3ba659167ec37db51278e2c7450cad612b75164698f2dbf459173dd1402e0f4f423c4bdcc2ccf000ecc6cae2edae88eb0c9aa2b5feed113e547df7d8aafacc67e9c77b1e61939cb46c069a1243a07c239d5c2a45714dfa0f90f8fa85c5f48034ab5d9f5ca2bcee6d6a151284a2b77927196e698263252cdd5a9ef35fc7fe1709d12f5e74592cdee6ec8f605133a8e359f984310af9a2d7eca57cee9603e9e01d84944c682300df729de69d422f5288ff1e88c8b3451ec580b17b2d8b733761f70f854927e0790799c311124fbeebf67fcc8a0d0a362fbf87bc06830a6a19796ee597b10ccc6ade2ef6cbc7e6a4611a19938e08750332bf0da683dd8bb4296b20f7cbdf3ba7a4a7590a0b3b18871c2148e6595888b6384cb58b8856585c4034266cd3369f10f3f31667dc2dba0eea58a303e7ca91356bd64bc8926919ed4bd828e231c692ce8c56eafff92533cb4a0324bc34a8d951bada0614af4a9543cca68bd9223ca900b97428f5c70dc3286dd38018a74cb70176291e91f13ce693b2044ddac425ad2f9914ea8457e39a00c004619ebc3f872530cc2be2d875763be29f4270ea51b88dbccba63415a6ba58f3f519e2070a4338912ffaf5229332f681705a6e74f8dc49fb111b7e110736a44de2f48d6bb2413eca98a381d9931fb1ce1e3fb679919356d1523fa97c5f8685570c9dd7648a899b970a3759e9a2627b7df72b629525c86a1d27d2b4db419366e7008b861d21a61a4d428fb4f9b605c768afb6578453fc4fd4ec5e4a5d6bac69d8ab37d699a9ce68ca07f94a6478c386e11dc09f1b9ea3827c7240c0e4bfef5a1145ed7c5b99e5f434aaff6ff9a44356dd5d821caf3edf1ef97e4a633a0cce75316f259d26fd228522df6f2cc8cfda3d5cb589f54152ce943d85422f1473272ae05c0191b79f4554fd38e5b43611d65ce793085da98ccc1966e9c3330ff3bc41b21cae8009e916136bf658c57c383b31a04b924a28792bfb50d021f9052c0f8b0cb95add1001cbe594ae8b3a8d04f7470b19d9e1aabd6fa032bd1ae0658fb85f970c69d12ba62186c7e8919507ec70fa8a7016a9703e4d7a04782a905f769b173aaef478df99fcc32b4400e83736a9c7ebb86732ef9a07fb4786ad5dd1dd8aad4845abb1db6788caa84dbcb849035958bb81662ad735ce9306c27aaa64d765a92ea5ce1c5978517152fe34b24852f73b91296605f728c196eaf8617c179fa90a0fcf8a439c8da521f06020ecb04d6bcd1e2c6e5ce323668b0bd02f8561c5292ca57a6e55f98d0cefc304049dbdca4589664370847406a1227a07dd78c47cd36ccbe132573df2f63645faecf8cb7d25e383d5f43c4c405da5fb9700bf9e7d4a6c7ba06d29fde00ec8157f90c5c26d58542e1a5033375fd08ca2d7babe9611373de30720686d5e50ee8ffae256e7f11115169f5f0d59420f2b64759826c33224d130c688c999d6fdc17d5d24ddc07fdd9054aca6f82b569b98018af023135c37ff584d5d222875870bda787932d28ff0983e3e2a77fdee1badbd4bb4f1408f09ad23f225234396e20c92c5c5dac75681f43f928b5ca1db05b58fd8fe5ad47211c7307c74bddbaadcc0dc485070ad9bd1f5a54703223329bda3fe3f08603672b0b5beca4a9e37401f4aec6f3bed2cfc294610d02a4609968269f0590703ebd88d689c4acf504cdd9ad3aca43c6c8c85515220c30b5dcc0d64ec0e93f4c5a656e8d934eed6cb05e94b444776ab1ad6292280c39b60909aa038d1dda7cdc066336e58e2eaba750ffaff0510ead2d7d8e598db9e6982646dd254e70a3a3b25789e48732977abea338c798aef77d0c7aa5d5acfcbf63dc50ea708e3a003cce1070d39d6b1e3696692fa5f5a0fe19d8d2c8ff6d69b9f54f4cc90f91aba1551db6f74373cce6c4955a6ca1759a94f73f929ef4d2fa74aff158fa3e3b5338bb7e98ddc26742830468a2024fd14ea1cc60a0910e5541a59d57f8c1168bfc4ebc0cb8352e5f7ba7fbf2597dbbeefef5a365bd6ad8bdaeef147c1162b1ad1510e2635c40bf31d614eb1b47f17b9db5c6a14a634006e09b4d53ed3683a4af2eb7ad179790c9d24ca1bbb3a5352d9f3cef3126e8cecd6a5b413402ca7c860da327d103973aa219eb04fe526738d93d34411e06e84931d1cb68e0028ccf1939597721e944007319ff0d7da1a8594276d4c888fca96ca4e4de37145f87c0722377a6ac2d6eb6a76ea88b47496ebbd0755682e29f5c68f6a44e1da59cc1192bda43e1c01e74d230a8d503b697e51f676826c6fa4b85f9d3a4d78a0a607003ecbde1096fb52e1b8f52f707fcc48c241c175bb041a28367aaad0ab3f8ab597ffed613338973d4f35baf2f23662042ee4b6862153f86b29c10b771e7bbbb797f2ad1e8c867d1b183f7253fd8a45ade6e950e4a0b24498a2f7e0d0d7c08bb36c1c61aefd07266046db990cee0189d75b5a050a9062aa1eddc3229847b4659a02823dcb2e2c27bcff069e383e4a7a8f11cb678cd996b66e25825a8592ee76b32f90101fd68351c20c76a07d8e5c06f5c0044246b7475846ffb69eb7665c281a5f720bea7887c227cfb65623acd78701cb5cc2fd85d77cc935aaf8499c0f3f65467cfb413632a419f136bc3eaec4214745266c9147e386c0b708e87b165a569108189d0b603d5dd050b45afb957f40fb7d2d6b42172b378e2398e4ed495748da29cd4a247c0fff8cb01a5f619f5d91358ed2c7768579e8bbcd1096a85e81e8b2e0a9bb52648ab7da9ebc44544fcd0026c3d44b5b513749b906b2ccb49569b3c3067ec11d9b1eb36759786e5df92b7748b8d1fa225abe2c9f28321619a81749cc6c474867517039e2f54ed19b5020532b50b21f8801f4401c58841801dfe42880d76d352ecdf6105c5859ff8c0a563e1c20cf5d7f49dedcb16fc30cf54a89a847c2c4f15566aa1ff2c0b27839681071b7ca89651039036ec2062e372483c9fb1b697cc7795c6a2282c8cb62aa4ab2664e8e80a459b6d6337a0fba71181c46de564406655fa6e450d4f44067b710317d4cd6659561ceb16e6221954ef65d84de333ba0809b28d85aa65567178a43f9bcf45917a0e70275aaabf27e4a08f05d61c31548e65521778b1169aa82422735376873b0775d1b267b62ebf781559abb82f49598217c75caec3f75d57f64ba2e669c564c7263c74e5d9f5cbf494403b6333ec8f723e663c4960c574af7a7c706a26e36b285a46cb0d0f6ed303b7fffe16aff089d3e7d507483487468169085345a7b7b9b78c2d97266abb149db662736e36086a1d30c74f2d5aa765e05bea917f8c1f4be385f540ad66012894b145af05da53862c0a75a89f7601fbb45ff85f94713b2594859386a588b838eeebf45f337cfaa4ab3393bfdcdf65b3ed1d6c38e62fda029c1ba4ea7367c68a2b78d5ae97aaf34a2b02ad5b3ee5d90c54d71c9856a3f5de1d163a4a8542b251d7beedf0fac01ef3995de9668b7ea43051af8cf2d0518cde9135caca7b98abdc9af8837195de42fac096549fbfd6c9f906a03e02f0e3e72a4dcfaec954e5d33916c96dc8a265d35f9390edba0f7225847a2653132f8e79f07dfb8f66b28b2adb432a89cea14cce0c791aee822079651572c34bc822bf43ed58fdf96eaaa8c047856b67355f9935a293cdb4bed7c20af8455e44b4e41ae7a4d93f47b8eaa8b1c9154ec11f9e367348efb68a7b3252584af3380c0a43e864fce8dd5f64d273b80abbad310f457a5a2024aed6ae1f470633fba4d3c1515e244b13a095da671d98698bce8fb7fcb4b09aa39cff15e40bf80aa939ac081720f39598048a1c0670f2b27ed69276f89e17ae538448f1ca91babe4ba796aadaf63171c9e4f7dafb583ea60b0ce3f577310b4ac812edb1b606690fd4b8556ed655141a8443ca5cf8f8e6cfd9d0b866bfb74b065772cb7ad850554118f026eaf85c1e2bca527be75a359893cc1f036f4b296b69639aeca0d06e0194687985d8c8161c076c779cd2039277f0be655c93fba312ae4b80c1655d53b784f6bef94bf43ac8c5219d4191913bbc0efc30df8b5b1d278361c1ae175572195d62b84c97e9ffcdad2f0274d24ad3b39c83d2bad3a4cf592148ab4c501227e3761a752f4fc4fc8d29a797802d6f8b8709f5286d205eee97b1a07d6ddb7da50358f1ba1df46f24277455c9f0a61f89e7d1ccdf12be713cbc22c7195ab76134020fc4cc4c0b1d3018516bc352e06d12282ddd70b523fa5b5f623b78c0d015d2552a16b3c3807115bc2dd9620cc7236104d95380e05ee5eddcf4ed98d919270e033481d032231068e9527000d0101b3ffee84382386856174b94ec67d42bb576fb5cdb53665ec6b0762bb6dd023bbc4da60f2ddaf980842298ee845ed8c68e51eb3a1ddf7cb878312353c233caed76562abe878086916450ae1153ecf83e116ac483f92096562567751d7d1bd666bbeb9c1a8c5665c002707d57d922398c548ac74a1191f1a1914a7d43bc2e7d6330129e0f34afecb5999847e9b4d1f63ed919aee573d19c93defd3989d52da9393131f0a8ca743f9f94aa3bd835b4a6b8cc08d5e44fa8b52cc081ccbfe2ea15a5010019eaa6b6d15d9d5a77a588c2988728c1a2189bbb1e060f3e182b36ed5b27c17e7af842de9bc4e77b350ff21c5f374c80ca383a8609a716c24bb0910304361733c645663edd8e6b5dc2cc9dd7fc0a3d476ec2259d1fc5ba94b9a2e12ea01c9c81f62f688c894edd2204f793abee34746679f9c2ade3594d1e4dbd7ceccfd20bf1bb83f225fec2470fb50d922103fee146cfb43fde48c0bf3fb2e00555f5cdfb6aefa28d9b3eec414ffdc0973d4bf29f64140ac96fbc43d1a3e3b817184070bfcd42db1bdce3a7990a212e8e51beb061511a3ddd0b90dce45a7e20509cff04764d2b7f55114e104dbb7b8ed629110a8e97ad34633e4909fad21764d84bf6980e3998d841b033305708d82976e99a516e72a226f80188c6802a7d44d3558e91196e47d0e006af79710e33efd07cbf79cf987481849342fa0991f38079a18a9e3a32adf34a84a0674fbefa7fda58ac4bbf3bbbb63f47024135a3cd4f62bd708952b7bd4822c78bc4e0a39c2884976584265dc6a8f201e21cd76f1b4f06cd148f8f9d77243d13040f157a9b01bb448fc1fbc958024b17d7942dfb03e926bb4b465619be0bb2f770d3e24fdab10fe06e2f9961de0578d4993e5787b27c6ef7dea0a1db44ea4416cd982cb6202eeb28b14f3805ccfe4ff97993befc9d4d74099a26ab8194840fcee50a7e1419ace3cccab350455f0051a248356a0cec439cc59441da5d144ededad8bc8a1137674bcbcdd0443605007444551275a47ea970095768870a9a3f7955a19c624ec3a26c35c7a2a0c05fc22c0233c3c1d507081bc11e900603aafc464f8ed525cf8d63f98ad11348f7e5724a5fa1d4285402f24da245323808475ef4bf026f36d3cc7aabe25fd75f3de63f66fb96b93d52bbc8eca8bb8e5b1c38b5798b957f7a5e471f8867a03eceedf975a1b9785a815725cb1a3a3dd8f452531a8582fefbbf437d6c35a7270c94eaccc0c6d152f3034cc10347f31b7245f34e89462277f055bbaa542a8f08abe5b0e5717e6e1e776e13a0e6d83066b18c4d9b16e604bbc666be336eff11370bbb50ef968c582459cf4bd246ee42a4047878d9b3a7942d80b579799c74e83c00bbe3eb6cc9381585e7a64575a9d6e4e74bad9a80241474aafade6f8927ab5fce180b210583d9ef1c9cdeac97f8e2666383e18463533f86cf770e7127f996d888e7e8c042c0492ba1c41aef23cfafb5256469ba74592fe159f8f8e67bb916b0b521fb23765d8f8913d0b49dc7a4c3f7a613a793ab6605103670e68c58a16bac7c1b912a57a05cf031a1dfc8a394da0f12aa5d69e9d8f9314500de1c2b7777ada8433d549eb95a05588f890e183531029659f481a24f630a896eccc6c31b2d7c4469e6a0718499d6d1b0a9776058ffe0f9707b98c8aab6d874163349dd9fcaefde9e76705dd34ec66eca7e9982026688fa0dd546d3e48c37e5fe894465da64d572e8e66d9896ccca404d9ce0034b7c2176298993e4ed5d572a5859c8e1d9c33b40bc284ee33f92774a51a524fc1f1e8b166452cd68eb891afea11cc2f342cf6f7c7f343bce552f19de563ba0d2fca6118b80cfa5084edab4cc7b4522654d79b99c8067315ab4dd97593a75706eb538b14f2eed61d312e45dc11715de22a54e77873303a3c83f6458d18b47a756e7fcd9a324a7096bbc3978f112e674b8e8876eb43135ebd67946c7e16c9ffb858e808b2fd4cfe55d1ebd07e41c34a5771429edd1b7fdf607f7c6cdb18f284c46a5effe09b3bb8bc76a5cba397969bbd0afb33cee89f8c6314d88af938c044fbade60aabb8dd033436708ea26ad2c84d713ccc7ed1987c3dfc7127c6e17e9e0ad2367e5285141f15baa8223bc5c371cf84fefdabfce5ad0929c7a8bb8ae533cc50247a7e99336e2de20a329564523ab35c34f397160f47574a8473317d61ec8e624c05447b16d4020b4c89dcf4a8345f1629fd526ddc096829913436b8872f20919b3c9a1418a2f2fbe2eae8d18cb8fe9fa355330be3fdea3a4299a63ff8ec75aa99dea19afda4651b9e0962985a19266fd47504ef871899227a886fc89c583173e9e476259a26875e228c68e283046beb6a9711f6fc5aa1c69866f68ff04e5e4506a6b198fa9440fa0cff1eb3cf9f0718dcb83eafbc9434864786f25650e7fcb8ba4e20fa8eb37c777768298147c78543d09c51a5d6179c6ff7859aabbd32859c05edf005f2a4e176bee38590047a18d4c086e0dc1205b32936aa8acccce6306213c624cd79ec98609d24811305320324d1ff1d38a5e80e06426ed630d8db04e1f1db1db4cb8bd9e948e21bf323c9f2d409010bf2a8c2996ab890a2b57ba614ef377380d0734beab235ca159f14a8eb36c96ae767eb10651637b3718dfd48b788da651e3a0ea9266a3c4c0e3d8f687dac012d068bfc1e82f6560f831c6a5ec438f7fb633834f91511d4a2762c718a61822a0b860d8722cafd28cada7cdb73da5c7dc9a52f7dac900c2a6c280572d7836651f2646cdb45399a4a2a347e2a7e7eeb9bfe97bb9385784e5d18fd0a848f624fcfde4333f42db0f62174d6e42fe6b07d52484e767345bd06bfb81d8e759bd6ef019da53220b8fa90c409f1aba211c4b112422aff4f30c55f7f8898c51108c8be0831e57c5065f232f8e04b11391ae83f8492a2baaf43a8ed8a4f0bdfe994f6c068d0624cba474280f00a558611b8a942161e46a6d9751e61c6e8f0b8e3637b00112ba95fd60816032a1c4ce0c58de0e11ac83fe69b3bdc45ed37a79dc8e3f979ad8c36fb9feb7e2323e84c558007be2d83c35736cd823bbfb509e44d0362abb3701ef8b69941cce7c6277f218af0adc59d4a9e359ae96e9a89a21b40eb4c4aea7a73f8c084ef5575af41cbea15a9173c97544f9a2f0a4f1b06d359417a41a1e678938b341e0dc05e6f108092d0ccc58eb03010c10e630cb4ae7c263a488e5a10aad956eae7166c003b6e5dc639dc750334dcb85e2b42fcc9f73632a64bd173e4362ede44aa4263a881da729f29ba9c0eaf4704b5f97dbad1acc763bbbaa0cabd399471a25517636a38e46dafc36482805697718c52597bb26b712153c1680bd0449f6f2c60ba72a2553c8c5e27cc90c63aae7b546fb57b7c8eedbce33b82f2907cedff1813612618c4087c501eccea44525c5e4f49d62087fc12313b5f4c1b1c0f2dc8fca9a8d7f1605db24953383e11e3ebdddb3405a5f441a69b0e35a029f65f74946fb505a8294c2ed3714649f213a6cc4b51f3652ead253ce757892f4d4094972bd02d1ed6d238aa0e5fc80bbe118dee7ae6f5cc9ec288f9654536b6258a145e83c845b5f8242a40021bcb4046ef9ee55cf6e1bb26474d966500dd794bbf8991ea18201b1efc6e527882a04a13daac8f4fd304e6ea79779225586553b4fb76affcb81681db8a3713d79183e534180b253bf3b44637e54248e0e66e6f6faf9f49e79a85d47af6da0d19b4552b0ec5c45faa5a0a6c4ed8e08827f877337be1a939d71d64abf97baf7627906b1b5f85d02abf93b35a9fb9360b41792412e122d3a1c821b8f2381e7e06fff8a100c3e9d831c032204a3ca3f1cd31cbc5c701e768f0cd90c1226957a33dfecb19dcf7c95baa46268298c9b3f9e9fceb5529fdf40386b94edefa1e3b3591a39873cee5a59791cf46782cee5bf8aa66d6bba5546307d88c70a7d0239727052536c5e9b14a3ee2accfc3ae5f3ed5fdc33050a45e052b54cf6a6459824d0f0e5a16151c4e79e199bc18d47a996732585023f3b4d647413e047d4fea63d2ca2a1deeb29c5e88474f415377e86fcb9f3e2c90fc873d9f4251a5bf14e5e73998fe8bc174c7555f4a8a516aef11faf279758f08b3b216a5cbebc643b4ca4b0ac59f91893a380070c5e655ff82295e0822c9ec89c24ae1abbfc6e17a130e14d9ec3466bae4feb4b68a0236128b93b4dc4dfdfdf1f38a75b4411fe331d2c089a533dd09d685bc25d3cce827b58bc0810049c9aee71714f3f9ab82697783bb229ce8558c317ff4314b504feb1a3a0d297a528d7b5b713163865f01c6d1893e80af7640e2ac65605cdf956f384be1c2445e5bb3383601335f1f0d8920fa0f389378ffc4d397c179685d7e850f214639422f02d56baf15397aa973cba940888ebdd31e055f91bae1e55d8c960f3e2fa42194c779fd6d97f9582c77bc9e897410f1ab02350e0d757c61dd8b3f356cca4c18f33943ad10355349eebf53a0cbd420be50f2e2b926f8811a2d149800d2997854ae940b71610738dab3a2739a6d44b8865d4217916d04d998b5473f80ef25890dd77431fe1502259a2044e13cb7f36889f8151dc9e4ceb0f5618439c9191ed81573c4a58b6fddc63186d67a2a60cd46766b93d1c96c04b2e37399f769a0e019e2b9de7bc6fc815b235573a09aef6cb288956e6485c114d7a7a8e06f631dd49fcf9ccd86a2eda8815aaf617ac3023a2c9fb74f37c511b2d4a545be42e2bf5fb50b22347e79f4716cf691565286d88c033293e2b09a0531d41166407aa7624bddbacd752d740d979cb046eae6c92b1f5a95fdea7ce6d481c94f2f4a9242ae95a8c41b95e1c8f117b5e67b2857d53b1056e02a76bd7ded56f36b10b48948a6f4d410520081c3f5c268a225c2e737272711ecf94acebc9d6324a8e6f080e4571aa21e437a4ce2ab722c6909c01f95a2bf91abae0f36c655d3cf1d725e9ebe780dfa83f82802a72525c3f200430a5d3d1fbcb126dea9e450147f04741de73ab1dd37e67f39079d1d1bdf88884b6dbadc34df9a7f397a898bb13c0062a8743cd1f373d8b941df62051f6ddbd56272f1cc1fe17224473804ce0265341a32f7f7ca095b4b74fd3d67c931a48584beb9286bed40b33b475cf0bd9c56f00a74cd2815012275a89a0f61ff7dd461c9a5fc14a7963b0f7786b42811be03b10d7ceca016c5f1a9406f5aaed5c0ad6c96d38aa0d7fbf99c14d588c7c0f0bf167ddbbfd8630993b4e0e60b8c538d78aef4494f46a0130b508ddfab96751e2841d1b8927d6a26593980d1c55c9f0d306c07e4fb135b82dbfc9637bd0fef7a21faa9383e7c18e7ba633a7233ab17c0b671b316b7926f962d98166845946940c10e2ad03a48023ab431bd65c324320edb75904e39ac4632cc2017fb2b61e8e284a29f2a988d174c625f8000646a7172992da20c53a331781930177b6437d8dd6c259e8c7fa65cd03726dd835d7e87e0e2413f9f78f316036da9fcd59c53a1008a71cf0bbfd1eb79e3589dcf3d0044f02963cf9a03eb50262255961d6d751ad009601d0238cd5895846b64eb96e14d7b35b779092ac1708bd6aeb6e40eb8c996f03e08f261cf22b2960400ac69ee2618cdf76bda6b345ff74d1079c100f93a86c1a7dcf5efe33e4e051cc0b029eaefe27c3bb7186897cb25b62daef156d5deb7d84337d973dcca10c60ad4bde7dd95c4bcd97348a4662d0b786f186f26dab5961211de740bbc6635f8f324c9334305e0b5e23730bc0832aa44263e3d5b489fa2fafdc3bf4a0b9f314fe81851455594005a2823ccff68b96457478b2935100e5e94c2afa3258585daf5f79167697bf8b96d13a3b4b11b295cb26468f8d9f820f0961e982cbae0ff964f1be3c8183051fd3035c5134a643c489ecb457232eb8c3a496a82d77ce039517387fd16d80cc16b4d50ff2e38b834aa7f694d56e92acbd91271a9c198106ebd1bfa39dec6961af3630c3444b62009ffcf00070730808b014111e39d57f1d1a9a8bcc42bff9422d3bc2531672525f81903e1dd0e5d44e158decbf91c09db6d4f7ac2c9e5b99c5505405fc2089ee1418fd4896a66e24700ec1c4073332d5fa1a91df3c2612610e60cd7cab157ca8dc7324b26e1268b2f7d0519335f79e32de94f5ab1395609a6616619b5abd536bee0c27c85f0fe1c40feda8b7e4057d5898a835145e8b830ed66b3c9215d8ca29b65619e4ffa1425d18d4e823bea6b2c0f08c4368ba24807f3a641ee94037110c73772ef971f61bac566952994ddfdace7c677b34e45ae3e25d9c4e102c8ed80f3ce1700af7494ec868cf112638f48dd90e26b970930226fd7fb1e5b352b5759d5e2b863c377c736655c9f9ccecdeb0d10f90775bced1429aa790c2d4210dfbb66c966683c7231827f93a0d110b2b5a2520e2dd98433fe49a8bdff801c7a2820d46ad28629472d7a5ce053e4032151f2b54d0b2c48f706e1a4a3d7b13573ff167c88f8d04e0198f9fbb7e7632cda0b1aa92ae0ec3f61b6ca178aa3464091bcf9b271cdaf3c4b1e63cb371e80dfe09517c3d006eb8466b01d05649b27645f7dd20300eb032c5a67ab4b72cac24ace80e5922ccd756203fbdf5f5dee6c452f8ce5580ab66ff008680715e4ec208881d02a2e8f54ce282e20de9dd20d507b3d220caf308380d1b028986b3b10258c3a02befb4996beff8a89f0646a61c2c9a33764a418d4d8c47e778278cb0c83198f53aa424eed22b8690596a14360faaf1e31e197fea33dfd99cc1f7c21c0e2c825ef641c4fb09035eb34b079755923335853e6fe5ae47daaae232e086c6297d9821623a208e0107ae5485d868c530087b1dd1ecbff49e1cfe8a40668728c701a009c7e9062c65d9ca2195e66ab3cfdf93dbba3738221f8f17598536084922dd3fea3bd8d8b69f9cdd9a0a3ddd3390779d9cd90321cb07b2dbbbdc212905fc071f6f25345bde275ad09536285a5ebd451f480b90a0ee1ea059cf122b0072ad2ba1007bd7b1d33c4f9119cb3e41a581cd5dc4c0caa65db4c41aba78174c3feeef675499a2afd06a38012429ac267262808148f2b29e2dede0594761478417f508e2568af1f969dadbdf501bbd42552400c94cd830241f0804a18f4e6f1e84e6403f785c8ced0b4133b32b09fa8649d4f5262736838849581dac9b2e94fe3fda991322c48fe428545fc52486649fc3a486adee694e660d5c08db40577199b5b8f0999e27faec4770a297ffe94bea9b0e95045340786bd73edee08fdff20898430326cf640f673f811c4a8406211a89ea83b21ca37d25f4f3e4c1439e51baf9af95cf790b62dcc02b6fa9eccfa3c06616610198df562dbd7b6b4f362e6d2df17536244500be68ac2d9c7e133ddb2ffd0d14b411b547b2954d1624e75282ee7ae0a8e62c1c9a737bc5fb13f82d11a5457a500021dc275eb83a1d2f4083e1a7d6a1caeb7991f4101f0cbd89e8cf2652c44005dbc58bdb9fa49242bedd8ef46d3ac0c47cbd163693ebd3df22ecfb68c99e43ac37eaeaa1cb750c6b4445c983fcc950420c6044d5a5edc20869570fc5a4ca9dda662501da5ddfa82f249f05c356e377b7fa4c5d64a51056f56c09e864b5d443fe30854a6082ab52965f44b12fb34e6f661c82b7da3894f7f02c9bfe295b43acf603e027ccc0fc92a8a206af2e0f6ae7617aafa2ae16ea60474eeaf79a21b27c46821b4e18a5693232b537feffa6a2742d176137b6253e46225d62ac21d2fa46abd18247f02bd884f6a1c192976ddbe8194c57fe06e17f51b1ba705a273f585a32a39515807122778b578ba264dc6bc2ed411c62cc753ba7e0ead83d7803c41771c5984c054eefc12590f23ae8c142f7a098eb1c846b0d421cfb45fc5e845736f2f82bf7f19bbf6065537840e2ad89413ba61f3c0973dbec6be970a082bf1d803ae617bed41fd7e151e989027184a59f4591fc4646a5ab6db71f279f99f9203c7214c36c38b1fe659d9f2872f085f5ffaf6f2fd041ceb568c1fac2d2e9aeb4bccc5419303f66ecd01ed2b43a4322375429d3090bf95779eef90bffecd058b4cf7f74b7d234a691032162f27e9a22409c28853ade47a7491b2ad3c6f80b14d43c54b69933ef5f01c397b1446e616163af1b2319e34a3f30b7582d3f98ab2710e7db10ec151da9be32e9e5fda3da5a85f00dbb5725712264670a050f7a2d61bd8c9baa6f679026bb7e54aa1f02ffb7537c134cdab26ac415879ddf7791e8058896a7250872e38a98a4e9a39a7e7538295a56f7e59959cc062733baa1d40362d01771b07454fb017981d69ea3c1de42cdddebc131f1cedd208efb5125ac31bb8e13d81cf456de130253b375330ecc334ad686be08f3277dd171835178fa3a24b11ceec07cf0f9b077c3ba95bde79850830e799bc8381d95db8689a22d1e65c987bcc91f51476ae7665423a0626ef8873a47ce1274e971736510ecb72f2a3f8d08737e522a03eb85f97949fab3f70e23a0506dddfedb91b2374122ef5b6562d98eb8cbb2072b454e68d1f033ee5f14658d5e97a7556cbf8233616060d1c5617a2354c3fba6830f29d8e59604f91d4a31bdaf59d8de4686ef9f026c2f3c69912bef101f9515f08be8e6e9de8e4bdadd39ac56e6c37eab646e3e3ed1dcf7e8f03fe48d13e63352a7cafe8ee4810f2251fe332e3eb4de5d9636d899011f2542cd8beedeeb5ff34f0ab959bf6b6e4237670eb980f7d9a7ee83209892685f9af92d7787cc749697b27dd7a9cbb4ab75498e4d65e95e5efd4e19eae5fb45d32ff469a84256ad38efa11c381456e246b389a130c087dacf8782bdb989d07b9f579b1e141157c289026a510724a656b55600cfe375e3161f5ec6e8afc49503006dcb2aec175023d00c2f1b51dba056e46007591d7e29be22630ef604abcc03d68d6d2f455d44134819ed0e57eaf983a9078c95ecdd022c29da75bac85b2545730db75f934671ec617bff09f928d7e04e1ab02e1bb502804053e206224916d8fccbfecc767c3f5a1527807bc34742a015edd33c7094acb3803978d02dedd0b292df23c49bdf187e81a53a797dab6e0bd2c337edb7339dca53c9a54c6cbb0d55e666cd4dce70084c0f9326d5439f2932fc13e1b1ea017af40c0331e97d56d563d6d74d4e7c1aa3e0b48bfd1fb86c86800604c7aa7ec7b8301dac411dcb9e672ba2f5eceebd30804c3250fc374c8bdfc6cda047f843aafb2ac6539770812df9025f2c4b50cf790743d7bebea4fba4b10430ae5d5dbaf391d89e22c386580f7b587a6ba9e7fe9a457389084378d7e5ccb71389de3f023772c1130399e20b7255fafc1ac5ec7175541056735c66b2a46c8f1028ec226795fceee5e7347a79e8755a2d8d08b5bc6da312751c480519cefab650d597280c02ab94151dbc7ea07da0233b2c18c61f32140f8c9137820d88fc6369e4bc15e33f2d047b4e5116377e20680ae13bc503d03ff47718c12336361df2024417894324f439dbccdf616b54e2f2932fbcc3d415d82a3191ac51b12cb1919b7ec2f6cb263eba37638b476a113ee00b41bfd18aef78a6ea1d665b2b58351888fe5c66b2a25157455fd2788603a80d285154114c2eb5def5a1f08d4b3174798f8a5ba0b17b4b62f0fa90bd7e0653a6027d4bf39e6995c852e8df1d44d92d09e327ef20a9db62c36b71bd1c74eb772723c945f88acaa993723e56d50d0b299ddacbe63f73ab3e2a04329805d7b633265a718ebb607334781aad6c37073c6cd48d37b7915e8e3b048fd91a1c2abdabf7aab8c999eda10360e9ff7895332db40cb51860589de09256ed0520ba038e375bba8ab8222f45d95a019c465811c5375c1caca8c1ad500b5069228315b10678a2c6e2ab7d6a800132f771dcbf3e34d63616e5aae5d9dc2141ef31d0f3a64a0f39e14fed08b9f114a5b29232db5d99bf31881b94e1abd2bfd0a4345ebeafb6370a6fb79bbd78e54c251674f88d0c8e7d11ed0de0825c4d84a30aac14914ab5e071929acdaf1b3c6197295b420d384422a3c6d6108547a8e52158401f73984848b091fae6944d305f6d5aead4a772d89983e67798824910a8a613b0e036f61555cdb205b632327b940c6b227bd47b9f9617e055defdbf8bad740c9f6a893794619047e3b2c588f820324d0d504666117c1203013ca7f91665b948bfd4b7dd26c0c39086be0648784566e8b7438dd2ed0e475f0a216b48a2a56ec04fe071b6d395eb272a08d654492a35f7fe4656f777dcdafb90193ecf9c158ccdb51579bd9436a5b5bfb42274db4953276e520447fd364dbdb7ae0de1fd0e45dac03acdc69ba7adf1e59f229676dfb4f253182cbcc782798adf636088daad7f7c636775591c32fe3a38fb4e9542a0e6a26e87c0211930d2747ac59e89235ac98cae76c7e694b3f121c7281c7ee46204447c54d773021ee29f1bb9b3ca68bed5e26652e6fc47cd1c8b416670eb4e6657a2362a5f4c0839430dfc29b2fe78d5a190bc88ab9d58adc0773084ca37456de8c7a9942460286a181068835be900dfc67311821e3bf6d7d9b832eb37f15225b3c3849b6eace256f02740366a9f194635bf837e30439ccb974f2f2b4f909cef24f43c9b3b3179a2a367696d2d7cc20deb61ab5774d7283df4b9f3247e5d3ee6ec631cab6f5f097678702be4d158ac7f1c50717ad867b7631c3b59c19fbe4edefc351b58bb156a56605ae30137abd6d5cb9eeba50ef25108f9503fb06eea5712a2607ba8dc49ab270d510779297dda8142603075910770166428d45424a7bc61aefafeb88eb8baad3903a48f361ab9cd08d5692d39b71a004c58f6e4437732e68a048ae448c53d95f7f000c756f5ab1e4e63b80528ab484dd6445ff966b6f3dc8fea9820f63eaf35de7bea2b9e6c173e9e8b1cfe9c47e0bb953bf7709c8c2967f450df406c653b3095b65a8458946c87ad6546d7dd64f48979edd6ec3b6d8b860dc22a4a5066589dcd56dc1a21e6fa67abe92b216bd993f57e00c7766bda136d3428c8b92deeaa8a10d6f4b98bbc512ea4bbbdd6ae58d13842fbe576c791b2e8a8528f6fdb75d6f4914dc937807ad9131201bad99dc0f25efabe650a26c4d75377865165304ca48a70368f627467ca37e7af6d661097a1153b520194101ccd973d31465ed740e5d929ab8a9201e64560d9bba9687b9b8e30f5136cdeea7d760b0089a3a3e061d55318c00b6bac1b6a1cca00384b040e83e46a4183429966d06eb0a73770807c48f637687809c514bf389823e182961535402591f802d8aba5ad8173d70114959b46d3d9aa61787aa921823e5f91bcf25ca0492bd446c346f452cfdf6a96529e21575587161109c7f9adb9b13cd0a33696cb2013995436f37be6da43b0e1445bdc757c1e080728c2cf9f9267982270d9d35ca3cb5e1ff41989fc7dfafe02a2392e7944015c19694661bd45f5230c68cc887d2b0d7dc4c3617dab666d3efd3b2bbbc7fe132d8006deb7fe61c4fc30cc74123a021f7e4a7e72b70d6caea5432ae800140ccef0ec0bd77debce120ee5753f929908af3695baa0f35bc8e77755111fd077127e337d038ead3d099e4730aa9e641479bed2c803f2f02dd693694480e4db68f987dc7dd1c8ac632c96be1ee7bafbcfd124953ab14085d2f961e3ec9632c6291a8fa1e765820d30ae59035c66f20000955703c4a90f5f820a591da78e5a0983f1e6577941e1c889b7d9eccbfacf300531b59b616d001dcc4027a27ea9a158a948a4a3f8e779a4e3c6d08032a8b77e0247707584f896de2017c31b5dc8d3ed90d94b5699843","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
