<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33b9f126563074cdc7e9bb99695ced2cc6dc51b058cdf375ace6de70314ddb74df28af6f6da729b9bb10b2208a8e5c66fee0c715fefb18682c281d657025e38b4aca5b24d6c55d5240ed2d80c63a085f6dde49500a6e78199ce85c7c038c0506d4722c9b6dcea45f27244431c58835a3ae77e90ae0422874ba07eb358c4a4d3cbde7ab33a6a8f1cccafb72ac60c7998d9e6131bf0397cbd40e3b2a0c075bcd2adb90d34a66cf508f1fe09c377b98e4457fbde23ddd9099bdb7cfb01d25c172ef6e56d2538e0f30fcd24dd875842bbb2361ebfc14e3535be18e24f1a4296004e4b8df281ae577886f1d4c1e4444806528adc6e015c1dd30fd404f5a2cd4ba964d4d9238ff38a34f399b7cdf98e132e2b1512cddca001409f0d10a08d6902ed4ed7507fc1d3db0cef6f162fab63c9db85387ae6866a5162b5253aab23531a68a8333173dba954c36dad4a25cd840a7e46594b48e406432bd7326f71111141666869add749987480dadf49c7cf4c9173f26c033b7af9d48743ed976213d817a6ff6e1562a62fe4d6afdb89f21dada23fc06c9bbe7ebf8be67e75bdc738a7cff08848a0f5bd4c6d98d4b972463b825fc8637e0e695e27544b97958e644cefe9a3db133a9196aad455df764f094610f35e6155e72f3c01f46a357f0c888232a9d06e1edf8340d05d60d8e7c924d7ff189d72713450559766e097d421b21e0d4ec78e230e246bf43b836a1db5f10788a93f65c17a4f6df4555d85beef5f181442e2627ac77d4f6dd3987bab6970b5f54156f42e9c28f07ad3d73ec3ba35bce501cb2b5c90f2ff164a0c190abc0928e7fb7bc88fa26c3f88150ffa700bc2f23a2e0986102251a35cb4c9acd1f483e1d2058535d78d9eda204c3dd5eefe2b1c292c19aff928fa905d0ef90f011ea93088b94ecea7028158f8041927508d0ac55925a3f08aa7dc5aff6b00fadcc2bb6deaf985c871e6cb0ddda8e4ae9d0c403a02ebe94c1c3862e449d26c9cecdc693b9ef7b42fa08590fe27656009aabf70e5cb667b54aef8ac41ddfd92c1d6f71d371362a2178a1f3bbf3075a9b2a96d7addf5a41393539fdb60d86e0223a78e6dac0b935daea47b65991e4e38cffc506e5d43e864e66da335b78dfde4af7d85a431ae647dc530565801eaf2e74eace654573a56e3eaba51f8979894d9393c1cb93992f6dd5f34265d2e42409a5d9bdaa91737d4273160e7290a5c1b76d1faf1c9de8902c0b2f7b14a901a75d1bced6682d8fa3139ee6d36b38adb9e461f80dfc0d6cf48d2ae2fa8d402c2e0dbe9f75d493d6e7f81d686785037d487651724e53374a70f60b4268951a8691d74435276b6888edc14d0b35f029140a0c7570c6ad94653b7986a40adb31befc8dfe304c4f29dd9f937606a2879b8850885a6a9965808e869254211ec4044f6f5efe09e785f37a2aef4a87592cb09e9c7bdd4677d63cf41efaed26b0047e8f0d020584c8b3e18ee2e383f5b14917a496db4b031a68c5041fe77d672d18103ed91ca9e1dd593e9bf51041232d34b02fee475412ad0f6395b46048eb4c9ad115c771da40b5f346a0371e5f5fad5ae1e4a3d281076d3903920345eb444163b41a7ace295d229ab7ce0b1596aff80d18f1428f55705e66139850d751101828acd023ca4afcbd7aa5bf99fd698d31e41189f512d1d40722944e056fa9968d33b60066031eb1e1edd1ad113e0e34f54929ede5ba4ed7230e36175e9d7b78839addf20d7e1a2201ce738c149af8b57513be7eb2f5b08c5029093369dbbf5fe9034b3d028a1858fb5aece6266c435f161b0872f9992e6e5fcbe1ae43ee979c7eac32963a9b7a95276718b2075a5942523d2d3bb93c360775422f733050c9b63ec880a8cda6f7855ccde01e6f3a1ac1cbd8ad9fd20092dab84cbe4e39a4ec5387baa686150399232b6e6280b6b687a37d4c406bada03b5d7bbc8f58bda6804f1b916221527e70c6bfd73b471bf1f9c19a6da44da64dc4d1eb33aece9bf3ba34bb3f9960714750c1dd689516b5486b088cc21d41db8fb7e4d526d3421bc36e7e4c28a6290d094a87ee04287599b1fcc632cb9135a74a3f7bf508fa502326de88ec0ed85e6699209c4517cdc480cd0326b9bd8752f432b21fbc5c372ec377ce8032585099f75988490eb44c27d238f443c78128c9382b9e28b6fe66d521b5e5ab719df11d107e2d0765fc6bfd514da4c87d7e0f4b8eb13d1a12a62ef626b062fb185b76618f50fddf51cbd866db98891dca0fccba28c171f00d8b8b321d608ce052488003f1929943caecd56f2658d0929be2a0bac2aad3c2bb9d7f1a6d56cd4fbc3eac0f17a4c1fd5c94f00838de7deac4213fea9b11a020732fa866716e423dfbeb02cfaa69939005626eef375a89e391af40101979f3998c30b2e3f5552be2f1641c4933b93e915ed9cd097e86d1c3bd7a35d3836d4dcfa92877c91a1c3538ad6c877edf542e04cb7890823bb71eeec211d68726ea35b2dd9af78e7e46a648218c8f8987cfdec6e388e65c8bda21b3013687aaad855969eb4d9a65b66d02c22f861e86c30b31db8c569905c2abf9401e01efa1a42440161be0150cbfed38d05144412a08b8f36869f60acee9ea25e9974df056715f3578d02e7a91a0bd3782f3df58f49216941632eeafbe5726a8b588df34b2e191cd2a48279c6745100e9aa40144b279d5142e1dbe09043952f93d250086af63d7380690b9ba46b9564cd530f980528ce4a7969d9eddd789b155f139f812a91cf40b05e9261763bcb1f7f0689e8cfd4e455f9685bb02d670074072cd48581b17f521ffb49f59a67ad20c0602d809e43e73347c19a8871d089cfdb6720831f7463aae9c18113451a887b3ccad7a7ef2c09bd0a6851af8d3ec703899e27a2abbf49e53411c22511c46798c3a1d260c4b66b9fe8133204c5bf604598895ad3d07872187dade39c858cc0054b604f2f7ff0c19e6db571dbb4cef1cfe5ec6c4b09d28c9c66a142978fbf6eff51ff090dab0bb90345482983e0fcf219437ac71db5a84b1bf55231a1536c304a24a317c72521ac3b2add5696f7d99f530cf29168522aa3b3011a57357434ed6c3afb1b17457de5e8bdedf27ffea64b8b224cf0d4a66db13df5ffdd45061107159a19005da78e12c8feaa961a74616c342ca87099f8ed8a40ee53fc50f830d51006673c47f222c630631993b70ed61d092247aa2581dcabdbb7a374a9588f9799df384d69dc3e171e032c561a22dc29c25d158bf2904a944f3123d79cb18e73a52301f709fc48d6f2b53dcf44b22729be0b22fc03581eddda25cca37868256ca985f04216ff929deb67e1352606d49ebd3ecaab48c81761051aa3f7fd96670a80d695b79abc132a631926fd8e13886b7f495ed63b347104b85695fa4d5739d8f3ab4eb3ce918ecb33b90638b645a23474de28b546eb9c7429850e559c9bc9c67b877da049ec299a3d5797d50e1043a23ae948df26048123e689114c99b5da27c98b950a351bf9c5514cc7dc7126430401354f4b82603876ad8d875336a625ceb3edea7e1eb6a6de7dbc84533687148ec0db1313a502c5e27c91463dd993bd76c2933187dec76dc933d325b41aa2c000c3393fbb5aeed9dfb0def5d01410864f26733c197b1f25e66764640bb1665fba72250a3dcf740104538c8b76fd39f15a2788f558766e805e215395f51cd24ed37c382cb3c8721cf864a07a000e3449e9e2662b0b4833594a047aba8e780694bad32eff392240b5b9a4c0df75eea4c53c9078d39330d4a08ad27e7fe13e27fd538cdf59cf0247b280bee4a04bad34eb73b308dd25fe20c5c7a667376d4bce718964223651c704b4411db40ef14df7e2729b1b6e0f967fc125604b3c5b2f45baccc8f7815f7b84eea77a65f3253100a6b3a43a4ba197d78d7151f60c118387bd66f5c67da7812af24c8e375264e10483bdb096d176ad8f5e144e39fda952d9d06acf69000ea3ac911cebdf57cca77a31bbd4723a607616f8b3f46a5c4e6e91a66e8ba97eeac3455b88c565809324d9d0776dee11f81da3263dd040f7b6b5cd76663a5135e5e04df5e7a6c34269e77569821b769bbd947269f52ca7eaa2d5601d57f6f17ea389f4e265187ebd15f056d70f7aa1a13c450893d98f841043cc111ba482cc43ac90e58c9a97e87858531a0a11ac7ed723c226cda51684f9806bd33f996dde90353c2a61cd008d2a0c691522f89e761aa5b6a42300cd6af5c7237223eae30d9662ed9468fffb8a4675edfe03a98b41f58544a511f0e5241a0807f25d01b4946b474ae3c48f757188a69026e2315064513db8f6f9aff4583c871a9eb55b9b6e6b190209821f983d74f6035862740aa8089cf7eae756353b769a4a81a355f6f14456cf3187b0f627f62e38c00d6a91e49a57bc21ec049aa621e9ed0fab816a141831efc6e86dd510606062465111a3aa84d9da8ef07193f492a6094b794653999ca70a3a0b30a8b4e7b28b3df61279d31cd26f56c0c710a0368383fd8e9e170f1e314b16786a10e9c8d2965f2e8a061c8082e0237fc79bf9416a93feb45237e5aa7057f9075ac8e0903fb793015eae91f8aee9b24f56326513ede91238859436796ee962a507fc79e7ca4b4d69d42bbfeb0f96c521ee0e522665bed2639a389b77267180fa3eabeee966e7850c1199d1ac34f8387ec2dd9d8e2bae85cf17897488f66a7fdab43da3678487265a8e78eaac5be3448eaee49e7e1b5112f2f9e338438e1af7532dbe790434c84d3ec4acd6c14a04ade366f97f4c6ff3280f06536a2e6103fbc23297d8963e6682b6174455ae279145ad9653b4bc1f73abef1a6291b0f51eb65a6627727fb03f68323a733726f381aa8ce4078ca6e03a5ba01e50ba9c394219a556ba6efa69c1a6b25981d3dc16fa270ed18c39504d51b4ff1c262abfb01b797eedb27b2e3f823b3bd5f4569313e74663896a27cb5f0b98ee78ac7ec0a131bbd51b001047a4ad16a717bfa03e029f99e1da0470c454a6989a67cf54212554072544d051d9ea7140171045d928d7881b484668b0fed31d0322f06eb9cb5fdf8aae30fa8aa56311ab14669994674bf3ddb47cfa4f056021d45aad7d8e9feb70828489c7ffd57a328244254c87f464f0fac4e4bf5664d7cb59b47098de0601e3f29c1c4c958a950fc651c3c4fc3995a625c21f818ff7b0ba6ff96032e20c6004a00fddf93ed52ef84fd3fcfacc7ed2811f1e3224c31b4c45245412f1ff39078bfa8155601fc9a050a41709401b3dbf8ac5bcea7f8c0ec35a88499ab6e479a8dc76ed215260ca89801559b5acb2f5e3e90a3ed0c4bf55dd38a36c5bd6e134c7744269491cb94fe1c6799adf987ec91ca4a03cf2924b43fc752a17fcece342e56a1424437fcce65b5723d82b8352f51c1e6669faca54c8bedc86a63f8c750e2d27e04d89386714ba625262a92f7ee1484763b5588c90ae447ec9ffa0ae063e48655c52371d97f86b527e564b6ba1d6ccfbf1dc78aeb02e72e70853c8a2e5b12b823fe14555cf5117ab98e35f0cfe03df9634f5315c4567691423c1710172879d88c6d2ae556b850a75316492e6f11b446eee64171354382d9f23c5dfafbfccd5c44bf0244c428487887bb4233b8d5a616fec53a7010de95c9d2f1f9b7a212d2cf3a8b081daae1869700b0d318ee4a7eef2ccf3dc44cf059fc577653876b18a6affb60ed128e9a8fe62aabcffcd91c2b25a2c1c7f066251d587fac0629484fadd35e7a654c52930d7f95c252d9a92a65c290d953ec03f522c936c0886b2faed9d0afa8bacaeb6f76fabd6a3775a0d8e21063c79eeac4e1a7071d72a6ba98d7a23689cc855e20cfd203f0ff07bba9003b22cdc8d87033be22ec580a4b4c42166dfb92dc16b28c9d992fa8e286298435b0b83f592e116e55691b3586a21963a63116a6ea5c6a287cc4cc4e47fc0825aa70dc495b157afdf9f93800f63343ec602dc8358a9a6251b00492f90ff38425b6cc4d97bb1ac0cb0cf8ed003272796814b47c49b848dd763024c483183d70257385321622b885c33c43d6e1985f09846578c850c77e0753d83ae04c223f6982b467b6dec456b77cf6d6929cc24b6862515c94d2926d5f86c124313e91732a0b7fac05e8be429466cd8d0f4d1b90c0807a12f7163119345c28748241f8fc45fc9e03f0f07e837cb74e16facf2add1a224ec1a91cf979e30d8e2dd887bd445b9bbe1c379ba45cb636df985ebc9e3a849e5a3230e582b31d3034cd7790acf6627450aa0c2ea8c6115502acdd8f0634dc16e14b67ff5616c40cea8d251306c5806d2bd37606be029220be4857d999ebe10e3ff8008ce73e990d96828672d04a50f110cf06956a6c3c7d0462991cf7d6640ecff00a94766be3966b073ad33a64deb610dc5ed4bcb2a0996f0b55365d6ed2f2aa604997798d500f51a62f8bc3f223175e018cf047a0b9d294b76c85cc1ef07083e90a2e0dabc5a9dd0807492cb530de39ab402f1f61e69db1d56418674eede3470938790dec6994df47be86b3004134c6ef1d5e1180ee254ce09ff816d187d671af66f566f2bf4120417fd4b77ed5dcfe605fe41df196cf67b9bbd1806cf7fc8c7561eed0d1a54d6b87e4a38730536158ded98814bdfdd7e6385fd0cbdcfeb77a44e5bfc73b062464f5bb9a8c0e9e4852ee2edfc395f2e5968ae862636ea0e1669c10f689fbf5e6ce7dc78d6e8505b0a12eb643136b7b51ee2c85fae2cd9f7cbb9083f2017397025888db7fc04c0d470a2dd0e0023d3586ad4bd37da1b9a7b2dedd424a162b0cdfe41d833d0a567e4663c12cb5020d73080741b88519b53e6d7296125319cb4127b1f48d5309ab14d8f033310a66310b8bb8763d45bfea756ff3102bb3f2f67a0d7c3244a140c1db8cfa08bfa9e0469c4ef3efd7686d7c80f29d9c79fd76f1d5c55cb74f6fb4c8b5c844409975eb2373a35d9b04501dc93cf9b0dc8a315f05f3e1c4945c22c63268b46749c74394d020cbe5cb4239adc6765a24f7cb0bdba73410d968b788755255bc61d405a726500cacfbfac5f77ad2c2f547faae6271ace248825b8490f79200a610b2a1a82b13425202452adb9ef4a9fec49a43cd5cfdb794328ff62f88fe63b7a5f3dd136fb92860006e3704753b4addf97873dd1250d6173849cb8cbe356fbfaaf6aef8af49cb396a222f632a1d3e13114449d1abac5f8b024f541277d8190452ae9edb1bd165c44bfc7b571977a4d9437da9d7a00251f252e51c9fe05a4e0642a740fb0811564ab8da34e2db706cd3494fe1249aa739dac737b60a6026028c4e4a9f6185f82b55eb112b48892ff885345c2b739bb4163925c572132cd9d622e644cc0deb659837aa9bf67d06cc83ea3b03cb54681fa14c07826cf9303744f59e058856e59879161edbba312f8273234b80ec3947f5bba5647680ce55a073c8fa7b049226221136355808e806f03ef76327e3f5c94986a9b8d106d3d78175a445560bfb2ce800801c81d1d91b0c620dda96919b289ded5d7233febda5a1267e2db615fe5d267cbb33e8e3d92f5c6ab9be48108b6baff6997164c105924ee4c7a2562cc88c77014f4c4e8f676fe51a30176839ed6549c589694984ca1125084af7d17473469f5c4fdc1f579266d9f262b6e83ca287b80df57c483deb3228edb1f92b3e13feae0ed5fed56e830f654286c92423833d1d147cece9087cc84ac2efb2c2570788d1f8f9da9ea96eee5c72475b0fb71cd3760a0c42c8977892c8b59bfc87c5681fa7f8f4efbd415d00d134b86597e94e54cffdaa8f8b0174b12e6264ded6e477130550818ca271c9d5617f9f456585f7c643fbabcaa366c6710f5ffa36aff61aa6a317f2412ab67126628c0a9efa2830cc613319f8a1b1b9714e2649f9ae479ec33942475fbb6e33dec3817bbf00d4a7f377f5ecaa2e08d6d2ff64a2f358d0892621d3ebfa67ce7e06861ea3a9f6bd965530bf8d429f7ea4988aa7f8bea5f7f14f37b74b6480cb6984800d82c8f2d82e3a89dd9fb3d98439461be73ffa25f4a2dc4fa74c4a7b0b61e1e44283c8806ff48011458b85e04cb71de019c82ae155974379f047fa0c62a963585969e6a7fbeef1817121b94c9cf0bc9807fe99c621e65f9ff1b8120333622168d987959534d2868ddab58c36d7e750fda465669148bea2f0a81f92b46b48962b6654c659588ffe4ab55a10712f99b01e259a7a67f8f696cc9f01c9f9a3fab2c36c41d053dda25a566ddd3c558b89b62e263e50ea94c8c2665a96af291342a2acf1b156050b3349a2f2b8b1d2820f693fd98a7c8f1fc218634fb3adfe33a2ffbc1e2b3fcdfaad70ab9f66b7c1cbeb9a58925ffcf3f7b56d3641b329392687c286907fb619fef0804b9735003dfc43839f3890f9011d7427f46780de69bae971aceafd14c0d38f4b94ac3217a595b3c096aa8f32c2fab00e2459a225a21ea578971527c2025d10fd7b8cca9ba0aaa48152ce62c193db4a9c8bcb85306149a861a5fbeb459e9e665d6f168a946f2738068deae224b304e25419c8463ead93fdba7a6580d6ec738f8cd254ce3cbd690c46b2d7c0d5c9b9d8e8c41d39b2aac01953fab4516ea715b55c14ff7b5f551fe80d68cbb50457da45204a12d771479c469895a287db58f9176bee4a43277d1c27947715776f36ef6168a1eedda2ce5697326b80f0539c3e8e640502904d62731785d543eef2073c09aeadb36f826b17d37b21529ea1fa7822ccd9d1156945dbcfa73966caf90d5ef9f61da5f1198d79020206ed0a75b16ff7478309b6839fb797889d20331b58ab5e886326b7ca9926bee379c3662afe030ee3ebd2493fcecff54f7895692531126a40d546c97310c0bb98c9616619ae8eb1f1479441f87e9dec18fc072965549530c90c8b77168017f4407772abafeda5d27e783b28f69e1d1c998f78a77d16823f21461fe014bcc83e22b31ca617461763ae71c42b805ad92989d4589c6ec9a1155fa3d3bdb939cee599fb1e90c003ba000e278fef6b109f8e4039a176c3a0c9ad638ebd7818064607b2bfbaf61f8afdb8e03651b8ef799bfbb26dac84d666992843ab280c8b44d951757d0a4b9a5af7279f63b0a52c0366f38678c2699c6888ae9e336abe94f909127d70e96d5ae1e56fecf4fb497ab27f07e3574593b8c6f087c6ff4b753e579ba618f10f9acb8e9bbe52289fcc865e522cd81564a36d10f910615904a80eeadd0e4da6fe5e081cbc82aac316cf089da1a020b1aa340fc97b73ded773f454f942609f781a12eb8e7710320c7fcc85f9b5c5f437b8a6d598db5add2a435198f819cf00e04d6f637a6fdcf6d476d1cb85f6f031d490cf1645c090299f48835bb418a1ce65d59ba91d4244b8a956d16a2178429b8d6befd59f40b8aea8c9c4324ea382f87d11ebfe6a590d7385bcb66de177f6cb4f7d8874fdbfb608a7493e511dfc281715a77c68631e774c5aa6c9010cea4f0e19d515837f47e952bb0e0caaad087a91551594e2a43ee6b47be48376f545fa6186bf44a96322d0b39e724ff5ae818d842962682ea02fd2fe1c02ce49ce7067c59c1014cf54243aa02db43b521de55cc1605e35296f8e410548dd68c4964271a4620b12cf69a72f57ba93a5d73c802b579488d3faf5f7db7c1b818f89be85175e6f03b433aa82ec36f21a82b97529845e248e08300dd5a9128f6e646393580d64e2e07db6687790763469f17e1c788865850582b2712cacd309d5876adc1e947056cc4691887996a99329f9168f2c7c4b996fbd6c8efee032be94f3d09c5e9c0c6961a169453011d9fd7bc2c2c9727e4fc547bf7a5720ba601649d03058408ea85afed8ad245c969f27b4c85e09148d0136e8943ae2d219136d55ee6e41a3d01d183c3d951f86e38b490a0714e83693eb27876bc0f12ec552f04e062cdfd50cb86846f1a08db74e9806c7d3cca8f3e655b9415daf35849f403509149c40eb21b33aecab274ff88a544d454572ce7e8ba1347afa672156b8c9fe0df07fce2a0eec16768d03a01e34a84bb969658fcd198c22adce0b00f0eef556e684ed0325b61f6118c5cfbf5b03ba1b6560b0137092147e16b91f3ae43e50588a4cd7bec3cb660f4965ab89853cbbb887c3db7f00b3ee146cc80a10993d581afeb957e8d427ccd6b1053ed8e7f5f3bc04f63cdf82937d53ba4e445b47ef27e61548cdba40c70572ef3d059264814ea541455cd4645915d46c5052dcd2ba2e347a726bc1e246a60c87427a0366afaa3f5012e233c596241c23bbc01a59c420988385d39e0e9049e5b19d7a3850853770c671c6ca3c0fe69ec99b0a2615dc9386b78f82d0c1c5a689ec3a844c8742ffbcb49fdf3e6ad44ae482cd8b41ea50f66789a8836f2edb1af4f11769db3138dc712f38f21e67028a07706fca020a29912a1ed1febbec7977af809b49660e39f56f260b6cf9205fe3f308b4b6d413d89ded4d01c9442d184e2af4ffec943b9cc282f94d81eb2ed65d86838c4d9df3f7689a93eb0ea661bb48dc2f678e219940958839e641ed7d93d0e223419bf105892a9cdc7d4e851eb46f0298941127cad15e9747a5424c249a811efb7b47eb663301001447788151a6a326cf632aa5b1d6a8eaa82782f5b8899f1fb9863dd144314c544dca7e9636ccc89ffece791bbbdb412501ce21eefd065e5c5db5ab926b99c5145de73c1c83f6c795590ddd1a258cb88f0fd2e0f4987164bf757661a398d22912266408351b81f531a0b3ed0aca34f897b27e980b4562a7a849dbd3bfa07bb209f5282ffb6c6d9c258fa79daacb0014bc4267876b70446731861ec2ae9841dfd144332e20457622a56eca1bef224f788e4b90d99b7ea1818f529e06dd88539fef47ae6939949d81e9aec29f9aadeac854212925217115dfa498639ced1df72bf81835532f4484833911f6140b84eb322a7cb029cea1601496544d803fc3f698a30079dcea0b29bfab10ca310725a09ce78a65ae91946f9b90250a141842ba89083938807ca611dbf39541ddd5a5c86a56e0aa8c917fda1e201d2d992d8f831d878ea69b51ba369c7628d08ad1f0fa66a9d6d942cdb8ae8a86f602d83a88ad8b1bf1abf3d6f433a336d5ccc9aca93842bfc4882eb0bdfe2abc494b6be30195e571be57129a93314af8806a1c4fc3fa200a5a87369b7ee4a019f2ecd435e170f0902d6793ececcb9c35ce1e407722f32bc7ad4f71953fbd62a5edf77a699f8fbaa185557e5548a2ff968878ccfaffb4b90df648facb930da983a0e8ceebe13ea55ded617f711b2d0ace1ecbbf1b363adc3e429f1b79b3a2bc74d8b0557c19b937fe5680afea4400696d35a24583831997177456a6b416b2aaad2c8f3f56d87eb6871e9d2e9065220333cf9532c0d843ea11376bc2410391125a7e5e45e6311ee70adc7218e869a4b9ffebca84616910552a3020b13c90ecc64ce8edce979aaa8838873b393aa08169c4b45109106b8dc7987ac137f273530a64c948ae620c9fe23633869bf1b0ba53bf70c3e4cd0f58f586b094c3d9305f8fdc3452a0d69e387a7bd6dfd24b1ca5c03f61a0028184886e0d44e57cc2a23a2fd187f91b76fcb00a276a5338fb3f6b2a7add08064be4aca0cf6404b121f02bf0848fdca2a34f2052f04ba6165de2cf05f0a9db71e49905a8312a187e125cebcb9db1facb1023503f59d631de71b4bf9c1f42f9129a5d8eae9a7c167c87c19a3c8ecf0c8bc6d3ad92eeaef0260d7f136915b45a2a9b6ad537ca0922a7a29852a92935018b49e41ab3aecfff385bf5643da2a12083885bf3bb446a8dd3717ec6d2b660765eb3d81269ac5cf3a612b67339f40380dbf4a7da67868deaecc473ef7390a0592e018ffb36522d76a6ca89796732da336b01096a9af54f7da0e6551c43933a36fbb7790e0891c39f1389896dbb4a1842fc6a8adc0b3ea93ca9d7bb202d2d8b00473e28915a14a0635daaad13bf96d2e7823755f55db77380a5d283b4c45e89bf0a7c0d81d9482caf5024960a8c39c01ab81d152e240a9ed7b9bdd1fc0dbebdce90068df66396afb6a4e6e91eb6c6f70f028099fd32c264a5f3b73ce2724febe4d036f6b5a777be92506c856c13574fe9f67212e754d506d1775c134b23ba47ef838ede2678f643be445869607c9b1e790b567060890f4e9151c42afda86d3dd1b7e9a380976403722e668e83ff704f07ce2dc4df454d11ca2adfada498e90da06a74b2f26f8a317b7754e7f94f97078de99413d4473d864ce735a564eb77a1e718737070749230f6a3f9089d77ecda670a833973d07f1d04413f8ef7babecdae166285db8defc9aaf08569e9ed9ba7befc8dae796868a0e72dc742f2fc5fc1e642f4561de0dcb3d72d13c5aabe596ff941de4e45c7e1cfd8017c61a31cef8f1d3b1b4dfdeeaa9c4b9770300776ccb242b3dfa41bf69cb00e67dd735aac2a48e22cd3e78c124d2da36ddcd042e435fcf687cfab334fd91aabe493dfeb719539f8f7942bbf8faeb3955b45eade206139da675dfb38ecb3e0e10352e0470a017cc82414f632da71d4d41685b7ee1877863e3bba3ee63d1259fe722675a6c3b6e9e577b1ddf86619ddaedfcbc563890357c739924f9fd65ed9039887d265c03048d9355da915ad9f4bc1026f030712a329fd326c36db337d0e9ecb658debf0521d53c36432990999c15846bbb64f3d32ae58589f36ef45744b842bcc09db75a9ddfd3add192f20241668e6f309b64c65e416237ec01d0dd0dc5c68ed6d6c97d3070552f69f8eb6aa2b1d76528d6d53b90c1d9f1602b7cac70acb46c97613e222866a4298d4f105ddc2cd0d4b81d02c3546e09f44e843d135a076ee9cd427ee7f0021f6286ddaaeba59b6f4622e6ce8c31d23ee688a778c143b0d3cf947a898b30f01a779a39b297b4e6a91898978cea2ced00e69e64f679fe453d07572e93f0bd5fcffe83ce390ded32d871bf5cd90f9c66ba3cde504c2db349e694c72cd8d4ccda61f463514b1bd37b75cb5dc4e78ad54fcca450b2875d6c40caf61193aba0f08541509e34379d61add209eba98252e5d7ee9e0e819b819c3420d1efbf47391d16354cf5bc9ebb2681ffb4b397ff14134755127cd5d8c3efbda13e442b9a7c70561737e0c790b419c3c3cbd8f1431ea4c26bdada29f304537ccc2bc713a31cba305d0e7b90f79b7c0ee8d0973ca572169f6acfe423aaf7a94cac4aef7ac2b59d6583c6dffa6939b584381b65bee51fe906789ae3b0a7cbfc49dd28e47a8b20b66eb216c9b5c5dadeaebe9bc080c03bd39a66b4f201960b26e7efb6d2867e2a204a3d955e04db91641bfdf17a75c300dbcf2683d041e9f98189cdf15eead80c9603be89f6cb8f68ceec1dd812ff62716fafe6bac0a91283f86a25159b93a07e3f4ec1084723a85eea4a2c1862c4685f7c5a760f90551604dca73f2bae53ee5f693968837f88765f93a5e9af315368387db063d2996311f6f77f95feca9861da3beab60844e7dde2ca1245de8f0c1167e3b6605ca3908ed1bb4e4803a07804f264e82705a436418e172655fa376a01c082425bd7d1fa8386b928d1642ba8cf758c499f199ab5616bea97c22341ffedd5be5c7229d759876a9d666194db3ac326f0fc5ee378ea6b7154cd41e3f42c3484563d82efbc7978c94a7ee67f385e2cd68c4fa3c6a09e0246867a040690a08706befdeefb93be60b09ee0c9a875f1d72036a487134be08b4028943bc2b01e5134c4f5bebd18483d87e53b28f209fd07cd2416db323a74ae7d0c4e995bd57cb2f509488cffc5997e7a285c1025748ec44ec458238585922ca912022dc6bff35b346a6eb451794ad8a7c8e1ef553e5df53a68d11024c4a07710f7837dd775909bb8ce125fb4fb715615059a7cab0609d1267ae07bbc4cf56557ac34e33c6c7a1e4173aafa653a195298820f585c7468bf18a5b6e688d0690b10da8ade2efc4ee8201c0cdda9865327069b461b6ce85d56987b4099f5d3702f9b6eaf3dd2bccb03fe06e4713112d3a29ab315db1c50dc8fc0bb43394d49d22caccd1461f0d2cf9bbf7bbe1aa355962854ba7f76f26c08ed6ead53581fd95d6910ca0039ff5209677bedab7ccebd97d2ba8ae48ace456a9a30e7822f43318dd2b100afc778324badf8d4865617a99c9d2e4d28dfa0a2c3a482df4935b247c4c69c548ba65b55ece96c9789e84c6ef01f87b8d4026886a5dad577c2ef80ef731db00f55f5d08fce699554f1971fd0a4b535832a1f55854e263164e6fd74aa2dd9a2b7aa95f2967c348392d4c094015f68be4e89a59ebfa9417f5e074e29742ddfa6ad4aa1897ec869a3a21d149994c5d44914da20f29e0f768053dad99bb62f501382f11a5cb691066216042a792a98b8266af74e5bf6c6f91773b524d291b670faa9b246b8050dcd41c29f8a9d0efe2653369d0b11c8b9d4771483918c5abb29838521be88aeb01e4368d621448e473d949a353208a795ab360d4e6ea27b199874aaf23cedab7db689ed79bd1e897816531ab9af14e10b0a0184bb7eb8f640d7267dccca355ec75630fd892beab5de04b7be52f6d930c71fd8e8746ac625f62522fbe3beccb8ee6ff766f1405a12c07d9abfc94cd814efef06807162558c9eafba1a5e79e1002f7c47fcbb27df18c4a5301891d93867626a66e2472f88b16f1e14f61b9b6bd9a2a1e90d3110c44bf3bcee44ad0066b237eabf3c3fbb2b9ad118c7cf2a156af68e0d9c72ea413ab6c4d9b12ebef9a5283060b09414d0640177fb7b2c22a04bed14dc02dd76ce9c541643325714c5da60fb9cc9cc26de7c2559a15782888aa82667309e7ca3b8c3e26fe7737404722d087a3360d916600c6694b51f5b497492d884b5a8e749e0fec4d4b0a1bf236161cf60d440686fc1b124574c683c531d6d19c0af181d1786c859db1c0c6725bb273b0644fe5f88517eeb8c16f3acc2b6e001e04d23b72809399f010c56f5bcd321bb8ec0b08f40c16b6ff444dee2cacaab916f1223bd5498fc53f8851ab671db1127860043127c9a9f39c609a574206b9248e441d06509f6649d82df23d7b685858fcd71ca026a1feca499aee0d1add7b10e31415feef3fdbb55805337b022e41dcaca5fc40e35fb70b636ce38d281c2620b25e0818cb45d037f0c2c0c5fba3d9b5c941347893ca3a99db0edc159a089882efac1aee835f3ca32db689fea15d9ffd1075a3b9c56d2efbddd9ab0d82de6c303c0ea42c152cbc33addc229c1a9cbe01e06393773c72287f747fb03759a01d644d1567730d576dd6aa5609923e4d25efb47a930a96c9c320a64afbf42a5d122e7cd801ea1a713e6f1c48d43e04ae178a017d67ba9c6bf09bf075a99c5f5bef1a2e0caef9cc0ba5c6083691e688596d22e3b22299a4e255a3b797cd568f3e038b2447cc69098bde0b1ee0e52fbbf030a1790b3465adfb8fd83e8cc8fb1511ed3b7819beb93fb8a27f8473951ac48ad1dd9b11fd3a5b1dcdabd7ea866dace76f69f0ddf3a52081f7688609c0529887b9df3ce4652519076a919fb1f33894c7f7c0e5270464ed84ff8ff600e59ea9c465ae6f6f47e8c93f2f533051f66ba7c8e33910f09527c4ba5471767cd2c2e88ce79ff2590d3b2918616dc0428dd36d737a23281bad7ac5fffe0287231ac8b310cfba82c8fbb6a21ad148362b0db7307d6ba6e0960e1ee9a7194c27c8c6d0579e930e0d24decd5a8aceed30177043c87a02ed61e220c44e272666f391ff2a44a476aca02575a52c337827218b9610940bb6afec5ad8614ae2a4767bf5b39c20dcb5a62cd209328e98c4a75c67f3cb2bea541c60b48d45e844410eaf6828640fd88e7609d788858473d09c41c12fc0d37c25178b29c6bd53e967e778d435940510d257ffa2395002af1cfddfb473d6ecd849a3263c0493eaa03f22b808dccd45467a31ba71f9550848e73675d9301b0d6bf867c60dff4f94f0f4c929f082baece2477f29bc3f6836899e1cc128dc18b6d3889b8c6a8a441ff5afb155c0e80352895179ac9b38d3111486043d242b7f1461864b330592d3e1d1e0fbe3e401085f34fddc1c1c9eb284225991ffa5fe839e0f7c448eabc5d6102365d70108687b0abeea48be73e7e84c48b490f33eaf902cb9f4e29f939ee3b88458ed372ec6ca6fb99e77113b6071b5bfe2cb833e8e3293aa6b967c98e2f00e07f1b639a73b127ec2c9948873268f61358f0d3c754eea5b19cb72b625668114e227db88d04de13819f94a8a3d7443682dda845a6622d2ac84e1287ce22baff5ffe677b179a29910a977cb2fe9d4c356bc24e5206f2ce754f59971642388bcc20101e538ee3c38acb59e6a99de2415cd5fa5cf3ad248f8cd9e0a8f9bcc08bb02f96ce4d3906c9e4cf635ea10eff3fe38dc32604d57bfb27e7453b5426d012145bf492433dd9049f05b2b9abec235517be394c980e235d9581e44607c547afe3ce41b0ebb8ea748a850fb979dc9a7a5393275d101281ecb831258ce69bf958dc413626beafe63cbc4d664a4b896a47c38f8b951e06a1e1eaa92de3bfba571292413f1e0151e9256bf343546ae0c2f1f2960f0641cbbaec7b09116edeb1f34eb6bec0589bf673a6154c6145d28999cad77fbbdc4cc85cd46027127f2836359fc7646db6df206cbb4d01e87c340736d255cb249031accd470531c7ffb0cbda5b3fe00645a4cb105f5aaef403869915cd7c87d9f7860aac5e893ef21835c5c5eb6ccf003e367908171e0adb658c8679b764cf974af73adf1bf94307bb48ee4b8c647f69206b9fc57330550dcfff93a3cc4ad544592ce9516a99e6dce0fa6ef5c0c6bd5f6e9529726542c1a5b76db8730be778bca498eeed7e8830fa81908108ecab8f36a47aeb0953e58c4959cc66e151d029080c80d7c2bf9e984e685efd225045247e40770b1b2c6e7dbe8526371dca2da0f563cc6570c1a05af4da74b9a58a26da2e50cdea36597b801aecce99dc3ded4320ab92941cb67a7383bf2323af0cc4554c9a4f3c579a2f67befa0dab2943a7ca307c3efc6d298bb74c7ef1f23ea6b703cd9dd316c91e07374714a86c06eb8d365a568f1834ff4dd24f89d067f068f92ac7fd515e28eae45d2a17d5af385418299f55b65bf811efe08faf4540e137d2affbc5305d0c2df5825346c73b8ca135153d9c8636a0176b1423d96533108ef839c48f9fe055ac679e5f704021723e3903381fb15f2929a1f8632191d84fac688c89a936f2fb9b71a8e1f910aba90f6b6162a22cc8f9351b35ae06fc8567fb9334f6601630dfa50cc3962b50017b800dfcdf904ea2721119a6d07934f0b7ba7896f154728cc58329e34e4a82425299b0dd0f7043092f57ff7e1d5f23ab46ac3a46e21f3f52f7adf263093747eb585811a1e48378440948311b0a835694e0cedcd02e14ee32bd24511669c60efb5b324cec51295cb6faa0f578b9c2e732b165538b119dcd66a0aea98253acdc8194c662899d7daebee61ea48567dfa76b3c9d90c3bd618ef22419b8d2092fc04a8fa4759e922aaaa3838f6d6fc6a005247dee9bd20cb350cc06e18e0756147bb987090f8785ada5d4b5d2477c1c630938b04e90f1e03934a3e66e5d9c8c527e24a6ba25364db2ff3aea2e693106ccb8dc85a0ca8bc679bda9ad87278734fb4ffe5086200a115f878b311984cd77d2b3afe6f4de8b40126a8f0cf8271e6b5b2e5e67f1b0bcf572a6d9184ec4873276f891c8ac0aff13cde6a9b5c75bfe14488efddb0aeaa1dd5ff2898ea451b0dd157c4e58ba8bc0e43e6375ca480c8ca9416a19207ef95717913212dca7961a32ee7b3609ccdf1be33ea75c94691fe935f55c8c79f2cc3b1b9235a8db6d3464f6a560375a2c1c290f805da860dab0a08ed1bdd0bf9e9a6f486d682406a01318f0df60d68dfc8f06b97e4c9db2e0efa218e26c608d7b32c67339d16f64f0ab09541a10626fa633609bf8816898e197bd59d7d88c9a166a7ab3b3d9134ebbf76fea8936aecc594e1b301cc45ff59a64c9c3cc2ce7713e7b1d6f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
