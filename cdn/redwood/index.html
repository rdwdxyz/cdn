<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e92ebd96eedfbc8adf71d62b34b7364137d54e1879a92f2890c3d9387e4da24f8d4773f74551554da97d384d7430afae123d1ccaf9b153fab4485596513b25d4796266e86604a9f7d88fae7de41b04ed96b4fb0b19f5376afa03075ce3e1a26464ca744dafbb39b7e02bfaecfa129dd41805963af7e826283cbdd4c7c8002218e76c4cac38e8a2631fff8ab41a7aa1246b8472f99cb363b614c1b6637dd0d51ba99676e956a5d2fdc9f1ef39f35a27951a5368e6818c8720e68fd03efaf65fdd7b6d489a96718067eb752d17040904ab5d28f253fe5f006529c3e9932b7338d69e2b56137418134e49877833cbfba858f2591d07e71736f1b812342338004171b1968700cb4f7f6b4be638f503d86ac0bf9ac6ddfaa4ab63f7c7d75371387800a9091f1102ec87533bf743b27cc3bcc8af95fc908aecd35c4bfddbbcb2d633469ebadd8e1b88e112be8df3267feda312fbe77dfe2617285d2317db1f3a332188f7c346b1e116905bb69d7992214275884a282cc53009048d0251757b1727add5dd963f72baacd6582bc14f858e024704db0cc045f982e7ddffca819e1eda7df3254eb3159e05afd90d885cfc2e3762079809ac940b32b3cde5d3f838a5eb268da58356995fae4550c33edf88730ffbca779696244eb611709d496f632a62d3153d6554044c3a8f7d91eb12549a21114a5b984d80bdd05a5f76896579b3b610bb7b072ead5b3b5ced34d12c96aca36c77a2748a692db98a70f9054432b3a37e50e4a4b4b36689644d40ff0b8b0adad87907489c9a06c75ade95b6d8c44431bb5d96a96b22f798824fe719527b63bf613b38f10c594a0b44aa20f00fa30232a6608e799112a40da568784fc878270a9e8e9f98acc192107e6ae91f25562f9a1f2f20e32d6fed2b0b7b6b3b00ad2ac6c7368bbee2ec61d10ad8133fd246d73036fb6a1b7e3d6eafd48d1b2ad3966fbd659f00ff56a60b02e415e391cf134f02264ce34b3c0d2e203e07a673af0957a85a0bec1f45d6b742009faafd40895ab9ebf2602acfcd750ab0fe8d216bfd6b711508ca1e7735463a7c6aae33bbc44fe2b9b80479ce84bf4dba6a94d8bef7ee474ed64f19011b41a7606b441cf312fa755c3e550f17364e30cec3c4a7e1e7bdac663a15888a828d746326268cbc3ae4aa4ab48e7e5d19be722a32a16b397bd5387aaa0624490b459570bec027c13ae00066b4de0565740efbd6d50c7485ed015dfa73bc9d877000536305d28b9b6a07af980cf17b2f2eb88cf23a4cac08d49b2577ca28c4b6f75d906c5400d06be1a742749b78949af61741903f4377dcecb6bfcf85a1073991af36b1859eb892bd9c353f9983b2a113ddd51af01bfbb596cb1a9914e83743e12dfa7bda52ee913fd6e7d43ef6a252109a64904d966171e4e407f4d664cbfce03ca2116708702e7c4725738b30274466066836c88816802c76911f422bdf82a6f543ed4156c08a6659f735d5c9c819ea83235086effed61b8c63047845f3f3a53500a0da0dd65076df1951cc28002479ffed6cc4912395a1f9965220edf44ba46511047be251b28ae3357ea81b74757275a7c003c0953e38c0e41267b141be91bc78862b216420af959cdbc5fd702000cc9e904e7a6e75fb090fe04a6bdef749b1f95c81cde778e6aff06bef0ff59d8cb45c39befd87e307a3088fe0872f00e422e108036f34b21d9cd4a027c4fea60f28a99de1c98f6094b1a836aa1c621204cb0d39a4b8cd830c027749d1b1b56dd30d6697dbf1e11477eaea81f29cd6f03eed7ccb78d00b86ae92d7c5e8117ea81530a5648fb23fd0077c873ec59926ea0a085e18d37d344ef9e031d3f2a2a5852a3beb7af1e16192e1272c8e53d280035f6a44495d9d5f49fc98c12783647f4965f3f40bd12f1da2c9737f67d385524fb382206049b36d972cd70f9649cd46b49f8522e3bbe76deb85a17d2df83853bb3d59bf9089ded2a4cb6cd5bebd9ee0e24918342404908d2b1715695f9f6b3e297e8f23ffa410bbf509efc3111d61b1aac191ff83a9c728c62c099dd42c6eeeca52333d3e33cc3492599c5dd47279ac964d76ac0a67ac134801af4aacd3e6d4fe16295857b24add2c049248b532f7848333776dbb24dfc07ae6e2bcdc04b7f180085a26deafac4206b6f3cb9296f9122b679032c0136a3d738de6ed8582bb526408b9bb44fbcbe4adbddecc75307517865d8e000d9d87a1cdf763557c4142f3b2c24a983ead7dbe7fbb41f5569592fe8b37055ae87b0b990b234f367bb235df6c72b8385d69daed1a116dc895205c4044f0d3843a7ce71744059abe85176aeda4bc17bfdcb4784f6e014e6b776a6c0ee00ce59ebe0a7ba9e279adba0a98f5b0b660e45d4cf554c213277505873469c461a774ef9ce25828774dab644ea0ed620bc35ff084eadfb4cbf2b06a8422ff4d2ac66babe5f64202f9700eda856067cd499f5ee582ceac177e6325a13a1d95f8d6a843e892b54deb2c08bf5d365ed25348a8b0f510524ea80bab4e07364df9476caee3f86abfb210cb5d8d011d261617582d928c1c2214f3e5e8688defeea5f004be3cbfa690e9871b3e705a69a91c2ee82f6da6080196f28bccef978142ef74c53595ecf2d4554b9158c1d4d6a87bc85e8da7a086c5ce73e2e0466ef516b4f7241a6b255d8133f87560baf47da8210849aeb83f44e721722e51b2dbc6e9d1be628348f36dc351962009a59a5b24af84982e2b10f986cfcea4781df8f86523f5445b1bf3f0bcfb39e5a9975f2508192b0e731d3756c95f02b915e96752a1241da2ca3ee6d05ba13746f34c5cefb43538a6ccfe60e0a090a8cfdd1d23e0a6721543e1f541ea8a213d2d16e4167b596595e64d73dfe1c780a537861b0302e517d69df9d7ea082d02196eedcade7255b959cdbd96fe06552290cdbf9d2a02669b661a79dab3230d7b7522bbab3becebd732dbbee4b0aa8c1dc046808efcdb9a98a9ff3e9871600b67df29e4dfca0d3df14dcd5a8797afb5128736fdab79c928a9e55ca1925383fc0ee83a612acd974e5351c59ae617d83b8c6398e65e83c9838377f79ed8b9e337c7168a1fa46b29410103f179aae008af03f19057aba5535533afe6798bc523d07ba1605031f401b01766af884227fcc9eca56e2a6ead0deb3cd4fb7d66e6d24ec0ab3e9419bb776b2a0f445ceae947ca0463b21a5a132bc15d9e62e64139bf7be907994d3bd4553b894b22cbff86c8a8128e8ef1b3a68a05fee8caea3390eeff52f56a1c93b95c79791f0301e0fec2a804e2ccc091c03d4f1e8412c3c94b29e5a3b81454c561bb46eb58fb66d545c68902929825912cf042687d56e14bdb913a19f97f44ec9cfd68c104c8806d170c9d46f582583283dd439f1f2e5b2b9154a466a94c787a99d379621e487c106b54ab105b8f5c7310fc71d189423220dd088c9af28e56d09e1d20fd16a44d644f6b1b4daea424681b4208dc7a7a07b38e88900c0548b4f90471aa5ab4e33651c6fb9496ba136de7d5e535c05a42cb9acfd169109f857c24360cd2cedfce2f43d6b727b1097d29670ab002e77debf52ab8adcfd1bbce613aa904ae6bc393c3ef424a41eeb3b2b8d379646cd05b1e30c7a3b250685d8179800ddcbc99f82c3ad2ad8fa8e57bfac77920c993d0c127cabd74de9b04bed6c3eb2b5391a47dae850fd964509f557c655cc75a9400583761b7771dd177a6a8edc4f2ede74168fc765e95164d898954e0104f9dd51b98e29831066e8d7aea1b175f596d60ca007af113f70f8fceefba12ceda98bbefeb01a0cefc6d8acd4ebb315e521aea7795df6c134c4bd559440d8305f7bab59364db8a7cef6eb884a6cd4ca3ce9cf0f6c21b0ab6224830c44ed5633284ebd95b68ba44ad270e8d42e9f492f98b0bf55d7fbb2f50ea5a974748e1d6cc87f1bb04238e80726864fedee9b3029e0e6abccc3c8d4b9621180b9fcd10129987f995e951a43d5c368479b51ff2b2756f0fe4f3b2b7ee1ff35ab9712f5278d18bd263b5840cdd54270b4edc6a4397a9350aa776d5eb77846c5044865ab9e3ae51ad4e56639278d66c880daac04fa905ac73a0ff6a6a19357e9b8556a42855a9cc0d1e62538d778df4c60e05b3e403e870a59b85edf5c1086748dffb9b988bc2007fc6a299ef1deffd2936233369b477760dc560f04ef2a1504b08605714d6cef061ede74fc189aae9afa7469b231977279dd630b9eb352600bcda71478b3400feeab68d3df83fb7aaea00844b6b55ad53a5315d5dd5e54aad728a8d301b4a116874544b6dfa239577623fcb16bd3f13aca7aee8a798f98b4500edf8ca89f8db007fcb85b722b64edb97f85e20f89d52651f58036a82a5fbc2b43f0f429f2270465ed1f1b9c8042b0e83e0ea5edd288f1ebd203b33f0e196ab91b0fe1ba29ed680b21615b2ff8aedce2a9ca8db0d6c3e06d04343084532d5715b21876eabaa3bbd5accd3a88ab5ca707a7b766469fdc154fbb3569e74ce79c2d36e1a6ac533e8b3d99f79804dcdb697afe8345103fd0c5c3d2f0983d5ecffd3b63feee645fc861201d743f992cd119f990acbc413cf371ff411722a7f515bbcd554e7a1e35402c3b02e1b1b05e7a62fb837af3aaca5d4007b35c0f2dac86e05b74b0828a28afb8015ae3512b44266a8f40ced65b5d7c9a263060db8c9b95473f46075dd88d2c4935446da2979f7be61f50888534726274c1651747cd553faefd5903e78a9a2c1ee788a66daeb4c76e1551fdd4c584e0dee01c9b04b01fa090526b089b55a583e626a332b5fd65c8ec610261b261ef974c8ecaa7d3e0a03d20b887bc97735fae6246a58d0d2081205d7d432a5f51c8b77d8bed9f529adbe040137d86367d1ea29aebdca3d011c7025a8662d0bcdf13266b7b8d96383937bb19c301b379f323a51f187f6723334f8032d7d4d1c1f1ff3c9092d9a2a3096042c25e141732640fcdf5cef70da0cfc5676d318c0b8b673b3abbf57c20f8023837dda5b61d30596ce41544b5b524cf3f4c842dfea6dc46df2944839e2bfe95714230ec9463b865161a6a82fe588328802c592903d6a618b0339739925beafd37df8374ba5a751237c39a10fcfe50249a9c18a0dd3a5e9afd67117d3f5bf48b29c97c196e0e03394849dce43713d091e63d6ae0a4f1f3dc1eddbe5ababec4fc33cf1c6f8f1297f21066e4f863d23f2c33eca50827d0e1375e8ef66f8c1d23b03665ff1362d0fab95f8d8a5f9b48cf8c909551498649629d9696f487ace3e95daddaeb0061696f733cca7c7a802ec2a91f47047053143fa210206bb00f59b8bd3704bcce3aea0c0d1a880b080ba09e51d87b43b949eb3e03edb42d540129576cc113f0582d4895db4f2275ab32152c8091e1298255d2a5d7691bd468690cf623d21cf877cb7efd240e23a7d06dd981c34e36b1303aa2096d6de5a90aac2585fbe87e505eaddaf3efa022ca71b693109acc5a90fe8842b2dcc3812ab345e5d545b1f12d75caa8d3c7bebe7352d3b84760fe7b2f758c78d229981048b3cab2f8855ecc9a0644c69db190ea7f7565b8d3bceaa97b939520eced0a8ad6dd54fe870ae670f0fd344b07169645adb510b4a0bac7907fd6b9aa7f26cec91e15ba281ebe4739fa1b3e561b7506f9751dd966f0f3aad3b1ffbeb597fdaf27f84afc990085661d2a0a364bf070bad667dc9fcb7cac4dc24f891158579fab347802219eb67776ab97877bb35a53a3011fcee5c1e7daa839d6ea93d98013a49f32b53d8362c8d740bc3ffda39b44dd04e113cc1a7a050ecf5e002101b048bdb78adeefb0ed360c6a2e2974ed7aceafcafcc83f057d6352da99349fd8a663644c49813a37b956bef206537ff0cd72a4dfb62403d4441382ecbf73e5958fbe328025c15a821c3b2c8c422b6090141c8477afff2f2b0f4e1cceeaa9280c090d8135673d94ee0d521b029384049405e51d4009a3051c2f950f8acb40670e3a7e33f3e9d7e3c39d7fd6b65ca59cc4fc369032b25d8b84c6cf70c0b1343e093012637e8c6f1314f42192a93156b571ebc2f00ee390ba96c83023ddd859a55da7d9a8efd8778d97bcaf48b065640d4f9251d92a040dde738b200a1aa677d1cff2aed0fa221aad32e4628defb369d83bc52be831361af7764125df40c961b1ee6d5aacbc1a88bd6cdd900ff77683a396a24d7ca7bd874a7aad1fa9f2f91da5dc82ef7cd2f7ab59cd7e013ee0f84367444b85e48d80f2e5a6b260ba86cfa7dfac1a69413e5a02b32568b32c6adefd002bdef6ec1b802193ee7795c79b86c484997b10544b3dbb6c27374c42c660e282247f5252d366beafe6739e1aee9dae5b7f75a444a0a52f8aa0c17094b0cbcf2f488709cc4d561fc4d5b1ab694fa135d9b96c76ddce80e000f4b9e088aae5679ff7073c0f416545efdf9ecff2322410bb5199fdca87e46b8f4cbdb8f8a884876e172090c288f2696db6c3d7835b448910a933344c924f5e4256f7f71ae2ba80e8abef6c0ec363247de69340a941b3215aeb879d8490619b9edd1a6482884598eca0935a948d2770419b10303127181fcc9d72d9e0a06df333f167739694098525c5177e924ff69002050af76f990d9c8a26a2c4e1dc5c17e0dfd328676567cf20a8bb6a0af00396239ba9b9b13297ca9090d0053c3f2466d01ef4b59cf6aa03b8a663f521687444113eee079cfc8b18c34b4bbdb4940b929911e27aa25f95e2d046f4375b2a3835f3716d02de390f52a4bb2a2817dbc6f8182850a1ea7b9ff2a5d2ee047cd55b6d34c02ff7d0858cc555c5bea0082a7c6f350dec9cd5fe8b4887e7a591cd5b6bc4d14dfae51364c93f0faae7bba388d516aa7dbfa463324d7360e7262b5aec9832307ddf351ae21ce0120db6b10ae70c417c0ff27a29f968a6bb4be4d7732e4bbb0f827837cf47fc86d233a387aa95484ec7ebb93af462ed89338886440d24544451ee84a5bcd92cbfce33d184ba2ec49e0162748f20d0c722f393ffaffe011ba48abea905243ca1d4c9bed7469d4ba29e53219ba188dea75a011bfc5d9047142c688dfc3043d3990c0f0a28bf4511c84f12a2a27aebfd32ef0f89dac41275ec51975226e97b8975b757397fbd1ceb90d56bd8402f669b463c6b308f0d12ae218d10d8915598b3f0dd0e5a5198d796042ec6f863671de5fd0a5837e2672c0baca5b81c29829e65f9d4816e8cf1d2be9d1c3d3d4770a275a97900cffb1cd612e0e82c97ca419c8938674370909f2a2e8ace39ef743f27ceb7d484b9eb77948bc1eae6fc67f705b228522e5d927a6945d826e0ce44e8d96ece3bdb153e2951c6fc7e7a0a374cef687eff081a2f479be722dafff4e16deb691c143ce810a6672149b03df6bc7c45ba674935cad31211a376828cff5d8a46c5aca5da12be77bc6e969e7bb0d17abdc22410f1460245d8f88c81b259b4ab028de5ab3a7b1f12454b331cea868f22a440c2d5bb8ec861216b4625a9f9f27012870eaf2d53ad8177da890a42e6eaa8f64ad673e7c9abe14dff965ba0afceaec29d05b4352c9168a113660dada7dc663ff3c79113b818773da57f0209d8e7ef796552dc0d0ffce7ae635f864114b67272091f0ca58d1a9f0518050a4340bc8afb473686b69fb16b0361ded73ae4be709d9ce4e29185e342ea3c202d1c191cbb771fbde359688d92f3866a0ad7d1a219ad54af29f327993ddcaf65ce218e73aca97510f68293d507997c84ba1d3dee5e5e56bd10449048388463752d6a243bda3a7670afc3ff060496a460eda33e3ae72a71eea28467f93c757c9bc29ccc1aad9377d487c2a50b8d647e98f6cbbb07f82c65c87f580554490ea54a85f38500cdab1cb8b6ca9ac9ba9c844be27d9c60df7cf01654b42f5c74917684929ab1ab0733338972f26e05e19b526310c9d0e9889cecf45a5f5c3d9d30f5c2b3631aff46f2330861724050d4eeb49b42659275615b9035c239fdbc52f54782e4bc9ba9c3c5d8a0486209f7d93779ce66570d722c2d043f9718ee37fa68b2fb3deb2a0b138c47bbe87b04165ee3ffe19cb27c4fb3f7207bc9f43f32aa787046cb565f550ae5b47e68ff7f77cf66fce4e8311b553dfba18593bf0382402060435761850ed4260b99eeda050be770d695655caa0c98b187ef4fe4e59fa18a92661f84b3c919d51aa9e966e3b66229c581beaf1d4aaba5e39406363660bf11b51023643e6e271a6056b7bad8ec98505ec79b406db8efafdb6abb3d9985b56a392ed30f79cd5a12fc0b1ecdbd3d2bb486fabc20a69b68f14c23bdc9c35f68452c735a7a551fc5314b4be46b77635710f4411e013abe70e164672a8f85f631ed61f691216b839c420ac3f7db978da1456a4a7dbcedbf4d89eef775aa4ddd18c0577956875ebeecbba5f7b26e275baf1a682d678a28d32ea95fe2ee949563dda005464f1f45e97bdef4a292483f433b04c1eca2872f30c7f8f6e8877272f4c6cda4459463fa255de225c99af1483e5ecc77fa4a4c3f7b95d51bdb93c3a8d0dcf4ea03661cd36702951421f645396b9e16034e96c8df1c5698fddef2c8c1dcf80712f2c327f69b2d9a65609c807d21e44883670ea2858ce45635a7008dc6294efeb591962384fd81083b5d71113a0e7700cc64528b7b55bfef3c04df7e6c71062b55488ff7e523ccb8f18455d07cf598639a648df9302ddc8e10ae50d9257e3915987082870743258dc171dbbdd6018d6f93485a5ef666017050ac284ee91a9f78e7dfdf5ba4acf0df7eb5c90cdbb3cccdf7574b0d92b6280ee8c12e353d3f3611c8edc72ecec2ba553449f604ae89d25712b40c34f3b169a830ebb64af305190f7f819e6630a73aa9873b5ff0b376a7db0efc5e16612429b65fc9540c9d7ea4f0a0c21d577ea27d2d07b8f8ce6e32d3de9ad6edee9a782554f5fe3ca74e569115107c947f22d6ebca7130adbb35562aeb5e6092c6a7423c4f92c8270abd9a7900fbceb7be72b555eb9b402fe95f36aef4cd8618e8dd928a1490692f50fc3e4314dab8001a6970f6f307e7d2c1548f755879b427d657727a4520c98ac8cabf9c7d05af399dedbcbc0da3fc29d31f2dc89fbbe8299698c8d9e84d9698c0404660e9752ac7ecb09457ca1b73bfd26ccb134f5acc7e9a60922010bc53f52f560c1b04cfba736b259a427f3ec5dcd67a8fa30d9e934c168960075e126523d20fd6ef8f9a04d09dfd7df01560b80351f95fe921d96713278e63c98631c6fa9dd36d91a021d49c1cbdd73897c864d5c53cad5247b677f22b2213fe5cb77a8b8b5586a31134e79b5738d39209ca7fd562948d792ca4e4207f0c6049648d5c29336429513ef808715885aed6713e5aee851b31f7b51b8fe66f0a0ebc8ac5f31213ae542adad7a5aa2e6af93b821d66c94457d65b16129d474b3ab23a75eb63c98fe9eb275572f81a85157b54c725dfcdcafdc4c41e84e20b3ae44bf1026d10de169e02ac8cd351dcd641c4f386be1233c8713a1c69fe5952862ac4d06e6bff40a74af2fee006f114ec2272e4901d931f2182fd705003e2b1c5383ff7844e7a6bde6f59c517e405fbe2da3fee0484cf7ad41189bcac920de4b1e5294e00ac06a0a68f5aec2094e8b9fd36c4671c0a82f4c032a042e60f3ebd4fc41cdd1cc3ef8d14401507d5bad1504f8bc122c41951b0aa7664bb2a77a8e8e0014b7c7f845d2a701cdc384746a9b62e7deedde6b8c12891b5e3500b43699ae49b4fd5358ac4e00908860f4c31c7b6b6cd81f866cbc045c87acc76500001fe1088b86a518eb4a2bd10877f99468737640795ba46ff99aa486dce903bc16af27935436388d53221838286bf135e472ee839060ee2ab09b8fed9a3bdb441c2ce575ae2ae10f50ed36bb9f58eef157b426726c75fbcaad8c055c934164c2eab7688be8e81f1fab23eb56c310456d31517f8caac6137a54467c2b77d1c848a7c34ac6628e2dc5ebb855883fa8208524821da87b6520d3e7c4db1b46c1b7bb5c69ab9e0ceff8031b48931f77691b333e4d87cedbe35bed6efa8f21f86e2069fe31a3e8c7246ea873e9105015aa113e6247ef824923fee682ef58fdd99f44f9cbbe970b9fd2b930ef240f780edf22c46d3cd1bf0d398af7bb3ec804093e5095435fc93e52fce7bea1b593665f1824a2870983404335d212a0957a0faf5d0a918d3fdafcec631856336125bd6b1a684e936ef848e51c5a3f749b3434d3a90c55d06099231b306713c0f252db1efc637ddc6c7adf906802f3aab2428f394f1ef8ca5cd19d5dfb77234ad0bb2186c58a5d47ca7675984c3fb3b87288d18510797f482851f41b041801ee5d698b064abd1bdca81910c6dad7d75b14de0e1fd3a71a61e25a252a5af01c9ae5014cc4cb514648d944cc3c891d55bb94e91a16bbb6dd29c54ca4af84d725fef446746ffe9055e2831753c175829e9f77c9c9f4d694ccb77563a00ac4664125ac220e985f27c921ae4e2078c3f1a7bdde1dddcb6bd90a2bd4912af86700dabc1b9f8e68e3d1a51a5f7652f94733729b81e1addc6ac6a92b0dcfff938e49953380f3b18389940fc6c47664e4f57ee5d14577a606eadbd09ae496f96806fdd061a654cecfedf5abb759f97e30661cad2363ea4bab554ab4a9d1e8663202fb54ff06a25f1ed871ef1e472c9aa7f674578ec9789bc24dbee65f6384159bc118150f1fea11fadddc40d1eff222d667927b8eaad416816847ed534fad6616753aa4b6535803f6af244d858683a66a9a6d934807902b21331cb783d95de9fc91d0346ee93b4f8f00a1098ff902928fb45f05ba3b876de6aa8a1745257e90698f8afe6cf21f8d11ab0e97c9c1f9ff97f55a1674a61b5b8b0b703fccd18f14d3a2d729bad94927231c4ca16baad7081512ffb4f9083541a77cf11addf0807831cc5f1eb144e2cb4497801c76e9484c125f07bfecdcc341a3b4a6e73603de52d6d9db5cf9f75cd231de0e7fd5300230527cafe1480efa1d23c99ba106b4270d586421bcc6803a40a85fde34db5400c58b913af329b2bb39661b451a686684c032b2fc64383ec09be07ce84b6710e0fdb5d867902de21c3da0ee7eee6f4e5c31dc72d833bf9afb792d96a2125fd602307ee312fafd69389773ef48b6db156f92405c7f248a14013708ab8f1173d6496f240144dfc44e10b3d02731cb1e4f2e83a89358d7d24b0f66b831452f34d6bd4dc694617f39da27ad48b23d93fd0abedaea4ee502aee671a55c91ed2d71243cb6a543430f4c558554891d240d22160c543c070cecc28f128f0943bd66017490e917f2def6f58ea4bf6a0893dbf600ada0d5273d9fbfc675e12a666a434ace1a06423dc8fe571d7326b7f1d593c04259e57acde41248ab281bf200c113102e4a2f0ff4b8a33706e0b9e9f3810b57eda511a40d8868f48355b666f1ebf7f6ebfa604b151385f9c5f4a63b5b3951ea787c8f1138e0a5d2686bf6c953879a5e62df816a726699b36db514f1bb9a5959a4f65cc1234c878cafa0cbe9d88e7c976af9272dd46c805554b0f3773633d05e3d493ebfa604bc72f5fb4311ced7dfdaae109256f7e50ccb3437e52ed1a61857313042366d31a729f8b363becbce8f1542088e0105e91c7b8cbdc47591f25e6fcf36b6d6bece708a4cc6864854b7933362af0907ba77840a45f8825afb5392358cb13c8ee243ad57602802f93a620a7ee2e3a2ae8b0ef0c472082d308b7bb55128d5d93cadf2b56a6f45beb78749e23f40949308f72c8d79b6cfdfe29eaef29de82a8e5202138bbfb997e98fcd0562180cea2822daab85c65bd429343b1ea5a32ce00071c2c4f943eaac2c9bce767a0baf368264d1405d7d114e00bdc9e52ba255bf02a798f1c71acc1f4cc8cf4ba2e1851ee4d5f15277edb9b29ec1326d5bf05ed1c48f24ead63eb07d2a5e1af5bc2d72e8a7d4a9b3aa816eeacb0ea6219d685ef6ce75dbc8ebc55ec2a6cd6852644425c07fe5c79849b82530b5b3b843957d18478d044f469891c728e05664a50eeb67208c9f207ca782477fd0c342a47b6d820084ff80e05faf9146285c9d3dbab0da4d602b0365cb123520aaf3b1e45fb391b2e7b0cc2daa5d5bc648a5609ed6ff841a8e91df578b94461394bac507f509a3684b56826564a4905945b50396cba4167be994955ed7fe5bc488c0bd3b52c2c0e04c824006f3f83c111c1b0379b62bc226a47d8bb8b56bc6f2bb5528e227f08f86991f018cfb2419d8e410b91d3bc89d1e5c3638d60e8e814512c7f9dc04e523bb5f051e769e533648387b72c3401c42c1fa5b7793bb8713dcf17e82845341882e8d7893bd716dc2cc75b3d3fa5308ea1213114242738ce98392c93ac5f0477748a3799c76b9f85e3922e1335675b93d3f149074b3a78fec1c1788ded631ced59c58d61fc9d386901486d485f82169424b178f2ab5f6eed438ba355b2d0d43ce39af04a188e6efa6b56a5a29c9516802774a55c3b6bcc8055e86822743bbd7a8672fab8df2d52d159beda4c50a990cc8590c277f87f62aa38c6a8f99e72bcba24e195e3af48eda55febbf2965de5ec3509a0c27c019c0be21c73213c7e840442280a91fa6df2e20feb812c2660eb96cb50f47a4c301af6073cb6d10519140195ee79de7760f5c20354785f448314bd793cd53619f507e3b13452e0e1540a9ab1229842b6c584f2fac26502a1df8e10bf6107b86293db52e723efd5c61551646974713d04dfc2d9d9b7864437e75c6fd644b72b70d498df1893b39a68df3b66f9609f195d34634228fc59d4009d0457b3518231eaeae03e4cd2fd86325c1f23de0cbc6b8e2ef695df27ab2ab70456ae914a1c47fbb515468517dfcc7f1ee0d85548f166103e1f81176d53275dd2f701f9f13d3e9d8ea853cb922f472d3a12560b7be3db5a440e91a96bec23b342ae959534aabe06d02043189ac098818d3173b5ff7756e0f1a3a85cba30617fa76c23f0515c17fa20698062c68f15884142991138c0d14d44180da60e46a61658147d2e63c4e882086e458ef8d27f7dc872b4ecd14d793c23ba417a1fd72fc61fa865eb5787da017bc613ceb163edd2b8e7296e5134683a8e1d1d9537277173c0f2820ada5e6f3e0a23a1640f33601a819daaf9a15b08809e36330a53e0616a04ec0f72facb20fc072bf87a376dff746bc32823e6f5561a901bee02fb8005e8ab454e4591c6a705d9a4366f95e33b4d948d0613b8fb8e4e117f5f2b1122ec29fe2544c2e90268b96828b2db165049b69ebd308ebc4362238ea825f7cee8cbdc175bedab68fa72948db639d8898cfa2df9e6d48849c901557c7b6282a90e1ece2247dd0c5b919bb7e3acd5478e7cef1315c816866f34de2ece81e0242769bcf92b378f7f7ddfb97bb3d9551a830c3f8b6ac4698a245cdbfc52f11743700ad5a185a2bb7f1d9765b18c72be4aec289b38df199ec3caae024cede4f1552ea51e191f08ef39926feb2ae556d95338ad924463e992adc7b1f1a518f1760fb671ad07e358cac0b1e1f591f23bae140d89ef47246033689e65ab3b91d755e251feb0f244c30daf92e8c9b5c2f1600136997efd5bf46c13f52f6560c77fc647f47dff08bcf10105cb186f69b3efc646201d285b2ac01c7aa16e1cec519c8e5a40397c7cf7548ea03056060f3906e06b08955f907c5c60f4c021b223b9c269d604a4f93c67e4c3d7958797ae0528f543148010dca7aebbc73e61cf7543658813143602fdc888edf19a3d1e02e10fabd6a0f3d24e1849610aa7dc0256eaf40c26a737c806c0dcd778aea04a29d20625f44f99e713de72581289209514e691a03d6a64089ee289ae28bb99c333447d7eef70b7ad5a2e110fb90ec56a11aad5de84051c42ea1c3ba59c03a0c49ed07543d8ec5c8e552155404ed08eae025361393efa5fd39036b1f7136784424985b3b22e03c8aed8d5e84a584b24c051cf0352d79dcb927f09975d4ca3e198274659f4056f1f26bef137a13303514307b306d2467f23256f166637b0d31f2cbbb9df74dda48936476c1c75f257d971470ffda7cdfe95102c63bdf733b20ee7f9877f3e9a8f3a1ca809de5f06d98f0956b2f068726c5f467ac84432e0b71ce4c5fa214b9e57a6976ca35ce9f182cc3511f8ef0195b7d5e307fe8722fa9f18444cc3d15c328ac36868f92f9af5e7d8c43098bf9ade94d315fc6f6ffb9dddce19c23173e363947d6824cdb079310f74be56d118283637c9788ff257b96c34a7a46b816ab475ddb8a624de8f74f65c9f37fd178caee4c02e765aa578d04c9b553a2736edac54afb4004e99b0cf0b8919632084ecf77d9de6770cd01c81d1d8d582ac0119c39005235f466a0e38946435317311bb09d1220ecdb03763a983f6882e668ce2721dd95eab1500b5a12f67ddc87e360f713958d248f197c680cdd2067c34b206ae057698b861b9703ba68fda65de391ce12177ae38424a2f34c6115b120d954f5367f9b56035567a2eb96bc1276b94e10539061f0d7741560c366f750bec8863eb73347fb6c9015f810a5320726d0eda587655ce17360be0664c11bb48689e626f57f1400d1a82c3dab355a95f7f1a341b8a0d40147045cc0077550aae29752ec662e2c8c7bb96a4e8ca522830dce1800729f62f025c36ddf11affa4f3dec4087a6af608e32c2a28a6f3712b70470eca2373fd30185f2eaf670a36fb19537c5702f208e2fd7b4aa6224bdfc300c1ff4e1c6c75690acb88deb775c11f8e82ec8b6ca1f17c78f9153eb69d10fadcb6e827bd7c3cf5b717fb478c27c371221f285b80a37ffd7b418d7e7b062f37151f95f954df7d28d84353576d367f8221e8ccb96af527db94bfa308bded55f8e000f90de91d4c73fc67e1841dff0fb6870e2c920cc7238d8b21cfde0f654a49d6a0527691db37657210120edcc60d02ad93a228ac41125f03a628f57e4c6215f5f52d7be8cb9374df8119425e01ac47913b808d042dc152cfba8e679ba642d88b41d13c67e09a9884d8a3f7fc24e6a3b49392c0d708ef56d7eb3fb8f237929aab2d2cc5c4222b67fe4defe3de06227a812aae1d676fc9bb939793331a79991feb8bd91c2ac2fc9998119931f6c7fe6a81a327915fdf50f0dd39efd9d901f372f440400ec574abbf308e76b8d0d78253364298f33d679386867cec7cd3b192cd066d633acea867df99fc93a97511349761f490999eea3c0f5887dbb8337315c9cb609bda01dbcdfcc372aad6a48554c7bccb5ce2ae14fc64f032957e8727be14e73f5e375e0a7b67972ff0b0d0986557cfa8b95cf47e02baf23d68d9dd74e4e7c10d3290ea4c28cb3ae26ee608c5d1e09e4d79d9003dcdb85541990e76d6f649107caf001607dc3053fa2c86f386e344183b4b1418211c70576940fd8e89b8684e7109ae0097a5d2bbad145a6ff71ffc78f2003dbacf8accc9fcd724240d529ad3fd91b09819b636010dc0b7f2bec9be07a23d00e0f9ce07a6400304e3ebed2e3fe04ab443477668204408ae090d8f36533a865b40e197268bd2e0c96e8b925c0dd44e7b4054dcecb3278351aff38701879f98de5e91019e6c3b865ea6d1f57bea3b6205285f4fc49e9cfcbba9229462cff1960ef3157756b6f244179f2fef8dc6487dff63535df3a3f32ed5a0180dab5bd789c099e245382ac5188af2c6ea384239aaf426947fb72ab00ad7556ca40a6ec0bceb54f518ca1c16d8cef3f1856c913b07ef44e12b773d2ab92893afd166d4b0308e6d46fcd2a44eb3ab1d73008e277e4e3fc9417d7cc7baebe0fb43116394698f12fa0d72a793d7f06d5281d7e319aab2fb935a2dd09070ca9d56d6eafffe178c2f0034bd443cc0e2764672ea4630ccdab5870ff06f3d48700fbb624684a4f4d18664c865e0909e36f2230d24c256f8795be5291882814750d0842c38f816fb092dd28eb3c89ace6eb2fe2733c435615e171d9bc5b975f9a18addcac20815976956ed9d31bc7188a2bf2732b76523b1bf5f31c5d7baf8f7d6477d61cddbfbde9078d1d3f2bfdafd32578541cd667e3373bf843293dceb596e3024ebe542204949fcfe2d355255837a6cff57b77f292e1374d564369592e6ff71ec952d8bc142ff4d8fea7dc6b3e6f1391deb484485a0d1a1f2acf02ed3537b87f538aefe0d46399233b9ce7ccffc4caa03cac717bb5cdd6f3a16d9c6ebed410f775f3276649a22574cd5f0c094d23bf568339430ddca702e2879e39ba3f36f0348d8cf9d348a221731a95aca65237a9a8ab172d36432c861af28fa6e474aa329c1e1d27a150551e880c552921f4441a4b5a4a73eda1759eaa2ff9751dac9941cd70fbd7f889c8e9ad63fb838da4217b016bd7cfbb78298f69d3955f970c2c598626b14a79f3a3ac4af3323f91cd98539e123b069df7b91e04cebac5748a297261adb768ba2cf8bc65e4ec4ec0cb4b932c523792f2df1a4358f831986e3f99c6f76c703a043d6d9b822fdfd95f95ae678d8408410cd340dcf9c2da1833843da765286d8c5414b5bfe4031e243552075dd21bc6f60440a9e78baace744726db02264fdea812d451e6510390b4ba808cc44a366c8a4ffd29b5709300d4d7b97aacd576f92b333732bb14e6bc03534184be65136fac1fcb96ee7318360a8705dada493e53d6d5f2045de051b220aa48f2a9869017883a79e81ac59673d0d0280cb4aa93f934650d6650597086ae850c5ca7d6ee37c05edf2bfd67266554bb7b525162170355af66799423835493b4ef3ccc21dc6fa5df981faf401b2b47006fede7b9f9a5de0989ef9d60524dbe493ece088eb69d36cc17a502a52f817b580dfd19a9e7105f758392ab1c304c45df8c02c31ae13c09efc4ffb89d6c4ef68806ec2c7c084596552e68b4cb56010df60a290ff56362db9b0f7b14681eaf377831d1c4bc7af559975c40dbfd04f02106bbc2c25282f1e67a0466daffaffd6f09086576b4866bdb10e4913ca035b0a19b0782132d223e9d24c063dee42e197914cc71ac73c6df21bb50940788e53fb1fd43bab6b4b1b48bbea694aef6ba196d8be210b8065e52bbe43d3ee94706c6fa9e665089eb7f66c386c33fb04e20a7d73e406a62275e2b11eed8b4d7891582ea33f9e3c3364aaa4de361ed33769e184662a8a5b10b324d8fccb1cbe7f3142c90acd342d5d377fbaf7ff8c7bdfa7601ef1fcc4052d3733e7ad3176a8a775abb475dca2d4d9fddb06a449d6a4f1dc811b0f496853ffe853d00001107470b5b94886aaba1b829be9ea509037e5daf04d29d74b46626b9b21e7731a32266ebe487aab1346f141f71de3f5325490e73b0fc24518eddd91fead12a90561951f25143bb150f516bcc8304b7ecb4937a3753af3b50681a078c2dde56e86532b817092843c31e201b93068b34df541bf68bd0a2897ed0f3374479023322e24819279a80765511b93cc79d289fe31378294c35d1bf1565ff36b864126945e08c3c718290e4e7d7bc88fbc0974646f41a9644f00904ef7af16da19b008bd787659161b24e016a7f9b758e5dc92b95cd8fbf964a057fa4fa72995c5f20189b2bd075a71adc56f2374d5eeff7db4b44b23eee2f8d9dc9a7212237455f1fdc855d4305a39e7cf385ff6664c2e4eb9671da05e129070d7c19b2d69e4985183ec92820c0caf17fb82b9c446b3a7788746c5d5563f5c6c3f21c76a70e9c8aee429909fd9db2acba37022f3da2a57d12ddfc7be81a8530ec4a005ce80c2da1deb204bb6a1993ae159f59e9222132cb393e48e4a533d8f2eb76f90ce9a7a92ae80d60f40ed12dc218abd5f4b5b5d602568cabed0725b697f13c5c9b4680ddbe573835db3cfdaf4aa861d75294cfeaf7875510488adac053eba476783244bae2b947b569efb8e63b6f69a667421f6587d184156ade8c762e14aa8d29d22d8fe7d7a2e9415d3f1487086a4113d13e9eb5159c7dddf9e03970b062c2df4aafe9ef121c368ff7d8eebc8c61dd3976fed0e495ae9365e27dd8105ede97298e3745a5a0de6566244a4b41843247816ed9fe11eb528","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
