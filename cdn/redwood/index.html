<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca24544f2c94daedee0b336ce4bb451e5a4ae8a5df7aecc0a7392824ba156faf781171dc22e1ba0274a7be1e4cd687c5b16279666ece41579a75c520470f244c96a546012246183b7c755ed21f457b0f7197a29b32833e0d58b12511c99364aecc3371e09bbb847d621be32385b6f4dd66b7ccb520913690813cb69ec16370be059bc4bc761576bed09f4289529f81f2cece1816d5a74d5519fbde55a8b80cb8907a71188347268baed11a3eda70829a88a2f271ae4f29f30bff431f730310723943e945967528bd36f7ff63e1a7119e5c846753a1045b0c04d6df7978860254d8821e9acb4ee7e79562f241e29ab0c8b843b0c683959d462ea125fc57b5209497f69579221ea45207f0b129c76a000dee2704f0cd3d6c05b415544795e988652178650864a15ae4ae1ca788e257f8db4369624975151eca630fb7f739207354f417e8736920cad8fa9f10bd8b1ec7053238b2a68adef7382abc1cb289c3ae3d7e3bed8753fba1fd715216439e08eccda3376adf0d61b50dc56777aae78a4059af0d6490200175ed5798bebe199c91c272b867ab7e1c022b27914950f454880d96e43c6709a45bdcaf3368ce3d5bbf847ed6d382910b0fffb11955df0bb9c64485c0faf2ecfd839d701291bc2a328e9dfcfd977127f69d5ede6d1e7584439525e66e1ed4ee03e5b6638180712843d5b8435770ab8a343b06f3cae65502f32dca942bcd30ab0cd0b4f2b6e89b889b720f53218f27c0a27ed98950d836fd0dbf476ad4717ee64417e2a18c75fd66fcdb4d738ff97e5cca52814a052785b96df9a06be411cce9372b43199b603376b00577e0a98de5ae75c1ec527390e86a93508c4ae063d574bed5ee24dfd3c4f3d9c4d2059713f1724af95239b44e46673d34601d18d3256067c60986fc61a51653708018d9f8f0bb1112b2cd72c17d954d22b3c1ce49535bd911824202176901e9cd4e74d2598b502bc04b411fb69f2727150babcddbec8d4e02db324e6a804c2fa8495170de567b4923fb3356a41a7cee155412459fafe6d76b8f1c7fb152dce18437f949e05e3a9e65d5d0c2f3d20e149485141a7576b1953f8d86c15e0d2d0a88f9a9d4407765a2ab4059ddc3306cdae1191221cdb421944e34c691ed2800e4424175519e053cdd953ea42645915ef5f8a54bec5cf64f5c35def37962a608e3996cc2bc0d8a559d7609a7e37fdead85767ebf8b15b51cb50b6d3d2169d5ee6190c3e69f1d9d1a0466ef3747a1759c0bb39a8f67f02b6900107cd4f6bccff0a7b8ffc3f428d2d2ccb46419ebd28942a29c12ebbe0b2a59c8786efc0602ecc693d629b4d201f6daaee50c01a7a8fd5cb4a1a0ffe032221d952c00abd6b93deb6f3d75623ebdd4b13e9322711aac0607300f2f560a27c2c21a1e54187b22fdc2b7a3d2cd1e77bbb350dfcc6689bf0620b71d95e6a92b94dd1e5375e7f49530d19d754e89a5da8c241a5b9fc379b8da26668df31ab4cfdc11edd2956c71fae94f8a645607a88b74cba2eb7ef70fb39aae7296492dccb0ee241f91c78c22e00452a41f7f15c853d8ba63cef0b7ac583dd4a4f72e028d901968d316fd3827e3d91dcf7fa7673871cd37710dac93b70c75f594dc5cea491513cc0822951425760b0baa74b72310b7c7a632add90ac0965fc2adf5379edf8060420079fe96fb2d92cff3f9aa2121b29c814260867da14eae122fd44f607cc63f2b7da5ce29f6e96be563df47db13d53ac5de400081bbce3e905bcf297cfdc07ed3f4ddd8ea4802a04632bf5a0ccd2c7700171ef9982ed6bb2a22078a6e2c0209f959b22c8a014bdf6e6fe2fe8c51aff7ef5e516b6c8da37d888c8374e91ca9899dc5c933c8aed886358f94b5a91a4b63585d905c143b086d22f75cf4df46138fcc8f76bb52c5e326dcd01f0d133059570f637cf90a6564ca6dc35c5deffcd8dccf81f4d86e965524e69ce497c338b28dffc42478a0032d876df5190d49da42d019b6cbaeb431c9c074ed1a9a4a8c3705217ac538d31376c3d8968cce15898029afd4316157c42d7effd0ddba24323fedea09b5fe802017001c72524a4bb5f72f711b19d53650bd6df11a353995faf0e81355aa648b4af23827f3961c0352034bbd3dbb85b80f94992e9167b3b3b66a1f95300a651b31f33a73b4f611b9ba74cf7c5ef9b11db9486e35806a3aba54913e728d02b6f597a42a57c97d5b13b2749426df490afae28f926bda1cd4ea490c97cc8d089e3885c017b737e1818402d4c80f53f427264b04dd0386fa5317592e09f597ba9fb8380612b6cc91ddfe6171016fa01c6c1550e683a832592f1e304b416674290774f48f59a233465f1613d6fc0be3e57e51436b5b900dd084100055efac5c4f1a6605fca28828731d1095e9c9b1516ceddc4cb638ab403e7e1a71f840e3b9f1af2d126e89cbf22303e785820e32ee041c819b9a8c129b5b13a7272af7b67f42b129f57969db7795ecd97306959061a9fc1b04bbd8f7411481b8d221dc5c62442445405c7aee7ed5bb26059183e15bb2f24b1875cea713e1d72ac6b5d3f40473c6c7c28eaf516ce3dabfce7d54a5bb56a8e1e95d33c28176cc21cc6054ba219075cb630abbdf3ae9edf281f4dfbde4ae9b92d30df91ec91197e7f3f92fdae894a3b2d9ff90a62f176e20c1a1e59a9cb13bc0b6fe7f01b8d3390b7cd8830c537a6af20318a5ee570d8bc90a19bab95fd7e890d82cd8103d9c2b06ec52b19c61c6ed8a3e3cc1e1b5696954127a6a75242acfa291584b3b42401db43dbbf0d47d9ff2bc5eadcc3e09c1e02e616dfe7690711dc160bbef1dd3f68acce717acdb5f7a1815c35f08758678e969a6644c5bca9be12df2b0e2242aeaefb20da5d90b7581b4933b859a63d3ca04c4db7d7cace1bf0020cbb8469a39e8691252f308cd9fbadbdafa4f484464abdf0c2ac9965a13273a727c8ae6222a68afaaa6e1838c0ea06b680513a75ee9d0ded001ea899653b7949674e0649b0992d181344a948fe5daac078fd1fd7b86f36313df287dc7a461190b38cef872611a42c434bb54ed2437b95db259f6ba8a9d2c3428e9f734778f0800b728190ef0baba588da2d343691c869e7103a901d732c3263f08adcc050682652922debef6f1ca84cc8609d94875bf9c24061e00b6c60b6b9c8c2f8a6fc2f72470f3a46171ae73e87d53ebb8d6caf77f3dbd903ed47fd34fd1441abfff34bbd54cbe35db53b6beed2cbe3a0f6d99021cb58bfe24088ed097a4ba47f522c0da344dc28da16a86c4ff4bedf11422300d63ff558529c9be9225343eb9e3a9e32fc1c0b218113b84cef74f2781dbbd75a0b2ca24b902b9484c90de705952ce0f0954733b7fde24f90998f5fe575dbb5bd4837193eb589c72406639a4f4fdb0d2e9d9f992ddb112697882f288cd2cf01d632ad8aa6abce5c53995f384aeff81b77a91d7bdf58f6fcaba8089d88badd2b3360ad2094804e6ee28914e9aa39e2fe97350ff1dedddc0c101bd0370831ef13269dc29bdb5b12a243b91e8c39bb9e475927bae7e7c0595bf91faac3e6a6af693e2c21c922b341547ad316d005152474d0cc9ceb6519ce25f7433c2428a1ea253d9809c103916c5e06d650d40ccedc85f76658f41a9500b01379b779628be8d9e6761194e3350305456ac1686da4c2396307e6d577145554b686786a4584f8b5e8009d5d45b3bf325da062d11c540a49829b314346e965586c0f9d73e0cba7b1c2198587e6d8ffae493940521b3278fb00ae3848dab9d809191bd3156632b5887cafb2ec80c808d93a6fa1067cae0002257bde2198d6c1973035c3ce5956efa94244520d35b4551ae27ca86783e8d5ccae72460743ff7740c0de15694048d7472f030876fb9b9fa0c8a0475d7b1df34188b7dbe773ee5fd40c103c35dcf45273514b5f5bdd79f62bf0bc70cc111063d6c7bbdd70e30c3e6fb6b623840e9c86d8258040043690e4d0137e675a203638f8cea85b2a72e4749acc1ef4a0bde0720a98c98fee51864039c2f1a32296944420610e82e19e8f55a578662280243ec88ccf7945b4b9a095af70c284f35fa51732dd7cd253baf5403fc9aa63219f71cce0a5d2199ea5bb5883222a3366fc71f92de70bf18ff91bf14dfbe01e4145c79d5ca2417246f7de55c5d597cae993e7de671660ccf8cd37becb20aaec8de03fa5d3e6f430a2a4ff2307475427023528605aa305627d4a73d30a2e95b321f09ee2dd6dba2434fd166181821504b813783e0f88c622620ad716407732eb9eeef28b5351fc2560f971a38d658fa581a4294a406d62fa383a7a297904fe6096a26df14bbdeb33dc9de4d25ecd0d681d01f7edcc1d4147c71b1cc979b0491e1ee1fe806841dcacf535e155fceb1c913164e126fc9f88981edeb60948042fc903a84cd735746236fdde35d62a511664818e113b838d93103c6d233ec33ac0e24f5b2c85ec07af3f83b331be1388a2476a36cd6433cd128038764c1550a28c071ef64318cc4903cd24da3a9108f89fdfac40eaadb8ffc8a96a5daeb16fdb35ef1fbfeca79424ea4f23c130f03a264a670bd9c8f17847590515435a171720ecb412d1fbb11dffac30580cd89e9d0021ec9560e123e5a5392151a3b37e980c530956640b92ba3e3be2b59103b3bd38a071bb6fd411ea623ee2457820c339252b0190a91d41537389703b84b140546521050f974d30f9f803ddd68694ddb034c79c73cde37c3ae07a77c76c804bee818bbd68b4b2175157e2fa57fa8e3fb2a493e95cf5ba543cbfd455ad579c3120d24170745a75fdee841039bb98a6aae4355dfcb53becd99b270a3cd5d35e3c09a12c61debbb27d5540e8dab73bcebd4bb112af693c8546bf99e5b9a4a424c4a1d68ae65504b58dc96d9db4043f8c19e7b23b945a9c955f7ac55815bc7198426c60899f6cf9d98098e8ecafaa529543d9d7b05738e57466b42479aaae70689c3797bf96bb08705000d8d806e7ff1f2d223e6179a799002c4ababe4f96917529e1cfbc7e81761f5267ed149763f13506a353cd52cc1931ca650ca77ce4cb8c0b6a161ffe6c8e07199bb26967e016649efd7f01ee5e7fc2da9118a8c373c8d4e40f8489c63f84d774824ccf9bddf534a6957950b3f5509fac0e4c64e53464a9441dd9a2474a327f0e0aa49d8f294aaf60b73084933b47e526441fe46c881574f3a0bc76bd8394d6152aa1f9f9e60bb084b33537add278cfadb82ce0602b69d8af8ed45504b0bc07929be3c61d59072e3e804fce09a4d04dd0048f41234aa5abd2676391f2f0bb7f5c2a75800a656bf93d2d23daddce45e5dd97c88e528fd53b858f036c352359c07d94b4f1d861cbc3e151bbda92b02f5f031f25531e976bcd8bdd71f7c533acdfaa917209ace0b7a86543f197d8257825ba93305fa3cff4c778fd6f4f24b4563adbfb1895ec81c962bebf8ec0b02103591e7c241d5d2d94a6709a8598398bb04c1636d5f4d31dc7f74a4fa5af06655c2babce74a3152da094e8e8911ae47ba0fc9d1f41aaea0db94df64c77a1adf59211637dbb75740266d359bec7c77b6c694ef1ea1f6c9d95d64667b04ff827b9432a938904bab152c91c770cbfd51052f03bdcdf49ba3255edf0abdeb3dc85f2d686673823922c71a9bf38d21ee247f58cd880d3158acb771dca15e69f63683c5b819b9fee8ccc79e150e64817285e636f31c8cec2342c81e326f3c2c2817d605d493d05b54edfff0b9d9f2ac4ea64731ce4e38b3f5f98329e543111f361da3cf53cf92a28c2cd584d4dbeef4a2f81d9b7a5545a1d4e5b652c68c387a6913d1c543808033111b632e0d95b6a1829f7e22968b9708b10d0be9743e574f6e1eade76dea909f2573e744434930f401d45b8f87e12fef178f7413c711aceb98c926f204524d9dffa8e31ee5c78dd7d78b6769531e5af71fca319607fb76643bde2614e5fb59a708c419f38cedcdb44e55bcfa0d0a2bc575cdcfb7407d631a6edcc62c3e29359f1320bdf53cd7e39032876439fe57278b8640285b430d2b0d8f62fdfb1454f2853ce201dfb51fa11508d7a94f0ce61a8ace536b461424afc66c54fc03c42517b73168cf35f9f5e281426259758efbc7680a6e3ecd34c1ef9a489405e5c6f050698abce1eb3d3a9d074761d1e6a7f07ffbaf79db780c575a587d6a522429a111142d6c660175d96c60c914551690e2c04b34a83d53890b26b316501bdce689a2099f7ea6f23cb47f9918dc3743f6eab7abf0a53e644b720a4637618164e45ef2bbc85bdc3895aa8e21ddcdff5d46a30f7a0ce49c49b7596488a522a74d3688664f356c3c3417952d565f39d15f02968a20ee03ca9c01ad85773e1ccf5d6cfac48b333b2643c45545f4119c6672e606d26d828246f308875b4ddf700d0b53f1faa3465de9d775184ceb7968b6ac4345ab5793f631d465f512c9c190acf3d1947c6905043be229e7ce75dab72c3c94bb586fd9ef55c1b44e5cf6b03bebbe65e7034b96e75be3b46b172600eef2004739207baae83e196c976a1452bd28f2590bc3efc1f07972a20cbe8967fea739eefabf084f7d135e06cfd306d1efc80639db765d399d95690e68539451c9c71ef26f92c437ab739113f72f6616ba2a4867b5c9651853c24cb1d1b4df64b07cae38cc57467c4d45ba26f613b0d5e38ba0554a38e57f858cc0e8149bb3217211bb32aa0064d290472284a6c47ca677e85eee998f4664168529955f0a795a6e781d3a48a313d740c26bc793f533dada3f80d31cfe9d71eb105f2fb3517d8d56169742db1d2a90ac9367480520e6093145c07d094fe81f3f8e3a4f97fcb12feb86bfaae28f324b7ebf7fb01a45e6109970af7bc36d141e6e9dedd7446548e5172ba40c85b9d02b67299718fe8500d6347c73bace7194337ac4a9a911b9d16545b491bbdd410cf282e06028bee1da951e2d047d92ef50724265a97345df5901e09b33897de27df7bcc9f1c3de9fb9eaa63c8b83e55f534aa2103c7a51fc82b29188a413e0b01d118371be0004f20e279dcf3b6ea35b816809a4fd8837f7efeab7c74200194413215711f452b9533242f265d0e0456a9b7e821465f4d3b6ed1f97df9cc0479f0bd969dc5ac9cc30523af84e78b084448eb60a00c8d89b786c74ebe47d2d0a5b8b60a43eaa65fe8eaf5c7f742906ad5367e903f131065466d04f684fed9b0a06977b41dc442e5b431e7887ca2859f60a4a3dd08a0956ec841518863ed86cd3d05c48310fb62baf8b686bcfc264c6e9edb4021886edf58ee5cceeb1bb32dd87b7b5180415928ceea4378e045a1c55c277e6da6ecfcf084553a436f1434388a309763d3095f8039ec6af0b68b7ed43116801e29c06cfde66c2ddad9096993a5c953c2fbadbe564ec5df898bf24b6941324bb58d6c13654219b68de0b3215796cf9a90caa7bb09192c1ce3cf040587d51333b71190cb03f39dba867702396b6a6737d8ff07903fbc816adc595bc99cda40732bf7f895c89da45d022fa17c6bc46d79249326708a4b198c363bdb17a48d6697bea17cd213123cbfe490d7f90ac4dfdc548484e733c278f30f159c712a1ad8e68dad7a2fc8bddb8d9deba91be0778902166054c6624941a895105deb87b2cafde2295aaaff7426b745db53a0ac73bcd30bd070779cda18b2bf31aa14f6114d8a6996dfda4ba953ad890991f262820466f41d8dd616b946528a6272de41f410bc9ebff0888ed0ee1376a58bb5ea6cbef30d4497dc5ddae0aa01a977dc3ab603dc9056887c7c205601ad4b0666195fb73b2ccc561cb382065e52f07da409295c8e093961ed64a7e2c7335ce0e0ef29ac883c69d7156787b3f645e39a463f05136f9bdb2d090d3aac581d195ca16b921070c8a9abfa831b4445021a4d3f9056d46f8308961e33ac6b4640137fff2c611915be9aaeb49534212f9fd7b04b234174ee0f0b42691944a2cbd9854d111b90bc23f8bb9c6a6adbf05fdfdc4ab71fedbfaac876b8f673269b639933cac7a8f988444deea3b2fd8ca7bfcb579cd24217a7e2a8be964b78a62a1c4f7d8b048e9ce5a4d8bddbcc6e242395f4e15a44edf9065340b280dee05bb0932850f3ff52bcf9c0afac6cb8ea45af203c17297da6b231db5d188b47b33f515d952f28a7c8573a0a1f631aeb11f5b3aaf04901aa1c3d3029a883566aeaad1d73eb2eb11215261b11f706a434dca40d4aac591654827f38a381370de4e5925d387b1b451666948977024b8c93804f322d4e67419cc942bf21198a93246476dd628d7ac647d5f60cf6f4990be42cf406635156ad70a8a6929812d7d8ff54c62debfae88bf36e9aeafe183f9f609f1dbf44e61532283618f2a708b7bb63b490e632d5f72cd2c62db7e31937c44c94e397aeb987238366a560e6c1436729eebd3d329bdc1465b84eadb83b9bc4ea9cd9f75caa4bd34fc384c5b75eb4ec8dbf9d659c6e71099260adfe3d51c6ae7d6e08e7021bb465a0fa87c41bc0b2bd5ee25acc8f5cff4b51832560c9d840f297e52613e4b8427e90ae4857ec1eb962b90480021c967ee4a617a85a84963d6de1908f574be33a5dbc926921584d486e4aa12df73e54883810ba1e6e1792b4e395db1ef89719a17d9aaa1a8ce7a55f894fe64b06e2d0bf69bfd534d9670782248f755e7b8f68dfee39c3697b664deea2f3a836c787170d292ecc8feb4f22606cfd208628ebf35650ccef01b1674fddeea294db0655c3701d8e317081dee20f5bec18c8051d6c8d0809d4b593d0b2aa31252a9b26c619f5a162d32b7bc552dd26a2edca896662d0d2805024a91dc75c974b1ce7829ecd40cc96ac16e7b7f9b914679ee91c6f29ee452d97c1f67b14c07e515f5e7e4337906e7eb9b7725e94f0bd6b187507354a75b43a09f8c0d4ebf7ea235a4640f2110cac6060ec33db1e9c178a4292d0b69d4042946c72a182bdf166b41cebc8c3fbed1cbb78eebb3f9777f0f5aa5a6a1540f7c9ef3d0a583ce67d5c30cf4366dd98977b7dc320d1ac4f3c4a92dcf151b3b69f2f5443da1176045175d83388dd593b79ce3d8893415f7b5080c4206168c6ced23a205a7e17eaf9f0c4343b12f973e6de681e9865cd56494f8ddb74a1db240ae7b961b0a2b616a222572eba25e5a8d55eaa85a5e08a6c564d90f4403c97e5b064e8bcda7d5995edc9f254c55ead81410cb754eedea891eac094b57bf4083d00e3d6c35ee4665bed0bbb4ef88210ee0446d7a2583e274866c88db28d6696d80071cd0a62d7ffed558e8d6b55b5b631c3e6fac4a40ca14025d632ac0807b39f23390e0b7ff4e33fc37a7ea9ae5cfcb547e1a312d1aa356b7598bd46ea31419eb1819fa1265c799a841723288aa09e7ee80ff7c9a9e809b77ce27719e1f84754e0399cd7fd5fa38fabf6b61db47d1f15643ef4bb2dc5a0e4671ecb13e183257c7620d976475de3e326637376792c26e374082d6437ad8924eb148adef30e6fc9a9fd0b650065ad1acb400c1e9c5bddc6a42c2adebf8714e8fd6a70e504b3b281202a4071aa5025b1753dd766d5f464cde6901ef3ef88374b393d88e3cebeb9c0964ba80ec8ae45ef48b1a1fc28b1ef09786c0017fc5c1f623966028ea417be81ae9b83afca0038bc415d9499777ca4d3880ad0faabedabeaeba8818bdfedd031d727af5bb2a1b258ea3850cc579f841777a12ccddf2cb3cac125d9c3fed3882aa6257d01445c7f29fc339400025a0c50377ce8467c784c36e08f87388c63c6aa5462c6d0140c94b242f6d0285658a634ecc710676b87220d57152f5d4da71ea7292607cec53284de94f33f0a0c1583975688da94461944a2988cd2c3e79b23f73c281c1d4fa4492d149281bc5154cdacaa19478ce6c321f72774ab26e63df94dbb75424bcb254c8f32ac882e168f57d60293c527ebe8ec11ea5323ccd2d11437198b77d3815baec0b1388d16ecdcba5b6b6c1403d6cd72e97a6b7b2456c3b6f542e986f8d405881632e07261e59061a10bfcfa028b6e9dab221d4d771365af9c690a8a58535b87b71c35320032dc182c9fc7f2fc68aa6a977f1aab57f5997f8e745f79d974c167c7d072fe2689679231e152db8413075de81e8877dea0e13ffc0fe686d05a3f60e5badc8f2fea649172f803108f05c0f3ee433a8e8f2042acb3b7683ef5baf1ee99a5b3d958c7b0223b4e5e41b3793af77be567119a82b0258bb82b3243faf60d4a2d68987f2585f3e40c605550612c4862fc576754b5b4f4752444a375d096728768c9eb6887bf8fa68cf3ed96e3f3e3a07d21ba8fd97d8e10b571642c485da77286ae1309818074a9f43f5c6836cad92cb42ee9dfd31e7acf8b7509ad327ffe78dc898d75b3b727e87be1fd581480538c525b4d150c58f14451e39eb59cc51c40a60cd0c29cffa5191cb0c97f7e32d5718df09cb42a7625487cfb550aa7fcb221c6d9bdb37047da58f1af479721e5c7545d4758f354f5b86d5d3dafbab77eeec342be51a5ef98a29bc02bce08d7225b28064af28141ea0eba1e846c90611824b34161dd8a4ec309b207bd89c0cc9122e5e1661133e8e9e85845e652ae8d3e1e2a4d9db4bb962ffc36f83d75fa259fff70b0e7b2fa9162f9809636139ab2bf319835c7ab10e7af54b9b85da4c93c095f74160b8a8d75832a1cdd8fc3c63b9c7e81015214fa579bc658d02527036f630e8800153f60efaf82c12dd6441da6b3b3cd13b2e7e9b7cb950fefc1204eda16580da074dd2884e34dbac0d24fb49c0bf965e1a91ec42db0e0d6375d521bd9efa37eb01e11985789778de5e4ab55d0fe783b8ea46d5f27bf50e5bea05dc2c6e32b661d2cfdec2a94c954a9f0d8abaf518c2e3d8c29b0e143ce6424eb83f62c0affdf62cd2faedc09b17fe672e0d7d85f5fbd9d0c4fcf4370cfd798aae82fb768270594491d9eb68f3189e4e6e5c279b0e97bf0bbc882bb9f4b8578f915027c33d126f5408019f4bd0cb7fa273bffe0bee7990a850c459b03d5fa0ece5750cca34acbc2c0cf11797c248e509f50a10daa4b4e0d03c46e487a1c219e31e9f72cf9b3a5c1e6028cfccdde1e9313b40edec56b79c7bdb1b867b5f31c320a57e656cfd18019992e4617a299196811897944403fb6c097fb4b7d6d483119293ed9b1a5ee721ec0d3b8ccc3464a1cc14f9b77ca3d7402a088f33106e7a5675b397cac5322d38cc0d284edd950b77bbcc6046191113b47b403609130b29670e6884a66de93345c15bcfa9016561150a60ddcefbb15496612adc75bff875747040dfc3c26e7adec086e9ee97137f8abc603ee076a6d41f04467c4a0b44d740aa2161bb1706a764f7a875c7bce919d195fbefd040cc62807b375a130596b2e8aebd4807e745dd4bba09fa29db53eb31f954ea0354daf4b9de088e526f4f2f4eabafd6899da8a01a8bea020a843a67d7cd671cfc357e2d7070fcaf03c0259d3f40ec9e13c1b769ea0955110dc42114812aa4d1e4f1b3b4148d857c925c877645d964d7b21f1f509a21abc5557ee26c9dc871bd32aaf9e369411c3d068abec24c5d6c2a41f0b1d3a5b3c6f843e452cb81987d55e9cb6cd4d9d67ffe162771097ba623eb032438e8b5c8e0ab063dba51e64590357fe9a0f075ac671e337b44bfbb6f459ba70ffd0c10976dafa3a4bc2899dbd787741879b51b7fd80aa70b0ec44037c20195b755222a46da0912a3e4e46c6b9484a934fc6b26956cc544c389e2c99aac2756e6ecc047a60bcc01f3b831537802fa98eee90137393b22e7b1d6e4eb870819eec67560d161a1e95f7c2ecbcc1968ca50617d64579ef3b379ec5add12dd5aaaf07ca7ce28a5c669f7bd02bc0e464ddc8afd644cb919528e9c244faaf01e08a9b80363be92d17d82251bfdb5b1574613cd0e9972ac6615ea0efcfcb25d2c1c3e21bac90bdc04e292b8c776ab191ffd127c9c9f93b464fa5edfccb6999f594d4c4c6e0e0544c6864de63d12a4007579822f9812fbb00ab7e2c70c1abcba902f8db71139ab19e61a6564443e691f694129cb65e4cb0476d2723b3cfdfa3012826db61a3377d5c49a9d285d94b3e398f7375269897ea56c193441d8bf79a45762c67d09397b998929444f7b5142c500cf7293b5270b834c45a6132bc1f6cfd3382a7c7d9736f2511f48e251859a0f1f506ad0a304e162b80e973e2456a75f1b20bcbc8a5bc7eb745dbd001d85b73257cd5101ce67871a55e062b907c470c8a3f91e314311038faa3981efa69688ad14cd8a4429fbe882d962e500c7052cc048f7d656c9b8cd1743e11b82e215a168e326a4838b234cc054804568a46176cb7ca41e47ac8738dde4cd26eefb7e71f4fabfe62ea6c2da9b74a0038c2d883ac5605ab86e32de46c1d62feaf65fdd1648c93f941092fc7d540498e281d9be946894c48567207513955bd559d63093657072e61dd4d4967536fd8a5bc512681e0192950ce0e0b652673c84c4c56e151dd17e388f5fb8064a4e0891852fba5bace6b9c204eb7b9b7e566b8802df405a1bc8b2a2866f62aee551f6a70859e089bf7c846a7c61f3f02ff6bd5970e609182948270d0035dc7e5fff1d8ea0f5b34e2fc8a424fc0715e4f551b2720bd29db9a29e2172a387d385e8b5a615169ca6ec70d7335881e92cc9ea5f447590d598c87d1472fef8842f46d6329f13c887de141a0a98d3ff5fb353808b2449e82e6acd3aa69b85e8c2a24791050f4840ca38ff6556b26744de0a7430499a59f7ca2522208479ebe9881e20b8527ba8676c0bd788abe51dacc48b5b46f93e6fc44ad60dbb52de941659bec500dbe22481dcff79c0f87ba7dcdf021fb7b9aaf49fe384615d53bbd1162077fbcfca533c1b05e50aaf7afc428c9f8721bbcb271251e5d56583216ecdcf09ec7a6aa31e467973818e3f1d0d62adcdcf6683c1f29912480be19034ffafbb994c2aabf641547ddbd2dacc943f206ed90decbe5ff554df0ef2183ceb6e651d5bc43ee295b9725522db0084b8ba4c197da44f282f78714214b60fb8807e685d658f14b2bade36d7d9d573c51b0ce5e62706b799c370cce9963685258c52bbd07935077ce22fa7c627c1127da018ccf3e7a3827c757971337d07ab961a818fd8776456475ee6022b0b9cf5ba1eedc9f1b294a8ff5be965f92f27c869d41fefed5243347c48516022723552f117c756a744ca4fc99bc88380d2e2850de5aa4aeea7493a77fcec88d108bce54d29ebd2c2239edd9881a97f8af27b04fd8cb7fcb7ee7a3a014971264b3cf137905160cc70ff0e876a229ea9688abf0d163e05db61a223c37a730ad5d07524a9dbb0736347ee0187680cd8c5da186175c59da20e3b1ed44d66c381ce346e5bbac40fee85047d318a8bf05cf0cb7c8301cf20d53aef1082f85dd08ea85970f5d9f1e2f225c05a1f336abeabd63cb9aa92f5cd4fbece398b3137104a44fd16f65a8f67c44e90e4cd1bf2faa5cd06a5d8245be50e83d9054b7d849bbe28315b82e6ce864a031bed5697d2b0acbb46cd55ac6571965ee28994cbcd44c8ea3b09de24c8e116d41a9b9d8080c90df933d81b145fd4ba1c7ffbab17dc1734a47e42ffa0f6ef61425fc49f8ae4dae97cbef93d0798f69120144e5d2187f3c9a64fb74b98ac28c0f6b347459110a75f1246635c6eae9ded194e23e0a73ceb8f6eb487d465c7815b2c317aa90f3e52b1236697115132118d40a798470b26f59661a9869f9c5fc0809da3625166c6b91ab6a8d352b35078a6da32b339231f2ed2f65b80df49a00e88724eb7a3be7abd98e8595412158962d3f507f1a31324c4b086c80faccaf1e846a522b14c0b8486c6aed98237b168786904cca7f20b17b31ce05659a29b108c38641cbae316875c2086f02eb30e0d09fb00070edb4ae5b4381d4c216f52cca84b171edd7178ddc666ce34a59415fe324a19ffc4fef2a0ffef65f828ac68240c6c4da47045e586e758d6a2d87015e792e9be6c834166ea10581f0dd1e46fe3652afcbce721b5ed0a7068605525f6dc78b83b3d4b23f52d851156f703f8c1c9a03e95fd9d54de0fea2c0ea7a04a25170f1aa82b8db04840ac759b07109e11d17e5eb9a8e5bb9c815547cf08c27f42e027fc76df345c966a12bf7b1451229e6e34fb47d7fc7fabfaf76499fb82d1aea2002182165407c645401ac3cfde9b05a8dd97687eab9bafb1011530938840168e6efe0b70cfbc61c2aa1a857baed38121811b2040153964c5f019f10dbf471a39d59b5b72e81e85e2073574727fddd8cb9ccfbb7a7d811b9132f5721aba375a7bd2f72c64620c15797cd7825e0962baf68eac3d380155d5666478147bc2000df73d246906f02e038a4e1151aad79b79563d44156088c685d46463bc00b0aa809ecdc11dd8e62165faf6fe6fbf0c9c9a473228e75800460176a413612a0a083d75bfe06f651899683faedc4db21c0ab23a60959e5cfdfa61d96a47b2a4457b4ce86158ef699c1799c44f99d4592c98aa725f07aa9af741d778bd67659d91ba28a553559afc071db15da570e4f9d0bacfb7fac955fd90caf47eacf1a6823e36202af99e0c0d166ca2af7fa50cb7b4aa0206d2b2fda632a6da33a92497599ec816b6976da21ebcc27eb077408a46242892cafc678f7c9ee44840bd8f5cd8acbfb853e0e9dbda81c2c5afb0e544696c223f21ee28d68972ad75fdbc39527d308b99630c5f0f8faf4d3b77b56a62d4761180f8b624ff289c83e96ab3a5babfd9f6c6cf96b07108d621ad1272fe933cfac8d2f6dedd69b94fdd4a2bdf854c2ac29d0e5bea6ec9e3b8a8927ee7efafdb8c7182d13a2930d1aa9b5fe794c3e56192145ca49a8ee2c1a59c0f566c67fdd47d9db7c201e872e257a869ac5e0316836358c0f015eeacdd21fd196e05a07fa4edf70b6b5b57f2a6c40b27ccbf85c13a21e8dd5ee8cb37b11bcbb6993643b7c1555c0ca173110058a3b1a01c1e769f96ea58cfcf1138e4519a5c1d3df5e02ab0eef26ce4f939b6b5efc48da0e8f429d01b1f794b3f1a10beebb559ef68d74d3d53c8d37dcf605902854fc169e51e9518fdc75927169e79e32c14e9fad9b7c34f5b1da27c00c5dc67eb3e124815bb168c2df4b0278496f0952f937a438685445435586497411c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
