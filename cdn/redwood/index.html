<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b768e25a00deaf9e084780ad25e5240a6b09dd28c971a0a359add8d3f59bf37a5608f8fd323dfc8824ccc2858e9a2cb2a2904408d95ca0249edec040c3fe2dbea17f487526049a8d1a0d08344d9dae29d141e5cd037a44f4056fc97850b92ee4e23f2af7ce58a96927971acc173e59b9c89325b4cd7cd1061f7f26f06cba743cffa4858abc008d4ada8ace78b3fb001cbfdc742e11c0f4e80cf77cfdb9c557f1274a2a6f40273a528eee225a43b347a887f79ac8ac28a6d5b1c0b2bf4ab64cc8e176d109c7950d16674e0be479c02fdf103a80921dc5e4d96d2749e12640230ada14ad00a519125d6f9dda8d25ebdffc47c2553bd499d807489b7371be27fe2c92e070e3963f83cece911d0ed6c4e43928240aa7d1a9421cb9a69014dfbe6053cd8c7cdb5da3d28b668892bb7aad649f2b3d4749acd23eefbd2e20993fa90e7ed05caa129f9444f3d7964b8ba3c8f299d17535a2720a5c6b85f659594057dd24e82e18c78f6143c3ea832e8eaf4fc5d8ad5ece21767d0ae7557ff6d9685410c31d5cb2d9cdb2a25c58173c48c631acb5e90e149fef5ebcb4536667b87133983ff2122de04a5f55bf3407c7236edd0e1a19043a365fdadeafa2400acf1ae5b02b4e2e742aedc04f92ff32f03033840bda3fe7229be081e1516ca62cefc8eadd9c8c83c8d3a9962b14ce82adc3584769422eada953dc04b26d8376cd098a485b1648be87cd9a9bbdf70730f93034c63060064ccf6db2d1cc7119d284423da07b9bf60ed402f4d628250c88ce425824381367ea3dd1f96af5cf5555b621a9c99a5ca04d979b408d7321b4c94ded8ad0704dd00331665b90869ad7e9c123062cf652afd530e896029b3095cb9a840ffb70803eb71b0b3c8c3cc40246f3d9d77cdca0b5e6c5ab51830fc1db844d321bc8058b16ccf266b80400f8a9bff253480f30354dd3febe92bd193b935d20dd80ae30274adb5771c3d344a8eda46ebd0e337e08b8351602534a1b27d773e2ca23bf5c2efb2ded1cccdf8209c1c5d31734dac5deb22ac83e66a3b975c70406a0f08bcfd43396f4bf0fa94913b6c2ed7cb35989925374f60c14ae2ac5f9e60728c370dd6bae5ae6ab3b6bbe5db5992485772e2461adc3251732fa9c749d576be374535dbc509430d77e729afd7ca18a906da07cd6f2c5b067fdc0b688326b01d901093b5da6cc83f2b21d0738a62670fb72ecdfb2f75264cc52075d147f219793a7d853a9c0952a21b23a1ce16f99b38c28db315b2018efaa1db4c72ba05502037514a41c6576ae9b1306a04552c14806ff5273ff9a3c65d973075a52973753ecfdb628e62dec6fd8c817d9a4c57499356ec519bf6e573403736b4fe66cfc493d8bff1ea66df3c4c9857551600b1c8502356c617e9dc6888ac5eefbd420636a3fb4c5c71e03255e866dc6305192f0a0807e6638f93ae56f6a4a2482f3ff9d386e1084a06773c17983dce2be3755394b21591eac286cb98cc518a25285974e82626289ed9ad9a49395fe7173443e3ad8dac77759866b0d8cac3d356560b6e3eaaf5450261496c3a4242e7ea956b236efc066b3199f3b82ea59b0c5f9fcc6d8e2b594c9033cf3b410cdee9a5b275fcca5eeab0e5a2f89b4332639ce9b6c09e26bd3a2a3501481cf6c029389744f1049aa29eacbd2bbfd6e7c2b29ea7ef832b28caf995e27ed028ea9ef1cd01d489ac98b5a22ca95ae3007055be2b9e8b01f960b0209ecbbfe765c4b5e4ac6465a2aeb8bebb510262838acab67757f3aa4856c316759c83e1a32aa33082ba519d1a58cf30dd57a6f3374a008d5797a3579ea8652df29a79903d24e882f66772849dca2598a03a4281247aca945ef1ad7b049a7a498678af06943364e2777f3da0095c71a056066973408c0a12ddb1a7a012ac66015dc3406b87cf8cd4b02ca833a9a9b596e10ce7e85cd21fcb80f207591e2399500ab83b30d355524fb90d9ac9a0e8d42313433113583da7ce5272f79df95f35c955a07b32045bd962c8e10759784cfcda9181d66f11e9386fce4626db8b11e9ea961c226831a71ab381505826e814cae48b5802b028792f592a4d581a9e4cff8a42a14a1540b8ddf0dc664ba4028e73defd97679118dc5e3a88241f28f9bc35ed161be6631e559fd78249628d5e3703cf4dd8897516303f5d733c236c721d5c3737dcd3ae93319eec384b34af1cd3c63dbb6f272157a8b4721b27af8d1d441b11863dfac6e2a5a021bb5ea86e2e454b1d8e69a45302e26652636259391fd8e7cd674aaf6dc0be35fa6f7fed8d8535b7c2fa566846b712aa93c75d8a9ed41a8281fa4c858249c901006a0d6b95639104a90bce0426c5791a33585baf68899f6c066abaa0c061363f1c040dec6eb312ee22f24b162fffd0b1c7da7b17b35b4a3baed2901d625ba955e66b0c93553b1f96a2ec6a657a7734cc5834d17e61f0f941c3f0ec055c8717ce994ff056be29ceb2fd08e592f299009e7733cc1ca341719a1262f2a3a259c3db49500f90903b7e979d85801774bc25bfc247d0e7f6031880aba9ad032c7fe2d4ebcf5c993c8694e5173afbe73a3a9f69f18771994b9fd0413e8f226d9032b9909ce1afe28a662de2ccf5ed182b8c6d42400871c9ba0e414881caea0952ae13a07bfab0f6749561e6a6aa9400c846f8278c5a90f229c1ddace609247885f04fdf7fe527041d22b568dc1aec2c94769742865119df4d8db79a394856661a649bf6087e6547997021d779a8715af08daff80397b5a1481db8f9cb405df20a33a348953538dc483f707e1fc2fcc9080e21927230e2b8863980491a63ebce8f4fca9e59d17165e22a5fd26b5eb158cd12e090b603d921506b4871acc82b5c8cb9b2975080ae7ba82ece75e921aef8b0b19f83be6c7a10074436890e9f55c60c530521e394d552d8ba9e2b029760fd5eb91639ae82992260c33d059111eddc76c7812280cb60c40ad63dc6eb98eb00083a836109a1e7657ab11d2978f0f7e92ab339aed305168ab18d78ac915dacb9d7b8686ff1a9381510e522fd238b9d43d709451584f0b6efeb5129a0414018a9e25ce89d1e45461d342983973829877d40913bcb228666c47bf72a05829446c54a51285d9b1a2e077a7dff3bc417596239fbd2cabe299fbb795c26f6e870576f0ff3e0f48dbd34502f3b2a6d876eb3e62c8b922b6ae1ee4e738adf42079556eb59b74c418c9b95c2050029e8f8744da350c769412b408d4e05948d771efa9e29f9716f8df69ef4cb5f97115969994a9b13b5d189ab9eaa4325588fae9c8fe59127552ce7e4de10c0c0276561c6b724740b521798338b50e4696362261f034fc61d9250ca140d149fc22f9c156bce5d8784143f2d9e411aa3db2ce4314e2f8f493bf0becb051b2611f8c46201425ad188dbd5f36c55e97e60fed4b3fa6262b74658712b2df217dc5c5325ef384f95adb72e094f5f6a72853fb370d5c107695355031dadbe2cd743faccc8c40e374a816e70d0c8074260b4735adbc58b5410e443ba94a803ab14f912ab0c983ab130c1fb2413b0aa4d3f35aca683c2a0395e2aff907873ff0691ea1b216a0a1cf036c95c715bb9103f03929e4b1850f5a24256365c3ed82d1f884c6c989e3d19a4c92b3cd5605905e30799a8748f7b6c467e7b4f60cae180c3b8ede3bf3cdaa01298ba426c4ef7b679bdac38cac5100581c6017adfc80e35fa752dfc223de2893cac0dde8e0312f6f02f3cdd9858b356fa64e5e9e08d814c620d8fe1351004dea5e89d17fe642e79e7c51fc34ee1640d352e39fb69bb7860332ae6734db8ed7d7ce1b187d338cef463b12f2c14fce1994c9c678ec9eca099af77fa5b4b120a53487bbf53479ca47c29cad82c95f5cd3e89048c7ae7e6b3f964344fa690ca4378de3b85b77431b3072decf4a3a1af8ae5d25b677fefe90f831c910b280e24dcbb03a81f003d657c00d2f2c4cb3773093c3eda11c62e9a06bf7affc63bf3374ca77c3c793fe5c2e2dbebc8c50a60626803f7ef2b98a608f2d4b520ed46a94c2f78c274645e8da8fe219460f2e3dac7cf34410d6ed1c5b63721bb2a382c6ac937a5e1060a3061b3ad6b57c114ec90e2ca12bbfff89d9f70fedbd1d989dc31f69c93d543dd91ba983590da1037f71ca044203b89564b012ea3e0b18f10ee776d1c1d0b77cdbfa11afffa5ca0b6769da91e159ff06c483683338c0171aa2cb46c9dc00b954802f956668102a1fa787c5aa909efc7f59dc3e255853fd1370ed24d679da2d18e20f693ae4006b2ecf51c2e5272ad1ccc8c1ad7ccdbf64880bd9ada6acf253bac4b1fb71e6fe54da963a3e855b73d1ddf1f399ca4fe98841a572981fb31d81e49ec85d06c28d817c837d3ca48a0f2df6c57b540c77200bce67af1b8b5710a55c82d419c324ed9f2612cbe500b41988ec4a7e2cd8d83c693ec6b6def60331c9c6d1ffb2034ca2587275491f6224ebb56eacf3cdd51b0f76dc15209c8a2bcbb8b0a17c5a9a2860bf9f922a5740956e4fd31b9678250a739998df4ff72ccf81e085570ec8f9a0997b76eecfc53f1637865056c4a9cd536c8db829828f5ebb1e942c90fa8957413b88128bd7671e63bba32e184fe4547de22a81d3191ca311703f4cccf05fb0fbfab7a2fe307acf082f376f22467836cbd262a1057f87c085d2da74a462887dbbd9dfc104a77e18159ed04c88d5ce7ee6fdbefbe1f458c9816d574a4b594b3f2ef614cba25ece1ef5fa57298ea599ff2799dd374bf4ce552361cce5d948b73bea5ee8dd58f4ba43a65b5abe6b89d5f601dd25bbe0cc823965f62caf20db11988b6f7aababb4467c6b8f1641e9bf3046cd64e59d33e2590641ca8f33a9f0db5dad59fc331037f14114e9c8c0965a2a027c14b69bd14cbde5013b835564ab0c1a51f3a596c79559e435d1db5635f0680e366d60d57f1bf88e0491ef05421af75f510bd8bd367bc6b596e14488ea9fe3f1f838535d109a01ac31d9311975b1e8dcf758136bcc065349b6874207217822d7e7e0d75b6f93e5cf04254daed3badead0258c4ce7e7146a86237a6483d778d1a6d0a06a39613531be216f80733049c1351b02ae0208a9fc8aee7a486177789f26af9a80784a5a38cb1849add60034e05b16f4e5caeb9d36871b6b92d3e3e90c39446296468a3e73b849f97227a30bea1976583986adf277ab4ed67df48df6d2323cfff98ab98ef5cd012fe509db199aadf308979d13d5a1389ffe0e34a128d0a8ac013caaa05dc5fda0ea6a7a1ad2948b407594665afddd96427dcaeda6e6fefb6c59fb3c8995ee4e834df99a05960bf01063a8b02fabc35e3dcf045f493f7b2b9cc4771f3bd9f52eaae987feacc63678da44e6c1b52f02b9b3cd14f6671d54905fd06a64ee95a466aa8bd1d4e21603650e4fcd4207a4339b1e078d537f312f5d6adb711cbcd2e9bd758e88f1f7463e284c78eecb9e48280c44a4a484b547e2a3aa0c85f603536f6202af075f77c1e85604a3f2787f7a434165779db6998dc3d6a677f0ba718ce162629b5db391b9260b862aa50c7ef1f63ab115a8ff6adee4e836a129efad442620a3ac4d94d9c46ee928d3b6898711d0908ab1d447dcfcd4434ed4b900845cd2dd11218bd8dd3ce28fce51a0694aef3df6c68a3f172e1b4e0f690e7362e542177c1d6c4670d6a806b0c5c640fd292ea62f20d9169be7fef25bc432dd8fd3728cf314b43bb0f5605eb341ce9935c78eaa629538c56a7fd9adeef22d2a6577ac0d76e35530a6e607ee41964427d38afe89b740128c077db74b5f4aaf1471cdbf034f0e71d7101f34fdc74a6441cb9f47d5c2c8362e5540c92595f58ccd2a44616cdf650dc0536c7ed4d7f49f65f86fd787cee8686da97434cb79ce907f17719420990bb80b34537fdd70150399e8625894e39dcee60b8566412235f1ce8da997177e779d4f464fa09467b294023ccb960c1de46761301d94af46870e3b54e1e1d2072b0e5a3d7b9bb0a17722a21e83b52e2cdf15cd8525b86ff08a405a0a948d52e7c911cf61ac1d6e0e5cd0a0f967416938a07044a561d40ffa6a5ca655db930dbb7e29b715ce32ae65132a4ce7afdc86207c2e9c4e870d5e31f2b3dff31985ea1f9c976fa3877b5c52aebb53341be6779aeed29dec2ce328655df5d476225451d448adb152350df8849d329e2d56860329d71e5164bf5fb7f519bcda43db8875d775849322ea319917485088491d3bdd5e8d51debd2e21a4aeada34f911e6527dd7d60410847883492394aad9438b0162588951c59b7400668c1101426ef9d9a52964e0b4e77a88c15530c3ed042cca96c675d3ee8373f7baffdadd1d34be47445b562595970c8080d6e97bfadf60aa6075103e66060805fd6d4d507a5781ee5b617e450adc16c5bcfa43a7e06388c7fbda896a6698a89a01eff05efb545b00ac3727598592704af50c94b3a43c38a3862e273db5bb43c3f2808d504df93dbd909838445c3496a6d526771e29ef889d6e2b3da77d3095c858d48bc631694cafc5ba6b23d5565f762c6c0ce167935d34b1a4b034ae3495141a63685294e3a14bed3f60152f6857c8e654506e01dd5504ee087f95259556215abf715d63833b64d95ff89e63dd1617578881b8f5437ccd8b8d64a9e846e0444d85f123f2c58e4ec5abb59e777bd8008b2fe945b035d3aa8a8e805efb9c8dbef6d722a113d370edce8f33b3e5c5387403d87ab13b03d6a287fb7a662e9388eaa10d5db74cad23cdc71e1f17cda17700d2ef4304892fa6c8270088f7ec323319725a75d1b0afa8e546534d111b324da02e7d7f4dfc8a9feadb5d8a3cbf8caa0565b642b652048e63c22cc47e08c11714ad2d417471b0b8647b5c6eac90938c9702336fcc04e8c8ccea2dda841029e18b4517030f54dd8eb47e1cf7fbd9f3619de2df38f388c54cd5f213b10242af250ace8f11f373437b87756b1a19001b956fed5029f362232b4859b9c9907bf3a1c6f39eba256aeca00225998d2cd06b95f40255b016b1ff0ab4085590d32d2162243840843628025240cfd51fcd6c485868388f5df7bbcae55ab3e6fcba4567595c623bf4c54e31121816be47e795ffd7545590b6628477fd237abb1e02ed20a5e457c334259aa04a6c6443dfc13f8308a8659dfe977e1fc8257f1475a406d2a09786e2e148db32833d7aeb9f0ddca1fece175ee5f59026fb0932b50e6b23daa037f6b30a22d74512cf1f3ff421475e657e8ff252a36ba29ebe18c0a69d01b13b5268d7252c3803773752f13f7fda202ca9baabf809233c29fb1f7e55ce4d6a02d66f552611a1d557810471a9a1c098ca2912cabfd7601ce3109aeebabe4e199f8720fba0a560d32aac3ec581441040d9d9c2e56c2e2c8d0d4144b129c78209e3cb4e6901d29c8ff8a2307e9646d5c7031c27539d771ce63943473c992bbf545870955458cbe0279717564d72c845788408a23632171957116182f56fa251f1ea737f94134a1188352a60ef1da090f1c3cb232bb239108330238fa0979e376546118d62a3281427842f6ab2cfdeee7a662f51eac507172592f0c7444bd91b34cada25c508ccaef198ad0aef2f177368d5f69b5442b4f28139bbe6c2f1492cb5795f86b1c7e755ad03848d0a9b1e9224657aa1102c087137384bb65b923f4b669cfc64e3a7a20808c57f480ce7b5aa4a60142252a16a469b77b20fe9a1f15c4bd159d6e027218bd0ee788ad9c0f2adf66a727976327ceba4cc25b70e92e7e69f16e3beabc68a8a7a92a75430a8090b14ad521673079011c43c7fcdb3298eda215ed23120ab02f02b8fcbc162702a28084219c3e25fb23a0baaf638538a8922328f0d4d43674c074ffe4b2ea99113387d543682fb2e8e9684c627214ecd4c01816c4ec629f8d8e62d9c5c0b076f270b4230a68e16c304590f4b1fd022979363f3a8851daa04bf3c7aea29a760e117fd1af45d2fc61f5f20a8a124ce6978f2a0a7d8f8922e7a4efea1e99e54f6022ed3334aa03ff637badc077ff01df62cd9238b423a52a1daae7a4c8f6287e4a565f475dd1df4abed77cfe9756af0f38496715dc6294bd88dc89b43a6071d2ebf38595216e6d30dcd1816670a689dd97bdfca3abc048fa416e5c69ae4a61f4e249bcab56584ed96088af0b0a44a712f0c045fc449e9ab9bdd18ea936d3e4ace5590bb554a94ab25ddc90939d863b795c840580f703b5213c4cb33f91b01f6158836e116d1c774d3acacbc7126226f4002ffecd36351d84cb8f2b700caf0e204b7ea486372823a27e6c130482594b6674baf3d394edd7ef3fc5df7dcbbb5e1cdf765f1c12a424fdd7eb2af8a329565529f041559511fbcab0bdb6a5fe456ea2ae82700ec6a7386dd550312334085727c7e5a7f525f19838cdc8413d85906f713cb268ae905c0ef5bbc7e55bb26f0f1b8aea8da9ab06c0678bfffc22318f1d253bb87cb279f60c9e1d53997d3d676d4617520830f88bca56cd1683826e585597d841215e9861a75db255919fd26d680c3f3958cd4b2a08bbc6e69a09c280896a95650a09a8f30b4bd3c59bcf92b0ee6d45384f0ccaf116f9ec76eaaaea20b2509b67610c4632e28c030edb197191929abd6776d3347b45e57dffe415217cb8df4b02f7595e9a09e9c374ad565648421466b2870fed4ebf6f362d66129959a7839ea972b51dcb8e23278648589b5d6df8556ba9465398bc05d9da727dd760c52c6ad0816126f08d458a39f3e1631e2a55615907c81d88f7921a5a1bee0c706b7c051275134195a4438906846e17010293225ea572779c8f00d562a6f8b8a8b7e4a21837f321ffe14264ed9a331b262bf82a85ae4f6040d18c808725b987ac48d048aa189d2ad7f2efa6584242e51a6c9ba824e6b06902c49756d8360695d3fbb42ee5fff51b1caf431e274533f3b3b0632102870b95176cf556e714c5a67d726e9610e5d27707dc37fcd08042cd98d2335f88f5e3ebe14c0673734e6396cc6fbcc53140ec32c414266bef9daf12c48ddfe79d03157cefad2908654f17dcd40a2ea2fd00476ea0c404a0f6f24483769576a1a974ac7dd85674b92326e7ca35bbba4a3372b02a2f71ab0bdcc18cd584c21347a8efddbc6d53bac9d4c5304ed734c2467eba6635b4cb66532275c203a90bf255b284c0663c0b5e78006c48591c16fd301b74697cba1189921c1c08e31131e3b3a96ff02c94207f943a8edd4d64a891f00904089c5d3da5ad2ce8c3a3f4367806edcc09b0741a0ad79659b1409909f5c71fd2350cfdc6737f2eae39d29f0ba80b75404f8a45aa0c0bc81756b1312f5ea5c32eb3738505cda37f19e7288fe3e2b3dd4032571a3fe6089e2563e9e47e81f171e358330d39c45c0c9931e29833b1b4fc828a89c405cde487dc7261ee0e1df3c5bc09a6d558013707f10026f4f4452d8f703b61452ceb9191a0337e4d1526db2aa486b540d701cf8c2078ec3c688be0bb0fe4d6e78536f6d127be4c7d787829c2223c5e8e62b709eca97f599692fd6e82266a2a269263e2f7284025677880a274c14816e023cabbff5c676136612240decd7a61184c27e31520efc657ff6453cda0985902b782b95494c5aa511260574fa6d9a8fd78c4e8d1f72529ede389a1a7dd550c2a2509216121954afe3bcc5040cc1b7318a57af172b726a0ee29879da425f45e09e05fc4b51c861e647c4bddc2b03f68e6bb3b8af51679cb7c92cf085b1002e2dac9bebaf0015005d447f6d33ba51686a3d798c7e821fd5b74e5c9104c127fcdb8bfc433e0ac4b10fe083831d7a76af86e331ddf3c6620eb7978f66aee9c45948868bc19af5f69aac535c0fa3ed2ffe7f26228979aebe5dc2484a4e0b19ea47b2e0c3be713060a3cd0f1b989a4c2afea2d1c10c45b68ec9fa2b4bd1105ea3c7c127396e8fa3fbb3bd014713c69588110e1e43529623abf9b1322059f8cbb92e5bffdc3217d74fe91c825d9bee195a0be135c93c1f723900ec31bce137cb9fcf8a79008ab3538f9096065ff5cdfc544e31b2442412ec8af1913a90b65c744591742ca23d99bf4e67c8c3aef6830937119eec929ff477c812a3fdfc0ee264a14848d7d9282cf266a4f9997c2de3a2630c01590dc29792c19e4b913bf03bf825fe379aa1713f2b9183388d8af8243c555a8a78132929bd44aff68ac0af4083c278d67e8676da8c51eaa1393ebf43b155ce91e55f779fd5888c37f4f36f5bee438efcd2f902df2e982995bc2f3b177cf0241ae35d32c4fd049386cdc81f82e1a40ff5ee3ffa89533cef192d1379a088b9d119f73131473c2e2b5cf7d9910e90e912fd9415982fb5a917ff95a78974fa1827b9bdd73efcf032d67fbbb17d43f4977f69b68586f9f320c425e031a7d54a7365102b723cefa5401fa875c53928813b245ff6fcf502e9ac973cbb4f433238667e520ffe8a4cab114ee5f6c66d5ca2bfae30a2c846eb600ef89d4190d776a341d68357516d14625f64cb39f6d1ec09ee253a70a1b5774fb70193dd4c3f42914ebf0f6d860bd29968ba93cf9f51e34565358055f5fde0d6d0ce60f0b87dc7cf9b6649f323b70bc1eccd865e332042a7f7ad012216b3c4ec8e1ee54c1ab3a1c195f79ad3dcb01525933600cbff2aeb617ff535cc543fdb834e022558e7706f73e7d94b5d05e4dea5e08e18f458ede406dee727d7bbf1664723da6852ef152a8917275a0921fe76abbb1d91a9229a3e85f041c49c334a303d5d7e5f19f05cc1f36423ee01fa3230a44c9d5fb09e42245ad29a9c89f6df59d8971dad284ec0fa8fb84b62184c3e6c6a0cf2fef023863fa81508bf9b65958e59dc144fd17ab4c0788a9b35af268d746288d33fe1ef594019f8e8bfe9cc423d67db4d1aa871904b2d35c2ee6107e665920a6005c24a56d64c1dc04d4e46c15479a4e54e4bb8cd202029aec6a0f6546ea1904f0ef63aca8c0a37e49bf63925d9f4881bc11271cee40b49745e7ddae688f037aa55a5f72f957119e7e33b61c57ab24d8f69875f19089dba97e68ca26721854de3b5c167262429e977706bdc60e4898146027ba71ece4bdca527eef394e08085061f7585fc6defaee860ca8a874b1f9c1df37620fc0bdacd8693ff5114697abde1df9a34a67a6b179aa8db7853a32ffa36e2be08764f5c52aee74faf1dcef29a281fb423b239659371ea381853630b4e9cbf397126055c2f170e64ce4430553a390c2aa86a7c23855f5d017b0e1fef3743b145a6547e36a0d714d6d0a93462818ca93fcdb5a544f205c91a3a0862b8bb38cb2ae70f391c7f267e46ef4894e141521539feb7fb7ad20f9d9df277040aa396e8c2847e478780781a683aab241c725675af1b24dcf73e6bdca754d0ba84c75f74a84a201d88d6c2215509e049336657781e521c67511f7169c69a27f0a0a0c8c744497a8728c819740d6cae6861b4838997048c53755f5d20d228cd619f3c6fe6b8f21606086d06120a4532e46c2a61d3c3b71d8dd9ce8b971827949062cb82ef8d7a3dca597f08f7fb9ce523c206aeb2180f7d02125ae263ecdbf7915468586c41f3a125ed25b3594d5410754648e0a41f7f9dccffad9c85b9289b22be30fd8a5b61534ffc8ad4641373ec60bb0871baf71688ca89298b512bb37d979586c519508300667a893004552a5235224b2c19c9254caa82eaf83c05db5883467bca3d4db2105b3c4fb55d4dac59c3c13b16e6a390b8c29838c7460f18fac9f565c03f7d9e13fd4e7c29bbd843ceed859b907a376222a1f902a6adb24b23914a96a560286301a6df05a40cc21421f7c80f61ae84a1d8bfe5c99f38875c052a8ea2d0780eaa2aee2085bfb85f20e3f3b9e339508d073b86db74b1746148febe7334aadd1fb1cb0281b14087c2a42013ee6c22e70c1c0dffdcad089bc815d95bf2880e0dad055ebf1ba5879f80deab98496d74d18b0985608ae55cf31efbc1b69ff6cfdd536c3c3fdc644a066a9527fb668e876beb472620ea5a15eb14fd86467b1661c4d1897caac9ae323071ab6f6b37bb9ae483d26ce5e64671daf2bb4fd9e094d7fd3bc6ea366afcca5e47290b7f2dd6b7e81da8cb7d415f432279605dd41519eae3ec9b0a2ede9d63e906a6a77f0dedc59687e37af63416bce9a29b25b75d9f8b562742b6a48baa8ecd5854aa94dffd89e8196f90fa2d7a725d30104a4e96c95bfc6778768d8539492e33001c50ebb04c87c071fd6a1f0127ebabac99c52dadcee50759b65004f8d35286ff953103bbc343f5e07c4f70cfa3e2498a825501095decca2cdf94d850574649c18de070b3d36a4d19408738efd2539e7a9ec0a1d6475165b0395fe23a98c761f14060623a4088f9643a4fe87d8e1285359c45e81458128bf74a744c911f87d3a71733c69c0221ce724c82532e2f54b77fa60f3677aa194321037f0ce5cd1109f114287ab0f294f22bcb14c74f02392bd1e0f13094eed188843c3e28e6cfea0e646bbb9d6685da958c68ce21a0d9b410830cd5cb8007560b8f818ff651b54aca2b3d7166429f4beabc6cac7aa43929c5ccf76cb4951bcaeab2ccd4a5294d0f8e9866910b19138d865a308cb137c91d3b2275aab2447bdd4b1eff737a695c7d04dd4f933d25a9b8cca0853fb5109b3b75879988a73dd2da35f64cd0900b239614932086cab3a6de274c403490e624725d60a7ea14bd0b29a171afece39fd7a95ba7daf0426b4f6b3a73040e8b5f236a26e1a58577cddcf3c28c9e7ba25f6eb82477533b53b6a85bca99e631d8259fce7902136573bb60d5fc03c14202de843a3057400f56cfd5db958f95bc7a6f7d4f109f3a1b4f49e6bdbd944fc007d2a832a96b35cb34d9d28618f9491518628b463c36f5fafd515b6c65ead39a84ba53ec397a8e5d4d3fae4d8a70eb5d3891ab376a75ce88a7b8674a167dccae72267d90475848c6a9e44421b6575ffde3833315ebc688f9d864d47770fa8422041cc0f01c1f726cb88a767c0fd8c9a2135d6173da9e099ae9facd77f798725f52e128213875e7ff6d2092e64f14a090ff6b36c364117d063c7b9f29d31ca1283e14cac3d89b13a0f5a1609fac9cd5dcc096283087ccc2fc1b96a2a1c4998af934a9f739b113de59c515dd7ccf1807e8dcab0ad3dc79e878e9d3437e43fa244a0107fdf55fbda3b0e7a9b5431a03c625a8fb1674b2feabbbcc24792a8ee13c8aa5822f985184854bf162e9aad496b9dc2b8f6f3401525aeaf463288bae740e962967f0e4a5e69f1935b30e28843467f15d924f18cf84259673365a2fb14e443a36ae01e16525bd51883f14c4b4b235f6bb95d2dee0faed8b31264cf5b96f946a322612b20c74666b577e1225ee1e25950137d5bfdeffd8bc217491e77c7bff9f1ba2fe317389ac3ca01d3a7cb0ef51afe6e8b5c0ca26573aefca9721432237d053a37fdf76c4c77ed6bfcaf201d806fb4745f1e7fdb6828f87447744d34feea2192ec3d3be650f32a39565d38307a2f4f9d0b8848ea06d55b46e3cb7ba1d906269ab61271b74e7147dcbb698a1345936686bf95b33b07f734ea6cba15858bd414a4734575ceb1279af29d3c2567a798061da4d7e64f46b3fb172a825fe3b852f32b930d5bb49cf314cfc38c7f2cab09fcfdc87cc651a8dd6c4c5dc51861a9eb12b14d35111b4ca029e6ac252b20247a9c60b7dbae526bd3e2afb819872d209361eca7f4cbc789a2b2a01d1f9a31b7ebbb4f9d13dd38568cd79d99efe8f1da40c907f5eb6be4a6ceddee914f9dde32e12c44d1587595362cf49946fea5394f8173c1880ec961329a633c33e4c1afefe36e6b6c51167f7918a3de2366bf219313adeb84daf2c08778a68814545b5bef73ca0af96cbed28a9ef01431c3e0a6a7d7da08bc38372482a89524215ce8b9c9a3c8105bdded49f4bb604979cb0933a2684811993a0e9a0101c605e2ef11356c08416005e99bfcb87f113ba28332143fc060ca39d7b96b0634b3814a3e5e71379c5c31bf1e1a246946b7cc0e1242e286bf10a02097d067f2021f0a197e7655962fadea93221f0084fed23d1ca70f9767e5f03b079be734c2e256bb10719b6b647a2c4e089e4f8c8f3eb9cc8601ad45cb1e6c963698fb9bc01558954229f525a55c28517db567f3da26907e8e99224ed872b91b7079cce88b73bcbbfa81a18c480b1beb79c6eb860071cba951f88314182e5ff35413ae07b7f71c75198eb5da09f7b0d0483e4035350ef83c49b17f93f90d5f67cec07e063345ae33f9e7f502b6115ae00d35fad7345aa3bfcf111a7c390bd3cefb974711c1f8a0c4dbb8e4d156c4c9858d1058dfcdffbfe2695b93775816e9ebfd791b1dbcbf6e1c7eff1f8a600a09f49e03992bf5ce4552f1670be1de6c605063ae91a53b0d34af9d9339b2adc066d562e4474117da3981fb018992f203e4f00bf850fc7ec4e83bb3ca4293b99fe35cab7c02987c7d2205d534ca86a16741158f25d7abc5e8c122a7475ccee8fafe5ad6339fb1c6a45fb9f3f702567d1247316680fd0407dc8ca4b267baf234e6d7bc1c19966f82a4ef82d99bcbf975d92b65bc963f0ed152c32d16bccb7cfb3f10dc937edb5eded3f69eeaaba8220875d33ae13674d0f72df8b8abb064d381fa7fccbec74ed2c77436239a4be5551e80b4d8bf5894dfe19b835dc109ad3f8c04479caa20b940fdb631df0381ff0ae89868e2d9582a6ec0080e7932a8d42f65aa4e4152b31c585d57faa06bce11bb1aa384fa0fa11d59b7916ecb39f8fa8a761d69f725da722ea328e8d57469e67451646353a4f754521513b6375368708b9e9d9461d27ef8b303cd6f2cc19ead0fbd5b51d5f1e34baa9d6e04793224afb23a553ca0ca0ba450e46571eac1765730459ec66f1d52554c4dd819db90ec671b120917575088a3eaa807c5dfcc554b2398b5c62699f6f20064bf63c80c0800eac6e3087857dd385733dff5c0598876859c19812a52fb24d6750b6cc195a24532a6406875a6f761e37edba863f776a385e1866f5795546f33839fcc9cc2f9bc300f4a799a4d321448ae6e8f5e6f9a6cda9196f3a68fe65e8c21916885796d4103a48a32882ea2911531a9e0224e2f0189eac777b5be23b055cfe161d833b282ac731d0bfe075f8364182db21bbb48dffd18baa7c70646b34c14f3fe8a045ecb4144e34e05feaf58ed6647bd5e8357f05eed4c2e94dc0c293fe9e501362ba821c34f6c20e9062c166a23e38cc1864e321921eb66d5866708ff543859637c692c71a3cb5d56f9a58820acac92971ecb086be051796a6e682542c5a0c87607e448eb414e9b37fa2d1bce99b26fbe83cb058a71dcdda60249b6e85a8a61bed5a63eff7b3c4f19a0a0641b35de4f12365f8795885560a289620c11c0b1e7dc677c3aa813728130e6ea39264d7d62dc7bdae75702562cc4c27c745ba919ea8c4b0a6dc6a200b104edaeed3716b84296d916e3a5014c771db98bae5925415a0db3d92bac3a5a169289decc8cc794c88d27cbac7c3db0bc565b8bb5bedbee217431226d4a4e9be60ca38eed95e024e416776bdc3bee111b05c24f2bf1f8678b763c14fc4452401a901e3d8649fb600ad277ebd1fbb64c420dccaf30a101ff240990a6eb01a4fd4058b53de61ab31921958a944836424cd67134b28d785e38bffcfe4c11a12f35b34cd0ceaf5f16bff1d6959a3c4164d0cd5a6ca746c5ed60d5100ed98a5038f34cbed6df4eb75f10a075b844a18e6a3a51b4cdd5353efacab9bece8a2ced5feee6f457ab080e957a01beab9bd4e0956cf47781847795138cb93fba1547fca653d9934e652b511082c60f068ad67a984a02c96e08bb1a028237a59b8e114df8ac9fbf21f5935bfc58fd1d43c6ad1e2c35b49bd0887d95efaa8c7203e3e55cc0df56aea00084747f2973a02766f74d6b64f50d75744cf87473089e5a8b6bc5a0f318dce1af5201164abaeb4cc80482c2b0264010012381589d01641cb9b3f30295e61917597f3702652fb22ec9fc67580f46cc4fb903d48b6a5952e22b591536c0c0a23695fcaa48f5707db71577ee07df25a8160363971fe39b5cc7deba628f649fab65bfe2589bda07a1975e9a9de707422ef8247d3aeb4d95ff4f8a562aeeec095b7b2a69cae298539bf8a6ace74bb1df285d512afad3ea8b2ac18d09ef4dc9c38d3c7fbeb3ca2625084d0ed5466fa9d2bb18b1d408fdbe0a1be9d3a05ae7bbec5d4fe4fb1afb73bda33843449d1fe94757644599d57576164ce928d40a2660881458ba2dcb1994d260edaec814d62494bd73ce800c45b5c67a84bfc29d2ced507087acd993b106fa8d0bcacfb61739f1623c3b1342fa027877c98c4b29fff67da575befbee493b955f0957a0161432dbfe3b221f7942820855d152a17c8b98fd1884a4846692d89b1e453f2848af7cfebd87e79e535b9540faed80efd64eb57a6cda0098df511e525e58375c382fd19f64231c04c484e5480c265ee9ea0a57c02608107fb0e2ff6e9e163b0d68d1d8c24e78479d65429dc13b4c9273455b7c38bb1b4ef33678ded1c8992d05715e44ddc184082f0234e63ae73ad7e1df413c5bc5d7917a37e8c93f0493b3c9c8c8d51b3e128a433ef3313e5c41b51cf8b2d24ffa64cca8cae47fd661392a94c245d7fede1d461452391f862b80d7958493f3e0950071ab3631c3dd15d461ac35c4dc60f6860f5f573bfab5a739d776d5430cb6725cda34fd522e33951d9f419b010f5e7269f58d50e47111fa4a3da224c62d4cb6a60932bbf4fa0e048609fcc7ea0b90f29588e536ae1f466ff655559a8b1cdb82f80f5d2404f3b91a5e9ec1eb373b9d403d901f2285ce88cc8565cff6430f67e53773ec87c2fc349708bbc7ce8f0cceb316241b6d3d84075561ae115360b309034ca68bdcbc357dc796f1f9b5b089f16aa0256027d68b8e989010a90f9c3608bbf9f635351b7b3101498ab118f5dcffa1a86dc3259a3aa6a43d1a030a516bf7226d298069190e94e40d428855bab0bd40ff14f74cd6f8f9eedc4378d4e6692efa69a4f9ff2f6673196d9c91012d46ae39f0c7d799242b66e39ab637052e208b46570322b6395a688ee1e8a5c9c9af547716659989f201bb612b5473099e9730251084c0c1fecebd2a2a5af8a69a03ab95f3aca0e9ec501d9a3ec6ebe9ae5629b6afeec8b165a47b986b8f177f3b5ef1cf2555d3af7d60c095adf107ecda17ceeb341aea7770b16383fdf71c87390b527d760d61d3df6cc684e080d45b642c2e82bfbbf871885d2dd314b7d2bcf15257191d1c95e62e12a73557de95ff8f7ebd9015bf1b4629925a41f3c4c3c46748110e1de89e67cc708a48505491b5a09f27fbcd46aa517dad49184cab5684e781f3b69e466788e4e8a5b386892743544c78163f85c5e1b7d58eab38504e5c47b9dab51455b9fed9d5cb3ba5f7759f0a8a8dbf4eee73d88ebd7e86fb9ba5f3df4d8d862a4a2743361783db9542883465b04f9927a1fef6a72a73fbcdc6bd0698eda3c04a575c1f6b92d09580dce0f599793da66ce94ac9485c10168a53541bb55203293efafb4e6d9e76d2fd731f188feebefe5995b2f61057be3ae34927c8212874e0e5fb4c9870147c45635c78eb129c5ed43e25d8c7e8bc6995273a55a46ed9485af726419bee7c69352780cd89fd56f3f143ec23113c006947a0a69eceadef5daec601296c9630fdc04bac398e806efd824d546afbba20120e3acad67086481f153db0895549d2c2b6e4bcf179762d93a383852f8b44cf7f8fbf8281cb05fe72fcf4e1d688e428b000d3a7b3e1b58662e9cf4bdef8e84f8e93997b4dd7189af7af6cbbc03b811bcf75ab8c7196cdf0c31714df64f746fdec68684aa01b3c10a4488143c319be9b459f81bc3275a7b4cb6d0db7133a23916349e2378e4d791bb3fa5271e4af1091fd37d325a73eda075cb1a1d3321144bbb6320c1b7bc4c333201121d46a8f66cf34fc02b45d82ac281f3d31de43107494e11be26b14532fcbd0d8112b5d67c37144d74277c1be33bbca9236181b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
