<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00ed6d4df16f6d2fb5eea86c2591f75a2e08f92da0befcc4dba4e29cec95d3593659ab71884404d9ff44014338e54902e1b21f815dfb10047b4cc34b6810b54745acc9952c1aa0acbda04af6553b0aeeb089ce11016f20d001f6874135654c764fafdd72b01fc78254061d29abfe251bf2f19388a18d889df648526982123b64d90d29103a3b631bd812ed7226ffc29ac435acb45340212107c1997590d55d263ee3aaacda71e90ff6caa9d7ff76933b3d5c9bd85315240c104b2c0d3e41e05ca0a92b95c6426d984e60c0fe9fb232eab566aaccbb120b3914ae80e48cb1828948692559426de81303d711889af4cf075f082bc9b0b317c0f985ab46063bde34f61a06e5fb823488feb1f57db34607bd1cdd198450068007351aa778c42e426ffee6e5af07e968ec554aac18732ae93a195a986681ca12ce1112b77c20d809d59c3fcfc8b416a763328dcc5da0a885b23ff299f020768a02c396b74e26aaae6ec12b43197ee5af8bf446bc016ab921b781115047b8d3648fd979ea56310829b748f835f07bc2724ae12a918813a0d1d59a5c62944466c6187f222169493de07c6d380ff18c2a8819292015e2d349584b9bfc62126df93fa0440410498ae997fdefa6af8567409bcaaf8a28b6b887b09b4a85ea312cdd375ec8c151a966b90148c1f49540c1be0193601bb9753b5b1df5797414bc5bed4e8ba43e9a54e6b7559c49503dc7287b7750ce66f4be5c2f14576ee269f1855985124815c0566d1700a6171f430f27b1166ee6a8438a240ab956eb72687c6adda7e4770a301d72c37790061e52a92775dfae6c7cfd32e59c68e36f862c2be18908bbb46dc93162540b6f6bf4a58701f3eb186c26b0cdd161e9cdbe0f0267b5715048d2bad622feb3298ea3ccdd9ec3bcd51a82fb45db3d8ae9f9675185d6ee5861b39f5a272a649afe112489c0856067bd1c82a9de5a750319c9905c35135a01934c54415ba3169e124b68d99170732ffc846cbcb20740db384cfc5a8f7abce8717620d3a887f5bc41a378a136a9ba912fcd989fa47f61b4ede1fa4ddb4aa69c9fc48d5b273168e0d1afa26c080e0b6a59832de9795e406c078fc255d2081e11997f81b426d868b9a9db31c8c8798f4fd2e32419901ac02832ead9f6c3daf30b792c4b5d4843763b9c55b7babd1f509cdc8d8c1a81d932023250cd5a0168a9f8e867a16fb3f63d5719a0253ccb7af93f51069c4eee1fc35c9cda34f05ffbb8adb39cff9d6c3bb4f13aa281cb24d1ad82141aac00b18a7fe6e56210f7456366777126982d31f5069b05d9a98c3aca554b336cb0af3a7c9d2573b1084822aa5d3cbd5f3d00f7df126c5768b07f7bba325ab861f390bbacd9a59885177c07c06b0d210ce1c550f65835b21e5c61b74674ad90a7d3001997603520088cf1a9fc20d9f62e692502ab4e640e04a5806dd4bd76ee0005262d98b23790fa363e610fc6fd0d213585324ba32eba3244668a78c61e9f79506e93091ffb571beb065ca055a3d58367ca1d56bddabedc8e415ce9de86a6577c1a64060f20d50878b1cebfe81b8a57d284ed160ffcc361d64928a6098e4d4fa86f1f34a67cf78c92921447ab2aa948bee3c3d5c1168f497598c30817e863aa98b881cc7f69ebb6ec88da4ea93aa4ea16d9a8526dc3edd81c32fa87f0fe2520c25903b24537b776d71ff82f02b85b2202c5327fabfb0f61b8602ba7ae1344923d449a6f92c995fa46db1757adc06393c0423757c6cc167ab6fb8bce138aa48d778b567a20eb24a2e6802585cdf1d6e9c4409ed2ac79baa90fb66238306af887ee68f84578a2fdb277510df6f8c1f3e3813c070178cdb8dc14add4ebced09629961189b933b9b5fa25d9ace3774ba28e1c3ac385b8b45c597ca488fcefa30a7db8c79323045f7dec4d001e1f5e45411d726fd48ba8dedb468c2d4b963ce488a08d2a7b76bf678d94f9ab64444b72a6e3432c12239956667b45c7fc1ed91760a258df96db8a215aa7449eb54e5d7a16f0fd0719e5b264828609cdd7a80ab00e331f67ada361274965ead427ce4183d908d2b17c97a0ae7af449b2d6bc5342a06cab5f83f4f1275f78fdf8200581f3ba7ae8e99db9884d956904f2b4bbd699eabf86e6efe8be77cc51273d5864e90d370735378fbbd2026d6f3397722a2e44b38ef84ae9a7cc6578e18274fef114e00d00a2eb727d23b59a73f96fd3950b0a6f05960515d80d03b76be9b57e29e25ca0a200545d64be8e160dfbca4b1f28fcc1a7eb654f113043ec9866d3dd0d0cda527ea649311029c8095ab1b62503b53c6cd834d1096ab0612da938d514762674726a30c8f8d9ccc7c01bf8335c05bf1169a067ea5399e7512d8336a47ba8c9b3a602c23cbe6033a127338c3a7045ac3fb10b556582a95e801935895dc84fa3be36044f177a2a74b2489370398f36d1fc1a2b0ba7e765d96bcc5b303b36f18253f736f3efb58d1dd46d96125cb111980e3aaba36641b7ccfcf7aea451c426bf9277913bfcf9c4bb2882166264d73badb4164cf0949988733dfbdd042b43f0cbc1ee17383016dfc43cf157d0ad8b519d2488ee27676a5d357df154fb833fd97fa88029f2263fa09b690778d9afa73fa49187fd7b625432e3298f9203911ff756b9c8f698feea8027192ace4cc960ba513cafa991b756168c63f92f188a7d8a73cba0df8413b02c4b178a9afce9c825898c6f3af2343a99a82b12517d66bc6e07a0976da9f8b7fcf7f0f1b556ff3fd8e4374f444765a15c1496b5fd9c40c3156ed78933eaa8656075fb400feb818da0e97a958ebeb0313f2694ee705e04b32b02c9b82b7fa7e74a7045e1a5157bbd4ce6a87b0fdbd97ae417e74e7ac5b86fa868a23026340f96df1e4d407d06bb8bc9e317aba5e89ff40c6e817f92760c4aff6f906f3a092047ce4ed9165b662f14aeb88b1d5022281cf2417a7df5250a3b6917874a0ec3ae7ad79187214e7718b2ea4eb64ed258417116ae05789d387282e76a32b9b86094acdf9d3c719f7571e58eeb593918c460ddb13bd176079db9e2e10befeaeec7a8a89b3f9eb12da67ae123a23ca5e23a381cba8361e49a621bbe68f9abcf0cb860c4b0592de9550a12798a097298830a3a8d4e64d62d8c4eb7240b5c9aecb212fdfef284007d26165d6bb12e82db4d3bbfaa46bbd4f5dc9b18e97e12b81c330e0c6c6fbba212af5164f8737729323cacd6952bdb2edce093c97264f621136737cd3e1cc56adb0ea09abdb7ea78869d9977582feb7091c97a3068953f33d6d1e4ca482b6d9f617c904036b1f6ddb2ecceb7490eed05c4fb3e3bc6c77cf6e197a876c9147dde1d0d8060ddcd205221e4fc5845772b55bcf6fb4e5c4771b1e3d2b377b0115df78a485a3e7c6b760534b22473b48c25fc6ebf303a5b1ac935c3adfd02875d0357260f268b39e9ec532486510f44fd79037e698ae9cbc97e61cfd4dd7af8f3a9e8d21e83271ef758a8caa8838afbfde53e29472156fcff426ac8eed3f1ba6b8ef8507091ca58018a6cf2c3011a3c62e845e9eb5a68417b445aba3d3532ef6475d4f2c3f5135361722782e6ca1a90476dc1a3204e3841062229d24b4bd1dafb4e289663adec3452b150a5d23aac8215e1fd8353d53ea5cf51c6434ec400ccf14811a58748cd1f192587b1d7443af9ba24d19e7ad72df8255c7971eee5a899db4e21d173bec0265d326acdbe8cbe8f5199dfc9fe564d28a1d701bbc1ed8f811589ea6e8f30de9600130b9725adc2ac3cc4a92ad92eda7c79ee6b64885aa7b98108398c26f6fb337375ff6697fcabbf3546250e24063e0a3d5f5510812b699ca7653aea640665944f58eef8e232ab2031ab2cbdaabfc30ae2331010b97b57f762799d21fbd79317b997afd400d459cf5931b0128a84a4888f5e073109545cbf786777444a7742cea06244c7d84eb854f721791110d065855318c7481ab38d850dad06cb98d497ddd37fa1e52444aa53d6025b3077bdfff28924d2fae7f4e4f68329e37e863c48752f7e83a4331f9eca48bfd6a344d0f4c37d30e7ce60dc55fab000b345000d8b2208fceb5d785f859ae4b536a3db45700e8f532f996b16f407577da88a69158a7a81251f28ea626c2bd616324574da60e5fb722350fa23326bfa20c29195917681deed42e743cb3b102cec708721c9a8037d73f8a8ee0b624acc744a98aafbbda54b040a1d7ca60247f186683a96e7b19f8457f0cafe9a64de8a6e41d628a86b7ef5d38ed87e4346102166662dcd586a5ceeec928b61fe5c076e25563a8e88a6e01849118460f4b1d2c2f0384ff4ecbb9c6b273f6c4cd06ac419574db846f4bbf00538614487cea96b7e52740b59d70f5cdbe8081a89bb4785dd863bbf0077149d3191ab1064a496e21fb14e0414e9fc2bb437decada8bbb5191db1b8a85a7ed82445fada2d07a223f287f55c743d8b5fdcd27ef89f7825d2affb9db2f151e52b4f25889a86f9a529a907bb6efc34796484e942361d71c6bf7ed22366d5b586f0f446482c3e6aa2a8b0493519d965c524ac2acd47898be3acbd42a562fc52cf27b6213db1576984c4f074cd5a225e522988881505e7d99a37e6a6f0244a98f19b8d5e486fd8521afc2ea2bd3ad911a9fa98a770c47286986d06f38f087ca6361a73c11cf2f0865106132832584cda4aba411c0c633b8b37a449f06154930226e50efa0fa1cbd257d6ac5388399ffe38fe1ef094f5698abef1329d5eb0fcf0c3694b398984fd51c1fa9a05af8e2beed3e4191235bce9d6417beffb73bbe38bf557e18c84629032068f50636dd2081efaffeae9e130727dd3456ebcce998cf6e966e2a462f5fb1ea2216f682d5dfd38c0fefe33ff323c0db112ced4721c21e9783dace48d66a6c24ad2fbdca3341314e996ff7fad1dc0fb847a0fb2b1dd5633ec21526226158e9b5566c96fbb45843f6f8ab7a5d02c5358c238c88379cc314356f3a0a606f39aa4df8a6ac60293e82a1213a8d59a2b4437956f774f18f3c02cac1e20547a527770641f9d24df3a7b7845feb1962d5a579a09561b0fba30b9f645c890fee1e8731fb7b0001ce87131a7c6c048984b5530fac4f15614346dfba754230bb96da937fd0baa8377dd1b12c1b13c713fd4e84c4488db4a2514c3a151591947b80ce310b8f16a6e2a37f8ea4283dfcde724abbae1ea642889ad818c71f1dff2a015400df1594e5046a05c777e836afb7e7e79a1b7569c1028439ea0e65deca70452ac1eb4405c0a8dde62f5c66066b688b2f0587e282c7ce0bd116284ddb7bcc7c9bcbaf1c1d65c332137422798454e0b3b9d9f88252775d50d775d73a3a5ecd13932049f47a7dc9fee6a8f4c4ff8681338f53a7798728dff1de5dcd4027753fcf31bc5a4423bb1626813d4163804a88f45b2efbd1172f117de756335cccc888a535b7999ed3c46f26d9835e45ac39fde3cf3c6cb95868d048bbb0cbd5647f4064dd157a7d1e34e8382b7ce971f7790cc076ef2c1bd7fba07370384a242f9f4ed039e0e3184f57611503ba75f79bf9eca1358d9e979aa721d32fd8d70790fab0bcacd4a8c53d270126e6b1f33fe941e629c1a1ce7880580bbd1c4d18ddb07ecfdea9a0bcd1c59827f124078e98a77a89dfed247a839c910c2718d4cce3ac81386b573d89f07d17e5e83242b28bcf47bb589b76dadd88f944e3f18a78d00fb84a52c1ec1506903c1aa060450e71885827379c3421dbc9e663be8eb56f1db9800e09467be2a13d6abd005e0bd990141f8878f6c0e5550ba76c27a13d3e061dbd0809411c2593449bf355e3f95c3d51f1c3ddcceb2888371c2e0429d5391ebef2af5b95550b17f41f7f3a8f58a7fba91262f70e2b467671ba9aa1e3a01423d85696e84506995eb20bbc7fceebd8c61841d72afe794a29ed4db1d045f9ac388370c5685c3948bfa5f4f472411fef5ef96f7ba41961be462ec6466c6d0aa631d0b61f92da21d54d398ddd7fdc782afa7c9db568caf537a1b148331d35e68d7267d0fdeae1e5ddd6e5b538ccd27580af363560d943b60675d4073f59b8591d92c1b1534fc1f0dc47b1cf8edeeb80d7ab043f75a397b83ef142d33680fc350fe147ed2be0ed615978079ade79064ef8e097594e5c15030a511088738e1cea04e1a4416295ceac60ca80034a6add39fdd8109522db3acb625023829c8d9fbc02b6b613f1375db740ee21b898af254854957de286dfa9ebc0095d45df37bc40f77366216baaa8b26deb10cf2ecbb6f4a45682b4c575f335390e2bee12c96e876cf71e77fbc2428ba664a98b32e42a2806bab1f82142b6554ae23f5df3107916e5a74c2aa00a381959beca981027ae67b421f980eb2e09bd23499165c820bc1faabca898308d12e42fa1a5e8d74ad7a5e916ca433f8813bfbcf1ed2bf51d6effaf85d0412d989250cf544bcdf6ed7d7f9c05378f5be6c3aff1a9207860b2ab67093c2a3cd5f5577c1ae742b0f73ef3d6f90454373a0e2fe6229665d219fdeb2d3962f67a6eae1ea5227b158579c7bf05ca7b1a3c5d7b613099521243bd2826a164ec3a1c88ad8a7714812a0b4a509777fec3c57e73ca33120d801d17fb6aa4c333e4657b73c4f5c26f8ba96a33168c7f37c36bdf77e040d90187ae8552d09a568ca0f732cbf665aef78ef9ef3fd666c8c2f458774084ac230048180a4aa389892885a0e17ac3fd14c88306709e90bb02c9b05829303fb34e870ad86aa46a1a2126bac757b1f020ad7fe7182ba5fbf987ba20382e98843428e13c0e9f1886bf9455a05b6019b72dbc60a7ca1820e6dc0ce40e40f316e2e538d183262744710106485b81a3ce0aec8e60ce797a91a86a9eb21177b4d03681c95cb2d1c3742f30f45117483993604218c755d6f46a968406f0ae58bdacc7c7b27f4d0c2ca8cdfe9ea684c86b52bc5636ce1b9ab909d0b550fc7634ff493601c898ce5a4b69001c12865bbe9c0f6235ee2ee3ab56ca87f953a9e23f83ef51e3f5784f284ef55d8346111b75f26cf3ee8fa5dfd5190649d829f37f89bb9f9504e30440fc2c3061b7614b28ae7c77660923a34d9d92f91b4d9aa1734238d4bccd6f9dad4b6426f86adb03eb3ae89a19a94b884a7e3a7c835a9fc6c9f8b84db6ff77392c850e93610876203453fd913dbdfbbc853c3fc437b65eab3b6f3457080229cebc196d844989fe0fe0904844f527d0f45453fcb13924376ad40c890af3fcaf9a508e215d4eb0f5c2da1a8e9180403d037c595ed657672bd4a8f4f148235d323037ee1ad5f3cdfd08d7892e10523db8d44ca069bd43aebfced7015c71b3a5559263096cf616b86b4f4a75e9fabd6ec84fb2f76c70bf25f5c3af00290511cf6fc98f86f3ce115737fe0a74dcc44df08077260e10bdf004278e90e11a29ea55eff3ec3c766394624b0a40509df827d240835e8c270038a5a6c4c9282bc7921ad6216323f7019b6abf93f0afa5b36f31c2e63017922d7bc57836494db25423043d8bcdf19fcc18f691cb7539445dee694979fa05dabb1fd43552d8dda13c559c63153c80c798302f955a84d5eedb0bc3ea16ed79aa9190a3a4341253a71f6599f0eb0b583086b6d4648ec9657b9b5169e716bdc0c55422a180c716fdb893b606b9825b90c18ebc500ee40ef73d9f92815f80a3d97e071b0736ca0de24952e4c00c52aae8b14da9e1ffa74c1667de3103f062ecf8d7d6e1368849ca67d03aae8c22072ddadbb3535c1f2a6917e3db2e25cfbafc8d7cb2e7b3b4869c2e6c7700e4f5b18ddc31327d66d21acc5facbbf8a50660cae697c09eeb1f25af28b152a1d9671a721f4dad434078d084ff747df3c15b1031e2a2b075fa4bf3abe3304bf4498fbf66257c9679b41b77688e589be81993e4b25f56d1a6ef4e9e0ae3db4090f7079fb1a4a5ca51fda76827cb07cd1413371d4ed3db9e585c59b0216ce7649e7b8d0edf14891f998cc7e6d6f19a7a6c3ca70e1c4f16e78a9ee4a94365aec2195edd6ab6c9b598bc8f3c1e552a9596c404a90e1adc3cbe3bdd70e9e29ffdfa4c7965a9a20ff36ded9c7e2836072eda7c1c2fdcc64a43d3900889c0c9f9e62bd14b78a987a7159b2b1bfcef427eb48d5170ad892e9c04f34e0d5bcf50b0eddc0d80efc5d437f2025fcd5ac80be56209df5660a952e488548e652f2473742ef7cfdf0d7966cf272517ef0e6986329c9bcbe6c09cd9e486b090423b384e3946f6a2891b28b2e6b4680661b78158308aa235bb85efb9473b16da745f88b0ce9425d3a951f6b36f37bb5bb66530bfc80d5217af6b7cf4e2b245105ab6b0cc49be10ec959e343e2d0b9f6478cbfbfacb8100f4b3020ea28e5afff2671880f4e064840b5d478337e7e349c9354ea7555a6fee34a0f5dfe39b5323ac992779fa43848df77d08af05c61c5dc444391bb77fc4049a675e02d0f1d10fd1e1979a56b19d79458059fc87c98d39f002967253954289584b8496a152cfcae12a77756130aa0c74dd22e0a9edca977406f4e79acb16d091557116d33178385a5b423576ad277158409d118ef447fe7ecb89bfacddea20a028d5784a0ffcb22d2855ad4514b4b6466ccbe242cd4b61ed86a249c6cd609f4f5c3ffab6e85d63d496112bf8bcb51344c47f367704b47c5131c1058bc471340e8313f74b8459b03d29f654c5c470e64469007e760650bbe1efd958039582c870032ca128f2849732430151685e13ac426cb90bd711c874fdec03f4368d727aa07e1c82d5511e965b1465044279b748fb84ca748328684f02505d4185dd3e7040967e375fa230c7efd1fbd32ae5ae517f7c8bf5420964c4c2fd07f6c0e4ac0e6c2b15962251b0f56a502bdf29525aad5fb7f4e8a60ed42b1b45668e13ef5a9dc392c1bb9f8c249f440fad3992fd1ce7031cb042f1968a1196845e82aebdf51920c640157f58f3572d73cbe4fc5fb8cbfc519ae6867af56013e2a0f0c30077a42635d417a077ed205d314086ee2bfb2c4977bdbdf22be5219ece3078ace904860c10161767782a1c6533e7afbcfec5ff8ffc2c385c2784ec5768fac9260b61c258758abff0daba2a946f0f4fd6a6d864663169e94217df917ff5207538867a251f555e3941809504807cf7ea9387ae2e6d11e017a7d0435f6b8a4d1d0a571d226436c9018033ba024554f8fe0f8c9bded207281fd2c5fea8dc40f00bce3b140356c4849c9a02bd94dd1c304fdd85502a6a41b2f692ff95d07392f0219f82f05c8e94bb46f148c0aab65f4c8dff146c68d21425e0fb3b25ee996daac4a6840b9d1f717c90a1ec15dbb1672e88dab28691d503dd855278096ecc306f72d0ab203bc006516466dea211a90893ee7ae176f2a24b466f368c614aef8f79e102e77b729c0fa1c9a24bd4faaad6889d6b864bf5b14e80ddc699c29f955ab5c488f98c18d45f3cd6293f445e44af55cab70d9480dbf278d4b5358cfe344a687fdea3d244350e2b5d0b8498edfd409208e9106d1e84648195df20419261de8852d1efa4327e720b234a472ff899d958c2e2f9bde35aba97205a5e638a6a7c6af2ff8d2ecee9131251e10c1a584773b476a48d82c34062cff1e34b60441f5534c28fc13a1443e50c0f26652d1bbf4333d810f224ed4d52340785f40ebd73f4123bda6130d77bc677ac0ba0314e861015cb27897cada419d588b28098f9282088f21365f0b8c636d61a15e3ca5db024edfc0109452740219e4265e3403bb516f7b246ed02d0acf223e691166959c574ac637cf569c10d83d8901eb3df4cfd81cdae616853287fd6d362948646d3ac7fa10cf635014724bba87452ab9a8e1c79cc4968b1db056c806756f2e56f4adeb1b20ffd2df51e05ce3e65dc8f62621cb381fbb842d03bc46204ebe66050ee6538496a2f591f1732313e07ab222d0d5f35af725def7a38e37fd632b7babaa7359975d40962c8403902073680e82001f0bf1d4cf48025ab2038ae67e1643baa776635b751a1f0d403c6b6cf48ea8be5a9e0eb05866d8b1c4392b7d5226795f8357773c7cb0fbe560ecfb89935521f1eae112c8ebe009a0669bbea21b8bb54941ab57668efccb1f19cf1c488834d93ac41f4f66fc0c09140a243f099aee5fe466e2226af0434954d7f531a61d38ff60ac8e3e347255ec08f774fc48a196534880470b24d5c3807826d5985e684a670d7c07b660a11168e5f8700e50b1282bb86e5c461be41254b472ca44259c341250674a5645471caae9a34bccbfa9237f1b2afc61bab4d931b08f6f46f94f12c4424553d15ae5895fca29d64ef51ba722c2b3bf8740ababe75edb16d4b27c7c8e820d524518125781af22d6955f75ae0d53b78b8aa12f2232f4ae73ffb61f15469459831a248541167cfc78c421d41257c4dc89b11f153d8fd07aff8bfbb46a3f0818b4c54b5a2c354d1ac56cd39bebb64b445e4ba3f42025bb520b0e3cec1464ac7502db5784e5332d6a78d9b214bfe099edfdd3d288d3d709864b52c6daeded9e65407688f3aeae124e22ad6c3cc201bf78ef2e49ee1d0a1546549b7b846dfe9f66cd1e04f9103040bd54939166128fe3f77934b7541b40e4475cc7430abf224e6f1b15c1732733d11330a80240fae81e99507a5588df973788942f4c8847837aa8fc8b71c6047d00da0d31f07827b50ad2946915cff9bb91db1df050114b3f29d8b018d92cb9fc56399c02a251cb8eafd82f793d369d6cabcffb0cdb585bc243d41e87a57acaa6e7d9690e5591dc34ca657e90cb0831fa64454fc7fb6e436400044f2bbf89be1558bf5988e6e4e2e9d89dc76c2bb0f2c08a126d6b7edb7437b53b1e3854dfbcfe5dd7181a59ef6b03e84510f32db204bc5caf17fd2b06b8762911dc9f5a2c32cc67fc10d90dc7466fc1cca84bb5bcd0d68d3e8517cd214870f3d061e0a646f84b5041591dd64eb700b02d5e6361bb885509e92ce338b7a33d635f79ff00a80247c36ab2f94e1a588e061c79c786d580460577c50c9353a0fd4c7d01e448e7e7a7345b9593996cb7a8880549042554a9817b70676c6e0791aedf43fe50c749519609dc216351f9ed19eef37f050d97c63aecee4ec8179557b24012602440a2cc1c57787fa278b7a9190cb77779f31eedf53ccd0869c87130119e0bfcd256819bd4f275e16d0a8fc63bc2dc2db673f285e1360f50bcaf461484f0a013ff5469d31d793e9c645511f342041385d7575e19fa0cd77b178780c7ffdfda1312e64cd2c6e769d336e51ab98f5d535c24beea073f6a997ee91442ffad544b132b80cff280fd982882a205bc133e82ec85e7bd29474179a0a4f9f835d1b2e5220d4f3f303a7f4dd09cba9b7998699faf9b393a27a958394aefb7d08b52d5aafcaa25102eefadba1aa9344c8ba8518e181dc6df14fd3236d710c6d429095af785b65eb8ab71bc0f283a143125fdfe6c23fee9bab4dc3d5d926f77d86cb20c78cc3072de91db28fa3e552db4568d250cf98b51f659e5e53c0b611b4bab9f307f5453155f4f30db428e6b29760f62a9c40f9325670118a706d260ca0f81c4f07f4a8b89d4c48252d0d4b6cfb4e25ce46d171895f444717f57024ac849a7dfbd291d528e2c19544cf2cd6ba7b0931d14b949fff5c5d98085a303de16494bd2bc7887e844a800323836668aeedc3cd17dfb0bd47f755ca6b0d936dd17ba9ba5c0aee9f6037804c2967ad6097e5ebe876fcaa45ac25b65d882c724cc0071a53375ebce2457cd78b1ea09fbcfb03283a1810911bc88467b47b8a5cefb50994b37a98a733c486ca0555723c773bed3fc6408ecd7483c5603ec21187b0ea467447c6845ff0e51504b2083a0948f15980871c3ded5e49b8cd5c8e79fcf2326a4322f20045f7990e1cd4880a659a41f84f573774e9edb47160a65f9de9a84596ce5ba94abcd802771f972e181c92a03f5ed00b61ae463ef5e6b455b711ab92b649bfc9d93d63200de7a972687179b09a11206c35ff5111d5d6ff4eb06980bc363e8ce1c535b1c1441f586dc0319e169ad81838b1878bd78b295a7ae8f3a1fcdfcab9f149799acaee34099efa860d5a7c0561600a7144b8adc245a5bd8a7e126123479ea23edbbdffe419bb627507f1d4f7a29b4dd137a5e79c576e2ee70fae628bb8027072d1ef13b3ed7719eda9c6fe606dbbd42d7bcb6bf9c8373827196f71faefa358cb2a4f91322120f07979052679646cb816dece8333b14f9c930983e304812f80d87ecb9fcef094fd00e04b4cb9442f261de9605ef0c85f52fe5cf0e5da4f73735109e80f3324ec458c3c3fe4fc85a741e17eab4e7b7eb5a670da8b4c88e57c7b6cbc21c92c9db4999b358b616cb0fc6e8da2e6dedd3003e8ebaf42ccec1841e212c282074e3184d86b17f092c4c97349805195be2ef07ca5a73aa881ac32a98ad34ce7e0f3ad7cdc8394f07296b78b9fcbdfb6a7b90f4f59b16426b7581de278a0c5b0180622a7b42788e3b19b241d62e3ba0512c06d84ee49fcc5551b4d7052407a489942921a59c1fd1a6576f82cd7a51ec85d2f0c634a464dd5607bcedda052fc087aec1da3ae501f87c7a58fcb3efbb29a8a00dec18ecd82136c5bb9a4ccb327b9a8bbcc9529559a97cbad5566e8dcc1e9db8f2192c7f1bc9fe8a1816d9bc8474c1061f21b79c74866e6d78faae869a583cff57bb85358ae5aee6699bb46bd9c8a128cf1e9c940ee91beb974cea819528629bc425897a0ab21910045c49e1caedd7d2a227d1ce044220932c4cbb581a067b8d6e332e0da0886fa4f286f4014f69fce02ef3346970c6e845a9dc8a51d97cdead4f4b9cbdb02b73b2f192612fc85cb52896042883ad255b38205a00c332548a471630277bb1a1103301b09e8bfba29dde0fa2cd6c6ff9459b8566035aa28a17db4e44a4c1e9bc2be6e3d90abab67128ae38f68ecc832d5629849364291169a0349a2605408ab90bd5da61e1ca4ed50fa00f79a3608b9a4586cce62511296711bc708224ba27d7033273d350a4f48196ea95915ade0fad7c2bd7877208b3801ab7afaf8e0c4cd26da9b9f7a230c93ca809ad07db9eb24772ecad570fb74bf8c3578315651a6516f8c8da315685f44611e46e86b6531a93e380adfe5412f816a94ec89d421a1e5a8cdcc67a561ee7cc3d0442641c6e4f5ba15601a0116c2b2ae1a15ac6db1c446b1bce0e2be4c4f044ddbcdda3f65ab1e41bc00cf2fcc9594a14b14ec984d886b007614be7a3dda243418ce27913780584c97758f9284fa38392757dd6755aeb73f17fc2be0f3f67f460cce24ce5e8e6ba0d94d4efce8da655c6ce8001361a64bb07c551a35bfe9aeed8eca02cf4a2dcccdd2d9ca86719dd826d9567f96ce414af0fad24bea0e50cce6f6e66fc332069fc58df3bbfdd29d109abe386fbd2442b995e0f53340db7e612f242baa590f4aeafebfc2bb9b0015738f5687c457ecae02a091a583eb1a3b944b8d7b0ab9780bfe10f41e8f526300848c8ddd9fc1c5cca57aee233d55afa533431a864d89d7c8dcb822fdf5707e2f5888cbaba22d144fa05d5e34b4ebf4a550d61576f66e3701774e0acb295c5bd5c9eccc010e045cd58f6f78f46d1daab28ca1a95c7c652f4e4cd648dc2d162d6623f60278dc656b015ca782e34858cddb72b1e7861bd26b57a45d29fec1151447fa5d6e2799c3e0a2b7ebdcff950a6420c51fb7fa86adabb8007e403904f61710c6065e6c79c46a0bfdc64bd3613243f1753eb3e15870a83cd52bea23d21262583f9a5d51206b844a245a51cc93879aa46a0cb5a21212ad232e9320c2b85ee3d203c32e9eab8d9124b2a78592076d5fc074f8410cf87e0fbd1966c654abc20606b09683ccd7c3ad202a22c5f6ec336db9e06b382367d134a5f3559ed9a079da97b7eabb4a2b76edbb10a850470fd7f66edd1a5903f7326634eea3475d443f5292e45c3d7a13a1ce8613f326b384280edc572b1e4058a822877fc307d3f5f01ac5d664b045df495883bcf029c2682a1483923c871fdb11283b0d75eaac92f2f324bc62500c6983242934b3f8b682179d9c4136ea5a3e2a19b0069593e3cf4f8cccfe8099a84025d6536db3099c16c8c1458aed7e26877c5d16743afb59a641010604bbff49cb12fd046573a0bc58059cfb44d94f7114459e2b6aa322a9095c630602acbfddd0757658712331bffa46a9391694f547a40ae87c8bb7da2cea5151e8471d016a44a1f3c45ffe6db257d0c0e777c4f8e9ab26e16b4508cdb9a0204c7c95f30ffe250c88f37b8dfbfe468c9d1779cd6a60003e41b850a9be5841a27f4cfaa14b92e843769f96802ba514e006dfecbc3ba322f2914a2b1a2b660793c235a43caab56c1ff94a30f7f9f6e7df084eb11ff20422283841cc8a7c2c830e4a6720d3cd24ee2f6afcb907f72ce8d8aa06149388369c61eb8b2cb0a125bb8c17cb23be3a293a17dc0a0da9dc185dbc16b5dbb3622f990bd55af66b6aa01b92d4c529d0b97bd54a3dc405d0cd9eb81aa8fc01f4783132c118dff3fdb9916796c7b54bc1ab4ff5455f561c4016058bdcf178a37cdc926b5ac5f87f4b6ca82ffd15e798d7ecab5dcedb096162c6075cd1da8539f6451061b3cc6f55ed1561a35d5f655a4dd670986bba1a7b0f00cd2e00806d428d8152814ba5143a64070929933bced80ef129fc0ba7b553723f66398ef5d283e6f9d6b2d44e9a512d141603f441a69023fa0fbc3f2355b55a2c2a117ef7ecb0bcb111cb8f5368518749801f712f415072ff3641f737eb40bb836166bb2aae6c45f5f9d1410c1283c1296fc1baea2e528afd1cbde2140e9483054ac283cba87166f1e98c36d82a83d4ae37d4c4d479a0f8e065c5f06d7b23931ac9c82727e671b1ee288640c66f7e98454d3a4b618a950757d601f8f23f9ffbca8fe3de89186d503e4252354943882bc4ad41548aac8f3af9a8908575eb30186afa7ca3de153e862ce4a2e7a547afdbcc1a32d8ef3a2ea06f26edcd874ccbe168ba21f1a7e4a8aec95362610038691c720a5b4255d19ffd1f3590121ff4a430b7d9c2cf99a8e9f6601b525a5d7800389df1b5edfeae651c2ac26c79525fcfa5e279f98668b60526de29e823c89100da9fa8a82579f2b535f5edd33b94be30d2ae448ae6176edd10a22cb8ca626868f8b3ae2bcce1e48deab30d78903edf53d9a3858229954489172bda4e7a1224221fa36c624bb212c2598aaaa9dd8697e5f167e7aae1ab0f080a73516cdf920162206ffb2b052d7315d96fc588419e5019bab4593fa93e59fd75654c83e7efaf7ba5b1609256c644ce955e6ba3ec634e9c380a7e4a60ccc7fc29c99a258850004a12dacebcfb3cfebd5c73b78350d855679be0944dd4a0d506e438c44ca65d8e1c03f6d3fea93e8b1efae956421c0b3358427818b48c8bd561e18bb1da852a83bb5947a594dd04d0759a8ab529c04ce23514a5a7716371ac5bddaea072920c8bfea937f07e8ade2b21b24d1237f2a17a11d9dfb14ec02ed49c8f2265c68648e1f17b6b584e07eebe4a37a65c6e7c5ec35b178a71efcd37aeed085811d8c760fc591d6d7fb2174acc6d1ec305193c2593e2a5f3157b16ab8b1d24a272c6584ef8be605984cdba49dd72eccbc7db7ab8ca5fb9489770c2f5eacb3013f4619c2e7d9c537e33d7c408cc045f75f08270018aa239f2b00098c149c9bf009d7e6a427956475e01c97a226104f737894e84509310eec6b34e5c9ecaf38237bd971c565aa6c9b32f6cbb7dc3b2c31eb650406b365bc22937e3e2c70325f30f8d326b42582820353c43e363f21ca5b352da1796f7bd4a452f7f104584a72da1c1e737ab6cf7d4e47de20beb19c35e26123292bab1ecee220356e151acf0e77003ba88d8e910245518107ddecd518b9ea096eebe9b057dca86bbc82efeac901d10842b96a0d7626fb928ef8012d44c9ea0f21f9f0352f7237f76b8974ee2f914a3d7aa3aba1b928a7e6546829dc1a8bc9737a21d238481dec19aa295410ae26550eeb2272b07dec8d7d5d1671499c1aca7a0deaa2aaa99af3457b2606c73d81b62e068e5fa62251a7e8ba3ebba9bf6d15df4156ba99677b373eeea4ba4d86e2a4b9a83650983b2ddc8a24670167f8e3f7bec7acb5892bc6f8484ce6a0c20c2d6ee0d6aed3f4cb9e0ca0166426b2dbca097028c1ff6e1ffd1e513809e6b41ca3a8ccf4250dc8ab3b35f10be78781405737641f66744ebb78af21704d72abebad3e4720c7c0cf714aab7322e0c8c2733ad245265b9dc29183c7e6134f988d7b385f64e80340cba56e1e4c72f5c29e9d298d548baccee743bb456b5ede8420063b7eccd010670f785dcefd9fe8eba624eeb48bd93b7bdbd018127121e98aa6d4533191b915101f5e7812e3636add3d5ec1ad10d05c264c0813d76f70a3193735624736382e610b299a0008f7541ebc99af67d6fcf60d356724802a22ab59ee20ad077d8f53515e75f92759ff02fe9c6393ef856e924e44c992a6aaffd806ab27cd1de72dea95d3f89393db360da167f73912867aa546a0f7ba16aa1b7f0fab8d7ebd925201e5c9560a1bcbdef8d6757fb08c40f63b28ee38ed4e6fd0b7a3f1a90ea75a137e561bfb9d8cb05adfe76e009e4cfa9b85a285b5747be384036cbf5cac77e489906bae9b8f5abd2809856d33ee30cf0c49302ca94b8644660bbb4e71d35e9324a1bea233a22155a6ac527bf1087291f1e1d5e2b82f755e6a698fe893fecf809ca97d22c41432bfb3b73ff79793185ba620d7c05a1cc1fa8e9b5900f8473b0b55a16248489c8b282114bc75621654244c29f3a96e66b1fb7172f2efe66294a016e0bc0ad3aafca739b1e097426409bbdaeb703ef8b4daaa37188111d857c7f4a9fe371b88524126c26825db64f1dcd2d1eb74f2b89ed36e78f0928a88ff7d0c83f991b077f797d9cd618319e7a10f2541260cde8d6aa4ff851a7fd0637af61729cd602488bf6669112ce46501ee2b57d4b927bc0b065bd0d65573534faed764a5ef550016e93ae7d45790e076d4056d91bf3a02fefc2d65bebb906a5c96134f2e06795a77ddf8170144b217206355ba617f586d85456a535038414ebf42de9cc4beff235f6a2bd70664458d489c5a920f0ec89e8a7fc2a3f14d33528e4db32eb96368c55d725ea6bfb60aaaf064fced544a167971a333b14d3ddc0cb65493014f628807c074197964c96f023abe4f0af3cafa8be3d3ec403cdc57f4aa53d8f1535dc67bda9f55fad3addab1c18aed45f96c48bcdb815a0d98d588632e6c733a615c00e9306ae9d9f6b604fdc28162f14240fd124f5495088008f8132d79a3896ef6533a6196191fd6b1af854ffabf86472e440cec7e78395453ea33e09876dff17838a668fcb058115f8d2402c55a21dd388499ea4e361a8a16ce3b7a6a5a710d9c3933189b946f8da08aaaeb4ea7ecd1ccaf9b216d3b987da2d3a3005895834e8fd92c3608b4aba8d9f64dac6fbbe76c2563899738c285f4f78feb5e751f2f697452b66613a0b01f05ed2a0555d5439cba385838c424e123ba3be239d876a60d38e4d1882be4182d26c284413b03f003c9f9c5f1325bde47126db42d1a1be45ad808256799acc0240f1f6cb8fd0d068e1300aa1f31972c4b75837ceea4c1a1dbc65d59dd60c3903b8123b5ea1e56218eb4f3de2447725dbae2fd5c9562cde313d8aae6328c4b78cbf3e5c3b8b8de9f31e790151d6154388b5a0eb1c7751253164411a6917e13adb4fead7774304050a7caae030a229035cd3e757875a5d52a006ae1949e918218c58f1f604709d698ca04a600fa9c097d3b396d6dc517f909e5e411beb39e9744edee42be1e0baddc97904e64a7b82e69a5d6621cbddbc6c2e3ab08bba9f4fd53eca0a9d3516e56f504eb60c51baf2fa085ffbfc6eff912c20e02c7a03570bfc2ee1c00f69056414e214b133366c66b12770221a89cce93f67119c4f36baea804f795c36296f398cf958ad7a58a5dca1e9e3ad6e78c0f9cffdba9b16d353b8fa4b856db699e0c3657c454711114b7a8d34f883e5138c0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
