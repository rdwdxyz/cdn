<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"715a33c03ccaeffee088ea6fe447765f1e76ac6e9d9f79ff8891409b93dee08aede4b4ec0cd73c0d9076dc5cd5337ca804abcf7b3ddc89c904f5c5400ea2c9eac73074fe6dcd4c6c500b73abba29c88b98f8f1adb6d44deb9fd1bb449b7155a413015ed9e23ac6ccde912ab0cd54f43a7fec6a21e02a89a301127c97b79730e61e169b220c783116ffe1a2bb0d7163e9febe999fb929e662162e64af784e55f026b2e4ab7bd447bd1f5e305c8852d23ddb84ceaaf671c7b2fa1d8f4e3fc7a2bd1a85d571e86b26386b63ebcb3f233e7ce177fa66fd9d70ccb82cde83ba8f01168df3b64fb3e73191c074d47f284fd8ccaeea5bbb8049f3b66cd78ebac384e1bd2dcfe70f5d896b72c340419cce577087686fadb65d421be19257d4da87870760bc3aec89ef38050efc3ea529ca4876523f6fc0347f9d8963a9b41bd6259d76bd9fe2c9908d18f67e4990fd69d3a8bb1ea23f4168287b73be13214c9f799cac35b38e09f290719f25a70eb32a1e43ea54710eac0cf800e83771697d9b74c4f211fbf2d74e813eaade7470715423a196370c53fb7d6d6ed1bb467ebbd5756966b0b6643cab18af32ceb451c73e579521a4f2193e5bb706aecdb965444fb475712764a1223876b9727dae35cc89702437e4be9970769e3f335f79e26af272ce7ebab5c2b90c248cb97f71f0db93c6f9525d47ffd52da56808d7ebc25ab38113c4a3657643830457a2e2ef2d67fc833063c3552313b8876a03cca846d6eacbe2b74bd2a6402e459f6d5f61373dddfe7a2fb55bc72faf19df13cea91bb94da6796adfb3eae96c1cf079a8306953ab781fe50d7b9353fb2d8b5dff3c5f1307e26cb4c8fda11d025b955e9ff3d036091fad1264d3ec6f950d3f0613e6074d11a42da481dc1738973578358d417761e48d85dfaccbd827c4470f527095cf52dfb415c133b1cc0201efe1dea70b038a44d3f0c33970268cc534666d6cdf4d451607cef6ecc4787642a0c0a8a53c6134302d1f983c86454b0bc422760c036b3b40bb2cdff35f5c2be865071a626322fdabc469065a6b9b78d1d295e7831a8819f9f95c0dc8fce3ec9fea1dd67b249448d88d1eb73305372eab1205779f88f150fa79fe80d9649bc5bf44bfdf22a0bb7751cf95c12c2afd89b45c5b95419763ba5b2df7536edca8faaf291cdc59b5a4aef4a19c2d9008e392eb71955f77c702349311941f5974f1fbc0f34a1355e9960b00a718b9ba4f3355cf685cc1b8edbc41433ec6df556fcaac1b84de2e833e5df5f0985019a71ecad9498e27e2d8de1882dcd2396e621ff07a7d0ebc6f79ef43e23a4025bda24ade31b0a62d0eadd9853906217b5c7d1cc25ad3c9b2b92b9417d8b63adeb67d415b3c0488ba260558bee4968c83895adf1470d80465031aacd3ffdf2e97cd0631e16af666d83bb1a4482ed25290d919f3f12fa7d48d73a4114ff3f7197a4d85676e153bb7a0a31d52ef31dd6f5b58e4b79dc92be364023e9b9fe190eb8dbcfc962c667af81869bfa63aab47527b54e01a2f722d5856c5b8d672b472f9d0136efdbc8df8fd7576ece94c7b92a97f06bfd1070b4b498c153006975b6c7b7be093b11ca1dc2f59c172cc692ada72c77b6e51b26554457008b696ea31b174b2286360c5a610da708d29190b216a52a60e5358eee4e64bfac4ea7c3d20c4d03040b938ea53cd685a373c3a110cf71c0d060a8dd35d9e13aa05eb1c53b5175038a0c08ba3a9e228a6b6d4327054e9724eddbc6fdb2f1f5631388240af6cd8a698b0bba8b209339a9a1dceb8c26753518137f7ef0869dc81ba28baea17396f2efbbee7d986454556d249b714a69ae8860bba5d2ac30c6c926798e6909721cf00fe4bc71ce234ee8408af1e123fd903c89b02d4516dc1b0f5489ec9376c23ba1d68127e8c4fc04b2ae329259982dd350a1ee65bb6f68eca4f34eb0abe0f1a5c73773c126ca859a89114458f7a02b6c90a052b8179896cc8c9f09bede35aae824ba5c3bf18f2b24f38c8cfcccbeb22a0eb75c446c3057a5349ada2ec51fb18fdaf14907ebe16b203ed299049e460a7332a8dc3dc780f3311cfe7b24ecf57e344ab8d3248cf01e2b2f2e25d3c238f909c32ce9649af02065497d604f8901d70ef76a3629a34cf45d501a7273c5f681490f92127b3f7fcc39cc1594cbe7163f0a1cb496d7a80451a07413ae87b5d6e479de5615b218762f2e2fd978bd12a34658ac9994d6d625fb6a7a3d89176e51cdeb564bec74fadbdccce05fd4946a83f003fc9adcf72395d938f655554d18067b2626f79cb282dd88512cf9399441f7acccd23264ec9b6667f58585b775d3141a94acd221dcf824c64d0ef9e7f646e429c52c66c5f5b1ad33aebb3deafdc31778cc3333421c1b5fd63755b414a189b3a0afa7a56d8adce2a4b0bfdaad62fcacb8eb59de9790822befae89f5b4fae4356bb15e0539a1405d24a3b94e2fd1526cb7d0bfaf2590232d49c9c36586025c4c440b8d1f2706714d136615c648fc73d405a152c68497f3bdfc31ff441f8060aebc236af2bd1d70b905281bb57ae2f0b974088db7cdf8a2a73ada193fae150e678221d85ff684b8f5beb4ce57dbad74f9f6bb8b9a17e5972cc28f1f44ff8ce8eb6e28cb0d4c32fc3ced143615ab29ea176819bdb94c89b8d97184ea07e604427dd4ebbc198ac249afa66d851fbf66b4f5943236f0ec563d69b38063050f0048d02879a4543d790733abaf1df29a478338ee2322a8cae1f5ccadc4a24dc88c07bcb0488cf132f0cd47edba1ba3da159a20ec1ec228b61cce501d8dd2619a67f10e502fb272569506533bad28ccca64d015b7a11a78e5c2297c14d55ffaf26f66251328da8e241cbdcd39438b0e2b4191471dcdae9f5ee18877af2cf5bc53680def6ef7a09e3237eac47bb63852b3cf5bd1181d7340860a6016ea4807114d8b0c5626ce3436e1a1da6bdf5f29fb69232a4eb9acae60ae3b5f79ff7c2fd30550ce651eb1604ef7054b76a5d8a17509a1f9ab1da574d4c1852530337f78713f4584f59c19ee6474071688ca2a7851319d0d8cbe866ad22196516832abd3af929f7951e814efc17bcbc7a75bd717f5d304a89f8a20e2d3162b16b1ccfe354589238a76bae489c2c6c279d8b53be7ef5bc0bb125d5bbb799392e154e5039162cff91e03abf6759035533174d5aca0fefa136d4140f312afdeb138d1ee0c6800cef66d94cfb78f67d9ed7515a0d72b8c262b8b4d9d5cd3dcb8fa9d1b87618a438ad987644edc1a12fbc416e4b09b19f564476db9a7908b21a30339db4e5ad595fc221168f73c2825306c00e067d2157e3093e6bf8318b9451764fe54328d2d300f06ed4759c7e8de1addae5f9a506b4f648487ab2e4d05a8e79544ef4abea35184b22dc9b99b64275bda76474c60bf7ba1e06fb8f8ef4b2bd87bf3d5b5cb5120154780a3655b9049bb49a9c3b0b184d824c5cb1a37472efe1183eb344846458aa909b4a6cd24bcfc7239c1d307669f75b6510b25a7eaab8843007422accb80afad13974de7ef4b604f10fabec0ae537736b61949a3e4cccaafe47f00fcfa176e0294d437410efaa210c44a6aafefdb5b0db728d2ebb7fd75b849387cb074b40e5d3ad3cff1aafae7db7c7820f2e0cdc7f24f2965e76cdf98b44425585d0a2dbd13c4f9c9b87940234261ab9ed95bca720358006b75b9b5c318bf86ade2aaa54553f1a8e1230d07a6fb9b6802a97e774f754cef5891d34809055845a2eafa28a0bf15a9795c49fe994df5258263ae3cda36da513a955c3639b6e017ce94b143c9d4a64501fbee6a7b87ad01770e1461f07aa8ccc77252eefb485de5a4404a9e5af90b1accca87c83ebbaa112e6bc937c0c6c20af87c3796309b4b0e32e2de87000c1754f9f094264f66ed51708c4125823e055d2273fc0e2f558a07b4128de0a3fb55ea299ac921c74e5c6eeb5cda1de0de6395aabb46b6a008653842ebbc18798d3d6561a4efe0014f5257ed7c983f437fa1f0396c9e9446452a2536a7520fe804514f382adb1c5549772594559a6aca309738044ca6c83fea1c16056805feaf2fcd71dd8b0a0563ee9cd3adeb00d03ba6a8c0b0c491bc69fca6eb0f810570ee68bb51fbfadf3496f63f8f1b934e0591244c198dd514c3b3d3861861e379c443798ce5fe1eb15ae90770ab55d45b04c4fa8668944d29e5896538f400f63741bc8a068cc9bec567ef748883d9504f292b198d651b6170a950df38cf7da01a7fbbb0af2415b627525f7174d04988bee857c3beb1301205a9773e18720ff865744e95cd007899b2e6f1226a7d26e1712aef5f7bc3cd4fa8851aad721e49d749eee8047aa0b35795175b80a34b7b87a8aedf5931a76833d766266402eb902b838ce3222de38f36f77795a4ba3c96b07e0bd9999b639edfb72d894769f2598833bdaa1db5510686ca7ae8a680a3f8785710d9486e809b4edd06af254e2d3afd57184f7585d3985ffea1e7c4b5419892ddfc3ff1ba61178c602379495d5f45c095bc8f6457dd701abe38a171bd1d7125ced5e6b1cc0f2362f66cb7d002a921442b98ec730c185765fc4d69398e26173d8e34530268c1ba4863d635b039b212c817f6a8ea978bfea59ba5cbd55bfb577932d7da2558b0fcde4febc8821226d83c22a482b36fc51a71fb54a651178d4ee72441aead32f28392829d67293abf6741dcf15a9c82f2d0e0457ddd1df1e96b045659fa761e4b9edf774c79970d7437386d3d48a0e029c0ffd4571116d528fd8c1b7050554c031d9925157e6e3e4e886b21352c6adb0815becbc92647d2c7886e97d412d888423d8e790f0c7dcc6b7d0a9e198717f4a483a3cbe11bb09993359192a4397a1a55b644bbf2df97767980c75f9130e1b96928a7ad487bc335d0cbbafe277cc4895234b1c813882d962d4dea790c0581b574da322bed4f5212414f9999d9cc9301bbbddd55bf2d78d139455dcdeab92f6c77cd5ecc2a090f763951530992783ca583f32f3d35c58adedf045123ac45f39957b90dc7b701ce26566ac9832f3729a326382b403d28ec921a9352288f9b5c786ec57954ff39ed1329bca31e57b2f73c1451c2e7cee22303475446e621d241f2369694ba989264c197d53224465f86380c0d6b2f3b081e10d5745db2dad3cd8e8492ad3f5a42efcf8e40fc8f193deb5e0ebe1f15c614853787c81c1af9a68beae157555e194cb144bf3b9081b9b05cde27af443f6f17601edaf83412a7c12dffc6e564ce078425f0ec09d78e33f27ced9069bcee0b9fda61c3de0e4e39415027e897278175022d7c5d83757ba25814fa674eb4ba269a382b5f28f2aaeb56069330d7d23d075faba9a8769b327c4ee5ccf5311e6acdc6aa60177f0d4fd905abad3732a03ffeb7825e4c21bcdbe502bfa670b80ee58aca663bd1228b4cfa14427e88b3e148b9c95b1fac38c20a4885fb85a2e64c112f4cc4c41470b85e43b12a594f560378d02decc8944b74ffddb0d64b871f04da765c03079b0caad9eda351a13928ecb3e0f0eac2871bd9b4b4c7b9a6d0515090cb5a7a8457e0112e146033553a3d83d369c3befc5c5d2718f3c2bb0d758221fb06e90c3a7862145aed2daaeb5c1c7ddaee68e2cb1513bd8675e239d56c95b8a5d2592b440efe8184baca1b59527a1241739df673e9cb7ebb48ef73b91df54f3787bd8d9668d8dc3ee9b8b51e02c0e39fc5c1ae36f63d3e40745695d7445b1f418293b1c183aae4eaac786e876ba75d6728ce36c8dc2e54ce9019d440434efee5ee50ffbba2962a35238cc3d927844627a8490a82be5ee214f9fdb52697a940f3578b95a6c53317f06677bac46b4f2be09768ced4f936253f6323fdab0cd8ed29e0afb0f21b384a09969b4cb46263e2d2091c4e240771d5bca975609fe544e1252f29e5dae4805b6c742221a960613c717a244b5fd3ea03cd8ce6a505f184c2cfe0d2e6415d7f9bcde2d0e78f99231c46e8054377ddf4efa30668a6ed5dab5daaf86d698c4f632fd84652b7ad950b5c3490ec86d19479d95dcb784f2b23664b54982871836b57ad0fa0414866769150e0e721a056a614b3d8d3bf7189e95cc6efbfd022f0463e0cbcc69ea964ebdc35e7eb5d30ccec09ccca8afca82f7dbfee6c019851795b8150aaf21c79cb5a1874020483eaa5e7a25b84b151016883db131322beca7749165cdab4400434e131b22026d2140487589b9255935a37b4a814db7f10c2e597c71ae4d644c24cf48e5d0e29b8ac0703f344655e1694dabf6e0fa7a3eef547914cb9a95f396e83f940136d761ccb196da9d18b508c789c68b82cdc36577678c7bbab016b193740e8a4bb539734868452d8fdf0162a3276e71488e15c13f0fb76c7182cb3f47e8dec00314939c731951864daf30fa8723921c5dfb3645e565aae6d57fa6dbdbf7541d807f6ebc5eea6607e1a2fe866a0320461a933a5307255297696424378ede455efa90a896dc0de7358db6bd8c17e51df9604349eab4bb09c869c0d27fa61f91944a7f7512ff14a77b10f6d35f198f1bab737c4947a341359005f80974dbfd9e862596cf92fbfa9725d36a73a0fd65b6f3cc5a7afa7159ebcb0f2183c75d4fc8415d339e2345cc219229379324faca5b6b2b968ab18d8ed5a30898b3e201e7511be8164d3192a29e0d62e37d5b14531c38cb351723061e68c160888b5da5266e7a894c3832186d1029d934ed340bef0eb5be5f757adc56c8c1b4d14e72b52ae116ba74e532dae819ed7ca17f87ed0dbcabb91b69b0ad1ed2f64406a3fa37ad45bfca077dd81168877c73f8c277445054099adaade849dde7733aee80b5cc5d5551e166cd6d7078f208f3ee15e0bcefc3d46973f8ef990aa66a44b349b8bad9e3a118a6136191c3fc4f3048d62166b86172f09d0fefe7953d05a51b8b3c1b889fa9db9a346aa00aacc22d1bdafb15fa9190a73803c0bb0f74f739c0d41ef90de7097d4e22f70943fd2d6345ce7e6697e2981b7d12d0fe399ef9c3b0eadf90d178e1fd607dc69a44c6382e1f398cdf1de4ac6f14d756130a43227c8944dba5b1884562e70f585ad977026407fb4baee2e917597721d0cf59babf41cefe775695315fef304bbafc7db5e659d1729ea1f9897cdf98208b91fe610b7df5616215ddb37c478f21f47f315d159281a578453f6bf19c0aaa9ebe1a84908055aff8bacab8279c8cd6114525bb1fb909d144d41b830d1666c92aafcd7f4379d43b67ae4718bb148245327c6591eaf7251b1d02cdf59a237021438015fe1acd6076abb142659f3dbab01db26d6d46feefb40568f9d38c11c955ce697a9d06f9027f34e9ae958de7d71a78e93deae895249f2b73d2ac5c001d949b104717f9fcac534a03fcdce6033a093ccfc29b0a202a117eb5fb8ea640bdec5197b982f0756e8d34e522c97e14b9550c86412c625e752f16aeb7182a9b367745248a9ba2844c5d73fc59e6ac0fbdc0672972dce22d7ebc0e13f62b94699d12367255a75a772b016bab90eaba05b50475d2ede72aa752463f894518e791c5f4fd7a84157346f33157abb27a0e8d87d6b47260b5b4841e1c74745f18f186e793c13f1d779105421bc580be1ee527a25527aa4e91f2f3ffd503bcbbdea732eb7cbe40b455d04cac338d2644761813da80679075ecc58e9e03a6bec5d7783b7fc97b01a253d9a5dd8c978ee22bf66608cb21bbe45756f813c999a7063eb5b6a5a88e4a7a9210775b17de6b63a0f2dd020127f42e575b00d357270a78412ed2561903c0a0b29266a0d6ea5e8a384cc12ffd514b3a319cc29ee0f1fbe4dfc4946620c43a6d7b6cc4e4dce5940f0a57d40c332ca5d6a53f56f286dcd2f6946a543876c0e9dbaaeb21411423c539bd6f32582de22dedd962ed389f267b28538f62fc2aef2595a7e4eee77ca6bd4041d9b063e38dd840632bdd4a93b0980f78fa6933253f237395c0e94e6e9f546ddcbc2227a3edcfdac1ad65c4ff2bd20a916e0cb5f664bccada3df72e4aa3728959ac2897a0c9bf749e0da136f1e26aa9d247035a9470b478f6e998fbe1daafac968e40c38f40de192e8633de1989b7a7b50c5cfae6fda872872f84e8c753bf0a1e80ece0360f6f7cb416a563445f3b675a11a2fbd93ad8f52c5a6a63a8b2716fa77e8111a683d2e96f95b2545dedad7d95bc04eebce22b47c14c6fefa0c03b2b5d13147692cf32dfb69aad335ad27b08b4612d234fc68a8101ff433321184d636d1f388a495d443c69c691ee31a65f091e0421ec3359393bebe4ac0fa81709d82163cedb3b2802473120d9409cade8918f8ada47ea4f4153eee0b5050b653580a06bf0c2725b3e6d66da6e9d7de410b589f8a9f9fb3a6f42e15747824fd3894711a06d80cfc0e9ee1b6c114f426cb244982321dfde440bca70580d128690d02356cb5ba9c5ac984d1d4768fc871b80a0a2755dc1e15d038f9ee01608b47dabae62adfab78ca5ef956307f1975925df04c25d234bbb3eec354605d9b0b8b26887bbf3d75a6d3fddf7c2a7bdb0e86e933fb467191eac0c8565865e5066d99b3ed98e2827f901fe955bfa22a5d727edb959893bd9dd554964cad60c2c846f9e80773d97fa8b473ffc2027423efeb3f8adb670f19e95d9a267559054ca978dbe28c210134cbd2650e1b222cbbe4319403525d9a24772642ac2d3db97e1be726f94977833d55aabf203cbc7a4ca227804bcf4e583554ee8aa2dc5438b769e30e2462b32626d36cb247ae3f0793fd5a323a9fd72e00dccfa4feb63769ed8ef4968125638e54230c6a058fb12f9648d6fb4f05441a716761a0cb31693eb2f8e4f202d53c2ecf2f4fb288f482b64261a0515a251efc6ebeca3df6a0f94a2f77c1497f4d54606ab23863481f1f903b7f30b3bf40e53df197d6e389801c92b3d4f5d8b7b10e975aaf1d20939a45d0fcd15026611e4d45849a41ef3b98c7e1fbfc673f444b1cfc6716da6a9fd3676769119a48ee7b4c43884b9fc133cf0aecfcaa0b31243be4640a5be5daae21b8de53ddb0e5e95cbfa4aed848ea31e88ed787cba36049cd506a1b02c884798e116c198f7e8dd9e931a6b69b949426557181298e45491a1dd5add137717968ecf9e80698d1a7aabb27814fd03a02f49dc568dcd3a495a6d729455ab9ab928d60f70306a7621ea52894901ff9cb3e606f737a41de9610ec9bb22f7543d658d9ec986cf1962fe15ff29933eb820436b5ea64ca3b4604fc19aac00d90665ab4edcd3d4ffdd3c06ab9ad1cbb60cd91abfefc1c5b49599f3ab6b6df61695af70c1dd149bb5ba5e3fc4c36ba65c4af09f890bf3d8e620bcfeab8fd06ad74ade4efc45500a620bd7c4d79d06bf50645754928ca01e7ab743f2b1cf4c6c03b8fdbc7b809d8720ab2b9e03f08da5797821cd44286b46f836363da4f0596d47ace1a0b9eeb021c818e467e18289562957a1dc3416d9d6db9ce8ec7fe56c1cd1155f448a6055060a60c473ddcb3a9c6a0bd7d0bfedd2430bd026abe2cd7dc61f836f1c93212a91e80c984d68d99f39b0863dac91da418d42f36410e6f048272c65728def784afefce3069aec3f888169095be77fd2a6122fee68b448bef7e0838e139bebac7a10c396ef6bb9b2212881f41dde2120550cd464433144077349a1f5b6701094af8eef9a9573fa800135fcc1213a84ee07d12979e956b8afce9c12bbe3af963c4036881723230f5568cb7300713bbf243a2b6eca53c48a4a3ed765d154fcb3db7ad61620c6f8c287dad3cc8ed4b5f97f1b29bfbd73d7b3acbeb9939da4d37bd3e9c0e90419da7355dc52066047bf6c7fa8e4d785f174a5c1d1246694650cac50ffcc63d7582ee648eca25d1d27be221159c3bc8dded3c2bd624bf22d3b13844099ed26acaef83de4658d951a1091dcf206c46637a4da026debfc7c2baa294e6ca6a35e2714a81479c2d5d286638bf794025c2db11ab55cb27ed83ca9dcc772c1cbe32f667f3c8d32998d9a2d3bbd0e6bb5b224da57bd2c7b62c20ff5d8d8e3bd54d4ed143e04437769a24abf9d6edd5d30f59ac87652cb36d3f2f3d0039d09e614b9a9b8b9b00ed566d4856cf004788382f242ca8bbb319dc2f54557ffff0b52390078ebda8ea3448479337bde85151c9b07dfa497ea03c5ef4b84579ef695484cbf095f5cc230fd6c59cb002d058beec9498c6df0d39b177f7e09be58f235b958c87905bec763ffbece2be2470f0923b378f0059323b4c4c6c58487dc61bb91302882925463e819d0015dd5ea86da8d761972f2a840f18f27622806d0a2d073f407b12e7cdbd0a5652658cce25dd406c31f09cc40255a8647b4ddf9f7515863481237e9f3267fbaf49346c848379af70acc1a18d7e71a6b184fc4c22c215d003da5b0f6edbd621f1f579ac7dac2e61427c749ed9909a9c98f38cfe2b237a38e3c74c1266cb5cd1226adddd9d600f0d5bf0a42b1bb5cbac3e222e117bd8fabe5d3dbf8e828e04f801d1080f41be507b3a0f9ea5ae2ae94fc776c0d59cf1630bc302afd55343b2fede07f6f362dd9837fb36e00b6b885319f754d0959e84047c21140fa31e83d0237fea566034696a01a2f32ab9f8eef59ad305df1ec7c700ea7f69029558964460381656b0795cd407213f9477c572bd712675248254723333065c15912a8f55cc998479711f8f71cc94c7017ff96430566b195d6abd600809e0a6635832a4ba58d3238755af0e527990bc241ff82d3560ee851084face0f48c4b87bf016785a5bce452d6f9d3dd9040507a7da6df880d78d28018ffd8feed4cb90a80180527d6e6629fcff31ea4447c718fe966b5e9a8ce0938bc8355f0cc0c437d0eda95aeab200b8b91cab23b67fa49f547a536ef389e950797295e27a9f061f0bcfeec1147eb81babedfcf4094284faa28512b7ed13f91c5ce09682861d6230f87c3c75ce1156191f29ea0f50d00e0a6e6a652a9aa7a0aae3d8bd21438dbece519ce69adb6b97ca525050afaa8a05f086980a9152bd9ac98a3284db91ae9632dfd64d09b59f7f28fe6b3151e5bdec331b1c6a168febbe17af1cfaaa2c9761d09168091bbab20e5d74ee10a234cfe278c4e3d70ce96967bd5c1dc4a3cb7c345c599ca9910bde85a6abb5994d04e5e8d9357fa83223c4eb95fddf700cc748ec15ac362c39a3bfb5d95d5e8d234eac8f8bf21c8432f9abc54b069966ee577ebaa3cb782229728ec5d27f9095913a863096bc92dbf38280196dd0a417f4fe2725afeb85b773b0edde41a0539f1c6f09d7ef7a86c8054ef49420c1bf890545bc4b1e37dd77f7d9f18d4f223bd4b810a5ba48d81a9fb9286ab08d06a1c0e02897d629442ed2d32ff2142940b16d69ca028c093910409fb907963e711fc0ff0f8fa03cd4db69542d1178fef1acb6e8dc6be1529da6abf2b1319cc25720093da567159c6f034611e313c5f3ccdbbd7905b9e32ebef00f214cef5f4241ae123c88017cd56984bd9060e7874a72616815bb0cf5baa1ff63f9bbde77df2c6d25ffe14cf48337876b6a0395722d178540bef6750ab25466e3a474e3fa07760734187f53f5161b3049a6f560774d5ac07baab90f0894d990855bf7f697ed2f45eeb394773c404ea486f4e6587a71766b9a7751a65a97e453988a4df430c9529052a95e892ee7de8d6285488846e357fded81d1468c9c5d8b8029ad946b71a571e07cb9d22696ba100cf51411d0a26b7112d1a23ed29ef24ad2a1576c92917a3e48029a8d38c5b265aa6d09092cbc8b82af5a276cf7f7531f61dca0a2b568affc707c4d5758abe67401ba1628c6c2dcf04c08ee163ce01bd7f3c428ff110d7a26c94f71c9497ab25eeea6c06e9d2d1f4ed7f345c343ee428c06570db478bde06eca10ded43155a8eb962e41bc0906dd204c19ef6510ff26de3188e29d237e95380555828819e57f40bd0a5d583c2dda779a8cb252ee4c7abf599bf80f80f9f8f74b04db1bdfee4ac23f9db583ea62965b3898f092fdbae2af98d149931857bfe837c9e8266b9d4e4d047f5b64c3665212f7804b855edd7688f66654308e31d511276fe39d90e2a39291acd0b9c63200e9d1fb87a836ac3b60964b62a4406313210666109d6cd5564308d15f9d6dce7442a966d9247e438a466eb9c0898732ce11ef0fb37726a71305be0758e5929dfc698bb870dc7f0dadd49b00bf2f392d7f421b7fb1db0e9db33c53e43a083e96e3da453225748fa1404918f83b85a431059b7a3efb5e5d53a1d9eaf798b72e067f98d91f7eaefe5181581cb9cb1bc39e42203ec7a89f26256b697eada33d731fa71cc2877628b8c4bea8f58ee1f8795ac0dc3f21dc3fa96010dd49482872483718b53c369f899b0eb0fd7149f712ed2be81e394226a66631d389049689f30d80154ad8e272053d922b2856f2b7ec268c544e2aa902492fa8e42d6ed7ac730e209e2af73441a45d16b8645694f25b90a06387f1fdd7bb03a40f23853ec984991ff119701c4d7b5297996afe8d79dc615156c1ab16beaae75ac09a872e50a85c5371aa0f01089778cd1d855fc6d01b53885236941f3fa49be78b806f1a0c2e2e055078c04f888e2dd78a6698ecd792220f3c51467d23a5aa1b8b640e0aeac1602f27d53ce01dbf5a7f24bae154494f78174e2ccadd22de71fb9cb6ace2e6ea04674124984c08ffcbc3d14be1a0e5b536d30f2de7e89eb9f7b06b1cb80154709378c4239c03de8fca1ee85060a733f4743c5576ddbd5f81e194ab8469e2a9f3898936da47dbc54e69cd5ee2d774bac724ca9d64ce10c4375a3b571cf0bf334c70393e4b879a5bd8ad46ec2a71766b3e218b1d6fcc639c852b74a07562cece4b9804e16746fb85f1d4fa514aeb2adacc97e347ca64e00e408167a230591e27f5d2374ed0642bb5bfeae93be101de154944f6a1bced28f392c16bd18e33601dc149fab8b49d264015521e4ec7e176f67fec30dc30aa2dfbdbba9d33909b5dc5238eb012e3b7fd2396e31a36b43b820d8cf75313d091143d9e6e3a0c35b76da7a0ec48478f98223e99e711accbed8b78d5b07fd3b161304078c42958fe63f54ffd0e47ae4c8773824826607f73351592ea10b75efa37f9ec8440b351524730b8c5fa69db4b801e17c7759b14b36d6cab59324260b6221d179cf7dc71270bdd7c544d17578831a31ae1a17521a667146214b2beeea21cce5c5fb8f18342df13a7f6b71a9ba32eb6c70f2a1558986be3dd645967eea601f10c22689121a909f8682fe64dac341ee7a9774d70853f58f228259bac41c3632a13d334a1988c3f2a67d72466c7f83c304b33d93ee629fab1a7836d7affac4be43d5a977d573f58a976932b6dee68e022f82750ba8ea0e8be58a898e837df0cc7e1cd01b3912cf858d3411ae3d9968ca17fe6525a7e61cbc135def2f59fcdd7eee18a6805c87de37f6dbe14ae55de09a78214966a623cea9b6f107e95909cd70cf2d273afdad792d3d3203283e71df650b37e60f830efa220c161239ea3628d6f6ebae22d517ab71e62a4f090d26f5c46fa9d37897440d6a05c4d89d233ecc6ee89278014cad4edc0b1e542b12848ec67323f0558095507e14e17369e4b9146fac5b128625b1c651f278f20a989948621dcc90d6b688f76217ff2b7b99570a6e680b2176a5d12939024496e019b2c9b1a20ea379f7672306782824e7eec33a9433bd1f4623e3828fef815f99e8c7f70480799e1904c613581a5eb95d7262d9369d2c86b2ea86e3287db2593c669d05f023f8dced0660dbc14e246248177760d2d69174655be2215ee5ebc8a0e67ee09a1f1c32f5eafea118a47bbe4d5934d06900608ea269e70ad785473e6c22b840d8018e1c0ec41a53a1b3b50820cb7f37446444979a21bd5bbedce7b9cac5e62ee1a130023d23b86e673fc91bb8cca0b9fd374d0d6e04175fc9e8ceecb34358835a49d2b324081f89a15c4ab1f1fe340349de851a17fb62a9b58fff0fae89bb21a0bef01de668d4a227455296a3ac11ee753e639fa459b48329ad0bc923b24ed49a81c6c571a6043b6c6e6943a31814dab657010442c9b174f790da87a6c5fbe83d90b7c639df8f56af868cfcabaf7cdde243d73c1f2eade9228e792dc8f667b762dab88b452040016d72a9752bfd98923b27b27a580e8e456d98b84c9131848fe9757be226d410711ab8231d616821293ee5714c018866f3af280b8b039a6b7876b054b57e4c61bcf54ae3a61f6a1650de3b7f15a27484e70bbacd04d0cc7378a2620a0b0665e33ebf07c587ff92fb275d9766f520b9109da548adefe401ed2f4344bcbbcdb96354377c0e23c300e8ce218ad365e914e1e722ded736cdc83f61d2f6d72aaab1cf21ea9e686554deebe84c223f86469b3b443987712d58eb8c35022d5840640699c7de954bda53e0f3eb9760a8f27133782e6a0f0ace9a9f8f131f7dbe7211f39c39cc11661ed90a1dc997baaaceccbd790325604ff5143b8557faf617e765334d61df721d27f8a208f89d9ec352bf731875d58d423c163d05749936952e43eb8b2ca381255e278cde913a23e3ec8e52ec7842462d51e274f4f6899f69946ef8259a8aeedc5bac302fed724b16e6124631776b7efa0597699602d01b33115d680c7402aae6df30d08d6aae057285eb2050db03921225c74b9012fe7969d90c7aed50c05bff0e763f61481117f2a4b000113cf5300a0ef3e10ca300f8acb278f48e2e12a5581f41ea3aa34849d21029fd7e790fe3bffa15fb72b48c73d03955363396fd66ff088f5d4e8740ef7cd7316e1ffe89b7ae30ff94e5a20f6b687dd4c520ef23b726a68b325d9a96ab1026af0c778d596983f210a142b9fb97363fcf41bb56abb318e4102397eb2cb9ea2826695d92213def16186c6872492cf64019c2bc84e39dd1be509ac8f496c330ea5d20a4511d130922b3350798fa8af405a8994fc33f67651acd71f5e7f9432e7b5823e5399532c08c88554a5e9fedb0e33229404d67bc39aa1f65635286b20e8a5d275a55d49775ef57a87c3741f870411e50fdb2f5a3a774b645ac8448657d29e55016af62b3b61705b7e29a1717f4fa8eb7daf2be3468fb033b9e073e1a206ad667","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
