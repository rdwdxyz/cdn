<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad8a145b10ae5527364a80a81d194aa29b8b85a529710610b3e69d7ff51855683340361715e5bea061dcc152467ca0a74cb4926278022580efb72feb2a90842fb235727e13221d0d296952c5d8e43c8962e6875e7a8ed15278434e136c6585aa1bc77fc3dabfc28e072276031ef49e28288979c087764078fa55d1b45242a56bde0b419845298feeb395c4095a3beffb1c475dae42b06732e671718cdf9c85e0c26d1a8b53be1d1409429109487c59cdfde7633e9c29b5778f2593f78f38cd6232fbeb014d835d707d21e6b5b6c5505994e8bd2e7118ff90e477a7f6191bae105c053a437cdb587b9ead738f6de36d3239af81e19a783ab8ae8f5969a5fdac770385f2f2ab8b80b040f08d639cf683a3ff9bf8324b8b36455288b6c9202b76f15a9995645ebed04d99fa21b54dbb2529b55e332c205b888addf81a4919cb3b1001cd3d2a832ef98b677f8241866d288b5d5eea721f2421c1c35f6e37e29afa0c8f35c38448b267e58a5df5f52d7061398a0ab5ae0ebf9cc8dd67402ca3c0e2b68b9d6f3440535f817425e4b593b9f9eb2acd7cceee3dde89229eecd9bed0114a668dab05eb98cd6ccc841641fe7130b73d9263f8833375585f281a7b9f9c3bef304b4c9c84d803cd50b7caafd83428911e8d13aea8b671bb28d1e76d311ad966a1246ed5e9401669bd1dbd29750c82656075311feadda911a432baebaac618954e02a22a02278309e5bcc15721affd7b29ac6fa689f1457be9e219e5c86598df6816105dc36f07c9c011980eeea1a1288eed57fa26fe1807d45f40e115c267093f6a986e3bf4f41fc22550547656432b08ceba5df4dc3d3ccfd90e316ffa0f3f3482359c35305ced499aa956a690b26a656b75abb40c69a1948a3961b273eec44b3c165124930c9b056ced91d70ec7900941420319b1187653cf85ed2e12e073f8b471c52a6fd1fd6350bc0505705c944ca038f0b26c1fd359cae875757d47fd67114439fb1c0958620f605995131ac5177e10a78981cf4337c23a7a99e5b0bfbedaa6907dd8bfe666243e444e9ead0564658314b8a0e4e2d984b3de6748e3f8fa94a2e85239757500478a39aec0c9c835a82976296d3d9cf89079ec5a25205feb0e87c3e4a6c60703445a4847d9cab85befe025067a73318b744991b7b6580f9ba22337bfa65c65ab8751d539c2555bb97fa5418955968f00f7a3532d0cc7812f110a0cd92c0096c4766bd42572f05509aeaef7b29ed4f216bb991ad0d03eb9f986f8c912f90744633887215e45a1aa8dede2e9de4557a4d5a5b216f2483259732bc7f5b8026fe60439538a444ebcb8854bd1efc2a5f36e8fe6441b99b7122fb5d98c9aeb2cdc00471e27cb78c3a0996b6f0c35d4ef66ff68cc8ec9b9d79b153434822f3b4977b2e503ee0a49c7a887c29cd6b7bdd841e1a150074d81879fcca87d7ae8f2d1f722c234baf5eb1112fbdc157587006b85332c0dd7a7049559e81379c723b459f9b8bee6ca08612db9eb5f2a3f4d2401cd7afcf33a5f4ba018ff6927e8eade7fa3bff003da00f8ab521c7653eaa93a02cd0cdde09c711b0c1b28b5f55dd47fee47fe24f682a9b95456b4688e5f29d93ab9dfa6513c8feb8eefcdfaf9cfcf99b35ace6824b219938af3ef853e8a670d37d8779a61f16db5751ba7c9207402a37a8586524a9897f69c34322fc01d24c45699e527c9b1ebc3377f184619adfbde40ea488456c59fca9c8e6236228cef6e51f5877056e7c551bd45fde1ba0865e74299f7f1036d31ebdbeaf718a571104d9beb556485d8ccc9155cce3b558d14ac9bd2d1cd8445f99de8e768acb846794c2a821d62f09861c209cb2d589d7b598a562a88db64da8add4811e8e362028c083c2f04df23f49b46227266d5ae956d13a7e5b1f26b05ae87529c5c460705fe5235c17265d876cec17e344e7dbcf29346360e42c453c254a47824d86d0f1e1d2f7334631c69a3ce2b91888f294880b62bbd2e55b45e6383b85e8689c5c6db0ea357113d84bb0ce2a5094dda21912551c1f1ae28604a731be8011fd34c4d715d2853cce29298479bde716f9bc83e3ea24ded80c0795e805335b234286ad25c0fcc8edd2e70f1a8cd1efa67d16a6125d27536027ab872b88227e18a8e68d1ae0be95aa94cb759b78017161fb0ec0386d31ac47340e1d07950b593e0f0dca947db405471d8f86bd0e7bc694885f184313013d4ebbb9ccf1acb0a389d4da49dc625eb02e7dbacb68a9179544e1eb6a3a1041b3008319e38252d614bb79ad9a836780e475f1f09babcab6823b914367643ffc505e29f42ca3f38b2a9131c6239ec9993d2434a044cf926401a21aaba8e1c5577f6e39fc1b83755dd5afd660758c2cc985c70dc80f89d2530d1a9026e02f1ba1b91842d2bc55d9f68fe7bec11d71b074741b40e2ef4be28136debc95b225a2bce2ade39dbcd1562f256917a1fdcbe8414ea8fbaa55995f088c980b644c605c3d3fea00cc0d31b60622b5d03950703d790677b2590e0b67fb1fa494a8fc14cd1512723afedeb00fb47bc8e73a1ea704fda521c77b287e039b24912a9e5ab899daa230213a166ddbad3cfbc2a26a759391849ea6fe47e0fe8bc7d762eb885a5a6e8587088571d7e4c49fe5b92acd2f18f20c65e34321e1fd3c8a8c09c67a773c5aa01b8f181ff4c97a80353140aae20373f303d713d68382012d3af8238a47251ef4437a6bbbd62ee86076b27129e1320044df3b3e5d183d8bb87a6f0c50863cf46367b2f2e705a204ba3ee489aeb259e778c8a6b93c073bbf7a9cf0d3864bf942434e516a1d1130e875c5f0d2c5b672c1d4e05b25a97ef09c6d43ef958cadf531b600608ff1f71f7331658217aeed99062af6d573c3dd6d0821e49b40a7f10c880debe57f34b6d2c9a1f7fa5675fcab80ac76f87e7b8c4a9b52941af07fce03eb186044c852b63bf90b280a1b32ae9b0a2f2a94bc141ad603b7ed243bee574c0cc6a4759ca542121cb7cd3e79ce3c0cbe71751a3e992221d986dfee216783069206951c5ff54d0118c3037ba99ed8449c6dc9ab898e9a5ca526a770cdf52d3d8c5893e6c20fbcc155de878bb8ae7f100ebad0df42b906592d8fb78427b309ef87c0994fc37e11403871f193da20689444106367abe6090f9a327d43d7b7ac725f096cf4cc5ae39af9ef50adb333c78dbe1d9d80cf73a173a1c572a9a4af759bbc794d80764027a688bffca6012fe196ee93b4eb2eedfe2c234129e183923f0101c59dd572e5bcf10cb63a2e0b39911b25481941b15dd465d39c4614da480f6b339f9090ab925e1239fa8e49c53332fce0c66bc00e51c9a4cb07a726fbb70e0cf392c33fc430de2711adaa527d5091b96e9e6a4ea6d9cc19b52b9ad1b4efab373560276adf7c10fa0db773c872706af47fc2195f3eefd8989d192721db7064a1f76d0605b6df42cf88208af1a5fd7e9dcc1ca5d371f3231fd92090c1033cd82e9f4c2032ac38fe332747f7e9136ef574ad05ebbc064b43dbfb32a74f44974fb033ba3545a3ad0d92e8a33530fde1a40a92e8ddef0c2323c29c638fefe332dc37881f0e76668be7056136d482217b042cfe51d8000b02b1829d1be80fa5025e1e0135013396a693be01a88cb2e7f162deaf58634c419ea5d37910141013f134d9899d3c9ab0e299e86c07d22a2cddea9aca1fd58f284bd0fb4969402d9bf7827323805c20104b91ddf61db4e6deeb4ff7af3e6cfd5639c0f65f40b5f0614d01923519ea3ffafaf0f2a584901ce56319c802d7d9fe74bc46cde00bc8aa3da66f1495d73acae28a8500b9b9bc6aaa724c917ec736b6ced1441ba41d84744f1741fb53792803a42ad8cd253535e2b17bdb3a6c31eecefcd821b4744369f29999d4f7fe411acae56726225e981fe09bfad8d0e99f4fa4463b276d680329a3671efa8bc1bdc794233ff4911185f8ae21861f9c8f1edc58fadd411d62d84424745640c956ad5773da8dee7f225816c6995d1e4c8d8ce360fe94a17fb3cc9597c119c3d9e91beaf79a1a38b329de2115a73979c4ce9c70200deaca4b89ead1a6e61e3e1727507039bb4d46a49dd170bc9b782fb8e2cb8dbea599d953f30114860a310f058d4be4e909022234c88a2eec25a29bca7bd7e9c202b53b0d33a729dce48cda06b9904e9b571fe0eda748e525a4bd347f9a344b52c6099a39d238cf43238844600711c5cb13f1fb9d95cf349af12a7df339ebb0930f238c54479d225114f0640206e01df7b0e477f8230f39e651fdd5afcdf87af21b2ed54d15ce11d81c4f2dadaec2e0aca8783f237c74dbbe8796f007a81746c6d43b50621052c2d0fd82cb4a765312cb9318386d43c450210a9af09596433befbdfb3eb30039e4ef51ec617a0d3888363d31663f1602e6cbe291b36e6e7df9195a68eea8a8d8114ade36803486c45c0db845a0bd42440f43a2c61d2f9df270bc0d368b2b63335e391f27d15df311df79e12e3d61dde621adfe83142eaaee9daae906531ba7d6568eaf89b472675225d5b4d2ae4ca0d21e33ce7d824fa4debf239a2a2543e4be9e7b057e20c33d816feb4ce05c30b58f2b5ece438dc40afd909baa760d5cbebd228d05976859d9e08294ba1c62259b34409f1f62bc38f0c98c49cecaa6d2cd8d92f926e39d0ca3d537dbaaa1333f9e4c942e851933efaf93605b45b1204881b9158af51b0727c643201c504b48a458e3812eaa3cb35b3f3ade8251f3bc93c6eb82b0b032cae98d23059c0d4f0f795b5af859111e064db862a2d97582e225b092cd58a02ad07e5d2a1ef7bb8e44fd641cdd17baae266be35081fb6e28bd2fa4737d8c77e1f8c006793817c3b3dcc01fe78fcae8982182ec6e4766084e7bb58bbffe905d6b9ade3b23c6e41a838853333f923611b4707aad4cb9690c129217b19440c82c73bc71fd696d43f32350a942a46e88f3a72a08611f12a8c42d9e7e89ce82cb1c27896e22840c0877a84b0b7d15110db7096c14044c359210757bd105d8b880dedd3debf5e22ab11897af84373bb3009e46f33e5f25aaf4ead63a9b9ee776d191b20c44dd383214acb8459acfbf4b226ef55312fd43642e9bac57e87b50986d347741ee20e87990b0181ef214a6e1ac42248fea906ef2887a0fbd87d0af15d034cacd010ab5cbb8ebf5fe6076689ba88ab3231adf4c78a44e2ac8c3fa73acb56437e45d41a09627c6bd3a5ea4caed48484f872f7803f2b8edd6752034c647c86d07aea10f29eaf5dc5c19d968e3f1bd2edcf4a818e039dc9d52888a9107b7bcae334c2b24206c3b1dee3ca6623c4e0490712c21516628a9be29dfb35a89170a6ce5adbc1c8271ee7c5e764f78a0043955a44d83b444f8fde114a52a56bd3e4cac78614e9d374fe698f36610478a3b96a7c2ed93d43aa571f5c18bed7bc105746e2d278d84eeea65ae6572ec8a3986062c938b1d7a38a0f15cb55109103413ed5fb41858ad04d5424fda007c05d04f423acb4e841f5aad53af65543d9b2419caaade0cb6678cb1cb04cf1aa862df8d0290a7ac85a609fd885959ab03a0cec4b24fe6b216897bf71dad825b9032b996f1ac243f32d75ba601fec13890555ce34eefddb54a58d2d9654ac746f67140f1f2e61590a02fc535c9e8eb8191f5a896fd42844847f80d07905a170a31d1c3ce8eecffd851278281fc6bdd2f922d21f1cc00b9ad836d67455a6cb2176569a446536480024ec3adebac1a44cf07db78edb9ce9cbdb6d6f82d49b5c6e4f84f4bc5979010950328efc164772e31788fe7fc8bb51d5e120bb0d8d2bc687cc42baffefe943ab71dbc8f01d7d0b30d745ccbbaa2681263812cd74b0af06824ca2b21478518504a455db7be9ca1a67af94e8ffa37234fc3651a5609d04621b6b20abc29e78fdc42ef228a5b908a505682731642a463d49ade65b2eb0589f6726aa281f0f580564a4d24b6146bd84361c84ec0cc6b70a7f4d578ae534aac2b7860455bbf4603e717825ad3977004d5b50567f8455c88d6b2ed24b3aa938655e875655ef90427e7d3fb6754d78c6791c3033680337163a649d104308af3ff5b630cdaab3fe40fcaf3c3dd86f22cec019387d2259ba1d8ac0280fce92041d73982d7079f5fa2c47bc93abd8c355d1e23c11cb43137fd1dfa80190025275fd3935f4d9e5e8de20231c0cbd53fcf56b2b25628afd76d890f9d4cd4b844f84280849dd279b69e882fa695a5fe580f9de1ec82f0ec911fc41915e3c131b8926c46497fc0964281db62b1d0275537d3fdcce1653a3710f7147f7c7f281046feb290c3563b7cd415822341660a8272f13da290e907553421a939b726d7371123bd5eef532eb096f586fde4228516eb38a0022ca4c654a7a7d08993939cb3dd383913eae5b84a4d91ac80c3dada704450612c9a65116310c0dee227d3e97d5c256ed97824ec038f57286435b718a9224177d1218b582c2077d1e56aaf5c219105f27c07b89ecf7a02c299057d0c97840099ee0b3195b94a645e126c77ffdf01e8d9717bff6a32c3feeecdae41e281fbacca5425d1097c1502a6e003dd676dd578fb6e16d32961419f6f0f3df89c4f0115eaedd8835f933ead86b0285433c3075d6885736473640ef05f693fe4a19fb2a1790d516944285c04208c0ea70c416400a7865b00638c9a38a1a6a9d6807a704f30b7dcf40d4f0d42a31f11fe0cce0c129dee7e42eb9fcae5cd4f250a44616b9b28fec12d8e593801e0b9400092f42c8bd40c70770c08379b5bc7bf9f9fc190867426edf70b5ebfa4bbc312bcefe4a7ffe8b9b49a73ea95074a81e5762ec25c10be0672b84897a7c93e17304ea5c7703821080a22961687f422ae7e4dc0c78e7d329cf854898ecec325f95c233f6474622875fc4dcf1a87e900c66a06f1bb5060c2e6ab7bfdac4df67b61925434a03c91ab9b3b2c47b9588dcfc104592d86008f714dce64d40ee08ca8bc105dd7234b7af150d769966f4b1f603d96317a492c64b425a301165c81573f76e9c9b2ad7784d9184d73f614c35969d6099fa9c0bf53c08b4314c06127a6bf20707ce6576e0b2d5eff6d5a15e54c06c12af8a59900eff3ea47b4c54f46dd72796552a00c0d2d111f3f99b9ec1d78f5ecabf244ddf6d9c7d1c9b609cb35e04afb962185b00f444777f21a3f9867ef00c8f709b4da885164c604e86de5defd0518b6b4aa25eea769c47b8b82987e7618ff145a1c9581267a89d2b39f022406d3f51ad67e9245725a2c50ef266bc36c8c853446133a9bf34be2ef260ae7a62b17d858905f5d17a2fe7806b88a23ceb444c5fd8b720b0b9ad6629e17dad6b59606266046fc18de3cf9d1b24ec457e7990906f60a4f37f94f1ffdf91d9d5fa783d18879490c00723c5906a372747c8ca1f56f94e8b4e07c99ba80be6bb88c13effda8c9294b189b5e5e249613ce2d8192e11ffd5ab2be531519a78e66e5b7f39ff773a71d373887ac64d933736af6aceb03531bb6ea4a41dfcf7e8045290facdef4fd64ad68160eca8924fc0e321d6031b7e8dd9d446d50b8512f7ca4e7ffd666c960c4061153f24442dcb92e55208d67da3f1f27caba138f4e0fc850809ce81bab69aec7c1797851a97e96f3f27431dee30627d43dc1f2e93e461359dc698d3a48975db2b10d2ff66db6213950abf5bedd1fdf6aab5e08dce244e8d7f61f65d54722b0640201b37776ef8ad533d3bc5ea0c2053f55d6d7afd0254ab3201bb15e6652504931ebde7644894009c0704de960dd04f3dffafda4361f2223e831b54b8e16479dd75ebb08280d53802ca97bc14435308142b24e31ae994e50618c43ade6ce987cb6ae52d2a49edff753d6d31b2c7722839def2b62e4c01d2c30fa670099ab0d06d2f3ba4510c55ddfbcb6238c007a0b2e46eba32f9900c4b5e063d475ad10e5ab3553382b0645f76320b30821995c5aaa599e82dd6113313c515c3923a5040683a743b81e6d3753d53b56777c793b2ff5cc122b795258d6c0ea147d0cf0625f2d365872eca5ac15e0a003b7ce48138f088afcc4cbd75fa18e5cf085e149f738fb59a55bbfcf0cbd52d1ba28e00580f897d5e01f068f4f7ac39902bf4faa65c6a4fc0fd16f46664d1df02eee60bf6fce536c68f53dbdf8a4a6ce9eeeb72507b89bbcfd468a0efeeffd7cdee1819a0052b923f62d2fa12fd7cd3baa4760b32aabd2d6e52eeb1dd946e2f20fade30cd23bb9f29edbebb3a2b28ea8a3d5c8f29212e504bd6435f3510e1d6de615e7af3c8b127f0146ed2743431dc4578b52022d576aa3b188f5b10d168b1ad6593721275f70733740e2ba9e422da91198dee569bdaffe7cc8ed922c01bed04171a5801af55621933759590303dfe176e221c2b9329ab58aa9fc92af9699fb5deaa1e144018c606ce70413f6264a7a128b7c2f3c04b69a6d73c140a6e0e16686a91be8b3981aa13a7431435a8f1ab312d9c32d147e44ed30f3761c809b8e15b3cc82a4b5b784b49cb3a9a9f47d7b52fabc29d3c457608308f0ec9c62b1172c25ae73cd242b440833e803f68bda0b1a4abb242081c2d881ff2b469082ee3a6e4386bc259087f179d8f5a17057f70008494b3d7fe4aa0201f0202b00a619ff0451dd2b3b0ded2fc8ab64fa5020985e00deb5b5b086cda1cbeed4417deb33660f04a8f559f568487e320bc109e7b7363e8354cf81295d0b2372b5f8c6f7cdcfb820079d0c1d28032fd1096eef6c1565bbe09411963b8f1fcd8c0ec74dc50a268f36ef7acc0dbee5e8de5fd6bdb2cbaa9ad446a0b74e66c1568f0bf2440bf2b4e1e4b23b89eb2af44786ff3055ae8cfd1017c97ebb315e5c4a96649969671f90dd4fe12b21a69c3885cb484d520cc7c65cf20751b63db294662622c378482e85cec0f6535631b4096145273b7876aea1b9f53991f9592e934b60995418d56c2c41d2dab4b618f9003f25579e57868a1d78c6a3265e2d69fb36e63f3ddb273892bbe2e774331d9f3ade57266df5276ff38b845e798fc6cf4d265bcf48e6d0d17120e735806a616c0cd1e87421812c34b82e386d6f38c767a8238ea6d781dd399e636c88159bca0485554d511d96f3ed4a929abe5990422784b0059f9d669e43359613d015dfb1e7a3af763185a1c3bf42233a3f4e778fdf41a2e679e2a4af74aa2dd0ec036928c02cba3eee7ac38d158e3bae0d423d2a104c55a72e361732e53035812e6d47ddfdbb8dfaacdf6e583ba196d526bd29045e7dc6678f197c93fd4129245870a738459f45e4a2e165113522f40a5ffd1426d0d14e4812add3497b45065b74d0bd1deb83fb8394e3634e0e822514614cca92d0623d2b253cabf50a19a853ac8bde6b621327289636eaf602afe42c07759c914684b8138f9846af97400ecfba5f5497fe3eded6910d0244af6ea61b4efb90e2b5d922433933efcd34aad09211af1e5a1113af4559993a8c061bfce5de24ee248eb6537e902e7e563575a4a0fb1d1897e4046ec055c783d2a024c3b8ab549b122e85d111ac0bad31e103f34ce6e6187a6b09fa302e9a6ccd0d82d15d686eff544dabaa379881c36653f5299a1948b49c7752cb027605603525be6e76505fbc8e3cb275465904452dc4414b7fff25b1783eeb854c794dd681399a26417c2ea01303f0e8afcedeb3d85bbbfb4304fb4c9314fb59fa6e19dd17ac93e85a2ae5b403653ec09c33d9153a012e54be07659045c231b420c4fef61b54f8ed797f205a7ee4b9a33de16b52e0cab786a0dcff435695bc8777ff8f56a99230148eb00c9701637d380e34daef70e6e3411a021afbae5eddb02e16ff75326da3207a60f97c77745e2d858162d5ea8917460d83ff7d11a845e0389f9c716412855623542ba0fd9dc4f8284c6d1d3a1e8b8e10d445b3919c604ea02964a489a16157f45bdf084ce16ca90ddbcd213f7d01175eb540f0c7266ca4586c1fa7901b73789c38261f9d007c73dc95bb85e3c5f898fee95bb8d9eb6c5b98153008f1d2c34337c9ca24eb11ddb2334fcf9baf2e45adae99e7897cbabf0a8ea4d5f2f964dfd1e0799cdcf8e23d63cae9369a53d159302579a06857dac773a8bc3a89b72f7f4e6233b9957fd1bcda6f09da2190e0a365894222e43357cab1d96f789adde9c61590650241910eb8f7a9fd4a704ac28ff667ee0b9ec1c772d0d73bf5c1f4c02e9776a20e02d03fb917d71f351c8ed0c8d82bcf95c56236462e22e8ecba07fb75348dce98a84a1fb68e6e812152c96ae85f9a7cb4c782fa4e69abd9e863507378471579126752686eb3b0a5abc3a78e78e03246010ac6c2bef5bbe2497c650d39148674ab4f4956026ccdad29014dc8e43070d09e83149f9f9512043241c74cf6f72c3d6151819dc28dc4eaeac3a1bbe472bb6ad1b41b0d33b0d23a4f101134ab913598c0f1e7c95b82aff8bf7aa5b198830be235696cf8f41747e0292e364222e06d0d359351cfe0912a58c4a194da696b66da331cc906759b018121331e031ba65d7d7c074248a8eb274605d917ff83aaaa8d13b87dd12edfcf688996aa0ee292d3e2761060d796a6b53eebe8ee5d729df7a7370d34d1e518fbbf3bdf89fa7f13ef5dbee113aaed67889c10a2d95b3c6c600f63a31b452079fe655fb474857ed3f88d85c84951521ffc384bad4137535426f1ba84cd01dd3b8d1b492fa1445dd77a11998f8f9fc4bddf8fe76b11ae5b4b4b29dc1a5deec7715915033b6a4b86fac6ba3ae3db8bd83f8e4e8efda40c7fcde0bd7754dbfd102afafd19ac87c73ae5672872adc8cec443f8f3be8bc23b8c189f7720833773e674448c49c220835d0fb88e7b674979d1fbd45af102a03e6e50f1b0896c2e0ccd0bfb138a9657bf053f9a9902ce0d0c1955132f20a99e118252f99e108d25cb4cfbe0d1b848de3c9696f6655c1c2c43ad83e953d0ba6efb657badeed658bd663cf130b3e8a5f0f4207ec4cb44a10fcea7128baca877a805dbf94101605df5dbf19cf3ff736fdb805e32c8f473188f526f39f1d8eb83ac3272987c3a2dc03caec60052549b018059621a0ab0af912ac6e337d8bf762b527312ca63b7a0f9f54234ba060c49a0da4348cfa0b2ecde8e6137c4268bf7bbe3bd7c224d73d4ea78513929efeb8c1899ca69bedf4fd0035f611cd26c4765b13f288e23098ddb067fa514aa6b842f806b5b2cc8ba68303426becf85d208ddf8201f00399b71293fd9c60880db808da6c52974d0fef7b672a22117aad722ef18581725e6062b5df104dd4a0de0ce58376e54d20dcccf8391c3e2d7c2254bae0948a970e01cc7b474bc08277af64819bb4934e67c496f313db62cd0192fe588b045fa716060f50c07e3938987353edad2af74f7ec79b7ff2d1088facc8e128b98344829057396ea7de1464de140a6975a2ba5a7fb90d7fce9dc04818c78d15f733c1905870025544ffedd2952eb559ec392c2716e4ede87744447f9cf50f065c61a65bc2bbaf25ee675d58507edff28c36e4d41d52b7c9d627cd499394dc33adb1d06c9eb07124c95844e280f16dce99230cc79d2f53fa726926af6d08f3522f40c821035e01f469909244652a9bdb7b21fbe5e347f87a77529eb9547c49a975d44ac400fc53132ecb19b60b0d3c9e28e8eb62f7b65e7a60cf960fe515f7a8407d5c8f5e2df99ab258f7c362dda781a44c66165e15844d24fb519756786f52d5f73ba22c8d714ae46f77e5d6e082637f920955f774f7185fbdecd8144109d31a814e54eecac7365f6c0379635513845d98d0ce1d56e43e120e44c683a18762ba92f75be21da22cd6d876e0bee793b44b74ef1a46a9ca0a6ca67f4a84bf60fcf4c7f3e0a44fec356742da0969dc16f47df5043eb408cb1edd1a0124eaf5d2000a0844e13310a39b06a185b5794b9363f2ce1c3f6e68cdb268d43661fd812096c11791c319bcbbaee230e34c7d8f55575af1ba6cbc64b46731a57197937a56ea996d90238d14f4fd650e2fc53b28b82597c07771a7c3de3460619629047300545f4bb4d9fff253818640298466527ecc6f54d2ce67aadec8ba1505d884dc7f814a7a293af3b953f32db80379e6a256440aaa42a3e275129840afd7e8f1d23ca85dd3b75569a96d5bc3c157df4698bbb4d25d89140af4ac309a71ad36ebfc579fc25d398ddebe25a7731d331b3f93ed1d5bda48b1e02fad9cbbf73db5a9791d624d0bfea18321d2cd898a21fd9280edfaa416599716c029b01d0bfea7fb3b7d1af80389408a889d08257a5683952f40ba6032f5adf364d01b0770d498fe3ef230274b4aac7fe95a008965f688d54f8e5f13aa1f4a1461840dc528c36035c106518b9e6c9c70eb4ed08043e415670d1c21e922ba622dc0c68206daf67e99d07839e1b8045a145da31317079f34fc8a0bf1cad35050df831df1a6f590012132e706c10453a895ede3fbd4d83e52c5c87a1d36519dedb4fa19ebe8252958c452b4587cbc21a6f645eb1c80080ffb07591909210f95a89a837d80c126968f0c6b214cc6308a03cea9eb31d6e474ebd561e91f76ba9730cf8a1eea02d1fd491863e8b48d7d3afffdeccffa03c45f6bd8414394cb11030d587c80d6ea10c68ae45a43176432424ccf594de3ccc32e46dba2a83adaef935b615662149ea592a106f4c733465c96c766896ea004d5f1acb6b083836b5c0645f52afa9c7c2488d5265ec2756bda09392c22551d636a1d7b7a9fc7e69aa3af20b44cba0033994b8326f831310818ce15a7c10c7fdc8b4dc3a38d2ab0087a4133f415457f31556409a30ea0240bf204f4fdf6c8f584062e7eddbc0c33e247d846a49e44fdc9594964b821676e67a7990f5f1eb0da094b47d0565e4c9670081e777905d4e9b910873fff02e98d76f840c3bd927865c7eb2ad70e33cf3bef7a505b59e2630e7e310cd1bcca82a85c29bfe0de170ad9358b2de3ff0851556682ac4158a2ba02cc7cfb8cdde7edfc75368e09f29c5e914eca441037f543cdc0439b715ed41ad1efbca061423a371762dd33fe77e965c80c5c18218845cfdeccaf5453e6a0d96723d4343318f013d8ec29bb91c1465fd904a9fba90d3396595d336fde1f7f6691724d176755d896392d71423308206b500b406498fe40f140bfefaf215f067ab044e2ce2f9929782101bc0480ac538d3700d4c32bae4b4b6bff67d951db3227594f93204f5d240c9fde2e2c96d347b0d7c97b277a479fe1008c713961a7276ff268479efb781c4de2bea7ff02a0d8058ea50a7d0dc054a27ce596d509b1212129626e51d560f74052eaa4663006ecf7fdda08da29c59115322e0337157c57154d1e5ff1ac936a541e326be14a0ae4a4ec7800dcb85583918bc60c6a92072713d619a1e44f7daaa9bec4b60eaca724d75b5fddd969a633810d404bbf880131fcd0056ab0398b276ed19e530332c6451b09232a8966b51361eb2f8b68cde461dd0d3e68b2efaa2a80bf6e533db6b253a7476c0d6b7fca4e77cd30378cd8f79af41c90a1ed2c3601411956a5ec3450d7b27512cda3dad01c50bdb8575dfb444ff94590a85d0a08a5227ed975d4296df31e1ac9a7b16d85eb43d77ccad77c132b8479126a7c8936e1c89995a04f2477d0ffad19d185a15daa90a00ef76ed645cea5ed4f6eafdf1b447c4a333d540f1ba9140296bd274afcbff7ba7659b54db2188cf7308ee1b8bfb769d27c208e68b61f2052cc3c6f434908c61e341cd46ded97339b1fe12d632043ccedd1abd14d79f242a1721357d2798fe4651c61e9eceed79c003a05c15cf0180d2b62da6b1ff3a01bf24865c68332e3ddc0f6b1ccc933cd237eb2f30221a8d3c10485c378d2410171e739773263046c9210f1bc2d6c0273093bc943fe3293f62a4c88c5d4dd1bd00e6bef866e3a1d8b6dab40f66a28cb6afafb0541f8c1b5986516ec4cdc7f8063efe2594d226e2631280bde3060c4f7c50263a65c3ffa8f3c3b73d984dcb53e02261ba226f7a2040f02627518feaa2607f60843d784da527a0d41d41252c6a5ee834f89eaa37d506d6f2a507c714deb4bbf09f7c7b03efe8799ba6fdf4dbe49b47d9c78794c256770001837b6eb89532715031e00d43374f5dfdb0a1258ae76e8c756ce4ec65c472cca9e87a9473a7a149081bcebbaf5fd3db0d699dac924c592266326bf987fb084291a061d17c16c00b0d5e95ce8e9f0c9647b377fb5f7d1dd6b445c8508bd68f4a7f2205f692cfde4d94d9aeaf0f3cd3e9f3691471a07d42befed43e40ec34db66c10c39808c1dcca12fcbd972bd93757680b52c687d6b55c2926cbb55810d23a6494ca0a5c59ead408a70b2990b839d4e55044c613e9c8073248867e0dd4480517ddff2b204381615d512b4b3e81c2f56caad9972d9066d08e4077dc85b45f6c52c6a2d4e7c2966375a4cee06676484aa53a2e821d068187011b6cc668ab9f7110a31ce09ed7c4afc3177bae4e6a9fd64092d34b5c3f9907371839b8dd5fcd240766d9428da5599cba0e639723cb7fc0b56e46dd1dcf3ffeb6dcf53525a36750e65d39125cc975d74a678718ac4d9130dfb13f333e5a52cc98666ded0b4fbff53e1c302fbcb456ee6a0c7ffaf2019871807b67f06618f15527400cb80f17ce789b74f80ec88e7d2a63a1fb64cc334f77397064c6fbcb9c44ea2c6e2af0aedc06ad4c1b5fd5f4aa41b3859c9cbc30fe08befc139556120210d1b76b18a38f832d16fa871e7dec2ebd325b0b096684024972345417aab1f75aba4bc993b79e2391c399c72aba0d3be7cccd15343bae439a636a4f2eb01080425dd655042a714f3ee6dac8549c41ca5c7794bc15b7351c11a2d78223bfdfe3bb49137455557aa51e69de108e8cbcf82f11ab8eb8b82f2cc4f8e508676860af215e203333f9b57a3e4e5ff899d75df58589aac4fd51a18e20c53d73843ecb229bc27c704beb8f5bf027ad9a13817312f4d019b2444406726a6ce66c7a4f282ef5af372e4bf5424a682608106acfbf62d6a00b28bdddcde433a7b6bd435ddb4373400ee649d71f03c3e43c36308877c7e7480c6736673e006e55d2aaf489275e27fe87afc85eb64e839da2477463e19230aa599ca6a9a1c6940af4cd5c51703f6c10af5b2e063ec6866fa7f3e1afa17c3243b0c5f6f75141636441f091eff3045ddbd7e21eeec58b815675e44798f5e9af9727a9d03085922eb9b59018d4235f55da1a2b4182478ca2723f0137c11f6dab3a6f627afbf76962e8386b92bf3a7b9a3f1a3f01173a9dff5852c4ad1df33aab57b873c927ee5ff9a854f08c7f91485161362eed8638f16dcfe4fcb295564bd18768e7234d3cd17a328c65312db4679262ab6aab2e52a29b9c10da6c542f46d505b360b46b41b2d0e53cfd178dd284146d7a71b6d2e7a6bdf3c6166cf0f8797f7441f36e5aebaa374fc1fbd75f48c325879ffc5528bee9fa82b3b1f7ce484209a668aca0981bbb06365b9d44afa96c623730a61d3992de25c5fc03593ab8bc5ad4e966a97f888cb027aefe8ae3556dd91e19303f9544bba886ebd630eb75ef36b0b685d83d53c540bbb9c0e4b003729f9a0d3bed163b3ac5bf94c8b7698daa652d83da3f52b79fb1965f656d70f8183a6dfa4f05eef4443ebfd9b4bd663a9a45a011cd628766982b0bcb22134455388c34f85d81885b5f962fdefbbb05c61d693382e6ccb6e6a0342107f6ba0a45a5a56459b0da1990a15523545914cd9c1233895c21143ff4910a60439aaf8f5f357772f41ccf03b55fccf342d82eb970b8999cab4dd4c29c4a4723e36eb716ba98630da53c6a691c3785860f8f0dd84359ea2af8d202cb6fcbed5c038167c2fdfbb7bb75e1fb8427b9b856a52c4ee3322248f61b484368d933b66454a2bfc5084a441a87cc378abed5b52a8798b5a3447a66fa3b279f184ddd7cb282369abf58c5da860cd84c6d3a6873344ca4ceac189441520b0fd1a53aa64ca385bdec484eb73b0015bdb3e1e85106ba15375df13c0459b64f6201289d06c6d3cf1a39b648c31e961d7461dfc5deddcfd77f54fcc6f1f84010b4d4ccb0d6529dffff1ac4fc2723819cc932e0b147f1245b69d6a907d5507ac1efe8c248dc75bb17dcc8ca7f13788aeccd131bf740d73a55287350783988bdf4123ff5a6a1a2b0d267751c33fd31b4a1e2777a52e1985864d72996ea9de03e23518b8c636929099f8ea536001d4f34138cf00703520649b0870b60a1a4498ca37f597eed9d18fb9ee84ebf570244c4ff9ef2180528ffa38be393616e3dfabb1d4ec1b335b25ca099269f699cc96b21ffa4f4155543b4aa796b4f3d8573a8e806b432601ca13165afedbf481e3151de822427ae075facb8d10fcd87a719285c02c720cb94e04698752b01873c79f8560188b474eba325174e10f40c7051bea3de27c059285447e915a835e0284b2ece8d03b2cda16df8078089b77bcb926c754ddd0ea82f3c83becad341ff54fdb9d37725ca3d6d6c06b9ac28f032945e48d4c7d20456119991bde35c2c3965791a4e3c4feca02af95be5c497ef9c905dda81bb3d1fea6223f4e31061af6cb06a83c09c4ad2ac6f0042f9db298c737f897610941c4a4325d8e5c6977aa56b3e8371d1651658cbbf90da0e1c9a40ee4189670992ab96483158b0a27924d22fc535a2c2fc52429c6cfcdb46f6e76c9818dee7f90876adc42fc8ff54e50e76bcc29b4f4c0d23b73889cbb21c7b5a01c56f9f975189443cfefc375f44b47d8d9e32d2df766f32917198802a26d4af695c47d2cb4a90107d35ba1b4cf4af2657fb04e2e4f3f1231e6d1f99ad226bcbc9750042e356f69abd11b2ad0b726fae098c81e233fb0023971abe5785d7c1c0c0150aaf194520d342ec15e325f93d3155d610dc86912d80bcfd91d5af78afe45022a8d49b30990242ec6a7d681c2c2e75cd010a7823b413aa1453b79c36341215abed0e4d4ab8cae0df00d7eadd79cc2c9fcc7e08e8b8b0af94dfa7494ff034d9f395c17ff4cda067c6da5147e827220971bd5ec4c08a0fe02278ad4e62af5630380c8af66f2ef880ddff457bd5d95c13dda92ec8e9477be7ca14de02cf5bc8e6371e02cf18805f46e1ca9e9cfa9c393151f926a363ad378f298e36eefaed4e6d7e1c31977c280a21a79ce03a66edef6d97b6c677459a065fd6b24e4a6986054086c6cce1bbc637746f6e1357f9429237d953c509e1312e269b5d1ef6ad05d1fe5905c95619b62b8d53d6b1fc3ace04a1082e9249ab955dc723ec1830c26ddf47a1ad9f3f5101a5c3fdd6e4e5516f4fd6b7cfc60359411de425de7cf403b339891f9eb9871f6485442a40a2d9372bdbc756ad3dc7e2439882370800ed673312436b63928aacd8caa4973cd40ce5c48c715f6d176bf104cece8762ec2c020c0a434aa6f542f053f5fa4e59ae4d73622892a987cfe9eb556b69236298dd6d1895a43076b79560dedc2e007bcda6a3d18296f6fdfd8c8323672dcb4b1c41203002ed52649d0b1affb2a8e193e700e1eaccc1a0451dc7323439cf534c603b6b921546f3db8d366c0efbc02eca9556b4725b52af99b535e3173e4fd20f4b0829ac1f4e47ada3f7c8096149d79e7538e9a5b6e500860c7f3e742cf25e73d1b11b86eae4b88ae4671a7375d5ee25b6e79fafb9abf2f5aba1ec0ded5e72653a196f85131bd41901f3fe1af0e054451646710685e7bf87e26788780aca545d8d692216d280fe5d4e50cc3faac08b1e43eb474db9f1d41ae81125a6904cbf4a19602c25c5c03d0cba05996b80101753846a8b72337a8bd05e57653acf6f695f598634172e4a06012a8f7c67d190a4b2bac1ed79c6647db99a84a74217688a34f64852997c4e02d65dc37a135e94df799fcaa6cd32a74fe1f952036a17e988aad11b984fe53ba20c95a81f6d2f18b2f96f1ef738bb737ad2010207fa518411cdbc092f33bef61ea7539a387f59447e9e8a45a9c22fc946f6db150fdd23d2be29e6a535c228612b02d2fa54782d89eef9f5fba6bce83a6329f800f50a8563cbfaf841b5f88becbb6a3d73299b553c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
