<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"857be89cb9a20f9a50a5f7bf0427d4a2900d6f7a69ef14aeff17426d2a836259f52be5ae2500c02ab61e0567595400d29a3b85282c21f534034ac4d57322673b68d31cc1cd0437bea1273e67778ade82ef5a4f2097e05eaec2a694d814c42210d489b6e55f450f1730984a4f132621a0fdba91665c3d6c7051e45e1e0361661fd69bcbd9e0fc0b46a35f76ac43ed4bfdbe599c7df7ea7b36c87c0e1ccb610cf4e87684f5141bbbd5c79e33aed85e689769ddcabf79ca88e4f9a9de09b0b49ad69bd8c7122f1f7a26d8369e6026d9867ee64ec28c884b881132a4e8c11a933a37ad2b5906b72d769c8723194ca86d82df83f19c624ad216adeaafa7e5b73fd496d3b655dab456c5dc6d4c1d1b221f4ea7be9bf429ee9b129d28db3ce7c82b1849ea25d42bbfd6d31f9baa538383d6a84e9dc7daddd55d5c678626dfde233a6e9309840c9b43b14c7a0e547c7f18b60bbfc19f906b9ad50a23b9cd6323771545006f4014f0db719e4da0b70f69ca68aa1fcffa65f0aef7289d8b6816746ca13d30d0ac66942ee482a1a3f5fbc7ac24bd8b9fa5f5746dbf35e9b46d8b17a1f6e173da34f38f35b650b71003a33802caacb7e726a505cc79b038fd61dc37c878fb357c2bd11ca921ecb8efbab00cb3ceb79ddd424cae4b820e5e9f81c0b4bc0ce06320520a84a3ad04271f75f2d1aa0929d006668a012c1f20cc2f1869bbdf56a5ad681b468197d3d56de737e813d331f89a8a89ea3c05b1119a94669ea56e19eab741a40f37b9ea86fce0ce74dc4561b0991a1fb0557e8c78b08ce53ac8d0e2267840860f471ae966c819d474ffe5490d8c88cc4859d94e1860f585e03e3ddd2d5c5a8139521b7bfa6458efee2fc9b6b767aa73fe3a944a8012fdef6991690ef4df1f209ca5bb5d3f6553de52c5557b5ec45530e2905c2d55028cde0761d143f834abe7cd7fc6b0d0fe4bf31975d99034826d4236b65561e4d04017d766bbd871e2162bdbe6947ace92fd21979ff169a4946911acd5b0bc080d5a7c4d66448bea151ec366f81dc2059fde8df80262639181cbae88c71d8fa0e0fb3626043cd1868f129ab5a190601fc1b07c8360db86cf52d2020cd460f5ada405052a619688dcc5a6181ff0451210896dd70bf3f459f117ca3d9692a2136124514a13d0d2a1108c1c7beaa0c1030e7626a8873bd9b970180000bf74b5d0264e50b2e7b69d336323668fd253b102f35ce77c02b64c5ed22869dd0513467bd06e8a2929f23c07223f4ae34a6664dd16301c169fa729a4b8e725e400674ed02429e795fa1a414b75eb23fa99a1970ca7c5f134467727365456b7a478d4452a1fac36ff02be125aa9faa0ed4edf5df7906da04207358cee6e6cbb301c0c9b78cdff7482678d9703ba48469eb6334c2ca1cebf830d04d72bc5bd6a03eef53054c9cd4846915e84d757006b1e922f3371c4e0af0a448955864026858b38aea8c09f04e52b2287b6e3ee252bf3aa32de18ca8f935f30aa3d58b0fb5d1228f1cb45ba3d3268f10ea9003485632692c2befaf140e8ac14dae0eabf2d53fdc7674e1fda326c80bc0af900be50f866cfbe3e26b2b29301d5adaf3fda8049b366b615facdd473ec9df3c5f362c318ceb064cf0c9399f4d29ae655ab5f1d96d72a85f76c20d9b91157afa346beb1a3bc7a931f2e2be0682ab52aa7229822575fa74c947d0a49b669a561bba7bac4311f4d4f17d31aadad044d5361d780057cc47ce404108e3c7880263828c7c0b717ad35e9132afb004e9f8d7ca97d0c29c08e38c386e2a3a8537057c9bb3f51e69c3ccc3dea29b95af1110fa4ea62dc229ce91b6e76ed452cd5bc42e5a7a45aa67b765f5330c9e3affec0514e3912e315eb7b96b6cfbdb8d4a0164802814ed926f6a9fc5d2d6d5432e7971ca0da41bd5d2649a2d123bf1d0c494214643806621a52c9237c2f86a69ea2095052441c055ae04eae843a954673aeed8401a1e84a5bf5453ae10a3fe5a213069fd2303343be68a4bccb0c19978e94e41a18490346d02063b9e727397ac440fdc6b908fc737b250aa6c4d22551e5a4ee11627ecf2e56dfeaa21a22213873b12ce838107df8e8058493a5b79ea4ca6b7d01295973afca1fb35e1c56f9447413512a800799f096e007814c24e57acd52d9bd7e632795a48820440c329a9e33e655cbb01d40f0e62a9e237d798678c2253acdc49d961e9b49d62e43a8a275ef8c7d66fb3e9f56a231b871b3e8abfd79e2ef95944daf11c7f587a4da1e9066f026f0f0c3dba0be2747bbef99ec5e87273c03747887da84eac8ebb2f8b6f0e9c1fa1114ce8e00ab1a98c93b8866e78b5ed1cce4c2f418adb372c117270b07847fd44ebc5933bf1d749b4ee03de3aa231cf36754a23f47ce058816f1900c92c6142a85ced38f23de6e794e1de4d7854578bdc2b348dc7a25c39e836b780702510f8585e2ffcb5c36a7c544380e95dff25722769dfcb5c3e4be381e92f2388e4d36b4a58a3c8794bd5845bbccaf180022050b9aaa3da1061838eec9e8a17d38a3bc1b695b9b99173c741bb3bd2801494e2804b98bfc05b3fced8db0d8964aef8525a48e6e8a2c86bc3a76e71135b546b4380c5788857bd0f7aa076bc2dc0711c805e750d00fb9c8ebf7162c842157ad056ac71ed7a5ae46cd3f0ba5a40f39c5ec0938bfcb6b497da6a128d0d56826f99d1b1c5d55180c211a74647a3678d431af2c068d7416d1c8bcc90af1ebcc44683a4a1264ef81c3234ce8b587081eb4010ebda1aa6c487a251d27a33c9b82381fbceed9b2123fd82d768485e34ed9813bffbe37d9dd1daf5a59b7739f691096e5f39b8e2f4f39706c49a70a62a41419d065fe46eb4150264d5234618a596f8cc9fb1edd2baa953a29a4fbd23ae80565a969f750c7f91ed6d2cfb1778788f7199b410dc8bf9b6af19b76cfcc7cf290b9c6f893a35ce522471a6de55305fd19d2adef45a9d5bd0b9242141856b03fe7c6143f57e90581f1190c07023a79102c6f661bbb3389637c3a0241bafdbe3eeeec224e75ef50a125d7834f7ce1705b6ff0fd79df126f033dfaa34f640edd4326249bdb6014105beadb93e743d31aa154de90335b61f6c311790ff3c16fe58a10e04a86d7f6da25db4c3d1484055f2506ce6f2a622ac7a3488f61eb7c7830cf55119dde464f401d89930a96f5ab912cb67f6998e9a1360e3c8672a04306c3670b207c367a64cd264ff03b379d067c5fa5103a435b313f5ccc1bd9f865a85e5d54a5f225da399fa2a211e2d6ebb431d7878873efe8263299c1a51c456929bb2b8a86cf58b355895e2fab2f8cf16d35892470e2146fae394952920e35f37fa473769b3c84e6b68f2e524934d6eca8a3667259246e709f5392555f9d0ebb266cb7d21a61b06ef8d45cef84f3388b0c717808279743f0baa5d0281c1a0b66533de07ca75b963200586effe494ab65a58063a5d7c538eeff1de7a9f5f7bc50c4699d0aa19c6b9662600c09b0563d4375fbb4ea3e66559bcc699af8a4eeeb78caae00f3dc7eabdbdf3f3ce7ca9f0799f4e1a1c511037437361615fa30b4e5aeb3a1210aaae827904cf6ba15e4a7d33855006555d7c9dcd41b9b03bb4fb316379a57d03897f0fe6fb8460b05263cb1a249338935961da9e119ea062770b245751337a3568e93f88b5d9796a598de96c73ba6c48d5395a01491e30ab54275f75d9884e3bff2f1e71554211e92739e32af5ca6b42f2ddbffea4bcf3cffb80b1582ad2ad68b241a1f3d5838e347367e6858e378e55068f3a5f85c8ec0434f1b4802d6f83166e410814ec04fa688c0582c0e257c2c4db5732e2dd3f810f3833c3c6fe3368452deacdec41427a5cff7b43cbed7001fed5d80145308f7f9ac183f9210c7d053b10b8f4944f556b9621df1b6880a81762f1a38a1e42c32f1c21ea76ca8484ea3abbc6cefd2279c3334769c6f5e590eeef5197ae529da636fbee23e3bd9323d8151c3f2faaccd2a1039b083d7682cddcc83df8749b918e066d136149ce8b8db99bdb4fee6c104a391f466e400df47be14b7365c5b6d30b06f5f3925ba3996eb4ef4f20be7ea546917db742d6b6f354b4e151e9ea0d9ba0326e185d97e7f324634843f3ae7f160b39720973d7dfe83fe839b8773abac0e3c0d2a810b52444b4e06e084a7b084fd9fa425273208335a7d245fd91aec3929ad09caf566714f270af4543f905e720f1876d61fea6effb1e6cdb1850ea94e4705a8bca63be025c5cf2b621ac5062c2be33b160a53021f0898361d62fce3319c1f126427d8c6ce9c9a86c51119d22c1f42be42d1c98d0fad31ab8fb104c8cb6cc6b719ed2fe8157f714217563d9af4758952cb5aa981743a95dc07298727fe1fa0e54ee14b95d2e34bf373ed61d3b0c787942365a2897181b84ea6c7b325b52e5cf6a3554dc8c1034d1d88104b0e8c8f40c7db7bec3e5875401ec82a4bb35f06e4d850ed1c7cf5d2c377cf61c7631ce1e1e8ff89949e21e575d06d77f52b0673e9246389aac0ce928a5090f0f993132f8a1c82f08e5cc34a2f1b061523af94ca678d445706b1fa792125f9b89e68ecfd2d30f2b80e32ec8f238063e1787475ce947a163f97941e5930c0fc265af297422199bd32181f26c961bb0f5296e23158f925c178f2dd568825c66d7093aa0cf12b612f0f5e82a3c13de75dcc7778d9589ecf9c75917558c703deb2c89aaf6881dcfd0528f021cda6ea765039d53120e9c3ee95be14353c6077c964c493cf4706593ed2aa491db38cc707ff4b284784e64a2015c2891c2942be93570611e304a7d639cc43bed87af892ddce296e040f7147a8862c95276a4c514fee23c35e90c664ba8dc1e7557d1f306b4d70a516c930290fdb59d0e7374a4ad383b531aca100afc7b7a4fe30eda9032e3afa8f6be11720b781de8ffee886a8fbefa05595a8c9990878368a1248a8faec30e2d6e456e07c15b0bdacbf9800756303ffd488cfee88c21d1b060b9f95f48f7da6dc79af7bd0091dcd14c85b44102a8a4b7ce833ead247d4021d644e9651eba0b709079e7d2f4b8ad118b3d4c5b50f037dff7dd6bf831468be560fff3c4c891700c7ddd11278f6f26631e03872d673bb6b16c59b6ab046bb5f198de1aa2ca85ea924f626d93f79514f29aca6d394d8a7f92fba38db302f2e52c208c9b1832fa0d786d97058446216d67b73018d4b6321d0385841139adf5e097a31d95f2263cbd762ee7b6434878bd3a036f325c0ac67b6ee7c54cab5f74ec04901a87546cbbde236e867024940895e42cb7e4b0b2442360b682eac8f44b7c9322cd901fe2dab43497a9014689090e972fd4b4504680278d502f0199725dd035d8379ebcab10fe5cc9c8e8565e325833889b9ed3c5ca2efec47eae4a49ee61b498440ac29a7723c820b7db06432a9577bcc30bed18dc2c0d5a10e8620e0b9fdefcb3e9e6632c135025d247462eeae2885bd9afee3dbd508cf04c8111d3abac8e3c4272908b9a912abf1760250cffccdd8753386b53b449f698ac3f11332fa52a690dca5bb9344181eb06d4bdb9b9e9ae59affdc47fa5c1dbf5d1a88a61e48223951756004a65ab13b2c3d76be82b89ee1582d15e6ae0e8a020dcc58f4a0d4964d99ad7480cf2cc1c6b920b8f82e2b184b75acb951838add78698b4cbfafae5c901b0a1ebe57976cbc67726b5286772d46eda0e9f9fbff8db7213ed165f724b767953e79a4f37cf8599ecc76480c4c457d64c10adeea58089a0213e09f8b2d00e166351323b619127d8e72f34bd056cc08b1156e5feee6344ce1fa789d954017e66d2df5b5d3c1b2bf4b11d83a998ffc98c78eae1f4a2f7e820146bd772de0d0b52cc22b903f1f5e319bc64cd192c79cdd0fa2bb1cd9a722997f778363c2117cb06c99a93eac4a71d72426a79a078753bac5a94789efce1aa98e7806970ebceb9f35b7e6bd52f94db07b1cf5dc8f28310fb5b49c837e96de232d0bb5b248673c0e6ffcd41a0cf8a0cf0d0e0bf5e65042259a6e29f2be190a78e8f7722c5e6a17ad06b28be4a16c8f97dd2d6e87e72c9f7e5ec9cbd7eb071124959c1c1c013645be1e5ad393e543b1dc210129fbdb28563e11f97a13bacaeba31f0b15a45566a2acf8c3e07908d792368c55e70261a3c08b021e6078469891d64024be30b1b3c62171df974855f9e286183e47ce5424b4170fedd5498c22d1ed0130b2b396b6244571b439752cbd403d6b479577edb2330bf0aed1cf56f854615ab04b58c7272c65017e6102275240fede09eaf3273055d9a666ce8db6be741576a888e09786a6c64aba6e8c60785c1745dd8da49781b2e74cd03395f92c02a0df3c9d575e4a9c8cdd3d7bdc3eb85b98c474a62cf34a6fc874588b6f7ef39d1e44ec7474785f2c7675782f0ab3ecb151d5dae8e39188e79b9df7d3d57650b715ee945295ce11f7533e6b0094d46719677fd6214a5f303fdf3d87655463440bb60ab36f8115e2cb959a6d71988814c29e502b3da90ca51ce8c4f202f0e1227e114ad3a2ca694490c7e3cf71c3eca6c8499d0072da1eed9efaaadb6bd6168f922e15fedd145dbcd3b1948bf1a27c8952e32dcfea5a1c2fa9fa00c99855fb1a80d6d033f218f204b82996de418ac182c072a7e25b8fb1a94d36d02a7cf16245bb70161c4291c0c3908b6717ac2a2c2ff1e943306dc4e7da1821adf8c8b9bd036600905240fc426c7460694c90d00f0a68a41d90b5c572e63d188cf37bac5e74c59e508df47d1a21e58115994970b920de8b36ac85e8f6e82034453b28afc14403a5d56b845d03cf8aefa6990fd23ddf848068dd56d49c2330bacef95844a5e392ceb9a53e0e0105e60eb1bd050d861828157bbc585962a1297861d957ab8759110d99fb692ed6e4f98b3dc2aaaa6b9f0ad9484fc3f3c2c70c097989e141fccd68ff127a47bd8aebd3ce3fb987ed511b6125cff8a45e8d182d69bfb54139bf8cf2a779092da6433e873142a60320dab3f5c5299c307cf1b17817cd73d8ee670573454ff8f29d25d7f1f089b5ebcdaaea61bad4819944f3e112ec6808e5dc199848fae103980f31f92a2cfe8fddbd3d477ba340dbba95a841c2bda602f12d1257116f17071936618b2fd1e6e571d6f3d8e92e131b173a84a534988b6ba7d42297435ffc1b318553c121dc2c2e6893ff39794be78a7e14d185db67b25f4573ea498355aa346272df72fa56599a7ffb58449733c40a76c0a02bb17121120cdb9ef5f460cee218c25d1bda1092ba4a51c5303f0908928dbd9271aa33633bf71682e50d7284ab277ff72f5d7b1443e9d07684042d2a1a8d512e8a306494758d5c1c7044f760a5962b258ed44d2c7ca71d04508a0c72c160d1a02c1b84fdd5a5fde9f8b88aa33b37dc7923b34f4e3ff6fa8628ef8f91b8570bc21b536ac6e887a960745198a28d3798b1e8e59364309bae158b85a56109d262d0e4e99b9f4c45e47cb00b0a1bb90f2a2c65cc81899ca3264116d39dc79ea0094c1a123f95e0d27137b9c3a6aaa53c87464e6c7d8fada627af23c67cb65f1bc4e83f7af29d1370140c9b20f24dc38b5975d767d1da3a99534761b28c2948e98a64a13b83d6c4411064af2eb3607c559fecd5b392c88cab618ff3ab15c8361223ef9b2cc0bf6429f45c3805a01fbc54eec36cf26ab7c98618145d73ef49e117203611d5b6e23650433b65bc8b3e1c38341dffa7999a51410b88ed680193956230534acf78af16c343c85d39ee3dde613db2fa66a59e645c4cc3ffa5c51d5be2cc58d847aa2886ec47744cbeab88dab548958ecb0c83ef1a7e0212da97d7334d94b2f22fc4142dc4c2f289120d3a8052d2572e823fb42c6b865c7f6d0b171fb62a267ccc560bb0e61ebd2339779bf7f88a20fc2c539263f96d2a1cfd949dccecfe54b46110aa01b478f65c846ba60184a2586ed56065b21204c031aa0e7ffd8066734b7424ab542e978fee6d23f855d4b4cf2d2fd8b6a3bb9959728ed32cc8e321b1e375992f73e20107665df8dec2517f720585fd03d4fc6a826d3ddd69265637407bd94d991ef26d1abf7ea6bf8fdbcdc849954ccf9f12700fba20351662bdbecacd5438da7693c7bbb913839da9cb87de6397921bd5e0bf2abb412aa2faafcbbb7de419cfe8797465546538e29551da8ec940dd72b194832b17609b61582622633746f02b0526a36f5fe66054e2ef529b6f5a1f242d9769e02d398b34e82a3f8fb6cf0d4d0dac6afbb358fd8bc3cb9fea3fdac0be90eb6b86b8c882aee1606caa0063306cb6db24e062286b0d8904df13f10e7c929b292cc6323eb062729c9f4dc7411cd84e8812bfc13297c58ca38184d47b042d1636369331888d615613d81b98887866385bc49169b500ea75038dac0f4f33b038220aa8335befd526d3f136cb63af092e6a6c3bcaa9233bf00681ed393f7f1d49d52dceb0860fcdbda64fd988853d5a725c8e2c2a2afa9fea89c354fb004ba4fbf4230a0d1a782e768b89c41df05b84de47fec0cd8e117caf4352b23d4274b2e877d2b9afb58f74d0bd211469b4cf4aa0f29553529cc6dc81bc036362a3953d73bebcb6318b485a29daa9a2d3fd0dd2a50a76c46b9cc4b9bb0ea1027a79ef20862df92a9fcc83f42a532f4025dfdad4155461fefd42ba5a1d67ad6e40dd6363f8fdc985ec921992afcab686b7011b2111839cf13adef124d32fb367499f817bfcfa35efd19de2ddcb5d2ee27bd0626b0687662aaf44b77a48baa0465e161548ce346d326bbfc6263e6bb8fcf3af547fe605c7a28beda384de3de8eae8998a0f64fa29af3d13f1c22f51c365e01aa1dd5163e3b30e33dbb5037033839cd9e470a430a2b171982f6100bb5e389913e11cef1360964ce7e7d844bb830ddf505769fbf2784c511724e499ad4cd38c4924382713d931b94a7718eec6714a67a0af0d2220e82e2b005f1dbb87b13c4644f5c5b5441b400de8aac87ef8f53fb3c86cdaf4f9e618f1d2cabfabadf6d853973dba9b4040f5e1e1c327cd67e508be4a065c00796f49cc458f630fc3f1bb9a6263932b5409e519ab2c88c1c5d68757e125a628d595800a392f1a0bd1678fe2b9441fc82cc1c5207534637146720b4d4de0fccdc2b0367f70f0525edeb272de5748f79f6a88d956c29c52cc5650b2bca0c6de85b8e5daa26f72f97c3320302abf103cc4c9e892275bc5981ea3dc17c9b0b9ab7c7eb1bd70865948ece0f5d10b3de0718e608928ab41dab5d813e07703834b98e1a0ee00b4666f2d8a8beec45bfd00623daffc9530b85113bccb0e90172eeef6b729d3681f79f7f79ad2d9594245e0a3857ff066b1144c0526606634e3365dd08fbecbbab54686dcd61c4c31914d93e494cb04421c16ae91a32cf1dffe88e1a630f45e14c07412128e5ed3b9664b2c9b7ebfe7979b9dd4ea98f60e955dff65641815718aa397ba916568549af2c06b625fbf33d15384bde10c3beef13ad4edd929248951e8f3e9d2b887ad0a75444126053c42c774848e2ba6f5cc7951066ab269bc82944a86ad5b804885e95b6d15e05470f521fb43042c4a7805b87935c21b3e3317b727e92d6598c1676fa36fdadb6e4d23ccedbb7d58e6f79dc1258aa79c5a800207c4c6dd0822b54094f7bac5916cdf561e191a3275cbb96dd9e2aa0fbabc6117fc14788d9215c2680400457d708194fb44a90b748c40cc1a1d38ae4b8643cb68c28168fbb1a97310b975092fc03928ad68d8937cc57c968637bca399015ad852114a5f806f5e27f9067881bb7a58a8491665f8f60485af52000d8fda7bc3a513f7c29179f78603fd3f79514bc8c978b75121c0fa39170d6e4a489af9cf5367eedd5b5f92d764add0fa3618d39f297ef3342a96aeb9ead8d0ee52c603041bb8f2b619de6a1125520b6b7bb2c2928e361706cd2e37b5e96bf3008dfa01f7b7f3d43fbb081be54816ca7ccb98f435012c6639c6e8822b8164990f289d010f796a32b0503d6f1751a536f0a5f5668a3747160cbaaf9d7c4904008814515d0692b371b6a68f07948d0c9eed444f007c7da39dcbeb976f498034a2460a339fa59ae66ac7df2dbb636d4a4cbc617a2557d00db2002ea6728f900abdd38818db47cd8a7d28c8057fdbae444e893f8729274a75dcde6a1fed0d455dfc3ad8730fa092b64682dbd73e456654e439533008763c378630c8ed203980dbc762717bdc837bd164cfe89851c4136cc0eff2a16436a165e5c9b1c8effa11bcc4d554ad880c941b05e71f2a8863944b8b95101a1a351f5e868dc9a6e75e202a7330991906c8f268e81d21019396ad686a233019d0d7036574d0c10f4ec54eb82aa82470e14966bf66df7107064a64a7d3633107cd424c209c5f486518dd93bdaf554cfe38064b64430d46c0f1b846d80e7e04cc8d64b5a95fb57ee7fa1341edadf9dab111f65d2d84cb53fa49199a3d859e2d49928833a964addd7315d28e2306e577774d25457e8dc5b8864919ca12ce4050aad9a0c7470b5b592a201d0911c729b6a66f7c5bd795225ec996da85939cf4dd6b96fe5b5e62230882495af83a6999a99f54d594532f124366a1b9a468f2a4f08726a9c86982c983cd64c7e70641a9fbe072eb3af9b64366902eb52dda0823d079cb4572d47de0cb28d87f8a8b1ba535036795ac383ab7afbcc527aa48912772a78fd4bcd5196db899057e2147647d60447ac6f8044a339dcca12a91859368eec9035bce38bf502ba1dd4ccea503fa5f539b5bf44c01a4c94d503334cc315979b8301addcfd9964a8d32225abd23b2ca0710da65e76096da869ab5b3d5894409305e2efc2816c1abfae8e46a6d13715893e74f0c4651b973d307c506dbe86cde290a2e31ca793158d2c8e7ea1fc7b2ae5e94e9d349449dbce8339384b010162f12b781d9da6995125e9636cf5b1334c8266f169793979dca9874362baef300690f10e6bc574440085502de59f370b3368f00140399356ca55f4de4b632dbf41bc30af9247d2a27bc6669635f4e23def506de60b6faa2b13069b9a7e4134ffbfa6dfed6e7f333182f4e30d6dfd249533417239c1cfc861c6406864f93cb12c89cac2f3ed0837a26064912d8ffba467247faf12a4bc9b68077500135bda11841f82244e3b5405a23289019b9e1afa9807c6f9691766970c19d950070b0ed85d90f6475519934b9e1f8ed6235827d44a163195b904cbb6f763fd3a180f6e920defd0181efd3a891505679abf2483a75221341069c27054e4164ab13b5322279e203d317d2c16456475ae4032a0071fccec43cb1509c1139b0e312f55fb4ceb07cb7a98b08b76001fafa212095261b0c3c50898880633af768aeec78731ff5160f3c4bd54aa07a7f710b99cb059b9f1063819eb0a7d5882cdabb7f30de40276cc6def22cb17fcb586ff349480ea5be6333aadb2a0d60893a114f0dfb9b7f44e6d0528ce846b4a9362083cbd3e6dd292f88119dddb207d0d83fd1da38501537108d5ab8bfb00d11305ab753aa798606269b33dba156cdc9c4fd9aaaefffc2fd1cb72f1118385023d007f2b1c1b14d820c4758f8075b35a4e93d5f7db0af88523e62e0d5b49fab5f58d319d8581f65c19d3f76ef661bdbebcbe4a9f669e1ee3f5b13d54774f074a5e7d018ac630886f929deb1d8dede8d7a2468459132a5abd6fef945f9065fcb512c3183c25299ca6de153a758714d4dc9611222b6b4f03fd9e995123f0950a91c63d20da0c6045e3e60990dc9d4db488c266eca5451cbfd1e6b3e795ac88d6d1aaed3c062e0ef777d93fb39871f35499c62a11d87df0e25115d3c37384beac5ae8de02b62b520040c709221165b9be8b601245b92302e5eccc84e544a6cef97cc4bd91020077d34af9d1fc9d89e68818d667848e88f723d47c00255029cdaaf1027d7e42ae18ba8056f4b6a46583125030f6dac6e835e22fe33aadeecf0a1b0f19a5741eb97dcf072e250b1c97d185879f5eafe093028809176e3415dfce80fc6625995d804b2f3a01ffb515c869101387be0016ca1da82b498ce1fce15ace222550bb9a479decc4f8552b6c2d56a6ec8e608fc5ca54cbdc50db6115c62e3aff9f8f574636d323f376564a9bfc4b5b236a514862e8478fe5d951f5c31226435f97dcd1b76a35bcf62bd70ab8f357731aee1192dfec4c92b3e8319671acbf5c1cf5f36e4ba31e06cbdc1de99b595ef7b09e486f28fe1e416c34b8edf757628f0bae33dc5c9e9ff266ab4bd038c3903c457a313ae817888b42f7955e2475454ce8e2f9d3b2b34e1bffde8fafbd1b36ded066cb79fe7edda0d93941c22a371a2a28470be06fdef8d09b8d6efe1f7867e02e64519f2873e1e642f91c9002f7522be008d134ddec8709da20d98bdb364af27f24be0dd9366a15d4217720c1edd69b983c52f55e0c796ab6d5329936c23e2dbd282f1c8d7d19aea3995c1587b01d449bc587d96e35bba0fe5ab65a6b908ed4763ef2e2aee276c3644592a200a246ffebfc0497325e00cc1dce470780c4eaf10c864582fbcabcc4eee2bb87b909f021bfeec66c438df32124ecced28baaef6e0f874dac1e98879e92cafdb17201042a6ece7074a784475ca125cf822f6456c0f5b2fb1ef9798b17e9b0fbf5b3d99faf27ee23053ba0165f0428b5b6e48114b95a9972bb5fc693bd178296e37c06a6b6445316e53d16f9ee7029f438e275abd41e93541fee8689c8b421228939122fa2f981480e42d54236769ded0f3e44b205180c53b5926859be1efedd35e24e010cbcdadd35d311432f9b80ac8bec1ac02145035d8bc352db25867fe5507c725101151a6ce1b1b7071af67c99e27a0b372f9fbd44bc467f13b0aeb91234c06c2615b69fb5c55d6fd5ef3e323a9e295e4dc7910148577a080ea6096bc50736102f31ca187c9118911a0c42c665b9efafdff76af81457b512343b9fbd9c738a4b23ef0f37ec2558d64bf7dfffbcde7ed013fb09dbbbbdc4239e947b47edd152eb018b1b3750025819012696b5376893096b74001d6b506b13f149d387067a470947589246bfcc8d574eb32d2ebd9d1e326f83e9e71b1010b954c6ef06489fa3135f49bc9aef674f57af1bfbabb9a92eee19ed7e09aa4074f582ac123e6f152190751adf9440eab3d57b83d67e58e25bf354790bac03d0caedc3f11ad0b33b3cd5af0a991162860a9ed1faa5d9bec22153aebe962f1f20c557860c730a111783471e8acc745f4981e20a3c3f4f671781b97e10cf3d188af6c308bfcbdd2fefd70e3d433bfa1bfe3fb046af05c34488cc46c80531af3367576fa5111cc0ca93e4e8b2252291ef7f8ceea02c03e8bc8a22d8ecccd24442691fd1f76e82d5259d44e304c68e0b3b42a41b1883058ed95b780d383177d7f18da7d6b7810aae6fa07b158e045919052da5b53ac4129bfc0fbc41e0f5352a58d61bf39fe3f174107ea9d022a68591b77041450dfd8eae75ff5ca871252cb1cad055b6eff1dc7eaf339f9bd03bf0994f11f048d1792f897f4a65151e5e44e3d7ad72fc38ec019829202471be4e8e71c40a3b89896610300e548f925b6f8c44cd18aad1f64a09a83ff7d0857a32311312430ebe5111e9427ac2a4e8ea8219dd3bf132c648e076105cfba5d4dfc267d3bffc8c0d7b7c1fda0a811a4268c8067f5f75ddb47f59e8ddabb0338964f9730db7f63cf61f5b3deba5e1fb453082c20068f046dcbf3606d1eb8f8ffa3bc166a751561d80ed676224254c5d46126c6742cee7c629b4e1c932919e6cc7868d2bf2615afa33d4cb3ec8f890d476c9a76d9db3f8c0d70c134b489bf08adfdff19846bbf06d97ce19bb740608a0a3416ba3f2dfc6669574d9bfff271fb7a6b4aebb831f849b4f11c64e145dae10458fbd2c0a8fcc2dd5b479c95fa6c561b931cd27e16989b8bbdd1bd8217797786860395d96d9b01b0be3ae1c2f86a829e9c6c3068a804c1303ddeda10670e9fc214063f5492a17afacd63b6667835946522ee4f8a36a38e8f16ac91646bb9276406085f925bdbf0b01a4c7634b10c172f125746c602077ca834043198a5cb70a79c7f87c401244580e257f3fe4d24b4bb32d61c054053bab7e89882e7386d54c97b5ea78a57a71e2e985267c49bea1fa80619517dd8edf0de8a11b61a6ce602eb19697a8f49e55fce6afe5cb37706d18b4cabb9a945bcc76b1e91d00ec98bed68d882b3075a4739ca072410be52c65bb2d8675edc68acd5ce77115fd30be6412838b13370c793069682121a66c75d0e1573083843f021b23bd61cf406ee180bd328cc8752a2a40559dd1cef04223e18c8bf31b7f32814c03442e8d68fe4e92a707289e940427767b96d8045cf5e301ef575232722e11e15d8fb613d534012d62f3833f4a1b1bc4ab8cab0cee1a483f3c07b2a5d9e37f0d0198df506c54ca0c86da148566e7d05fe20c31b713e20bac0a53623ea678771f2e6e2e80c7dc97674768934d49bcc2adaa4959b7840483d0f71a7f68dd38f7b0d1c2128a6fac5daa61bf95e6691ad3aebdb7ce408ffaa74337d774dc8b7cf6fa6dcf563f0acaca1ae600ee084b877f0cc231f8e9aae4a6a8aaa94abf6ccab67ccee43d37fff3046d3afb5191a36afa59a0b2114f65ca935be8fdb40a12dad87289b624d1450c9c88903dcc15ffd229273176df207509db74778a31a72cc2c7b9882ef8c1787fb133d03fdab8bc7d120ce4a27280d7be94cc0dd3f9ce69396c91a99a4ed95502a246f95054442b711a83d7de1dadb300785bd04937f2e4b419f25bdffbe42b787ca9038b95e33014282e94799c1526de3210d0c3cf2908f125f8c8bc3a4b5c85e94d62c35e48bd7ec9ee7f70c52af3712a79ca957af8ab237baf478f0fcf546a84f33d768052a8043da110ba3d60a7249bed3e6f4e1c9c7d506047775fd4b214aedd5cbadcbf6097aa708346aab3046c3c00a9c59decbddd0561746c6b05063d2075d020ca8cd287c82df5136fc92cbce51ebcb0355a51e5588ab9b5dad2d3fcabed7a806d781663b814cdd09a68c0dfda2f9755f486852aac7a8c1b9f416d815cf780abe66ecb4bb598254e5e814bbc85720e1b4969354a20557b21e859578282dd9b90b7be6d3a936580e2886ecda8ddf7c94d5e0d8eb0e1dd94b21a2f37a79fc92b614b4706fbe1e9a25a1f13923e46665d7c889c379fd7620c7ee758f419a869193bb36829b95d2a0f39b008a007808e91e67ba5b3289742f7625c9eec716bb7726b20f0b89b5dbe3bd952e38cf9a3b5156323ae2d14d5ea2deb7132863ace2d0af793af64eb15163ddb12f70d34ee2800e8a56b268879d708bdc8519c939fbab92e0c980995aef1b264c928bcfbd0f4d1c067deb6faa4bc0f4978257f23407ec3940f347b710a48b0dc3efc2b12908118c00786527dbccf102f1830f60926c38d74d6a000496c37b81c0498949dfbab013d70bd2ba90a76f129490cb4b8971e5b8217b1bde1ea937fbc237143269c7ba9560d8bb9ef6a6c95caa13d56e8ef0583bfc805aafec7f509061e5da1bcf59469b9993b722e16e1ffacf885fc669df3a911010da71c5978855a814c20dc2fe900c3c8244d0d2566a8b21e42b5b5f04a2d7c8ec04f7306e13b966010363dd9013758072ff9f3e81dc4bd9a4c661f3e72611fea782dd6f0b1462553a999a15ef7849427aa0b8d6d505edb2894f6d622866117e5105cedc349908d4c797658c1febe03dd797e392937af917def7eb634479830258e114cb648869cc67db9f47113aad05313bb4c3e3302c66d1e9b7737d26f333fbd1094a59013f0e987763d6f4049fe1dda18ce09423777f08b422320696e7bed399e129a30732e9e2f659e67ab126f4d5f39c245638a7a769b1d7ef40c8b5c090a58bc7ba178e01b23043d9ae39053d720e8c6abd7307362e2671aacd729b74082c58db1c64298fbee53f0c537ea0da2063f9b4ed01aefed89134b0d97419f3ae129453e3dca57171eafb7db0c151b9f0d0c3bc9138d8d80ea0a243a55231845e4d7a2c07029e43c652c9538c1247361cc5219b633329f695a88dad0e8d41a4c5d385c434241d8fff2864ecd11c0ddd8733a417fa2ec9ebe5e89e4d07cc483d59b3ade1833540cbecbe54cbc16f2365ac653dae50d089141ac8a100fa4ccbb583c064d0ca552f1812f028970302bde5a16bdfa9967a037ea92d6c474abb5bbfd5eb7a6ab6c6d139fd977d3f2cda7c77dbefa69ca716cd27834e544fb77a0d236057272d20b9db210ae0180428727db478244e75f2967cfcd5891d8e6e7a9007396ab0c994074de6d94c4334c91601eaa931a9422360c63474951f22a294d8b455d8af14e412752a1079a0b24a668ab43642b932bd9e5cd6e359b95cae7ce1f1ec068145a85a3d3e6cf529b32e057f66cd1b17bedb033ca81dba43d27f6315eb4c3694d1c35e160bc11b44f7cfa76a5d002b4673372e26bcc0dccc8ae7c04ea412f45f4301428c765efa668c83745006c071e61998937e55e450332058d91a8f0959e66027f74fe3716de82aea963189100cfd93a3104621fab2d30f8d040d259d9c0d921af41900cbadfcc3c150c8b7e1fc6239ef48b5cff7e616bfa8b76d1984f6b19e0c2aca5559ba9a6dc87cd7ab9aaf0acdb8676b28203cb8be90e8fde777643cee694c3104320e17158b6939b9700aa04c9e267331e9dc523dac42f7d79ded48e6a2d94f48f493da8afd3d763b4d487002b1252f8cac196132e78d226f0780baff95132769e4c6efa6b7d2f2bcca25a2dbd51c889875d8a1bcf384580aed2c3bc770e53372a9bd4407c7f34259023e13939a62c176bb7a4344a49562c2d147acfe5b0583a52ebc699dfb4190297d27530f440e5eda289c4a88a7fa8dbe9908924fee758ad3cc9051c049ee1e04441406077fa763008fc5ed76b1230ad6f6ce0d7807064acef4dfa7f8d693a6dd0489678a110220c40d4e33b60d310e8df27140ac7475fdf7986068d934cf8ef57958f585704bf7f3f326d4509cfeb597cd91025151af5061c55d7cf27132c459af523c197ee61c9d98a3755569f912e395472eb29937642ff304af86249a4f68f31133886f6f145b9c98e1994b1c515174423e7731d270f32412e1ecc8a262b4135047075353409db4830d92e4f6dfe6e316ac6c4e35ef19f255702e31294c749bcc4368992211936daf6f28f7c172b1fefc78dd8d5ed520981ff216fa84f2aa2bca6633b606d691e1f22454f8eba1c9ae2392ec9727e785c3aa2bbe84c4ce19f0980bfba0ab2a3761c4fce3ecb55bb5c9f129cace77ab8393efa8a5f5c77d8cab64dbfebe7d2048e80e73e4a90404b6cead0e4609f9a382b27fbd8371d49ceba94292eba9d442074eb4a8f588c3d137a2629686b7b47d7eadfcaaa577676d92cdcbfe084d4767988c3e24da99bdbab8b008b8dd105f34804877bff0894afa158db25645b46e31bc07e53bf4943aa86127d4c83d034d707681f86cf36a291ac2e09e33fe470aa5004a638c7e39509bf0d992db24ae76117c31a48eb15d99680e33a05ebebf5fa2168006d2135351967168bb3c0502c7753a7c0b686332c32ebb269f431ee19f58c353141d4fd42529aa1acd822f7b4fdebc54d6861f3bb68f61222304c733f455dad40ec8214e5fd17c46f68d914b932dd0aeeb0a298dc18255a7714646122bdf474789a922a5a2e1f077c908840fb11817d9fc10b7a73ebf5fe32338705cd19caa396524a1218db3d402feb28db91f5e42b9af861f6a09572b7d454b4b11cea8b4aeb05341ec5082e5881f8433f6590193bfd03989d172b618d94a4f046e8677f79d22fcc7378d711390e9ce9fe979e22345dfcdee47c377d32c01903938e5f9423838b1b6329aa4b6ac6464120cf8a666c75b83621575ba3582af857d5aaf78e0c4eb4aa7796423f86db5f6fe47f5cb6d1121652d54c61665c3a6923cb66dc0d69bc511d120fff08d518c94bf77b35ef8003501dc7ad1f498e2af360a3e2dbcf32e2ab6a1f6780677252a39de3f1a1b3e1fb85af10584eec3a11a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
