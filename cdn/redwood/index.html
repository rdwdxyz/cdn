<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b90e9d6357050f098e4df4fbb9ccc4e51cf4bb6ddd8a95a1c6f09f83e7a7b64434741f522ed8bcdf3e7a4cb089ab13106bc833b1ea4adb65df968ca1c61ab9808446bdcd9dec3fbbe6b948c8c6bcdd843ea0eccb26905c2273db38b6acc018dd047f30e94473c000f29d5df832297e29aacb9784ef4acb19600e106ce30d715e5bed02e190056d7ef53b2a31e5150fc8e4e593b3a89d915f9943b3e6b76e256bb6b17a499ed6dd8e0fbc18a05d47e04f31d70d18584f1b2dc3e65ebb296356e92e54962a373cc9acdef2265f822758fdd652101f730a1c3c12d8c3b386af3f7d6a1efd7bb30066292a91c2a65cd2e83219fc5eb10fefef123255523b73b234f7a95c594abc72076e72c1caae7329832ea4114724d0c1e2cd346bacd763a11cc8d11fcda4a9626fe3943710c43aab575ce7c088f05efa540469456ac02a50f4b0193055724ff6d005858dc1993d70c49ba913f8e1774fa74fa8b10d515820c6c5bae052e413dd78f5fd2885ff60d557f9e9f72b77307e088154e7872367e4529074f40528a250126d615f7d2b4633f15412b3f4cef0841df9edf56cda61111ed6ce364c71e9b4d4131bfe466de47692aaeb5b6a97c2836634e3e4d2155c97b630e4ff3effb27def9fe41629de5e59e3ac8002f631cc37b0c63ef63ad0bb95da6e765301fe81d4d3eaad83a531627f793a1d846ab9eb86fd672a9a87cf2ce57951c7317fc68565c4b364f63386d8f91c0a25ba38678a7cde5e91c686a267d905988851104034555d2acfd3fbe991e26274db14bb64b26060aaffcd19340737db88f5f6270ca83a6d942ff3a67e1d285f72dd8ffdc532f8c7a5f2e78bd51072e9e064d9705f1874120c4fc288735d922640f5405b93afb6716de4c08887906960f9b5d6ca5d341ac4beb43f0a7fbca6161d8c2494e26566baf502a2dc9b88916f6fd3abc077d43984bd09393503d55690d9753c771d53a850bd272aa1fce0f65f96146d1f30a19dee8a90480fb7de6a40de4431272923ba3691249056bed2beeff4ab891ae42303c1aef384ddcea0affbaf791fceacba254bcaa72e6ae21a8c6c873d5d3ccff1f4c9b6715a5453874f00ff3bdddd6f1e314539f7cf5c4fb87afafaf3b526b5b2f30c4fa24b3d6248dc2c0ecc6c80c8a168804b2f68946c321db3d8a76af64a76e3f599c9356fb8f7a2f1b7115ab3c250780bd2f23a5dc5426ed4af47cf3d6fa72dad1e680c40e5d798e7cf653717e5cf3a2a99e9b4602766d9a4b65b6f9de338bd7326abf1234952a37f827c87195fbb5f7171fd727491e67edf61a542bce39503d280b4eac142bc71902d7de54bdbc1992498c5dcb0854e39cba4da05eee9abed3eef450cdab065a25170ed1063994990677ff85f9ba58dd3bc8ccade36118484f74bd63a817021537a4924b89bce8e640499501e430f875bf8c18d8c726f2c5e363e604d551dff23860a724c4c017927dae9cda54775594ba2c61d15ce50a6b22af12f850bbfdec0c24860f17cd995554b50d5c2a7c3cd8344512fd26b479b514e8438485a6eda25c9a3fc0a80e7acd7e3ca62b2f466ea4cfe5f38d3a8b653bf63b53f17525546e8362cda1eac325e3da2c2bbfe503ed1dc9812b2c8034e2b7b8bd5c0d1a822f41af8de467c8dc3e3dffc463b7f0021205a249392153713924584c787c61d02235554e91241002a0862dd40ab6f72c312e8e656de715119967b82eaa32adf62a8144163ef17dd49c320e8fdbd0ed237cb86d38810cf1b0b46338f6a3ab52d81208144943fd3ee759113dec0d11289729232329ec0c1b7916525a657d074c4c851659ff82a653ea71bb5fadb3cf1908220a1eb521ed9fe693d60f9059957fabe4515cd65b531f481ed6cb78aeb204bd6329655bbe5ee72f8197e30f9bf611550f929cf0ae66003959026bccb02346807c47201d0ef8b94e64872805d8f115af55d84ab73cf3a43c66035f9336ebb6ba7087e445d02fc2ed11bc41638d12b4afa170d1caa6b117c04469118e7b1edfee9f560009c93e261fc0e9e2d3f7b77735300a45226130d9fa1af3a7f2b00cea3f1f174508d3552231744269d0986338d89566059fd112f061c218eea4fceb064247e77d3311945e14fb25811bfce60ac7d848951dd3b3196dcbeb5d609f5c811c332fef2c27436f956b3c674db24b54552a30be59ff540ce9351effa48683d7751225100125904877a336ca3522d27da18da8f68d8ddb7a036e85ba363183b1c74f8ce6c810938423cec78f2d9c0a36d397e74e90102bdb887f89e20300c2793a4fcddbb96b5a0901529f619ca8d0371a671b288f3331c9e4afe53744de6778d15e527d98883351d1725f995339f86e776c26d92d703c98e9b1fddc8a7491fe032c7d27056868b92ab37b2a012e7656530b252502ea39453767227e99711b8428ec401b956240fb7564bfc3bc4cc05b2189545423bd88f7cdca5bd4c2a9eb7cf0ee15caaf9be098055e713bc3e5f5fe521b0a29db39e0745dfcad3717ef505f9920a4c5dcfe4eed5d2a4b7ba68f48b5ef79a25059a2e0e60133a963b02973026b631f8120148b38e9f9938fff14d192ab761e45ba11f4232bcc1c5efd2a97ba8a9376d5a4c9392e2d3cc870c3724ee769fd920d4c12e11bb80efeff518541d4b5e31228f32061610948faeda94b68971ff93d6250d06bd2c847802e9b1774f9cf07b9e61c685699367e98b6a397839dc73b06b095c7de0fdef120689deb047b92e865f4ebb26849d69329461b32d4297f9e6a18f7ea823c49fd7d192d22d8facb9634fd78a0454aa0993a1053f13fb56db470e122ff6b82b3ef19bc9fe38cc817db4cff84007839bb00e0fd85ecd7cf43c8901ceb48cb22e5f0a8a3cc6a4f0861dc1d1b20ecfdb9f0c6b218a59f5b8f491766cd2437b861ce6fbb56140254469c7291924c351ba1189be8b16c381e19cdaf31aeac9f41794cf38a5aa801838b8ead128ae2b873785a32613f41405e02f7c2dcd0ae7063216555b7895b4f65f57aa8e024e7477e394822b949f21dbc0ac411ff8b073345536a5d817c689d3614ed7e1c6e2bf9783bc810e8f403ebacade9be698b5e9e9db83217f2e06eef5bab3b8829ece9f37b562d167cf940d967ac258d4facddd39b271d4d7ddf918adf63de55402d9bb13494371cc277d61ffc953d66ccd088e99648ce628f759e3417a4ebcd4a39a816fc68ea5b33bf91a8ed4969bd1a76541888f2cf4987f974df48a58d095b77426ae40dd18e4a982768e71a76b896e24681cac6d017ffd0b683d3ca4759be66d3909ac72454ac87a230625b5af0a1f1fbc2ff53cda6c67bc1380f805408bb9ab73fc40aa9e94c52cd61ac30ba3aae2c595c703cd682932967c9d51e7e3c9bffa1fdb0e6912933f0416d56ebf444aa968d4d55c60f42407142ffe6450aff391a5b567c551a02334b003a487626efbc99ad1d91eba323e1a9c0ac41a847dd98c8b280e98212c1faf14e074dc6e618cc02dbefa99b9c2dea5ea34255798ca2bc321ead05afc083457d94a52f4dcfcb30c5d752aff430092c12c2d136a351df19a527c540f1ad16137dda98e35340cf9691807567a2804d11f134eaad5d13bc54ff29b00319a756a717d14d8516abb468e8fa1c0ad338f40d4dd4785ea1f12fbcf14ac4a1019bd4ab37477a902250b09a70887dcec459012dc3d36c2eeb3fdd6e8a5e09652e23ee2bf17e557687cb988915fd8e966f5508d4941a1e77de201daecdf94f0663bee614faab983550a5d032c821cba8d8f22ce326741487c4f10c8df33903f424aafcdf2d51e407558aaf05b94054066ac38219e48ba204aae85d7b8f8cf10770a043bc5a20ebb8e85489d82d72719fbbfc0edbb9cddc9578d5c888ef732534eff2a584ce55291ba2008daacf523e11f05b80348eb6f83930627edf5f4da6f248d3f8b665ee504d0a04080b349232c8bd7bedd2edc002499f0ddfce7ae68aaae3179e8ecfd6f08f6e82a7f03e8b6de04632880278e22df04a97abaed7502106621b0f9cee8e97cffbf403ebcc0c8054a74df0d1f86f1fd5a35c05670ffac74173af1612a88f94dc4167094b3484f468d789d8b1d5ae9487924bdf959a46172d7c973bb4d5920eb8bcfdae299a5286a025d746b3b3cf114923e2af90a55fe748787c95b042c46b28f8c4035f4bd4965645dfb91245da4ba0f9a11c2f7707dda85785243ae2cec7f2279c30484b4f8737725ee5aeedc57415f2dd13554b943591652a4477a79e35714e51b6e482f77bbd595cc09b340cb1bd56fa26a25f3fa1d8ea841f26f136679ef116856887a0f235faa9c8d72d0f53ebbb93ef236aca0f9ca98fa79664f8b40a1c1277644c5a870309c46176759dbfc58af298650c8b36b70e44d9cea6a0f907d3fb555ecf777ae37a9e0e17fdea9bd05924fef0d3ba0557ed56d777d88ca06e57694daa654884e9a2ec7bba0f471911045d1c3efa161b02f8ed5c1fafac5e1fd70ca9c15a66a42d495c7d6d7e03e33c39c093a03cf5aa025b59cf1821f3e7cd09431d70eceefaba08f85b2e61db13628b60a3656f3af7ecd3ec94c4fb3b2d3e3099af78f65f29ed0e0204e6a36f9ca4b4b451f06e9de42cc8a78aa6c77bdd474b7dc1beaa1aaadf71a3153515232bba0b482f314aeb1bba9d80f2e0d1ee5fdcb2c843d41eb3fa325fba60a0fcc15f3b2a0ef1e9a60436efec4429da7c0acede6148fd17ca4db2f9a86092d2ecd1b63a58c6abaa081eff80ae409d6a9ebb02a2f2e9466a8a2ff8cee35729f61461543beef4da1e0512b1004045cfa244f26ab3e0c6a14822fd788273b20fa3b557bcc09baf15fde400b4c6683d96fb4a81a9ee2b67e965f333ba286336c8cf184790007e43a1bd2b18fda8b6e1c9d573b23f647b0a918267508b287fa7f63ce9c070a7d817f2568b35d6b45b97671abddcd97290363b33ab50a391abc18107b43b730fd4fe91cf91a3bd102d67fb496f1ee6152a49a9dff9ab63e248f258e0cca1f71fceb54656b75201a93545db9c510ccd60a69541ca5e89e36cd03cc5e2a16191b3de0f395d0d15b33a740c3ad0797b544a7455dee9927fb965d06084e1d7333a3700c580591bc8381a7403664616769e33c9c0852dc5d827806521de40675df2039e379e775943b94263697166abc48d98f78c8c67a5dfce29d8493ec9c75722f25a5e4ac3f1c967b004a71acfbcfd995dac0e605be0044fe2aa807892d643e43410ba6b4c142e11a6532bc3a6ccb4b25a94d1f95b06361d8145e16fec82892f271fe4d9e5f588a2176aa82ace0d704d94e8c1daa97065b385669f4a7f0a33e1a50270a058af92291a81cca9f12e95754342df047b77cd0fc168303ce4e9cba97776ef1537d153f2debc69b58f9e1436ba37c78dd0d093045c43c70283394f26d1715017436a150fbcef0a791b6ef37ba8d321ddbc589bbffd035e23c2d52eee667a0abe4b3bc62327e1918462f81a1cd1f56c47bf186fc66e2feac60032deca168af585bb154ab35279859d194147575af0fb4112b6e149e985a8802e48399aef2d61cb5606ae135acd578a502219ad1930d6d53e83f566d05f7a4694b92b8ae5c0776eab21adb1255d60aed940f545b3d1b1e3ca135de7410afb12e9be1ff95347316dcea88ccaafa1989a4fcee7686828951ca265b18222f3eea51d73eda0f55c16ff0f4aaba499ca59f394f641365188b323d3ef5511060a797e132fbb4d609d64a18ca0dcd2d858f4d1c9796c0b70332fa4581893e770e218144e0df66237078a96df82b4377aa0381b73e3f6f131ae780fb7257d334d9b34ef073158ec0b98a41cef6cf82570ca673d482fc8707a722a721ecdd83932cfad3d50a02bd39dbf33461c37f49add777e00297000ba3aef325ca300b0e9e12c6506f52d431e3312ea59ed06631eaee2afc73a8b850aef2231d2b1aade81db4216f981628747f80e5feb126fbc5ae74f1074d00054af2590c573f4634f0cebc5644d5cefad0327db800fb6094e3034468e12f5972518df1e11373e5afa7a3aaf12a817c2dab78b419d42945684120dd21aab2f2bb3acf9ca701beb1045b6dcf0de102c31bc934e8bb2d32625d6b2b49c78d88db3db88d2f9b1e98668127a26c95af235e958a93f9eb75986b77a5daf863f3600f8e82cb8b37be17e0f1f80ff2218e12f23cc2e73250b6c5c34c0d47942648fb70e3a769ade07f30e1852a0746abd255040bc7787f9e2fc72da44ad999393c252afcb620546d992519965d0e246ec10fc88a3556d7258ec1d1cca06875c7c0f262c596cc91723b8c30f04827fdfe167717887dd51e7bdd77b68ba0cad1844d54cb75af8174e0fdc9f5d195072c4f945a91a96fae437ceb39a41435092e449b617a120c39ac1fc4ffe6714d16d4053c630e4965b4ed9490a89e5ca2e468eef59250501f3dc1839bfac74e2420215ac6224be0009bf0882aa31ec5467e9a35baf6b3fb131ff87cb8c2959ec38debeb71b09464df4141c993f4b436d55372dd790db739fea6aada0392215276566931bb15dab4798f3566c097b8c8b4ee3c9f5ddd512bc2adfa99dd1b2150daac45ca3e2f07fb583c678ebfd43a0566b5cd9ade58fbf54a78c0443eb29efef78ff4d4ee1e83e2e079de999b815d5365846056ffd98ff1eb934469e36db8bffdf88a1b1d3a2fe47f3ce09791e3c288b0951bc8abfbc9bd5665733ba8d527b610169c90accdbe69b12a4fe70ef24e4e26729960cda70073abacb90320fff39aed2c25d38e820a72d7a044d243514018e3de8f4c0d722084ff16444b63a0833ae839d29b8ba9fdd4e292f133d137d2f621846cf2e10aba85c1a0f40beed0e0f0a62c9e5665b366b64a1144c513d888d37e13485b08247f76ca465f516d6bbcf725cde4f2a2b6af34e02cc5d6a5c526aed1fef576c12aaf073c64cb31af637f13386efff510d5ee7ea5da5c17b3900b8e4c6ab837d1e822c845ecfd7a966519cc7c6273d263426e9b9993e08c57506e57b5c6fa38a2564e05cd3d1782609d0ce157eeb3436c4445d199b613b21991c3c97a8776df8046ac25f409a33010b3021068d22853fffd1eda8cb17af6cca0c1a6130f5791357f1e38738f1a3e51673b7374001f5d112bc52f6e7985b4dcb53c7eef64232aae242ac02b4fe23d614dec8fdca1ef9da0105d1d927f0ad89e4efbb1474c276e3ecda68ca511a02d31ea18a5ef7f29bef9aaa9c99d7b9c8ebb8f5a28de01106ac4acbac4c6bc9c1e1865161089906ecb8e298b701afe3b2b7f85170a31febcf2822231958333d080f5a8d41d9d36f6aac011413caad0a2b311e095de73ca6b17f44a2a121f34c74568cb779183e750f5d9351094c8b59bedbc70a7669ddba164a92e4dd848d677a37552c7cb5d659ac3c7fedb7e03ff9facfc40521e16449775b5f1f08761597b3a89e856f0159751f9d36b080bb907c67239ebf73a55d8a27c0aff036ea15b611350c290a0b7a850394a7f44d97f66b5bdec6b6d44b631f5be5ce96e13603cad8df6a455ad744919b2363d2073c7b27fa26764cfe5ed363dbd9f7d9554a04ba528cca0d6b17f727dbf28935d333918cb08a0f7a1d0786441c841ad632e924b99a6b6af3ee339717663f97383112103e56d4db6b2d81a1c333bdfcc7f2c78f06bb54be71a445dad5d07a14ef656e1cd26ed252548424da1cb41eff02a46c33f9ca58fdf3e6f1b55d3dcfc86553fb6d79e87093199717ece3c6197bd4f3834d9033de121f582f9c03f4af08be71b91ff9356321efa0b2f1663cdc234524ed659bfe323597b8de9f127a28d3e3fbbfb8c4af8e5ec78b35be206a5e5dca3646935674e199d6589e808a4b581c3cfb25c29f23eccde5cb22e2dff8dddb6f043ebe856a80a2845284a002df103aae21ac37b17c938c8a40bb1d664fee8ef458ae9255e0905d16e92c54147badf6fa8977322de4d221a866e0f4c97612d409262153688b1b4aa6b1a8cf34286eeeee439b4ce007861be8162ddce7527377f93b685a2994f9fe2017cca5b90103a50e97d3360e2b51b935b26ed16acf1d47dd0c3aa7afa361062ab15dd22a76f45408b8c5b5ed5deaff0d8889349f44eb0e2f680816002e82b4b0c1f07f12444a7b8a272bf4f408b940d068e7fe2425aabd8e032018b7ae18b1dfe864f67eb1ddcb4d3f47bd498af8ac7d59262ccfa202284dd5bc4835c8aae38e422e7d8ebdd14f00f2ac17e1da87df880725c9067632e07a058e78c6dcd4dcf4c63b3b3acbeb6aeb6babb29f8cd32deaa3ed22a0e65c960c9379d3f67fb9e6c510d32908f5e78a0b9fef1e4766fc592900046654bcd5a88603b38ea5aea399a8e827023d4ce8e1dbae17e1958e673e5b03538215cdec107ddf5e8301bc8252ec5a01dc97944094ac60cc8ac8499f6facc72951b0b450e52b339ccf0f50b1d32e6c2d015d990016d3b56beab0f9c3a331802fc2619ba7d4498d9957452342a49419b2f3cf487e8e5cbb6f52ee55030a1985acd412356cac033316a23cea11bf439f3af85b5e3f3908082439934c68209784523ea5e920bf05670915aa480d715ac35cbdcc9014367152d5fef657dc6a1103c6e5bed3458e431023454df129bd794ff8c900397875e0384096109043d977792e1a6f49a2b69084c9fa73f456d5ef2f8c7c07109f4e7ade5309dbe8070cd3ac46405c81ed9de430ac342854616e80611a3b753a310ae7e9450131a2e8c5a2a1bfff011154ca6c25f6f6af3eed14b60d6e8699b44e3816cb27b3c11631850638e5e0c1d89a374238126bf58dd9ff3899bf0c6e0aa780e3d91a306f2fe7e2105179184615d5fbc69b557aef316f0aacfb8ee23cf79bc59f0b43bb8865788d3d88ad99c4b3d3611250dd6aa9cd6ad2639e789382be5f28acbbf799751334647ad9ec75b1bfd98eeb0ba7beddf03875bb845f691bd54c5c96971a8bb634052988f537fd250e90c8cf3624f11165041007c60b810d23ca87d1d7e4ef627f58fbc1b21321861748c6b099d428757e9d413a8ec0817afb84b8b9ce1ae43cd12fcfd656187c5ea5e4e1a3ef6e957f69d8f1149b42482f20622db25655656749dac78b4e3a7ce6910159e98f9149e6c7836fd8a628cd9a12d78eedfd152cbaa93d35606c70bedcf8700de59aee90b180f3eee7b2cf76072f7a8e798927c3be84eb42abc16be24d506a5be3995dcb6538bcaa84c5aeedfa55c367b984744852f4c7380d78929264695d0469264cca6bb66d3e7e578ceee914a9579f9fc535650fad4a86505869b4999324ed06873798da49f9c3225b28f3fca571798ca7e81d0efa0331f345611e3515daf3bf2942a8be78934ed72bfcaa5454a03be296fa55fbe1761622f6d9d73d5308bdd783798ab7efc8cd4831ef34409cbd6197d8722ab33f3b536b8e4df0d2c49722cac5e9e44620a7b38d7b2130a9e12d290750a8218e5244720f11114e6a4c05d2f66f16542e60085e1655e1beee70d0fb94b67c7add41b60ef809236247aab27597d8a6552b6e8a759575a16f12362bdec21db3bbe7822d685761aef9b19a1d2fe8eaf86b42251bcaa1c70a18000ce5b84bba6f1414738ca9962a0fd96df2079df25361a981de7972b63d08802c8ce594e0568fe1e47a81062f50d639f5caf7bf54b231001c9eeac7ab21849a4417bfdc3dd330f894475d295d0cdbdd4a1a1cad96fb4d68ece2815efd3afeaeaa2c5a3cc3ae20af8de2a1f9c5bcebd8a516ab798383f92162e60bc6c11a07ce04c02ea449184ecba166a038bfcda2a79d3449e71716901dfe420e31bcb4f8ec10ac0f6f587449ca8c95a7743968f426c125fadfee2d5b2472959e94d67d5c079aff8fc117a4e9f53851c1eb7f61f0be188ca7ad193a1b2299dec804a759e2a5d16909425ff26105af62cfc2d0af2c7fbe1392f8f5a857a663428fbf78439117211e8b78c6cc9d2fc6c97068e21ff3ef5af9a710c521532a8a27339be73b84710df52056f4cbe7465169bc050dc65047b7595ea31ca3b44bf62192fa33956d2661480b69b6409bb060a14c02b6af7cec51fbe27d90a95fb21b362d47b072aa1fa27bfdddca4ff6d45425b8bf6c94ece9b45bf871af0d8bf12b6944096e666254028a1fa680d2389eecae1bdf60f2ff84a97305b4340470dfc9f2e77c6f57ceac76ee70c12e06008659a088bcb82679e8d36e8ea388c6a34e6d04bc1f3111046ddb387226badb996a43c72f4717ae75683b90b416b4600af9839b7947aabb9242b0828739b523bf7d517d88b4ee297bee25e468fd123b72c734617fe72c6a1f3be86face31f8c26c0cfd20a68edbd66eae0953e027763707d5d8274e37f173dea8dcacb3cb5aacade99128b49416bbbee2dd17c3248d7f54d5a83d9f20e94cb2436b826a00785a149d91dfc86e412f483a3a2b98d9467e5eaa4dedb7ad967777870054f373e9c4a7586ceda848869e0a840061db0371d33bb339907d075190e36dc85ece3c221e5a3af8886fc226532a2af87456f132fe03f7db18e134dad7f27bc3ec010f755ecc930289fa1aa62c06435a138683c52106a9274419675b4fea8bedfe302d6cb4d015f923d40eb64676ebbc4dd4aa89e6350faf7d14617eec65f63076b4bcafa2d736447d06e616430c5fbeb655c3aa5e68ae08b64cf4779804687fa522d6aa6e8a4fa765addd1200cbbb9a5126cc65cc858b9ba2494ea44f12b8c4c24d134e38a4e4ded585d78249341bfab6e7b154b628cc1fdaa7fe1d0a0621ebed2aac2c07e494e8e612e8e6b277a00be0d8143febbaab73fc5c8d1f5b9f16eadf09015c47d7c212bb5087fecaf75f5e068f6fd970e178ac76ef324abc042e4c04c0c4a5583eaba1cb32777448e791c4826feb0ffa583deb0b0c8ca5f8e168f4fc6674555f20fc21118136b2fc5286050d37831be207d054263e62cb73c863668558a129bf09fb35a1631133bd39ed01ea8278c762b570d13a9f39010a39f58ebc67a5dc8fa3f27abb668e85d63128e28b5c24c1089a3237f046791171bd5c6b738c81fb02985b9f2f0f3533ba2736688145f9700f059fdd628f0d003143d1b9e3a4ff090af6cf085b4c17e02c1232266eee2e904d8f9fe5a6a0467c2461d263d64383cfa8b09130cef6377800184b0e3a214771c0826bec3ac7a4cd2ba8c6cfb87c4a15461d55ef80d4ba87748ad58df1745768b3f4aff38ebf82da5445005464bff4918bfa74114917b059fcc51d4bed6b7de896449a4bd1ebcf0e2c0a2ce231d30db806794ba1411ef3a090fa722ef657f7f01f3d92fc638521d03a408b44a6352f4465c83e8f57a0369ad91c28b0bcbba1ed7e94a5660e8ec95fc65201ef79df0b9eea72a4a669b36c3862a9a1b40f6f34c2126913b0b5ee5bbf3d56fd138f26762598f11e4d223ea6763adda8ba0d6835fd1613e1111622353994ae470ccade7c0371f12f3642723ac308bc253fceab1199503c7d255283a34d2ed31e68a7e1d969f9c1d16182f39fdd4ccc70132e3b5d14518bcea5f9234b0b6a3571c48a0d8b0b29915aa7c621ee154847383cf1bdecb0f096538a771a6d74113498bea83bff3326cc883bcdbce90bcb1a80940b32dbc0a3d26cd4e002713b57ed0c6d00924147eb73dd13998dcdeaa3cfef14eaf2b082a15c85425afaa78c134302de12557f9bbc0d4ee0c3e3520e37372de3460a719fd8db5079afde20f2ff3e9b5b7a025a5c1afc632711f4986c5099533e4766291a1efaeae4bcfe632f51529dcfae968b34abce23e7646fe655269db7a8f676d2fcd41acf9dc2bb6df4e67d74dcf96fa970bdb7aeffb0a4e8f49d6b425e4217cd27893145aa99c84ad0e3f53c8ac94e2183473a3f90462f80171b667692214ffd90c95e1e57d41a7444886294af51f93def3b82c869cf645e6d0cb849ad485eccfaebda07a661bd8167f07414cce4e5d368706796b7ff469136ef25bf85bc7c62481417834af054a4ab7b13eb24f54ea13ebccd8b0b3a4876c5d715d150334f6dd40480383878a9e02816866cbc396b522dd79706a49af36cdfd0c40365e6e2222e8e6e154fb24241f8357cdd907538aa298ca1d3dd2c3892520d64054be453535aceafb48563cd6af0f0e8d151e33692a038399e8ef6e31f241d674f2751e5d29efdd4940e7b6b1a0ad59d7063b6854e1104c61ed7ee08f2c3e6e0c72aa12f7238144ebd28c35c873504a615d88949e1c084fdb9e121920e87967ff7337da1c5132ec5afc1083511295a7c4b9ecbdeb9bd7b6a6da02b08fde8b3725a10b454aa7a3eac1dd360b5058dabadbeea03ce8ab0caf3e6af6d3e4d3bbcec25985d975d4df2601e86e45e8a9d872d05d0c1191817fcf9a85f251fef457e7f666f945039f3166308a47d3e8c4b107009034d494504dcfa443a9d61504c9544c69de9cb0af6e91cc041bfdc54cde0730de62cd12392068042e83374fee66aeeb0f0d046fd7e0c2544b957a78a3d8749a2658f57beb35a6f329bf39616388e89fefff9a2b5e1ed60ffa6fc672af6b5ab61aad68245c8fd076827f5f332887936681235a558f81e7c0958169ee2e1e582e845a06640fb25cfb856e600ad64396c62b8dc1c3385abeb6812e14547e001de191ab54a54289bb750e07992181975f0578c6504ee76e37cd05b6ba9fe453e0e1a42a5b61faed415ffb921766c780ef60b49d4fee0dc6b98793c3d7eaa7b97b4b921e0a9bdf3a312320168942c8371be6568cac7ef4f27f77943eb1d6e27598b677813df3b950006d29c51ac13ae508a0f2e8245fe98384eca1022e8ed3030412893edc1df13e03b13c520b994f193ba9cd5769b9ec69cb5d11e6059f7ba34ceb6730dae8eef3c0025000a9e3b004b649effb4e2cce5a8d506be2a7e231353ed070f5138de0e5767c75bd1522c900c5dac3de15fc0566994b6e884d47044298f50ed0a3e7943f6f8b836e6124a4909788a8dc7c4c8254b6f2509550c76ccdcff62b9135d8101c0fa218b1517c11445a78e5484b2074da80fa0efe54911239a0a9056f83394a8f6222a1d451ae44117d5933df61cbffcb5d4ebcd2900943fca0ed0322a75731c1ea5d1807dffb1139a819a4202a75b1094006da8ac17521d196db8965fa433209d7f05d6688261394d2e6bd1218cb1c3f5adade4e7b4032dcebb72acbda2abcb47948778c0fc6412b9e014b4d641a89337405bbcd60abdc0570e0f36dfa7dc9ae1e65664a1c74b9230991be05fc22ccab9c8947e31db9408063e7c6d1ab514b0cd99f4f7771f525993d852dc1b0e9c37b3d83dc088260508733569500eb8ca42958ddb1d6b507523ea9b47544920296f7ce146ad79462d39d5dfde036a68c7ee40725c3b67a04efa0e8d77caff3b5b549ec62bb1dd617eaa538e3ced3dbf2dcc88d337b37b7e24477edabec2e3082446a86b1eda9b0889030a83ef7bd2b9dbdbd4f677fbea77e348a99f8c51a488a87dd165b765633c706487f8745e2943ce008bb397882a6d5d777505437b2ae4a894b2a6c5099ef4bf99d840f0388a333749052ddc2f6d783b1c82b983d6ff68782efe47f775966247d6cf0695d57dc7b42655d097f10f7559e421eb8ff1f09345fb26f65c595a4a31714dbec5ea023ae5f40d3bff52095934ca76d3dade8fa9e6cc497662da9921293351ee85708148ad20a62d6f0ac714465cf96529e5e33864c8e45c3b6917b064939e849f87765b51bdacca0afafdaf4f0c1c83d4d51acab1d1842ff5058054df761d7a4cc3753cfd28a85417f9e66c6f746dc36f62eec626729e17e1a78c234914517b66ebc6d5aeb73eec75f34a4076e744a579f1dc43408b5396e6ecd3483b0805d8964d7659f35d5c47f8ea3976c9aff1b3666c040f676f40354cb2d047d93c3d7a9fb679049283b7e8703525c2777e9f7a7ed7c52181518421362a5b5e52f2c80f176f2e0cc64909f108f4c9a4ef6ef362226f6e071ef4be39e231ffdfedfceca6e4f2273129ea4eb3c720761745b87abb54dc61c0c77e8061350014ee5adbee0349771339eeea086d0ac9720088b37319a49e84db224c34118fa5d37bfa282517ee4d0de7d3929d7135c1eeae5feea5f0404df176a8731618c76aa5b254b6812f40879e75255fb2f2d80fef2f188c75d99bdc64430f5c22ca952f6e4d52ed10500a9c50f77aa00d996e29864e5a02a7832af392bc7acc8fa02ee73389d5fe34eb1cba221acc6479e8114a326f6f6d03c2c237cccf8e3e0d9524d118eebbde2410393039d48f79e9bca4f174430031b2db56637a117b6e61b6a89f3436b9ab429cc16b3758ed1bac8a2ef1ff6646ee8bd2db7aac8f4fae2e3811bd1bc2f3f01631b7b6c931c997a9362356a3d2123a643e4654b67e84b14b9606d16c5388ec42f1b027a6af37c88b6f741f01d6d60c2e58b46f6cb4b18838cbacbb73aa3744357d05eaacb76690db1654f5acb5f59c0dc74acf6b8bb02e2433b5ecc54fe4fcfbf500a99103d96c115d4b73a7f84166197fabde78925682ec4a3119383d1b4e7828790a1dc6256f3f6247768cba355fd50c30d232fc592a089431c30a3f567207e8b0b7597bf3aa50a6bc98a63b7bcdd86fd2b65614873caf3013cf7db8f82a365d1ca62eff7b1d1cc6ab3e2205dc91e617118d9ab8ffb7219de7ceaae6571235148f261cff9b2ab9a0bcf8830bede97dcbd4f5fbb398422bf468d756aac0e5c978d8f5b208a847c4a97bc83007977162c57ee3cc28b63d788844893bf32cceba8558373e4355bedc9c668d9e9b7ac7ed4fa50f1ded3a8a9d481a1fb72a3615c17ce16c3ba33d0ef179b0d20611b85bac5762f1eaa5de547082d099c4f9be25699cbfe61517ccdd106c66b9fe03f81a9fd6c940fdf6bdb6546b7676f907fb803ff50078a7eb979278e52a85b77f9298d2dabf138a92952a953551f3c782e93053ff3d5f2531198867c7b1c8fe6ff4fae3e6ae5a40a0bb98a30f98a96a481783cccfbbeb63dbe01f5a6841ff3f1e8b1e754d81f1c6a41b319b7f53900234283792a437c25cf7a1b82695f3e292a2d06097af235606c5333d84f85ca826653fa156e27222d97300d292433fa63db35c1b93fb62f8af73d5a300f1e9f9fbe73fa7b3eb49eaa3553f9b01f4f393ac5a0ee866f88474e37647027b7ff18a65a064a374a8f224b36eb5bcb49703bcce792c280c56e31524218b1dd5d86f5105b1d839a2b90c4e5703e178bc3ac9b5a34f8851587730d6be60ef40f03ce1a65c8dd8f5fbd1783d21b829440b0c99ca6edfc16240abe6d75078d98c8b7b64c6061a8ed7e771ec7fecde9136bd36cf9ffd87ba234a4f4b4a74bf73713bc0afbe7fc16b391f9a9e507cc592da03fbfb5c8c52733ee35ccc5448a2320895087565d3e38c95cc0e142452c7d33b27aea36765099aa842a0d1fdfdf196c451e420b1907205f45bfd10bb0ef7460406505f09bf0aa0b48377ad1148dfea8fedc46e597b7251103c6b1288620ce04cb6c03d29592c5791e370690c01c2f4b451ce922268f302c35bb7cf008540f3dbe307ae401a34dacc6527e9ed53bfd53843996f5bc09f5bdb7c8739bca9761d885c7b70f0d2e701da258ef9fc09138ad581f0fd93a7a6cc95bd3e6710f8ab69c46d7050abae32a8697d7dd4f3fa9e8a65369492e30567e7c7b48d25e5aea2d4e494f6bed1c38f423ab177c3bc98224fbd833d13580859eb1d76a56c32309a208dcc626b9799eb10ffb10f76c135eea44a0776eef282e3709ba1e80569942997f08b1eaeba9ac303506a8701477ec8e378f4620a05c640b0ba28dea5c07a744340236b5fe90c3cae129a872d1645ff5f729f1f99a5fc4f1df01c4d2d66ea07ae2de14acf40ba3d8c64a7457523c9d3f80593c14d047f3878bb81c981b09f70945c891806255df2601e2b103a7f0b6416898c38235ff1e0dd9f56307c221762ab51cd641dd927cf9c2abfc948260e99fc60bac46ad25b64aa896382a703f7e9c69c8f37ff7650fb19d70d8d7d1eaf205d12f9816705e36bd59d4fbff26d9cc9cfa36cea2ab50f6c4d4dbb1a5d4d04972e7b8b1e71c2019577ff3b7d181cb492b06e95d1093c9725f1b3334bc2aea9b89d53c1e085bd50c2e30fc64906c1671cdfb112c6e6de5a4c0607e3221380a902d7e002cdeb166d1882d3d09ebcfa087bb4770e852ecfe702b1483ddd100e421d7170581de16a8a0efded81eaacb62d3a17580696c52c38fce048384e9ced5f131933a2fd68a529e99acb90c6837c6ccdc1b983a967bf7008deae781f6c8386685974a03a64aa204252c17b3be2913c8b9753759d46991a32913811b4580b4c5488b3768cbee6a51f8f85d1026df145922d1933a38b98bc103e25e26f42272200e2a28e4e6a9d45a11508ca999cb9640f7fb1f0e7c41d69e392a98a4380003d5900317ae267e1e61901bfd7ef62afdaf4b4cc94ebd4147dd032cc98d0086a35c7089a6fbd5d017344a29e463858f17fe761cb2063085a42432384c225d6db4751d04b48bbbd4bc483d4e2c5b7f8a28ec6c966bd5c1fe830c948d821be6f5572e355a1f951b1aa219963d1399c1fce4af3792219c9c757f96c7983111a13b6508ccb85d3c78481721ab4e12ccd87893ed65bc12dd1ce3d9a29bebfda6d90cb363b489227206105c21214a680f7d20195eb143d4e263e27f248bdf736cd97cdac5e2ab4aafb6f0cc3f6cce6b9076944b8ec09ef749696364e119d3afc1698efd4c21870b8a79d2da563b0180a33cf13fc96621e0dde0060ceb0107faf34c2393e2aa356aaedef0cc5686a4e5f83e36dc5a15362f8f6cc367277b53edba41c88bf48ebb42447fb054fa677a4485fc510bad3a3ef9917b6d29c7f23894c4106e517b71fd4344af9e08e6c868275e5006466b652bd3e471c3e70b903721ca65505127c4a246a6ac01a540308093e3bae834beb4d88db41c416d2196eeb33e8af6fcb4c5cfe40c1e4a6789eee8d91a8f0cb378d86db4b50e3524e31c2445a0c0d58c3ba3d8ba64fb59fd920f33be8d3bfeab542c41952ba4943aadd93bacf96368474237c18fa21e2e9a897a8623accfa43a4f86b331691ed1192fc84cf3ea009683171e390d94516b7ca05efef7a79cb222564be6fb6ae57b0b6dd61841d78145ab271f0bae1f0c84608627fc16673fac018fcfe6f51ff3f3fc6501af5f288ed495c3f5ca28a07291ced2678bb06d3d7b10dd2b830363a56d3e2cebfd04c6583b3240e3570c62ad77bde0e02006609d118c7ca2846554e91ead0aa7ca33d5e6946cff0b14c9f356b9c1a6829db8f353729c6bb834c905f7e17e3e9de90e2cd99efd5fd35c1c23772da47779bc4fecf2268e66995ed712aeb4589c2281db5a9511f2fc1f5725bb46a0d9752ba4dd2f741349191e97b64a165af4f449ac38989492a2489c35c232edb6d81520a46b083fa080def2ce2aead043cc2465ab6bfeaffc66708f609792e92c5a226801b1990946239902ed26477ad406588d41a3a5d4ef3e484ae143b5f3eefc57ef0bdf76c1cc880afbefd6e8b1b29763f6df4a40ba153c3d337ec71639635d0a35611458faed54cc3c4148d10e711b906ca0df5076948ded4f342f87b6b8bbbd741faba62a40fbc9c679b8bde29f29895375f0512c2949068a5db350f36b3a77a1fc645c59950e33292f5a5d0e5ad94505f8acc763a64f4f60b91e3b18c6b41a6b95d31bca41a44304d84e129788825a42642866df5af9ba261a8fae19f8f511d28c26f7cb9dc9802ea6150f24e08255424a9cbabc5120b792e935be13e21affb667b5fb79677b24eea36379a70e479e10950391dcd959ad88441a4219288cec01c07a64fc85f34ed7c025269e6e59217d8e347b8f983fc325f1a9d6fe5ace96b3fb6ba19d7622808af7bb82c9417a53a6f165fa2fd6e133629d9dd8d0f88206e4338a861ff214837d5905ed124d394e28df5fb01fdc6d312f0f5340f60bfdc0872f1de66d35011e34afcd2515f8b1b2cb6aa3120c2e202fc48336d874020b5f5bcec229ad34c5453c39f833d64cdf19666fc0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
