<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22f96df5da4baf141f24336fcc2fca2047025358bcf94effedcf33616087f024bb2b301434462272c1a574747f9276d0a4b9a4f4e95a66c086b4344e28443e48fa548691e7e84a16c296b5f22d046948eec14f4d373b68083794833b72330bb54b9d00000d62d7c2a2cab5ce7bc7baad60da6afff0ef7193fe22ac5e409e491f9eda1d7fcc092af17693bcfe57c4d4f5905463da8a39e84e1c8a5c850a8639ffe2cfe9c21adfecc60e33fc58ac4e871cf6cf3e6b0f9c088ef22290baf8327502e6af2d645fb73ce6e0b6c4e68f5670408038ad75ec449288b7d595d894b4d14c59e5e9068aecf7a8ade29418376840461aac160e877a99a5b09b97a25a554bebb8dc3f83360e7961c8565196722c12f036a77a1b878ba23ae6f0e5637366619d12f9daab61cf4a3569e4fb88e7f172f2cbb51d63e9aa12279e9e54d74748bbc25df23f82f3538b6ddc4124a0fa94bdf3cc2b7658059eb3ac6cafba1301ca1605ad442ce5e03d46b4ed9090e024ac216dcfdad8390133e17c9a022a290e1337918419a51ab6410ddec08ef1888a0ec0dc94177e041fafa399c37af550337e3dc71daeea00fd5a09a398a9203ff297701fdd0ee0ec27840db03af140a9eed0da6dbd9f967e2fa66b4254fefa3327fb97916b6cbdebbbc7f8f53134aadd67c809e36980ee4c693ea86c4b5f5ae04f1c14a4d69d3e02e650b8121c2ff08fe5f21448b91a18194db04029f69626f5212f7a6a95babb2d75c2ecfe144c58f1354bf1eb53a1e21f33f92216af6dc38a908cf7fccf96d9b76c86bd19582d1462cbab6078c37fdfb6e6025a2d33a821d92de964116c63500c58ea05ac30d20d3c813cc77827254313e4e916eea24dc4a50b68b2b846d12c06d9ae60ce522463fa6074d14d510e0bbb9dfffe87b89789db5f372284496c9aa6fa1de4ccf8b93a2b849fc2cb18604740aaf7526ae5c1eb30b4b78a669198806a9dd5647fbd34fac8a4367ca206204131b0cb7d852224692b94a3233de106e0f90150f6a8f57dc9228cb4b5d45d028bcb581f0314b181f1236e182466f1498f95fbabe5ac0cb580a7f7be5ca16b8f3bc9832f6c1270572060532b56b906d3ac6c918cda631f45ca45696a93e3db7be24c9acfe2c4ce4a0e7d9565a73306174949e5b7129bd36e9277182be93463cc129ce5e919a947863765512bf58c6f6a64b0b5a3b7e59be0f26e46167a0769a77953f75ae52293c0a9a8c1b82d6fa09a5f4be4db2a1ccc0806349de07ef1ecf0b1a5f6e818917b75d90371b126c068d04edec4356b864ab4a713c7cd7282106b97a6fdb2e3edb77eea4b13886f12f4f55504a0d8204ddcfd11e436abc46ec5af30a7a65a3975a5b56a90b2d48ee3269c389b7d9826633b78b42df38a18ed3ccc309fea2f3d03549ed9d733675097ea52b706db6441a66eb85c95c5e7a6546d75cfcf5dab0ca13ed8efb39261029654c8ce095c473cd6219b8648603927f1b67043de4df5eebca1b25308bc8ad77f33ecdb4620a3722771d3fe3c8066745886420a7fae2c350d2701527cb1be62a10138e2092537a039243e62c952844796bae4345cb4929fa064829304feefc39e4f29e2f68414536c6794d20bf937f5769125d371b18ae1586c608021412ed28d498054057cfd8ab7b9b2c1d4c9be01eff45935ad09900c065075c83cd9c4e9a357c5c0ff9d654af459733ae2aa6bf349a6602f0db1a53493664529bc8b3488b824d9c34b3f6221c7c7300f5c34adb4c5dcae251505fa4927946f2dc4109a74aa61f0a3960a69d014efb11267df01f991dc9cfe92ffe2f78018bbc602d618b1b2428e1fe8cc98ba23225e20f49dbe85c29c97e8ee4bbd7e36b5a9b581c22fa520307486397ae46577ca5117226088866c08b35d9deb54cbafb4e9ed6eeb51c7439f32a2c82ad7a4de5f5a69c4b0e66a7c6dc686522786747ee7d9d66d6c14332c8329b01cdec2446a01b52b931e5217f74bdc13aefad65fe75f99f4567df32cd52383a499454c3bbabc93761ad54b0da65da368f76b40109092a12bdf775da2253eb650c8e62ba83eb0a292177e9a427c80fb52610649645d3c4f8a90f2b09914126963161a20ccc056c63b2cff00adb6ed3ef533e28a21c161e1ac1ab804309f9f46c7191a807d35c98c47a3e849c2cb0215540e14fefabe65ffe398994f127f8b3ac6dbc8130cd02f4cb305e1b59c0087667122f43cc6cb6dbcbd159b24f01c4270ef95fc39b4a1a263fc7e47ce280fa5a5470218de1755039b4711e9ad9b176372b8649a241528cf6988b615262ef997c5b09b03abb808283848142482a644244e671402079a4a4da485ec4411741d1a75f23649a768893abc567548689ae63e4c57eb317872ec41cd11820238ffc5e817e2d1c25ad021aebd22a4a495c61a598df563bb15f516efbc9f574bd088b2493827504538cb43eb4aff573611f258ce2fa61f9e246ff5efc0c61224d78a43ae89ca6b7e39f45b7133d083f78986ae4dffdb4fc6d68c1140d2656303593a73313b8ef2c982ad6a6b323c755aadacf0abee4a147c9de700b946b2e63ae8bd0d39db083759a6d7df87e749d9a16de539ce118868825ada82ce368c3e0747453964daab2119db3cecc690df18fa5c0368f1a7ab7472e5d0f91d61d17c243b5d1dfa8544add37a618512e58f09affc65e93e235431914c1af1f99e34bf022788ab5962ec1e680928eb4dcffcbd29a545c7731ca108d17364a6ebb6c3413651b7e3c11d940cbbc736f014a5f88e424fe2f141442225f6f894fd79a177b890c71fca71d921966e4724ef56c2b420eb500679dddeccdf43e1dcfb11799a66520c2e2bf940ec175ed1ffbe7170af322e52c3238992dc9c07ed18cde1cb9b3807f8016e9cb8ac1a2be652bb1c5e7c84caed210e02eda04652da3a8dc51f2eed1bc2d4aa0423f599d7c7ab3ea395e31c4f61c706f28c6ede06e8c7ed13c466dd59f7d5569e464b96c9eb553dfc89845c9399c98174aebae17792132fd5b019bebc520d15d3648326e8ddf65c16cda0a43a8d8649fb0fbb77d6061d1d4e638fb1fbc9128b5de6c22e867184efa4516d98655e0160bc7fd9574b29cc7d6e78d4a101c896c50b6e6cd7ee57057e171aec808d47dce574fbae3cce54696d7bb547603ba4d4bdae956c47e11acfbb4db94fadb4d07edc3a29e4670ad18ffa145cf4c8502ea3362a1de876d1aa3ca544d43f3dd474954a8cb259cd2d97194dfc38d4e94e7b66d4bdd6924b9d0cc4ceef3796f768bfb0df1b64f598a2c7ca76093e670f4ed91cf137ea4e777b7ec7812b0897e24edc91c3743ceff48e4fd486a5db3d9d42317b673642b936b63558e622ae6e6cf53afbef40fb29fb1122848d57fa653e11c9ac1599ee72c89df1de2b16397e4b25a071331255d67d8c4733fed6c4f22b1c9fb539e1f275c9381bd1d4d67961dda1a86427523fbf781e6b644863f8866e93fd422f5088e795c2362c03435fbf13f115407f133687757e683a0dcb3d123f091cd3bd2f18e808d83e882ce4fd23a952fbf335f8fe47fbc8a601735165de16d9c8067556d97a8f97e1d62cdd12ec2e6641ef8e43012631938444252a0da1bfc715e1483b4a51e0ba2be3b81554c99039643651e9599d254f3c7f67af2f63c33ac8398a647378b223fee6a56a9126008693e7304caef28b4b81b66cbab6fe93cf5753d51b47a57e73674c5abc645b33378771f755f27dc6dcda657774b419914eeb1c3a9b7a8375ac9bdade82ab008352206c7d8d5a4ed32ec618c67e528cbee57af96dd7018d65bfbc6dca8a3021b06728aa508bfdb6a07b065f4f7101aa525d7c0e2ab110529e2a4ce5d2bdf95ba3d7c2803fcffca1195824f20364dab31e9830a6263c4371cd5518936729a4aa29943d685c72a8199f24ea1de9ca2ce79efe75024fbe6cacc8201eab68bcddbfdf889d8047904ace3df598fd527fc20f12835c62dbc597819e68c6aa3426f6f1e9e62033df0dc4e7d7f3785059a26798ba5079a053be7d9c156e900e99274446b5556b90acec78b7147d87d63a3331bd6d76dcb3ae3c2e7491df49f9753b64bab70856641e505fd0f57650fd23063e4fb8b186b065425b6aa9e448b64b945b69a7b80246455ae8068a6543f8ce8e52e600e554aef8a28243d784a353d0a07b832d1a5b91a1d83cc4d1c0ec5e9d9bb112e43843d61d93e7075c06fe689e7d4a62a90f65097f5ddb24223bfc0f6dcf5770956f81559f4d98bcacc5f120fd7970fb74b7293b3c9b66424ae05c9c4d34e0292dcdda8bf7bb216da80f3d3b2e5067eaa1c694b78a19e9a7a98963785cb4d36477075ce60e24af0251cde805c9b535499a9d08f79f2e5981c0b5355462a509d2040f4365ac6f64f93f8201743363089d4dbe4eabc6dd649f705b51ee3ab96c41117bbeaad4660c14a39f112670055bf7226d054c2a8a4142d930f80c0fc3b0c602ccd591ae132b1f823e0d46bdfe934d9580df506c01825b358dc4c8bce559af8fc2a9def025593267e7935f4fd14965d5830b92b0fff6250b40ec2e5b0d9dc7d318127aef6cbb47759c941db7eb20d53c35c900e75289b200a5acbe1d84b576cbca3af81ba73d0bc6e6d70f3e1c0fe99c5fff4bf6cdc6bc52c58b7fdfd8a09c7188a19d261d12e29b5296ad35a29641aeb83462e28550a0f064bf3d6c1de1502afc474a3e3348fc635a3cd3c9f5c7cbe51bd4a59997488735521e3fe13aba9b2acb5f2944edb59c028ea1a4af15cb6fc6db81524ce8cd9930b12b0c9e4f736ef2e352bb5e95e9fb16cc2415383f2acbbfe7171595b321b0b7a872996a9079b67f25664100886df879b5a7fc041d4e115212e44c44b67ebd8b750a1c2e64980ad7744292033024c653f9c929a95523ccdff6c10d86b9efb451d4988161660dbc271bae778e71ee9d636b5ed85428df40b6867994b5c0217e895a4d0ec4fc36af545315c6e13a184712ea6c29a4aca090347b58c989b7da9b96431c56e181e3d2416b9a9af5a6c111b7545095dcfb459f22fda3497ffe64a4f4efd7d6ad1f5c017afbb8da94f04488670273ef7f3d767367c71ed34b86e1d461a40e9693b457cfe38cd901bf67291a96845dcf73e235e42f513fa92432b59ce5b9481c8d18cebc5fc1a4e507f677910b7ce2fe602205454e68614fcc5d402f3eb1ca3a93ec0671d7b7f0fece3194d272c634eb5ff0112c7819b9fd904f50c35ad23699b1741e95a3e58c33b01d24a7396785393e6aa0ac5549ec605fd5557189cfd4e3c16d1fc252d1ead2f635b5de62ccc423008f92ea3a8cf82c86f8b1bbbaac90344fdc48d6243babbc17a1db56f972a5118e48e0f25581d49ec2d0536079f1bd93d2c6b58c4b960684117cc7d68a178ec59af689dedac05d6361c394928f2183069aabfa1e5bb57dc5d4c8baea64fe0954744087721d07547b525953be803a6eb49757cba93fd43682ed2ca3d1f9c9f65abe5732c72c8639bed89fd409d984da79bf5e6c01ff24cccb6705ab4cd4ef9d35b6d43e67f3c8bfbf8accd5e36b0dd344a154c0a0c423ee0e2b959c6d711098ce23a88d61a1365b673adeb6f05e0087456cd1998b1e624bcb95de8d13925bb826304cb87cd9eec3ee55156242b5a2d49e05ebddbc13977f12139ce6aab0f37b445c6d8bde750da61879b537a71ae0ef5e60c2cf3544fb6a20158d3ecb58d2b55d584c32429b5bb40be0be28651fa420c4e9c68c8bfa3e7fb0011f6bb401a8bc68349883f8fc8756b86145129436bb172eef4c580203f9e053b692d3aaaa9c5495b8881e9ef0410dfbcd7c10a31026823c408a5fd5ae22b9cbca69ff1e848779d66bf89cca4ab0d0281730add92321dffbe60a968607499222d02605ed26cc6915ddb7fb53acc4a3e4da826ca58e0262953061e115b9f29743f0e6d9376bfce902df8d5cc4f0be5d59be8b4c57faad9c010bb48a76ddea65e47d1b517682df21c471f370dc73b8151a7f1a72901071a2557f9cff9004013aca8456496b9ff3a082b97e88464ab10dbe62a1656dbed6e9caafb4cf15aa57d58bbda6083bf424f05f1d9520c392c171d17ed0d82024db7b9104d5f302a1972f6a647bc3f0b29aeafe46e202527345fc45a27d1f80088bb3900b7415e8ea38095728d21a62422899d2d544ab8accd9fb22432249b86e4620ae8180ffc383653bcc1580245f5f6bb2fd945ac0c9103d6148160501a5fbb0201b9d8b26bf2b39baa85f1d3611a367dfccb9fff45e330921ceec74b96ce822a32a329eb328d828d693bf5809170bd8dd957495cb3eea2580977db96200dd26aa39a6d6093abd737fdf4f246ea8eab698bcf957599e2ef5d7b8b7979f35df821bad335af80cddfb14193939b6d3e044e68547b7f9b2f1c765b5a5d796816ddf7f8c7401065f6cde72e2aa4751686bb6b42f761707b36c83f1cc283291cbaca868996b3b0cd53172534f5f2d5c72d6aca7754946447418bd39cbae78b924592c9e8d5852263b0c68745547cbb9176dedd30bcf6964bb486a45ac6de44a39d6e1e00cc3be91aeb825e29441ddb3c84a82402ce47e6bed000d8c810a49200477b65962ef31c6430ff8e5d9c2c8cca47c73feacf90da1df899f4e6ec4f9c101f9907c156a33cde041e40f3381c58bdf6fa8843f7581a0f25918c52bf5d5f488ed974ddfbd2af535b173710d67bc2057c6d21e11c4f84ee6dcbfaa5000cd40878a16b58ae8fad31c11245347d04acc7fe1237266a12d333804381511908b3bddcf4cfc3a3cf95e988f74aaf4fb352fec4abb5f4b13caee17379b92f318c6a73579ec9f47a5020b680714c50bdd95126b30861e97844ae1a60f1ea26ab25c5ebb38383c4f5aca9203dcf5ca7ac71f67deea94d3a750cb58a26191de37b7ab474268ea4f4061865a7b723d4849b0daabf3a4e57233501d039ca043da3f9cb566c0881192777a07a0a77c7b4e3af5c09d5b762e38ea6612fc772d7797680b6b38f53fcb21696d2f93e5e7e2c69a49880d6c74ce2b66f2d09cdf1d3d7c53aaff5cd886254d7a3b5df6d7d76e743183f5ca459c77eb3a3fe1887daeb875a01f7fee4347bf7b0da770b4aba9c834cc1c2e1363f8a19b7dce2c1f04fae31437e0ee0ba5712ef31c48e67b1ed8382aa7769d222465d2b92fd297e5c87ad8728bb643fb7ea3802761515e012813f8c81a1bb0a67bc752ad40a6cb7ae4a2a32b24307bcff5a482b1ec43943c15a672a194bc4c863d64ca73c689fe692120fa85bc6b4a102ceee135ea76b5c06bbce0ad40a209a0e13b486b226763e998eeb5fe8b7d50b7a9d8c04b7a59f39d8157e6c686722b0e1800c11e5f1559c2675340603a927cf739caf48452d13bc2d2c7c4db6db22af11bd37b37ec7fba1490f5824d8429c08bd516db521e66d87373d93ac0cab6e5e6349ad03ec6a5df5892e51474da68ca3ac54b1812b6d861b39a7f70ad59eb5f765e5bb16569122dedbb037675c5993dd664c8e762466f310281485b194aadf3eba4a0125d81837f187b5cfa358f1884bab3e689c02cf07569f013db7093e16f77cc03f7ed202f4261640e3483a3780d7e8d5d152e274557336f6106e5c1ebecc9b1fff3eac76830d13b6e0072802989eb6c3f687e52f3c0c473c7aab3ab002d983e7f7411adf4a5655eeaca327c0eabb308eb4672dc547a8b3536c07e2ca0ef14819a6121c88d0ab8b9a0e9a589dac4158c2c375eec53f3ed7837c36f52ab91d40076d8946d252c6e1a3d931c27d788aeaf63221fdb2ba68e830874630e14e7a4a0e5ad92d101b888b348353e4c5f065d1cdb4373a910f118273b72a9bab000dc3ce0d6b2383d7ad74b7327ac0519f06148b690cfa03a0311406df994e80384905ecda8c76df70b149bb96b9b1ca350485dcda7c3b22ce40f8d303875bb0513e166e738b7fcf324497a0e4b39fdf4fd5b315753d486f0f9d0e5f7ab51aab44602ea583da60016f9fd9909327181832ef6809d6a9c1102bcf90018e46dc505657acfbc3bf598ebe6a83590e05a0e7b40324925aa46ad885e1149054938eeeacea676573478a18eae715e2d2349bc13e1769b9fbd36d8eadcfdf18d3191f3e1d7cd1dd839194f7f2e55bbe811e0311de04041231a88d0ec5be5f6dfd072fa676f083cc5fe7cdfb09f4f6b4bf931600fb42e3727fb35b93537cfcc7712c4616ff65b595dcc28d9e70ece1f108f5dd6f7927e30cc57d487bd193660e6cf705a7d3d6987b323b13fb7668a0d6c1564fdacc3380eafaab12b07b3832dddfbc5b8971b7dbb83583d73b0b9cb7e98d225e5bcfe04d477ad7bfb04cd0828e367459e8fa082faacddb5184b487fbfa7868dc1c37eea2ab013a29eb9295c28cdf915ba57f5cc6ffaf1643657bd7b546864adf50f7a33cda76ef66cd778bdeb8ee7ef85a271b995a753bbd21bd138d54e379c70c42448248cf5698f24430ae70753575e73160f8addc6b9eb25340ce0f82ef5c172fc8f46ce933174cb45a9de9bba6c308055d7549d668b1f876532190bd3d6889b9fdf895a0a2284817277d01881e2c52016b28577b705a4d53ef94cef158da8835f0400480c6a1647e1fde3834b8feb295ce10a9c5e98a7cd6ff52bf1fe45fb60a4fd253894c2573f36ab5815acbfa60205d84487354b27ab9dc1aafbfae3bfe314cbeb5cb3b3f1dee4b254fe9be65d63b9ea43dd89fa131462b995da3f1f8353bff51c668d0b219b93422bc9a7a45b270d6fa7f36c2dcd7f545c33901851d99f742c81f2bb490462d96ebf1af4c4470a2a0c032e47e79935fd0546535447089b8570014bc8ba4aa756de52cf115a7ce7affc731789e16e84cecfbe760f4192d101edfbe76302d98d9a08619f92a04bd89a9bf44097cf8f7a899b0cf058cf52636d68d70448b2b76a884b32e605f4954b21dd7cecfb4be2bf5e5a0012bbc27211e20c0ec3807df12a296fb8b817f4fb8407905bd7fe650e6ae61617948bacac0d0200da59a44b780f6cf78f5b2a81544040f711ac3f54161613634db2c22255552b1be77bb225b5361eae1d3602fbe15837e84a7efa87bd2620ef4fc93ae5c41e1b976edd447de9bd0c115f700dbacd2bcc3d8ee4d440ad176cd8ab37e49b032dd001a66e74c38e4db2d7f04a65328d5daa686c9b260e29c90dc9e78542d9026c0f54f9427e042095085dbb1e1250a8fda3734915c4385aa90b30092101838999990a409561ccdca2fe9378f147aa62f061d5c3602c6c5a664ff608c0bd05877aa435b62a2570d85ceffd404f54523320107a555cf71367c29f628902b22db585cd680938f01aacd518cc9cd2ee17dc8be8fcd6b02855dece8c9a50efab528c1b5d1fd7f2649e5eefdb6426650a83a3bf093f110d06c305a4ea8fbd9f0a4abdc05bbd9606e864068965491759a28224c64303d5b5e6877b2395b57ae66924c2c31cdcfdfd05f5cfa86ab87ee75b2acf48803f13f9aad35e89a2d38da2319727390bcc240734926c29e9e4de5d7c440eede113708a77375e9eab350332112dbceb6ab5ae94b343df4215ac53a12a6697342e48f430751c6f0090c58360dba7ab291b4fd5ab3744103aa162bd44f1107cd8686dcc1fcd5e68fb6a0d2821ce3db84f9792969e8d069c4bfe30af9286584996c256ba109259cbd0fece624d887533199a8348437e32a05a7c25013f3d587ec90ace57681902921962a6eabbebc9ce949f94e61b5269ac1711c208acc4a1ed798c145383194e5b65088979d54b3fb9fe74a8c0c24118021d8fd2e08d667c9b847877c1fb9ed03de08d0f04775ed9ab665c4d85049688e58a8f4eda6e8f7a91b0eb242430480f571ead63c13516527e8c4d60f98ddc3add40b05ec285b1ce4b4a019d57c96dc5c205f919e2d4be88dce5034090ec8962ce0d65888f18b068edf58d94b9e1c663ee97c8764b1bb81cdaf2cf8c36375fd9921aa846668e9b21e06ba7fdbf72b25f87e11f8098ac973459269b074f1d66cdf89f3f209f71c80b8a8dc2a6f13e354bf77bb31721cfd4426fdafcde14c329923edbb374782445fe753f2b95a23b7650e8f98016a6c575109197cd2824797bf22fd52f14d5a5b9d029c380356133925b285a5d56221233894ba075b93773eb944d6fed017e5a15543d8a70f35803e014210eff214896de30130ef1cfe9038caff0984e75f4f845aa7dea4be47f083fa534d3f0eb4a988892321868e6ef4cff45e711c80d2d659d08f8dfd413c514b680492e49df3850f291223114ec71380b7338effa1be70a8a08042a11056959612e77e6f5171e2f5a5612d68e0f372b3785ec794579f25f9c441aa840b2f0500bcffb36530bad7c58c138b9c0baa764174c6fe48dc3689738dc1e4b021f8033655dc0d859e1498746403949195cfb29f3e70d65332fb6c1f3394fad112cfeb95a58579b211450c06d9dc510cd1f25fc35eb1bc323e575a0c1deb66d7a8ccb2d1954d02b44635e2cb102fdf0e803e4b5c335594b4b2c5c43ddfaab39d4a396a71129416a508bfe3adc40d0515ad7d7425b4ba7d40db6da7ca82ce6575d1849eb4fe5e43daba094cbd74eb2b7984505af5074db7bc3e7d5f149197ac578cf8d50baa95d2666c708c78feaaa7782217cfd5f173dd62ee8a2f63ae4cea4815ff793ccf67e3908bee289679991247c5e84487e767105a293cd18b02d99c63144fd75847cf0349f83fe9d0dd2d9e859ee3e8c7ff27ab4016ce6c286ddb86962f9df622622da64019a244fd9fab0d7759ed235f18c1098beb64bb65d015fb5218d4a1f40c00939ac96c53838fed7791242e68a597812b1b9191f8e44750130f59d46847a227a79358c18e658a55e845c4ec183b0b8dc2d5d22ec966662be3d5fea9c7d81b6c57840bfb894c6d0fee372c1daf1fef805c79b1368829c5968e0d05f7a0af8a03ad3306453be0d4ead425e175f96e68e5f44b2f8005936ea790ea96bd889d40f8ee7f21a8b5d0fe7952e50312e44a49e7164593b4defe7bc7acb52e2cb56b02df7515be67eee05cbcb365788aeecf9cc4401bf8299fd7bb04dd32d77693feacbe6c1247efa9d75b8af47bc9d4b5351488d414545397399199c5ac72acd46d4f7f7ac1a54b983f805a677693969b9d0bf26bcc1c2158d39c704a7c70cbfc15db5988cd9cb95e8519ebdbdff97ef2b9ee59b77dba91c4acde54192c337fe4816a2b41eb35bb5f591fa4dc63b4493dd7173741fa3cf51501201ea55e0c0fd78abd6f6588a5107f390bf1324c73b1b872e78dd3443bdc9922f4c1aed7ca419b22079c96c742301d9352875fd5bb416c6828735be1e069e4f4c98423667087215d71fe840b79c19f8269569d8f1afb1543370ffcf2994f70fd2a59bca39dcd7d64d9176eab2ce5274f32273e48e2e6e946df32206f42e79b2ebebd0663e30a5520c492931092e001a9a363813523ae50250843679b882a5548a7a9cc9e0d3ff6b0fb1e9b61880bf3c415960fa5342ac943122c8b4a119cea35ce72287d6fbb934177e667cc173321a7f465c7af7932eb15524acf8a6c8895a1b6663225734502567661bbbf18e14dcc1a1563c25a2a3102c800875aceb87debb9af7a2b7845eee5bbe14159aa4b29d0f076037e3bee6e2dec6a09083acb6cce106ea13c6896ffe986df862ccaf91ec564562e38540934ec2b82fb87e5cc2e416d56621034be65ad55d10e3578016cdba597281b3556ca47210e7d4c3193d910fee32b08a5221eb8c84f14a4a5f6faa6b0e356fb830b79bfc4cf1d8c61a81e40621fa74d55a175b9bb9bfc38a93f3a43cf073ab1349f71dc4d416f926da75f050c3d250790d03b22886db21f432227995e3fb55a9db67dad440536bfafb0485e3e7f8512dccfd0dbc0bd3e1e8bf191e2374cfd95b8510dc8fa2ee66bdea6d99fda81caaa43cb6dfbe01e44f473009ca6d3ceae9de82ad8fb62f512f9b015eed5de79146a70c2644d508252eced904a3ce30e12b3383cdb811875f421e0ba2fd009cdde836aa1168a6e0eba9cc9a143c2b06404aca2510215617b991b6c1c2555b43d4561610d0d1e352e54fe67dc3ce8722d606e33b1def231a2b657a7358edf7a5c1b9f920be70979ed45aa1921eef5c1f7cbbdbf2e7e9818de181706883767aede958a96ac85d6517340ccf3307fe8947888116b67e57d2209efebcf5fc22e0501e956380277b8306befdb83bf8963db3e6a2976f0bb3d196f07e49f11e3a4c317042a80664e35ef5dca5687547fa678c1b678591e3042e82d6f99aa91cdb1113adb5b27390d5b940cf583602a2db270c7b43a6a964b9f0566b2df265835421d00d44db0c286b5632693d7b351f064eb75f429a38159283ba79b7f41e61322a06a5159847c08d482d8f8e28457cd27f7fcd060941664e7e8235d2498323831f274af55b62d6db6e1301237d373497c6d2797d845375a23eaeb8c2a28bf51affcbc165434aa6597f8299761763e69fae1cc677295f6aedf174edfa5cd7f26c2697736cc2c4f9971a5e994f7071348aa9fb56194fc30d8078d267e4a8d4a46d551463e508f61c8f628398127fe4ffa8234ae7e1204084bd0daf347be92421762610ef020438b980848718c86aaf52e10b18e0768a9d3266c0aebbe7a640d24d6d110262460da9773e007a0f4e62cd6e8f12b5bfd3664fd0897edac1ce340e182a72c14725c8de8283a25e52625885925c6447c62a3b0eff80fdccc757a3fc07b7720fca674481b5cee38675799449e5f8676237def7e8d8fed056ca7d10cb95a8929f2f256a4b94863242212cd6e750f3bbb6ba7689f9da0c9df1383384609ba4bb8c7d3fb682d74f645117d17da0f04be326f67d08d9edb312945128f2756e00327683721a05279a1e05a6d0f5837653d9db1970b743719774021f7f0eb85642efcf22eba69d37f8b9521adc7064d4cb4c0c855907258e40305973fdf3a5e6b66e55e6c287cbefcab7eb13c38cd3f7427b30ce54831b27ba0a5b577497655bf4f364d975023e75bdbae7d3192d3203ca5cdff6662cc2306be8f3478ee79c0264a0165f1cd0c8279c4b470e07f25362fe61d9d3490f313fab4b867cb81bc22405c4241077bf22e2f0deb778fda88c0b066d258d6d40ffafb8ef9491c2fc53f2537505b4f31101c918e9c253700441d4151fa0ec5e8e83643c6db90a5322e9015865da10ca397a8dc771ba4ca200426e4c83e16ba7981b800700420a334431735c482227e7145a4794356d9800c3e583fbf0c082a064bf36756476cc1f668f26ba7bc1725526ff0dfb31cb4078f904ec0c1065826bd13fa05aec7cd4163303308ef4aae819e18297c739c8153aed5325cf9966ac4a293767be6d73b9838cb08db30d3b3b8ba3bfe5e50ae65da3097d912c769028e5a5ce43dd0f3788573eb1163fa6670ec2473f34ce5d5e6acb545e1bf3b555183b2599287c2e973d1c17e437283fbc32d7169916636e975fba007984c14527670cf7d7c433a71d29e3def0c23db341e502dffafcf70ece1271de2676f2eb7fa6ff4ae807e87feb86e8e2be5bdbe71821b6c06d629d387cde2346dcb671000e81558cc3aa2e6f3570b4f34f7f737ecada38166e2eb5aa72819cf0334f8fabe3f856e726f6c05856a856da6548b6044ca89346dd3d079a2e886bfbee85b63a3e5ffa4ae3bdc0f62486cc054230244b660f2d880a7e009df1203f2f21b336dffa23b06d14376835f9d6cb11b0d078479c1ae39c0f2ae2515e9b0ab476d5597bf6425ec7fd2c43c18327e76945f92c55f3f96f92b7c86fcbc1d782009dc24d8d1bf8a2e0e7b57de081568b4c2f155a6710b7a4c2b42f1ae244a7e1d413bbd8a6ed7626f15d0ec7e357b547bb87f80d2d9be9e59d45ef73103a656fb540779857e22d5b3999cec6ad0a33f9cee5d0c986dcddc7d46bcf2f995708c69676be80cd8abd578a104b35ed30013e1063d8afb6ee8b794a291fc7b925784b305144cebc0f90b35c0cff66e6fd7d52b96aedcf97afa39d1e5b408b56a36421f80b57ddeb3d914a1fdeb8bba3df525ee73e654096040d03d8da01934f5a17a01125a870b18c8ca92fb8f043da49ee75eb7409bfce09bf5867533d75847be31d09e7f0167b0b7e99b3c3d9ceb706970d2a6863ee65fae6834e1bfa3edfdfeb7093c772ec90b83f9c59fa675b2b7e42b257228eb901bf59ca5ef6784237e4159e21357799ffc67dfc3ce4695c308eb22ba05ecd67f79a1303ffcfcc9ad8d5fe277dd6496670f15861085d8abd84ab1e4c5b1efa10841cf9b7f85d8f1950ac757c824405847961f648c9282c52b3baa366d22c82dabe90093e51a888b515f5cc49d6865f1edaef01fc2c02bd9d12e0fce0070b35e70a1cb409bf31536bddc161f65c7ddb5c5bdc3619aaf9157bfc36621c0c0d00ddc7b0bf702881150abd18db5e9eecdd1e1e8ebde99e33dd5ac05fecb35c5fcb3043b0ed7b977d4213657c3fce8692665caf95fc86f34c2d29966e41bf9cd312b4a87d9523cc2b8b3e21350f8e5d1409e3ba148ae24ae5dc9eee6a10d22c2ac2a3795de500de46aa9e5059afbec9708bfa969bbe9d42364473af3734c51fa6696050a0fa841b132db07279d0160bb387883a3e7f62de1f27209d08fb3a39f0f40de838513accc056694ff287873b102b7ba3e21ac04ca2b8722144cabec38b24a5cca344a7a4b25cafd9fead771397f07d544c543fd2c61d29aafdb4d9f26bfefceaac4a079a9934a2f16cf49bfc7434825fa318bc40e7550b356dd47ead9d5444e0defb28cacf9aab2cd7cfa9cd2b4339c0fd5b6f6bdb460b1c662380db0e638474d066c8aa1923869861c9623d4cec1eda98b5008670220d13910d8d4b98841951878e65a5e0ccf8c896cb8c265c8b06f200122d75bb446fcf90486b6aa9b9ab561a9b47dc51c24cfa7688a0265fcf8b2d24494d5bccdcb848ae798ed0f5efcd6adee45ccdeaede256c7579396482fb981638973d38b4a9b6d5ab89b994cc5f7c20ba11e28ba69f9061ac30ed9898c379c42ba43330dd67eb4d872843ce44f8538752c6d06d1a50e41c7551cb13b9948f0e378d9b809161f9e3039c5d1a383954d633887f3b93f83b08da7eb4a581c6e5fda8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
