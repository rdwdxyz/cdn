<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e23427323ec49d82bc53774ad915a6c8e1ed4afb9a32e3e2fb5640af1f8e8e8198418da76e19c2714597d0658806abae4ace7f2fff0c6b19047ee29422d055905c7dc1b80e1aadeb463eb905c4cb497473764d2d42d51728eb50d90433ac3a9d9bb4827f96e81e6ca485926ce84034a56c54be49ad6539f851bc1a68424eee66df5f06e5faa95291059ead434985b08b3596573072376b5a3332b4a2c5e73a434937bffddef20b509c6c437e693f071492a1336f5ad8cb9928aa9ddf5fe23fc21d2285bc6ffcc933eacabaa401593e530ccf9df4591d94cd8fdbef22a237e8da090952f09692ee5d5a39ba8f55869819c13cef45d6423ae0e3f2e6985b253708a39a0532b70914bfb1ae49679c04a00fad4b6f211f3ad47c0979e4b48077aaf75d81679ddbee87618e620bbde9f7bdc6c706a239743be57c443600fc9979804b26b40ced22701f35624b4198933cf8dfccf350d833ecb1a3a6d65cb349cf008686c48956c808f98b259771ca1b33ffd2ce3b6081108fc1319b7a909e435392e6bc4b52a36a001420d3d83e652d0539765521e2a088ae83d60e70c4e7ceaed5937bb955a20add93008ce5066733446e3ad564d0617ca82323c706fb19cef5b716313e9c866c631e1bd57e209c975c61392af6d514b0bdb8e8f2ca0ba5e695c1df3c036f3873f7cf314163f686301b6372f7ccac7ef84874f6fc8e638c59c301f6d28336978b4af5d77f9d79d28bf06fb0e19667b0df7bca21648a20e612040f7de500457a38a7efd8c2b2a3b5f6b0edd4fb4c5b04549d0019a0fce702e020372d8acad70ff5e8ed820ee46b444f20d2ec2052837eee805870ff7c1365643fd06f26975d92560bd937feba5e5b67f4f3bd9e68ec762dc891a8ffd228e9f5ec081b814404c54d4542d42e2a96a87cc6264ced54301899541980b4eb6f3c283be66b9d896bcd98e91feeacf5c783f848ff9958f9e5a9e8d8862d46ef6dddef06f6fff6c20f5fe030b882d288da5632cfd931a4ef0b24fc60b7846cde9b02ccbe47fd7870b1e7def6c0f9186a2da16dd6d2803b2330a50021f6ce67fb3d05298e44a15c881949640ee8d1414f0afa53392e0a8dcdbe06061f6e603456e74f962801c126442fb289cae6738db2ddb6935481b32151f480d043f7855f923968653c4ab6f82b5d733cc09af19f60b0f0b53a0a38bd0f5a9d867be16d684df15bc1951f6ed6cde79078fad6a7b37080c44ca2720d8279ff15b4b90db494d51782053ff002bab67221a10446e5a7baf50ac35f6a5617db32a1496e04b4171fe47078253a5ff9f1fbc1e585724fdf9102f605ef64206bf0fe68b72e5e01679d611ddc6f3223ddc3b4a1148685631d18ec097709720771280308d1742d9df6902facd0423264a15f709fec1275088a601d576df323d5dc857afb6e0049f2d0eb46d8c61c71f731324428f786826ec6cff803c963f2a79ad81744b30e56276acbe6c49c84a738917e01d5d45a5e5d757d69ff09d091de43cbc2d146f6f2e042741e505578a78d1c852b820361426df75535254f996d92dac6049a005af944856922aaae9a0d28ab0d43b8b4ba99220621452880aa7ee30ba4e32002561fa96390fcdce156a6c2a77f7b8b92f73c9b087c4ce4811ed45326e6fd97084dee0eb660d71ff0c00a5b279d5b325ad34363928e3873e8f6ccc00382614218747a4fee689b800ce58ec7ecd07f670f40b2c257171a474701704e11795846c142beee58170c099f616883cade41f6a6c013e2720a6cf960087f60639148f8788eab1d06f52095ff367bdf73af8aaa4c4549e1d346423cdf010d9bac83b55cf6ec789e41aabc466f4e22173578ff8cefe261e7f6450ef717286bb0487ba86bba0429424f15f022f78bdeee90d0f943a86575353e9d647b4613ba84b4e9ae8ec39284a77816ad38eaf8c0958b79a82a25b64381ec6a6b76c72eddd3f5686a6dc58fcb378290125bcc9991e8ed00bafb41a343d8a488bd17099c8de28851d1d33ef4c7d54ab2d23195b076837f6017f629a5f0603e9ca259434774a5603b28b8a9f722dc96afe305b5576c4be2185eeb536b9c4cbd181923a726b2451254cfd51ef82d89d74523c8f0ca5acaff4c644c97f6cc71ef343e5f73eaa99298b3535c8cd154121fac81295f156ce6dce86578e0b101f2d2ad2014755489728e145d7d1073427a9eca6b8dcb6e8ac626b4b6d01c7e928f9a3d903fb820307b54f877ea7f63c950e8ad903402716d4465fc7ace7c2ff5310c257d89919b55120d1e0446336fe53b6157f555dbc3725bdb2f0b2f6fabb06a791fdde0cf9793192b3d8be0b267c3ac48c33a9fb042ca10446bcc44138caff6675e0a5cb4d7c0afa6ce193789a88be38aad361ec4ddcb37d0a9b9c435538be7cadb626a60b275a829d3957a3db515d6187099db1a9233620f3a37353f20bb6c8548218340e0ab5fab3347739a561a9f5d8f4253c2960257ca570aaa107edf54634f0698458b4b9c452cd7e0337c70e75140084a7d4a3287b68ac29514eafa450a213efaaa1f29ade00b9997df724b433e57ce3ea08c23684458d0d85133b0921e3d953c9bb43295394b2d9f51bbc60202bc11eedd11de16c82c2283c579f234afa94c5a98fd83be9d941a027996680ffa65af71908d177408c09fe2bbdd9ce74d82e2d80802949b05a27a60fe2970610400e25eb1b5fdbd53768d335f63d6116c351e59220743723d1d958d99e96b57dc261b711ba98d9dcb3d4763db1d452535d27a3ad15e2e14ba62a5c287fd315c351fba0e004f628e5ea2ea1319a834ac85cc5e27da149bd9ef570816e542ff2b1fdeae17384602741b66249005df286cc49a758eea12a497f2b0d99eb9428a233303b232f97dfe37ace1f6fe6ed8721c0bdc721e782b4b18c4b6596f999f5fb829827feaa50bd38462af20ebb29b1d63682aade5ac33a674003f0dfd10a1f2e3328ef32cda189707c4a84dacbaf17970bff2a6507ccf7b7dadd2ef68c9b66db29e442b8729ee12884a674cf5a7b34bfb85fa9d4f08833aed0d3bd120f593ba9f9908c065717d99197b2071998fb6706adfc23fdd4d8eb749ba6c873a33c01a8b557cdb50f821b024992a6852e0880473f5ee41abdf95198a7e0ec280bfff9e5951fb1f8cc231be31048be77297384b078d930f99d23f817c1be1c30eebff63db3d5a86d14e4cba8d574e484c97e7b9a12a341e124001b95ea4ad9ba90261eb8bab0613172c1831faa76faf0287b95812686793dd7fee0106a24f2f0ecff3b0d04f2a5b5eb22e382cc538703199e5340b5db1505deda85b7821b8784e6024e806ec1a91320d8863d0a387b38599f856f3c6ef60ecdea62a72d52c54076324f92ab1170949fc26b981fc7614e2e5b48d5f73afb5bb68d1220aa8d534b5e93f270682868b4cecb99f6baefae011d5f2a7d0e4bf43978189ebe42b9bdd2d0f74b0ab5caae9814f02b6ad74139683bee7317dc756f6b5b7ceedad8b8602cd6547269b694bb7b59f0b41a832417556789e58fb2695b0909cd61e9315937c82b4e62f96cb68b5d305c6a949f04749b0f155069d30059da5fc5fc919f3a79775254ce4e8b1bbdf2397ae0607f2647b0f518d66d30b1e42a0567d6c3b76807df18a159b0fa64a834969219dfc1e1195043ef17a5f6521bdf43869f8f4517fab757590837421df51d2251be653bf34d432e8beb8d24adda3ff3c5fc352cdee4b06bdef221b7c7ff81eb2aca7e436a23665a91eeaaf123091a69d23eb81c0a654dbc2493fa1b77331d5123631dc095d1f3fef19592436292f7cf832b9dc6894ad909001bc627dae4bb788defbed828f6fab777e922b6c58d47522beafb635aa9ff656cb30c7e0d5cc2284098004b3d10280df0a90f60ca01df9d330c9b13fda22dbc0d06a1ab2eb5e7b91cbbbb45fd5f215e2f14ddc1ca6e51d84252b8d8fdcf835c4deaf857fe39559a06a257fb628b0c7d3b3d5ec3b4048bf329908cf248a904563a3e4356969317920b4fae5d1e5fe0137703d930b8a032186f486e41d0da0a66eb05592c8d6689304be0ea03fee627dea73c976fd9511b324e575e2243470243e791f791dd8af11c8e2a0920abcb4b6f02b63d427504f1a0c3c766a65c38235d520508afdba9fe20abfcdfb1b1d6845ae64986c196e3e139adb1a1bcfe7fc5d0d75f71737be8d8a0cf5c4a8fb1fecbbd3cfbe78c4932ed22611df5886b11d09ed3af4d7ce0178342ca7a655eff9177e63554d3de5ac734d91872dc539125994ba1ecaee568d884af6311107588cdd407ff2f7417232d8fe3912fd0e6adcdf74ee5cb6a1d4251264365fe5c5e74c078089fb204b426af3ee0f67c70372854ec458ea3b94c6e5f473c461963036d690973c318be656451b2cce8c600b9a68f3f2e21974f2c9511e9758713f0f3fc3f50cfcb586dc98f12f1005226683953aaebfe768b1a59260b42eff697be9d2a0b9dfca605094195bce8f878b3442c96e71a0f34f23a326bd95252bc388c188803a4f93d34ebbb62da4ad9603ec38f79366407e155be6cbf280db8198bbeaac201da7fb5231cbf4a30093547970785864462a226b55769a778438fc1a5ebd04fe5ed76c266fdea621278b6bd98475ec96adbc3d393c6a99be14c51b3aef32737d5e764f84bfabe89e48ca779e235a2d858fd3e68642bee37803535d1d11baa5e10382531f6a132e52f61cadc01703dbd404fbd25f530b52dc6e384a6011f7013630f32164f4418950bb318279991a34ec6a196cfa6091e3f074a027db2f7da6fe844e0b875160c99c1452d8caaa94f60825715904d105cdcb70e9d1de4be031c067947a67e37f54eaf540b2d3e3d9e15b8658e978f2f680b9d4ba6fe7c0f8f7ca4658e34c581cd8b0e3dd8e776af2ba599091f6f53797ade7f4b056f179a98debae18b6d9cd79187326d938e336f73ca53d99d549af25dc8444cdc84e193cf3ea7c305064f8320b7cb7e92de257af1855cb079cd2975387a0d20d705bc327fce40919e117f6f17040dcdfac6afd21fea458dd008a281ce017e78c56216483e3596c6d797046c0ab737c82e069311b78644ed79cca7191b2f19ec095c97ef57035ebc703f5c76d08d63cdbe41b91f49eb0c4ca909737d4a97ce3d7fd8aef76db23848d58b406f89537bf7a379467195cb84f465e7bee5187a67d86373d2d0a91c2a84482e8e41f9a1c512826308c1037ed6c84772cf6575a28f4d48736b9a3cb16f5768a2e4ebcaa8e8a321466180fd7ba50890d13791d8b621dd5f74e1e7574bb61761c524c37d0a03056adae22c52373a98b490c3869c8853442c46a9f5a9660415782fec39d60a4959164ad49c25f7aa6f7fb93a4277e55407c2f2918ba3a84343b35823938acacb724d2c9a5196564da11be174aaacd9a0203e4b95957e6953d5a51e44d612dbccef4a3df0d3e206c0658dd56368e5a76a3846e37319a0f0253ff43479eeda02d7d03629572076e99d63ad47f3c7272915fb880af97998bc9db90c1aa58c4d32cc0824615b0175710e4c25ad815826342419b43a0755fed3759a196339aff8c6ab8b392ef31465c1595f510f3fcf9c014b802cecbdd6d5f61dc57ccb4c748587ced52f0e24b934f6186b1f0c4fbc61b3ef63c71f77e35724fc0899ac3a9972e83b8706dbf1f49cf3145e839cd6033c0e2ff4e25b57c62cc3fe0be843a90891c96481090db19ad3fb44766ef079155748c10f946313aca40fbac255813248ca83bc9b21f15c351569ece496fcbdbe62a6b34ee2be53c59e73df5db26f6419ff924905db99cdd0d305253c0634c3b83afaceaa1e3225c0616671750f8f5e2c7a5bd32380ea9a2f634bcf9ea8615a81cac310c7415db4c5a747ffb7378e1ab687e3b707883931e168b97187f926e9cf376c5e2d625d6af259d52ad8c8527d219e98958c3b3f5c1e9611d6190622efd7a163d30683d33f6492a9531116530860401d2ff35a449a9954e25eb44435de6c3d3a19ed60e61bdce9edda0d57a1116d0c5bb914e9be370955a8914b4f9ffa1b38e1af071e96bdcce7fed13068c7443cd5e01bed1e23925d2070bc1ebe25b4fe81ee68977dec429d797c1c9f01b9b133a47fb0b8bb7c708bd00283ea1991b87c3625b6fd5b513af5fff50fd27f0d175f13d0bb1bcdd5ff87833cc19298f0873bee4d4d050af94b6cd64bb8950a612246a28c0bf96d59d726dff9193553deba58c723b5f9bc3a3bb8224e9c329514ff4ddc65d89c2d606283ec0f09ad24e19247788ab2a7a28aceb99c765eca6ec1a750881a7e7d4fc48720487cb591d06bb35fa42ae0a26de983c763ec2ee3753cbd8f43d8bb017c6f01e505c2b2cfb8fd3fe3e951457203f4aed56cac2cc50de4145cd2e572ad9a225042f90794fef734948170630eee27aa29336c5fecaa95ba487e2ed261c70bf2155852573fbe64892a37958b5ba574f863d581c2e817ae597114b8dece8ac904e9b1cfde40215e943f982ee8ccb7dce9eae6906c69e0d9ef9101ea885fe8f40628ba15234265973c900c1cb8b431f22e66d27186572ebc6fd4996780bc53fec78524b1492ca8f89ba2e7ad72cb379d5e11a4160ee1d52be50165c7bf2c46623d1278b003897803470337ed3950e80392bdddaae89eee2ba270930d743ef15b6fedb82c87d6d9f6105cb06c77f9b4989d85b97ec32366034d47c1673fea4fe095bf6484d818eefce78e4ca7b0d52a42e327bb7032b6374fd52cf7f27be410fa973e9525704bd7e13623999ce164f003fcf305204ac1b14706ae339225bc79fdcf38143a99114324edfe7754e794380745c072945a4b7218923fc4bac3b5c9010e5adfd5d532f674e402fe22250c6033113ce2e4e031fae8f8e7380b97bda218ae9781db3cd6d781aee14b0b1457ab04fef432cbc746ca4d3e3ec1f4aac8c1727ef07326c0b9d6a08a9eb54c492b822bef69d5fc1b43e3e534d6cc0f04602d59284d10c942187b792cfda598d77f931428d77b89e9b71ce6fcfa87579135917821ffeeffec5f3ed1df1a47ef1145a32554b6cd11b80d6a6911f77219268b74ab6912753b8f5e0379d55ed2dc4e18636570f5de342e64fbcf2780158c8f908ad3318689ad9f2be4f12ba52230ce88872e99529d5265af422c319ec4029f145c6b1dbfa48a1b5996ffdeba32abb42dcd0d0c347926e5c52e7a85ed570f5349ffb30948d09deee72381f8b31c86dd53c8b14a9aa5718d5a4c02914a01223f4a59a61c4b24444a2a688ca1679f6fb7a8679b675f2ae31ef9fa0c7e70aaa993efd59c46f0207c94aa89ec721d597c67a3665b303fda6832074a1ed583c0ec7c1bac380ab0b2076b867853393aeb04e16ba9c971b62f4b395af5c6801a3015e5654ed03e99e47d5de4f724e9b9e543a3116a2edd9a762e287158de229d5f232bc03fb76c70f53d2ec20238c1373908249e8fc613495774ee935d12b70dd9210930a6d4786b7b2e8b2cacedacc544f2b71d0d3553c660fa7c3d0bc11be8dc9ce870ca8263e749b55d15a441095898fd7305e23ff9a6b8509057ba2424a8b7237346697cf51f6ab560ecdf8043546c8fbc85b7e928ea424fc10c733ed46172a8893f5c0b60e6b99a33303529da83e8ea2a995b55f143ae10d0f45a2970ba529201fe6006199f4a278a59a11b71ac0dbee724cad61682ffa3b3fd0cbb6a4ade336c1087c40bb1ea4f57ed4d0994c16c6a699c241e7b90f41ca526bf29a2f027e87cba458883412056bc685371bcbe18b8fd314c5fb926bc891f1495d21f2366e325ac4d5ce799e708af9d71b256f210e7faad10b486bf33056f2b8d6cce8076e65f118bdc05007cd9d3c84dcbfdf50550f95b5044819b0abf27785c9d6877182edad066e3dafacd09bd44c49add73e618af84389ccd1114dc229744b762367f2a359c3951f371546b55fc2c6ce06a0e80749238775a440e9a2b24117f7201979912469f914c6c8ac8fdfdd501543cebc7a554ad60053fe36fca0d826597c3859001033674f1f496a1392584e5af351c734dc689d6baff44f816d8d2e6ddee1a04b1b776642741b77fc76360c926531760844c464126eceaafde977880c89f5422ebde4b80b1c53c99ba008f1f0be7e5574dd53db0922e6c652fa5002080dca12941eb1dd791ac579e1ab0f9ec74398d8224ec7cfd7f78a4264bab63c72c290b4ff68e9f3da50a63195a89cf75dc3c5ce84706da4bf45511770e2f6cdf2d74156a1e7721d7bc13492d70aa311202f6abe00c3287b56cab1bc8457ac62de03f0f909547791f40707c9bd977a5f27cb8a21eb1bbd2a9488c3717e2b10e65368f5357c88b215772ccee59e42a2e20bd7d031bc21c07d9ecc0f5cbe217365905ccd1b68296e0676801b1dffdf1353d89cda54fd0b7594377774415b6c033ed53fde968ae3882a929e67fbaa599d4287bd10c1a9833f57283a11e41de33e596e5ec698ccbb387cfe651690b5d40ea85a8e2d08a642ad42270f71905925c86493ddd2493ad7ea7a7d1595ee9ac3b45aea6a980ab03387175fdfa6fd67ab2cc6b44c3afb97d6888ada0271d7675fd1033655fa4c2d64e5c741760bfbacde50ffd24914e39aa7aca360cc69ef03c11a1c33ba0610052ff740be25db9bcbe88d9a541cef97f761f68a58beb5f9be357224edcf92441d44bd02b8bc67fed4cf75388a047f5e4aeeac402a41b0e429d51bf2249c9d1509baa90e1947ca68212faab1f854208ed52ef05af7d6272299cc503fb8dbc984c1dc33da40881717a78648f2497620e9060c218df8efd44ae2b139a965c456a014fccdf7e0632054565bbfc2762daff074c3ea6456af039c7dd4572ae1230a32fbe26b8d3755c6f9de41ec03194d2dae595611eae85974c6c8fd40ad89684a4060496a5e0c9518f8c2c12e2a92671cd161e9bddc0ef070dcc3e0a354324d76112960ba7ceeb0fe159a8cc4cdd0d9acb96f9d738e38afb3014a67615badf63c1e9af801db819d318a673f4771564bfc82c8c4f7e7c8497f3145cfa9cdf520c2a4b5e6364bf00354ab72bba5f5029341bffc9d5b3e9b81067dd6a48c89b0685184e0ac39c37c88470ec1965d093232aeabba8f31354d16543e10162b172cdde9d8ac9e4796f718bcf5183028cbbf7a11d79a26943cc27b7d1d30c8e59e88f99e33129908b270a071c2afa57719f01c4d5a4d633f1868c102ef357933def6a21ece300e9ee837aa12d220c582407647d32d7fe17317a75a57634bfe6362b9d3197f60d8472180e9d940c64e6330509478b2c3aedfdbd2f7cfa167eee0b9071c753421759c32e3bc3711612a17443294684becc89d5c24975d4720288ccb3ee5fa309aad0b1193bce0afff040863f6c3525a53636ae8ea0c7d38c3bb400c90f57bdcb1d98eb3de6f0d2ff4787f04c03a4bf2aef8e0b47f679b18f51554dee6703a82f5adf7b81d958b523dfd449e36f8f87d84886af72e00fa4715140060d6d6754a740a64658c5045988a5a532d9b0bc6e14eeb147ed74126f6c08a0df3df60a513161ede70371257c5a5ade092c7eef50c08650bbd737df96414399b2ba304442ec920ac44c9b0538e78b9d89fa187f8579ff4a0c919b77f4254fe0fc87da936a223cf187b4f725549ecc6e81858f0bc0cbc21c44aacc751b5c23348d662ceec6d7bbe2683fc4f257e70701cde72165bebf0489519c6e530daa4c79e7be462cab498a718a7dadaf256ba6ae1c984f795ce27640e28f84b474e88f0de356c1fe07cc599692bfc60627d74a9ee715537884bb21e4ae4631d61167d5eb9e8f836e0e68de6e0c09620c379e1ccacafe673e95c194a1c441f28e8abb0f333e4afbb2ff1897c7df560d51b6eec12625687a9e37b9b46f8d28182c9269b8908a24467f44a7ca4f49d7de2a6a0aed8d3d42c08ac1e8acef0f61fc3ecc10d1a1f99750bce44efe4699f63b99a6c1ac6acfb4850e5d3edf45cbfb7f0418c8e5199cf5813585e3d61baceafa6d3781b71af8b8b5c60c84f5141948bca42bce053428de6df60a0025a1d599e66827c60200e2319a952b5584cad86a91d1881870656e878e8ba45f76a8b02a82209d16f9c4c759142f31fa15f3f48783d792bd58e720ca58b61e5039443ba8558dfafc12526fe63c1e0003c96200a58ec8b1d5a2475a18ac9653823d647a2f60fc0649903a465c2b8aa347bdf711336e6566e8faac7294389a3e16d541929d39d92d131aee5b51b3af5d9917b2505ca366d05c317c18eda9806d24d4886c43fe97787e9862738f259303071a4a739c38a4dad3cdcca145d8de75afb0596fcad1b9e78b268c68607a8e3680a0c6ce490f2f29833063076e1661d3a4eba252a70f565e0e767c29a6c5e2b74d1cef9e2c0f2a55f03d8daf9e92fc6b06db912b26d4355a927782f9dc6650b0c5b2f8deaec47726844c0d67bd78f5c29550c9964f9ff03659d7ce3d14c0405336307463894db0fb9f6f4972ef27e7a9be2c688a5d44fab36be1e71b2afd7e653ab978c6224ef0d9f69556bdc8cd16cc81229efb860fa025d685a80268ee4d676fce84541ce664139045e3002b594571a60b4bfe27d824575c048db969eca1b258871ebdf91ac631bf93bede3a90d79a126443227bb8ed9e1dbd1ef975ab564eb9f4983280b769d44fd268a5659e1d460d993c1f1e1a51c9d53bf44aaa8f020c25d2f44ea59f872640f61d471edb4e0d49de912238fa4f25889cae1668d8fa7da6fda4452a6015a1b838b1009f772c0ba73b5d6535a1708af42c855d6f087ead3d1590fda2476ea1ad61d74d1c5a67f87dafc5218a13e567819dc11788877642391d139637be06272405303d3b04ed147a906866ec17513af520fb2585b233940a3e7060cca6e1317834bd54acf2e16f72b5413e1f17b139abfd951ae55138da7a2c3a6ef07d3bf265ea7843d1ad92374cd7d61032f0de064c5ade291ac43d8f7325a89fc91cbe7115f18b9ca29364379bc8c887c545cf0ac6159490e2e6b56ea749d14e0de2732e0c7859f2974340a8981abcffaffe1f637cf5c621c8dcf71e1f3b3ce00683e0996d49a601b1cec546e299bd1ce980d76e31f80ab784ff446d27c939e074cb79bf74b7da733bb40ae25cd1c68bea8388c061dde7901a13895f17e81a2eb1bc189a43aae89a306895b33cbf129b32846baf51cdfb5911b7a25cbcf4ad99a1d5ab718cf90f9c02de7c46a67c2a9b18a03b6903fc1b824d23a01c3ea3ab840916e12495a5d4c423a9532c0d13671b39496a130ec7aff4281412a0fc0883aa1034f633e67279ecf1c32815c4a33ad31200d05509328afee5f211ce0de3f5dca86eeffe4a4f9068553e778b57b5e2755a77fe1745dffe725da143011e27512a81d16c87cc9d3e137790499295d39fdba7f43e80da641adf497aee343da38ed3ca8fbc61ace4bb68fd6265ac4463896cbc7c854040c5f48264d3ddef5560d9da6722c81bb27f326e3d2098b2fc34e06dd8f7f0d8ed967bebf1e516bfd6140503b4ad3c655683ad5afae7b741747e47111c5b0094825a9b83c53050bd8782b1df69be60f5c4c9f0980b491dce634a2b41a995f9668d68a5394ad83d76e8c0dca53e33880803e854cfcba9a1c8e08e8cf647ac6677a0f3642799ba59f85facc6ae9693b9cc2763083a5f85b00aad582a2939f6fd4b1cc81337b73d5643bdbc1b94753fc7e80c0a755154f0db18b16653d3a833aee02f265af0d4fb6b83acc5ce5aa8c3d53d4e91b65c091d306de1c62b5c40c20a080648039e06ce5d5513ec9951122f83e1b01132ed73c934c5b89141f545444db03f900b75d76c456367d52b511f40cdfcbf1f0764a254d2269ba0c50681aa369c680ff19ca71913dc5df3a7a72256570035e8846f02224e075ae5096274bc827f62c1c335cc38b0259a35b56ff6eac4cb765476ede9af4e1f49105bda6f586f3b69ae7f13d84ced60477c83076cc713a0e76d54a60a456142cbf366f0a94be216a36fca25cea94acac5cfc07cf289cc2f88a03a7dce8bcfa6210b8351c2e683a6fcbe57fe03e0a0402dcc4a21a61da0783cef85a2e48d5345dd38a2fe9d2a6981bf52b996ba19b7d819b2daf024889155b0467d6271c5e0c104f289a69b38da9012b1e78d5c74aaef422d20df605eb16eb500feef2b7be63e0bf8e5d2aa15653a5ccbe5e2b00d1f798e37401cda6b67d979634617de3548943047d866aa511af9481a6fa1e274342072480234a59d5301cd8437a54198b154a4e307dc0ee2cbf6742767861393bba841222f9ce7b4077c92a8fb280379faf635a2ad4f9575e6c2f681364d6a1c79f80af37ce0ffad1fe88781237bd3a78d8be67d4e7b904f59f4783280d948f00ce34ddbb2362e0081f9e028450126c5fb992ed83e93a6a13b4bdafa840ea26422041c7512550266d660e0ada46773d91e2cbeed02d8dfa613521a0e031c43487e4e5eecc316fe5a94cb10c0226e5c2bd6cb2be5ae5876121d01576c88e3dff93ef1a42574a6dd22f7384f8c488ace8de3ab41528f7e0662caba2ec80099266c0574945baaa377ac1fbb3323933821b488f4cf8300773edf37304a02cf3bcfea0d32047784cf94c8b692ac77eaa04d907f465d29ebd2d76e11a4e9b11868674584102395cb7994b40455ac7ba04609720177077cdff723df6a25cbb57f1bc679c79b285c457f1635295894ab87e00187cae8b662440aec861941731810842f8422b3442b2a0a70e21b64a74f41fac310e62f2fa10925c0edd3c17be8c135bb7b17410a64f9e3fe6dc85b14bb6286c281fd769d598e9912a7f390e5cfd0a5d500fa149f404cbe3351b0c0de1d39a30fb980247986fa464a54bb1cf09b65dde08a3c2424a703806077f5cc3f7f9da8aba682c0daaefa194969713e20d93c9544b6dfbfb075ec4e8337a2fbd7cc4910e7703a1d52219ec1b31bb874fb1ed0175b3e3575d3996075dc7e2d0b58cea8d78d0beb98003130875586d7ed7a627eb3be8761b90105736f0e040de9b9ad82375d46d3a3714fa410b2d9df3e969068397cf06ff7da23076b1d3e1f881b64ecfba9540d707ac3dc528882e3bff4da16ea89ba634551d10487e73df1f01d673dc708fa25d85d76926299d6f857efbc70f4c66597118d52ee0be323481cfbeadeae26208170ec42b7ed612c4a84eea955df0efdeb7f9497b1f40935a3667b7875108df63aa0049065b1a9b981954f55921f03892ea1b697b49853e498d3449a6333ad96dd81e47bc43018f0532f453f36a4ff4f9fd482f8f3650931d052d61e26dfbfd1800942f6d3b6b3a2fd362c26bc58187fc65d703adb4e27aa5ea1fc775ea14bb2f84bb4d881a89aa0255901e8578450bb48f13ccfa5011b6d0804556b4fa8914cb15e95696c6d04e115bef6c539fa91e0aae4bb99f0a0213dd9aca66cdbf70427d6955f1884d3f74539de7f3598b9fc0b5f02b64d073733a5c1af4112b9951940317c450912cfba82f91b45853641b0ed1a109db293b896b7307c0437e8070bfc5a2a609e760c2534415e373066b2812d7daf2d8c69024a1b0de4596724aeadb233e21469601a67cb6dbf447e610d3d5ae23cfd902b12459b9e82f225fdadd240d0b5e1b8833aef05be5c26dfd342a773b39b20969570fe663a3ae22312e6e6c0c702df8392dbc0718aa2ce22411652457302a2002bac4fb2c155fc230519c37f4c13ee84bf5afa7a680ca7b4ced22e24c800815d6773710e7213b4be6d17249c22ad4e08efa97a00c3a8cdf2622c61d88e4fa19c6e87be3d32b0c3111c097365bb76a2dbb3325f025415b94905720037bff1bc6bf28775789c20e4a3e5c1a30d4e526a1ea064b310f013a0651e852b5b000fea8fb80e29e7e1de1a12019ec6c5d389c691c24a584634ed64e40edc7b397c56d81ed5db646a0751ed33b1d7ab6dd5c2b988ae0e7e01132fd21adb65ec7bd22e7b22041f6d83e16eff3809f79aa932bea092652ff6ce84a9360c121fdbce8ae618c52658512eb52f6f12d00d9332c1a9a1202fa777edd314144f7fbcad8db3f3fae185d7797b92b59806adb0944e5fbe8dbad75390a717458a838c82f3517987ea5e72c1aedb980b07460cab3ae569e779c3e93320ead9f4509edb262c4ee3fbcd5b05c176375cf046e51df280c3b48f1a6b75db843023702b191374668805efda7f4468d28a0ccb839670978697115ddc713a1e30954df0fcd3c51fd2d459c535a9199b63ddc84458ec9f049b766389e7f206a9f7e696d52da78bbd235013fbe2600309c7ed8232dbdc98696216c43a09d6f1fb7fcf5964c8ff57e59163e6a3b576488cb5673adb9ea6db398421fee7e20e46c486e742a7bb1370a10ca13c54c5523508f657485a8b0d5f77b92273d1b73b4c66994f0a056c53a1cb3f4294b81e0462f28c6b4cd04822b379eb5361245e8520483eb327e46c4efc999dccaa1fd3141bfd4869a74457a9cecd897b04319a25b7ee8c19cf03a7452245504aa6f9dbb3c1e85496cfab96348ae02cc21f7ad09e735258f01bf0d7636b4b989b406bbde36511b72f8afe4d0efe8e3eb66765f886be7ac13e6caeabe0be284c0e1bfbae9ea39f45e6d65a5738bb691da36f2275a818cc80c375a9b4e597e52e7b1df0a1f1f9c514ced8e7d7fceee1372dbfd2210a9cc68426df00b492af412c473de047ff1471ceca396e2360e2b00951bb1140e276937940deaae7eb257dc60f8a2c8cdae909751b3e26d0ab5184fa7b9daafc13097ce9650c323db210831a03ed857ad749d3ea90cd5196533839419570b01c04f9f3a648a674ad88d079ae4fe96db26f242e4711aa7d511e681ebcca3bd4138b262094c72f7340475ce1691f610e8ee23c356df50af62b67ea279596730b1c6ea290a2eead279532ebfcd42abebd49cde8ace5daa270f401d45c85d8f295927b1ed668a67dbe9547f4811b731e37a85ff9710188d374fb8a032f9fb7c08862cd16ed4c908c677e666dceb3e7eaacf10be0e71708554eb3d4d4c9537349e7d4532832c168fb8b6a904b4a96dd9fb59f660024d15f1e28efe49a2f74faf4d41beeaeb14775f61b8927fa6371eb969ba413a84ebf3eb6e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
