<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d20dcf461bf43eeef844501ada4c59f744ff20565a7ab101c6c93979e39c931b9691a18e156bf188d38346b5f867c63fd2463e407b37a7f273ac1ca73c213516502c3d6204ddf875c3ba8e0569c49ffc9c97635166562d58be2fd721c8e5baaab77b3d8e44956f704a3a3b6181c6b9aaf6d1e4c417e1bd0b8d358baf5f6dcfc0983e360496e7d08d6fb81080bb2f3c3c5c9d8160c6a5e0dfa1d1768017d5c90062507d14eec466069e74703cc5036548ef5a0d8f20dd63ffdde7b855ad5950356a9aca1a32fd2ef37982062f4d68b663453448c710a82b59b944375fcc630088b3209e63607810d1ba33beea9b8f1e18fd73e2a201d31b374417a77867f2a88b613cd2929333677a23fdff8b48ce505626371f0de167f581dfc5dc1db89fb52239292b93a8f9124af1be1384919f78f05308ee1cee1f6dfd1b35de753a34e730eee8935272bd06635bfba5180dfd14363353e12c33a811e9633559fb49e3ca3e9bc5b7125d8022712a49a9adb2d1ec0e0c9eeff3ebe72ee1d324b37f01b19c1a676ac13da4cdfc0d85cbfe9cc7bff113796f088cfbdc1b6313d7401d62280c52e5f4a27cbbb9c854d8da7c7c224a7dcbf21a74349abebc050d25f038273fb792ccc87ae5120ba64fa8d4b6c96eb20ada7d4df09f3792f80e6a7684800f5c51fcd1647853703cd7bd4fa3f9fcb82716c851021bdd3cd8179ad4ce1512d704a41b639bdfc41fa6553cf89db8af74e88def963fb51c26e65335e20e4438067981f4255d19533bc469df10288fc1e54ae17d196c34969b052c71465849fd8152c6714a8ce4a54ad6ea04bf364737ef9ba47741021072f1d755ab8fb9ae681ad0ec0e351442595783804da78a1d5c0c4a6e320454740ff05ce660154343945242860749d413d975626d85a48e9a3b7fa9332cadbda60cba234affaa25c937c105b2ce1c99fe2640893a13896e6599dd67e497efc46acf3c3006c67d415ff6bca0697e0f339630f590cc6b14fcf81d52dc9e36691273e8dfe23983f8600b08a45995159be541ee182d6401652b72852fcc915901c39746558d24e957e631aae853197fa1a4006d0369d1f5f7e377cad7ae9698972fe09b46640da5c7d398815d3e07b8b6fc4cb81ffdc28284676cdc4122e7f55178c22d1c724fe76e0c800285bcbe0d129574fe0408914906e2a3d3ac269b0217c4b2595f8adc4ee8c39096703756a9b614e8cc80b9987cca63442d90cb1223a550bd48e09f1aa52124ffea1e2a0c03652ee75c73786845c8abde51b68dca24eecb5634baef6bfe768d1a53bab3f8bcb725ac75a7ae3f272e44dab3dfa2c1446c75907f876d1a1d43e36c091a7912f52d9d8df3eee4730ca8b9e5895d0e0867a0ff1a0575c9c9294b31cba148f89bbf605ebdcd3d0576ff105da0494455f051fa776835104e09f645caf77c37c31eedfcf0a3b75308c5a9a27807a2104bc10c48b2c4a46783585226d4b77e09f2e8c9613dea1e4454111a27fb6ab376e30ac8e28b28c607ee9c0e7eda8d10122041fbb01ed6d7d41e64737aae1ea4f500237a898b1b937ceca6ac45bfbfb32f0f2d4d6d2330623a37524e71bfef594332fe4859cce9c457904cfb3873d4183112bfbbf90c005d28966547f95c165a7cbf017612a87edb6f4ef8cc6c70c2ee5474dacd46f567e646873d175ba1e54a1d9bc037795f10ecffb4de0d14eb0440798580f6be70e8433f9a206787b8b147a3b00c1a2160f39aa206ee570314609b89224d0056b1201876d8f269a91d6279cabc03f69518b9a373acc18ba3f41e583633ecb4126a478a4f4ce454c2e1ae8c167fcf108e07e985418e634400693e356f9cdbd809e3dd675acd17b100056e8a80ca3b8a9eee60be2925b8c6ac7b2ab507be0d46707b50f275c2915fbb7ac52e82355a6504878c5ce3349624889b8b12174e00b95140493bdcce43fec83401580d7cce084063fe6292e246e88f14095e05f4b2bc4978993f0f51c8ae5f6549d6d2a66ab74182e91c7149be2bf82edbe8430bd7f801c7cf3bb8eb51d578cf9137880442e42bef2941a1b0dee462a9f7d96352a602dd3031c0cf04f489b1d56c5388888d5fe4833b82d3741aa3f2c1bc11f249757490994f18ee201267a7d732a86e2bae9c691cf19241d5729ebce6e565abd5ac3c97fd4ec7d0e83aca47bff52cff9788f0684ca932dcb485cfee04c3eab726f78dd3ef7b34bcc753aa7c1da4f7bd8f98c4821f3ccea8fffac4b321f1aede81e9b2c3489f9e83f941b44a30f5a789fd1d7276601f41d9a3504ef935c38c3912c64cb957b7c24820a844cc1453892f8dda2d16143f205d8aae11589b9b2bf2ca1e814db70b220da2dc3a54d66c7529b634f223a2c0ea5b14a912e633bd31ff3821bd03c8d392d2aa07c0635d66103e15c658024ea374d3fbbb1a26504a00ff4ec7c902fea2133be91a4e2e8a4cf46b561930e00d072cecdc62c7ba4de4834f7c53719ecf0d538187458b4fa2c919f667ca1daa46f2fd05a2705aecc18e5e6794190407b3787de543df204b7a931babca482a977313cec92a5eb6efaf01f414656de36815912218a2f9d7063117d1f6503395d2be62124646f1b1fae18d6e8f88c7b1e6c06e72af8e961e20ebba93013a3f8722cf4966461872b7a94d548472ed2135ef94046c823fc09eb2610a121b4b561a3d13061739a5c5608b2e01955af62f4b7313d4b50db8f823b256525aaf4715560d9e37545e5d139d91717ef6943b9253c9abeb0666a42c99724861c6326f60826cb2d33e0923720873437212c0f1f845dc33f464faa08edbd82ffdba0fd5cb693c6161f065e588de5b3936c065ce0478496f8aac819916501678f62b706d473257806fabbcacda01cd11ed14771a9c7cff048bb8eb8396c6d748588cfc13d85de1715aebea3b3ae77dbfb5b0eabab1295b0b6784ea7ebe1f2ae54a7b7f00e36367650ac132ca5cff12a14c1e06ccb47ca13059562d0bdca7e7d85f609e1dd9d8fb83cdc413f7670a834d406d2de739af5a151a80e9c89720f071c3b4d8e40e8d91a0760b356913b83f6c086a0b88d049604b0152e2f1396d890ef420c520fbedf451669aa0736a72e0c3a1125f495d3076b85b6b3a5e213c7ab5894ceb8b3b3c86a865fc344b03cc01bec763ef944ca40f06f9af474ebc8d08256e610dcfc28dad098903776586aead6db5d42bf0a8e5d34eb6f08a89acb587ffb233a4c539e10a72fe0b71a418c70b4e48dfa6c169426f5fbd8366a517e531d2fe3dde8187dec3eda023ea269e5f5aa1bc7aa5b991a0a1b8df021e43a9b10335202b0589805ba300dbc0fbfcd206cc40850174fbc1debc8abbae3e182a80b2479d5fcecddd43de886be2b89c33cb6b75de8ac20da6d8f2a399390611ea366926d3fa0354da788c53c351f9501362c4cde3f3d100de4663c07bb8a452777eda8fa6d1ff04b8ba2dc4766eb246c823b9451911da1f56c0dd50f7ef0c8cb86950e1ff894be3dc1ec0964b87f8e2b11fbe830bc301cba971dfc723ffa107bb48222f23fd3933bae3cd531ea3f3340c90bb35143c6dde6fe2f4f652f49252822ddc9b17ebf3325df5125c2bfc06af63cc450fa68b188170c69e28c395fce7994d484c3fc2f7dae1d9522f1d262f6ecb1d9dcb718b629e313e327ce6d443c8e80d65c0404913827cf097b3fff0abc369796af9c54a1ff9a28c03cc1cf5e1289e311de0bff2292ff1f73a257628c3167b364d9cb4309f44d1ddaf6bb59e6d73a3c463d7195d6843fce88549ad0c734e4f14d0fb506d779ece478408da65e41eeae7c5fead5031bd5d0da59e1b9080e0eb8d9709a446e3bba391275e53cd404ca3bf2a19d9f32b6690adc9dbcfd12a441fd7f236edb875275f33e09004c95aec3a06b9ec8a7c42d0865e7fe3ddb9b178f92060916d0257b64db0eed3552831e412aa08fdb2684c9cfc6b77d6dd457227a20bd0bf6f0950f4ec95dde960ad6b32c016ce3d1f210a93e60b83dfa760738fdcbc8cd68c591d01604da66548c7d564b2bb9fdc5826f8d3e7152407dfa2c1c66613f1593b339d77624520afdef6020025d310b3489c15300c65fdcca064bd7373abc8606d92cc897accdf168985f1997081bb3217696eda97137c8c6cc17b1ade80ee9df4ef85c46ab1d24d4f1ab8d90eb7db667dd251b2c9dbf323702e8b17a307c603db6b4781e58b9c8acfa8f75647eea05a7a6a45b120dfdd72453b6ac11c144fd7fcfddf4c2258890e69d3c745b724d2c7bf3ea4674cd528847b4a49ce06ff5c2180a45d542040a72a69070a2ee631d34b4bd71085e1f8d38c264aa5c77f611972a79b4d1b612d78654a053e3e7e9339dee1cb5e2d4a889c2af99787bf8a18f6e4af04a37c6a861fddcffa873159cb05278d41607f30b09f9fd9c3f51841e146067473e881224e3f35b218bfe185ada8e65b6da14350686333174eaea325b9d70ff58800d0e6d26568107d8b771de9a19cf02a2851116433d7b3316c8bd8270aa771de9aa005e9be0131d4619ee87f11847a51a7b84c1cda36e6329b086b29ea92ad87c5712e6f4f2950a2fa61b3bb55678ce9ad9d5aa50be46b8caf7f69b18449118e1a612e44bad7e035cc99c1e99e3731dbea948b5b9fd394af0ca343159c7f5b0259b3c2edbec7b8fa25310d702a15b5e0f5eeaabb3ffd5b0a8b6491cdfcd1a06313ca56b0cb6ba7ab95295e509b5e22a2760e6e02f8ba197ae14e38c5063e30f27265349c59a020bc8dca12ec99665eface20f7cfedea819e7d7cce13f24d1e11949f5475f38bf02d5569a591fd458f2b8336a27d26e9080e0cb4fac02f7c0720c06bde97c12ebde9b339baf90adde0b52a4dd1d47ea7f2b1b84058a79f8da2adb41161067d1f4b79f2010576eab6611d6d844a744f2ba26194bd2ceb959a9a36dd8645a5047a7d624e22ed982ae1908d019faafa338cf945d65ada9aa39475a8d6f1ffae0217dd94b14e4d1eb1f652f77b78514f747d29064a9f025a9fc113f4f0c5a26c220f72f27fb884c43d3a538e5cfa4bbde1eca08ddd710dfc35150ade069cc63413525efe72863e5d203129f16e6e2436ef06b005731d45d002de0974b2af9b6d2a31973a40ba807bc97970d7361b12f250745b258581a55b584e496471e7d8a38f797db91c7d3ecf9101a038623c619090bce55b74f968f1d036feabed24b1cf28643de44b8a27c849ecdb71e88ed3ff576eff4e58796a1681a2ede68ffed8654a1a079af0f09219d5dc8f540f6b286a5b43f90b876a493a21ead8376ab9b0ee54807d3bd41caecc23fc7c131925d96b109f57532a9d26a62840236a8e2013caa45310867dc294bef21d0ad5701888067027d96ca87f39a872aeaee156db703d903381cc068523e2760371ba13daad6615fa495b9b2d25b191f31402d8a833261f603626f07af058a90d2a300503c83a2b2b215bd79cec2b2003232dd67fd97c031e7095980f6eecc51d0230ec9a73a47c01759011e0abb6337492c5d4db91a3f79583dbc69a27e2d685b8d10bbf7b14c9a751456e80e13e8ea240fec6759e93ecafee1eb61e36be6478e09ddf82cc51a41040e277cdfda487b135d94f018ad5fce2704d8a67a2b29f00d57c1bf7fb5bf537f23faf88417132508dacad2325a3847044819e020274d677b19f7b713c28d132e5b86e8ae07588d10c3691818c1215f0d8f8cade411bb47f8991ad8a8db29669f5d76008934a25089164ec526b12c3d400b19854728b1e1b24f61e27ba68a4dc1bfc654c797968f5fae17f127e7a5a0de3dec0a283e77bbaf9fad347cf8b6ea749299f7b836faea32503acfa6bdbe78ea78219c2f5d6453882cd5869d3bcd374d2d4b167fa0021684bb6a4554668d2555afa2cdf34a7cc76fe1cf6023b0c58352e2b210b52808ccc3e5f5586deb30a7db27e2271516b156d2429a2412ed0b3fa8b6d5a611493c786b1e27b03e16a7c55118fbef98d98a444d6ce4a05ddcb1ec54235000fe82cc8551c67105822d889721a1222da8e554dd68c71045d1bcd6d9b699519b7391896ba9a420d2a7aa730d6fea32b27ffb679b94562ebfef335310f59adda4cb9aaaf90968ff01eabb0c52e28d0c3b7699741d1fceb57f75b0bc7a8b002f33648a6dbb38dab1d06cfbbe2913058d1a30142cb60870cd962ba398d441d198323241bc7a888f8f6be1a48f9cfe405491bb4f4c853a43d339008a32dd7c6dee9eb9856471eb69bf17e2be31a314a5648dcdcddc1fcad1cb91153c6a423925856694795b51ffb005b396ba6b263070e4fd7871cb352ddb0f5c51d789eeb49c097f1fa095829b4a24e2f46a695603beaebc605470b1cc0de4b0c93981540401bbf8c7fd5dc3fd39163728df648bdbce92c60d5fe89be777ed6b2add162aaca82cc8965ac3cd147daf7ee6a374a6f54a3eae7a7a8d6eb545d314bc18d3b3f8639213b1e4971bd0c7e39b9a003c56ee46d7cd8d32c294ec71b00deacdf5804829ac02503340a1b3b4af6580339788cc8cbde52947601e9a37f659dc82a05e2ecf517af402e50583c6643b82b7f529280d34568b1ac3c0e1cf9c6470325dcf2b800474edbaaadfb89fe08e9f947ab8e19d3da017be5f6b0c6639cf1a44cfcb2a62eb32cb569270769ef367183a59b302db7aeca4a6e878055367243a5f627a3456f610d44be3a79916941db46d2024a9a3d72b306435648b1861e634b18b2d1ec4a0aa0ab2348173b9e0b8055d82342b40e1e798a6121a6e8af54bc9aea05acd56ad9610876a10d2505d6cf630606644d9ace825139f2bd20b7c2a3e5cd3796393a894a3b4e8717df15678baed76a6d4a70bffadbbd1ac60fd7fd924bd978708da4094ebf9fd203dd9ab70117a09b515290c42f030f301bc54d60d67aa7560cd17c927712b18a10756f96b92135c604e6caac9c8a6a2f3163ae54302c834b23fd7887808feb8d89cec3fe829a3bc35ce94f4ec691eb22aed985f19b383c4972ba10aabf3854e2a4093a87c339e4c42218d29361ddf4fbd76fad5321d72dd8ffb8cb81a16713284df9f4d46098d9716ed61a22bf21cd212735441f8f3b08eea4808e247dfe163f3918f4379c5bb73b699dc96330db94c49c49a87571dba44719bfbdb8623e530b7408b68fe5b0b630c36fa1277659405fbffdcb538b967e1cc1545423d92c4a68de8e53ee2ce17271f38cf6ce90cdd3b981a5671bba8854f1ad5f28ceaf5428dad56389a4f33bd877e63579262140735b4a4002c2a7b3312510173e787cfd37fef94fbfd692343ed2a959e69d8891699c32f335192b34e1506396494dc4550ea3c7a48dc5f00fa80f1729310ac7812ef3e5be1d0e962a2202a934d3f48aca2675d72b6c325df1c75092d7ab50f2d370b94e17fea0f67612e0772fe1278851bb11558f6793b73a268ccff4d576a7b4bd9c9322c62fd5461c808cdfefa027cc2cc668c1eb1ab82d8e238ee06303d0601c79900ca7fe2a914a5ac28bccb01e475374c1a97a7a8d57ebb38c7bd5c37f93b9e422294000f66d44844ea47e138fe80dec67fda6151ea988929a868fbc4428dbefe253db7c64adea27b06552bd95e001c3421f0e1ed1a60fed34bcb14e7d13960da0b70345b5bbc0cabb4390bf33343c448db8d2dfec609b2b4d208b2e3dbfb9cc24db10b4a7b79902e0cd0490c450ab802ae9b278f87fa326363caa5d265ca939a637c2f8da083f152c6698ffe13be5560e8a00d7c6d8d1f2c48603587632eb78a53ede6787079dc201d166b60e6ab33ad6ced7b4efa661b535dea35c4a4bd32ec0b311131ae2b0049042e16d5446680d43db813182c71c8efc3c7138d21e7bdedbe6ac27418c6108c38a36ee6a2ec07fc58eb7f3eb784e0c0b744d39d8af23c76514c9299bdcaa104b2e68b60af98e791cb45fdb1c01ec9ff1dc0e985e2ef8e5c417bf6bcf230f9e460d8e60581d9cd6fcf4f1b44c04c15cba074dd6d544d26c97739eac8d0ba2c72df3678e102149864b39c890495eea7d8b34725d2868e271ac061f60a0f7528cd10062af7a2190b89eefb1765b26654ca7d4e77df16f50fed30b02bcbfe601c904d0677d7b63fad032e28ebd50252691598abef886062b17cd4c7fec323620049aa1927c675156bb2e085629e4220e9e7abcb8621c0b194a7ba353c09c9b745b58cbe10c0f2ebadf59eee01b5d742d0c2b9bef53ea66aa2c1fa403f754a6c7def9b4424281bbc9039175186309b00c8d6bfd1c0fab9b985ed185ccb4e78321369df645858747fc6f96c92fcae0e36f6eb9293d53c55692f8bd9a9f660a56fa8d0c8a59110258bdfcd4c954e513226f2386815f037ac3c6d6350d4a2d18e57f8d47cd6c6b0c60b3749f306352b199f44934e3825da1be350bbaee9cc9e2c5190c03e6c855b5d435d223d798d8e85445f13c9fc0df29cb57643f185e8f6a1257222bb6f08da89eba46193b3a936add8ada655d78ff78ca45e74108fe7a4ea6cd7c1a563bfc0673285b8531918d50567cfbf090ec5a005c6738699ffb01f112115d6d6ff67baa75c14f71a90f7c554c8775535dc7413abb141dc7120019ce720ac3435c1977ee3a825980ea05d98543a47eb9c9ae5977fe3af49b34f477bf48cf2c28ceeadbe2830b139a4542bb59b357d0de2068eba05a8ee1c1d33a7dda1a1f7f965e6afe7d849d27b6f1f75a6fa25f549b2b348e95aedc752938fd42922fd18c5d9062d728a62b8f7d551a7380da393c25f8d250acd274b8b85ac6816b0e22ec55cd851fd52cf1f608a79cc5fcf96e78697d30e9fb02ebc41190f80e2af3cafb47103d6bab238f0fbcf772f93c1fe4ca9efbb32d76ae632c5a4257afecfb406dc2c528834b9f3ebda8599e8d47d46a7efecbaa542c0142a6d4bfedc7e4714dbeb7c735bfad14434677e048cf2636b173def18a70e5addb2ff9eb01f7114575c94af0bb239f1f14cc47334d6ed12512ae3ae06c53a3a01c8c352b84203d8e63380fc2ecbf1dd308f9c87bff5cafaef58c81116f0b4d0a13dee84dfe00efb4d2080df69df78d6f34b4e70d69b31c3a56eb02a22159105509759e108462532ec29cd4ab463394bd9f9e0658188ef12db1d42f0eee00d459282d0e79609f933818d8efd600b9da91393ab4294f6580a77d4ba2cc6dc5645cbb4e47ebfb5a20c4ecfbbd26d9142e614ac2cbc0bcf51485a97a0a99d43f022929d848c3051e08021132dfa1823dacf550662232c3825f430257084cd2cf6f27c4f9872974c54c4f861b911d2f534f6ac73b398294a022bc0d8eebfb5e42adb27239ba70251d57ae08c6f3ab5333c9a3e3e16ee3a15ed8c8a9999bd208b2165b4466311bb7968af4d3f20b79edf93c94f7ac71e55623c97c17477a326a5994d1f84d67940f26ce2e71f681ef6bec9bab57c8ffc2d9227366fa1744fd939ae7f38553c7accf6d2ce3b2a62902bf37c41499d9401456d21c106a4ec1925a5389e30e12108742c757968b99ce754873128ab2fe2656aeb2534e98ec9a80d4004bcf4c0eeaadfa7e4c2dae856fec5e58f46d3af55a2256fa6738987597afb1c25978a02d1bd07f31920f068d173811c04e6b17772e8fc931d722be41d1a756c954683feb4d9d3ccec73770fc97209ed65a5f55c21e8c98e06c22c73356502d97026af6cd7dae1bed16b0cd0d9a106bf41c63e35fba55680aa0a5b78de6e7cd12838e366b643ed1b2f7735fef243ac6254cfa252cb04e08f3f156f7de2517f7d0c289691aaf07cdc291a84a0d683f16a5d85fd39165c48794dad9849e2b0d8b0e535b8758d5bdcb12bf06ccf38a88308ec4bab717d3edd80d7c0baefa57a1523bb40dcb314fdaedd197d26a1590e314765e1609af1bdbda360337a080c0842abd44880a2e379dbf9da49a1b953bf1c37bb7b8023ffd734dd53f763c5e779ca3067e9595a6752a82c63fc736f4290dd9cade619089237c17069949fffbe29785d0ceedfe1198fbfe03772f33cd9448f7b7e49c14a0953cc04176a62c319183daaeea20f50f94ac7d4cba767adf50693767d9f18b8319e8f2b4030121494fb223d08dc4aa1dd0d10794412c7c4b325a7c17be4cb7fe4ef0db061fda0d448a03bd16271cfbd7b2f8253179050a09ac538189093cd7e238d5a08d0feade071cb80284b028af02b3faf915348bf6afafa72e919af81b6e686080bc1c30917f8cb06cec05efc90638fb831fe23e5fd618a54df86b0ecb3ef17aae3c30a66ad6110eca92691cf47daa29efff4c7c93ac6fe38fe537bafff2ba3a3bb30c11bb9a4ad21300e2d84a1cc27b37ec28b60cd7e41489b6f18d2006b3492fad2d918f289057b02f875accd7ccb79cce93c2d69e3a0fae778666615da2de94cd1a2a2ac6b105484efdea59d6c2f46179feb1c770fb2191033e97747a8e0e86fc767a00e147a19c0c0028b3e0f2b88602856aee452996d1635984f98ec426d89d9530bd2cbd8c9c0cd2e6e86fb9ec46ab53165e688f92c7de9a476b733d9e29ec20fb1438c8dec30d7c9ee7b52e1d566f68274d77773092a3ec51509e05c7d6562e38451515cdbe13c08167b3ed1ac67666d8ad06b4bb56f2cd77078fba462f090b845d85a890a96011b308ffee673800a1e43749ac467426cf0fcee410b9846b7b2c5f762a3965e383cbd08ef0ca75d1d4ed9bff700a4a14286adee4bcf3ae60f37a99bac9e12abbf160c6464852446a855e4b26b88a960d731441eace982783b4109f5fac17d9eaf1f9b0fdc25d774aae17828ee54651958e5ac73009dda25f89090c9d5004a585535d7c4e86c93f0fa6054133ceb5532996ca509a053cfddec77c349bf15de1954e1fb9f2ced63f847870343c21072fcb6e4f98ec973c55ad69b94f67be7d9429d24b0dc864efed226a6d7f3bd76d086fd717d08c0cb82e62f784a1230bf638ce9be1abbecce69be1851fc72aa7d8e3d31eaba20cc42f4227908ebd4898aadf8e901f1c7a29647ca07d050032ad060e5c343ef75279d17930cec9e3e29cc48d8da7657d8e6821439c705698c980e289e8a76fb14a828ce9355f4cdbedce0b8f7844d2df0c6a665ea7eb8e4869c70189bda83024c54bb5e5eb5f8d295193db7caf0dd056ddbc3ac46909556c861c0eacdbd9e29b88a168297be5b8afa1ce2b2d94166288eb15d1915dd4b44aa854f197d4011a16a322b12b0bb69740d316edb031d1fae33b8f632544e492367b2b2d31f48b934edc024e4bedf81a32af2fd762c7c7af9439bed1d24d7c240b5f790fc2c5b4b691fcb83ce9ddd885883760ccdc25222b88f77eefbc8aa098f0be9670c70db23fafe7f76884e75af6ddfa18990354f3f02cf5e33611e91f96b65e4861cb0ed51becb336ef2698324dc20d1541bd9eb52ec708dc0bb3f608a5ad70b460c4f4534e73da53bd728f13b392b4f006409d5fb52539453a36ca54a0e6769f19ae5de48cec99b9b2759eb1a130815536eefb513aa9e01cc072f0769900bc5b611fc02459b37e8db2bb5586264ad05cff417a9970b0b1a468b6408be8824ab54f42223aa7371621fd20ad822a142c6cf50aa1304b580bf0dbbbee964ee1f2228c96b7d1c63c748404235319e3d33a033b3861d358f58323447ab9e21e8d2757e16c57fd008f9c251b2b9baba62319633435fb638b0855c6421804e3f6fcffc3fef7b219d35ffbea3fe6acc6a29236914a3ef2f8203573da9768d9181e969fbbdde984b16b410bb048d4035b61c0b2c6736d4e76bb74b79b0c18989ba9e219cce935fed793cf58f3dcb2dbdfe8c517264e7ba4c6cde696360834f48e26aff08f2046a3e0672af99ee8e0ca11a56ef91c6cc38f4e13593dc00194f3a2a57c58febebd9fb65d5c45cbd6e306c24ea94d9d10443b6994de8883f0e3a2d6ebc3ab50b5f0d57989e6d5ff91c84edcf5d38db2fa64bcbf7662929f491da1017b49a6e181113f95670f1fea7bdf056496d552ee4b1b302d3530884c60d0d4f07f5b3e446a6064dcdf47d370b4559d8c5a4f4b0963c8d5df9d3fb199db0daad015587710bf794fcbb51ddf05f6dde358194d5125c7baff3c279f878426af43674bafb778aa7b1b8c5550e7a7255e9c3aeb13e75264bd40bc1064dfdd40c06ffc7228a2e2a339dd2a4d5c9b09736c40d22e3b0a19dd3f9b9360c1380c84f8ba31913605a720a68996896a0bf716416376bf420aa829497fca62e1333aaa474b9f604359b41db18fae1a9d719a4eec5a2362f3d3f35dc8fa5f994ca84eb325c05ed7b4b8b65ef2563f761ffb2780606edab5dfe757e4118cece609b588cf86832a7ba10e23fe520aef7f8ee7f0b36413e8ee8f7e94327d0f10d80143470fd64adb3fc8387282232f17ac9b1d6258e1980f891d908b301164365f006be1e47e1b3cba67532af39d7bdbece58611598c8a6047910f75c3953a2a32bfce877bc9d436b79f5c833fa8859095e46ed651156c3d75810b89a96fb531002716f4822643e9fda6d39372ed278891e183dcc7e1102f57ff5403b1862a8207dada0d56f064d145a95e371d03ad3570c8040e389f5e461d17332e66fd61235bf0790fb841b86c2efaf4bccd24b56fa3c4cb01d9fd497c2cad1d4942afe5ba198cc4539d44ca235b6f4bb260a04b8a736503031b566b8b62313d7b32456063ee1f43a48cda476b29d921e5851bc601bd917900865665e181a02b27c21a479a99bc4e9f40e3fa16e4a8f6adff9c66c6410b38fb28207d813fb5e698f62bc8a5ee898daa8712ef0030c0b8fe268a988fe2fd9f00d0f05659657aab3bec54f68cfa3b56d6bcbcdc3a872d7f2d105d8c5186d28170b168f32828ac9e8d9e124efcb50460524b7e76e7248b0e808c801604152df97ce225f2b6f9931b32b0731d17bc6300d87e095f14b084b2915f63819a5f7c4252024bd63d172a6760e50d7cfb4326940d1350922e866445f057873f2ce3bb7a9eb1f56691b1c588752cb45862255156e90ced9547c7def8028d3667ab031819d8ec5ce76639883d8c06d62098032882f9e5ffd921b4d6f5c6ffc793dcfaffe887b70e0520be7608aa6b69d05dc1f8ce67d08c66d2cd37d10ff6aeafb79314c3b0050557e2e231d299a0cc379ca2e630ea11346443e5f892f7ae02a417cdfd7b80f07d19d74e1e037a51ab2df5b3e49baec2d86469a76035b31e41b668c53e3a0de3299ace84d6af5a0b4c5044adb0fe6f0a114a2eb875180bd5047428ea725dceec623c7c4a13ddaf680b156b384e734cb13df0a4d8a647114bc6547e01358e5b74188228cc756b122142d6cfd2be02cd35be1a72f71902dc248e413cbc16518ebe52f9cb7203325ce6a9ee4c5d769712f37afa7661eef27c74b48243409837b257f0b4d839a948e5e89b665662ba96ba9c158af33d13c6b2e912947a846e0d777264d8e198b8c402ab31376e2b2242e9c4147fc7358b8ba0c85feb9a3ed35b6d1eec4f02a5c805db80b9c28aa78b70cb4b8f27334031482a7fa8e120aa72cc0206c722085eff8261ce7b968d0c35466aa2c7658ba77b1ac4942b73976481ffc5f8ce8379c7cf195d31af9a27ece9ff5c8c19677f8421a7c75ed0a8d98368d5f2b7c1c72e5194a80dfdbd2b94f66d460195f45c89eeb18db34f614f47971d0c17910d2340ac66749c0bf4508dfe220945150cee2483455d364741ee84491ff4daa5234d84b8f2d5d9f5bf8cfee2b1bb07080d5f70909ef2722bd1e4a28f967b49a70d1061cc89ad853b57061828461f48b1c8c83f26a61bf5f2b712803a7fdea47df9038d36801e7e0626c1e7164ec70714caaa6e49b9e61ad79e0ac9efab2dfececaa76bc63d04471bc68688d86d26461a32571d501b8aca76029dd69073fb163c339d71983c7cc52a520725a18a887fc5c4e9a65978f89208977e6851528803c1e6043264102fcc6f5ae7a61957b58a8ceded06515a9bb0bb7cfe3f8c502ec9d00c44c2fdf0a695f6b2ba5ec7803ff6e05952738557cc5ec8f6a2e76597d64c8478772dcbe156cf1092da2d9b29c89943cf86112b3f1e5ec8b1986a0cf0f035da7c34309d592d145a984bdd79abacd504b8dd2c2bca270532d4a54f6d1f4142dd178b841bf73878d526f2dde3c3cef76e7f59858a2cb4ac76619bc4d6440e470e0794f4cf0e58d5b4658ebb7f78b562ab8c1173a2c1abdc0127ca9b8550d8fe367feff95c74fd34abe610272c2894811e7050510a62518652c58f9ff96c721933d5797b48024d378c11f2cfba1c7f70c4d7726387f19c538d4e6c9291f2c347cfe4324d4c7a9735fdcb0cf6201477d2abe6cc49f64c68cc91ce56f0e3fce5707cd7dd11c617c4979330c78df457f294a1f6987d051fe94e3bbe29692f283ed1937d3dd16b763cc10573e9eef6f29b642f956dc2f1584a3b13702b7476c037ee61e206302be541dca349d79e7198206a61501e17a0b1db44c3febed3623923b1c24033f264b0b145511ef90a09b542619a84be259e0203ad56d0ca43cb3ea687a17968d6d09db79f0ed5037ad9b7638485a5261efdaafe63e71713b6f36c3aa9e7d1d3914f8dad487b41d857150c4e72f243cfa8d6f585559c2be3b313930ce0e24d84026c173b00d00bc2fe9a9b6c5106e00fd2abb4c16bd84b7cc299e9f7614bbae716bc1d26403e654cacff8bec5abad8fd2e61fa65df07e4d53239b6e03746dc7201cb46d963dabbc287c7b16ffb65188f0a4736a35fb27ce231f4bc758baac7d6ef5b6f7368f81699c93920b39b3aef4e0c49592ab8b4fdc61eb086826841bbb9941649b35bd1e7b580a5e63913a0ba9248738820a72e308876074d9bbdd2ace2b9d933b8a8a1502d8bf70bd79b01b1f36e0d9ebf2d2605e8bd103222603f9d7c7cb454f35e7225a85b26c448a9d62443c0ad92b8b4589d3362fd3bba1bfe50c59bb80f7b687b5589017858d8a0ed75a40d41614baf469371eb9e8e01fd81d220c3d4f8a4e340ca48c494da2005dcfb5ed70309254632fc04f553cf14347360d765ce5cfafa3de31c7a70def3eb727aa17652cbde8811c7f5b65aa5e1d686dbf6b359e49e08a48a35151ae9e10a04472c626bd53902a4f36078fd0feef246222e943865c6290aea8c8edf5fa28b53a86af3b3602d386f39569d6ee83710bc673a0386fcef7171f5f8ba08a3b500a8d874c7f7dcb27bdfe0715da2d312a37e25a48b3178178f6148efe413c9ee62f181871ea9857dcf709630dbc97f5f727955a7c47f0d8c13468bd02f7c043e0e3cdd3dfbf246518a27fdefac25858949afe34b203c29a8393a7631f07a5e1195acc63be888e9c9dfe853ea8025da5cd64ffd0ed31c340af840bfd5e6b1530edfc31837abd42895c4a029f4a2e37c842be79eb038c4b1c454fb199fd7de55f772f2247f6ac4631b130a70ce9b9c00f57d717614bef040430010a238e705876cf7f6ab53a732fe7dade42abe07c404e468d2611c32136d6c8cf867ad412ae9eba7fe723450bb8a10724fee39b141242a1ae93d7e91929f1dbdb88ea8e3db1cbdc37406ca348b3720aa284d6a7338601c5f5866d2dc61e2f5b6ed17f43bab86d80cfde20e8c14434ef90829942ef073c08a6daf74f74b0c176e243285146d53c4f3b0fa7d6c58f6e1237b1669687513b12c8a3c55ee6f4a5855a83ea9a83c86482f8064e5fe65ec384131707fe7a2fb5ccee77f88c7b5ecfebb0e108a20a324591b1ee38c95a41b7da4e41e2aaa50acb876b43fd59ed5471a376d24de5dcbf3b1410a40f0611aca344a9c86fddaf2e4fe9981422e393bb5e3f89de3e7b2798f34bdb424a3eeedf975d45d1baa0983a6f7e12d1de852d7c3760774d5de41ebe58d11cd3de4d04121697ae518fe1184d63d3f76732d19ffbc2e05bc50df4ad4c0edb76a32f22c85a0a4edbf28308258546ffc5929959ccf335c9b110bc774d14dd6262fdf96c6dc43af46274edb85343c211ff57c243f4e54e6309180d32e8ace6e03ebc48c61e2dcae04ecc865bf29c2527b77c1ce7c45d2a9471ce564b83a6e037197032193dec3483d2fc32862b7e1da8422633fde67d05044f068e933616d9f5b73b694175d785592a07f127dfc7f5a984cc070896e786b788e189f2c9cd38fd9d211770356ed863a26f53e690177ee0526955575e14c6e5ca87ab4e3e43102a169dfb373e9f9370b267453d43ce2debcc872babf389571f3983b9c2a9816ca1cd81fe55252f714b1176e74e82bc4c94c25ef6af759f33a51c47a96a172f6b26047a5a9ab4fd3129475f85ccbaf9fdd5c98e88cc1741b6b0d2c9342c2c31c0db924db55219ae59739d2feca2f9d1eb546ab4a581bcf6be9b88c4158eae4933665776084932e615f2c7ba388982eb0416d3760ace637c1775ee48a1542b3a7017c785fc86985f474ee3829b9541fa217dd14f12419a64b6ea3cf08ef2f7580a3708459c56fdd2a158746742bdef4d9497078970fc5762d7e26987a630c90da6980046163039d00516b72bb247b8a1807ccbee82de01023802bc92b2d81c96c1b30feb187c5009e71a192ba5e1639e7002bf4e6ed95f86cc6b1116ee138489a3c82b7df3525b301525f90eca2f45856ca2f1313cd976e3aa248cdd8869622ee90c5faa4e37c37274fbe7a308cbbd94308f7454fb952c216e9c1f91b6594e54009c105f80c60e242e1f6b9226f5fc71d461062a89fc0c08ea86ee45d8acfffdb884b9876d503316660c011ae5433b28389605264d16f3cf5a334df7f1674b74dbd3b60fda37d6a99cc1107ea7669f442cb45b9616fb8cc4137b348315e999e5a8364810137e964960512a4ba5f223f02c22e4cfe2a756d9df55173cad8cbd261d08fff6cbb8c80bae2a246222df900591da23192920a2fcc58f5dc6d5877313898f87859e0f1d10800980491d457d0b4fcb519d100781e0603ad87016d7ba474bbeec7907fa98a680f0b86f575b31f0a14de8b632dde2ff2c2faaf8981a4098d72d48ed8c7daafd8c585138bb693712d100a1e4baae75ce962e2c97677eff0d2a2dc5f7868f6be088a7da35eea0371bc5bffda6dcb392324b18775c90deebbdc8870b114283a934e816d5150c8d1925b8e4fd7cf2b4ef250dfa14a1c65edc2b347c48cf48e97a3cc21842e8a51ba21f01b892a449930bdba1f36d245a637261f5496154fcb8c5f8fb04b5ce3690302e436818030abdf347f2d5f7af7c829a7e38c50296f59692d590e25e73da1141502834034364aaf42d68b4bd83978c1f3368a01a370b1165bc8cf14196e62cd02928c5b08982a49c471792da425b4fdc6377ffbe0df013748b8f93f39800e0a08f514de0ff3e7882ac1cc05f77511eb992ec875d33c5ba6e1fcc406bcce0b74420fc1d3fa92b9c74282018aff70f05fc6cfc8ebb736fe99745cb8bcc87f9b32ea6fe562cf1b94db21afb32798eae9ebb8bcda8a428b7961c6a1f17786cde53936ba8b6357553dbe8922b8e1422d29b4af2e99277607be0421ae1b3631c0feddfbd9ed7d991ee4e1911bee251274a7200ce5f2ad2531636c0ae48418f2589baa794ecc439456836160c23b56ea08a4bdc2e14b2511255101075b0f4cc5369306c95bb94784ffe5f845f717c92cc883fcd1056e967887822ed7bc00c8824dcea28fc82212f6e1ebe96e11f061c209aed6aa731d1e73fe07bf76ee5a8990b045b913224965f6b388bd40fa39b3bfe01e6ea98dc7c1536f8eb82de7983650e6e1e5613ab2750d5e0541e1e737c0703aa81bae5f4311a18f530a3be22ea393632b77078dd9edf08ac7cefff96d067c53c974a3b6848929f5814217d2c3adc52f5cb4672c4c66bf399f8b562e3b72fbaf5528f90ba784e10853ec95482346f8d8a6403db20b4128789351e558b38274357bb9feec1a6013717f543fe55e4c1b0d99ad0bbe05c12952ec66faa3ee54b358ac1cbf003444691bf229175d8c473a28f04ea03da2c877816400cf4ec4af9e2f0733fce4a4c727fe60038babd8971be32d5efa76c83f8fec8f301c8f5ae2a09d5c3ea3f1d0399b06f7c44a330dec4c3abdce0e1c4e8181a0b0e2d5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
