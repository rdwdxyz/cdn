<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f276f7bcfe5fc3ab1ab3b0f3736e10f9ee4dd78789ad0ad86818cac4ff8acb9f5a1e39b96bb374d939998c7ef1f45c0b710a319b944dc29b9a5deba186619ccf404497b8bcd536f4cc280acbd3ee174e3c4c5c2fdb9f32a60be1993dbd1e7d5d3805397d2e2bbb061c8da2b4cd8879afcb3d69b0d916b2c32ef9b7f4cbb5ae9f68c2958b35a118ef8772487f1c6670120a54628d288d722119a3bc040b937c5a797a63ab4ba01d2ccc3b311c2cfddf3a8be0ecd9640fabb25402950c576bfdf98a9ce757490bcf8b155798113a5d32f9eca8f8cbdaf9e46bb2a1070a929f299bbb57fba3001666a4d481d0a0dc8eafbe7144bff6472f962f56d61cdf4569765acaa37e5089b2fd80d83d5ad593a990f3dfb541131722198eab43337fe6dd5d6df448c87afa04424923a3e7198c2ac6b88ec39dc0fd5e5d46ff1f3d2eebb7a74652c7c646b798d79a4b1dff06e3ed7168c38cd29fdabdc30a70568940153a68d88a4d2659df6e49b2d3eb402d06cbc82ec7d6e62bb31c794d4cb1abf24ca633c9b36be1758a8dc88633cb4fc672dc77950a58ab5f63a5125e7c9e95ea1591d7e5658899c343ee53ff58f702b5702ba05895dea3ff6859f1283ed6f00db1c9a13a1eb40a38ab2a7a340e378622e2514f3c5387af4a36335fa625c5d1afe1a3c51c14251829c7513a6302903cb77b0d4a3598ca47bb900dc9f24505b33ced74009c6279cba0068dddf5f6a7d2db30705423e1c088597641a1d5c9c5c8d3a82b8474f2617178e2d0d2d40561341f00ae369eabcb290239c02082125b4e5069a5a61815cb6e5a87755de084657389df720b38545bf56647352fb871dacdfee1a599decc56f41c96f4c19a1c4321bed789aa64829cd38831635e17e7bb9293850833f4c944ead55775308eceb7be777bb4ecfbaa3a1e5d1306ea705055ea60f8f85b8ba8e3a1c62f223b055cde8c4354a4f3f9a355b44c79e40fcaf1b84e3a76af25c9641b3f367fde5d433a438ac660d029ff637d04da3d359e231ccfbc863e24f7fcac7de943c914477a8fad169e99b92e718b7ba314505953004baad6eaa92072c41b6c59d2eb3ff717e02564e87d91f7c89b9afdacd7e65048b23ab800dd5c65c2651040d8fb1bfa2bf968a17870c9d8a635baefbd89c5df79a0790246fc98c9c175951e36eb7aee04446c34814440f7a2c7f9f5fb3ac46f4faf4f3a09ef188a897e253b77200f358c73988d40ad7009f2198964b3901fc07ee22dc4655a4521368070874056dbccddb2376d3f53b523620af54027f19f6318414d60896d85fcbf65b46a2fd009ab1111648748dc05cf777c00da55fa7b1810fae62daf802e0d759eb9e5564160da30aeba69562c43f7022654c8d505be53770b6d9ee4de2e9f0f9bb8bc8f0d72dff4003af4368fd9a3ff465eb2ae90903063a73c4e239ed51c00d861114f04bbbe025d671512ace580353f822ad312b598effbcd718dbf907320d61c9a6013260f4e1da03247d94aa6e16efc6ed05ae69329495472d48f8dd69f1f9e84dc66e364f6c3b0d67d3b771783853ad268b6a9a4abfc92da272e2d828ff136d154af14cce811a3f203300a79390165bfc69b06cc71440655275b88accf755a63dd778fa260b4199b103ac88164a8c0c2f38fb505129c635e2a5f7f0541e815e4a92cf4c083543a87674d6955e2ee03a059c9ef1fdbc56db02afe5ba60fd647f560110fbd17fc9cfa43ee5837efca78dcb346004ae7a450623cdf632aa4f772b1bf93d9d8835dc2f8137fdeda59251aaf9107af332f6d090afebb3441b812d0bcd802b44df466988ae4a623bd348ad7361ebbb7e907d67b9eee0b7fe545c6bbe367a5c8d366e7e74842853f03f72f256f26f66b38480b30dddbd579bbc59188b9aa96feabbd67c9c6ad759cd785a3f50ad6ad39746315e9b4319cf26a78d7e34c30da2fe2ea9a2f9c97d834bf89be0890d805e92271821be83852b23fdc12924ccf77b6a1815244707963228f41de30bb0846fb48659747717e564aea33a4641dd976c6abe9feac72d1afa14be540e1012c1d94b89fb72434d108004d1fc16f923d2afa176387367162c116cd6e876bd9e66acb4a7271fbd1021cf23616cfe894771f5c1bd2700acd832c2b5e8bbb6e57e44a30bd4f9cdea8089973908e523859c62152011f694a4f816a9a85b993a6cf9b06a3e754d4b142338f289264efd5444e92302e8336a8bdfed4754de8ce26bf2ae8066fc23e53e60c8f6adea453130b548ed7e48cef8712348d3be9eab88601cc6aa112229c421ae283d4dbfa631da737ada0b43eeb800bd82251426443bb4459359373f34615942a6d8eb9cb127587f9d1ae9e722838517dcfe0b3b3c0d787506191975e295b885fb8b45244e86f40377195162524873cdd5d49cd3b47326feb4a50343f01faee2f088b844325440ab2e14ef2596b6658f73c2b978b78bfecb2edb96c412931f05946e7d28bd9954d1a7a42ade45d1f2f64ceadaa3a71c3bca64813ae5fb891c8537e51c118cdb468db8097699effb7de914e1bd718312835988fc2dc527305ec559cfae009700b4d694b73efe837fde1ec996c734ffa1cf608c13a5695e54731941b23da02bf9431f645575813e327e05612c3829867733c998ac99d9a061ea250fa840846d6a12442ca1a3c09066ce10a5d979993a4b2c378f1914b31793ffddc5169c6af1d177f8eb246c816608bec942267678059d5528609f510028dc6f95497f235a8655cbfa23b3131322d1dd77fcc384e06cf56398ebe7765a8059dc294a072c987d92548bc42d21f7d1387c87ad3cdb7586a1b8575a1e207f0347dbb4aa3784063681d4f8ada84446dec7a71331d09f1d6c08af6e2720d2b0068a772e6d61842b166f4e35bba5b85f916caeb976ba87d4268fa4d807433b1af6b006b8d3ece916d1d6ca24cd11f536826f14669e1e4ed1be9430a7cdc8ce7dec022cfec0d87b941d841fa31f5b4dcae4fc400b944f56874d076553be47b1dc39ab27622c2e7f764753a663de0c1bd096758bd1c331c28fac0ee58c8c94686eb6fbb2d53181d5f81670617f083eeb6dabd6d44003c131f2dddf3b711133e8ea5da43abdf3433f696baff4bf5c1b285c00307c5bc04e3eb0c1ae8d194ee3a7185184b56c5753f8188ea58a734f3d2e108badcb10885880a523847c498bfbf82603270291f7147a44b2db86a2e368dc1301227f2ae12e9d94734eb1660f8c03062be06361fc41eb2cd585f136b7096b9fcb990335ac102edc035f3a62409c525a5571389f287b4f5f56732570e4968730f23272c937a42883df7be58bf82c9f60e93fe4d7df1f5fb77fd9403226c5bdd84b8a05e08d4a3308b18b89fe3b95534ccd252783ad222a581336d0a9f8939860bb0cb7b21fa0a434562bdad3a4314adbc00e0b97891f140705fee7089e6747b800af76e7299bae31689fd761288ccdfdf94c5346543003173b289c1c19947fca0c4428d7383eed1cebc5d3a904d75e128a5581c1b20f3b215e684dda9a5a0df08c5f113332ad08ec2f64969c8d9400785c964f5e4ad1285d3f26ada555a8dc582c4a00d9a74a82d2e7523aaa08cc96151e7630028b4ee738c5831476259d06aff2c45f6642ee4de5e842236c646de1d74fdd410bf92b5a188c7c244f6ecf2d0cfd8ac2fa7631e832a0ef56c6fb703b3ce5af1d0b6acb293593e01277b5cb1c9f4f72caa3c5da642cddab1efbdce8feee9e814a78c6b194c70db78e7c373c5be33b995af894c7d11259c59f414a9d93f509f47717101c47e9752c8ace3366f4f0bda53abc709dabf2cbc5b50aa325ca02f5318c236c0d31de1fb63a58976e57e3abf8a16d5bef33f7e68108be5d41b0dde3556d600ae3e0d9e031e0b50d94a41f4f58f953a61111dcc3c69c455e4433ee8389cc227f55665510532f4da7f89db183a9e8127ac9ce8699a7a1739e9738a4b5d2793835aa4176aef93748c0939d9837c67cd57d11b6aa8753a4a1cbf79f1e3f175f32c61807804c4efa36a1f7f5f7d5dc129f93e6d7cc03b57b572536a49e0f9076b8865a0130959c8ebe2ed3ec04d9925aa425958b36d9f9694d24f190a90946750d2af6f60d3462c68749e05ef35ac53db5454331b9879d544a7f46c176c7a1988628c4375388e23a180af4aba0f4d0658613550a04f5a800466234e64770684e2ab1cd3d8b8d67360bf575c6091bc0dab8146fc2afafbf41fd569c2475ccf2ce3f7b4cc9e2246e017ae6c49caca631d3a3e73dbc4a6431554c91160eae4a9a9e94b7289f67288cb7399333693cb9ca5d5a5ab2d6a03ae6d78c6e5b5aeae99fb32676d3410f22df1d9b2ad0d960e7af1c6b7cf19ce01834b09970dd3b8ccc52d3c49453a10d27c49c40fe827827a9c90486732f91bdabc3e84c37345883de7e2e035a9b70b26bdecb1dc92ae57224557fee861f2b2407caf795eb21e88fdc8788abb29ca8a4884b3c19cc83f52d719aef9d57a7159e2ea05963b3ec19af3ca403e8bded2ef6f9f41d97df6c1a6608cbf89e17b57240dff0e132aa77b091a29d1074de33fd3850ef3aad867b0c9cc32219322efc832a9befb6d3c24175a0a93182f42c258bc6cfb539d72a2b7c9984dd57800946b7b8fc8d9fbf21af46be3d60533ac26e06c23433e2649fd92e9587c82bb93668b9e92a04e540365c5010686c2c3d4b02d74802858b144446ab3ca5151e8c495bcbf587bbe2b1607fb3cb4d0d0c9bcd16437e03a8a6aa5d8214efd88f5973429414b295156c3f222444f100dad724c1784bd198971a4f6261b59658e32ca552e1bf42a0c9bbaa1aad042c6578e7d5835abb742b539b8e743d00350226e5a0ad4b0420ceecaf5b51e6427ceb569bb38e183a845cb2565def10055d25ccdda3edfda94bd61030b256bb98e2111115d98398466432b3b32f26b62cf9146c62169a0e46c1d0eb29205e65cd835ce4665f76b1c99bc25354d0dfc814ffd15f899a7711f93ae89d24b395beed86e534b571c18918a27060d26eb26c96927eb4a6ca6f7285b915fcce8fa01bdc6c0b0c6d70b3279ae243603e8ec9c5f3ff12d30c3613a86a9834a01bc42f08c61aad38981402cea69635304f3193f11d3950a505df5cdb6f5146a6245fc0dd69a5abe6975bfbd03e58a262c7894a7fc7a65d1d4b574852123723626f54ea86bb45c9297ad0b142b36cf43cc9fb134f99891ba1e666af716772d0e3de11f03c4b81e498d3c4b429ee4f9107b81d7d60a52287b08bca7050876e1dd96deb69df7a64360a41bbaf62a76cafcf78df483f9d44cff25a82742e5ce7b9af71c3047f840e798f3fc13f12df3c4487e39eec5def2c20b4ad92104c0041838f244de3d7853ad1ddf5e4e22d6f2306ad03c9975bb903c4f683808c6c6a2580f7341ca881f185290af1e9dd2e278b1299eb5dd439dd527eba943ad8f91974f26135e13468109127ae864911a923d40fc44290f6213de5bdd943dd1c1a7d7352525bb4d153c4398c776df5da703f9523822d645eae8173ba9bcbf75cf1f51a1189ac4562a7baf34d10f17e831bed57374f8f899c8862b2fcfd6f4798b958c315ca2c06f4a4d3ac7d587088112a55dc177fbd4e2e9beb590a2e581670cb16348a48098c00e8722af2f450db975ada4328c05792b437d459cd150bdaa5915ab4b3b578eb802969a9383228c26d9946c0bf493a7ac366aff475321cbc4807fc2184bcfd6e674484790700ca9027546aa273091e6d0516e4beb120929860012f1154bd268588767bafff8ac79d6f04c4b20239e76a4221639226122dc77b12753d8899fb8613a81d02ca8e8411e805155b5d990f8c5271345082c422039105c2cbb97a69ad369992b4b6803dc6e3dbfb7151ac106c2e52bc24e980c8dee01a0a96ed7f47a31a8e8e825867b49d9f06a101078f6df16a0c60e0341eb826ef172fd963fcbd1b03bd21fab473209b5afc9733ff373d8df2b5ff3dfeec434e79210b3696959979e787fdaf96ef8557314750e6c40c15aa33d803122b2a584570de574b9b979c3e9d60cc9f95dfa0eac57c9c7b41da5ec01a4429da49a8db7ee2415954e9a4e39aaffca840026da6b83f3016a4ccc87edd57fe46c5088f698fb045b3aafd9863344de213669e066ab6a550ccd458546fd0310389c18f7bee0965a5d31373d2fd1639f6fbc0c9e724042bae5f1ebeb71d8d8b8bec39aa79508a6922193d5f3cccb6e962cbbc74a341d16e66d6af05a30f29816ee93e386026beb20130a9f3ef045dfa9c979fc2117aa1055fbbd924583991a93a515cd30d5f0d52188030c42895b1b4021b3c2e68640327718b967795534d98ca28646872720a70ab75b589b8d6214a39700ad7ce25af4c10fd6e8347b695bcf77f748d736247ad9164655e8289800cdd8188399a6d72bf807fbbcc5883b47d7a58ef4cc8d3c884df44851141ccd5481311e44f525d60516ec880a569aba3844ff54f6bb786dc610c4f32273b89092f1e45ea625b244528e728e43052c2bafc3112869645bb4d91b161a6979331ca76539c84e52e7d7a7062214048bd0fbb15a5b1eba5c35715b033defe7af2aec109f7ec98074ced3c72009d00bd0946b3b03a7958b0b6090961f7d56f3519880dd6d66a68e5c680a6c850c44117e5476312124769838f5177a1af902956cf60ec6d0306d2d61080eefa1d4d3048d3361e91df86c42c3111a1744d4943da3d5b11a255660dd0ccf1da7584fbf1a9b829dd4b76dc54efc7da8ea3509a2cc300cd9411fd9b1cc75f6345debcf303480208459dfb6465b651c80daf94bab02c3c90a405445503d310d03528b0a9e800bf1bc5afa3fcbd91829af859efd3115a90d1472ab38a9114f0cdd0409e2d0cc50e5562106490df94d457267f400e6c3ff2de12115ed363e6459e6edf2fa5a87bb53c1a93aed329bc1c8b4cb7beae3c1cd5e8d6adffdb604b8c7482ac2c46a33c6d74a4fbb5486fd4fac0332a8eb3f84736d7f46016f0625fc4eadabe5f160871fdd3273f12bfb8bc063cd45006e4c9cdd0be6d2556a0d77663b6a5a4e470d853d72603f8c65febb200b3d422ede97335aa12e887922aedf58c17670bdbcb6d64e499556a14044aea5919c2211f9c7b4b1f85f6ac2b884ba7ec6c140fbce6009490d0a0453c283a4681d8323f68badfecc326c546e36b334a5581624834080b9111fbe005ac9709966129bbc4db248b1122d081e8304c57e4f90be330877fc8a49aa60478d730ae895686ecfb7ac5f3baf2ceede724eac6e3947f11284e70ae8dd3ef98d9b5af2627a9fccdf23b0e79e7957339000646c489c4c6ffc974c9f5144e88fb0b9628e66444abd1e98d63210c9434822faf4e8bac76459d202ca781926488e54dbb4c3d373075af1020a8e6687d8f2a2c28dab30dba1f7dbba23b2a0d47ceddd061fc310fed63ad2f29495e83c488d037c66c30e3ff89d983331a9d88627f8ebeb645b231aafd137f11d18b41a33621a1c835942dca45a0487de584946b2a399945ec41d230575eb6022f6510197c2536002f5322c91cb18df42c9cf4d1d5865550548c2f50934079b436afb7c362f473cc1ee616d6a257501d27ffcda3d74e190b43f0358ca838248775b71a2a1b06145a967b49ceecbb4e57c969886ea1a75f7922e0bc62ea6ce23b32f9a3c9bba15af2df2923c33036e37c89ce05bd49eb3873d59f8ab11014a44e907afb2041aef6a3acdbf942586709e69158d3916ed82782d7b2fca20b96a73e8d7047b67f797d7936fffa1250c6b712b36ebff316b9772b72d5f9078f311e2ff2bb2d730cbe3deca45626620df064b8824679ab2d6adf7cb889004e04e6de41e4025e03205fbce0c06a38399d51e34276676a2ae7aa97d6fca06fc3f9642edb9196764480df9b943e46d693afaef6e0165725bef9877eb3945e4d56fd106b04cf054fa8a4eadd338ea16846fcaeb5ec5292ca01cd5db318a150a683b50596578f80c29f7e9cc54b7425f5bb8793f08d2454ef99403bbf6d671204e56e4b69fa4b843b7953cbdfa2f24d4bf6c1e8ccf52aa9e2c536ba96f076ecbd03caa5f312bcb26eb3ac33444127efb08cdd9a5b5dd6c134004d9b2fc608552af812057fe989a4d543e989862339abed687a05c24b3d69b219120dd54b4990297d8caa41b92e4ec6f32154bf858b22765a7b6f00cee26e5d7f615014d6c3357cf1508a5fb169c001d3cb90e4e5535289673c0cccfc4bec82b8c689ef30503cb691d422b4674ae20ab1f48ccd867c1bec7dbd031e4f45fb92c36822fb08e040d44a57bcb7be4d64b4cd5f8172c3c2a304a86f2e62f954dcf599d2a2e05de5d7d930a4512ce5ad1ab0621ce816c94930c78249d8f512032b8fbb4642278dddf08bc840dd2dc5a249a58a75d9cba019ea717382f263492a4b58409eeb7f1c92a5b018f9ca4dbabb7840c4f1fd582e4c06ee18758ae70d1d73ad001ac65314b1c662f536e717bb2de5068d37d0b3c60bdbfe93fd8412e0b3dbb666e32a6daa6648bcfe95fae5dca8e264f6aa1ce7a01e020ea8994d190d338e5ef7a081eadfe6ff98cc66e614147c978731db040e7fe207278861ce5731cf251735b4f6d5809d27acf49b819c4fce2563ef352e3be6794aeac317b63a2171504e79ebd72babc29c574125d1c137293dcc8f9bba02498af7e23a586f15146fc975ab7a774ad05250502c0c2348b190fbaeccd437028b6c875709ef015b8fec2c0674e0e1cc513d466cff6563c5bba4bf757857f12d3a7f3f301f8ce1a1b098e189d53ab2e8f1aa7c0bbe9579cf3472dddf0661c9ad0918e13fd020d8424c7b099e34fa2f893c94ddff887352e1cd66ab5540b5aa4cd031adda837860e315ef3fdf5c77f10dbc13d2fe5832b1153ab63b45dae81ba8afbe2e45d1f8362a0c74b0b4c508bea65ec6d25d645d4a5fc24054c8ffeeac8c3b6705dd6a3368ccdcca56e245dd91e447141589d91c478e0a7e7cf1d7ebd537095c57bdd6d82fc894b15b148f713ec8bbae05b0b1354d9fb9fd57e0de03d443622cbd5974a905447b6c8ef4803821710d1047241cc3f4f8c70d737e101541d1f22395178fffbc713b4ea50e19bfc0dbf272b997904ea259f5b82311815bce779dd375835e9f5eb7d160f0903bccfa31e207138b0733b8ea547350f460ff4c01e1e216ebef9e2e91b210bb929bfe0229631ad8465b65c83809569dc824d37094fb9cc04ce368c77bda691b1c928628eb3c70c81f256f4aeeb410c52d7b7122f5c32b6e1b3d9f372b10a666431185b911d1b689b5b0ff7ece36d9a4d5663a810fcabd7f2c15faea262c87e3c707f4355d16a02a66a0aad1f64449b9ad1bec3cbf7490a1da16b7bc662380c6b99bb942a2fc12b743953f2f2a85a713a078b061a3d8cf7763d10be68b29d3da3417334094a67f802fbc513fc5a72e3272a1cc9887121d6ee13e4e84d473f4a7bf2e9c368297b92c6729027a47a3a1c8d87cebcfd255f095d497c2956a155f654ffcdc071c8a22322d907faf01552d404b818e134a3b5e39cd480e3058b99b3dcb92e3caa88335c1ef99bd0ffe67d1d0e812acafd5019a1a56c033f80bc8e0a9f946363b92f9e02342ea8f5c929d1b6f40ddf67432975a142cb264a7fedcefe0e9888926d512b0354b50a5372b825b2d10dbbcda17a1a3318186a4271c8875033b34e6ce263370213428f1d58b475f2abf116e741c276f8fc58206e4362c31de880508e045fa1bf5a3459de019c5c33169e63a7b125d2f79c00f428b82a9daaaefb153b69bbc268e721054e213457a0ef22e4b0a96a20062952b4aa95dcad19080a38bae22a7d0063ede81c72fb0f1bf2a60d15db3189fa47b4714e1c0bf87ba1007dfe8ff82eb79dd019b251b5bb87a827399b4680c740eafe2406fec5740053a2a665f9876db127acaba38a10522c23cd47772938c2add499166611ba319d5968621be71bdcafeebac1a0c6b26472244b01bc5c61c056e8a224f90506ffef1902881a3568ce5b4ce3c9d39c6694ca3410c7b097f2ad06bf2fc3ec64db003be4e650c9cee1bd2aafe857283298bceb50e61d36baa598f923ee2aedd59e4f0213527c0f2b06630b99b0a2f6670aa7970aa8d3b4a3369313108506a1d0bf6f65df7b7701ef5ee45e808fc9e3922008c038b056ec26ad1bd91c821e558f1245055a0d5905e536a1b3bed6f19db7d4b658a828d0d9e9eec7acdfda04fe73e17d5180dd83a082a6ab93c59d5221cd0a9ff5592d06e1521e081595038bc5f3ce75215b7262055c60b30b68f8f27c7040d3bca9fa50e45affa917c715836ea98d6ebaafaf59a96d864cf9d60aee2edaf31e38cd53773148012f634516cf7ec262426eb7bcf39e750aea9766cb3c22c3c1b57aa53adf3d7e788429794858bcebe4e9e17628ec3fa2cae1b07327fb84b219b8502b5391f8d69152cb46ce5d133a7effbda55756dfce54cc49b030d9a02fe0dd28ebb01f1716e99ea00c64b9dade52269e6999b124a94869345583c577ea8807b3ac945ef87890c881732f9a333b74001a35358d5c992d4a8d92470072382e3fca99018cc07f20fc829474415ddc27f8268c7c743b46cb5f47c788ae139f7f471622b5921a667fef63f353276339ce7c4fbdc8bfc8d2cd8b2f3bbfd86e559ff72d2f425de1d36c9999f98c868b47f02f3cce15a906edd6f309ceb723d4ff08d39e332ae6a50d54e78675f973d12bbf8b00777cd4512f09b7ed599d92dbbb36da6f960dcd77e7e1b1098d1cdf6083b23d461fc350bbdaa421d7913717aeee161df760e2f33c67bc5431a8f5b57513e28e2c48fab2f8d0effb8efd3e02eb25e5d86db72cfefa19b9e060ca2ffcd3616f2404d3d50f402b8407aebcbc40d44146fce9a9370c3a77163e8a1ef8b8317d304aac885fb0981444415aab0f1cf502d0e775d3234079f8a13eb0ecd7d99855a795cbdf9fff6ee5edb40e70f8d5ff2280ef44967bc199ad302e4f4a7559b51e22e3a32fe37cc93cc0e8891986dbf9b55aa0b24274a2cdcc319dbd4e9f12085a2e7708beb4f9ce38780b12d54ef9bccf999287c56a9dbc9d9450b667df6dddf46cabced34bb282690be2255ba669c99ea3448cdc67c406ad41681225271fbeb9ad7312989da0ff235d3e33ec263c9e8923865ee7ff0ebf45cbe2aad2d606a5cec610b9862ed95993ecc7d4fc02518ff291827ca4353ceefa1b2398c66934f35ee0958e82c04c815fb13557b2e51ce60e3813ee2df69fef4fc7ce7a9c31d2ba4c5db59455918aa01c6bed11ff2afdb5bbfef46fbd5fd304718a8f4ffd68e6ed378fe7c78a49f17427f926b8a1029a7b73657661aff959cc6b4b2bc63a2ca3a82ca9c51795c7fa91e7f60267947c6cd36c8649914853744beb7da02ca117fe24b077a8b849ba9a9f8ad8836e6b66f612b69a84640b9e60373f8dc5d790cf75727148e6bf4bbbb45b817393419f7de6065b0ddbfe68b096836a5c22153c8b740ad3e5316096efe9dec5a81d85c015c1d5f1418d86c8f04e558e739f23c74093e897032dd0cb002e1d6e72b1ea4c2b14faf9caadf47e94436998f8825624d7809ba657e3315316278722841300fa7288bad92b19b7d64e567212c7124347d4fa421a9d4db1b669813cbe1e249f645527092a479b6a43b7ad7dd385eda6ba9b6b9825bf0fa7c96783cf69bb06b1dc4cb4323ee7c6e735a3548a21a46961a7eedb1f816d09f8938cd230bf783256f6e3cd6e22f51542c9446fa127102d7133d335fc18774a950cb98cf1ec77e3691022d415f9a548fdf920dc21077ced979c8f83f391ead9dba7a23e4a70933eba5373ca47abe76bcc88b01aef95b5730e35c940d2a222220cf18b51c02bcb830a60779ab05df94b6211aea12fb794ec81dfc279396ed0a9e178eef0def093fb654e5a3aa088d79efb1ae7e96ae8a66659a1032e8b6bf1e5e1e7192a0b0b6e40756136aaaad10b5bf3558069a855a021bb639359e2fb5d284ef88318ace5d3c506b89db344f6fc96833776042b6d1295463b76dce029295cb8b5d6bd4a5944d4aa3c57d954ac940b35f7065d71c437bb0fbce8716f143fc8dbbe528d271aa4e8817c955609881d677a7e5ab84320fac97253a355d24dcc50b9598a642df934447a812453cda547a76a34c35314a01027ce2fdc77320b7284e9184e022fe8ceca5a7fddb6ecfd70cbb0abcf7b0ff175d70f671280483923cb6e5ea95e672c729b21239e7df0b9cd34852edb18b98f062f245865ba1445175c4a595db8ecc8dff387baebe6fcc01fa27f8bdfc0d8875b90f66bacb2243c163de7bb7609a981a5efe9453d9cdad00030044c4a63f991cf164b63657d106388aca09a4280aa9500764259765ddd98729e1d6fc7df469c4be7b4f4b6e748c50e481b05b54171c5a8fa7df5ea2a6f99f3f8921eb8417e001c9faa225c8ccfec80fb52658c4a6b6d1b16d3abd66bfe7b516b500eef7e76f59787026254b2e75cf635d38eb7379cedeec0eefb6ed1f19a219a65eb8c4bc203756d58d20989aaff2438282eb1ba69b56c19781dfb6914551bc5eecabdb8ce3f77c583d71aca9b8b1dd0bd47e6751028a9737cffbb0c43afe24e1f6646072d3230e1d9a39680bbaefdde5b800edaf78b98b16f85ccd15aed89a1f2870c934ad468825b2c2a943608c736150b7c017717eaeac10260423017b016a06724fd967ec801106004787efc19ee245f93265c688d16a407085980cf08cc0d8c96e6171eb0d41db8fe1b2c301187cbc706a16ff505fe95994ff1df5dc123b680eabe005a2ae3b3691b25ce142236d3708c438481a75cb522b23634ad69644ec96ac9dc3ab1353f9a971ae0f69cb9f00f8e37e944b8ce80bc58aa11ad32bb63d9b71a5fc116b279a3a30a4ff27ed01cf744e09d1c951b78d814045259ec508ee3d6c679e198995568c57a36d061ba9b884b0471a96d5f7f260cc2764176660cb99de9272657f97c13d5d24e7c8ed3e35a06cbb925711bebaa4ca9234fd8e15ebe68f0541964171ce17b14ab690cf4666442b1442646d3676e68d2ee2dec0e0172ba39c2b3319ded52979eb3c59fce0116ec9312b9cc2088fb8551564b216019e7037a09071b9bfdfb235790e2b12fc962e535e0e5bd3e72835d89400daaf6a609b5597e101f59590764e999f8cd25f9b89a01ffc82e8c996d2405b3ca39595743afe2f2d416f61601760a12093da2d1a28857d880de6b64553cc50e2026d52f6f84ed95d530bd31d99b8aaa7ffc84137ba4ac2932f80fe34bfaa81e0edf234c1973521b720c7d7412092305de5eb84e504315e5c03ef9092eb38fdd99fa07b1504f2c576ac5f0d1df651b5e10c3ea0ee5cd493026b9e0345d8c4fa6071ae3ba7d0034a44f1622034b278716a591220eb676bce61ad45d75b6a1cf3d8f9c1d7005147f027c67a9ac31f9205353afe55bb97cf47f7db695e531c3157f97a37483620ad3fbcfa741b9aa5e343e75ba02bdcbcc2ace7d441cdd1fa9b342a540276e93e17eee1f4e3202ef785ce21699c8e4fa5159d4fc8b6d67bbc85f93e6596cb349cfed91ed484702592c62059b4d069be2b413afdebd4e97c742a73ff5710c2270e9c4328d1b60848c29e812a495f471095c40580ec853324bd93a6636503514979d303c0969f9f5c58b3edf4667f9a711587d2e8a604ebf1404153837c6281414bfdd9faee04c0c6c911c92633affa25230a5eca50c0efc8155ed46c20f6f8a9ca5e529c109daae4fc7f47ae71164ac5a74c85c8392858a22f709df8da937595a2c5b03fb5995ec510f1f4f747f0149aedc2eba9aa389718b27a60e7f26cbe756343a2150ad0d3bc2e11e0da2902f173271371829a488893daf2a2e42cd2a8b9405e49047a6ed765ed050b6000b586e099058683cabc6aeafb12197f95060891451a10bf937f839585328b3cb138d0954ea9f34b9401fcdc21f8cef1f95e34e8577b63c6a3015f74a79d2a93b49377c9928c12f542ef74613e43ce138f80d24732ba573fae2c92782cc7dba85280028c47bda98cc7d1033e4ea50d3a9f4c2e9c1370b1539aa4182b6976d80dab74d5e1d6e2cf4b2b57895ee0cf519025845c7d015088a8d0f1c554d7e9e9beaf70ce482f22cee69b7a2698d1541c32e9003fda8764524732fc2e18a751cb7dc1acfe71ce793f1cf27a8d1efeff128fbf19756ba4d1a5f94be1b137ced7058067d66a965e6b4f5d75a93381406a04dd7fcf21fe43e6bca9c9c33e1f41cf024e560427601035f8dc270f3c3f55eec16b7e24bed784c7250e44a5d5cab83068d8ba81ec36cdb996202e16618c463c863f93ae53e67231df0ec41bd48490e78f60963ede5cf1006c72b43566d803590247c91663a8c65a43ba0a58f5be07f5c1ff9bb67f29dc4132a2becca5cd5912a98541353495160076d871e1aadd7c0a940253763b9e55155718da1c4f5ec167617c2a679c60085d678eca5a49be6a0b5365098ea64f4f78709d5a1873910389e00e4d838f3bd44dda52d403fcba4c9b2eda60844c2b6018c60328a95ba73ae4282785df7b495ae21de751a04cc27c93943d3f1a8497d83fd98645572f4793f09e4badbb1e0f4876465be563ddbe9d59d8404fef57a92dc497e171a7b7c7f24a97e107c0d2b3a2c107cea7fb9ea9dd2efd330f97f77871e403e670d331f63d859845440e5a318f8ff3ea9b44f353c3f67e2f6b6ca6b0a97a53d99e81ba330cb0ce89986040dc439a33deaf2654c7c42ebdec7cbba6bee3fcbfd30db0b675ff64c88f90e3777827015b7a73f97205357be1ba2f156d5b1b6c7fc2dad432d3b982a075a8ca6055f4c2129699ae2f862277ae477c4c8754834701a5122e29595bc84dd11c0d74ae575e8bb8ed4e3de8953d55419b820bbb8f2d8d450d10157d6b01169f22a09c2119ecb69d460d07a1ff1038dc560e12d4afeaf380d79eb7dc1933818d3da3b1cfd7d84a4cb3543cebd4cc16d13f82ffc90aa8ecf4c209f89f806f28d3448b3c0d552f4cb0eec9bf14a0196899318cb4080c5c91a4acb20ca0c7e78b04e92c020de5b6323df7fe4b73ae545357d8a7abe64fb45c2b099141030a85279430a7c77ee8faf6507abf0f9d850836d8b4401216934cbd11219b834f57563f045ed4bc10ebeb3a47a870c035b549645fb629bf3371e667ef27f6b5f69dde023cbc3f5320f8ca4dc7d90763cc70583719b29b21931a1e48b3d23ff466dc055286677392770c34353a178e23612e93d736a49f8936444c7a7d28b29613f4f619e832cc1e2a48d031e1182785a098aed9caf497875ce889ea34abe6af18e82138b00304ffbe7f516b90808f23b6778efa84117ea96c794aabec5da76efa9fedc434a1621db0c3f15fa0f85ded9f2eda0b8088b87445c7c7b498851dad985af2578afb5235461a55776a9f18739c81c76aa9d2ec6c5aad9944df63579c3521bec6aa0eefc8605bb3f71bba36e86125f1c62618155c77812769df687fb37ef3059e4e6816d1a4be9675c12e5d4843c81eee48f153944ca0c16c39ded7476edc74e003bb378fe249907c1b991d227c71d776b93e98de35e6e77b8f27678940f974512194de54ce6e8b8613bc934510a8ac2483d644aeab6f4b5441ef30fb8239c476820f2c7b456e1da8010ecfc71016074fdef0b883d6595014481ebbae56db65c8fcb6c8476b2adf23394451cd6934db8098ff71b6159589d9f2431ca1ca9213be974e6e6b1fe87d86f44e1e33a6ff51c514066c5364a4ce67de8d0b9b5a46b4ea198b3f00ce55777b653e06a9095fcdea9ddbedfbd61b74855301aa63def772abbe8a0d1001b9296dcb9df1d36a8fd3a9ecdae563f7faa67dc4ade7e7b4f7596489bf3b4a6dc645f96f8d343bd97e9ab4ff247a11b0f9b3a8bc567ef52b6bb9b7bdd7e13ef4174a017557dd2eb7cb9b2482c5f8f0174f0719eea2b7a4c0c5ab6a46665fb67a5b24a84c994118d0a6d41a75ccea7fe88336b67532015a55709b7b831f6537b06bd48150e9fd5e26a98249e84bb3c9d7636a8b79286c3c19b9e6fd399ce2c3dcbda906c4e1c9aa20e2c89963fbc446adb491c4bc91ebc9ab200a35498ca853fae937662aafd48ea25dab867bebcdfded93862f05bba6362a2534099ec2c6ad3936249d7613e98921bd2de14532f5f04db8b97dadc10862584394ef58f9a1292a75872201d57253ed617f5eb83fe38484f945bcddf9c711f4566b9722233f96c9d1f997e8adcad2a573574978007909a45e95084d2fcbbd8fe44c9627a01cb19025bf272beea4a1cd9f2cb40639f6b95a9ee0bf4b4c17ef92e3341924f17990471771f4fae8a0befce4b0da805957ecc1469e26ad2ae26060b182a2d676a15f3344436390abc7f380bed138dd86252b6cbd1927da5f8903f8787553afd293700553742397386a3cd83cf97535b20babc52d3336e34df937e34c9ce80c0102e0ffae3bc82c89852c386ba55e8944e7da79136fbbed97004f56340af2b09794d0a99729ddf2e7110fd0128dd3d0211de44148a07821fd6b7db8d3c684a8a6e6fe6a307666d3ece4f06a289c628765b0f750dcc52a8848454769727502368d85b3b34f6bccc0d70cf50757d1f95ac68ee889146258ab0132f85b7d185f7ea49da52b9bc968dd414b9a0342f99ff016a712dcc9dfb8fa5bffcd149ae3f008dca8e3cc008588d09d5da2cded5f7570ce6f75015d1231146001d9b8f7f32f2ef16bdc93d70851c1bb01036651f9b0ca238fa15df7146b4419714f839612cf7243ef7b53988ba82911b521bad9c70391611e41fb63f1207e346cc1fd311200e9bc0506a7e9133987486ba3acf434e38aa9427b0a1b50971a62f6f57bff3a519125554a4ace407f028c13c10535abe3ce110b351562086e68aebae7a176dfce3a17323447c8d96461d7c38a3e38487d30bb270dd555c11cf54c32c2583c3207f524cc2cebdadf77c6670880a47523acffb312a5af0ca6f701f600032122a29978d8a294162dffad0dd8c1fd534cd42dbe826e0928b7a39aaea793d750b98d8766d5e238ad6ac938e66386387e8e7fc91429747d6910821418ddd92b3c8a98357a7ca424b20003ec0f6c2af43b3579a89dade21237f5206b1cc948d2f3afc0684268a81cc840498a3a1159a86434530b194719d4e8aae39806887beaefb15e3ed8793f52d08f4cc04f302d22669c8bbbd7ff09a7132cd588094e920e7b0e8305ba536df791a3d0b3191d58fe7469c4c75d4bf1f5ee148898bc6af5fbd4dfd6734e20859be6ca2e167782e96c1170d5cc51ad6d966a02b96d95f19d25a6fc62216c19f6b34f33ff55eccfe8c8334ed37eb61294037c168e238f1cacaf92e4a6c25d3a51758afad1cddfc2075156d714f02ce10f9c77d970ea1df4bc940b826f2e3219db9cbcedeaa9447fb791c97163bc659dbc42fec2dbf3cac8dcf874cce40bf8f9e06876d9be72a3a7a1e6e864fe50d2cacb42890641d340772090c11920ee8820d650a6f1d77547edf09dee44d875f7bc9512ddba16aa1644327d78ac4f942c5af31a78d52a36165cc00bee1897409ab8bc0e170c0fa0bae0ef49563676866878be24a7c74f58b5c881f27b73bad0625fee5bc7daaf681490e31538389db3b7b9bae34ac87a68d47012931f9a99851a09436e5e2feeed6da67f213e72eebdd58fc7dcd624401227f9b9bca8b523934fe21d89c2870c96c4601cbb0ebde86f44ad02be5628fa56a8a04a4fdc907cbac57b1806c72be7be9299cec8ad7ea30d8767cd192e34d90e897eb82a445b0a56045f9fd8910e3badc005a6027b088221b8b193f3e37ef685bc087315d981a216cc2f60b331ae5facb65519b24fc45da3caa9e62dd941aa10da841950f4c1569ee591876c46c7586c86eee914362d4bff5a624a3d98b94b152523f7f3deb61e6939c09bcc6f1913872ae2a557f7840abf2e0dfeaa76ce5a153185de081021835ee396aae754d3030cffaa359c9dccf5fef91a6276d7bba203cb3a9107e97b2cc9ddb36c2baf1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
