<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"702ef1f3fc6052dc3ad360bd7fcaffbfc2ca236c52dd3b2275412d9b4ed09ea4af5f26625e717a909b14176622ddf02a48c689026bd20ec9fa6eb386ce329abce4bace7c8a9da56b2b76c158bc0fcef5d72f3bf093216044422fa689c2e575a0eb979308b5f9011f2bfdd492053e46c2f7433d1faa911297c0b459273d74374c69cb3eb7c0e1aaa94cf6986f20600d9169bcc2172d0b7b84ccdba655f1c0a6eb27cfba858e249c20b4b541871166297c26a56b5b949859bb95a26e7010ca8a46789e72b94d5999cc93d166e4f6e27e9e803396f1c93902b6cce5de557fbe8f80e5cb6a9bbb0d40aa26f551077357e4a8573b4ef3e01432a7d90a756bc54b78019f31f20bd1a408611bd2a147fbbab53e503a377ff2fa91a256cd8c8066ce1a731fd5a019f605006bab471ad0c4e86a45ed5d80d73ed449ce434b86de94cac43f412d0241cfd3a9b730223c200196bce94e7da558056be8ac091a89a3b69eb1da63a4bca0f8f37a6368448897bb748c321c8a0f8a4027c7a064cafe29cce22a1709e040da9cd80920115d2c8ca2243a6ab92b936f198a79699d231bcd4d82a7210cfddc4d6cace2f7807d24e5990df35482cf27121d826a68585a57f47f6493c1c937ba3c702d0adcceb8ca6df88711850e66a9c0769b1007ffbdcbf0045f816d2ebaee2369adf0ee436a3ffb2bacb849469d6331d0a3e4ea7c5c0f44fbcbb74b0b54f8dad87c757c3f4d6ba5bce246d79c4b188f1b33b52abe664926ac3283b94506d3cd4f167995e315256da4cf389930a0c23a72134555eecf64f9d8f088f36dca2ad46dc83f8f2a97e3c9a2e8e2407e07c2be281d90b18d40d6d8b74b11f91390c11998c23ce6ee723bfa59bd2c7cbbe73f1d5ac6350fbe0ca8865d1c47313bf568b7b288204a17d184485ba3f116ac14f34fbb0f85027c7992a11f24ea2a218ac87bea28b16f87560d1f33b3ebc97964f59fe1d0b3d0b866673aeaf7c3b3d57bb9e040efee6be7095a8440d7a28b60488ab39586513d86af69de1fdc1720a338a0db4f7a7280e16f50287d8296ac6a7f8e95b51bea31d2fab1fdaa9e1f8e5d56a295402a5f020e8a5d2db10a81951d9ee3b3dc82ab2aaa55c8e0ed9ad52798b1d1e0d5f2527477583a5fd8d754b0c521b3f96a091b2d7e6b2034f49d080b5f6200faff84d10686f36b083f884e5f95652d535df0b8a97924fd4dbe871232bf996dd0715e84eca8e01acc2eb20929f24f51bd2843a1a32f3b5b3845dfc09ddbd79bb7ff30870f479c1a0d71b1f13361a69a7e12e2a058a343a4e180295dfd66defb19f5ce026b0eb64ff67d9de0fb85e2d241db6ac07905b48b5cb94ded82096bbc83119fb3f45b75eaaa1df259123ca4c62a88ebf5a3a8561955b4b06847a44e4ffeab266bb74f3a97cf365a8884f21c977a45272d2b8b29da8a3a834aa81fb78838ca541e70a69400c2c0154bdeb3dc46192a9c76d473add57e254ae22cd35546b39cf2f2a4123cfc7a01b1b647d47f5d4439ae629187129822bd1895520dfe7142db967aeb9a968f4906ad11879cbcda85b93a10cba2ea688eaca0db9cfbc6fdbc6b9cdcb1d6cb41e0e586e6f6e3813ac861bb410f42f038fe870e7434d7c27b9db5fa107042a087030c967d4176fc7ca7731c74e5ff6911358f13d0bf7310bcc3ada2ef779c7031b86a6ab1f42b041e72f6fafb2563777b007931aa405c83f07f82770a2fe4e3415fd964ec4d5bb4b364e9c334ea85f1c134e34a7d514b9e3948d113bf292466e7e739e02dce079eabf0cb2031eb1b46f9cecae2fbf4e3a780002d608edb6effe85ccf517a173cc1028d6df9c1fe6cf96bbd6ab5df712c3930d13f9dfa64ea3d808059cf52491798c1bb83bded48bd6db7bd1ba462dcaa88b8a3338417de97b5607480591ac04258bf6d4c43aa87160a46a0ed9662cdcedbfe7b06f534d10ee7e1a39cf11a7d5e0a7a48a758aa54871e8e22686b8f961903f4c27640a2b308abf450776c66980628ebebdae6d2be903478c7b0d40adb27903a8a047492f21a8f0f5650206d2db8463d9874efa7e98f34f2a385f0537381139ff1837a9ed8d0f60544d5f022d380eac28dacd04854219fb4fb50c1ddd1cd4f297033886554d668d4dac1b166f9d98adcf884b0cde5d5cede96c1e0fa4af1b9d48eafa7a2689fba3b6de4934714fac6a5c576ae6029e9736ba5d3b25920d0e46824e83926bdf82d9f6fd70111329d4ef2bcc2d87325b1c5b844d227e7804b514417cae5be4e3692ba8dbbeb208f6286daac46f005fd6dd1d867274ab2d97b5fd7aa6b9878ce55e524f8a8026947eb9fcf0aa77f86c2ae28becca3f58f48102c942ab1f4a17eeddf203f1407f59fb7e7cc720c7582986bb551989142193ee0c2d035f2f2700043f5a5db33e41986d617834f2bef19eea401a80b27a59986ee82e43a56d9896fcca3aad06f5076cd0df6ed5902a03ff3a775d4142e6900e0c602dff974491f3a10079c2784e86c8474f1d0add42a15d03c4aa66603aa88baca88217c399e5ad9eb31d56e38026dac3881f5ebe66e6515e85b35ecb75f5ac707f09f784258f46d2a409c5ca871784f7dd2bba63647c856430b5e433240db463228f540d5f88271daeef52ff77ce08997715b9445fae86d9e6c8a037e120c7b6500b78f1f4f83b6b25a49f7336d23fe5bd1025f564957bb2dc22dfacab4d1286aae3bcc64981c2462051c48e40bbfd65b62b669801810106ce1c3e8a8814e55f95d1dba571cc717c2404ec8c0b46d1e7da4178c4df1ff70e4c6ea599ae2d314d7473ddb8c7f5c6d6348229f8a07ba55eec2593bc4af4bcd0ff1facc2f408c0fd3a124126e4256a6b784fae31905cece046738e65d0e9b4b7a3b53b31bbc0df3a9bedba7e967d8e79014c69ab2a311c2281e1a73da088f72c0d55627f53470e5590461de0449ceb3678da2e831102427bf3cbc4722a310c7fc30069c9bef9ced83f1c4135cd1f396b3a80ae2ddac567f6561580943f649311bec9ed7dd39a503caa9941c89aa87ee5f74de91bbc2fee7e52276a166eb7b3f43b1707a129c175f7db682f366b41cb5d153a3675df1c95c5badeaaf23a5f5ad1811964e5fb9a415740c2f5598e6636124c4941ed08e62f67487ebdc8f21ec0d514d3cdfd33e7cf2edf1e2b75b3008838b92460a4d5f0b1a318515a2190c1b333fcf8281ee4176cdcbab84e79a9a0c688f7c51f37e1bad283c37949aee1657cf93b03dfe74436583bbef8f354b73c09921dbdd37b3ca05cd7e87a625ce541c227d7f2cbb0e043755bf3d397f3a3c6f8b9885876b9d41ca77f64dbb997ef89631adf99002e764e380feb222003585af53e672742e10ea95a4edd59ba13b39f1375c4a77c6dac2ecac545a93db6d80b9b3f4557f27eb23fbbcf8962280b6936fd933b3191d8cb0ff38df7aa7e2e056ad3ac15ff39c3fb19567b57ca16dfd062fb2e6bd6219efe750f132c1fbadb76a841f6e00c1bc7520474daf6b1847ff43200511f38ec5fd18f924c9a80fe96dbffe996f6b2947aef6bd70bdeb165c11f2a7f90cb9a519e0c45b2f622e6a92dcf26674442e58b43631348d7023822fa6a1bdda3660a642f3acc1f94f31c6d1a861faa4708d67d65c6c4a3dbbaa599763057c92139c3606a24fee85d3bf71dda416c2bd447a1038088dfd09ed6eb5af30c119a757aad58a660282d88ea3ad7a607b9fddb739cb1bab456c38dbdfcfad46f5a7ec94f889383808b391f5842f0739dc9990b2cc2c0a95fd56a8cb804a6c7b3926566cde152f9ac947c08191500850e8bb3aa2397c37b770286b445c5da21127c1579d7e26819ddad9a9a4a7447f492f43cc8dc58ca13d67e480e21369817fbc546f481f6511961b984e59d3c758866c76529013fbb16171add95f6ba9234bd23cbeb8b149d1cd2b99ed4b1a83dec33369252cecd174168de1335520aebff2132dc3377f2e127d6f6f352a6b1c24a2764eb28ec34476456b5d155e5d8aaeb636a9b6701063ff52a8e4fbb42089e8786c016e94416047c96207bec9cae8d4f3950e31f3e74a7d05524ce5ae4553713927815b69ca885741995de2944688c6d6ea7a33de2c71ef82763f15cd1d4af997c48cae64bfe862403132f77105504809b21794d44bf48848f63a3d06a21c8edc706ec4149d691feee55c52da1fceafaa0679dfd12b4a4c3127f87465c9641716d2ab47d64a4a19d065d8ab539751a79caeba23343865fe4617d87c969cc26f67821b35544a76fd4f4da4c1243e475ec9af61129dcd23ae9015432e48eb3a30212c107bfc00b241da30714edccbf6b31164b7e840e9e00da7f56356fceab7d23fc307c606ac8a8ae8e1a5256bf2b6207423fa01a4c8773e499cb6edf76147543a4d3c75fac686dbcb313a3dca548ed7ced439b12b339299e1d95314de498faa7d8520972be43c06388647f7ed3b188699dda998317876e2dbaabe94e62c0ae09933dcede92e54ec6ce7aaa1952fe043c0d184580a968dce8397b4cfbd06590ae837a4fc2112bcd198b277447bfec52d85a9013d67d017fe911d46dbfbb6b8e652c659c8dfd0a910944660e90f631f7ea912341a61f51c63d4d6c6a37d7a4a106a39b2a75565d0b192b3e61577048f985af95803773c42460beb714c609b015870bf746aa0fa184500f366599db66882ba23cfd7d2538fe0d3529027ed8ffbdc0680e516e8006786eaf327daaadab1ba7c758141ba156e62b5dc064be2169d10f326eabc82d9691e0cb7032d09598914851738b5977f67a33697afc8bd165e2be5ace0167b15b73fe6d284678c073c19637b924dc12c3cd9dba4a6ecb8b19e704220423c26029bcc54832546d1391479bc3ea4e9e54ecbeafefbb4989160f577a50a7f3b18c1546a983554581279bcebecedc42c45319231d291cf3ba0984e766a197595d5ea2bb9ce08c6f09ea8aab798d58a20cd4963041b0ad22755b4ebdba4f6d4be05d50ec5c4755eb18a834f6ebc469a8324a49051d8dacbf62f976bce5e28a10778337bba6d01f8e744d7ac5704f11b6d3f2956eff6c06b71a6efcf58d8830669bb7fb75e43134eee828f8749ce9c5d9f5e05df9de025fd94b03184b78c3eaff1c465c7440952ef002191b5e2802b87dc71ec97f122682acb5fc20a31cea275a83498652590ade1e8f13c81c3eb1196d8693d5d7a2a60fda210c3475ff002f5fe2ea1627eb0c9f92e10900e187eff07ae6b87ac0ed8457b8a515382a9436b24ad200d76c81e506e945c97fe19b85f1cf085305c1704fc5cd1c07fd389d99ff7b6b5091194619479fdcb96d13af68cb774379e42ad371d031ce7351c4b745c04aedfd96916484f6477dafbe334f12430506170840d8c0ee0bc02941def43df2e8b35c2bfedc0eda33d2966fb27866d87c1847cc3bcc4a954f36b0cd33cff48fef98db5385d67154260f659662f52596072d6ce38ca473c59c1aa82089371daf013f98b7ac1fa6a47ee0bd22ed797dec305982b5cb1ba2c6ef2e829fd220549d745f50a9d86a169311a45ccf95c84a774ca281371a4d8a281dfc4a5e24088b7ee87401c648e92d0e3b3e8da09740779dab66a9ee147d4ef2f6cdee424d258aa675a3f4d1007c1b334e16f70c98e45bba836843b98e624e7cc1a13a0a99c5422048693db81bf2fb3f09539b291d30b5264959cb62d0d480b8410150eda2f7e20ae904d10693315df1795cff00519f49d412196ad7ce4369dac0efbacb26135703fa1211e6f98ecd96b7bef3c77f43d1ba10558a3a87219155427e2c2a06b1384d0e32337250598213ec9f0565b0b65022385453d58db55ae5dc7f27dfa5c7c9e3a7285dd40ecabcc94e2bc8827573cdd068f1548e7ccdb01034b3a872332ffc9798f8193be5c3d26505594aa36bbfae7c7cf5c582160dcf0c1326799ee2dfc38836767e54078669191b6e551a47434c42aaa524c5dd3542f8d153f26e81bf26ea6e8cc5a6517765177489c92b48695d25670871ff8edc83c067522c564baaf6ade8273226bc0b118370b390f614f11cbcdf61a1993526dc03dbc9c2c9cfdd10c304bbf6ee80945811caed32948b63f35d4930bbcf97869dc0d33c5a3031890217bd12a375563ec56f0fac9a965b73441352db57d1263fa3e00170b2a260199bd74bfcd518ea23638a8d1c6e6982bb726d4c85f23d762d27e1b02232e57c80bdad52d2bc34b1a68b4751167f3ffc0cb9329dff55b2f8838e76fd10cebc141c091a6064dac163037fb458ec0eae6b714640edc595e754602ba934271c0141244617d9ce8f54fa65fe89b3857e5eb2999ddba198b4c0c64ff8cf79ad8d988d5528e48f059c75f9603ef2c548ea33c08dffd344c9a8e3625bd51d47fbfcb7c49dedf14e1f394472c2e3fff27683852a7f0464a8e997b4a0474b46dec1f963cb0d4f73756ba3d7bc7ae6a6984be15a4555e797e386e8c444b1d37d8a95086dc5f423e9ac1a21d2d9e39680120b1dd3e13cc35992cbc3b26178683eafbc52e11c406d007b5cecfac0a80da0549925efbc0de5494296dea241814bd1951c93e65f89958308eb69a5bb4fc180bccf94771bb7e985b73ac1989342f526616a1c8449236f65de77d38e32f817c5d3115881bca8e09728c1e48d60df0f242710001751d6995e941617fd655fe01b4aa6b15e4260d0703e0c9411a6b468cb6cd7d11c1599ee1b8a2cace5951a02469ae5868f29665622c4e45ef64c5df6c2a63e295700143623ee6b6c6819914ce280fee19999afc3e8784a0807da484ea327266f9aa556a466a339d8c751d23dc3463b1e7c1d280de03f4d42ddbf675893cade40567fccb66debad726922ec4c2baee3f99424dbd360c678cdf9ef194b6923dfdb6743fb5722113e83c5e98bd66348025874b9fb7431da660a29ae3be5cc82297897ee9ae36180fdc77462b5c38171a5ef8d3701f2e2b81579367ec3a752af256bb1e598820e897d90d4d35fa6da7284a1534ebe8488400af4afb4f7ea86e58b650870dc0140ba527517f8bdc512fc6d22ffc6db31a4a7b30858c26d3dac76e2c2e1c3afbbaf4f1a9e678d3b225d220d18f48eb3012d6b3e0a4451e80b62de5cae4aefe297903ffc89ff6fdcbb7d1ddcf35100ad125a815652ec7551c0a4ed98b39476adb5f6bd567a9d97a8e4d2bc51171ba91e09d50f9901ed1060d99c759e3243bd31d640bc49a344cf331f443ce64855a40ac8eba26f7297a28275d73f34ce6c028cb0f841184bea4822270ee79fb7c171353058f289ef3122974fd7a077bfda29324b7a922a94931e2c9372b02ac763c3a002eb049b4061864b70cc298ef9cbac2e64d93a76d209c7b45b8f2b402beee42b7c85f5fa1e07b47a7069ee3ef114a286322ff9b45922a6dbdc9fe385fc591a280248b6875b036d53e591aa88627e40905e8f6019c1d99f4a0916ff21d7eb95e0d93f746a1376298652552ba4ad7eae49ea13894dc4e0ebb845016359d1ba7b226fd2c91247b3f0b96603a9adc779686c1d877c1c4033cad743f9a865e0b775eb27993506be7fb77f67e63a51f45c9d4bc2a460ea17a8f32694343191bae4e04ba581ff420276b8e99d39b5d1ce7d5ea656d37a3e9cc8349dd094eea045a8f248b198fbcdede1a07b244f0de484248f0ca858b5f10265bade9fa1f6c0878e1de817bc7511297b7983c9e4e7f61cd508e10ded00c0a9b5906aea4e38c856c18df4bb532d7fda01e146f44dcaa2a2401f647132500e5059f8a2750fde783bf19ce85f62425db0748dd1bb21373fe9910fdeddda7b928df972daebf2b2f3d9b49ee6d316e702edbe689e9941f663fd98bc7b2c85f8b197d4c5e665c1422cdb81a5fab32ce4772d3b4b73d87c9d0a1a6b519898e2ccf17bd47f9ebdfeaa6623376eef311e6be2cb33d7cacac5cf4ca1a74d8c6aa65112c2786acc309785f4fb0386b8d7294bf26d307b27868d4f238372a334cb452942cd18f36e2cb75c97d75420b7a1097b256f2a7b4e883678d5b6d210a879e6db712f35d7a4f1b79fe675cd155ccbd66d61b1bf33eed20dbce33a446fcb7d799b6af8db5ead1f8e9dea5908d131c506890a8b17986aff00af1ee447c3745e1204a250f6f880d832287f8e43c2d2d087f6d3cd699a6d6d1073a1a8a69fba6d66fa5f265e6e897fe5ba8091d6c0f76a1fe2d53ab57f3664852e3199fcb171f06921a78520483239f4a91ec97613fe1ebbe74fe3334bc9860101b939dc763e47dad1874caf7c60b437d10763635f9f4fcfa9a5691f397188281c9ac365791ac61c6e50f6fc8640801770ccbd32da55f716115b3cdbc257ade0d600a29928de98193486c0b461f5984f592006b779fee2ea6dced183c84c0c83b16a263ad6b6be19d814dab66253eb9e45d4b0e17d8310122f9ca2f2668b00df5df169016874ee8db2f04a8af33119a6ebcb37cfabe75a6291cf4eef70765735bb96f21ad8d5d57cf860c488a8bdec0490ee972ed70c23b3aeb18243b633796bb09f4d6942bdda753ad168a3215f2138b2c3cb70da13618980373c7cf1e31093d547a66417f2252c17554087ff717614c1fe0f08407e5e5b6073d71babf765efffd3d3b95d0a76b6b9cc2e8cb78dcd5de7c72da102376ef7639aaa01ff5fd153cff756a09c9298dd9b6fd20cfebba91d97a8dfb7bb4aaf95a7307ffe57c8b0bc2470178f93c4a56febe4d2f901d2121a993c6ca5d2692c8f2ef8838f149f77ce83be6cd92b3fb7dad297c75694c7f89a23cc09b177f81ca41b065ebecaea9aa02d824a2eba251d346c4f0d59aaaac7369f849bbe10c5e76ef48b834b52189494c81b4a70592c43ac985174c495ab4be09289a26d75b125807c04a143b6b9efae31950ae7e580e8244e69f3e584de6d15c62d71dfc4df32623dbf51500e79f48f67f0eb09fb40734333a3f8bdd75f380f5159028f6a00dec0ee79003a3deb14955d91739c2ab9346555d870adac0162f8106d9eb74d771417d585f8fd20934a3d76d6d6c055644509af9345006929c96b781610a69b618124d8fd59a6cf8748e5dc11260f8f2dc18d76fec4fcb98434231f29a9185ffee30c4a7b1bd28e504b4dea1641b77155f2dd5b0bd5c1fa78914ed37fdba6f1cf3c9850ff4e465ed4c347c60d8ac859c7061614d9acfe58d5d0204a865f1c831e4c9686481398d0f60eafbe6c5bac8066a075a92f24a98649227ec8df3531492cecc71c1726e99f33e46d08c05458228ef7aa058e35e2042075b4542002fb639e9df713ccdd5f9499f51926626c50ef71ab2aa513fcdf844f8d7c00b6c4bcd99f48d4094e6fc8a8084fae0834fc08b2f4f8383e362dcf5ce5b0a0c68956780e1fb65a277878fc2fd38ebbdedb2bfd1fda66c037c1cc8c3f6dcaa410b12e266e0019a2b81bd9fabcf2da7a9f575b4db9f25e78142b9a07e439c1f0e4ca890387e5497ed38b665c4fe8fad1b8fc807c0acf7e25e7b3f8143918eecadb641255174454f01d4b94944a72bd3ba9c843d5223dc1147679e4b414fb14b24609daa74491f17d608b721a14e1665dbac23aaab09d90de3ce712ff7bf7fce082b8f43bcc49a35bc6d2b4a13a7f9c08dcc5a71b5190d36bbb2e3a516ca75d0d5249331cfdc33d544efbd2241c072f566e43aecf726ca937abe9beb73ab6829de3c8f126ee5c70095a1ab7772a198b769cc23e02f6caf9f23a6a9a7a7b204bc3abb2c4267cfc78378272e245f99dac908eb0373b52c6f864b1aa043648c2a25677f018f0b593d6bdb883d620b65d614126637940a8092fdafc497b49fbefd6f7ca99230fe8712c2c5587d3b7776909d25e25e9cc3e3e54dfce26c9c1ee51be917d71e4e8b3a96e694637a9e5a4353e4d2a7f05df31e84b9daca5ad303409e71030d107da36bf2702d3a9428907a5ffe1b9db415e4ad6a352d05939a61e9c85ea986da80d56de5602ff0456b32aa2e4b27c579c2b061d4eaa30f9c8d79faaa581f79979139dbd4d0115122e39a2268ddd5601a96c790d000ed9ed5f48369675d504d2c2fc3d32a8faeb2e1ac8394b13c80cf7ebeaf7784720fc979695c9356def015d7088d55628472045fac92ab0d1969ea9e0767552a70671aa96baab6cf9a4db834deeb8486160536f7c506475c9b96cc85aee4fa2ea6e718cc6b7df35446e30d6158f6803c73a2f40564def4851f3e7e99dc3c37d9e1f31fe34bcdfb8c971deadf18f1448629ae6e356f62ba1e1e35770b0aefa735cd42d0ce0ebdb793408b779a61c0d5e23bc3e1a77e2b1da65bda8dc213431556c014759870a3567e869a9d85a033c8102d1d163084d27ec33312d8ff52d2ee65059287200f5d92b6cb2675fc77fa1b459fefd2d1d18186fd2417d5db43ae0d9de443ba4095ba4e74c386b6280ee04a877aeedd3ff01e947f02a55b6ac3cea0439715e2240cf9002d9b27aba6e89ae4e95a2f6918b823de28732041d67c9b367e2165f438aab2070988262d24a4ee51e36662d83239f36c623869aa0a7f86e1247ad9eab948a2b9049ac41fc8e3b8c45c70788ac9529184d8972458048d2b93287461cd960ced2037374bc0c606f1fcfe8a96c155354db27fccc34213515720db1f22ed545d196fbdc9cef7195951124070b534163ebf51111ba461de31dce47ef9ba89455e51d6fe8e3beebfdabf0a142078d021d7fc61a9935c77320b896a9dcb1a0a6e4d11e199b8df6cb8fd3dc0b3508276d4c37ab765af9f62b137f443089bbe143da012b0fef197b62328eedddec97cdcf1497c393d02172afe02f9d2b7766479790177096ef54d14efc1e642d10ea66988fbab247e8c4934c44b2707aea0e9c6feec54861e3405809be09a6f263b3c93fbfc643dd9e23a8ae40e09b8947c970a66f5f4b02bff06f0270792707457da185715ee7cc4176827f969a061f0cbb79d2e1527ab4ed8a2cd8a4dab60980cd23b202a71db36d71430cf49c623daea82a7d1a9b2b3b636ac158b6f8d2c8b5bb0e5682e310eb82a25655d75b9ffdebaefa734208fcc1c328615d9b15a4a1b46f24377b392262ab351cd78a621b08c0575da17afe3cd996f625a80258f276db7ec2232ee3bf19dc8c7cb2ed04065299ae4314190f7d3580fe0fabed05b68bee39f434fb1dd3cf39cc9d2a452f87b7bca6e6af5e91ae52530234e663c915ea0765a423fa33ea1be0f81a18cba9f2ac12ecd36cd948385b98b5efe05af05d7a5e1fe0d5239f9c8308c6a3f20a4506a7fd34a4f687109e3116f746c31a911641801c71551a11edaa245a9319602ff66293654f4ae64ec8e025564e493d5412df2f1647088a3a569577351f4e5ec2884869fd78091dde2f02a694c2ed66a4c6254240c9386ee2a2c1462cc939c2ac36e18f0c84602ee4a5fe9a1de533ab66f46cb1f137204bd909c2666bedb4b3d78b576021c54d3b19f4a26fefa44232594a7df6c8e12c5e042e79144823bd3e49fddefed2cdad4ead54797f7088e57206c92b904591cb7e724a1e13ac4d1804f3979ef38d4dded245e0d6f477abad9b8d95e3f1bb214cca2a76e469950d01009ed8cf34136a43a81d7b5c106299e9352576376a963a333ae058834798f7f25ab0fdd179d4159fe90413b0421bbf810e5d611b1b1e4fdde46b46840d17421f96664c54d2468de4ea56094a327bdc5ead156bda14bef994333cba096180c0f042d187f7babfa12c57a36d93c1d6b8c33f7e8fc96182df61140fc2725576063db418f37feb2e406cb014ff3d0810f24474b10abf215dbe70b383d335b62ca2ac1efb6315ae85a46a5fa19f3d2c8dc043dded0891b8a56980729644c9eef4eed25f2ce3131901889bb0e83a419be2d85f5cdec7bc062f0528706272b58992dfb656510c7a37e399ecfe4e5ab97ac940d77c51622f2adfa4be4431271b4cf51c79f9f57f0484121373156dcd9f7257fecbd5edf8578ca9120bf9e720f3fb8370307dbbc3e86d9b54918aa8ef8b8dc28b5ff85bb7014ea221bcddff68e359fd1a69e1583e08ae67e185cda6186c1eb4dd9dbef183f944ab78fb381815dca04ea443c74f7eac8a060185c2938b9176f24b6e84a0e56d4ccdeac86efab76d48b91c99d944d813804df575928ed53ee0371638d4d3a6e8b32c19d8e9325cd5f5074b0edbdf761392ed3ee77bc9f54b9a052a13942487ac868d55a4bb3b9d2e8d9842d7871f5f42e6c108755e22b9fb8707ee4e21900c556328c7d39482d0dc7025469b457170b7bb370fd002c84de96b60ecfc6baaacf67f99ffafc04118cf64a2075f27588057b8aeec01bd8480a7b1da6e6cda23c1f971ac1055adfc2af6cf6f66c7501cb1fe066188c3a5392025a5758bb337e268affb4be723e239267c70221306b11683bfe4916e9fb3cfaea86ed05095d2caac21e9b80c0f2ac3d430be6b9352c0f0323c307d37c9b76b89d2d022846bbdf59f125af572aad3b9bda1c852c14fb9df47082b78506612fda9877e0cbc060b769834a1d98f07db17d1ccb341970a83ee6b9299c6a683cde6c65e8effeba1f15c0282448fd81a670318e17c7ae16965dfb889a44ec2ef90d9f6eee1b708aeefc5561570d5769f3a8cfe9536517c1c22629a874428bdff83dd43968b551c2af285f10698d2ea9fc244eaa0fe3aa30702d845ac3f1ebbccc647af929f2b3223f8b6f0bc82e0dd405b14809598f3b615ffe07a704fa2db1f87b6ced0074ab37957d897a44819e0f9d6fee7a3f338b5a40793c5b634df249aa505c04fc599cc687616526df84045e15b4c113faa6ae01041fc94f97cfdf01a11e95bf0538c5245fa9c23bfaa41991e324674c638fef97f6d70d53965adad49cd801d19241b89bb9b8029672a7eea29995401ff878debcdbadb8c2a2581e19e5fd62634d1dc8d48da167acc2abb089fcc6ac8c182d057cc761b985c9d92545d2812326250a84d029c7da99ce4c2b31cde2e6ec9eaf308b8409bdbf1d5c34edfe4609f43d9e3c360f7af88a0bd3b155f381fe8a492e43c748fae75340710f578d1012961983713c7a9ded75ec0f8ad3d813f877a8f3e1dd98c2aeaf7793f530725db9fa867f52b8dc4a08635ca3b0da544a3d00c9b264bc882e3fdb33567d7eaa286f49a2ba2f9e1d9f668ce32f60e8ad4b3516f184a50fbc1094e02151ae80cdc1f566524ab7d6a83b512b03fd8db1e1f43e4fd3f943559e6a412cd796449ec3ad9373afeffe23df39cfbb37b2955e45571356b85035de29deed1714e8d766999fbd891760fa9937a6323d8d2572004886c0b1a543bcd9159a45a6896b41f0934921a09e54cddbcc9d1db7dc6d5679414aa1de871c4f791220d8298aab3d7f596c9061dc4075b5a3c48d503a7011716f190c8a6eedddb3e2ce74d1e3dd5a4f80cd5c2cb9646f66ea39563fc841ae657b555d462b023e4951b23bcef567711c3e39bb140ebd2a2bc2453ba15b89ebadfe92e9117b77e2d96e20fe16f59617ac693342a8a257935ca52b77ff359940f9c515fad064f27b9b9877d7cc53b04783d275a65a21e009c0063905865e51260815f534b69154df0c2a6d38bbf636e8df474d81e8fc61bbc3745b4a5d8dd95b3fac080b39159f493ec0bb3cd9cd95fd9fa0bed0598196c59877b04184ab9d0e0b82115f1e8201d2b855dfd40a933c158cf89be9bf6b8826dbc148ab60b7575417967d1455308743ad44a4ca0ede2ebf3372b1fe0b185fd1c9d781e1d2483bf12043f3576f298571b7931c37d0d3c81f683a600677524e97092cfb03e49d180267c8cf6a595d22c59e4c86d3ddd56f278bb8122ae24164a7ae2a035215a80153ca0caf006d187a72caae08e512a6324872071264368e11afa58f1fb27186e0f3cadbbc606e3d978a9cd16c05a7c41002dde13be4d52911cb3da120aa27a56bc34bd6779d3d4be3e542161725b3fefabcb29427a5dd7dd81621fd533ccb6cf16bd8494dd1527a83984dcbce834532e2c6935d92c4433afa07afc88e3bbf6da5b4baad70321a503bf8636785a8f6a11fb910a8ce04b540af1efd339aeff652e04952286e2a887437f241c6518c794be820310d20b4300e94162ca2a28791f4d78c336f92d7b2dd396511b30663b0018fb6435365df4c86c10d017ecc4cbc77e870129700eca9f6f6de1e5149c5644d59cea0a21912ef59ba45654a5837fc50d0ea9f12b7e093557bb960bf459842af277386cf115c2dc5b85285dffe360539df8511ea71e776974d575e8371040ae8e452331eaca5018727bd77fe662c3606d5b0ad7c2efb7f4a3b6a040bb3fa5656d0ae8598441d7a0c3ba0be0aa3b352ac78523baeff20b96f4b4676f7bf4bd96ef6bcaa6a067aa6ec5b77bfc16787df30d099ab1b17db7c0040c894d65bb6a6d55b6cf993bc3137510347b2a68a1ba41d3b6ecf5fc0962d0d1eacfea09bbe1d2303e9bc4bc95d0c64076cb4bd0f8f00b1400ff3b960c5c818a42b15b3b2f08a97698b0b079cc11da9ea80e7272f632c4576f3370c6470203ca32140de49c3a2feddd6dbd47dd2d861a5e445d49c7fd1c78060f2643aa1f4d544d926a118b065ecbfe74ecd9a7d40c0c146acddae03d1e265f73bb44c6975c11128895653bd415931dc71851870c811542da9f24f6f3eb4ef267883dcf745a93cbb791aa627b6db54db3baedc3e73223f3d1d389dec282b38af89cb55de62a213ccece6d2ae9fd461bde52760c61384f3dfbb53d9e406ee40979e632e946c4072919965aa2bb252ed9443973d6dc5d019ab0684915713bb485cedab03717c243371f5799a35c93ff8dc1d54dd51c6ce26752af53a5878fc7704324f1618a7efaed3129bee0302593fc9f533a5c9c80d2e55a8540d83ef7b6410221aa243be593c113c6c97b6bd8c7797c056a6fda5d5f5e5dc792d84560b4e0e42ff2e4f40bf67b43096804c6a4ab26c88844bdd5775bd2116f66e39b66344320a1c027357286b6e3647a4ac4b63579ac6dcbb3a0a4e0ed094e6c179575004a3e98cdcbe04b4e9fabb3470c7a0ca5d1fe876f67ea223d531650018f022bbb2cdfd3da8f74f75f12ff9a6f8a2e18797f704c7c6c8a3dae82d8502a14bd11dc08e18f97023753d4d7ae06c2f7880b7c1ca918d0d3117d447ed6ab4a1fefa7b271e87086728c4828bdd31c68b8fd3bdedd88cd5123fffbe8a78c42ebfb6c0d3823ee85a4e60ce74b8122fcf1e6c33099bb1edd160d4b5e5d8916a9ad60147427176eef71e240c8a5e30e3ace5abb6cf290e9feecdd34b5c82563ef05965b8933e59f743e1d8eac64c39dc6ed115a730473a0244930b77c6e064b944e8e724817d87e140f3c3ea67ee4bae2eb9a697c19cd842d8fec13d930b85eafcad521548df31d2d3f9e28cdc0670027a166a2d9fcb2c02871cddceb830e950e6ea63e07f6385a2eb81c7d5737e71d9c4151f6dc96a3168baa3a6959273754c2cfbc41c1e267713630b2310ece6bb397316dafee4c55ce52c11facee0d93c8925ab446a63ff4f4f223ff85c79467e8db2aa1a3ee14461cd08fab8865c4d74f75969bee6294555507225aa754c28ec15b9d3060f221187551345a89ecfd7e023397555ba15c0350971e31aad55d0e7929971ce63d3d2efbbc2cf8d5452a80ea02e788c3a2b4380ad38816c53a06ede1d802de6749ee0e6cada72d66087d9fed41c555a15e0062bf4a148ad58296ee44785520e246f5d1c6f608b3843854ec18fd5677c77ecaed9b235cf95859eb943fbeeb6255c5d7dde8339d095d996662ad71ee30a7f59857d2c8d16736348064bfed3c5713d7eb63853faaac57d7cc548e20681414924b907b4b69dce966ff1c79293b148ee32296e6b6f9ea044b971fc3072be3814283a50cca77d8c2d4cd47ec70040252b72b93766a4ce2ae8e64b1480ed02e70279fc8c7853bb3ab8686bb7ac26bab93a6e2396658c5b668e271ea08e98f844ebaca69b62ab7ee9af61604fd3250168f68934950b6a8fe109e63a79707974844b3f55c11aabdcb4534bf15fefc1a4d2b098a121e6c666e18bc2d447a879161c7adb168d3b6522a97ae4bdd2a3ed90c3d4b02759d2285f7a50c9afbf5fe95dd240d44ac9d50d630f63eb5e4776df51a2cad0f5902ab333ac00cdcdaf1f37bb8cd4a2d600f95f06339288261e43bb8635349f5816ecfac1e12613193215df76c2c53947df0f937a28d1a45b02a06617e9ceaaf7a66821fe262da7dbe28cf3383791ea338b9873cbee14dc03def1fdcdf29d326a9b3141e9bcdcc4924912b42d5b99aed9233afbf117d64cb8220d783eb9b6b482b64998e2125dd5eed96a908b71c6d1b8d307b1e85a8ad8ff4794f2a37a7c9c05747aec8a0310f5e303c591f6b3e72b4cdd12eefb2499d43fcafbc696204b6b35aebaceacfe5307730f1574071f88c6887de821b595f8293cc57919ebb24bfef15a9584490c445986cec5005642d376dad419585e77f02701ac8f2d74b1b9b6f78f7bf8fb471ae19ba00c6999c433e0ff89fe04a4caf97ede43ebd0061840138da34006b448537777c721fea2194dee8d7909c93e6d1e82b970b8868f0650c85d0053d37dceb74fff3d985433c204d606665af1f06e096f681e47385e3c5d3f7a7a9888cc970d4ced17022f521d823784ecb8b7d161bbc0c3e3ccf4d732194a248ebbadba571aa304a82e11a8846366ecf1d21e4ee7537e4cfb0409b6b9bb440cc57f26fe49e6f19f10ce739a381f81b0005e5c71b19279d210f57eb277e0d72646aa8e5d3a180a3bf757a262e03f37e8140b9f0f6727e0c3f81358694612f6bc5288a6aa793ca82ef3832b2882ec2e992706cebc9b2d593eb1066ba99680e4f660d8c429a942ff15e8f15a60a3efcf4cd99fe45739c697a4f621f64c94f0a6bf2098c0b57b9bd80562518232cd9496f1a1cd0b65e6c95550b16b1d323039bbab16ad3c5a29568a52ed69bd98fa41696d663b82b25ad83925aed32ba923d63a26ad500d2fd9910e462ac46ff73ec3a12a628d35c67effa661d08868a35abd70f882c8c47895665bea46cd3f267ba5425388ecc668b1ad5b8bd8c5beb6498079fd749e16b54d19cc926f0a34ba37e7bb9e87f1e8ba75c13d0aa8ea06622830f18a7aaefc00d5be3d6bbada9efd35dc995bdd4a44a9b1e801c2dd659985222ad01be08dd77172f688b783ef699e736830e7b012dd462915c6b430fbd9cf0db370eaddd37dc669c390763c2bb37994dc655412d296e9aadbe981487bdd7e5f4294aaacb1c3c5707038fa73398d9bcd9f12e686ce74eda82326df05dfc2a95455b3870fb200ac994413d4edcefbfd41cae53dd36295fe1c201c802813ea78719827b199a2a890c10dfaa0fd7b711c3430fe6132e549611d25ca7e434e17fc6fd069ef78ce251ee8f4d16a026e0ca7a10238db7890c975f9f0031916e62193cb1b75e1f07b40b427f57601dabba29fc3337e45180a5c4fcef04f6304318312b9b148a3768d99ea288ac0b2508892503bf7656746577ad9ccb76c3f04ae480a3cd7e0d6f8f80088b38a85a0548a28f03bdb03c079f293af5229c8c92c4109447593c76fcb4e22502a9e332955f3bba2bb6850e0ab1cd1dc5e29bdfbc8869219e8bc8804884825b08affc9755b2ebdb5278cb541d10125404adb1a05f7d1c1261eb27196ecdd9c94498bb338b4aa0da6d778e3c8287d5b36cc8e85c063de68ce4b696b105bd42d4f1f7b05f55cb99d77efc6dc90aa355d5c07344e5f49371625bbbcc5811d48ae0df64c04ae10b6c1e846457ffaa541413f5f3abd464c608ff3d6e7e6b4e8f48ab83ce2e24282286daae32ebb96474eaf41af2563bedaf51f3b72b43008976e624d8b0f4b19f3912d3ed189a5a19279ef7301b976d641dfd8c9c57ec88a305f7c923f2408b6d504cd26b29b57dc6a928b38d3ca0148e21231bd21b209ce0ab5a37b9f7b6cc965ae5c8cab9d79adb43ce77c73c1e4a46456406f5d2194a1fa0f0f2c4c29454ec7bd18961cc5359a3829696dca476126c6a585d459b9d15206c9cb1e23706a677b36d1e2de08e74e4313e6625ea03689c0a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
