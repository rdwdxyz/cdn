<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8239e2a12241fc50576330c968b9f849b6a382a6bc22be7bcc67d46b3f4b39e4e6886fc7d19bf74123381201a0ac9356d1fb4737870e64b6b2583018b4873ed690a584b618fb7adf8bd98409980ef665189de4c34f3493be74b2080c66b9f5ddcab68afab71333a4923828b33fe65a6a50d20084d98ed57992c3e9be2ad2a0e1174ff6a9ff5b9f122a129f01c84265a7c3e555c5ad421b481b5fd1199775721e69a8914a6636aa181d6b562ca137cff7edf0a3950b7e4e4c805722cb579c617cc790005a24126f2a2aaca2260619f19d44d674bba5f1dc25d95e9c955d63a7fa1179cbc77a7d90334cd59a019a7cc1c9d73da4d7657b419c68717f81c2d37ef40c4b89ef5bfc749a3ed6e5686ffd84d081371731cb3a67af569bacdbd5146d785cde19a48ceda8641fce997a7863e6329ea9010d587e01223c946954441cc25d3990773d618d5b7c3e228102bbb2b8f00e75ebc7deab248db4a3cf0e9f6e95fce1890cf2188345bc0a7dbfffec9578ef320abe6963626043a1be2165d7aa42767925f8be089e82f6361449303ee0877d88e45b06c845ce64df6358b50e04693608f2e82aba0722336126d8274a40112f8b6d2130cc53b719cf7eca048ba05aadea20d47cc9f809e8783547f19144a6b62e2d91270b3f0fa7fd6c86c2d243a442e0d217c297017f5eb60435b680bd4b46c664aef8ed56531b1680543883f8a5c28c7412eec1102c1de1f17a158cc3e82632dd0a7b9267b93dd925fb2856392fdbe7b3da254f058ba78c06a5531637e2c234342613682b58ed0350fdc0688e99fbd2b5a5d23a777d2da4582d2c769d7edd11a73f7bb62c169fc991993d3587cc83e74764fdd2b228100134f84b1057d5d12e99046ecd1a63976e99b4b74d553caa8b8e5460763751a96ca67a1d451c154976ef5c91a73f4b72b0bdbf6c38cf877cea99e282f72dcac5f4801a4fe14a4ca443e3669dc033592f4386a8373bbfa48f1f57ea8750ebb3709bb5dcf10885e94a032eef36856cbb72510d424503608bb22cbf43abcf1092d0514e4f3650748c1a703f1be4efcb43cc3b1a391e42c9f579f2d79c34567c1a89ed0d3e392f8dc1ce6a381e9248719da8799149dfbd41ec1614daf9ef3540d0a9b967f53e9f806d31ac6ceb884433217ef8f9e71e9118838a7ae3eaea11542171c6476e4fd144ccdc6f8cf6338398c8c6fbc9eb0a03ff1a7c528120044630176c9bcaec6bfcad4b460c867a1c921a40bceeaf45209aebefc8b5f897374ca1d57d75aa6e36caa02665f17b84ed68a6fc7ed7903379c360ad3c265e7da981d4b604d1fc94a501f91b9534e38ba02e4aea808ee1019c80c84577192c692723b96a7607f73483144f62e93bdd12263e291295f8d7dfc39ca6dc0d1c48cf0f05117ea0d1f0fc9907780d11bfd64eb4dd13925f2d3bb1fa947a77036878c802744861a74f95ca86ef28b5fb01b0321776d38ab2832097f96dbe0a038aac04301ee3f581ac5a69e73d0af7ccbe3e8ba5ed4bab05b15f04831720b4b581f1380a41f8bafe044d9412484014d50c7f747f31ccefef074d9bc07b1b4173da5f88296cf80e25195467df3144357e7acd3632e8cae0f68b52bd2269e6aaf32a7be46f77b605f4f972013454a1f2da63de50ca4bc33f7bcd4b7eac0af102e0a935183df471f641bc1b631eabb01c4c2295dcc0cbeff02917f597090ecdfc7b317b277ff350e1ac639b99e6de9ce27f636acf73399aca0d93a924e44296580d415c6b6edb362db0ce61a5e888e137b80d68b298edb941d07447e92b21d394d79a4ba0b6e0af67a0ac908d88330ca4f0a1530dea44727ad89fb765a0ccc1a61a866e8bc9ee35ff2cb5f6b55f70ca3cab6f07dd92cb982c831609a1f45a45b3bfeb5d0a6d1380087d54eea50b402203ea69a84cead6bf4f9fac0a58227ab385a5863b3479ca0658a54681f3386ec98ae59dc6d95a8a95f5cb2cb135f43cbffffb2336d8d2180eb83178cca287e9e3fbd507f6ff84e553686df4829f7c56c01a4fc842f2f71cd5b1cb5c7badae0d18f05a96f955ff85c4033b317ffaa9c98274c7eecaee15f7f0bf286675d63690e679a41c3b333a989907ae5fc048699157da49efc00692f4bf5cd9ead593bb66f0ba7caacc7f324bc5c2a014261ff362c2a59c295324ac7999c14f68ad33c4017300724aca3173b367891bdb1857d1a1a345dc59ff90a4be09005005fee03438ad7e5ac12e3f6dcc6c2dc8c8712c82a814aed4c91346b61e0fcfd028beb66c08932ea01e0611bb8a56c7192f24a54c1263ceaf8c1a1d320f34b6172c11c3a77c105cb425c8e775034234fc81802742baab0fffd242e76951def8ec9fc38abb4dcedf2fcebf13655e71b00ba94e1b20b42c454266eb4da5aa3a0c896a1b888a92bce4cea3b8e3badf89aa6710dd46a7e717e5c9d02ef1bd3b397a069366e0d966c162153570bb1eb5106bccad2a20c75a9a14450bc024bc6247ac4a535d37663672b50079a6579129e35863e7efd4be4335b1298da50554ff81ecd2bef2fc6fc7f43eaecefcc9b1f1fe29d8c927492a2ebfcd75679cc813518d1b31285c0aad6bff9ea70ca162672717445bb5873716312b4a4a093704ead8d2a94f7145f3e30bcf3ba2f87adbfd751d00b1c533c00e2942f78af5df5e0e1dfd64b529befb5f369d3fda45ef631d04f2fda680eddcdf20a96b46124ed7a5144807e2514ddc9c84f3ad73b2f557f4af95dfa8e0367991dd493e6a2acf7eff3a4b94a59b5c7883b03d7d7b6740a6b31894d53a6d518bfcc57edf3ebdce132e990f23510a04e16b721be03ff8b974a1d015c2a7b2f0d5b3e931e729568ec8e32b374317874a12e90cf5aeae85abbd413b4f2575c2b92e6765f85a386e22e8dcb4db00c7f201ebe6c0c58bd34a1b33b9b45544e13ddd8eb0559c44a4f08243ef4e0a02432cb9a0d45eaeb171d5e96afb089996dd73cafae5b1d63c3cda3048f92b15b20dc8ee0fd9ca30f9cbc8f8b7a0f1876d9468455c06c832b3c4ccad0bef681b9c442ee70f822d1cad83251f05adc741c769a85f67e7e00d07614db81faa261e884d6d32be7c79c832e08ccccf978b7785b4631b36971817e9815daff1dfbd94ea85baaae0141bdea79e71cb299e503e51a1e32f421166beff6494117d4a984969ecafaf18058a5691b0a5a4b59545fbe51a34a408bf6b1a7e5c52849996437984b3167df7a8ac863eb06bb7aa8b40303c074fcb95400a61694c5283240adb1f4d05a52d6ec55ad45e4f603de40ad7e549c7bd71f824a92d331a89bdf4c6842c469219cd0462595a448e449562666e003da74f827da89eca755220b196fcb730fc0505c1c8d7c02125bcb8b728917840edec642ef19cb7d47929dae7195931372dda73954868479da3d94975b08c30a04c500f1efbe947024e8305a606772e309c62db0a4c8f3e29d6651faf4a7afee3c0d3f9e4c1e5f73fe1aad6ea5f3b1918db2ce80a453a6c28346fc29420920f57b50848580b0c262c4128308cf28804af0d2eaf60116da16f4ec06397da611e4a34392a7d3949e123da4f0d8c06d6f514707340a014971e5c6a5dbfcd48013887bff34e1c5d6e7861750f62d0ef933d6bf3cfceb9bcbcd71a1953988ded6913b2b164bb1c15af9effa686105b5641f68d1c8e0f792ffa05e209fea624591e4bfe552f10c05f54aff837761586d4f58b8857a43fc5438a4772b758f436b1f7e9d2b58b3c07d408951347f14aeb3755f311c8128ae922215ec6a01f0b9f6939e42f2eaf7a09a3e9eaac747b91c32bc1234ca2c9bae89d304ff2e8e5387a71a2f1308bc25571e060936ce81ee2d99c62f779594f499d4c7e5faf4997e53ef201f9bcdb173114ed18652f2e8bd4051c59cf76d21d19edb2b6d41db38998c4bd5e2a254283df89a0a4ddd21caf9824af18ff458624c7e24bd4ec2a396c6f513091d4cfe5b95d214bd57079bf79a97576223aef85e148179addf6fd1f95c22fc76ff6c9b0341f124f4f63fff559feaac19ababef2699d0004425b50d548f341f3871b839345bfcc130d39886a969115e7655b162bca3c919e723b0cf4c49cfa374d3c2bd566a6351c2e1b3835fbacc1f423bc7b8404005729e55a33b6968fa33b798d87b2ce2e5266556e80cc1d7ab059502835076337cc23d442457f3706aec27597ca3ea9404dd0215262a18e30dbf3a1d8b766c4154772dfa67f02f51c998edd91a92ade9361396b905f07f6ac6a1ecc4ee00cfc3fae56689871ce646dda4753381ba0d7069eeab2a466a54b422ec37d7b692abc97c1963af2ccc8aee552065e0a2ff82c9dcf96405c79b2bb348a9bf3e1152aec3ba2dff1f54cc64e75c19a422424aa378b53dea09651f98817255cdeb56435b32dde3c3bfbe3595d7f64807e1c0cd1c66d9cd11dfe3762c2b2c42841c82c4d7a485d5e518f3fc05002ed9528d894c41381f31a04da18810d8d41f388c46a48aff110e3b0ad44d51560526b39a6fb613053ec9f8fed923a80eccddc133a919defe644ff1c02aa4971fd5d798c9bea2db4c0815393856738b6cb8759449abddab612b61deb6c635ff7012d93942d40b1d577929fc4e85d93060f22ed09fb80c6c94b6590dc4fbf56500c8fb1ba31062c3381fd9847942ef942835dd1843b08d4461afb2864e6d52b8a1458801b613098d15ed67aaa3341017d92520b79d83199a505eac6842b94e5ab1ee327130103f7eca45e1655dae169fd5109b859026863e794c6fbcb9f0d7476f6edc6c129d00202d9121227960cc2df64f4296ea99af80c8d8e105697d57cb2448b7520d1f6fad36adf17ce11f67f7549cea8e9a620a5a62d6e25f91d1dcdef37c2f15cce96fced7e69349488904bc3b82ae7fcd499a095e37529e2191e18d3215cdd2ba90af0f72aae95789a0ddfe461cabfd8c2bda47fae1476d98ba300fd74b47e6916949b2c046674e56bb7a17bc2b15a7c31eeb08f1289e1ed80a844f57af2689f63ae2d8ee45147863898d259bc24f8ad5ec4bd529d1f6f15522a01163e552220f0835ca64ead4ae4aed88c83dea83389128852752959d120861e5cd7ca20c6a202ca6dc4e770c0750cc99b8c3595b5cfc1e982e3193075f0bbdeccbff06af315ef65ad2a5c70bb4700fbd1e684f718d24cb2f4fd7d2dc86f3aec8828b6e4dddb01bbbefae1239e22a3b8bc236015edd39439efb5efb9d18776ca5d22e5e1eeda1353aa0b02aa1d1ed51b8955b121ba2ca06ffabd7e980058670b098a3c069c2995dca3bd273eb2811d3830bbcae473f131854f20e24fcf4b689f811b8d9f877904caf7ad58d4fc96c221b82759d0611419fbb90a8b8552cf782721b45e45abfec88f65d52475b3bfc3397dee0a31a51e1dbbdf8c95e0a9cc14008b7287cbb4e590bdc64914fe019e138f811814bc4b0bc4dc716e20472b5c412ed10ed29f1b467a151541bd59e5f4239de2a7863d0f5b67ea8ec43c02612f76a1faa61be3fb1db54e6fa71cbae0275414283c15842017029b1aeb89c30b332c53f7a07bfafba1ff26f377cef489485077e5d5868d891204ca6a6cb998aecdf2b525336989170fe5602c583ca6d94b303807670aa2ac05bd7cbc269b5e881cc195331a7cddb25d4463310e51397c09432e0e34fd99303fbd5eed654f2160b467a14703dbc4afcc2b15d3c15453e4bc4ba84c395f54b60ab0179de7e2c3fab63417e3c6413ffe4826919a8da045a77f20d2c4340d5675d189580d531f16295b6f87d814310485b917b8fa79cd290ca57d22db49e6fec294f375b4fc24cd148a57f7ad3efb33b55ee1860d93026c13c6000cf56732de059b5f7787261f09195ef418f8ffee92d4ec6e08f4eb844175ab3da46030bc450626e8858cab9629fbe05db428b002572cd6b8951431d1bd665e8d024c95939464d982cee0fd2d3561319e023e7c2aa861f78e69fdab6d914579b13d0c11a7b8e4312a3e79708e37372731105b5577ffe0d7323483e8e6c6fc9e0fddb7b9be58980ad6f144fb160cdf15c2520ed410a103a0d68138b5bdbb4fae5a02778267522120952a71945aeadbd2aeef1134a342ba79963fc9b4fce320722eec3b8fb51380b334e2987e5d68af6bf96d618ee6884573839777a7113a5f3d38bdc6655981423e678bbaea54bef9368831d6346fa2c45799c384dfb70e3a9b55fecd74f2da43cffa98ba614e48d675698045e283834bc66961071a089846b0df832d4c7ef9683db8be7cbe410e697b147a72766c0d11e8ed147af374270ad2c60cc1c5cbfd90d3ef41d146644fdc8be710f9ed0652f25c8173f463a66e1b5dce1c7b4e2c9c608201e91b084e255df4ca4f10ffc12a1afa355be2a67486536cf4691f1cd942ea1c5ef615d0d6db4d68faeb34e31c7592806f7e12a3a641b6a0921db944ed33e72f2db829ab2c1c831c3c634238a7a38bc3a521e13409d7d9df6a51126645c0ba6b4a1fded02e8b44fd80f591faebd9a718f971ad4f7432f4fa18cbe35cd57af491b1c556f1fa45778090ed10bc1a656a28316b57a1be2419155ca252f08d74aed1ff993c9deceea60d313496c031c229cc94489c0cdc1ea1887cefe0f3841a0355f2f6d206b34ab7d7365aaa7004de4331214f03863b9a1ad01166d0276be6e7f35c9c847e53c131cc31e79ab48949e81537fa6c414f5e1818a9727030cdc10011d069ad43046c2bb6235afcece6cd4caedae2f05751d60c20670b2f400bb4a468d4d81cdeb94ff260fb37312cfc8e93a3a21f465d43d684a70cc71f796697b06b9582202dbd234da9af8e95d13372c71c04cb89588f418e07683197716c9cfecbc8975e2589690ee7b3a63cc9f7eeec4fa95afb8093b7c13bd56b07f9d5e9222227ea96d65d448817d2be7ae67d67e9d50cdc22c3f2cf4147060a5cb36d4b7801c49b4d300d08888973d28b217835ca9d2d5ac477395bbadbd24532b278ddbb5b282143ab469087f2b4049ad5a2ac065156853a51ab111175c2cf33c0fdda65e63cb8081d6abee80ca23f0588ac96ad3c079d31b7680206a752117238ae5841879a9671453398d6de8fc84eac1039ba234c7967d49595447ce163bf134f2e2f1ed20767068013a36eff285f9e45d68088d2f6640a17c3422b149126dede353bb12882fe9f3f0559cfaf692ca20f7d21dd552d3330f099a1981dc0051af6e9bcb9bf32e2dc03855f42187b4c776f2ccb33ebaea4dc70384d8c842565b2e169af2befdd8b9eff4a765e356e86a2028d4a91b959776e8516c7ba82dc5371e4dea6b6c7481d8723fe7536328706b12b8be22b4c478a4d828b8b42d99f6acbca1fbfeeaed4bc87597cbc6a114a6699443195f8264d9b8275cebac510118845e0371c316966f60077c9deee7370ebfd8181fc2fb869cf3cc4070741b278f45b57f8261776bf0e6357e174119a23dff393478f6ad0120cfd20ab71a10802bf204fd37a623e45f5322be4d31ca2719821692ee173abe9e8bfd83bdb9146c942f2256bd0eb4aa53c4c2033c952f7e978b5231fac8417ddcc704ed412932db6ec01f57ab84645a71590fb3e774154e971eed820d3c5d17273ca75bdd43d62ce342b8a04daa44432ada8013dbc4a621746f7a0a58c6879544e61eadd952b2af953e1604515d29b125a84e40c6da927fe3d8e16f0b82a0ac1dfcf21d96bc5f9619819c38b33d9679e590e1671ac5bb802cc06cda97723748ad56e17067482c7ac10d3a1a55dca3c3c2e8ec9a33c325b82f05bf24d3bb7b31d6561c8d97b5b5854c2efa67d779dc8fc6c744f9187b0825e1edbdab23bef4b5634efbdcdae6bcb22a322a98e60f65f7150435024d580ae7425343b79e38bf487f72931e06ae099e24301aaa8b2259e8fec07f7da1b51be1394a308ee588e32669468426febdb70a3e4ed226b2aaf3f7466897e833108e931e2148303eb743caf6a1c946ae3cef0a90fd2120e52ec56f454e49808cbdb6e01fc97864ee65d2dca1d5bd7856805c19d053b5a0e7b3e898641bcde6929dac9da38e070716e406ff9add32b251c46b1afe929afd887be5c25baa803d9881e121e068014c69a9dd2876b3792d39771f0873c50bb031c23e5bfab483f6de048d6945bdc04ca941b8149054d2b2cb335eae5c19915a757ae7ee326a2e11ef73b0cd63646ff84f9302910d50ee7f8e98f21fffd4976dea92594f1b8471a079301205a5819bcea30352b180b156369f08b161d77ec16ded11b819e401bb6561d6734347d09bd2f7c5a76acc541cf5fd655ae67019c9c1e7ba5e4ab9838b15b8bc7c182cd7ae0f69320151f98290664b3fe5d2ad240c1916050b52a8f42864390df04e65d94db80ed16dc671e78eb826455d440374a953f48451f7175bd5018ef1b5d1011eb6b87361923a07de99d505ea14c99340ae882d069b209f5bc06413c734f2473a3c3179a83e68a9ada5d550e40b1e941e70ecaf957717e418de4267645f6c80add214c39c2372fba47d68a7aac39cf4be70995b0dfff3e44e8b6100673779948f36ff51bb16c3b48704371300a65911fd80ddd3642dcd27ad1a8bd21ca1e5cefffd8dff4595f5fcfbb888ea839feb4fc3c24d553bbd934638314a7c9e7356f8ec8d47b6ac50216048f2605b5f71766435444cf67340d7145a31ab50f79d43c38a89f48f9962664aa1ea9d428c7a9d7d10e0582f9173fc1a0af77727da4d9e781af7c21baec6f5462f6205112bdb33e664ff47fdb56819c3df7137df9d1f96faf88d3201a2a2e98a7c848f07df32eda2df3c95326443f9e0dd8dc77b7432d09216af2e4188e5a4bf0e130e6db13f537c87a4c98178ada4f6ae943afb2a61ded05b6a777db4afed5d5bd009febddb79142c71bcb17f8080533fd334cd6686f93b2a1eb3e5b469eb4e0311f9702590e8a3742f97cfd96b40fd83ad42230c62d893eb4d8de6fb7a0bdcaa4e19bd8f939101adb376f14977ccee058683ef8aaf15780530c7ea9adf962c943947490ea7fa6f3e7ba1baeadd66224ef360ece9e2f5d048372c6e6eab198edc8e92ef93e2a4afdec02bf6da25737d1b359121cc0b6144f41aafefe59455314fe1e1a5595a782d6b07398c96505ba87b83c8518434f428019178184d1e63dfb454f8a4a62da9df77629973da198c938cc30b3ddc5e1ba98534bfa20da72fcaca0c856635e911975a1a64005f1731e4ceee57a67ca520782773d8689cdeb2c4859b7d96f7afa9e8a82713353bd7c1c34f7ec4c0e0174181846e91ff555406e410e569785111f5cb4cee3888e254b64758b7c361a5bbbb9a19f891c8d3ac9cbb2ff193b0650493c269b257e181c61800402053a304101b0519d9bb2f4303792f940ff1a9d9802726b6cdd3236b39ddbd6b4a3d286b3f16d6afc102fd914d7743543cc97621a0e50dcf49cf9b8715db86d3a00f39898225232e68251cdd434b81be5cbe64de7f0e8a75a7ec33e415f6bcc2a66b05026a8640dac25a40e8c31d6b3877cc1a082a1a16e1946628a011abd1e9a4848f0d805fed654ec6da1b15d5a346c92bd0a0b0055c4e31175ebefed7eef8dce72eee8784608ead1792b4662996b57a5303879c0db7f37fb530f80bc0fabd1330c77840b8e8b077408c792da69f50ac41606ef9d066be263751494630a575a0c50a25dc25d34d66524b9902bd372f53954ea07e9b4c043a953b3882fc6f23ee9a48f039e46c3467c28496190c56acecd439ad3ee601bf29e8848c2affbd0cb95841a67480fd63c3a21bf7930c06919d819e97b4979b5c97af9eb577b86bc9ceccbeb58540f6b1554c089ba45165bf31bae30a941acebed8367b0405f552e36e8eaef66a665392dd0d90a3603511356e63d7a0e7e6599b6f9d4c7b6acb026597b45f1d882592aa24a6ff4c9d737211052ef69091038f7caaa020ea1f6def5a58fab9a69f97e4c0be8dc4fced1140796fb5b869e7c213b90fba564821a162b41cc10974659ac44d882610a9f26ea04661963930be2b2fb0576d41296de6193b74875e0aa50c81a303c1ce87e98888fc6fdf83072cca2de7ce9eb13969488c9028baa99f53a67e7e7cdeb11daa2769002fdc2a7eadff1dfaa51dea6e83782c17c9621cc37d14c9318ab8a70a130a46b26a32159dc4f806358d321ae317c76768fc7c699f1beee708cbd5da085a7acb349e200eeda62144f8ca55cd867964e82a865a4efaff1fa9d27086334aa8f550a3b856710eacf24e3546471e92ecbee1fccca1e8435a1422452603b9fce61b80fd03b89773f9f722a1db187536aaf1968b11c46bb4fb569748d9a3f72eea47fb769ab3ba21ca91f9745624dac437486c0045399094c1720778fd2785a046762dfa35a45a7892204b4a47f859e68d724f7065310ccc4e87a92de9885ba0c3e441856acc51f3858437df804a451bd56fd57528e1fbc2e2a3c8c963eb890bea6aed853490b09551182ee922d2b4c21a55a31058686cb409ba0faca1b9a4db801817e4cc0fdb1f2e0f4989d7d48bcbf3e046a4b98dfa618b80134ea544ed3883e238a3a8d6904ffdac0fe92a26fff7eacd2f5a5ac217146e57448f635e7f73e867d654e551a4ae220701d7336b6917d0d615d8dce21702c789856befedd9ad50830a73cffed8a6fbb7f2e247d2ea59bec21574cf950defe2b18eb53476f53322f22ef94c84ccf6d5a734ab71eec677a417a04f396b915c6764286f1ec6fe3acbe28a515a159ddab551dca9daf280f2d5107faca30b867288b8e2fb08e86064001015ad8d013b580f39266d323a856510f8c4f07b862f1bb918f97342aa2b8baf6127833a1b44a5408c458a7391a1141e7c622e813c1dc8b508fc4008c5fc8caecc3eadac1a95b3caf25ccaf641f07ccd647c7e2b75ef32ecec664d9ea171569c9d77501fefabf8d8d084c8d0a6d644fd33b43eaa6869dfa7026df2681075dbe2e87ef06bc630ab56701f0028f65295d9cbcd1867753e80b2fd2acd2a0691a25da73a939728ac61c1a97614999185c10bf358d97f6e34ddd7ea979bd109b12c3de1b80b561939c8d6426f4e1b57792734adea00c471a3aab5245c6d10cfe948ecbc53adb4ab829cd3086c4e190e7595ed87afa447c169a06aa83beab9b27c618c45a2cc250fd245d8eb8e16460041d5d0fe811a87562e5f9625071e38eb3fab9be02717706b6efe580110c51051b60d5f9fc5fc74716211e811a3cec7bd65f28a7fb3b897fde5bab4a3c72c118b7c27c1d8e5da55e6e2dcfdbb4799a9c98e619ad7015a0fe13ecc56fa914f196cff8a1f1dad95a4e3afd825900f43fccebacf2984fbcf0b571de84b0f706a88afe8ed67aa00cbcf9c00f3088da4e1ec25681ebb875793b51a9f029d8bfe11b381fcf1a5183e9c4aa52727841ef556c7fceb46beb209640cc7bc474bac80a819558d580998b725024b67fa46711db07a54c7854df4b22bbdd7a90a191f469ae597d62f739e63330b94129de8fb8e871f94734b12d4ff4f61bbe1d00b22b58748d27070457df95a1c877011c4a9a8a68e09cff2037f96164795cbd3d6320ef84278b025b9055232ddb98f6778dcdd4c3a51a60feff73fe93387d6c8563c9aed2df9232bb4eff03a43126978ef00df6c1c9793691a770138cf9865035b7b180e06ddbdf13708562bb56a831795533b2db322bf06823a0a4001b82f28e73f58fcf6fff962872320c420ffbd472dbe645fa34334c42b5202d0c44cda4ce241611b596bcaac5a82ecb0dc93854e1d829725b4ae3e7b60c06d44f5a9ad125ec56a252b4c89ef026ae6e603d6bfb017d981931a821d1a39726cc97347b6bbc0c09ab2ba55674258e967b168c6b93798be04e64fba62d4e1734441fd3a6e93b13bad132735ed43b29c47f1c427740a587b81e0ec6d0fb20a1ef630c0aa5657f8230fc791bee2a509d6f4e047173c8994c073b247d64bc110210321acc4813a9c4feeadd98facc758e010b90bc6e515726a914e6f709b354eca25d21060827ce42697871f7a9a059fc9844078df06e0a67d8862c5cc0b4df5a370afc82a5eafa0a3a7ea502213b5dae7dc15ad6909c181e39da34e3bd877f70c595760eafedbc6ce2d74c0f8e3ba0c5d13a57d86a7ab224bad6671b6ff83276f0df76d8050e440c8c380f73750ad0ffaeb7d3da4e495192859a04bb5d3a4b4aa33f98ad366a902c0113ff78e60d5e7b1366aa89a775fd8871007b37b4364abf0995ad0ffa47d622645962e67316f2daf65e3dafa6162c53dcebb3f081164051e5ef4188b1d3d70c89562ef0b5c8dc155d1dda947fa75ad1d10918970d10a662ceb2c8f361572aef0a174f687c232ca7cc8fff370c19d50820330262892d023a4e60b3f6fa4150d7e0e10839dbbcb5f62b13a2aaa25e342b62bc61a8446b7e9f903b95cfe5d6930b9f750743bf46e2b2a8241eab54e3916917c799aa5557a317055a76cfc2bdf307d741737b1b83eab3599aded683c908bef59ea2eeb70082d55bb664e8a43a583c46950b5fd99b19497dc293cdcb9b8961e81f75a68b64ea4a36ea5d8c4220e4e7ac30b61613873b9c8eb724017f6b66431f20fd753982b7846d101e95ffcdfdb912b78905f60a9210980d09ed93622885203b7e80f6ecda0ae086ff396b439b48c9c71efd0687cb8be6bd4c52f760490a660e9caa5ef7f60d606ef33b1654c0069de93c7e72c341096d377f65ea0033667e9f9e2db63bf7f588b71b7a31c36c1342d4e746dd95b0e0c7364025189c832e560104e3d2bb7dacb381b255ab416a75010f70b9546f66a7785dcfe6281c3e4d2714c57627a7255771a0ce9c38bad7442c2d4d58653c3ea67ad73e189b5953265c897b8ade609d7182d70f3fecf4adfef33f539e97f9fa53a105b906cf84c1c08982e0ea361f552a86f8c73a8e77e24c992d8d651ba91335e619fd207e32a6eff887a2240c8a39fa4a8aee324cfe3c87bd88da89c730d4676e165614170671e817d721f9b726bb602613818f1b3fbc17bfbaca3f2072ceeb043c35a6de42458a1687d2cebdba3e548dc5804a1a9013e35fe863d309e65155f794a12a41400afffb9769365f3bc7b7da59b698c8830103cc7d40952b8a5ba7aa6d74caaf098686e682367923d5d289738a3d238305ffcd1e7996c325fe5924abb0b248e5d5b0523e71ef858e9bcf758d2a37ef17a5c1423c5959a45ea851dfdfa3479b259fcee889b7ff0a87ce6d7c1114e47ea94df1486d8e0d24da99b04b13e73f09a2d1bed25090b28a933fa529fbeffbcc583b8de984dfd09e3b8b1570ab98c337f89553afcfd3aa59e0f518a030a21f411351775fa359fe7401f95d74f24e7154091889c11a86e3536ff71c8f2dab963f7c5d84ad665ca1e4a2c0008536cd26cd6049f1ef9c12d2c71b11383297efb9515f0e7c309a3b9c246cd99631d6500e1137a55b4c51c34b53fa9b102f17946125907bde4da8788bf591b4b1ad40e5643b29abce90e7e21b8a312c44c72cebbd94a388767a687e964451b89fdb1ce9a6642924e2ad0948bbc7ca1adf1525f3595250719974c2433649c885dd815eb72d2068446e1bbc249720024c450d551eaae01b70167fdaac1aa037b0011aceccdf384aea9e07078a626aed0e20f647e7524d73a41a1d6214d29f6d56b36049e898ccd1b52cebe94d303c8596ba41827d440ef2cd45df665ddfbf71ce90713e3adee85370250a5ce4faa949a502b2fb049d15f4e120703892a9575bad5350b61d7b1d7de3b3819432b1e693265ffa6ea2e682e93a5592e033340aef32a13f9d337244b1cb246c342b5f1147336f3aadb4a2e8612d3790fc33e90b43e9f038519c96991ef0d0de94e13982c125e6b2528aa90cc1bd9c33502287a037f4b9f02c0f38ad50a25a7a78c1afd6eb9cbb0cc1aa9dd65d9f37d3a6f55c5b739295207fa5c8095899a73e63129e7ab09e6b496dbdf1e5dda26adee578d7478db848942a0d374409e0cd72c5cb14c28c93b54be3bbd459821035a59449b870d67ad782f82587994f26e61b27a93e6de6f9b3aeb4c12c2ca43dd022a163e0cc3909e5287dfedf0778ee953a9dfda933edf7bbe3e290ee832508a00274d1eb0b56aa3c43165a2ebe094bc4d19784f3a4d86fc71e9b174d0d81604342379878019990e36b9f0e928f6a8b26d86ef857a077af73872de2ab2963731bb7d89f835aad5a6c3b54d8ce1c3a1062de9e889be23e77c1dab4e9bde64279b1b8d751361c1e5ce3426a56e2ace839ad95170236b61bdf8b55109f4ff919ca9a1cc2a6a8ab8a00bcc7d79de8d61bcf344b4e1e39598adb49a6c1c6a87295e3e8955d7b5e8097271ac5b92cd611402e36f754b5374d34953d5dcc5b83172a67cbeb0b991bac2640a4b4ee6ac54308d1e6682bc950185a7c0eda6c82a8b66e355f6f08d610923448bfe6d7e2f4e33a1af3a394ae03b8e86762b11ffe415a12de6e712341f73ade5c741fef0ee2a0ae2dd1bc00f5a9586f0603e0890a5df39edbafbc09d00c77fde440c7ed34f2f560664f7be7d003c8198955cbaf94b7f987390c541c4c141ddbaa8d7f9b02ce014c7003f9304829ece5ac0c0d41064dd4b7f4a5ec02c30177b35adebd3ff58dd70c0a5d5841e4b0c4785fea7f1734b457ac034678bb4b1d61cf91658a70b8f93f631e0d477590334e18aa6a700ce49fb88288bbd0dd60e1bf44794bad8b19d91c4a0c086257b2592556be9890b06de8fa3ce8f7ebb8546e56f3cc1b24a82e1d1cabe958ce65c944082bcc675ec9c0ae59f05a57a409306ef6cba0f5ba802d3e13f25899bbde12a974e1096c7daa869b8a43545b625588ab3e50a31183e45fb2ac078607e34774311754fe672c10b28d37feea3c27ff0728cea66ecb5b2fee8a49294a1fa1ef277eb60fd9bd62987ed37a5292a4e1c1168f915e841c51e165055f447a595cc6870c10b7350f94fb90857f78d87cf4bdc483c7bdcf827b520588b9fc31961b212ab5c698c96b24e31788b574a55e17b49e719b69e34a4ebca24a1042b12296a96d8f8eed3be1994c293a94bdd9202886c603cefc4a4a15d3800418bcb868fe9d6ec58253838e4ccfc10301fce7c43c39cdba56c11c5cb60ca48a7f60b749b25bf9d1c167e04c5054072cd014ff41b20f59550c511766888ef99c46d1873eb7c160b47f8f02fed3f0af7d1736a7dfa6915b9781cdf726d7a9c12ff2f60508c96e31b9d3cffbb72e661dc80a2719aaab8e7590be0fe4eed1f34337d129a36ae638315cb86dbb0bdf6341b953459a21ebb007a3059302823d8f97669c44c895a7ff519643e686c2d631552b74cf9f2f1172c064f44fe4feef4e4ace643811f9075b04d67c64a76ee03ae47f057694d433bca56886423129de8763948e9847ae43c836af5e1c450720ad41a62fb7aeaff1e9863c48dc92e00f20d874a7d1b2fbdc15c170e1821be9920e1f14e40fa0d4ae5a862a0f8ef7f3719ca6ac82899c71f59b42aad376d664a945d00c1c2da160ca07d7a758d70209968f2f0d21400c19f6f3d58d78f345bd61f0ae302a1cf6305566dc278d4c22332cade90f58ed691dbd62e30ea5b7ef65f2b06546c7cc90ab73df2791eaafb3b720f11a6f54923b65227f3bfa5c811bb1e9d4240d893cb61e55823dacad1f3a51dce25677838760a5ab6396befe4c5d3917f10dc1c3c891d39a6a4d5cc0237d77e4f749fb04e1d0ad701055a0086ee7b63950b497e909dd41ccd80ac9dca98583b8019638964d6bed2d1cfb659ddfec7a71a30b19361c2960c1173514a6904a0b815c36a1cdf8382bca89e0d23b7c6959c3c7dd68b41a07ae9d0bd49957073dfe197a71236195fd2d7c5ed05bb1b6592d993f7531e9a65a05a247fd4743cb5840aca1006533c1a57cb741f677c73979131f9025a69e4049b8b8f5d7e34eac851e66c7376bf7dcf7ed6c2dea41147bd006b9c47c63cb1ad369428435dd42999c2287eb93793f0c26b3a7d61554e28b747229e4e0834e4ea6a78a474884bd58c9edf0479f5debb671f6d4aee8714d56aff8f0fc16d1122eaec300065c42fc1fd86e4420773a431c13a87333f19a1d334dbf125f866c3a9973a2acc935f88bef5553acc2748dcb5c733ed9e4bb54d43f058f9d6bca1a937e67c180726f2ac1f12ad3b19f2872f62590c1349729c628c20737cb8edb7be8f958a353e8a46e7ed1d4cdcab68b6898756f4e6b2b70ae3ac7996d33ebf62312ea01b9a9e934a80ebe2e39d9d66553ea759062653ee4d8bb8fff0f5413f114b32d306b1b305b36f9a1fff7f1cd70b7287dd98f190d687206b3eaa1e53ac6f8641359cd5e2461c3d47dbc2b375f660969ff0d56d032b5360da1cf645adc8530b7a9df3562f1267b7c4a7c5c7d82d348896d4f940b228db26d952c18c4ccd74283c4020a75a88e48390c1061e80c7f00ae257f6c451d90adfa01f1dc24f613186dddb48d381cc7ceb319dc5abae3f492e686d105df744886c894deb26685b9407b35c0fd0490f2d41c64083c88a59fdb67c2e2676814980467c40665ca191fdcc235f07001cf079ad341c749e9fd2ee23eb749c707b501f3608b835724a1e593fe998b9a28403af8dcdd7598249f91cce4463e757b8306deb29193f9102b423f8414dc8e81d09d1cad8ee37da9bd85f0ac9597e8a30da57378a17928910dacc235bbdb9c1de73fab94c2c16f0c300988710bae90b9f8c45f6caa0eceaa1159bec0f1855341ebafb9560ae85a217143e97d7168d1551e43b7533b34fd822a0f7d765a355017488ed014671a889cc97688f10a75c07dce2af2decce088929c5d950938e089ac1c036e9d92173a69b4bc9b48dcf1b97f4c9b025639156e1907e7697d55ba290bdee46042f9d1c4915738879cda313b875b10281ff58850d9b3fec14324ab08483ac8e87e0c214b9dbd8b37df68234b98a62af9836c5afc080acf618087fe1c7a2a43e5b4d8e6b7ca67bc36d48125b42e582dd27a9feadd306bb0ff67f4f89c5879c8e64dfb3aaff507371bf0f12537ebec27cc8ed98ff683df3db4c594c2a1b539c66529e16c9b5908e74e18dc1251b048718f9dc75c368861a97114c114e93863a66b6637e521328b34f95169a2e3d0d02e3283871f46772d052284a2bb6e8334dbdb012564e24a9b4b73bc4a44b7832eb0ff70e8c5b8ab27e129a8e862a5a12eb94df20b1aa8ec6c33606b491c20ac4f4eccfdcacf1b975e6d27990d524ecce4e62fb1b6a8eba50e01d12fda1a8587488fda27706efb78b2d2673b3a5e1cd3ad6a5ada1afe27063ab6a0e108990d9206219d204ee4a2953c74dda92939ef6cc3ed0d369e508a83adcf98794bfb85ebb2082513c48b349e3c51170f0ccd3618a7cea7338eccd7ba057db3de65f13a4bd384615d12ef21de2a4fd70ffd58308e4d3d1fa47a50f7a44fd4d0f5bbd75ca73799bb66d804a070f16e535b692fd8bc4860262e4a99e8c0a957151dda0a294792881183506b56ee03bf31bf5bbb7e4cf4f79452961bf748778884fb0c0a5c6e336f1d91f525791faf8661f3ccdd35a8163c15df456b376a331278ed7ec2e2f1314a1fd94124b138cf3f46388bf96d1e6054010690d7e8bf9604e858613b842638965d3e2328d2203c4e4b96c0e1940037522779f21e03d103fe7f1aac63efdbb43420bad3a2ab96dabe4131917c60e6599fa6461492f09a66c86b75cd94bb051ab38bbe26a4e0458be87b182ab4add0235be92aae799f87dde45a73ba91835581bde149601d64d78884ceb6af0a5b05f8dcd53288179201a61c46fb0fb1b7b179ca1fa92935b17689611ad9b98e41b639536e614181eac93f2c61212a7ebf88061d7acb2d6de4b52be9681505eb34ce9facec0777a4d0038639f297ec6d7fee4a62f0070f7ee7b13c80953da2fff9bb2fba7269b3bb7a23093500dcbfa1095dff2f8d550831f09dd971ba2d2baf43a017d8caeddf9be6cd2430c3f8967a3d92eb8f9aa9280b5769bc4749f5a124d8822fdc6909093dbebb4db10378a0dffc5667cb598fa2716354f76a3064c68289c292a295","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
