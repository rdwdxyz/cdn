<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46e5d8bfbb310acdfe3167394fc9064ac661668e0e0ecea6cec42c566197ce1a34b02468e4b448775a8f256e2ab618618f1fb42d29618924731e442863554251202784d68492d1041d7578ea36eb9ced2afc684afdc74c1c0cabe90cfc177a38b8a8c71efec5cf2ab5d2f448db4fc69383904bbe0d54fe0445d541730f35878afe692d81f8a334665a7cbbaf84fee4cedb563dbe5d5b3c8a3f18179c9dd40254d436ad046e3c4a85543751dadb106c5c9bb55a92a8caebc5665c35e4805bf5bc5cd6f951ba74fb6b0865fd0f80450109895516365165b1eaa30b60542b2d56b856fd266e8d35d455757e9c6b912b4f98e555bb16ac81ba982b8898e9307cc9ead2a377f5a1af4e8326c34e10e833a342e9fcb8e5b705f04f62b7d786c77b5fadb083a896be74cb28f7fd7227b66fa56ce97a47decc52961779616cdb4fafd3181457c3a4f3d9b43687486f1ed71d37157382f54de059e69be4e28b31fea48d978978a33da410cf2c72d40d7950a9952116e137fb0f8547644f426010e45b644da2f3e7c6980ad8eae1651a65c611bbdb590e4122c85ba6ac68ab2c6733d1bb22fec78d78aacb98ce35559b11b68cbe85ba3fd7d654b6d418cb174a332b8ae7910b326aa570e389acd8704411c9df00ac45de223eea5a4e36e91ec9f10ef3c295f3ce0de8e5b9b73086361d633350e6340974b6ef5a0d25fbcf83e0ce90c163fd8664b324e6194bda16ecec7a34b4bbe0a8c93f1f5f0f18d27cd79e50d164439aa50992c421b80697fea03a5626280fd371c2c5c0af81f9291a395e6f2c7ab111d6bc3b959fb959bd15106c0ead57bebfe36c4bbc394f1dabd44749390553d6b1e8202b2f8c50880766a66537ac03bcb59a1c42f07f280957e074fd73790d72d33b9e30e2f3752efe1260fe980a46d8825388e49a8f134b75a1a694d8fea5b438fe389c48b0e0a02f40f487099dbce059468907588a5445abd77e7e46b78970c337c6215dccb248ad12c5aceb14dfc9ffcd02ed461b86104b65aa2470011288fb33d6fab4818cf6efd084f98d5e78d7d18f5cb97095cf2b27dbfad2bf71f3dfc0e4a721b70d93389e20b690d6c2b62cb2cab6777185fee84fccd78b704cae1d5f886be1f487ce5f21cdf02064bf24f3c0bdbec08e4252ed084a8930a8fa1b1595966548a500c981ee5fe6faa1024cab3630b5af1f03cfbe4c86b001da4d8a3107f765996daa084076e5da133ea9eb7d8d5310c226e83c79fe848ebfa46f48c138f63c26ce44c5989b1aaa30e0692bf77c93835df11b7963b2ae309b07f44437c55318c47c9b3749581946f54610a44699646d20a2eccada60cd3e9964a319d8b0aed68edc5e380dacb8c0db2baab5bfcd04a6307c6daa3c37c45fed1e314dff99018eed625e427df5e0f9b3834df0dd47912b642e40fd2da0276cf307286b9a812beffd64dfa715768219164cd04b743a561561085e78f7d4ae876feb752f0f6a2e6419ad1f5672fbb755ad58f1983779e17bc1d1e766972692b6ce11882edf421883d25d2782a2ff1adfe3a6a420647082d2d2f05c5d019346366746516486917429cd7770982e9bed727653de6d8c1fc3ac1ba77f0db81b5f44e87ce800df8bca1de6036b53fd22a03d7c028089b1eb491719f64054f4532fb0bdcfabddf25d78bf3a2d141fa98f008249372a116a4efc2c0f49f372258794d15a3dc69658ba4a4bdd70b469d0f89796d3932bc83c157f3f3ea6cbf984feae9916e818f185fe6e37661426b9daeb1fb07dc124e7fd5a914514acf3ba5d87ba75f1129c9ecb861e5b0463900de55745bbd964c8f78e5340bb48c14dc86c3b282ffa01c0abdb09e524d87c7d6c8e074aeeec02162851eb1dfd65f860c0856588894622fea0fa037126a5391bca2d7cace7bbba7d0296f04fdea07a31ce00c5f53758a0499a357f309610517d2b6e5dc6e900087a48ca767d9e7f6964d0e06b278d24dc56837d4ff7b95cc60342a744c24b1fc664096a0bbd9b34bee16d8a9d0bd45b1353451d038a44f8dc486f7f86d1e569c289b7f5dc81e1b2e7413186fa2c61128434b436de92711cb530add91444180c3d3c3ad7801867c32666ae36eff4fd05353d44724eede04a129af68fbd07b028eeca0b20c6afea88af87c274f9af5331d06fe4e11b690aa83d4f747d1f88e9c2fb32560e8af65d15b214c7a66749c2f7850d8dd2b588bc56e109c904472c0b25a97b30b7470843602008cf84c301f8b2eae12718f5e9b12019df347830db9947f330ffc251e5f05d9f61e8b827a3a87ad75b7c2ec2bafb305812830b4dc57bb09d666e5f4e4a58f8a3b3928ebc6424cbd2c276949f74a4d7a7f3cd3f0516106ffb868253e1d45e369f58ac56ae2c86f107d9f97a935591df04e50e5dffeda6fe7f6a1b6ce9dbed36a2d0166a3bb3fa0fcc2e93b1d7b8c2b505e2ace9e0de33d703a5baebdafa368882e28129803f8a118007e8c924c11f8ee623e758b17f44726f7496ead85cceeeda55ab980d364a0cf920ef6e37a47b5de809041ae329aced628d04a0114dab0005f44d94e941a93566eeb3424d1ca592ef1b25f557fae55fc496659053d4b76df4f84b054862aba34ae96d325bfc475149dc0ae13709ea3b9a103e9eb2f2efbf5a67a8bb690adda9a6e4d068ecc98ca435440d069864672948a7cda31da80aca785773d4c349e5fe349e3d6cb64544904b1840654d519b6cc286b5cc1d297a74efa312459e168e628a77fa655dc845ed9b28e52bdeebb1d1ca2f9e471dee70a8c142ac0875a317e8087668455866562a2e9c72314835d43a8e06ea9f1acd37d82791f648a24b1fcae007431785e80e59e9970677b2f7e34f4e53e56f4671d1b1b35d919984679042340d04ad21102fa043bb5961f017b9aa79d45acfebc2f4174fcc90fb54e16b88b4a3b889ca1dfb20fc240f4a773adcd42c51cef4fddf8931961d75c559c9c0b9796cc4d9ef12733078175c0d9b7624dd2fa2ab2f1d9731f81b8919fd4f01d4422666446dec2bf9efa9ca838c90280c6f69d8e5914978dfc23bbd7cfb2fa904fa609703c744da3bfadc249d00adb0777f1796ff5dc50173c7cf9c8c3672daa4c8bb4eec0ead49689de829bcb05584b8d948e99ee6894b44ba1d98c9f65cd4d3176a0c78b23cee5ca130fbb682a49239db03f20c0b872c9d06518512ddb31c677d185c989bc3f07e28443dc237d48285cbb6ec9bf7e22b3d77a70cafebee447c8f5d4f75cb3bc7c9208df3fd133e8d0d8516301fde6ea2642bebe4dfcc8b4dca8b1f7e7d8deb5598b39609c14387f9466c8aa5fcd6ed29e6d43fb925fb5475010e8f32028377fe1c9a2ac4f00a8f4993af7fbcb105819329cbdca64fe0888946d9d130082e4480dc308dc93ce0ed58e292a7b69ec0c0cf5de6778f7e5ff8826464e53c9240e0c39ff24153bc6069e4722440e1b92b8adab8c1650ca732bd3d610d5f7b3828ac1e4941f1bd2bb584f52fb3f866c01e8395940b4695070dbc59f7a234843159550084742b49c57ab14bc991800c0780827e2d16b66d0ab10c731961fa254cd065ce5ca351fa98e00f4e65a3c46e59da5bcf40d97dd51a06a4f87588118c02fe44e11a8651a0c5cfc16bdb83fa85042fe657d721293c379a334cbea8382b57b947cffabb98a7736e4e7fb8da7e6653d7b3ed57f8a0fc92475d1cb6c9ceacbcfb030c679dd3b52ab5cb224a49ed0e347583d619e82f9b423acf4ef5e5a2b7fa4ceb171d1340d28c15c2a9c766b51f4b3fba54de43231a7f512eca29223a5e80a86ee213d5fac584a6e661152a97999d31e208737be3e2fd5de2c19f25e901eb213d8805e96e8d33135db7779787a9336b8e89814d624d6b077cd9a2fa1f4e8ffb41ce2015597d35e58efa318aa87091f46025b1c385cce071c05d950c6f84c7cf71a2de25860656577acb2fdadd4a1f4ca756db02eada47c49b044a27ce78d8aa0f492b70051ab9f429a5380dcd18a8f1627cf87c096f4fa5f7275bb80a83393f5f8131ff45d821b2f7d00d187c3dfe88a7e9d62797a279b2826d42a4ccd54f779a8bc0bece270b8543ff4ac4124ac4ec7d9e33b6e928579f2841fd6aed9e2eaac0e0836552af79fd536c46cfe30efc59ff2d8caf19f5261cf3e63118b446d3213699cef1a689b17707607512f8c9d93272cd09b36667d292c097c53589bef831c4c4041c8bf858dc7b0e623cf102274e438476cc09a3494cb6ae7c9882845a7f32b085c1c88ab340ee75b0d73038b865c653dc38507c677e3905078a3f566bf1af9513e7b653a8fc567b44263c5b139175a4a4144c713ad6db7f45aef81eb5e2b0dad383af8e437bed1452a0366b3d77b65e254100512ca1f34317c8c4e35a2d989a44ef8c250dd048fae1cd0dceade8f6a0c54227f21c0a6c0c37401c0764ca7a1a572697fdfe6adca88e942dce99a6510481851f11dd398c0911774eba55a6e28727084b513a1dd4f792bac89803410b785efd2d157c3b9e5dbf40d9c3d30c5c50690ec896276030d6b172bec55e558e5d6157d22763e6242b6baab396aa7a36c74145fa75a9041012bcfcedb7f84d602ff46c26d0f386c02986aa763e73df81720b84dc4941820b100fab45837a927facbad14d27202302ae9be7b2c1568097218b175169bf46172e801f8f478474ebe0276ff0ce13d041350fbcc5797711345da229a5eeb97c8cc30a0d076de2c6968c5f42f5e29965cfae9a94147fdec85489d903a6598a57f62a07dcfd2a6283bdd3badc7409be74358b8d8d4b962caf286547f0bfa97d6022145764954e41efd9a71b3fc0db4313ccbce8d249b60f4e9802f7592cac13a194195618b73a6a7163a9ebdda37447ef671051e67df28cf279f8d7376d5d83d3af1fff9c12a10ced8a20b023c9da5c0ac498967b163c6c7c7a98da7c49402eec4176625d1e8eae4082970aee77521c80f45fdc2ee55eb9340dfb9ac6b39e84250c8d4fda51d511b0c00ae884ef5b710b44f3ecb087fdd88c51495f539e78d103a552b12b9e8843ab77a9e3b45dcb375c5d251f921424a2b3e4810324ca54d2e79bccb35e03eca0283897dfad590ab1d0de209e9e6f624cd5179e6397844edf4bc010ec305af9f26cf8b8b897f4ed17a7d4f24221d2a4010998de785cf69bce603402dbd7a4f4e5e8cbd4fbbcaf5d7efefb6b5a850e5045770de06137c1a1110d910c74e53df8d189d5fceb79ff913bd16df1ac10a4c5087facdaa58124d9ca0a8473c469bc462ad6d7670d86ddba990bc0d7c06b205532c129c711aa5a9fb4f817c7b66da5e40c38470a47f83b3bd53984de2e1abcad9f1e249013cc3564ba524263abfaa62c2c0f385926dbafd630d90850a37ff21cd7fb7c7245b3a413c64db5dd430a961e51b69a959e4ce054ead88454d3b82dbd70a778f865587c082db05f4f4592d2e7489a6d502ee6a9d84a827b9088d222b104347714c44a4266fbd10a253fb39f0cd0431350070b7a79a06682c39a4be44c284c7eef8012eeb4d2b62db37285a9bb9047c6a456706124845647036f907f25a3588c2df392a4c37eda2bfa87b949b3d8466c00c910815d426aa44163ab0305e347f41920cc9d5a1390ad47f0b028174e8a05046c0f1f5c001d2731155154de3191fdf5e40de5945b5e664b1d4189b4c132ee02d7963033204801768fcd43cac1e482c05184fb5096d8f524acaa825974e01045b7e4a88d28f2075f2504985debf9aca2e5faea24810e786b478b54005e52c6d82b40ff81bcd5fde8a2688443fd04ede6fbd587b4aa912bf7e643bd5f7a39f3cc61689e3fb5e218ad5b0ede00a11d68587709d05c50562177be3158e6d34980d274d0d43825748571bf51241ce41ef4c22275dcabf3b17230b4863e7d34860d5dbd624b8a34e6ba7395473500d291477631ada40d364643c1c7c10a800fa2d00ee96c509caf9bca33e6f99baab4d5d3741cba2c7f8db551ebd449af860afa2958c43bf7ef513117ac2917cf77ea61f90463ef10ae3c524ff88a990a914566aed4d5f558c16c48f704d40ed27434a45159ac8d853d7817a15a8e7e075d331c620b375e76404058c2d67df8db13a59420a800c815f1f6d05964b6eec9ce691bd42643c0716aa81e443bc839d5c6583a1ac27d7bbae2aa63ebf24b2d83347ded68b0cea9ddb1f32e323bc53e1ec53564747eb893d31c933fa0e80be39f4c5ee7a986abf3b728e1b9a97a65e67273967d42cab86c66e9c22ca1ace7e82b392957dd29c0da6735def9aa414e894ea3617303b183774095484b17eb5ccd73a66ecfd276c2dec9c485102d52720fa9b0e3c8dabeafbb0f57bb87b05894257ed0cae5dbf903145d9f61df31c95bd0e9dadf8be48786db259a0a569a6cdb582f32c225a36894d1dc4f080ff81074fe4ce30516db358305049275df212f5245d153d3cd84b1573b7f29558f660e91a8e42736816766984d5d453b6967ea6d93ec19295cca45c3896cfab89a2b6f82329cd341aac1877fbd2a27db2d2b6d3a72917d8f0e0db3095231d9ccbde2323ba021330495c2ab638cfb55babb103d079ed51811e5aee83339d9d300774a0edc45989d015f26ca04b2786542775d7084a2a21764f674539a64206b5c9880300de19e7d5eaf3802b0a89fa61641eb4c65f8b741e74430301c4cc647d16d4c84d5ef6371624cddba91dd81d16bd173357098285868578e0e51d424e465acd872b97fcb30b176a299df7df77f0960a11a60a281482bf655054dadd412114c1ef8ce7e1a33e137011058d046a98db885b95dcd1503a0171b8daf3e5e99bc190ec4010cf55253a8a920ba79e3d0a2f85850764e306f32baed3a4830389d57a2566ced1bf247debb572442a3aed2da84bb31bc634a7c71b0b926fc227207c71e7ebc054266c5f8aa14aa035173f9ae86c5e7b5e40dd557fec705bf80b70fd65805bead513202119058b95bcfb137c17f0f5c320e9b8f765dd4c0b9203377cd57a2b4286bec10e4558a31160fb345d3d331643b40410438ee8e778146e10bc0dece921a899f64d93d24428a99333442d248bb4385582aa3a8b2918256507460a7b63bb4a77e4a31f45360e113548bc18c54dc9cdd8228c992a1d6ec952f323fce80287b4cad73b3098899709f1f6fd65cf662da8222f43cd6c67c7ec03d36b3d49e2bb4a49a6ace0d6f56487db6c4f19ddce97ef8b9e5965911aa7587785a469d9873368827297082f3299f2ae2b655007f54aafb8cfecdcf9c89eb800b68ed95b315b456c21421e64e6312b75fc36f44672eb4cd245348d16ce56a003795cbc35fff6f431c5676eeca87462886571d97d9d26dba8596830c766ba0e3748bb131679388d8f419fbb771d9ab6237b24fd9f53ec92141c3d26a64019bbafecca640ca5117ae66ce4510c3f760b056af467a0b50f225051c8146e8305e5adc5176adee444538b89667c6f4218fb98477906f757dbeb2be9ae0cabdb9b2e1b6596fe10474864ff67535287c0db579eb020edc51d77b39072de6cedc58a2fc7e204c32ea680b45a333acbcf9b0e9cff35331f6108c760f6ab52dc8093146db872a7fe39ccc2cc85e5ef0ad07ed042a0a03fbdb90900cee4f6d4de592fe29d3884a9f06d1f3f952d4cb948946944e3acf01516dda787e3298102aef3eec19387ddc158a9347c6aef2fe91f1aa35cdd43f637f596a1b63289c07aa8f6ae90d5db365e6d1ade24d138b5d0c23d8d0be83b9d4cfdd3a3d28b874e68b90780803d664bdaa233af9ca1b9552e63675f5ed17273e5fc35b15e7c9d817a0d826cde665ab817804bd580d6f421d85780c970a4c6060c894ab1ba58a70baa1678ad91625bbfd35bc07e7c27fbfdfadeb0dde5bf2f7fef8b6d4b654071a11edbdd5b57b66daa448b9d6284f3d94655b9ccea81d67778db30c6f9a88a152678b5a5adf1b19d93c8404e96bea20ce82214880977f75eafa896930dd1767527a0b5bc46e180ec0373fc4e759233d97eb54212e28169147d422ab8c33483a8b3f1dac13814d83e5be16c4c006ae64f97025c563fa5140ce5d10fd5045a19907526d6450c729e3bbfc75f7a5d1e7b7386c64a76311ebf4c8a9d0f532653f94ced98ce5d15672db7c85415686e598c2e1ba59d7f1ab0e0088517efac89aa5cdf34869ff927c0e50304ce683b3831afeb809f0b907f96e0c3624d73328f2af1be20c68a0468c7cd2a33e27eaff89f977e379a17b070b97e5bde39447f3d3d7de5f41a3aee3c7d3eae21c467209b4945985cdf9b10e9676dd2727bdc3fc5cf28fba2b471f257485e940350e82dd2aaa4b474750a8408f27958e8a4922bf37bb77eda178c2caa7e786a2d462a4fa7ba8be15d0ae21976bf11b0fc7ba950134c648e1f422e917b94f2d6322f62a05aeb1f257970554ef775c1f2fcbbb4a1c4166e731ec561d95c3970dd13b072712147e251d577035324f6877c112f06932f73bac8c7fd126b41e4658dc988dee4344de7043d2ee7dcfcfeafa2506277660cbe5f585af1e6be1136fd921d9065e3fa44bf0e8092ca93f487cfa5abdc53063181a07e15faf1d5b391e16aa88daafef06eb47eee9fe449eddd3eca8ae087a5439de4e0a9d549b79780657948475d8df38b51dab42a900c6697db0eee9206fb8b4c3cdd826b6eaa24be25f2bfc4f92126838f61ff1eb3195364ce7097e9306d112010af6233ad841dd670de229674fa4d7a25db59018fa478ae1559bdc6af0c98693d75a705620f5fbe5e7a0ddeb8fca3bd8d6d7667bda77b14e02b038e5477f235d4b9da7214b634231c7a5b48dc48373e47330a618db1f6204224309f505a47fa1e1b81ea3e1dca1ed1071bb7cbeb58420d9a3399f3f54e959be31587c59c03e4c4d3e4b6c601812ab8e5068907ff0c4318550e2a2210814fb8d42f67095b9fe978d19930d1adab9d0b60a1c6ed9070aa8bb0efb41f06910f0ff2f1debe778ef6e9443fee5ec64d06a097602cf7fd09e63c2073bf172c951609a03677fc48d46f39585e053da661c462381e5b97000aa391cafb4579c50f1086af14d2793c1003b6e65cfb86381033f5ec287def09e41ae696cfd595a5536d07cde5877b7eddae1db0bbc7e486e1a8f626a3b9b2c823b76b30af126bfe34d688b294de204aaf2332b5cd82ff121d401b87b2256d09ebbd6ad817f874824cc363e68561e9f61b208f776c64e38efd1fe60e3d4588036777cff7414a454dfa9ef7f6d72b9c89fbdce3a82cbf2881b33d8f3e361e739996e003186c0293ada0a56602166e89835b62fa485a5bfe95b5fc1a9f8e2d6d55b137b9076cf36ee5f219731e88d26c66f10eb3e8d3f14fac44c90ed0a99dfb8d4d25af4778bf91979d60cdd8e1819fe18975b9a051ce55c5aac495ee4ed28d61efcc5b6fdc15e10e76b07ad2df12d9130e3bd6c7962e1b317ed8f11428557794106e1263f0e9ede048bb9bd15033c62dc57826af31a8f48937cadcd61c9bbc64266c56054392b28ef384b1abfadc09fe3059526cf9162fb656582cade363c4aa2ee4744ed245d237b9226b92b33e5a764f56c4c3a991acb16861c470811776da961ba3c5909496aca087f42e5b191d4dcf3f3f49a743364e3b6a37672bb23a6966254197c4404f2fb14d9a3fba1c8fe5f01f252e61b188cad04fafd4d8a283d131564819d9252f76d4694efac20e0510f529831bc7d170b4a6ce74f8fc7ad4e70169e6fd5a9dcba99bf0a922e9eed3885a02bb51548593a33549729157ef4e1f73040fbbe7dffde5e7554d0e56f1ba1dee03ebf402eb48cc78cb75d509d4fa8c5198df3610c3f76a03be5390961c320bebb28fd92e335c2e664207c0d0bb49514659c3070b87637aae2b033ad0c5fc6bd597d3dfc8a501f5f80fce565f9af468b1262000f2f077fb6d66685989b69b0283159695636b7cb35cbb012d692a268bc2e9f84f189ae950bf6c96e4e9fb4887e51120b8a5b8c8a7a28f6aef1f55ffb9e421c80eef8f2134189121b9cb2ec8b08cadac1784328ffb8ff617e0904cdb4bd1b920ed15d6190a71ba2e6fdc3057dbdf1eea403583444134443f41bdcd472ed2af0e4bf16186e5589260de7549b11477a8995c7619800dd4e778edff3e2d669f243e398d2235c096a593b52ec7260315a5739ef7d5c085a3405248f2daa6176183821b076078fbd21fa76ff69e5cdb8d3bb6021ef28fa0d56659e7c001e8f44f36e17f446d6d7adf31f2ebbba8faa9d601cdf2451737a160a70b6bb36bf6eeef5a3b16560c88a289618191065f9cd6784fc0f3c926a38b0cf5b19837992a32d18b320763f6bbc4c33e8bbcb03de137e02db78fedc71795944871842a70f311d3866aff58c4ce0752f27056835ef9aff61e079405d651515d86ea579c14a74e8eb002cceb328a6eca100c7070fe5c556a31268c28ff930a44bba2a87e0b1b5f3858f75038fea097ce39eb774e52c0137d2d093f3ed1b5756e63fb835433d46cf3f7749291182085cde733a88f711ec2a73202adaed986791934d31cfa941fcaca17a7b8236cfdbfdcb375a285bedaf7925b4656e0f5bd6e9866fe681697cb13f2426dc241327ce4b01f9e18885d1e386f9872e4204b62ad6cd7c4627923534ba1791f83908d530ff35879ae4c9da8c97081cc086ace6c19b5556b98de934205c898ae4ee5d262297af43c8d0a40f8e2b72d31f306f0bdb5cc0565e70a009a8332bcc2d7dab8b72d96e6458d5c03275034cd2d23dc48443c55e2381ef108de42b0f553c5ac84945c5115f53b346156debcdc510674212011d44415d0211d481683e17ebbc843db3ee9b2cc9078d8f752120d2fc0cbc85ebcdfb1fa1915e17673e1836ea3edb5ba0b5c93e9253203701cc3317f8c278174c7e95f38bae02e70725c39a5ba1965287534e1b53b2d3b966a339d9e00b00cfa4a0a549e15ed6e5ca031c11d5fcb2addaf051aee3feae7971fa61f44f7aa93e598b9e516a03fe2b7de3fdc2f0ae6d4895eb1df2aa7f3d25567fa91b2fb8619bb484f15dbe46cc8ef73dd665313d3c8456baee4a10f7c86176b9eedd5b2bb0d11a5b12af7b685cd5bc9c0c8f91b6ece796c77191da74673280e5412ddac4867dc93c06f969a63555e44b12be4829f83a57d4f4830125c1e329b5b9ba389cfd06b5a596347c01cc96c168c61a7144d4f8facc520692e7dd61362c8dc1ef9ba2ea01b5ce5320e64707c7277000dcceacbf6460f8b2f24d3ff53c5a555abe861c1c3d23550ebe96eb20c6ee3603e7cf3ec0049f3301a84f17da9134284990427db95fec111e950471d44d1fab35cf70aff23516c186443660000e61d905619f49537ee3d375773aa2c6b1506872661d48a0354bb06894303aa48e1de84197f50192e3a9035e016c7a25f4146ad4b3b961ac2b41a433d951f03f2d4ab1d4c64a51e1655ac4f7da3695ae91a6b0c1d7cf0e33be889e2d450a0e333ae00f8160d429255046180bd63f2f54e0a526590fbe624e454315775210916316d0dc9dc904015d2bfbabd0fcecfebbee9b2b157d7e0b2a6673111d523dd0cb9372f5f6bf36d89614abdf9db7c202380b58ff55d91b6240c70e338fbf4e648e3da6db53ae9d4f927608530779ff66c30cc8be47c8ff0b765436c29cf16ce33b6adfdc9f3e81f1f20555ee7a7ee5d69e9fabeb052e14b93d5420ec29a43c803ef44af22d2f9986a3c155c08062329443f28c72c4ac5a9a42dc67b29b201eba1b030213562435e63d79cbbe9bb44b90d14309dfa19ecc58ebd0c86c3f66d2201b8fe6fd7b3f3a6900596ab26a21a7282dac498f18ca8c643284b3d1ade67e21e76cb3fd8c90d18d4a1a7a87dfb1ede490c9666f6245c73b33f5db21716d619f899f22b5f75b34241ae937bea5966b872df68780b9368d25bbbeb6ce9cd7df61495a167f9b0a89c06f5e7836b61e9df46943eaf9f35f1f4b5ca2c375819d589e396abeac059f69843897aac68c0eb5802d8cc764912b5f78119cbe08a189a9b6fc1cfacb3175fd14eb94b494e4079b34ea6a210082b0a4c6b775ae7f02ebf2d3249bb6eff8931368148669ce808c8b34747e25fc1fe428c054b81d18a3cf3f6928db1edf1877a6cb0559317ccd06dc9a6b28448dfe45affd08014cadb451a410855f97868e91d4846e896b19d404d8c871460cde8acbdce6a60a7c4dd4e1b70d1412da87d720becc4f3eba3f3a5b7aa98681893dfc69f31062439f1cc8f82d754083a5817bea1dc04512e8222528587277171bec2d0836a43547c5cba1a2d3c5f78af38605b23ec7e597e372392dba3ae22ccd2a40c9e59c0877e834fe12d1f232031df53377f67a90d846d1e4a0320fe24c5790a7dc9034f97543ab65e238fa3b0cb7bd2e08bc1873d84648314f287fdcc68dd6d01cf88c3f66d6f947905a5dba298d28583ab4242fd18b3443b6cd923cf05db5c27f0b2677f9d2df5492981bf739b3fcdaaaabc3ba91d54f04179167517b68103235476e3b362b3d1976c2315ee4a7f317caeaddbcd03acd25426b1adb72008ca43bbdd4608aa7b1847dad255f63045e326a95c99119480219c820f440a1d2b9a9547dc59b8db56b0c4ba80eea1c1396e0db15d717b64336a03caa6c4c1e04c8275c96f0f593458ffa06bbc8b7a9dd453020a5878cbe1b7aaa6437bded6bbc1f1561039d5d903a371be7ff1f1246cda710c38a2c9f04e7403b49db9a74fc57d572bca44e0364e73a1f74e0d2f0998cd6bfc48a2d575295eb29180a2d1feac54b93db520f122356caf0323172ca63538bace9702143b9cedfc64194a301e969f9892cb34e47492b8db11cdddbb235afbcbd41c76c33525c3317a4fce240a3b1a881ef6e6bbc06a43d39297b1b8ad5e42afac30146b45e11ae47560263658cfee9e13bfa54a7ece03120c0d667283e15f46d44351eb3956db60ec6e64e012248a40476fd5f75a789a6971fab231d875682c9fb66155e35cee874240d033dfe3f5121c9e2bcef0930f8e3b178eba5d19e5820f2b9278e1ac332996e8c723148b669e6cf326c4cf0c3fcb6623ae25d3255cba3da24fab259af2ff50599342d9077d6a93da056febad3d38522be9236dc8dd9f3e7ea65f05e16397760e614ceba5f409e62ac23f8a14dfc2d0624dc36eb2d66c5e0ee13bb6e77b3cf89c9215978cf7049f64386a61ef5c42a688e862039f5d5193d10110deccda2e8177daf715de19fc76c5808f920a217ac3be4ff812ab1a0991d97d2c48ea9817ebe78dbdd2083fe5c82025c694fb44884cb3b262d53d1a9d1d42171f8722a363af7e399077a78d2a9f28915ff2fa71c4b9770f2d4c8b6bbd33779daac0176b6c74b2d7710cd4849fc709aec7c8e2ecc8bad343fbbeb4c1aecf41ae1b045aa24d3c2738fd1fec25821d0099695d30c54ddbc99b5c515b29864d0ec5991f8455ec720cc4d95896dc6527ce6f56c675ca1111be62ebb7ff02ebc875ec5cd7f483478ab7fc07239ec3294f25fca7997c71b69eadcbbaa0d91d9ba741afc6942f04d2a0fef927d98f62a8f87403a1158a9beb114e68520555717eafad185ddbc62451e9a8438f39476d4287a308c48347066077d0e2619eb470decd5bce40695806623f3624260676a1c1c576b35aea6043d183d8f72da0db30822b1d624080368747757360f136bd1ad784951d95674916982f34195ca28fd00e3688696fc79408947a44d5e78f7aec457f6c8e7cc1d46608826dc07d355ff76bf6e29cd712fe2a38dae88c03c763b5370b56a3b4ac5b87007542d108deda012965cc17ca15f78d04678b1c85f400d2522c3fd12740912408f156fb5fcf46ce85eeeff7ba3ea82af5ad8293e995f5feaff024cf3ed7f6da318f0da8b2c36ce8e2fab62bafd7675382cc3cdd98347411f812ba1e37416f31c8fc9858cd2f3543ddcaf9f421b66b8a3e98bd0da15c580cce5a43a8f874d04ee867a8b557b83b2e12ec9698918bbeda540adee1eb2e6b8552f6e1ba9ff6d650fd53bfce66b6fb4627cf3d591c45fa8f139c00120aa24adbe03563c7210152f3e5aefe5dd0a71624129052eb65b7bc99c4d5f0610f5b2229e8adcbf5dd7ca92125b28e3fb946aaace03fca82341fe3c799e928718bfb93ddb35c0ed8b1d545e13b22e48ff8033a801e9291734e8606722cf5599e8592993ff841667d13382f56965ebfb8b34b6df1f3ba229ee1251b62761a49f2c804139d7df8ee600cb816f94385ef24ed245f7cb55b770c5b4220dae3be78c697ec8926bf394d7b32f356bb23a95f318c4451b6adc662fc764458dd7237a99cc05987fc83d267d29720ae3016c11aa33351e573d234d3e21e796e752d67cb05b519699d9b79382427e49aa347b2e4734401279b9b4d239bba1de90103d4c24feea79b8435d5539b4a3499f42517b1aaa4c28f42a8164b758583ae37811ee4a10b9ce6fad234c5a392530ca2631269f277b5200971c1f809140008381b133ad28f8a83b1d4e0eb0992a0de414374c44d6d6d414726c7f196e99046835a81464789858798cddbde86175f0a1ee24ebfefb95b474508cd811178701d95a5c2a18737c82c43dd2ddfbefaee4af4e390127ade942af5f73fa343a211e349a7080145e49c04b611d5861a5bc7a1a21b0f54b62507bf59d1dd88445afd6e2162ff2e9c56afbb72c1d94e095ddbac3d9844ceab39dcb92c470f99e545c3d5604aab3706af2e457120917f7f8f109795f56351cde4435aa84c2d58c022a38a9c610faf1fa5a1f4366c53571acc0abb6df6cb3a2a6dfd266f4aeb1421ccc890c22a4a7deb1525fc944305222aef9a6f2a538537f193f189028fefb89408dcce4f7dcf3f91955cb4706d042045d7998f7f945bb118ac0fc162888760cbd8bc64d0ef1d369aab614dcebd10fe3ce54f3238a7ede1e9069298f60438803989dcbee669065ea1e7e029672f2237038782953b9acd14c5635d467ef14d530d3dddced5dff274985fef59e0042edb7c92e472f8117ca1640d29913ab343e054b794b1658fe42b71e15098b30d2b1b7b9ba270049c2d561f45404a87608bbda2c5b88d4d49b97b6f75f37844c0573aec21a6400b85a5836c50ebf6f22db9fcb8c0a8185a6372991946854689c0c999b3df644a722165e8c8b780fff93d7874fe8b5f1c8c62fed6de07c640956c470bfa2f3aebfed8b2155bb434f5ba910585ac470c95245bb4e3f2a8e302ee1dcc027aeed8fc9dac7111463e0f6d990335e7fc566af5bd01ca4f6200a3da5d0c58a242d07ecdf551205fad2fa818636c86765b0e0826c39b5f49686f25985fbc7623f6f1ba0b26a9cd109a02e53a335692cbe8ba17c6b5fb5e376b9334914c1ac8003883351130b708d995f9a3b324a1636cf01ebc7a5eaba8406bbbdaeaecf512e866ebf0086dff714b301af0929bd9b9e71006b120caaf2e27df419798ebf460a049afdabb3487f57e35178c0b87bcafe77212a36f19987228ff26570b632ca84375ad67b00c01d2abfc69c5dc8a885a5b5e3b4ed332efcc89bcd282ea4be5fc27b4d8791c780cb7c5b57db5f7879e429db501ff1f7a4e61693bb4ecf50012d1c8c873e402e4a4065bcac95ab94ad880e2f24828800d1deffcefe000c072dbec6d5b5b648e6e722fec59efb1d7aa1d16753e405e82bd6605c818ba3f27b26c3a971f8c0bb22f3fa2b06cb6bfde006d4748697b2e479eac177d4d3bd577e6bf2a8163ec1f32b03336f9b67eaffb6ab40542a346d2a76c942933ae9440d048ab5129d549584026784203b7e568750ffe75e0cfbd5e037b2cfcbef72581ef939a32d576c759385c9d1576af1f5095585b88ffc4caf482b6312162fd9d6d5f7e046f8eac6586b401b38797318e5972df869ea7139ce2c4de9a7f73be270c4f3025d1f81f6d9afbb2280cdac611ef330d67eaaf5fc28f4565d2d12fc83b1f925ba1a84cb9cfeea821f13e4b7ade7db68cbbb7e9716a405163739193a95926feeba87d6c08a9e04617820262f891d1790d889671b6dba333cd0c61cbf5a87b40bbd579dc915e2435edf193f3cbe7bfd9a2e4512b5f98d991a0d17a8ccd47366600a4af6b982f2952ba6ad1cd0c1eba6d45c536af09a54be27284763138abebdb785ed17e06846420b82d57aeae6c99010851526063583ebbb78b154a50f61983144d33ec036e6dd798aa0014d00f5f470da570dec86a3c8f72f508a91bcd0bf78afea7772c684c570770bd65e589c91d18d0019feb8787b23334bbc35de045e089fd3d62abd48d53c5f20385d00c12f816fd515fe6e11c67a228e493e4096467942032ec458abb45c0d66bd8860c2b8da6c9be930664a37a4b9ed68dbdce221dc5e44fb87477a7b1a0726515c864c520d4cd0e9e486173e53c33557cd3137be653947c041419af4c44b8fae2dc93a54ee07e45b110d678124a8bc9e02e33c8c0992ee20773f8794a448841c149bbff727f215b387eac8a3e4315290dd4227bd9e6641cadbfdfa98b5a8fc38c4ada824ff66d60a95e1ff2206abdfd0c0d18fe7eeb3919f9ac5ae6660810ef08d36997a57c861aebc60450939c556edeb4841ea2f8f6381afdc325be9845c79fab09074e556cb8d45693e48f2dc081a9d34be5508e3ce1e5c307d91810c70d8acf18ae61539f34f90cd33641897dfac900b43ddd7cbe72b34388a2850ff91b2b863d576c3bbc8101474babd81a8debb21f40d789fed8556db6473ad17ab8e650a8bbea91071e1f73533c2fb21d90e11ee31089fd02ccc1e7c1dd3383ec0ad892bb015ffce51832aa44a43f933ce35092f6fa8d5e31e40239efb1be55c827b59cb9d9c5eca4c8a189eb29386b3ff17c1ccbd00e596a68a1711770a464d9f61ea444057f36dd26304e77f479cd280414dfc35e9b739df75a49548101632a31c440a48c870f5006f6ac7f5c64eae760bf5f1e85f3f1c0ab4ac11f86bcc694b1a1c925e2e89e61577284ce2c4c26c43d7d38f03bb42177bbb1c3ba7b837a06c2fa8b975f7878c992b883e95f25ba12ffd384e431bffa185269fc825416351fd2da772e011aa517b06764162ad41d8202f3ffaa67a3a67d0f13e8d2371d9e9c7ecf33ae78e64b608ef5c1ae2635e3c67a2a8556be1743e18079e5438826dff2a185e27aa8e670fe48a27772aca98f92dd7dc28f6138a64e51f6f251fa0672a4ef2e1b64288ae0df7522b51911f904d8cd8472ea03c148daf2f15d20dd5eec9dfdd1f89395c70e532ca0bb48fef9d8c91ccfa307bfea118a720f21fe4868d4abd2c12ce11b0048e64aa7ba02c4fd0e53319d9aded6f9e235d3a4fac50c154717a75a13d1228b63808b9ddab7a5919e4f3782018ed05b85f6bb25512ce69f9b573213f5a6bcb58fb4b723c5d440e2a704add9cb06732a98670a6d213810e467ff13ef2cc23d200558530f5cb9ca6a02e5ce2e994a2987acfc21c42183d0cdfd5dd4df3983042fee2d6c838bbde74eed815096cb35059d5280e0ba340ad1ae8318b064719865d7d2fdaad15aeb766f0d6f6a5580005f54380920c5381c939c28914b682ce8448759fdd8d1f39d62557b85473b0b79473bc27a2094279e931a64da4790854110ecd7733e05e6c5923ee3e52f1ffb7d3598f013a8b89db6768d79ffa50a05c1508cd7cf98b9647862252c657546ed598fb872eb08eb2b4854f35c4d4d8325e7499e1d1e0d6e4d41b2416ec10c0461e2257a592cc5ae85c9625b77b1c43c7bdd1303b7d9bb0124c39c2d846169ddc9b1c10db27a7278450e5c01b01fd088c2f679c19c6e49aa6a2c184b8652794fd9e34391eb7dea5b1cf8894c12bdd7b4f3378d0efac0bc8b9bc8d117ebc3801dd0b26d9492932e4500b979d36e183e4d0f48f9084aa1db76c1a61813333b0faa3513c76263b5245eab58c1734ff7bef795cbf4892d6057d756e684b3bbedd2374b22b33c4756246b79d03123ca59dfa654b44bb1d585de72ebb5107851adbcb78ce5ab8401e26b7c63367eb60043b7961013d7e00a6b6501ccf311c03a3b70d813da09be9a5377f4282ebe58dea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
