<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fdec083b683ac33159baf5e161d2b44138799faa01ff460089c08542c80486e2b6f5c45fa9bc1375cd3d022e4a2da61c284a6ca61964f1a4643b6f31e5aca74356e35d1a338abc85aafd00925d31f13b32d6814d4c2d30c5854738316a21bd4b4ba277a8f88af2b3e70d1c375d4b82ae46c4325b55dc486d108de15569b1831dddb35d75870bbd1ba1eb334b185087c5d8ea2df960c07704e405c7449d323bb579e125358f315992a8d3de4201f0c2d49af8f8ab8c2da9d44bdc25e9d96bc42a98d6d1552d6764b8f1df28c376220acdab905e98a10c465e01357b1bec506de894a59ecf832a397c24ee65586df5692dda0192fead9f44d83187f1907927bc36f41c1957ec898ed840fab85ccd2160833ac90a5454a1bc16861740081e06d9db5ce7be850445dad3673adce33769b3a82ac635f2fcdba9cadd5889751c476e8d71d6613de2b348b8e3279f5c79842de72e4d8a4ac0d83ffd2452c7b3d70cb61b4f5a3511898c935ca4a123ada03736a57a3c1f416ab378cb4319f4182ae9fcecbf534b06d1f2c80ef804748ccca80d377f7d6fdd54a339b5fcbc9e39efef89cb9e88b5a879491eb7d054ef06ec6a068a93cafa5611efe7e6bf45771ce2690e201d96747b28eba714e9128d4e23d62006c29aceb0ce00ed94073bd262acb8b3e3c694d279700633c29a844240b0ae97d9c2c9b347184e748849355b927a62e10a156a294e0beeb0812979871b8b79fd18da154ce930cda91afbb4548793e16947eaeb446937096b04efc61e59ad3af5028e3547bd25952f9eaaa0ecae5ce5b388225bacb69202a2d282ad532014d94ba5a29227c3f442a8427365541895602bbc7d9dcebb344bdfae5f2c02c51120cf8e3e7c178ab7ed72f3efbc375a24ccf4fe2f76618e285023435a4d6f1ebb797c3abb511971fe6547555fc470da9849af798a0a394b15d6128f37d565c55986caa84c1b9964cb3b608a800f70b6440be2617a1763a041f387b5b800ac1eca433ae8bbc61e7a7cd71f3bb0b93581ac3b56ea7d10f7fc2bfd0ec4374608c5e370511abe69b17221046f10ff83bf9cde6edb1bcfda035bd21bd1b41056c9d3139717ebdebf49ead7d716065a79eca11e3884230c13256228749b6745646c925731923db8bf9b78d1b46a8dce92184d9bc8fc9b7ddfb73844555d0b5f06ff7ee1c85c892eb523a7036981e88d924bb5de1913d6b399cac5fe4985b9b21806e939a01e20af73860cd4020f3ee9105b16953a78b065bd472d7d60338e5b03ae362e80b18797eebac58d92a3c40eb85354e315041c29a14aef102cb0db05fb0639ab76c77e45bbaff1a30aadaab616274bb2316668ea11a7680bd0aad32b83dedaa375330884f2bc6c1886aaafec3d61c7912298b283a3ec6cb6c027596078595ee9bcc53f0960ea54d6e6f6980c45db058c608629482c0d2f316702a58834d31e86c98b6ffc448810c9f4a024a3c6aaa22bc601e6149e47c5c3ae33202dadc7e8941e41df901ce79a023869f686276f2a2b7c0ac34d4b791fd264cf6908e15931df55252fe7e688da9f32c8e61832bf35e797c8c95ffdc9fba42527c8758d0363cd2b22e550f1828e0de5fe8f53b41bff6306e97ea19494c5fa7ad19ab37814977d8cb9d09289e94037e7e9bca27b32b948a40952ab38d6393d33cb2173844b04241b5dfbc1c593019516965b0584ca8bf9aa176d70d53f39a74f9286682606a2f85b2744ffa99f4ba0906dca2cc6eef2ee2772289214cc6047c9acc0873603a5d099e1fb863c3387625598bdd933dc44ae85e099cabe46300591fc6a17d9b5f9a8eca5c06694b131b45ff8f0dd0cd1287597ebfe6bccb6702156266737e1f26198f018308337160a02e47187aec0f54dfd562e3a5fdee6bf8d48d06ab11454b5920f1967d46fd47269011290b63e32a43ce9d35b71a41a9be6625a1eb073d9a184289daf52c35e268f426cd45ab90dec3b59614e3c155928baabb7d4161ec8ccc0ca8297a1173956dfb99c143bdd5a352bcf795aeba916e889fe8c0d79504f0a09321d5d7dc9629133b9db6125b318641b5a87d2afc82c37a94a54d0e626b1baf23695196183f65d23acff10d68e59d5f03b672959ce2902ec1f3e903714240fe75b373feb492c940455d4f18a10f18500082a409fd288dec875f0aca7703af0f63edbed4da1718e99b64bd03b9b8a68e3da3fdd35ad1c95c1d79c24423ba18e6cd880b37e784b65a28b035244e9ebc3011967bd09f8121cdbacf6c734425df6ffa8de1d127ba7331329d459020044a4f87257f590f7d95eed03f74d3d28e302065583f5eb565f790ffd1910ea73bcd4e2c9f60051e32bed365f611115454e15ed71508791e73a64b70c78afbdf77bcf1a12b9879f14f53dfb0fcd36ecc97cef658ddf8fc5317030a8842f3ab197a7c42ea8b2e063ed71abc892103227e8e004934ef2ea5a5fdf2108816bc33aa2278bc1a7807cbcca92e69cbb68988b5be94f60e2d47b39ea3f058e5befebfa0b98f6637ad7019172b50b7f2b37d9fa76e7bb78b57265e80a1199c3cefb8503179a1eb904ee8a0fb5023c75e336684ac5a15e1cb1df9e1b731556887b05af0bafc8fdde4fc8b51e27b31d0d0b1c975e125ce8f43550a023732c853a1669d5da6823dc13b3007122ceb5e2608a161acff2d4dba9994141d568466d70f2c8357cd66ae49b074d8185368cf79d597937b288e8b24a9bb29066f97c4585580a6fc1178bac68962ae3a9df151d678b197fbb1ef403e7b8fc42182cf04b8fa636e4de1e50fe6fa7710f5111531e244cc082cd452a203348520598ba9b9a10240e4989f8c3aa58948befbc5d382fc99bde8f2f9db6b47ff6d7761d06e18c607d2cecdff9f59a043e81f1de5f8afb8ca3b7b76eea19bf1bff1deceb8adcef59500d14fdef15392b03479bea3d5ec8f4b3c795357c7cf8760537f4f4930fbaaacb369e949b41476a2c6e552e898451a24cd2ba1b6a8dd10b18b92ef6ac4679d8e176b4dc83c711d29165015e8492ea8daa2a675608f233b9ffd5aaa74f7902436dc6a2979548ae9ed1c1fa5dfdf9885115a7e9f7cb0677ae2ef531b4a718e25383b141115ebe1071ce9283181fe7db653ee4558623d0f86372bb1367ade4a2befd71cce893449f55650d91f851bf2da6cba2a2ae9ea53764ed78524c83b709b378ba481da91509d18a4f10e26d416f0e93ac44c5c15653da930895aadfcc05ab1f43ad00ba5d7ebc9a0894d123fcaef347a4b14fcb1506034fb82c841229b59e817bdb51a2a761b19eaa2ead52283c331b9139dc16d5d0a5ad998ccc7e5ec0b6253b42722a364b8caa74801081e86668c96e3fc2ff55346989327e22661335642df5a0971cd13293c8b4a559e36f16aadaa6c17d238a7f18f1e89216fdb67d731686900ab5fc1de54f10416cc350eec3b1aa3dd775dd14be0bb42def07615665549f974a81d0380601d6d4abb44e73357f2252837277343151f710080a903aa0c25333d9323a8b74e9643d6489de84947cffa9604d66760af365db90ce84df1a61ae0a5e67c7e6446df8bdebf6ba0a26c42d13e561c617615ef37f969ae38a389ebb97ac3ed0fde39f8f8a26bfcf561d5b2495e4984dce3279ba5fdeb59e22bfccbfa27aa65ae09ff454fed48e16c04e281ff1b3dac75399c7f88e73e8b4c25f60b4f8c873cc92ca09812d99f7637c87ddfbbd25ea3436c2ffcd51f38adee0a5e25193360ce085e7a1a1dcab60af653f7c0993b13bc0a8cfc8f24ed259aed731fb906f0c12ebc1a4b49d58137f011d46403b0fbfc61e67bdf25e378c83ea165096b43a24d5b768239749b2d3c7cb6d7734a71c377d504289c1729d0f916ffa3c3ab4407a8a40b3e82628ed0a002df78abc5fcbe48def0b692cd35004d60b516b2c2f17ed2f2cfa7e3173c0f2ad86aedb20d43b3c47996850741670d4cf009fbf0adb0b42b3d48a0b10df354b9c94da6aeabd2567fcaf0a28657687ed5321dc3ea70cd1cef1c633d3c7ab79bb12ad3ceb8e8c99c56f9da6b9754caf73490717580220f16c41e9d7f8b232bb9bcdc0fc1adef9d99fa86e6dfa19ddb6fc98a394fc9110a79616fda885a8743390b598a835fcfc6b3cd2823a54e308aba7a19ad877e8710d09de2973ace2466e925c1210107bdb14022b82e3e6515f352289992a29bb19af6e998720286f73e135b50c5cc6f21921662acc2adbf37bc5126a4e1d389b238c5aab567816a66afe390c2bb0d52088b070753a3d2d15351af6c4273e60732d5c9361027e042dbac12075b72d55482e690322b65d347d0ac033f7416b385f455d6e7b496dc4d9a4e5ad5481c4de13a7a96ba32e98886ebefdd519bcb20560280a27ee8ebf2e5ac49429d33f1bcc917b19a277606edd1f413e0f341cd258b453925080f990ef86aa313bb55f590f4ee124d5168b3f71cecdb6c0d09efed81e2fdc173f337e552390366843113fab938c2f042851b6c68ae0c74366a740d2daf09e85c59dcc5142b8fdb4c109456b75498ff6de1badb1e9c2fae81374b45c0fdfd913e2b472dbb034b137411069b396d142e8995639c5c80630bb12acf88e5b4134f5987f67b49d8c52c2983858c40747c9d45fad72b856d2a65deb9a0d81fcdf0d3aaf42ead9face88b26c1225a7517d75b79eff639761aa68304c448ed118720122349453b8a53d8f1e2a1c674bde014bdb10b7aaccd1974b00203592428427800c7d3ebebaba952f8aaa07964d83f41c027b8f3bfacbfc9470bc24c6e7f07cc302892a1edc56a8922cbe52093a6725b142a504435a319ca750f164ccff90a9c290ec4cec7fd0a81fd41b9586ebdcbe60333e364b02569b5758663d7c60803a8ec6473f62db723081552254fed57cab7297cba809de3bbbd832d72baa191b8022052c0bcf899e974456866cf82e7ed08ab560ec9e5b56967f55c3baba7e7640b89ed29efc06702cbf8b9310a9cddde1a18069b7e3ec486ad36f674e101b32c1d45269cdcb697ac3b30331b7fee4ba2d427c91b3445ec2075728ccbca21699f68260ecf6cb7dca7751aa6cf9d140228a236384fd3a1b00a183d248e3354cb076da013d179ae8dac97d3a266f4e68d082a89dc37024f2a7497c6e9529ac3d314d404884fa0c34caae2c6588dc0eb111aa338aa3b24444339c069d11702945017c8df536acdb2f29c6e30f708c48406e4bb253d4f1e651fe77b3c4187c34eec95bdd47fbeef4d752c2c89d2350cb177725858eedd187e78275771aef482b59f73d967f40e7217a721132a30046ccd4432a3a5442cd2d444854daa7148f2c1d4d6e1a151b69dec9dfbd2d892e8ff98771d497b62b04b7f6ce039b9165fc323c97ab551f986ca1b09ae822b3630724565f9741452abfe3aca0bab9a30a9aed0a8bab9f65e7b9b1b837760b2ade016830b6cbbfe4324d9650adacab4e07a2aaf8a70b6b020a6e9cfd71e25a937ee6bdef46daaf101c9534a2efb6f462abf68c3807774d9e6cfb0a985aa7b68fac19b7262eae83057542e1406408a3fc47a3c536567dcd174ea31e92a05f15f657bc21aadac83e7f0cd400baaf81f3afaa293e111f31e7f413308b4b9a79822401246b4e6c33658190c8c862c3939d452d47961298e40945d6b5403906064815586f3dcf31249e42994a3a4408f826ac26d203d441e3b56adb856e681c94ec56932d85ca838f260d961e74dc5ef1e2e1379f72dd6115c534c73b9be51ad65d3260e8ae1aff56def05cf3528b6051ba6748337722892325e4da49e046722921008e3aef5701fcdf1fbdcbc299d6556d59ef207abb4d20fd4be5532d8bbf2b9a242066038035865a424f0ffb0bfbf5a5c6816a04117d9c626df2c1a2c5b21811ba65a0cc1fb16aa2490d7f209b21d2c8035aae1925753274367d35fe85f9fab25f6b0f8517664c4eb780c7b251a315a8547b9a8a2ec297558be650a45e8f3fc35b39bb180711448f047ea4cea980847f1a8902939f9fd44e47b25545ff9683fd5523524ab4903bb656835f64de5d897eefd2578cb56ce2b5d634ba9efb269ae7bd8473816deae8635fec981bc0bafa3967a6991a4d68c1543494022f3f18642fec84bfafd59a72ff4f58ebaf99802534f99f15b3ffb8a110ccf2ebe95a8de05fe3b3d0f391bcb979af372df0316609b6f714a34b27358da5b06821b5a802c443de2f506f3fac7e679587b850c080f5ca4b882313ef76363799c365c9dec5fadcd5608c1bcc77f7b4195f76fc3b6f595bf57499ed557aba23aa5b9e34b4a82480e6c6ce9036736b35d76e1a1c03b60d1e585827c687ef40314199123cdccb27f9e209f3fbe07778e5377b3080458ed90bf07031aad4505c3e11975428351145a1ad7dbce5c9c0a298d24143e8de3d0aa24720b45ab36ee06cd51c0113c51b029ae287f918a785be1a5ad3614a2168c2f61418455655eecfac6884df80ebafac3403829b60d2bedd5ff5f757097b3162092536fb28ac3d1c80b814e02d3c5f35a17cb80139e00c5c5e30ea0cda467d9818e5ba66c2bfeb566e6ba3e518032ae0769601f14ea2bc1e92eade20a9d55e256543c23542b4042a94ed532230afd8ef3752c2d13e0dcd335462326f6edb54c19b3a890b7a1e24dbe6a40e04a75104c0b855ac23078b6e9214b472967088c282d1aebcf730cd7e7d4784f7deaa5dd029db7d8813e2b3b440708ab1a7ceea2b7278c5b5cd93c8b8a0c5dc37db5906afc9da702120d778126163a295ff0556066367311ec5dc5ef86db3b7e0d5f8b159236b674586485a41caece2adc7ce9fa28cbb5110243098f674fc79583abab70f5dfbec07ea4f47e727947298be7e7442832080fe2f73748e79186bfe1ece5c83442230ef868ed030426b1f944bfc81a0626fe850ad86dd2e8189901a9606d6e44dd4ccf721418d784c59bcc18f93b138320e1f09984d13bd4c123a1ff406d115c2fb06c41c1283e2b098b847e0f4942eca74a6d3c628bc8d6572c9fbccdea437b0901c154ee7f6920f72f1e5c68626ac76ffeee46c384cf916104c67656e6cef5bd0955d5f596e7c7007474c851d01a8cdb35ae56fe196663afd5045e758d092070a1be1360f02c60c9d6af0c1fb9daedc54e2a220dcce0e7f19dfcc457ec60183cfb6f75be69654c7c45fddd0d0a44b49dc4fb330535d38a8ad3bf2b46e09d76e39f33254473bc80086f744ff9fd429c9469da9f9a5bbfcfe91373bd4b69c37d28623ecec5e553378266beb584226723f4b32ed69edd988ee547d08e9f57f2ba2a82312b86b03a20fa9298d04f57035719deb677efb175c55129fcfba6ee1b72f18bb5b3c3b413b42b59a737985b3a4aa06edd074c37a2188ac0062735337e830c75a28f7947c71bbd9f3c37514f44d015bf0d10700469eb838beda17340b8947631c288124fc3e718d506f09dd0f58b0977f4ae8be76c4e4eb710b15be25e3f93b826704ae77e48bd0147c2b1db3306923d8424a965ba6b821caba50fbfae7fbb1c6beea5276ff6c8ae08438bfaf03dab3359d0b797ad3a28517f9d2e6cbcf5d1562431384c21fec1550ab66a7f5f24c31148c2034c955fe12db50fd16bc9ae1327a1a18eafadbb9e860ed2ebb148244102a3194b0216a7eb7d4a9b9d6e2b59ae81970bbcb3dbc48f870e95b1f12bb1c115e34cb8ff9a00cdc092e08d1f8e138f44917ceb5c2f69bce81aae608313ccc4e7af1f2b5d0261f00f8efc676dbd8733f651c70093eb7c9f9818c813c99dcebc90ad812eebcc2b30472efb87f71201a4a46b7480536edbf63d51ffd781a1438e9faae79b356e1f223f7a127f4c681ab10d562348ac82ce93e44eabb1fc32e7cba9d4cdac168b926f0af10cbef4f059df1f43178d6ea48e04ad1ad8201b71e7406ffd93ad5d2643e73a16536ef5acc1928571ffd1203e376a6ca3a1d3765fbeb7a82d147aa45fec75daa024d05052abfba88ff760ebdf08a456d0aef07196133ca44450e4bbc028c04615f333619ade6e07b39311e7526692750a9d2c3bb6ffe2644f4d77075965cb02f5761de202fbfe00c7c326151197a71d4e67b1acb5db4ca20c9303f8f1b19ea80fe4f87f946683b99a30270105a17524b034b0c1473f165bd30f9ad35a7dad34fbac4ebf62678e90c0fd0480803a5f9ef02bd986e728563e6b099e2ede6362de8ad5503092ca7396a3563e1d76b5fc425134c6130e68842ec5c818f8882720e93f3aa2409d460c6a8563747c3c771cb48ec1a45de49e341ee5e0a838587d164628970cfcc85792269fe6988c20f2ea71fda5ffd82a109040502ba65d5c0e5e8119c1b4886ca0e2d8682816912cead17f4a3bad64d39a3095e23594964827b74ed1031b84fa13783df962177c6ccc1615793dfe5b9d5482a9fafb4a9b726ed26213596f1c36887d9ee48a01593288bd22ce70724efbda1831477d08432da1d4da887d0b4acad8ac823f8c6dcd3dfe863de493dbca126946f2e1c748d9b3cbd57c15bb0e6ac34c803d68bbff8f13b4656be4cba523cec77322a45c3860d838ab2233fcbea88faf71a944f9274785c22f8737f246562656cbbf675e2e46ba3816390acdc0ce83448759f0715b5e84e7482d7f5d3e579c8fb9474ed1034e74c456be48b3234502544fd90d7810b1600d961853d59e14a599c5c99b749573b9daf7dc4a7b6d2331f9bc895790a642a8c5be733f5dec5600799813ccdd983c7028f528f54be22bdf13fc7912ef4b5253ea33c835985cd7d2d2c49c6dcc8670aab08be4fd2bb78040d99ac018d02b93b8c658b5387c23854e2f643021f62e72c4fdb9090ea41f27b85025247265ebe1bcb50e42a19fc3c437fe0243d56e5eca0a067912158ae64b71479a3c45268bb912936779abaa823f1de7c5a69371d1b9a03c5efb00fa584daf5fc43e3f1270e67a65edda1a4b4279c506f21fc30d44dd8ac7c6ccaf9a2f7814ad68a2abee03ccfe258dfb5726b8c23268fd908e57a5f421654e60a518f3f38bb0c97310efb2f0b5b47d2898373ff42950715279f89f3bef59cb16b1a804f56e13c6ec56b2ba7bf37e5aaf024a582531dccd7561d9cc62fc97969b16aeab3b07b548cef1bf4409c7802bb35864c15162c5c6c2fe17fa15c08943e42993c681d8e23d34e670ea74778eabd9f34776622f49dca93589a030d03ca10cc685a4e17d7f6d75fa180752c57e326717956c7ce36eb0fe988d73441e05e4d5af942f96c69509393e9a7c30d4534aabbb78f27f853e46cce5b2cdec018f038f02045f15f7c51715819783eed8f2bfbe3d9cb445f0a6eba9faa519db7ffc375cb7db38b51b1027af7e4cfa0f70bc71480812ff6b74d9814d6befa31f44838635235f7df3fe70e9af29d7a272f24245722320066dfafd16209537e6026ba0869ef5d441c8a38c0a66b04f8ccf53d9af3b77ff154bd888074b52ba39b2a3e10ec0cb0b988b64ae61be8a0d47c63ed5afa942840910aebcf59cb6bfe2710b3b0444d6387762463d95f1e65bc7912dfd9d39e3ceb48add584b8503ba6baa526dbd9f1f4229d1a50958c25643b61d3f25955860fb5df12f75ff28c59c96bd99cc0d0ab4918a0054052cd11a66543d3a6cd337c421348cab9eab8f6a36909a6367748bce6079509225958e827401cc79fee77b7e60740ccadadb9b6f6917d960780ab03586bd38252f96389c0548b0a167919210956973619f4cbe027f029d647bcacec68ece217fa36e6b24225d9681655c3f4b9fec0e594babeb15ff34d192c4b849313c4462e710f86ab4366bee71889404cead8f385bdbbcbf31ef54413f1f7c36347a32bc0b7a5445d2c9c477896aa4926054746de14b8ae7872929894f833398208471f58185fa3f5c3824cd29a53ee3af9ac366d19a58d21f928f0c3325c294b20f6c03f8401d310aba7554330c829c8eeffb5f63c7c5490a3b80993b85eeb188f471c5e5ddd08bf771b3a19b1492632944525da267fccf797cf959e76d5896e63e3f3a78a90ed55e244ac44637c8d7cb59c7a58bc89b55213895ebab21842ece7ba2fee39addd195f38155749c03e8f40f718e5b31e88e0e9fe3d8aabd7034edfa7cb7446922d90c568ec273364b050520774cc03c0f2cc85a32600c174aa0d8e230e2b3cc75498aefbd252f009af89193f2db2a82dc376d840655b3cd0c6ae8cf68db08f2c666f4b94e270363b3d28f25f95f7918aaf54368eb8fdcbb229eea73d68a0efe3e488a8f5c31199698d894ac5d58fbddff4b2a944978a1f1b2be3d5fb2b1267caac4f1e017e3279f47bcc4c20efd20a3edc71cca7b3fca6d465df7c80685bbd1dfacce083377aa6c575b7eac1465122d898680f248485a2a2ccebd46fe6a4ff89370111e8b616841c6d7fcb8a8321d7a96a5e5ad3310d4cdd88d0860e3cc384ec88c632358606e08a370420808040eaeee5cfca2a931586d7049dcab701134f127b4a54ee695539951f696ee981918ca5133a1f115705c515bd8d53fec87c7badaebf92b72c8dbaab3753309a2f4abafb6c68eee2898a36004734672f918e3f0dfbe349ce3dcf985b7d307df53d72411df3189170c8ef902fb5f81653bc4afc3a78d447637f0c4d5ff088d6ded81ec67aa5a38b11d73c76a453017536d8f30c40f9aef447fa43ea23dcfd812fc994dc17a5152cdc2c8f62122d3034fb0f1678dc516ac6e52d6515f7c685437ccb93e9913ecfb23b773c7efca330e671084bc16c8876d0218a785fcd4236d02bc485cf71c3761221999a0084926967785966c071fa73e66be40b93db07d762ce7f9ee0a9bb07eaab39c695f7b6d51f7bd5d31b80944b9ca7dcae2fe414f75bdf7e5aacc10f81759ea748366594f2ff3356b9274e3bd1043777c6e94179f46dc7d7e96d2e5b788a5e7265fb11f97fac31dcd5b83efb38c2c087e1fada44436296a8a4f313672a398a28c93ea020bdc80e8d0640f2151b323c12c8b561647a4d40466b4784d3e6696ec67cb932fd3146977870e7ad92ac912142a38bec4b5a60f7602e48be8eea1e2f138fa78b860588ca4dee642ab29cb6ce866a224293ea6e328730a58b5b868bda59d2eb41e8f420cc76d9504a0fa35326af56eb2afda448a566ed3e81d412467cc2f524cc9633375c6c066a8eda9e865bc406d220bb8cbcc44a91a99f4b088e6e428680fc448417584a10701f3536f6dca75a389ea2fee2e843799b3e836549fb5951d90958d767a92e1ee48cc7cf7857fe1597db163bd6fcfff6c7d214410a525689b1c67be148f10652299d4a36bf4d828758adcb6883d86777c10b1c3e50fc3ada30bea4379192a66ef973e6264580d6b16e9f326d36774a5aa88207fd63af1e6512e9dab78a619c5841ce44c25f7b55660c5baae59681eb2642e8f3bda90be304dee4ef19a340aea662a37801a4cd2c969c3ad8a6eaac29f9e464186dc59a1ae419d8735b4a79c61bbe9b8b0cc4dd53ebec89c9615b436e257e755a806cdb94e124a0a7da99c9d2c4028e395bd0dc9a98bb4b01bb16217d4d40f04e2925ad16bf17f5e64f0d2d0df1a40985022668ac6a3abd26af5f8d1bff6775ccaedf07ce80dfff5984ee2ab282ff5ebb4bee0f842dbf96900f54d883a1cb1f8d3c7cb94fd2db948e49aca0e090f6d606349dd95786f112134ea7cd09a801fc5b290fc20eb7de52a71cd15cd5aa25878ac4b51eaf0eb4a97ddfa6dfbae01704aeb962e52532fcafeb8d6980466e18b87701bf8a9b3125a4351a25d3c4758f10a4bb586d51498c5075f7050f2348be1468a5c6c96262eb9a747556c576f6ca94b3eb3d6761c3f535f5bd55556faaf469af26c054a3355ee413f4ddc23210e32ff54da41f247251b6e71c31facd4b65da4ef5427ca9695556d0f882b0bdaa1b3e7dd307505f5c8202a6596cf9f83c8e9df9c7b27b3147fb30e3bfac8f4b39fe5b7dece9c7fd7966eae6de6becce8cd5496af42a272ccf7b0ef8dcadc14f94913ef381f2e6b7dab0c1910c93482f28dabfdcff65a4471077a507e3df13c1ef3f3421c3bdd0b0d99ec78f598170d376e47e2d5bd8968360fcabcc813f17a42b4d1432ada72252f6830fec707661d25cd85809a3fb2b03ffc4abf5267ef2a17080517ad48eaaa5d68801a0ab25924c8b9e54c8545df476e721c4d938351b83f90e58178ee000d41a4d693a005f9ecaaf98e494f9d0e4e24afb7aa938dc04d59e8de8177779c35ce0a1957b5eb7cfeef95657dd704a6c2f1e08b97664bd8ca603beab979b77f27b5825a3f4da250cfbf58171c63c31a1ce327cbdb39a5fef51f395a86c34de78ef47383deff16a93d34b32b0480236b18a1bb7a80f3f067edeef31f79116b04bc95df13e269c8a42f00ef0a2f53e39d29a9076320844c957684493ca8c0d893f25b258b01ebcc6a9554d2d6fbf7dca37ff5a66d5e2836023cfeae740392fa8af48590ad8718b27013a761b7d0202fd8c8c0ea3cfd02627eaeba8f48bf3c4dde1f424ea282fc55fefc4ac7cb9b80a45a62069ea779b1d19d6cd2d0339257238d693a0b81a4ed38221e69c881baa3396c36de0571a13cf2688310b40a3e982700835afc86798a691f34cefc4995b02ee2ea0cc3e39d1cad38ad1549a85e08cc2b877f64ad7b139138b7c0c661b09fe3f608f91aa4a8a476a6afe42d85f720ffa25063b8cb2e91a5e22ead7118185c2df5eb038fda685ec61e676784a7b239936d2d129c7ea581fe1d5b3ce926eeb23d97ad51361dac421cd96242d31ba27e2f12cda92d170f166c8c62dc290570b4cf25357f7babd38f51875f8c705450c6529081520cdc2c6ea8e388a65090b3909382bd654edc47e2f5b1867a1991ec7e7fb7dee91bc5db148c1e6a828da8bb754555135c1a8774d26daeaebef06cd052b303b20ace25e6250a67b2bde8510cc6df74f4dbfd5e8e854f2777f769ef3b58ca6172f4386e65bbc870e11a9b2d4c5ab72fd3af7ea6e336b97c19191a41c50dc313d6cbcf0a344ff627f106c3f903fb70a14636cff2ae8a922e74e8739851294779f20def581eab9636af91f1a00b8695ccb2838ba9d009febea98a7fbb980d263360b482e0218bc888cad846f5fe3ac7a95722dae19efd8d8e87ce58cc7577cbf6395492576b980e20d05241c640fd6d85359b60cbf3aaab0ae83d476d319e688d5409a0ecf551b8a383d1198c4923637e23b230de397ec34e35afc9a3d664abef669c418c066fda5b09862a2c2139c2c06ae680adff52491e027d261462bab8cfb8d65ceaec6209c054b104ce98bd37cd31ab20a66afbe82a095f8949393bb0ab9937b4101732d291eb16d2d713375ff54f5f8bf4c065e9ceeafda497cdaa926dda6ef9b2d0e98c3aa683a04cf61dc2b8f2ad0e643d9b49aff0054919c5e3d19afcd0ee1ea5810896acedeaff5c06021b5dbeb5a20560e2d2fb60030ac17b6767654cf299e37c7bfc1979e22effb6b323d2a34ee891ece267c3c80662342fe8ccc03d798914ffd28d56a0693831dc8abe44da7df85637580be43d41369876d0221a696e52f9fa2f27df667400b9ea10d0fc90baf01b432d8a8c282d4aea6dd6d931de5b6606abbdc8f153c63ee2a28c05736f5e783310068c0b95b589a3cfecfb132e305f476647bde4d3a279021587f9e56de56c36855b1a1f1b97b865289685e57637b0fc7c25f2f990272dc617762d90f520c310a536dd8f82e938d29f8d091c220b005e37f6888919e5303f1aeacd9f81385ee70cf36a9a299496c19efa51adb1b750ce31d2b71d94e12dcbd35c3163444526c39fc28314a4ec33d8c5b9233daf54b0579bb7b3068afc628d58a4b71af1329199e567e7af51bab9480bb46af6b093976f15b6f5960b5a268a39f4a9e3de5d920e6118594e3769b8b52157db9de8304703f446ad02b8dd1f9c8ad00b6491b5c4b3564285c09e7cb06a7fa0e7f4bf9bcfe45a981599b0b3afe7cc323b383199395461e566e7b41ca021bfe6f85d9abd5ece6e68167c1f667063fce61c7ca520c67ca83a8af89d87f04c4ceec6cf76895405bd9fcd98fa44f1d838e7e5a31e78008c40f2be402254c48ff051010d7068d702adb4b33cb9a43fe6933f184c37c1f9230e6adc15d76c24a1961805a51c3ab45134280b2ace5b550ceb669c8c4e76120fda02cc1dbd2b12f6e5e633a64279c5db417d5da80b56c9b7208e7198783391a557caae909348d2cfc5c919cc90f803ed7b8f4e0a0cefdc5834d27fe22cd82bdde644e1ad6719430a887719860a00839b0e1ab5741f65b460b85c46be1ecabb6012a0ee2b1af5a7c0421da7f7af8bc52244ea010be3bac9afcdac251fb5270495ea695e732c73efe60f255db17c7d58d34ec0fb600e0a5290683e28ead59d5004f33ec7a61542ad745d218d26386e5bd190e9fcebeafddbead27668494037acb505893d09e8fa0bc2eefcb51907f14ad55d47f2bb87bb12accf5ee053c1b6861c3fe946eccdbc06c73fbfadd366afb6f0fb8b37e2252eaa146356d4eb5ce90c3d9e106184827c3a32e1cd5959b6e144b9e312fdc80caee43cab4f92f23d087efd37ef4eb8a71e656d5762b5a729942fe3e79b86f96ad35778c683c75e2bcc2f1d3b7ab1989cba58ec823f72ede742092e2b3c9690c8b5d4f64e1c454cc5ad4c581b5278f00f35af6fa113fa87278d04cdf4a8785c40b6e65c3081ae4d2f51091458b4bd0552a6d437afb114c6ef8b54234dc4178468d2f0cea0d2a558a259fffad9fe9ee6f26f089d904ef56f79370d6c5afa407b91f0c230073dfd2439d8f07e338bddfeff4c0e0994de6d494f16c660fc5a5ec1da0afdcad10e3bfb2be80673d806c65c5625fae3afd144f530273e0fccd9567ad107f07b409f45ed060c2dc1c884f82ce18156772b987daa902fb85b7607946f4134c2048a1a7ba5f48d0a17cda40e4bd885b8e2373715b47fb1cfdbc160d4c3c9b6db32372cf55ba277dc6518cc0f19da408f76ceb278f83bb0711ffd973065fbfff3780b3755679df59929b125495235b42b61f7e9ad12f5b73141e596caab8416cd95ce30447be77737e260c80210e65e07dff1134c3aac187f2555ad87f04fe3ea6fd72c5274dc6990a9ffd8fb56eaaf448f7587077acf98de1dba453c30aea3406ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
