<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a01aa95584040f9525ca2fe921fdd494cd80af0369d007b413224e9e90feeda8ebb30b5089649cc6d5b8953572a4b1043e57134f280b8040d31c3b2c39082b38584cac3ed593241b343970a7567253ceb8302414fbadf53bf3490f945c43cb5ebc947ed8225fe77b3d07a0c592e1a70ad3999ae59bde5cf21d7955d125babf7de1203f213e4f5fd673d6e3a67aacfcaf2b24c15633a1c0e1dfedfd8e02de15a6726748205ce354b21a862f79dbfbcfa10ab9989e24addcddbbf9390faef3934e481c3b1433f28aeddbfd3ff5179a4540debf9e149bb7beefb9c09afc9df828845013deee1d36f105a1354223174e00bee3bacace32ec28f6719fb9310b89f8b09613ac17a24b3ed9d6f0339a0a1e0814b824739e0bc1701014aeefa325c65355c3cddefd76f04368e914d72aa88ba7bc04e28714820a7cbd3fd406dbc2b56a308380f25b8a817f8e7a534e6dcf3cadb15e64af56fc612f0fe1670a38fae82a3d85fb77c1540713d5368ef4cac7080543621a609fe92383c7039668d090841e0f1e8a7074fcd2a7bc9d6ffa75895cb20b7cad7a31b462f64c5cd39a7e905f91029a128e04f49803cf4084391558eb21432e74a4992d285ba1a195b97f034c5c51b25cccbf87feab62b9f47792e69d574cf9cef9b1873e2e176d529d4e6d921b93a533e808a5f777a6d99cf4fc52c7860917efb62a381e309f84bae87062e3bcfa19945c44fb91c6fcc3f3218898a2df0573e174d113566c27e80983f44b958791cef577ba71ddcbb7e3a9a34972dfc037f9901dd93e424cd6c58b6325a292b5fef6501b6adf7979541f98069e8112a99150192e4563ed7f0f92c009b9ec877810d304dffa7cc87b9bfe878b7fadbaa6db2ca6549f664145ab9a399e22543890b6b5e2d4dfa2d756183b4ed17a1fc1e2bf1316135722551cb3e231736970cf637036d19880aa3e693c4aa53e77c62e5ea223e9f86912ccddc59e4e1545f7e6d831492ed1de0196afc2a95e1e527a742abc2cfac52c8a62ba3769b96003d8397f82cf8e64d27e91d3a5d7db9bc072ab07e3d8a97afeead7f8682e637fa1155a69acdf93aab6202f0f73851600a0aa63d128567989fe2fd1847829d4dd6a22db5a6df18537de7ae0c9307da33cffb417da1ad372c82c87dcd65c98e1cd3ebe9ddb5c1313b6f425f1588d4c1a2a2599d0074a6666b6421829bc7d4c2e72654854660593e3ac79067880296259c63496344538f7197dadf117ce36f9e72c81965fc09ed08ca9e4e5b414b5debacff6ffe056e03d2b25d2143f0cfa76791e8787d6341410ba70173df7186295bc454f4ae7838886bc3628e9243c2c32a01117959efed9456f07dbae9ba2aea086dacbbeddd3450d1857e8e1b30d70addc1438fe8aa7992f0a619090f6772243fb6da60d26791b5f490b2225ae140bfce95dc5c602300a995236f35631c67162540b9161580a8029cfe8b830b5aef8d1ee5e3f0749ebd62afba2de48bf2d8000a86452a246dfa2b8525930ab276604504af3e2d6b6872d1010c1bbffa5c843304436e346a27768e217bdac335dec8cf756715afbe84bd080edc1c1bbb1865e132fd1ec32a1d6f2d24392aeb371cd2ed2f15c08310e23a1bdbca1b008b98c9bdaabf8e0df7ac4a52b11d502485ba0675bfb12874c02e35828efd9fa32166c951c96cf7f06cf9c1ae49ddfd9f1beb004281b8f8cd47b194624e025d517b372ed0e8316107df05d30ebaa419406f42420fa56a84260c359a00d5efde9b32d63bdcdd8cef5a801e1cf80a85940a64700b5056351ef66ea91ded892f63e5a64da14126f76ccd80a034dc422d4c660610dda07fda54f66181dd57c224e58c5414b4535343fbdcd1337bb1d1f90782b01fab89ca72569820f8ecbe3591c2878864d88f2969acaa557dea3a4bcc4c920e51c011899e03e2f2354b04759272e4eb3134b2c9c3d054d03362544083f6f6b1a97f530675efc664127edb99e6e97d48152ffa202300b7d6d4d5351a34a389a0c434dfe71964b6247f8276d3ad091dde37226424d98da96d887d0a571ec3ecb5991462284c9f489c8c61ea1ebe92df41cd55d45947da24840f7fe9f6b2a90284e6d85bd37e042d4c9f0cb375bbc278d86a1286b4644c6f8e7156e694295a60901e17a869571e3aa58dbbfd0282b2856cebeb33d710fe7dd6610cd34276b22f91f78ef2004b6ce438b7154dbf51f0ccbc7704509d53fda30243c5a7f68a7c201a520f88fd434a85f10ef9a3a0e4914a6f3176d5bf33c02bd5d06eb90f3746d1ae83c78a2e6b46300cdd016b9f2e962828d416a8b6d749b0ca010aee5ff42cf15e8468a0b28e09775f1d63403557c954414cefc56cce79cfec6df39f5263d3cf3c32f6a31352017439fb2a4d8f91d4f726cd5b27fc95b916ee9688c3e28b2b06edbcf79c256196baefa7d729056f113ad4dc1865f1b9b3f8cbd818c1c5349588388368a7d40e0411eada6572b3086a6a75898e80fc2b958ee88957bd77bcef437eb59acf34afd5a87e7c3ffe3a9c1c5aeedf437b30edad8e750f13c4da56290e798c78c29bcb0e5114f92472edfae5e929e16de135823278ca14f1b71d65b8d521a72ddcde1d853c35231e7c9f301fe68e81628ac3e19186579247e9cce8a972001c4e5734da52a88a076d2b916769658b6b3960845e7b42393d251dff55a7c580a9adc40f78ac756ea50f5b8aa01255cab64d1021f7fb71803287d65707c50b1c0e0b85b6dce483f1ed476438b22cc723819fcf5d24079d7b28019ee0d430ca6d0265c56f1352d121973ed70cd58fc8182be828916a49454cbf7934e23254d654231ccac6a0e4550447d2b26f7aa8cc8aabc43493a81a018457edd3080a7adcf3dbda95b2bbc0d20e408f6b7558c0da4bf827c1cb3279ea64b62fb058ba19ed90cf274a42b03e7e9db08595ca673b1f58338102c075ac6555e57d838ac61b56fbb5ea868cf133d14efe2b4cad64119ff1c564e58b37d63d5eebf2c7b645fb19988f025e062df2e3996070c50fa9167601ab4f7a930e0d8adac1c7ead4bf61602084b35294c918c1ab4e720204dd873d7f497aa211417a320cf791cc4488a605d25356cfc7f62022754e9c88d67a61a2b8ece371a140e9899c43929a54cddbcd16f6ae44c112325b094bd567d3169169a09f5c9b49e653bf790066ac630ad190a1a994354971cca84387f03953ce3ade6c5cd46bdca83c8eb9dc8fc0e12de9009c8e4b094b6e4bc92ad01f85303a66ad830fc1d62118cc6e9b708af205ba2dcbb4c4959da6270435a4ff36b29421943374921f5a59463e70281ef228f61f1cc4a255b6c495dbb868a2bfdd17b744935fc1a37ce309c13cd10754fa729196c4c21cabcdcbb081e1e529d5fd068b329d6c973e8e50ff98c1def377b2d9d67c2d939bd061362c4b3e9939371948330be1a24f6b26ad678d23483a481987f9a000b6f5025d1508fb0e1ca8d811537136313873100000c8a9fad54ca5516bc78859d4eef0406e4980dd8ae9b7c40f90b2c46f2b251bc81e8f675b2d72d8acf92463e5ddc84434f8f5fc7897880f680218555659b0536748ceed2508efad09604a0a53a22af999a1fc01341a7d41ad6987cecfab2ee485f91e2e4ee0371ecfe245d5b90b9b6b35757e17c6e6ddfb31ea00f88f4c4f4891c7785bc7070cbff976504899166aed044a66b7d1bbb145cc150ef94d2c2250327173fa092166f5dcedbefd4e6839c399b39727adfb2f33e839c9f54e8170de4e24c50a3292c1aebb8fe9dc6f395e98ee678089d19d8c267590363118fd133892dca5ac142b3786a17b2935cb3acc3d0c745d05aa915e33272d7299db9ccf05817d49209db9aff9a9a3e355ad7b92c82a51d35f6bbab3d45487bfd03a520cd3181254c6ea00dd5569534e2e4fd7d672e79f5cc1f3ce5e94cd70b558d39d93f0795448990a5b9b84d9ff346ea14a35a3e7bc35767cf853c4d2d706ece2f99d4b60b0325f5be153f1726f6f6968239ccc624eda41d0741dc9fa98983c99da9004ceea9a3485c52ea61b645395bb72698ed28725b29b5546a26e1beb6332a3de6ffbc7874f28a74c72ebee3047fa315c7bb68d642594b50833fadc8a6b531b82612a6c41d84e3680dd0f9441cf34e54da0bdb86b7975bcbd6f86fde044f73d55a3b9a5760621b6186378077a0e44a140658ea1e4c634881368aeeb10a39dedca704edd40d45fd74dc6bbba5af457fc68770c7fdfe51940af4e546e3993c73f20c4c7d65d757ac0110b07846c4ddbb52a8b57b28060660b45d12d8606dbd19cd205fa79b0b5f2fabbdb045a59e92fb8ed13c5adc2255db1fe57eb79c674ab1f8024c7923822986edf07b001087d666137d0e211b055e004c6380fc6264c5231e4019046cec889480025af915badb225960379b603c1915caa46be80a93e9c967011f9bb0bd29612caa97d425dfde8e7f0aba0ef799afbe0bc87d6f2efe494243d07e413aa68867df00fba9438476721615bc7cd0b0a70340f51f177150b49fb0ca4d7691b1263c654efa8b0ea477fb8fbe155b908211db661f7dd658aff5ea0f3a06945722c639830ac52b3fcbc1670eb283520abfb0bd95b88e08177da910835d4aa77f4c8a3fef23f8c9360f432d03190ddbebbbe544526962311d84d7c2ae73c76cbac1db45fe647026fac9e092afd3c8b8ee6319097d42dfb7073ac21746dd777d863eedbaa269155b97d79c55648fb86a188082a31bb982d2b31534d1d07b55015e1ebed3ac17e4177c79747a8588236ad896e6dfa5380a20a37371824ca9947d5edaa8dfc6dd94ced9e5bc623650224fab414e030511a4289ebd391cd393d42d479b80b08f85ecf50e2232115e61b8b1ac2f53216c595ac2277097b231d8f7c074ac1018af46d66d65c9fb81411427ec5a6f472b11f95dd098783f45266fc26895f65bede4f73fdd375d1e01df731ec935a95be9f6b9ad1abbe396803d79e9fd18dfdb39044a539f0f1e1da9c993e29a88bdd0fd4e235e15ba2ad1071fc1eb1cb53a1efc2e267c037a6b6b19736db163c1ec2e9acf23520a85a08f2bc9bd27a1b85c94728c9a486cbd86e197d83d1f6fa5b4de895c006be0302fe61e302382b09040f76bb0b65803e283e64adb45b96e54703bedb031c59d251c0d6787d80ebd5b422321b13ad93175d7fbf7883a21516cbabcf5d23d50d65aa5fa5c483b3e553add156eb1656dfa48fbc65b28c89fd401735f75c331adf2b6d00b1d27fa0fdf09fc9585cbf06040a74600a44164876c72c224422b5773eb213e6329de54fffe4a9323b979d39eb5a642a42dfb4c0df8be2363ab8e22c40b44c0aea1cd0c58b8f7adaf3f2f452dfd753a481f1c4a22d633d9102b515bfba181e5cbc2dd8d47d6db7dec1d37eacedd1c41031ff17dd0167d61bbd9ce93e8ca3564e66aa0538e6677810d4a12281b76b5c00db8a5875b8caba7c438a7f8541c9732a4504175f1d872f81274277a96c7a3dac280e8b8eaf8f537c401f3dbcb338923f5e5ef27918e382965bfef228e956899e5e82ef026e585638431ffc72b78ad553553b2d305550e8c2008b1254f0deb9fdbab633dbc0c44e196ef38d32cf09f77b258a7b069623793a0e3f6300af3637b61989033182b961219cc612127f6f7e028e3dad82f328b4869e51a3c4d2c715bd1433253d6571564b3fda9535acc47cdcbf96a653a09f06e327a90c318e8056bf5b9374032342dd349ac4a24c7fa71f2c2f544c941cc119bcb6e28f34690c43f8d905a75194878f606bdfd39a462d4e7a80d6c70cae712f8eeb088c9ea08244764160b2efd9e1d5c5aeb118b35e52ccceaca40198d34a9c27c2a31d254d306d3afbd8447e9a1f16614253d5aaf8d61ed22cc51fc904c68c95964a631ea1484e620d48186787bcec6584a77662de4fa25bc8162e80a9d4bb6a4325cdcc1caa8e596879e1cdb26d01923c132fa6aaef729557cd0d58be5c4b987f02e92c5459efd5ba696b7c1025a0e6a25e6a2e20bc476591f75b2c5a3fea91b5c630bebe97fbd575a77d18e4e2a457b19ec2b1001209d59551e2cee953182f539783b08c0f1772ca8be2847fdd34a960065fcc9b285b822061fe54d82d84d940edf6aaf8296b694f5b681b574b403db71916bdaae7078be3d3dc21b42b73c433134c2c64dc09c889d7a0e5c74d4aa26ccb7bcda07ddb7cdac878e13dd5fdc1e8e0d7c70a78f794f5cba124b81b34f6218b2ee29e845be67bd8ac96cf5d0a92306f062e12bf598a3219a1e3318a4bc8f6e0e82ce39fe01137153ea2cf060df61ddbaea1a69617793cba943617b5080a3de85c632e732b3474f1d286cfeb364dd19a3296956270ad795e818ef40a530d3c3ceba49e86a9281c68c7643ff6d34c74af741c38998a309f7c3271003b64277a0e7a92613565333ee0ec7aff382b136b16425b686979ca0b657aedab77a25689e36f20555af2b9bf95fafeb846bc76ecff321b0305d0faba55f9493c495420a0f17baad604d2ac8cfdcae448dec02637952ee9018453749f66e48f2a8e48510eed2f90ca9572307b4722a0fcb9286168be6bf74855bc20560e19a2891308b29b0ba1e7bb03da6e37c60236995b6baec05adf02d34a4d703861a713d2e44fd82daf0aa921ad0c14585dd459d5bf0a9442e9375e584040b3d6cfe072580ba886e29257bdea2435c7089d1897c150bd6cf9211a840f5756e5abd2ed2bba59f293b9422fb1615beb5bee9e4badb541ef66e3cb8b4dd79c43f45f1d025846ec186c86995c9355154216fd4200e6f65586b128df1f0ea38083142cacc55fdd3dc4008ebbc76fe04c859778df14fcf8aa55849714634976ff85aece6ace23ded11f2c582fbd1259499a95c374af8734abb05fc7aebfa94142c11ff4f6181a0ac0e9ce341e97ca5afd034bb4406d1f93206d954a761a23e451380d47d11814980bb9b6e3ecd1518306c9f2addc9df97711ffd3caf5b25a3afea47719b34a893be62ae08d9c4102c80e4a5deede8d13881f519bf3748c5dabbc9d042259fc966c8bf13662386cc91c6020f16f492785394cee93f48c629d409b84b30632bfe95efa64dbd544f318eef3f4af564c387a7fc7f165c33af0c2b9947c69f46facf0280091596448506d2b1b7bba6b430064f1ea8b8073d52aaf8bb4c3f375ea7352716e17b89f66ce2860677799ec1a254bcddbf0a0e77549f08bff526e8be6044ba38f682c38e9357d7e2cc2d3f12c0bedd367ae7e0b42c03147d70759065b2c14563d461ac42ff8e6bf7c0131cabf071ca073998ff9356d2244aaa7babdc1834f34c9b085d124ccb658f8a2e4ccaae32e95881896835c1ffbceb8d6fe39d066338cc87e99bab51dcaa059b36ff3528bf2ad8a47a6b8a4fac0ac0ff39b2b9c7ab8758c32dc5c2300e33458bb75f460221e03500669144e3e077a9915649877b4961a711d7f1dd3234d3a027e1a75c84e1bc4e30a260f3f266b1e299d41f5ff77b34371d66822889bec2f429da916e74e67f7098773ac01e2b04c06cd11fce885441f39b25958edd7be330857a22b63270132678f7ab8ab45961321fda5e9fa20ef20b4c5be2098696b55d0f76039ee2b66a8a09ec0936735195efcf91f7025ddcfd0abdd4f0e95710b35e469b237ba6d3119114992b40769a575be7454921042a960ee55bb803a793761434a1277b59450349692ef4c983e3e7e23a2d1bd072b1bf8af5790f4cf9bfeca0b9dbdf20ea38353c71e55e878e16daa7cfe60979541c64c9e1c87027384e8712da8beb88761865e41bf09f64b57db51574875db9f7218f3617fabaf15f9c027d424bb8d4e37fb73850168ee24a9c02c22c0493e773fe6433b2f60c5bf35d71ff38de8b4e1746df4ed77cfda2a7dad934ad7297737975805d99823e3105768f1b1dc685fc25b7bc87925a64bbd726439980596931a90c758070fe6bb8b479f560ac34f06abc2b3cf5372d3f7e1cb736b65768eef11b558c0fa0b4dae288caadf424130e8172b91f37349958225161a5f3bb194fbef2da37c8961629ef4c74014a7ca02687b8a8e394b7902084b8a4247f332ccd55083477efadf9d1ccaf6fe92e95fff019f29ea26a5b460b607e40c43411f677954c5922b66821d602995df7a6ea680cd99808da2127d1d2fb344d398bebd1fd16006a27d983879c62fa9ce27e3b20e361beb466ac16b8a0e4c3fda8ab26898281fac843291449cd241ae78cf28abed40175d48784c4e487f273207de24bd04a02d3a7ffbceca9845f909e82c8987987fe3bf8553da4bcefa6cb5229231b491bc82c556c9cd3b9c33d846a85e2ebcb36390d595a7a5457191c9cebd0e576c72e0d0cbff385fedbfb0aebb9fce866d5341db98ef6c74bb15f01c3f4886cb3e170086da47f4104cc4023241fe17f6b3140a7d30540a99a307ba4de5a7dabf989d2d890514bfb9d059370ceecbee83b513c68c9ffae5d81edef67149671af627d0dadf4caa833e2e44017c9d9c5ed35951ea30ba06715d5170ca91397a360af553af2936eb261a89cd17eaed824375f894c4fa0ea4625ce5428114fffe323f92076954d9730b01db91934b018d0fcb3ad7c6b7582d812b0adb9cf5666f38b68a81d39236f04929b579aeb27a625f71483b0d642b1a22a8f9d4604f01e1f298d1a9fe82d130e109c4d82b34f75cff9b9f90732cfac7083d2dedeef8d6253225af2d4bc7a6669d279695dd57bf56e48c46efed834ffa55498830859a592cf06590f7284420e7369055519ddcf723dadc00a783ae74e83b023f6322da88c720e7ed52a135a9f0af2c6b34b579848e72503f96730f4c1aae597d93cef5bd3be751128244b5ee99bc15e9546d82d385788c4d1aee6d3c34cf186aa91e415d893aaf28a26e7e514bb1cad4b7265919b1d88dac1655a1ab75763b38bb851107050955eb70e2b8468f71a1561144704d6a5ae0d3bf7c8fa6dd5e92b28bc596e61e90162289e1c2f239cd0353a44701b8690ad85b96a06d137636e2a505c517c2fb8383ed3f34477fbad945f728a124b4abc5e19f5583a427556c5a97a30d2cca649e4ea05ec31a0f72f476270b8043b3d4c97a0ab7d7738f2912ab977582c72f3cc86b9c24a2301c05668e2b371dcce7e58eb2a807bb0faaa84d577cacfd8f50056bd32b00d818b4763cc1555dbd0e9d9c1057fa3da0e26530d267a7310b34e9ef9fba920aac9e4139abce4df94a8aedb5c62e81100b4ba09f2555b913d2f81dd6445e9e0b59681f140fec3114ddb8afeef8c53b547f56574dafc87d1da24d8b2c3e5d23cff8112b988ba1a8cdf43b702a000eceb64a88ddc523d79d3bf12972e69234cd2677046ed843f92dc9f7f403513571f837d52dd0e1812ac57ccb6f288d5905edb7de06bbe13e809acde889e800f98721fbbd344a331360790fa4a91926e409d094f3e35a8c739df6c90ec086d3e792ba7ba17dc3541ea554ef0d8778dc3ee8341579b0ecc9e0bf4ca47cd01f968e66aeaa25babbb26f0841213b95b87730e844769923233077f63d210164aef2d8bd6d28157dd190fe3789ba9e37b590cdcd3ca229484d7aa22380aad98fe9741620b4dd12e3b0a61e9b69a4178154ab54e92edf753eeaa9970cb4b2283d4158516e4f497c18d39ba3ec130c4d209f5f2e8d691077794cf82065e8f0b71f0480eeb0282fb982a49f80c9ef2e711a79828c709391dad7d68485bdde953e652b77576fc9d5ee3f01e05d04d81c115ec46910df229e0244dfdf20a58417c782116e49ce8a84ecccbc7e372e41d55237f258f102f76636fdea09c118ebfd5da84714678facca0705c5b482be3f5fbe5594f3a335f9f183701d20bcc991dafbe47be43d0b28b74beaeeffb1bb0d5cfba3d456543ab5afe4d0bc0c43469908057e3bd5a501671b83db1a2d7212058e45a4259ddd5736769085fafffeb51b12e03a582047be6aa162ae5af42ca70de7264195e2e29618858c9a0e82d223998cc2e3a75e6c7b9cffe842221670564ff895d2638975b0c8dd54813950c2a5de76890d7e5865b94dc488fbaa719e07f528d91c016b1509c1a3d1fe9fd1c014b3dea0435a4e3943dc42f5b79730f34fb8949fe6f13e6de74be5998684ccfe01d45bb82c5c094ee8198a360554cbd47d293c13f77c46560e2ce454652e39f1af7f3ace603d948865336a8de5e77b60e3f8ec7d7d4817b774bf14b60754f736fd9afa77721b8a6149562ff447db3bcc32cd504e7ee25059c8de62dafc30b7988a2d7471a946e5879c46ce21f9c61dea5a1e43ab5f5046266fea76865bf52afd7148a3229858d6043d8e7c3876745e012e670dc7659fc6c74439c43c33d9e57ed205996615979855289578ae0e5e77aaff8571b77e2a7cd619897f589cfc8a7b40c7bfcbcbb36782e02aa4a7301b3079e775df300684b63c8c9c399a835249c1166369daec4f8e216c7238cfc4b192d5303bc054ac6403bd6d6935df53539ce23bf6ce871724766ff654e8e6e5c9041a78172609d95f0c3c6b2653b1c67caab82084d201816519f463d3fb2a566718fb946280e366f88f53ec53b1f9428ba3c8cbb7e285a4465d6e5ced86815e0c50b1fe3ef873c5166d0c2775a0eda8151a1f2adeef07d29c68214784ff4318b67a5848e6ddcf078be733fc942e4773124733fcf4180bb8a02bbcd2c061d58b72b1e9e44a5190d9e2f0f20286f47ab2bbe5678c772038150d749ab3b3bb629591621b54e3f3f78c56c26083db8d7d780466106b1a8add1848e784d35443dd337540c3c6e7acd8559aa4f40c019ab3c52da67612dbf2763a9ce836396d140f25cb8d597cfa7692cba757948aa69cf4487742801ccc0d19e1466030441a941902c1728850d8876aa243e4af17517e80430a13f7af47f9cbd9b1dd2f4bf5a4210df9220a66900ee490e8bf4e27aefc413efb837ce5a1b31b289df73192e4fad2341850c92f2c1e5bb5ce47362f54ef43bde6ba1d992a53963134da6b0ccc5df201a6a8a93c0f7706fe6276c863c2265e2e9c2fc1cc68c736e36cf6497cb46e4970b274e0ae1155d8e3758a904efc141409d5bef4ce58afb4ecd3595ed9ebdd5977c793443001baef652c84d5969043c5806dbd117ebdbbae89f238e6b081da4623de1e475dd1b58bb25497cb0cfd7a8317cc8e74ba1da0de8dc8a660b29462627478de59b46c9ef1ce0e2e883bc5f6b68b9aed532c11066300fefd962830d481adeb1f9b847fd24571a8dc5fefb4d3ba55b3d7886b36d39955b322d0567c0da13cb2a732246b1ce4f383892f23aba2f26344ee275c5b0d5452a9b4b9b5d3f88b9c3fc4883e3a4ec76d4d0b438dca3c26ac096f948210b4c86e4f5d3077381d2bf23dc969cd6ff0b17a63c49e721e6fd66917a7edd620aa2e18206f67c1ad8e5134594dd9518bc67c582e29e3dca3780d0468ea4d66de4e9aa734807e2d888662dc528f30eb8cc1ea84ad2f03647e7dd2ccb9adae6bebae673296e9c250c61cde3172e6ebc66821711266c0850996bc77ccfbc1d0392c94ac2ed242cb3ad5e5b70353360392246feea348fe073b56141a25d077264d7651f5a28b9d6ea9127e26467c06ec74a65889b30f090c975499d69e612f286990df0b373228399c50f49ac0ccaea7947d50d5c1f3c416ec01fbb21e827e08493af24f900e1d836830b1e2f55bd6c4a56259d5f2f1b0d0ac1869387188b466dee8e2f02b3fc0164a179d45e741cd29fb3d7757260e03be874230952b0215f18aa036e4ac46eddcd171c1cce0611e2f1e5ec640eded252136995034687bc0d384fb9046e86d81b9b80d6c8f8829906740271747b456451f32aee320d972817d96dd5fdc6693da3e3d48b3c7a96bae0c3d1abb48b51ccc5bc568687385a56fd55f7b57011d0ef394b5ed3654e0a286e8f9c47f3ed5a1bd0a17a016fc45ea696918fa4c1c6ba97cee90031f7377cd02f545aea1ce083d02c38c032748b244e1cd9e3b0975feaa12fad3950b6dd1534eac5c248f0dae8f40934cb153af8c6a3415d4d1e27859e596cb4d3b0c2dbf603e19a4808322f6084da28f5cadfcfb43164e611523a28dce8dd8014beebb46643e1d2104de6930c0eb1f0f584b60608c2d97084869a98a3a08cdd25a1b8a0ac74079814748d42616c112cce0d1ca9862f0d6906b88c7bc0b81536329ca3f594143744037cc26cefd0e483040eb29cc6f6cdcf1e5121fb5bd13123eb3b7c7d703fa25d2cedeae4fbc781a8849298e3bc7d5b1a779771ce5bdc2fa560fec3be93e5ceb2931c7303766014bb0be7a06ed425d4e2e5dcd45d48185246cc0bbe0928b422e23d7aca0080e5039971c62cf5535184be23c0e33ba5d5c4260b3e8727f9776e729554bb3113b45425c103df4ce2158d296c1362defd2bdc519d07892347043b88115b375086e902a2742111c73e5931ce4f3dcc1cbe3b974c4ee69e0385d31871d444422545d9da4339070f7d63ed05b9bf85f0980742c48e640cca8e8cab5890860dacdbbe496957a8b23dce65efd774e5437cc228c3bb2d4017d9d377c179402fe29b31f6bec451951b76b90708a9c89514398617b0cca676edf6f1e7cb54b451c346ee775728267bd2de98147d156480fe208ebee91cd667be0a4e4b0063011fdf8c4fb6f5ccc0bdabd843dc7f3d60d645e28f4f5c6aff565316b73be58ce6fbd08cf539c9b882a3dad0c92cdaff7ed183504eb3c6ca90db404a4cd9e0ab49c303c5447865c7252b93e0bb5e73066182473b3a1c9d9c9f6b037d4fb344f00d6879f2819f916fab73d9fd7211abbe921559572e4f97117b1cd8377a3864ad1324a7e011da8844447ff9e93817c4ac4848b0c893f38737df5595563e9adbc4b0b38fbe8ef0abdc4293848f818b3cf2fba885991086448ba8129b3e154297b6f3b48d3aa96c4a21893476490d6e4c0fa72034c0df747493f23892aa3a0f558b7e353b39744c4a1f5cbfc4f8fd88e573427f686a0725a78d00df591d4e3ea59c8e6014063eed6bcbedaf7c7b3b12ab64fe501adecbc08443f3a929c992dff75b583743a715bd508bc8b722ff938a2ff75c09d9129a3364a00f49a2af25afc89c0b63113dec0606e3214d239d9cf2eeb3f992d509aea5cc94bb1812a76ac8152ca3acffb3a2b82bdca297b931b4e38699dc16309931bd9ecb4450a78a40436ea7829055a7e9b263dd35c6b29b72e27a67f8a72a55a2c8be56e8167bd0f87dc77a5a9cba03f39993a6f801f5702d25f74de81e4adb8bf059a996b453214328cd3a29295e3c9603df6502beb9e0fe3a00cde3c02e9782b306ad1a4785886a77647a701d7e8bfce60c05c894a4d4d44eaad459ab495728b383e56bf70999346adad8090494e182719db0c49a7905105a3ca84de4bc80fc068c353d37848ae2ae72c40a991fd1738d663578138c7b73d33451a132acbbb789ece3c7a183e7e9a6f28c499dd01465a03f5ba7b7874a1dfa46ccb9d063d93f14fc46c70e554239382d93d1b744129ffaa6fdb7824721293dd30c2ad092bc5a3b655907cd98d4b43136b3e817c6961d4bea951caaec4e7723558b22baf77a26a4d28c451f9239ef95e814279f4fe2ffb57675a997fb6fef7ccfd4816629f089c9dec85ce250ab83a8d53d5b5dc391d0cb584c356849c1c63dcf7c0d3dd44b30f66200be9522a1069a94fad8c6853482bc7dea18a9f3323d0ece78f359c29da3e3736741e3bc19f2de93aedfc93135197924753449ae1c08e0c27ed0ce6fbd8b00697c78dfd6aa1441691bfddac16977504be8439ee66784d506bf80d94110fcc1e2296768b2e513dfee37f4ad8eaa27bc5501a5400c6a46be29ef3a44b6db8ad65c8d1ba4a8d68b0ee0e32fbed63cd78606e69959a963f0905320ef94cec64d6e27e822685e47bd58da5ac5f0bc951b183044bd6ae400dff95563b41ffa2135186bb3bf649b8cdc27c3dda10b1636e5efb299d579417cf051e250116d7126fda245f394c2a3c4c238304e1ce59db47279aa1ab834ffe69a782c4eeb9f12fa3c1d917ebccdbced00fd0049ba4acad972c680408503e606ab70d9560e00ed5c06ae952bfd3d371f43212a625d7700b10b6e5daa5fcfda3d48363e3339f036aae92713fcb6d8fad2dd8201e9150f5367284c99eb32c18ea32e811684de98389520d36bbb74fe0740789330c7e815c24edc05541787d436b6fe2a16d371e2c6cf5dbf3ad05eda48f8329eb86248924da90b008aad019d3845b09473d0fc74384eeab2831426f968cc63ddd717766374a045bbe00f4464d8eedfcb92b777f23af0723234d06ef6bc35a5fbba292c68b62137966178c8119c1c04a08b075e4a1745ff0abf713a2045dac7b66775cc782e8aa45b402a0aa9100d192bd1dafa7dbd283beb30a6fce46bfce3fe8c5b8a4e138b2ab0d0276d6a7025dc535cb21a04ac832fd6d0d4f833a41655f56b0641df4a3c323a239e848f0857b741ee9de0c5ae996415634fdce5e1ca8b00b8316a755aeaf57a70088e71edcf207066958a8be2c69562d9611ea4d4d2c99eabe9f798d1b7543af17c9ba9804a0ddc893829e8bd0118cf3c86fdb60a54a54787005c6fdc4843111bc2e7b42fc3bce4f7a63980a4b552d2a78b2dc8a8b1c3cee2d09d7dfa329a75d326fadba7fa7be2ed2c8e1daf79f873db2a2bd301100a7b61e67dbce6b7f275ab7c97e62daf7aac7da6d819cc470cc0b33e36a7511edb10b80fa9c9ea8804f686fe2db7078401b884e85df29d81a90ee2c73b90a1017427da690e7a982153254b1f35a6f1bf93d6483bb969c47e87bd47e951b26d883a15f674b7e4117495c29685d337a5c7b9fbc86a677c04a0879e008075a418991511f010d4ad74cd47415e6d487b273e2a6fd167ec1d334219908c7f966a7f9898c0e0bf84ebf4cc243e29bef35d3978eb6cd961677df70e3e9ad8ba3834f236e2ea38b81df3072d9fafa27846d95f826d55e050cddbe5e474bc0df6651b01fa766809ab1ddb69ad43f28fc146b72b3270e080df054fb8d2de861da462d866a455cac8046555c717c08f821a071fd1f896db1e767c97068e619c8881540e8a10083330f452524275c33cb074e51706412de89f6b2f9993a6787bd7d2cef4b3251f17bdef6895536fd0d709b9468a8421d82755cf8edfd2a0ce8a5f3a68443e424aa50b0ff3796ef95e5d2cbeae9f61acaccd6b7eb22e64c0f9e2b7485f3b0ac046f1ab189c545f7140858c4d118b57aac90f0a6522085eaa9289306b9897917fe284c3efe33a83efe18bdeec117d18e932f8b84b0d2f411e8ccb21a60c7e90fe8b58ffc949115814afa75653a247d28a75fa164733fbcc8f7aea97868f15b985015c33fb3a44f19aeff47eb52672d0c5d4807841df45075d238fc2e7739b0637e0bee88b123805eacd420f008f261560d278080202c5e0ebe5ee75fa204ddfbe2ad682b3fe8633e8abea776c81c4c90738a3f75acc2b739395fcbb60bf4c05237a9e3c621b8912624449d0d1d506e436d6f93d692172e87066f178c640d58a5a1cb4a528bd43ef5ec455f131a5dea37a19ab6ad64d677ba3cf618bff965fc943f30488b01ca514be889b56203b4f1d6b81e49cb11c5197c742b2cf3b1340eb14d5317ba6f57c004b7ce937855376a063e757e14fa516f0add761cd956f004ae3e102243874517ece19f95e4d1af6fc7f0c26665869e29c53f4bbc937b2d0c55fc76d5be660c008f55ca7ca5edd1c1ef2e0f1cca4042d5f87b76d808264efc4ebf44822a00ef5a43c2819e456df3325c7abb9f7c63bb584781a0de4c4f0d992309fabe7587fad66f495162ab73e8a40a4569e9127f16318be7ad40a9a434680b13282fb413645bb4c89dc60d83de018c21d46ee028a2fabe6218ebeacf8b50b26eee13e8fdd90608294875dbf63666c85f4697738f1f6c329c8e626bd45d659c05104b3bef9fdfbaccfc4163491afa20491c93c4db45a6d92ef8f9fd8bdb72ea7496f5768d0d2066ee3e83a9867486a0b1686688434c4ffb8103cff6cf1ada3b43cd68abcd95a0b93583df7c4a27f371ed1f1ccab27f9f742dbf218259e90b3691bac9bc9a252b99f88518593524fffb9906c6d11012cbe46cb950c2b18d8858bf26ffa9caa81bf3081c48265f7ad00a7b6ea4939461dcacc1ddcd48ee466a9a5570e26b6e35d88d7729b4f79e2b07566d339c2728579e3609c404fa644a8ec1e49928d27905e25ab1042c95caae648446b0e13a27fe3fb90ef2710aaab1da08be1324ce084456676d4226a6cf359e918735c32dc4420e8912c4473d1c20862cf3773ed9951458c54a5a375ed2c13082fe1db24a56370fd37dfecc37fcd64407d04bb36bf4b1c8bd853cf5d00c1c9971ac993c6d5ad200d3992ca9aa37b1da5e4424340ad730b8c4a7c870dc61d85b63ad5e04fb2c07d428ecd947a85579192f99ee90e46b7bb6d5e379efdce4026ad241936a9f26f24ddc5e7cc8875c25e410fec4896d3e8bb0a21e0d7dc24a4caf8a6ac6787977fe48f65d3c051ef71b275cdf8e8e2077beb35f537c27ec8599b43fc28d617c003d0fac7ea019c9416fa40efaa33ab4187e54c1768f4617354bb7d67a6bd1f403cecd5a0edb94790825970af1c3047642e69bf30d80fe91f6f2fc116fafdca5f68e9fb73455f80ea22672a59df261e3cb7e3191ca453664d64c3d18cb245e8d89ea71c9cf368b06dc9d8b622bc5bb74424a3fd75d0a602ab1ad9a93974a283ca35f205995981fe25905ee52f2a58a5c3a880e3ae8eebc31da9ed730b80fbc9996c87c24e6bd1641eccc9113322e75384f80ec27621303378b2ae6e37ad9667f39c61fccf9ed1ea5c764084ed4d4b4083d34e471421e30cca0ce92fb9ddefc96e14b586018313fea76661bbb1dc858d6fdb7f96cf8e7a34719fd56ff91f05223c65d8eb0f061a1fe11ffb503a5b3fe13c3e1633fe9675271b46d2b98003550eee560adb0e4373c77fe5f8750e9bd414b4cdad94dc632302b4d1c015eecf94403555a52c22c1d37ac6609b9374e3b17cf9e7de28c4940c40c00828d947afce65847d117b7bb9fa07e3b5e0ef89fa6a33d6a24af0c8b74bcc5f5e81f702edc65b78b8420465e15c167b94a5c1ac66ac29886990bdf5bb1d79797500f5b26f7c87bacc6bfdd14a46c8d851defb3de0c5b122660cac7ec2c45c420d75fb8a6f9a2857171161c529db80dea310718135454cba572c50a87068602855aa42cf9b1872e5958696bc24ec72e1d491b11e71ede7e04c91d091c03e959ad3b94964ea965428cb2aa3d57e00a69085da14134ab6527046746197cbb7bd628a5e516216acf285460dbfeca19ef7cce2ffadf1ed2de71707c08437bf860bdaff37ed3e6f12c13be94664b32da10a6645b12cc74397c326f2c174e8f063c6b0b117acb4b66a4770ac946f322102c5e0865f6328c2947e960b5f32af4109c64b02fc9a8b4d27f16626648b38e1bf0b272ffa21928220b6e7d41c178985e775425bbe2062ea22b7f38025afcb9a4537bcb66f30496d56a7446b0cea6d7d2239bdf03db23850136f48f5f6a8dfa90add5188cdcd5a138a393a47acbe7b64c15e02ebb3bc0c2b0bb84139ffdd4ff04556ce34a5117f93731e58b8794d8c3452b79d04ee4c7b755b6c1b1df08b029bc0fac25413ad27f4e4576caf43d116f23f6a501f49c8edcd1f3fa707253ff26681fb7c60c5ea6ff294b5298531cea5240cea0e250debf84522a59ca8a6fea1e7ac49141881fdee8cc95c6bcccfa9fd2a78fd523a034b61496db179a3506eb4a0a22e9606d5015b0038e7da952bd7b95685115d3a6eea9ac365c61f0854cbb0d1dd6df0372e2fe173feffc9ac094696b1703bc8deb688f5081c11906c091cd46fc3332b84fd46f5e99199c79a10062fa364d6a2d637265b925c887c820a7991db87cc88a656fced572c24e518d041cddcac21958a7012be0c298dba91ed3dd38b11fba0e6de8306e9213c707629c211539f9aa3352764cd3f5f018192ac07d96647a26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
