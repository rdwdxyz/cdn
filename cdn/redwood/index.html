<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2615b1ab956c42e2fda483e308da3a5d31df2cd8592924e38edbd44569728efeb1dfe1ae190132af0c12f6e00b3f608c0eb8a8a56b57f7e955bb8cd25fc8eeb6d0859ffda0c40e6e6619f92686b3a40342513ada118dba197558fe6a535f09e7e24154401048069fd5e4c907d8f85d0408c93055877d20d595935dbde4bcf3b4cd70f62df2574b1b7c5e26fbe6db680c6bdfb29b451fe39ab78008212afcbac6beb5b2cabf4b347b5633e4db932f4874343d4651e6cb668574878fa93ae5877c54588797a52c2133c0f7b4ce98ed7fae7a11d3584f36d0cf6170e6949d2ce659d14c653fea9a1bfccc94129a8618ee4eb2bb744c291dc02c035be57eaddc3f18a30ceb51595d4dc62d9bac60a1cd32428d6aadfcae818132ef5bf37a8c7807b50bd6f9b37ffb996c6d96a3e1a5eb3b79ac3663d58acee18fecda3584f6c2d9325ef87c78fdc347105da0e6750de6bfe33b548f3990ad430af185bf0e8a4fe335ca744a8f8e21ae3a69bce7b6ee5941e5f10913fb83e69cf58b0cc9a6985e3e748bf42779a090b6b9875ebd4b489607c1644d97915b848f14c14991aa216bf57fe383a703ab1e2cea1a8ec4248ecf30c91d408420ae764811e63bd36b9d18447ce1145009e2f5bcce84a66d557868a4ad91e2338d57722c8bf094c2a0755b69fbc6ba6a45b723109040854bb94672939775df29212b785d4f68104088e8faeeb6fd24bb247691a51b412866cf340c6e368fc90fad7e318f63f3b13e34b4a1840dd3362f0737ed76d6e52204ac7fc6d054baa37bec1c36045e4219b44426c3323fa82c2b1cd866ec300511caa5000c3137ac5348a0b7e012f8e21923eb8a072abd150c487f68343f00fd5bd4e40abcdf8c79b06288c330953ab4e8d87342462c44edeac3818606c8e2867f16d0f553aa358b46ee6e4701e723109f2191c9407f23cba57666a60165af2befbb87a40f023dd7be6ec97d8334ccbd0e4d7449154c1d2baff0d1b485ce37cff1bfdd05737ce05165ce9bde67cdca0f92dd226c31baf5479607455c99b78c611026cfbbfbff3ab43cd0fb0bd63176ca21de729a61ef55894cc576d2d90cab319176249718198b73e6e39d38c8ffee565c1d89a47a5d7e028913c60c0f1b06442bdc6ecfce63ecfa6c8262ef159767210334805072a7d6a4f7017e8a41d433586e8abfb2b3a017d801107bae500b79c8589db2ffc08244b4bb2ebe2422df25153d23e0e0f7ba45cfc66e955fa5cde6fc29273fdf6c3cbf99106b232fbd8315599feb8a45b78a8ab8f14126c87eb03d034de348c9794f78cbe94e5a0deb340aa6e0c0fd3b9bd370ea646b1bfb889c82bcd9e3ebb7079afb9c9d28f6c2022f007f6584429a6dbedae6fc847a4cbd7b2c7c91e92c88a67764dcd270934e09598680330b126c610f1b609c2a7b881b91340211425586cd9e4efe6ce9f9de7beec004466e4eea1652ee567f50eef00dce9ddd8cc69732b739a409780c03b11d1e0aa4e9b31e2b3a6eb1c5ee0be340bde7d89b21829222c1248dcfc978dd409e08981ffea9eae137729f6faf15019be36d336441041f69e77c6167707006eb53cfbc4a8d00f61385c81019456b3bee27cb1ac361ff34868fee15a28e0a128ceb42bff94a638504df41804dd565175262751e62a2aefd5be02aa53031aa1faa8e6f9ad6d6a029610a11f269e16e3357f1eb3caae2eb51651a81cdbe65854d40d69f12a52bb4bd014ab35be63d76d346f2ddf92a94d36072ad0b1c2e36d41f8c931863a2d43a9189b4fcf1a90dc57446a1bd67d74910659b87672b73c829a92f184ac34c3506e8b2bfe54a6298211b687d20adfbc8e1361e230324a02927f906f5d8ecec38cf9efa5d0d3fdab4e638c67f56b00d0c5d481cd975b662cadbc9171358dfea4f155cf70e002e28738483e58c2066bdd0294a18f601716b0f31f5ac41a145dbbeccb16ddd2f4b9398b300a91b128a2116e7a121e9825f937d23ca0b8a78fbece1ac15e9f0abeeca6a12076bab516ff8301baf5c580edaa4cb5db1a4aa3ede2b271ba4afb2120d5282640069ea275b1858bc5cfa825a3bf520abedf631ba30a958a2688c374cd6a1c6cdd444c43f704bd60026c0e5e0a6e15e9f3d1a6b45dfa8700defeac43df577c55c6ba0a94715173dd4038d6f727bac91b6f6ed3c13fd949af73d1f5772e157a7321e36a6db8c50252d99a125159dda4ed6631a4b80fe5462742095b768d069e5d88ffc0184d90bc12e0fba53a8b104479e932497ade6b7176d0b0912616a62bbd9334214db56f16b05041b7f4c5fc7dbe062ef8351590fb00e4918ac37387b9e69589d04975b476591db8bfa569cb6156763eb52729b441a34112499b7eaca2bfe100afbbad7634284d4ec988d4527d41c583797952ec8a68fcb251cc42dac374a1f955bdf8e9247b2e7b61fd7424e81b7a905f3540dbc49c295dd60169f3894280b65b62194d635856f621028720e6b92b2dcf7077d90775fee827634330dc29ee1630a7d9126fc93b91c97698f101e533191b5572f4013f038848cffd35ef8b1013805f8c0fbe093618ac94b3d2333518be6770481911d630c0e35bf59fd7e94367dccb42e6818ec320e21fd07d6ae293cc819131522fe50c50c3a3b381a3d6013dceb9375ca217b39e1b515cd8eca3201f370848dc798786216dc4c4d1b8b4687a825ea081bcc9a3d586674ea450d2fd31156f2fa3e16c6967be87434f1cc2ee2989af0d65108b11389a5ca62ff359104ee02a79a0395010c8dfa2164d94c72cce571c019ad3b4f8503a5f1b2b3cebb8f6a5480758b1ab7ec9ebc8d48534fc56a62445b5d822d0751ca3c5b3e56faf6bf7c942d21a0e7c06427aa13f8389c8a7d0b9ccc700c843a00d9e2e384efe77c4e635fbae4dc7b30ff618f1b554bd3bfa92efd253fd43758aeb38a5371ea0c8ac2eac44459de1bf71a5a70923afb0bfe32769816643c6516e21178b9ea1ec6410ba08669e9f219aedfed91f64c7d045190b3b562ff54019f4a1f6f930d3ab72c580dbc61c654dd75463d12e7b0c050030459b6a6757e016626a2a658a4c9a61509afd920f65666a708cdf811a2d8a4afcaf58acba14bb84d16c3972c1c2cd6623e08779db444cebdcd89fe4dd9c8d15c715084c8b20eb1ed9dc1c4a56e879244c119f3559d532ca0adff600699f887681ff72df04b38a68bda277a8de76795c35f88bff673d45d905e157c5e6b7b33cdf5adc70801f1e82605ad2735772c0b121d949e07cc3278384e75144968fbf150b77a12093035822e662b3bb552737994e61827cd4f52e18f99261b8b52a08b98e116366feb0ac03b366c2461d72a2a6489e8e8d6e3921269a3775461e4506f33e422d45f088c6913f896f6d1d454082812ee437ea6bf8ac134b441b3b30979910a5218f965e3ac6ac731857eaee73ec96bb6f485d0332bbf79745f3a1ec506065d0a4e0d2c957f05857a2edd80dc176dc05715a1d1eed95254986799d04a2e9badf801b0abd23e9773af7d7b9765381dff3a7506b643c2439c60b569896f13e5c6afafe5dd7103dd2770fa8fbfb2aed75264dd7d638747103c407f69b05f87f6fa3616aea4d49b25648b0d374e4f57abcc6c25dd67044a9299fc956f6bb6c5d0178e4614e9fdafe4f0ef880eae91c0d7461c97f2ae68dbf60b52c257b7cdf611fa3ca908be09faa584397fe68a8d0d311cbed8d80e5da4af9e6f0e88700f444394dcf6f69eacf4fe6e7cf05c0eab86194972fa512ec619d9cd422ee8e54d83b440e4409e6e94875f1526b34018a5af7a9c636a076db827d2cb5d125fe0ae65474e4eccb153d83dcc20569e16995dad356a3decea353bbdf998b731d2eba0a53fb37069a491093a09cefa5e8595bf2f853dbc79b5195ffe0542b14b4a2b454cff8adde5fa4cb99b7aadf83a9f35a51eb8335336e8b3ce5d685c3a77a761651156523bb3f3480e0974d1b2921d82dc8d6b0cebfe84753686aa537f5af2a18d16673d8c1ef2dae795f02fbe2720286ea9e08a760510216e1e90759f4ab8ef3b4947a1c0830d88bf347316afd2015d7da8c547478d52fe07c572914831a3661eb303bb6fecfb85a8b2891926b5c57eabc7df7b006fe76c39cb004237c8d67cb775d5796e6c000a937efbe0cf8f1b0ce6cac65b3575e900884662402587b5e9855835488cdb050869f863a0b1b135134fc4bc29d1957fb699fa6de1d8aa8e328f24d2e8a639b7fff01ecebb781b3dd8ee3522600b88c96523767179adedcd1664cd8f5d7795687e9822f3800e488bb39858e8fc18759488dd6b5b298cb0b49115e17f4c873ea714681247592cdfc3705d06349c621ca83587bcef880f357ab6fe27260a6581467412a879c5e2fa9c298ddd104f3d928d11fa664ab6844d669b04076456e10e41ddf4f098b5615eeda0db9059a33984e018cc1e26c35d2c4bea2fc8cbe93794d2673039cece88c494e384ce499fe2aaac73e52e13c5ef70f64787b285d80a8e4573515de76efe0cb73714fab636498baf65eec7dd7c10e9a1ee7512637d8dd253e9dda179e4888b00fb70457bab9eeba5c96381f85435f25d45808c65d32c337cef86bba99c0f4ebad44d03574283f9ecb7b07f1ecba9e2e81d2209aaea99e63b6822f7445b87f32845e53dc4767ce104314e9ba78a6c737e180ad19e2e77f236e0bf1e53016cc27cd00c8500d4f39389186867a605d996901ff0e7d8df6922b4d3469617abc0f89a33a35095c7a9f10526a82a342357084a21958740fff6f5976d48e0538dbb8ec99387ac84ca4d8755ebab2b34e2dfcc0b211e7ea171f917fc14241dfacb5189f56be797e97471627b79951b997fa800d6c9aca2c9e7c6b56658859055ba8ee8ebe4234cdcd76e23a1e62a2e48ba9ed87790b5770f5ef4720730a8e1e4f0527e4defce5aeabfe78f0d62f22065bd76c031995fa6d4b49e402a1e074034423f2e309ab8fb6add40cdf50425ed70e4b36c975a0ef594dd941fda46d1fe3cc5c861ad0e72a38d54f0331dc71a7db0fd4ef645b66d67916d9e8ae8f77920b4a5bb45dcf83848004c29127b3f1c35200cff3464d90c11663fef2986979afe9def2082df5b888d6bd5858415655367898d156f13a6470474ee12959b5df3e127df464f3b82ce595b0e106f39317bb17628ccf69a29a37bd7d2de2ce701c2246dbe294219ea32861f11c1a88a8a5a5439961ff957d199db11cacfb96bed2765d14322ebe56f44b66a852317aaddf8434e3b5bd5d9fdd4339b1c0551c1210ca45c128df11fa0aa8db48c3ab302fa7800720918b17a66c60256586de709e053c8fade7b9c1f7bc0a8edd87e83a75c8a6a99364afaeac3a32ad7c2b60381ac76a6f576d2f8af71a1b563f612d271a202288782e55f3d279247c207d30b62c632ab568aacfa1379b5a2afa570220d8becae14acb5469da593eabf011939a6ca36f06318c9b4f56f9e8f000a5693ccccbba65a2708b18c5f8fe64a950ce5a37691faabbe8f8a6f085253cec4f0ac2625377cabfb328929eb382871d453beb62c6c8ced1a18f606a406c6f3439fa2c2985556f9ccade8b3247816ccfed6edacacbfe2834df158256c28e150b326910624973ebde1557f282dc60cc45f95ed550862b8a6784c7ceba817646f8901227d6b5e15ae29ac0c139263bea98915f5eb39de726b1fdf305f20d012c88412a7a01eb2353781372544a8253a32e5d1558dff813f43297b0dd7770c6a5cd45855701b4dd63dacf95c4eb29ae958439971e6827fdc737edbabf0f09b2c59a7ca54c04857b0d47ac7a9fe9327c17efa14c530b47babb721c976dab9399de8e6faefff9fc697871913b83acec2191bf26074dcd413172d12baf7ca22512d98c3fc43c27d80e641696b4ce5d22dd049e2343f4a4ac8b0d5026f25b63cb63fd6140e8d1008fd395fa557dc53f305d96b1c2ed15e19a826465c97fbb7e0755867625f3556817f34744038f1d22defc51ecb9ad45b24968812e50d3cb6f54d133aa72f0571d135922386aeaeb1f333d95e96322a0967eba68e0d979b526c27a596b6f397c549ab6e912fb39221952c2138028dd34b9f7777bcd4fba8d9d64b7b21d4c820a7c2ad238ff49d3f405adb693e3b6220ffbcd3c37ace158f426fc56d188ced8eeec62d8ab15cb535acdbdb7a3f9907c993e4ac7587fd606f8a2ca7bbe430fe8d7a1d595d3b253d0599dc6c0dbadca9cc6b2606beaef7d7c207309e95fd1b607c42fdbca00f5a874cd18f5557ba571273f31ee0b8632d70d6c445ad36716e30d67cbea4623b3301e886a83a519a5511d05998296555d5ec68878296b17676b1dc7d092fd50d26d978c4573fd008e11f8598d47c5c0e8298f9657360c75052a59fbb88ee2c9b0da42e55616119b1c600222e15a0f1de90469c6a65f602ebb110f70e095e8f336a1558c5c7af3095226508a59d242664d68444b6d89159827050884830c528c62311a7ea16a1405cdfd983a5d7b6926d71c50acc07946f9adaca8dde0bf6ac066b55dcc9c07872b3028efa3f7ba878fcc80751b6fbcc8a41c14386e2d9c4e3d3c53189a6c9145e788a65462e70a99610f01a954d171c95bce38e559a73ea24affcd476b3d08d5934895a5232f6b04ed85e150ea9f744e33f2dc1c2aa05d1a5a0efdbc1417b277975cb996f2df608e1e751d740f48c1d85d2376dc7e65642f79926768a79f52efead2604c10da8b0ffecf62eb11a8214fb40037b2ae010c3c816b378ad6f1ba988bb7b14befde4a67ea0aa556b694702cdff88f9104d171b6171d8631043745970177fc9166c496ce5c9ffb6ee643616bc53084529ee9142caa69287eeece09aca79e13cfb53b8f79bbe8a6732e899ed07cfbb86a64039d7ef1a0faabad558459f838711d2f962f1ddc4925b9d93b42eb6ba922dec7b2a582574915a8ac1a50f23b9f0a23d5db2fb18ec997b059d6b0066c835881190e17171afeea0c29d9616d5c89d1b1eb7e0e91c60fc840b9cee0a124161a35c89bc4b24b785af70c1d94f5af597edd35abb9184d34e62924cbb0c9671241077d1413063c7b3bc3cf20b72391f3bb6bd374a34d404ba7ada5c883df8aa6831f3780125d49205f115f3b69df93821aeaebc3a6c4382491309f775ea83f92dfdbeef05f262700a0b340ecf3d3c38f4f04b46c529a811e3844c1f082bc21b1c69dbdfbf3143c9ed664b5491fbc4cad718ee80622cc5704a5acb09a66d065a4312453c5dd8b6e322d13f305b1ac3bf6fbae55382530b3da0b9521303b20c7707a41c57b310890d230add2d6e57b6029c4bbdc94fffc158f4fb977e3861533aecb37bf22f1b9fcdde39dfc86465e8c44120e43e56421bd683e89fa75565fc251c40ca72148ea2353f50e1def6c0a30f0b1d7e7ecb81fa4e2dcac88c5c9827817943c65daddff1a65a6e7850744f4767e5e4549991b45460ba3d2a4c03e2bfbd84f173f8e3e30d3a1b7b6acafcf8757b5ae793dcd737de34e32488028af5742ea8add399e7708efda3c086a1ae730ef0e69da68c188dbf5e58f6d95c02a3557dc7c24536d20509c879a39cfb728870f9ba8d3095bd0c07c4f8fe4fddb9d95c723b3cf741712daa8a062784d706501c6981b5ffb2b9d8f14a4665583ea24ac81e1078ab9bdc6050f7ea0dd8fc3ca7dc944a631cf10ddf28ed50e5c359b7257cb077a3ccd0f5bd2c379524eca0ad89f877d5085b44336c80ef53de1a2dc91ae288e0dc0cb5332b832b033ad1488b893d52633ea7e9ac6cceb59ac246d2bbf26a1b12b21719a730aef6fa656a912afbda42ce15496edd68224646ffab5e6ed8a0eb0724daf199d48727566e8ca45848b1204b4439254df6eeb34db647f6c748b283e50f69f90173195b37212b9d66efe2793470f051f37c1216847cc065e4a55aea9f05e6e8ca375350c9becba7f60590b281623f1b8a839b43e89ed5f73614849223e21d99e0e4c64ee541588c0bb45137117800e5749b24e3427257bcaf94af36519e6c5a0aff2076ad88f5cd67e71594479ddf635182950823ec8681730b1687ab4e9c1986e09487cc5ffa975186363753a42caa8d7105137e11ce0c09324da15fddc31f5d0c0eb40a4cc6e2793f35908e62ec6b47d9f7e1d1bb6432ee92a6b787bf5e51158422b799f31e79a1cbe1d7b9d381b2dc06150e6a0b30328f2de6862b7fa6740b710e0cd9a1ece025537ac725541945de6db80033f782ab8a28aa5c50ccfca2b8b034c25853d8b15248475e1480d1c0910d05a1891c22e56217dfaad77a045368c729746ae3417e87c8cb33b64364ae93511bd04872174f8e077070bbfa63f90af25ea945c704c9eec651804a280ff4cdb37d545bc63e1b99f6501fcdf0a3dbd5a91fb3fb00787a395ec157b23b735323db1a177cbbe02c3f2bdaaa10b987195bb4221a91a17e004a6ebae8d3be422ce81d2b1ffee81a4a146afd7a1c178499c3eb3655b81bd768635407ce9b002b81ead0ae657c18813f1a938768cd8209f3a8b8161ac7574a60fb2f99bca6ad755de12720f4661ce7e8c5fcfbb20ff093f82c5069fe28856ea2c0e2e7bc5f751173f17100ffe1c5c8ea8eb014f0c4f299d8defcb7d3eb24e2b0b69547c36047da58c96f9a0090aad5a6fbaa336ab6435b13e1be9537c9487981ca56e7891ae9c1a8058f7b493f0448c5f50f5f4544da622ede6f80d8c7c5a5a735bc23098f129c9e8c73b05aff5f90dd8445ee12b62fe9ae38e7d476ffb59cd99e1330c53f1a9c2e1502d1caa79d68ad33e65d783467ea3ff28f42db98016f88a109302b0875e9d1a3156fb9b37cf40aa793cef12b20233574f6a76281dda70857e4453b90805650bdb35afc01932b74bf12db6f6f6da6562950aceb206e71ebcabe90b0a167c462fd7afab8ca307d9c888bcd7140dc520ef8ee70a924a316992c5b15954b9d980808d7784f75f7cf359471c4983d8837178852de4c60fd60779ca8c3f0aab8a6844b8ae50bfbf3ea49b0964afb8f2d5df09d64b3836642a6e46b1c472674fe4e515c838e45a638db3379d05b1393caea7ca609f2fdb7c33698ac2a83a6601b1de56b97a6fd04a7c511469e196626baa952deccefeaa86de5fc7526f333402f42f99a1fead5f9767eb29a46c103515fa016ff4826b6eca6d22cfa2603cea7924c4414c0eade95678de2d42aee1a72174e65397bb801de599f059004f13f29052a229c82e2ac95e1fe446391ea2fd6b053bdd4094a3d9cbe15078fbe7f768547883136b1eebd0ca452bc6fa1dfd274d5d4064c17ad21f926802460ecb013f6f8df6cce2ea5d8ecbe986584e5c1650e9402835de1e9aa38215fed5ef3ad09cc72c44ce79fb60d20c5341a63450ad465a6a04faa9d35f11d3dc2f976c947ae2cb08912c4d22b80718babf7443240d08862bb740ae0b52dd6e198b874affacff6032cbedb36680ebc302d8f791b95aad34882115f65b570e0ee9f1f7790c670475b2f2fde69a307d6684d8372f6f681761a838b6edf32411bb9a668201a2b78c16706be056418d2fce64d0692f6d38bf1f42a6a1212258a4fc7435a27f84e5cf6eb21803df033f3fdd7048e1755932b14cda52bf2a0f89991c8cc6504cf63e5d9509fff44568b37d77346b92cfb7b3e9275a3f73f413d7c89f368de4e63d06496c1e83df7fe4782d9c373c44e275be79a89fd1cd67ec5a3b7afa1491fb5788441ae79cd912511b5502f57793d337e7db347f9f108b61a1121745bee9d8adef5fdcbd30471f3ace42a77a2cb35ea60571be6cc1928b520119cd8aced21eb1dcd5379034c7bdc3415ee00e0bbbfa5c7048f8c68da631a98b7a3c682a115fd1d673c68027eddf2021ec2ab0b08f1874be3b5b863eecded34c33b39fad44fad86849e2a4bb8b43d6c6ac953f1dd3adf408081dd3ddcc57bb21e347ab09860ed8e7c8acacfb1eea8ea1fce56a8a0f56eb3c86ebd8158859753734c3962109cb544daeae14d91f50709fefa001839138507163aaa87cd839865b5816317c2d39434ded652ed3629c86b137d8869e8c1e7915e3d660ebef3d77f3ce5e75472ccc25e4ed2c7bd95c085efb944a3267965e3cc9808b0e106e4c46b60654073609626ff9aa4b004418535fd111b96de1b89a081a2cf51b2ad5564c6ece4dd85af28aba73979af31295c10ad687d61e717ad89e58449dbabcc06ed0b68783f8f88c717c1f8cf7c99705cfe83b1d1fbbe1176fad39b2bddd684822a75a5d8a28e78a037397556d006f06823ce51a7466b886b0848101a1a2011331f7f13209835a04884277e4b7a8a74f021e9117139ea03eecc808dae993623fa19cf338a599282bc90b0d7ced4e2050513973e0dfcfd337ecedadfdbd6ec6cdec7deae2a8cceb922ffbd5eba226a76f71754fa97550a8f0c35377eca6b157e769361d4e2a2af39431cead2d905c87688c653b197a2d4780f623a65ffead94c89e94ec789d45389609a2077aa1ea1eab9fae808f11cde5da0ca09b30ca49045dcd775a91d467273e3144d574739a4a8eed4a32d348ed370a53770aefcc2d88154fd015d4f369ff8872e76b299d0a0398a8441bcb47ebfdfa769e53d5c747d84002d40ad328f6f6a4abdc2f567f2e01c89a19f5e8597bc2677581d1419753759be64ea0a3d7b72bb6d7e008b9bd07c57b8d1e5771a6f34d3e219b3505c37670dd969065ee19577e2940e67dfeae24e243206d6a0ec7ad09807c29a9274fa2795195732ccac337069952cda0c5010e6ed233ee826a0eff7b039dc53556224010b8530640336b4917edda7467c724aed5a7cb172a0bce095911fa5c29e7367b2cd00a68ebe78ffee81c0994bb2481e316ea9b31ceac1e1380a42d3d9579e5de83d3acad96f90a16b4e05823fd2152f262aec757a2b912ea7b69e86d2b4842b568cec2d6db6c3416945fc85927c45dc979f12279918d77057d831811cf06c5412e86410abfaf6fc277bcbd36fe8bd77f38a73aac219630317de73a95eefcbb5de244d6e04876adad862f6b846552ad155bab3584619c3b01b3b898b53a0d88f2c420da8da439815231fcd827a01944903a61ea050ddf73989592abf4f66955dbe35f0b82542dea8df2936881c0c9beba5351ee2549f2945b86f72516b4da79506f3f01b7577276bd5df31537da17693f67aedfce2f3565b97052dbdf7fb117ef0bf024d56a13366985ce0cb4d06280196d2a5ca4447cd972f94aa457dab73e3b8c79e414068d89b5db6f057bb7361801776e1c551c65894d46b550e2999ef28b1395dce0e93fdae4a35793c307b065ac0d52d779113e958d009d3a64e0b099160a4ec068240b2e356adaab13e758cd96230aea3f8f05a7d94cc9849dd42e85e297eb91851e1f03539b488a938b81c1b18db595d63a7a435761b57a55a7bbf12b81f08ceb62fb359e370970de83bc856b6cca931ee5f4b51ef4d87a52c2ae7e48a9a158b837fa4f053eec8583a962fc54723a9eadbddc641583b303580e35a95e71999a7a84169716b94948d9df0b22d41c8c6fdd73271d26aa270923f97517806a03ef57e393b2b2896f2b0f8568ce1dfc5ec837f465e105a5bb0b66ed8c213a2a669d3114dfad565b1a99cf9726099d1a617c0aa698577133b57847f4bfb643fd42c89e17ddf5654c56267cff04f8e52a19e60884d2fc020303daee0c391c3e59b6902a0a0add420652c9e1dcbb82bb9d2b61667c2afebd06c1f99d2c98c2b42b6d060049a66a28067b2b295286b25a90730d673fda4c6b006c188f5d7b548cd3635eae7d73ae8b228cbdac5528af79bca17a0ef48c2a9a92e27bd92e65cbe172d299aafbe78ef8c0c9889a34e538f3fea52a51812746e8115fc2e28a7602e399a6fe55c1f5d1da2971e11497445cab1d2d42acb1be73637f1f893a3e1b143b4189c9538d0c5a23cb82ab4d4157158609e072e213a6539a531a482160d7f23d8ac97cbd97fbf2adf95f8d8b6b6e3d893b5ef228df67c57cf189a6c5ae75e89dcaabdf0d8120a2208b85d709e4bc86b26b44334a1dee9ac91d353ba7e52bbb13a3ffee34fa749cd904b1afa9395ee32cdf3e53f10b118c263d0f35a04f8ea9b411cb73079dfdf48123c471dcff08020b3f1d86889983f60535d062f3a041f60f06f115cdc7c4c2d906c86c90afad65f03ac140f25bb6539929ad01402e851fd804042add7b31584d790ff9db3bcdced67ffdef4b28caa886d149787d9535507cc8aa50ee570c6ac52bb95c727113b77d787df7ca24d7597c97fc43b71a6d8d64b836a72af81a18194f15ae4834030a73ea391d7670ab60a599cfc3039b1ed6eca3135f612a94d1e81e683d79e04cdf853c9591d240cb10405b96c7d8b7c34e263eade5b04f4649ddd20fc1fa7a3e078f646734e9ab1e3aa01de18fa1475cdc27354cb3cd0ff8ab999d4b4f663c480d3b8f3f88b79bae737fcac234b73136554fb2f837e0f4a509f9253490ecdb09a66ba250d60126b9dc27e31e8ac65f421840764892de4f21d71f051514ec223a8348d4efec2ca3f2a4031bd3625b58581d14a051de38ce255b72e0974c26145b27768ebd84f9bce487a17e598fe5d7fb7c17c35b0eac8333214b570feb3d73cc67ef4030ee478f98489391582934bb0d9daea06920ecd137b4c49415635ef7700634509c64aa8586f837efc21788c456294be664ffbf03a72bb9e348116b6aed63b76a58fbdd30ce77c5d7a95c3b55d4d94d47cb36a046e4c673f08eceeacef7ca5af5c678aa30be41e0e937ec88c0b5eb059072dc92aa3bc2e952270635c007536418107801739a86c74cb1d20b0dc24590f8d59f1e7f846d802cd06f73c145ec7db8d39b87b80d64a46aa74018694d0a22359822a3c9fb2e81c49b1127d0d47ab5255c37397406620fc95a53fec14de2971e24bab9c567f88ef49155ad8135c7c6795e205130b48d29fbc296b47e318579b754be84042e782615f999c76bcbd2099cbac84128803529a346257a3df78503acafc80b517a6ad88dda8dcbb0b3e965a5394cffcb39d104bf70b35931f5e07cafcee43f0a9940101a12c1537ef22070f3129c4f92ec59d7dad630cd7f5f6a553ce3197998d6089cde6dcf01e7707c08117afc4b633297eab24be26bd891dbf0d5fa39e12021722b4a4f0d56b34bc6d927a1f317063679ccb03b47ce51999f645991654e71e80815244c924b53ceb31e7e24fb1728b08df7225b8a3659867ba57cdacddb7bf5cca4e14eef9866ff04a38adad87f790bbefb486d3c8696b05e93eca6d5195fcb2e588914d5f36dcbfb25057cea72b38e11611cc786ca3481967f53e99babcba1a04174c9657e7fa1ff97cb4c248e6cbf45b6c3e3fa6216cc5302fe21f5942fc7d2436943707e01a2b4998ed8a24ef6a6061f9fa9e8861d5fa7411e52aafcbb0db2a30e4b9d911b97167612e098bc1bddeae689f4677a16ddc53fcd02db5ca9c88a64d0e11fdf1a18027bb2ef2342a951a2433449b091930bba7a22b54fa4b9077249df1195bba52ff1decaa9960e5a7179d0c85a51e3c36605264470310c6a61b40e28889db07a6f862dde8792add04952e8eea0e1c8e62eb3b9b7aeb530fefed358b5c42b0d2ce6ae2e2e7bf097b8f881f4a99f344d21545b39c155a8a90c481082961886ce141248a6e58f08ac008d315b9a7b3735aa5781457404eab93d6820d61b46b78926fc63cb9d1ffda9c4c3451e2187d18a58b5e774d6ec009e35bb3220787ea73cb00e0a19b5cb6d4a3c7c6b91095a0f62f8afb3a42cc060ef4af1aeb07237795f2eac00e474c0cb300a93ad89da63bef9172c89995dd3fc61596045d8ae3a7d4420a3d1a9867b07ac68f5c79d038d60b2e12aee105b386ecf8971a6513fe73b4a0a022cedd80d16a3508e8c82742cd1c77f5c8a09414a24dffcc4e7b20d1d94f79e58338e2365e9ef035e7be127582e16205bebffbf329e9eee1be2a844c04e08843b80e08070931548ba24e47eab5c3057fb331e240cc9559ec05c5ae0016047985d0fbabaf5cf38b00e62c125eebb10dfaa2645b57546c2fb880ed846a97ebb6f043785a7d6c43f460eac088c6b796d75c59acd64eaa09d90c49ba70df06a60ce747fac816ef5287b5add65721740789f347b487decfb9dafada8b53a707ef53afd5d8ac8487b568551a5b6f9584883c7f3d9504b88fca05857aee0b85b385a10dee27b43a9eca0105e35b3ee652342d7547fec4eecce8d861d520bbd2c55cfe33115fb6f4247c8a497c3c1f23812637049c02ae4e4a728a023779cbdaa86267a1f0f0097e9a275ce75e0ca913d069e993815cefa0ecca4ae0e0fbef363ca6874c146fa9e3d0ebba0865123ed0d1bad46a8904d7bac432406569586dbc7c087893ea121e67d6e6578c675b7d5149771935b44a868db9bc88cd4dbfee3480ad8c180433f808f953e109d1268cf54c046340f89fea47ad157cd87676e1c9f9b0ad0d6cd376356c0d5edcb1a0ee917d36d591c3490a7ad711f3fa35e29c4a14cf24042d1dfa5dd62e44bec24b4def7685caeb06672b5fad44641b571e872819cb5baf8c8c3a1616636ab343ade0f20c8eca466fc8b102a63cfaab096b2ebb08697c4552d7a71d700143e746813925d77dccf05aff9ac3716d62c5927e1a1b5a6be60d9fdc953a9a92e42bad8bb36733d3dfee6b08ae5b26680931c2c92d6454d23cdf35dbd9171b9a29ae160ca0d3635d0d3268cb3f703c50e90b55a2d437fb81ec96b8a3e94f197ff498aa7088fbd14757785500d22af6a1109d631808ea9700e2d48f9337aa9d01a1d3aac411c351066c6272e39ca7ac8fbc49546f50a4a96b170ab7de2d63862dc799ae2c46e99bb8ae6abec8f6e10910be052213c67886876915812a863b3d32cd07b06671587c1f7d8bcf27b95455dac4f9eadec8e356c96206a61f7031d4307093b60a5b2146ff488d894d03483814af94385e7ef19586dec2829198c49aeef35308a86c71bc26a8313a0d57d5705f5e0d9d7b53169adfb0f9d69283b877f46aadfa599e4d80fb9013894636cdf1d2ff6c3889c50e65be43eb27cff67ac5cc84f18309d899e2c85fb7a1c5a8f1b673bb9d18d53c5bc1679991b5dd4e19fb68cd2d99374f32beb768444739174ed1a85d96b45f475d7ecf207acbffe782e8a428ebc170846b3f1c885e4fa6e5fe6251e527774ad506a949a3ff965a37f7d50df10fe1a79cc3d8f328f196600c6ec5d501b4df0182f3b303cd83328aa9fda85c2f73ccac66423827199a9c2ceb554269df8d7cf870d344cde17660331c7eb403773a4f51e6ba06b5481a9af7270c13ad147581db2aa059dff06d437b80921a15480e5971eee5f993727dfcbb5a08354ed395545ea2826d496ef5ad9855a43980490f00378d62326aa9193014321c20616cfc946bc574aabd9354236628f97e5dc13d2d6d4c43297cba9d64c24eb26f734ea439febb33c7e5b55c70c71575d276fb9616a4c3a385c79944c20f785870d2821ed7fa009e1f55cc55ec9dd16e789e91870f2d895a5a696e335b1805e689ff3858a60f5e571a21c15c603300000c56261d7338a33089dc28274a9466a84eb133c87c356f3e07b71721efa6cb3359a2f2eee5539b37629dbf66449428d02cd181763a2933b826c2d95c80d3fbe30d4a0d115286f5d80981592471dfda700d86c79fc71933f0bf7387f22ccd147912e69d4e1d6604c53ff8e21fa6e24d090454a6a4e8ae2c2ff8694d0689b4ae1954c00a102de5c0d3bfc4eb34f1de44667cc7a6be167cbb71c9a79986eb32c5e4894ced0f2ff52291f99457751054e356a5e80d02a70bb7512dda4f22c05920140c6777022ace6e3449f0c3fd69a0acfd795484f7b626cab34023ebf955c568ebc7afe973b698fa740511dd14ad50aceeae65860184576e8fbb278403061d5ec2f9def47edb3316d0e1e7cfdb841876d08e71768946aea822473b9d9ac0761765c625a9c3b0dc034c25a643f765e44ae91a5e0795d275b724c44b5e74d565c01d62c21d4df2c03e7dd9646997661dd8b9a38825523c85b96e45b22faf1581cc379cc9d4dba9fbf40247a812ead94942440a8ee766e5fdab0cc0460a9b7166b9d658b2dbe7aac8f50b40a8fb1ba870639ec567d5ba0a7b775cf9d52129a5c5a5ef2bf73bc1fed4ab2369bd6bdeca6ef00dfdd97b2732d079e8d501c4bc458f124da45b25d69499b58dc68934096f8796ff3fb6dac9dbeb6b702373f42d9680dc65dc8189444ae95f332ef67aff962669938d5b1852af5c176b683795d7ddefd0455bcce02ab6404d221bc028298b3064f5aa630ef1be77c51d400fbb368d4c481a36e1ffe6cfdf929b9bfe033ca2c839698b4a4146c93129aaaff52a5605f1d088c8ebe9f115c9aa9feb324e5e750ed93aed26dcae8fb59dc9641aa7beefc1a4141e1c05b21878a74e67272ed12c49a0f7f56e7e163468aa2d5722b6d50ab15c95ba87476494bcc1312a31cc5f6eb338e15fa57bfdc7108e8ef9c3e39734519dd63991162c3d3fea31c99875554cac9cb422cbe73b9045c7ee517e328ca4a3a1187985d4124d2c28a5a6953bf73e3614e997d7aab40e3d4ad794911f85dcd1b4597b789ae445a38378bd2b8634cacd282b311c15c428863482dfc0f54fb755189ac4783816549684b6866f826d19b12a87229eafc8549f1cca6865585ed302d30f75facea9ae053524c8e3802feb6e2f70914262ce32ab0973a8079514ecfc1628c10ed0e68e2653599d1f29ffe907b67e314959a23d85cab3056cc4e34638a28ebb62434916598c2c2bd9fd2d9a21e443fbefd434a3b14d3e7302a90dd214ef793c6c66f27e1d4633d7700e4526756f6428860e54f11d3d7af8e727a779844f5b853fce941f5f67cde0cdb64d8b1fa50ceb5282dc3a29bd1e3d276b86fbf96fcc6546b2e304002e042f209aaebdc2f42b036a7c8fa64baf925e364ed7499ff518da75e3957e5d3fc06b1a21df18c14760187fe49f0289f50c8630bfe0eda092ac5364b1579b00bab698a9152fda75a9854fe333b45247d53bc04d71be3f569424729ea07c974b7d97cf3e040e7dcf66959cca899dead5d822711f1f10f6044b5832005205ecb48de11331a971e7e115be815e65f80be785c3f2fb03acf4af84af7997d8ea6258707fafbd16d78e3e4e7d2d4fea886adf57df49518fefce534f735af3c3ec8fb78e5f839642c0d6542dd88f5f3fd365f8df466b22d22cf9e4338056031d8ae169d791f3943f7f80fbe3be21e254b9f959c71d767a59b5610bde67790890c614868a239d48ec077d7ac344229623741cf8779dab11c57e4855105ede62e285d1824de027f05d8759086213613003b13db325c6835ef7c93f61d543cff6cf2324abaf0301956ba1765906b6eafb89647486610a5bfad4e159bad368061e4c1429613cde17d1b772212168239ee934e2e2b5e66466bfa73ef17c1bac1d91c9640120a101e2010150fb8b614b470d2d1e43a21424be1c67ea9b6d66ac7d7416caac291cd721afbf23367b892bcddb2c40b94fec40fb859330143c7714f57fd8732c89ea94c453dba3d1c1a31a6b912ec71fcc8ddb64b18c7dbf82b7854bb83db60350af7a21cbb8cc15e4a878b9eb313edab2dcdeb59e834a32814c3bc2d9565d20b56460caeaf73c2fa2ab7588347aa346a39333547ca97bf53fb7d6585adb4784dfb87fb652a58c435439968a18c8ecc2d113d416ad7182bf643b5e2899ba016de7c88c196fccd17454adff70ef0f09f0071713a06d54d8e4f6f28d4a5cdf79c13b880154262d4e19b97838b5f47df8370c5abfa01dc90c6f3b0a31579f94a491450183b52c1c58dfa3a5e31766817eff0169a9199734db4b29ec0104f8bb9ac8a53634cb299cc86efd646670922ced422252b4d5667669a54f7e48d54671af09a4df0a1793b0ed6d65862dae807795bacea1c2f290e785b3bba39facf881a34de307c01732def2f60bc203a3339ff44c15c37262c4e318e2752eff34b1db6c71082d331b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
