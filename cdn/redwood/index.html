<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4d5e6d54b0619928d343d25b959d93ac0a5176f3af8ddd700846552546e55e1ed95c59f1718ae02ca3d1be1bf60b7a7ddf35b338adb9e1907671256acf9ffdb836deb17f5bd85fcbbf3ea1c937c72819f14d23ce9ed3d60ae65e611c86d55e8e70b1511539937b7076bf9efc4cc4fafd9258dd664da52b8cbecb87b07a226847ea34035187c0e5d7d83871b5a4a62347d7d2de0355aca74f253b5ae8b28d81a7193c2cd17e22dfc8c8338b0e55d9fae9f86b0c044a4ea20e27a65ccddc4ecb6d641d199130eab1674fa1ca302bd03969a52a97eeb9ba1d86014977d7710873b527381bce276e9670701a11826f5e32f69f5649f2dc7b5cb81b0a01c60a2b151f2345d2e3f06f8285385153476fdf73472e665c3a92785f58d848ca13ef9ee48b0d7e16a229f7fb10c5445f770d78264e0f41f79554f067404391a4cd9c424165e12d81969236af01d3289fe4f95e155a9b3ff90865f475123e6f30a0e0568a12b873bdf3d3dc22b7f6fe8cb936b6934fa9a57fdfe6aa40d252ba2af85f19af64798a26e1e5135c2528af996828f05f26963ec61f516cbab1aa39474bad27f11a457c2583fe4842586fc3a325f09d1332f8e340f36dc9fb8765b3bf13117cdfdb7eb22fbc2b30955990f566caf2858d68d9eb059e0effaf178fa4866bf21640efe701ad1b93b4c29fd7a63f40d8c4af2b09d1333be1eaee218712e7cfc98276e177058b56bde38db08d286df16c4b21f84dfa3c1b8fe65a83ae1388e6ebda9f044722a8458f72cd6f31e57a2032dc0834098c47cc26eb8d390bb09e73d1f723350f481e1edd990f4716c6138d0862a276b419abc0d1599fdfe97b0a5071de7b2a9f89d19cbab6e27afad5232238e5fdd7bc6832bf70ca93aa5d43317c25c85e75453a71b433863ba908337c472f9e41a2e98fdeb0818cac2e825b17bbbc2bf5973a195fe755e78a92a5c7a55f1cfc6e27ca6cc4cd660ebcf4416603b3e18307092cacbd4e3929e22508f6b8bcda8906e21f8ac91a8521e9888bbc908ff4ef030ad68713e66ea7758f2fa88f0017202792a808622f964b85e6e7995148382d8be549aa0f5cf0599d144f7b27ca5e9506d55291490cbf5ed5caee553e56d51cf01170d50714e1dae0530e6c1c53ab7f14740e41b6ff98151c815d734f498a2192f57026225622aca9ab8cd2fbdcd7bca4eab3c0afd5906de19a7ae4148018c10273d218b56ecc32f95be8c0fd6dd44c8ec0ffc8e5409c76825dac1ec216618bfb17be11c1ff93c04516fe9b34e04fcdc696d977a2bcf6efbba96f398af79733c844a8f601b369639fbf4c2c35f30cf1e557155a3bef2ed9a7e81b6c10e5be2232347b0d0b910d6f15107048ba83e9a25a6340457191bfa9f301ec3c6dcca567836d27986bc0791a19c8b10fd2566281421c42161b10971b8d9ff53a682a62ee8b5361986ca019f1d308da60d8069cb35e0a9a62d4f1185e2fdb7ac5b847b751f5e4ceebc721bdcef04e5c8ade1526f251fa3083fc5382f96538615c04e0a5c7da8f810f3d73e71187658f890176c3b43ffcf2009a0b77d8f85dded5af1b29f6d325781cb4dedc60857e49ec3bc7f8ccd60ae43a9c4305b2f7f78f9815d7cf8796371e7dfd4f8438af5e6e9bd78ce88b9f1765862bf7b164870a589205997ab5bb47d0af06d1a9a4ba17308f6c22dabbc195e0e5ead262578c69daf06183a14214f348e2bb01cd7878a222304855ffd1db2c5337e2df0e2fec5471aa854688d982f5628ccfdce5d7b8b6b264990fbdd017c7587cfb28e678731862f76ca37d3a5b456513519bcd7b58ea5edb883ce1feb1c84fd9c233d32c8f9f6207df45abfe24786bdb41fc9a3b80cc4f24f503b56d9338e3a097c9c00cd53c9d78b407586e9dfb6f042048a78fa938cab2784a894215bb96256bcbcd907cad9f78064b94d4e23ef545e8020be3e56c7fb0ad126e3de49990877409e00c0f4037567e40380b23f4762c015e0672d952ed1cdcfc962559d7eb62ee87466e3ea8f0f6a0dc1e32a754897a2f7e587a0c1806c247bbe685b37de2fe0325fa1b00e14f12f5ea631c8b1a8ef1ff0a11fcd29d05e79c8a1aa8395e8cfe27942607dfcaca8afa4003ef9bb05b338fb5e89e58176d15c2ffa972df4f0cd0d86d45b08b78baed7f0899aace9146cd084cfef8edb2f68f4ddb79121af98eaeb3e3ac2a9728172d17c1d4c966a0ccd583ca5df8d9da0a8995fce0796a69cd228bfdf0b065f29537f3e908023319d1babfa180eaf83ebcee51dced8669afc8246510a4d530372b8cd44bb64749063cbd28db42066937d6349230740b81ed72479f000757d6cfc7fcfa21bc0dece0485737b0a1f9a6dcbf3937234ed69d50da6b91171093684d9215a695502accd187cbd3b6d111e39004249b6dbcf62e74ee0cf3e9d2798fa8d1164ac213de29207dd5f0f1d981113dd1cd99375459562e1cce5c7af65a381442b660b01fcf92f02c6b66179df5bf3fcf15acdbca8f5d270a8bf235dbf4e71d4cd7eeee851ec6b5636c1b3183efc79289bae8a36c8e1e0beac8895ed6f2cb26e1ef6ffe4050a5d5605b89b286f678328e717552c53947c129bad49cfabd2e3fe50fe9655dd0f44144ff59472ef834ee2963a118686aa187a4828aa7462fe817151ecefed7dd5a39e9fe8b2ccd7b849398231be3e7df69c9be14d60892e4f73b52b279a4c6c5e6e2c15ce7fe78ba2ddb4b1cfe408494728ec71936d011dcfacb7173c7723b9194edb200c87f415e59643e6bec99d8ab3cb56075ee07caf43008d7a2346b5eb4c1d200bdcc4979c8d061353e9af54ac777573d72ce1a56fa637c776319c0823e7ce974b4fd724bd9dc1cae303f3e8f15fd2f19c17cbddeed3ff4ba2e577cb1943ada9d7a3425d01806e5c295de4a935dfe62d23ff596514888a8f29874bf8dfc75f5fb6b5a9b13127a00e252a2d355254ca8a5f516b844324419c4086c1ae145a1c976045506b2ca17131842e45a512ea3c310fe65ced78b91eb025034d37d0f414a5d8902e850a4800c5ff3fe7fa203830d14ffe0ca2b5a84af3b86dc627a316d27cafcc96839a8397c47a810d12ca901dff7d80f0876f632c3305ac3f4496b9c12ab50e01f664af7d8c7dd5ba9d49503376c98271d7a771f03bb378edbe79a0b6e712365a68799a2fe023410f410433d65089cc53f3ea4b17ca62516cfa689041269597e15783b621be411164695d372471d5fd2706bf9e8ae7d983411825f2b2063fee79fe418282bb3c6fa4b06829759df832b3223a294e5a01df366c4226af4c8dd127be5bb2d9487f18bfd51b5274e17564503d7ae14160bef5ead6985eb43fa7aa600baa89ed62ff8e01c2a7af024d1319c85716fb332fa374e97bb9f6df6a2991a7c6fdc2ba3020d6af22056c33ba1d9247c4c90ddf7ebdf888865d3ec79f467de13bf4d18bb5519d7abb4567fd1ff4a5943702587da760dd0714d2012da95982b78d99340bb60f84da9c87b94b09ecbeccbba79398a7236634846ca38ae399b0df748f20abf60433927abef8e8dfd47c08e0187aefb665477ce4503e779c3cca2ab27cba6df0f10b1d3d81b50078dbf0272d4811e476c3d60e7ad18a5d06c96a41bf674fa451317fbbc97ccef6fdf3cde44b3d348e651e816ddc2975b21e12ea854246c0fc4b9a3e15cab80789a693e37b772db5f21c0e8ae7ba7da2b1a832eda20b7f30917c21abab48e1c3320d4929122bfac28be512d29909d17303781cef78dd9c3cfa3ca0712a4e3ac9fb998c60e12e0110e65cb9251fffac8000ca1f9bce09bc036c13281a95234241e22c85809d1b31c6948d00e9a53cac72b754b9413d7ab01cae8e63ad42874b74b8e65a6178397abac1f055c4114b488577c1daa0c9b45c314132c4ad03062787a854d59113dfa02b9eea3b199968f3e7244a0f24e156fcd12230814a6d893605d52ff390a1da58e49deaf9c64f1e5033b14e0d97729149c3b5f381c21b6108041ccb529092d147f0e750f5cd41e70bdf26113e6a7e52b2b3d86b881971d22864d7196f84356c26860c55b23589149911168679a868b0a0a8fd92fed70a13c7141bfe4099e11cf3e19a25cbb3467007a298215a9b73330d4a1b19acba1f8691ad8e2b51e219f0f8d91df7ea8ae57c38d61416013febfb91f67414e66ec702be7d2be420b21dd984e81b63f0031f2fd1cc8b3d21bcfbb72726ad64c0087444529dbece43d0edf2fbde7f836e6701014d353c3ac5281ab811c42e436ef67f522609bfa95d640a7309b9356766787e4a9267465e39001a12fb249c8fa0d4c5d90bb203b6085a74e76de5b1f5e1fea36570456712d69051263ceeb7b47c7eee0145ccb7bfa451f85425c537d206dcb63270d5ca6fbcddb05d469342cc9eefebe13ed21841e2bdc36f09a18be484c53fa0fce8f0ffd633921cff32827b85742f8a177ea3a152fe7aa0844854bbdd733627455754a0ebfa23f4ad7b7114a2c5231e3976f88a93735c9c386de84d6ef89890326fc8347ad91a4d7768cba0a42a6545766519e3039149a57bc607c9615793698d1d35cff3dfca1c84843a0d9e487dfe1ef13716f5f31da26b30a410c9d7209e546cb6dc4b8ccfa786d7fbbd645fe652d433328025e2dd88d2f69e9456ca937c8c8273b9af7101cbd6713c39cfa95ae2a47c5fe74be37714e8521f3e2e33ba67e7e98eb82addba726fe9106d71257f47593a524d91719fdfacf26f3f95fa5bddc7d99870576da800d00d62f58980c3cdddad65a78d4bddb73872b00e24eb12c06cfcb6242b2584a0e3aa4a705086088b31f6433fb331cc976a65011a6651705b3d1ad970f5b31e0ed84019d3be85047eee47a0403daca6515e6824910a4e259861b940ca4cd4d5a877985ad0a48ed98821941d9da7e5bc92f7ef40b4b8751f70d61834980c75d851afe60f8c32df89cf5b68b4bc1616c68b9721103cefab2dd115947b9c711834c70e916e7d3ddd2072ba2da46f89bd5cc8884d7ef686cbacfed5a58cb07d5b9521dfc60207088d175e0a50d80e39f3424c9448935599df79484603091cb35c109c8c30e34120739768ca789cc629b421a32d039492b46096eea5139de044633db895e1b3e311eff70febec302f675845bba55a2f2260bc40a45a0771984b97c94c5d2e35bd0aed13cd35d1c292051c10f1ab313fe8703e12150989d967fe7c7b6d6b471c354aa1a80579cf93be5ca656358fef6f5a6aaefd80938d54e7beef9caaec3854134f1fee1f854019f44da49ab87f94c6677195e3aeee7c6460d33e22c1ff4a15f516a3347b00a5682c6df47fdb697bd8639327de11e9b1452b272631b42a71a1c1c03479a3952dc8a14b02a3168fc39dcc4c63b08d31ba5feea24259601d71c9abdcd7feecb4a71ab39e4db924a8ecff5d2a857a46535703f61b19d29b8be7fdd72060a3e4d44eec626e2365be7d9f4eee43e89c74645b523a6a009a1d70b58e9890b9e2bdfd963eae279d5a2f1a0d73ee9c308c16b17c40f8a00151458bba8519967721e5b2a0998b926ba762246997a00a4e89de5ce0b82cbeac20f314b54979877d71764d742e87e5067421e66d16f9a0ada189659306eddbe02167e2ac37c4f6313e3bf1493d0deb0776e013ca5fa1d1543e033dd0aa6262cb49d1590344289952accc75ad690e628979ffcc07539cd8a6c842b943020ef1f5ef6e619a7feef3c21d53cfee2269b62db738dd1e4ac16fe85a87d9d97ff119b23939115a0d47b3ab21ab8550f71dad570905b911e6ed846a8fb059f8c000005ff0ed4d158c22b04a03d2eb0981c6411b3060c6a427389c518b2d9f6a8e6a3462bac3042219c0acc39b2e2e10a2ff4c631cda1bee3838959c03108756d487f7b4856f983a04d25fa18e8debb47d916827e4950a7f0b340285c2d76e58db22aea22842deabf45a2705a6bfb379a1b669b16de58e04fe1ac38e64bb93e02d69cd617d4b18684a5ae3137b8f3a48c6c6f38783159240c7ec041480af0b563143e0365e67db3f1f628361250ff17620b98858828977090c2b04b0254ab8d3a667af94c29e71f0edb10b5d3b1f3b89028baeec4ab0cc97d8ff041e1e98bc9b5f0d0a3f722886c1dcc3ce4c07c93db8c62dd1698e5c61a13322917362ff71668584d98796ecb8ec4f839935944022d311ab9073bd33c9d12bd0ace4f5347215ece5809b90fbf3beeb610a22b885564310d9e68db7a39799acba090c1f22277a1ae39bb50690a94bb5d4095ab954e94543469112e50dcd8d665bf48d04fe72446bf3c021868b703d0b53c32fded58c5486f35451b491a79e09d97722980c73a20ff2cf5d42261a4bc3fd6300d760fb8cb00bc0cb47c1deefe9422c73cacb71a52bbff0002661e6898fef4dfc6e98143763ce93e2028469defea78317fb913ac4786d4b26e4adcfdd5872166bb0dda757b79cef4123ab6355778523b036ac15239c8ee5ddd6998cbad4604055afe3f53b3fa722bea78c45fec8f9579fcf037b420cc8920d453bb3974c8685f85caba10fdb71ac00eddac87562a926cf268e56e701c0a9a3f0e2669fe2435ba89742aee82759228490c87d6523cc469950b5c2e59eefad123fb880740cd439a71da399dc16139bedc5b1850717a010c50181ea7835b2e29e35e02125b59c65cf2e51ef65e2bf70ef40c9b0a3d1a3a1ae0beb9e5ced664a13919522cd6db8692dbe14335cc193c1ef8be6e790932136fe445fd1d5929b496b6e348a52fcd8759b8fac975a7fe7366bd8935d88c01c3f29274b74b36ea120ae91fe3446d69c46f8756ff7c1e8398e8d43a718c803a1b7744a04dae8668a0682f477ad506429dfc8f6794a71fe31c76b13681f1d02940ff7f3fa2c74b77b88cea5f96e3f14166d9a32eefc47c16a04bfe15ba4b873a2bf44cd926a76d312a2dee503114c96c6995873bcc9df5390c3bc512f9a7939d71084ccf95f3d81dd75eeba35c2bd241e6d6d9682bff6a8b3e5ca64c496817cc39bbe8212a0be15233e725868b7902c6fccab62dbcfcc11a916494f1c5de2ce0674f2d3910dfe969d9c0c51b48f662f0a71714f60e692cb4f10598c75f8934e1c41ef7cb2428b4eae9a90288baa7133525acefde8cdcb05835cbc8de8fc517238f93bf368fc19bfa5c644c474f0973bff43516df2274ad400ebe347539089dbdf46860270620c9e55371fba8b72a5402379c29ec658a95e28a2a1a0c0036e7a762b3c67d631e5b8d615154aa4f1323d07a35b0eb232855ed8284d4da2f5ef91b101129e83e4d0a211889271e515817c06353e43cdef57eee1e404b2b256137fa0975a4e3438ac31aeec6902b9827c2b5901aacc19371ef876e989efe4392254717f750f1078ae6c8f8b26470bbbd46b8074aa1e8ab7a1e0ed904eb1e5edbd81316ee2ef21f5abae0af105bdc904d914d4e9dba82fd549989726e8bb882623255bff1958a9b89bdde3dac73fea1d80a0613bed89fcc80f6e08b66e11eade2d11623129643cc5ff0b8553ac11af056c852e51a82061862d417a9e64d073fc9f3b452b7be59ae9eb057cd95da34a8020aeb9b9ee2671da6bccde7843e2f1c6f5aa575dfe0eaaf5726722f4c1c96e2815e770f3481836965b60a6ae1641ba7ec534eb5e332c729253fe26415b16e52779f7fb4c0e412bd42faf53bd1e241987a12a5008170bfb937baba72febfbbb7669f54056043633810b10016511a1a28d625242ff13fc7b0e61b5093518dcdbd003746bb0da833ad20153feb01f772865bddc03ad59696d320c9727b268e9b4e5f061723a673f48064f806dae90067dbd8f30d31e6f83b0efd6bff9309a542720f4ec9e3e5b51ca2e3b70e714edcbf9ac8221506f3f193a374b8a22626f62d69dfee712f2a74e9cbd7204fdc93cc89220b5dc7bfc13cf1a81b02c78b19d41cc06cd9b2190adb5647c66cd2b2a745c72c3b702fb9b16f33200c1b6522447e7a32a888e2270ec5974309553d8d28795a36b5823bf74b2f8400dd414d2ebdb02c00cfa248a9d9017d6d7a76fb437cf1ae08cac2c4bf18b58dfe3430e6d2900ee8b1ba08ccba0ccb97c5339e20922b54fb802e9570c8931d47f2e3a99c0fd0e319ec946c4cec272e96d2ba8a1f8af0e48df52344c5cc43da878efbda94774182b2b20cec3116bd6cf2d0b2f2ec92a08525e6b86778e9ffaf0007e8136e8e6b5176fc8f7a8e85d05c1bbe2d3ecf3513662f0e8677b1cd5dbfeb381d875509bb92e706d209fdbc31e51de847e7673a4619be6469301576534c4ccb5ac2f272c9bf3cbfb4d15551dad603b3e0462ce123c0ab4a76d63f62b14f7ffc9790c29a6518023f46deb3bb50892496f5038a240eb8df6f5ddfc1ea4dd3f387afa86b0899a1b2f8dbd095d57fa620e316bb67ca77e69acfb2c2986318230ae2f1ba07fd30bd31c7bb904207783d75daedf9533647bf4136d559399ec0d99166f6af277b573ade6e3ff3100c76c206b7f2a59a789a1b43778534a91a5fe7be5fcb57e6045df3f938762041a423523b7520a3b7135acec669a98440fb10db08136f50f45b73eacf493848c62ef31fd3b38c41f6bce38b65163c927b287975c6ef73030a2b995b41d1d8c4d21a112dffe7e8516622fc23b2de60260c50ce221b3c94091157661638965b0c988ee9cc2eb6b27614e6efdebd946f5229a11efc71297fc8e96bd41ab967353352ed8f02edd22aa7679e5f2cdc1a1ae13e867791b615cbed8ac58d2792bfa4be0bd1b3d9778a5405ddc5fe7614b1508c4af34089b83779a5a498adc2bc8c7ee4d7b4b0ec2cb0b33e1415f101a2720a741fcf3063e1d2bdff33ebebff4090290b0d3e1ad249b36f171dfcf5925392cc35b6317f60e035f803d1ad8defc74d1f97cb4919548b4ae978ae4d0ea04be66be76ac9992c842d93bde691bd16aaf35784419cbf6650ec4872a869a529785018fc9b446fd3d2260aa45f4bf108e94eb4f68e14ac6f01f377516ac9f1505032b218e71fe59c35efa8d7b05ddea55c057684a8017826108836acda16c9094e9877f41fefad4ed2bbdb9ac76e23bf56f254f93edaee05a8d0743e8c417104d2d7d763a6093d0d97714b933f9d884021cc8df4f3c9cb4a27b329cc25981cfba08d9ae7cd0ee3ef99e89881359584c1e6d4b971ff219b79754d92f7f38185dab604e44266f7f12518eb7441b732d368da4e62b23352e262fdcdfdc56ddab3612ceedb3271f7216d3688eac8eea48240ee6dd377f8bbc449f57894e97c511391134c2e5ee0f79d5b54bd8c0229247063975d244e3901bcd670413e71d62b65286920978e1ee1d909c3fb1c750eed2b8e89e94cb28171be6d5df397933f78900014bbca0fc2b437fea906630503241bc0d4acd8e5e09c096f033fd22c5bbbea7c680e1b8c39ea50b67a8fcb425fe401db99ac22d013a1b17f5ea094be6f06fdce2de7fc2b27a1e2080632e32bdb27144ae082801c871b87724a3893d7e8976d8ea5ee3a7f3a7e2e734f3b36c7e3a3585f94b8720a36216294c9e53e7c434b71fddc45ccc5d2d4688160483b27e30a1116a4779db6dbe50ccd402176c1c956346dc153d0c5055156bfe7b768ee57caa83e74e02120364c4cfc58a437119bd3a39460c88c0e7479c73affa201a55c3fc6acd93353683d5d0a4d710f9bf9fabe62fff594ebb47b2c5f542750990ec13bcead7d18cc1e60a46878a042384c058b103fe6427b6c500cf3d8743e533ad9e760927f4944f28e214a1139df30d126590e31316ecc3419178a452cb8504a4de8e08e9f157d2a3c355e03716e5101e995cac96974939f57ebdf317a26485e7ddb71fd75bbe249041a8886d62c6661b0e7399d024a8c55625c0d0d038cbd60f4c96293eb063e79f35cce21538f4410ef2f958019af47e11a1aae85b645331b34a7b0d6b0c994f2402690d60d37e284ca2ae1836bf331fc50eaf6577435485f15148673a6ccd83f19043a982a8a1b7b267198a212efebf0b48ab19167cd35cf8f5cc3c61057ff43929467f6e0e67c95e50fecb849a00caaab8ec495fe85d1444a90adbca172ca04dc6f09ee2975b0f939e3a6fffc3f25d5f00911f861e825e0e3f31aa016b820808502aad06a73186c439961272d448b9b892e71da929f6e9831267b12e1332e6af7b9434d3b53f912191f9b33699c49b7aaa83ee2173d15276bae2e144a42ba61d9307c6dae2f698731d491245b36ae82d8cd9e64848282ffde454c546db829a177345d4ed0c9510af5532680476e0338820e22193f8c02b17840c9d69f49d608244a3329646367337ab40fdedd5134f67209b6b87be8772c47e324fe91e25ba637537e6165d565463c40081b0466dbb87fb1a42d6eb25336a067d028a247df3fa06b88bbb67c09f1c3387c0e4a823c08bf76c2bcd5e841c9eac8c0e99b43bd508e56c89ab2a4dcb97a30c190252e33b7fc32277b0b7cbbb093c6a2893f3d21a7453ec3ee55558ae9d9413d3b731d63e48013bb63c1f2e4d999acedd1d658d61413953e41dba0f62e001e795e7d12c6be5c9fddcd9fcc72207f9a21a56b71092763ef2e72be0b09d21ea06b3ec87ebf036fd1bfc6720218d277a95c67c7c5c0bd97831133af381fda5747ffea617fa0995fb8199283ab095f7fdb12ad8702b3f37169c821b19bee3f21008f6e4acec3b5d839cf8fe2bba3705fc551f0e35cc542a689e2574d023e0c52f81fb18eff060ae43b2b5826a6a82564cbe96272d86003114badd5fc348885f7053f7d17c5fddf7bd2f0b43da0d062e24fffaa773da2f6782a93e79977f282507d54ff271327eda7154d6ea5be985cdd6ffa8fa0140eb7179caf53d55b7a0aece7a9da4ad47814d55c22a2c5d265189c9af5736ea6a4f5b1686b1d5f55e4020ae526c3a73a1f063f4a159cba55f9d40f53e793749216d67919d416b08672a7d85802723003cae1aabb0971b1aacaac507094ed161e743fe96d4918d3a9f3975ad1cb4041d07a8f854f78275830148bbab1fc592136e5200eaeb44a8a218cd5b72e1c4b816990bca6533b7aa82dfa13d435bed11dc5bce6a2d1a5c6ec691ef76d2e8cd4b6a569969facc0d4012279df73794b5f615829885e2ec89639010db2e59404ea16d613007b89f2301de9a53ed8538dafc1e1c38f35b222b9ba784deacc312f84edb69a4ee1f143b9d9a838d3de4770fd19fcc8bb5effe5e7a4827fab4a9beac2876964b09d116016a8784aa045f5ce598863737d80e291ce0342c54ab85654d5f1a184afce32d3ac6f5dfdb35e32b7d6259f6f3732b321008156e631d696b29584e2736328df485b79d2e22818efd39e63e35c6e6b13d302d895564e62f5cbbcb7f9bf258cb3cf5dbe7fd4d6cb84733d123c6cd94850419695bbb477a365920534120f1ac0f24bec3f680b32007ac8985ebad7c960978363b819e313d2a0ffd607a842fb15836a20d232adf83643c1b14ef3773674b42245ddc67838090d7718c723fa7ff213a02b6987a6a7c7c2f86e74aeeb449c777499996402283c00df45c5a49bb3cf4f9345f22d16e0e19f476cb8dd4205364f3af027c9368e9d2f2c2632c648b3334f246d1472c447b7a9a4205cd09b438fb793117dc1cabfa92545eb2093ae8e525362451707355f9ed2691f905cb9661d55b7b7e26a20994dd38f13c34c9a06c3c959e700cae87fc238d9456d758c7ac1196e464eacadccb167064f31728b931343bd44ce9132ed80e38d08340d0ff966c7bda4509206d8a00e187de15041ff60de9f4ac01cdce85f45121525f3a8ae023c17fed6daebc0f17973a3ceb41d38b1404a7c1355e11433b7211d31afbad0aa28f642ed790b85aecc9e9c95f2308eb80121bfd8eb3fbc4e6801b9068107482f3ced03b081e92dcd0c58e5da83938b6dec18fb42a6e2e6b9055abbb479076fe1d005dc3e3a114a46dccd0c27a71a5e45c301b6a11554f976cc39895802216a91b8ca1cd1a9fbfc54f44a6be58c91820fc43d2ab9ac46e2cf3ce10bb116db46ae59601f9938894012247e74492e92a4180721f1dc7add0b2ba8a731dff0298859f11a6d0e2c4be9480880aec7fd2ce36955e67e22a3a9ce2ae5ce118b2414de807661093d276b1b3d628b5e57063dc078e0bd6d6edff8894e2461c411cd667491027ca7b03747775ed72bc5145a5cba06a8c41e772fd004527bcf4ecd70afbbb8e0e16f96e8e5cfb8560dbbc1c23fb62ec85078b2e157e82ee2be3ea7b2c83291aeb06a4c86eda6d6115d5f30114309eb641417f27566729635709f62eab8516dd5d258d51f339d46cbe4a5443a65f08bbf1a630b6da4ada345ff6a6b5c52a847429f495238b064156c3aabe12cd092a795d8010e46dfc4476e39dce0480b9b7dfd99da4739dd6dca1e3375ca0877ef02d448eb1bc7af42f1b396d243388f2ba76914cf2b6361064003b586568e9d2114d4282dc9b739ac3049852fd3c508c4ac522fa8426efee829336b0eb38000921b12f76edbc0d2e8baa50c22ffe04af8a2e4602543c12a5b259c4ab8bb8172eeedb607fc84e78ac9cabff3e8bf4a7f6bd3591eb9a954a200200401283b556dbc357bc09e17cc0bd2af65ffdc4f0c447cca4fdf9e492366de5d78724936594d2bc210b00520d0d78193968ef0425e64720a8b6f9a040bbf41abb2d0ca183546835280c008cb09bf3f48280a5413bf1dff7cd571ddc1d93aa01b78a0ebec2eae1815a264bff7e62249cc6056900afcc3fecdc8f8771d517bc2afc1874987e141a3e069d5ad81013f93ad6b85a29dfce7ee85f05f2bf1cd858e8e851a09cdcccb7781e62f4d8f3f7fe3f476a4801e0de91ed22c97c04f27ad947c8688e9ae844dfd2ab714be85d0e8262a70e5119203d5a802f6146aec508bdaae7eb60edc7ab51e5bdaf18aa0ca95bc861cff5b84c819da82618f503daaa4752c718d9355ccf811e3d486a86911c5aebaa3388b9f339bc62db77221bbb9f0b5b2ee995a15ccb160942bd328a9e5bef7dd0fe3fd612b3ee249c158a89618489f84fdd9e290f74e78ff7b652185ef1894b63d6f7e87b131e51ce33bed3686023067ae1ecffaeadf47edccade18d65ba40ae0ee7aaeaa547796be42912d1bdd4823b0db08313e0f59ee30b9612252271257b2535d44cab1ef1807b0be0f76b5c0714b003703d9b9f0cc755f76dfe33ef95d3448698584cde3cf8a4e8ceaf312e0a82ba3c533e1becf9639ad75c561c6c2024223605d5da4c5f6f2b24118b14d4b4d6cabae482adf714c29395920b6afae39e2c3208b33f5271272b7f65d56bba8a6427fb5eeacefc3cf6ac2f6c9e23b23815a70ea114a78fae5e86d36bdacd7d3a7ec5eca8e383a872408124458a14677216f27a6b96c8b155eab8b063cf174a11b66da162efa690c9cf0bf51d78102a1d29bf39786bea32c106e18b095303c6c85945fc2f62e61d625db0cb54b45347a08ac9608201fd42e0452fefc3b81923ccab12bd5449d5d85e631365d8bafd232857b85731196b702d8bf1c88c86ba3343e7798482fdc0231f7bdb275a94c98cb7e59eb4ae3748afe62a658f4e062109278af935f63aefb9bf8910fb574292f39b061440bb506bc95245a354efd9a1e3b9073da3f6ffcc579ba943e62f88fb97b92faa73e5744de780ae346fe9c893cc0bb33a49d09d65f482f6bbf1143b64ae2d4112d5783a73ff80e4bcaa03c85caa223e4580964838f9016bee813fce8ce13b7337aab26679a244b57216ecf5ae2487b9ca10781536429fad255111bb42389b192cf8fdf2de155f81a73d63b4eda305cb999ca5e4fb0a52e7ecd1cd1e5b5b3714961ac4f6623f16c919b952daa39deb0b3e0d148406baab5d3865b32cfd5808807987ac7965fd985341f4674bfacd6cfc177e3017da0d040a6e207d408ccfd45f070d4be58a894c9f0d229a46a28d61378c591f3cb476048e3634c83027d28119744d2a81850a6a57a59fe2040a012b8a3f72ed9e2e7d19c0f6f283c3ee1654a95ea1b2e355f2cc36c3edb9a361ea2680ea95c770bbd5c3dcb109cb95206c2d1aa917b0b9bceb112bec547b302b0b9fb7e53a761b157590aa466284050c7f638c0bace664e2a38382043b0e66485d892d71b35cf925c43b2f20063587b57cd56cee0f9e4757a8f82840c4467132d21399ad99adfaee97173504ad74c1602f389cebd09b71ab1ae0c4f0a8e3e1a7b566c087623613a9625fe56f97ab6647f1bd580f9cd82932d157ac200e15955aa82c24c85eb210841c0408f0b637c130408c8a2b5c99ea2fd70189af0dffe0cff0e72653efacf0d7bb5cb1d23940b50aa4c61e544458490e793cc8370e3c47e71168fbe9b5c151eb9d357d177d951dfa5634ee715be49fd01e84f3031cb268c3cec350a884f4ca1e02bf506dc4512ff1825182033fbe049e5ee640669d5f86d0e5eac2c781a3230b988ba096c66f690ba3fb4e0ce5d0818e4c8299407ea8fdde9223da39383e5dcea28151fd89438a24cb45aafcfdcd8f808e3129500b14d5ecd8f089795b6b289efd4557214359c7cec50b7d57ca5c4ea086fe870d25052119f0a8900f960034acde90d6ec4827a249e6eeefecab2b1b25f336e3e10ee39a78c305011df227bf2830bd2add13a6642a91bf5df21bc206c87bed4c527dc44c9ff563ef1ca029989069689c3fe16e3151fbfea5fcd067322df457543fe4e14dc635f8e19fd42331a11a54b86f52b7ca9644e6f1d606e24eb581f5519212e5eec87e779c78b50407111eab53a81482a6eaca38c5848e491d967464b9eccfd391bf796d402e9dae8607da8e304757ef7edaa8b4b0c1e207bd20569015f3bb6e64233506ee117ec4141b53c5eaafa1e119a5471a20b4a8af39b679e349e39a7aba7e622e445749bf8f297ad33ec83a35225eb7e9fd8b42ad2e86af4cc8657199a6c081bea381816d15eadd47813252321e2773417aa95b11a879d30caab0ca74864c48427a01a4c5e5c9193161a68ce72747f37955c3482279ce07ea1ea4d577b091067141319ce929f8998094cb71f8d88ce090a2ae6beb4899be8ed1a37d75be0de0d7f3dfb55f444e9765783502b2b1c2e5386f42ae5331276fae59b75e96b4bdbe958959dd996780138f400fbdf5400ee2b74197b89a952c3dd9a8b653114180e129237fb61405b1c0068acfde4370c61e2e9918d160f99f064065eda51a68c54edd98357cb3be78bb1bfaa4dbe817dc495fa3e01641acfd76d1439eb2d83f74ba68dcb3d4e2d6d16af9e51edd8b884db4ab16de8981b1ff842bc450ddb67416a02e780da1bc008f3486b163f690bfdad1c80f7e62cf15f571be05b3d68ddf1fec2e8deed3dda20afc6ccf1b44c184c4e46e78f2a5e0ddcfac1cb67091b16b65225e44af7ac21783d0b504a96d8a689bd770174e6315791ef5d05d8f9ac7bf9d8fb8548e3102201e407e0d5f947273e3760faa66a9c4113ca8d9587d610d4befcf6c8d226eefcaf428d1c8e3fe399104c1d8700ddef4113d55350cca6fb4832b73d08c50654c568bb0839d0883d155a3168b3ae12c0e87d429326fbde71bbe8efef81ffe8fcfb2a4ae9f1a034f1246ffd8fc4a964a78c3bd14b62d47189e8fb01cdf1521c2af069f724c8753fb08b1b94f2269707880eda0efd3dce27fbfb49389ce049dcd683da5dbb198a8af2c416ea7f32ffa75e386f584c985c8714415172f0ef07b367d3d934b8dc6166b5d4978c52aa00c5cec273e63c397f84e78e215e651420e4592f00012bdb435d0e3b9256c1d804b1767a24494a6c72154ba44582d2bb8c5c97f02ac40ba7f02bfdd6ab4857fcfd8a82660a7b272a324ba834b649d7ae7bd9b2b9f1108b4819f0615395cdd30e1c2a9e27bcb8515999b7e7ca599f399317c95340b5fec5cbc259d8b134986ed09eddf07a0076927f01ef2b6626c3b67132b79cf67c9657c3a16c90d2b5b9e7a983c90362ee40aef490bbb20a8fe899bd92064e5e0e41be92335739092a7afa632596bef5f98a842e36d3be2fb32759858fed5fdc279fd47e64290ff3562573919150b7a98e6ad29ff6eba300e93ad54c01ec63fd0935508c834c775d9421ad745c1b6f33faa265af5007fe177e6dbbc4e1d6e56b5f31413273860acefa8b7988f8a0b97c8d064245d5da7d0c192bea63b5444a84215edfe46d19b8952c0cf8e2ec9218fead7f2f2412c2fdbc62a5fd74c4fa36d61d7c97e17b09141efcaee7580eab3660763c46e4381e65e66efaa6651a197a86d02326bda035161044fc5392f431a8a96ec43a7e377bbd15d335195fb5d1c56fb025956608c64401fc2bad7065df85b1c89938264759fc44996223721bb49baa9eb861165b1fc55e6b317c1c3e4f7bf59089c386267e9a1ea297c26d8d548cbe5615b8ff60a99550fe5c28cb7b09f8f996eba42d71f37c3d6ef3762fe8fbeda77c5d97b49c77477c01b7b803caed1a52a7d79122bfc48c19751e682b46362e99a580805b00f6e7f1d28c81ae5e8579306911763fcea057042f62d4073e0d65b09c77ccd0a284930d35eb8355f1af5d5a9dfd0e3bfd996c3005c18dd9ec15d176482520b594d57c58b00d351e37e6ea4a76013936a4f59751d591934f43d8c87d8949f16c54d9fece755bdbc7a2ca374f21dfdd7dca168740f932375dd9c6efa263604302ed7aa2e1a25cc40f9ae45e0a0812421610b71a2e8aa63ef3288a0c0f38e3b5f55618967ff437493e795cffb05f055cac27f42910ac1f069298bc053c47efc89d0146e1fcfdb5940b7ab4802fc8c4f6c6882667d397e93afc921c80f394b0d757456287d5f692071824cc8e9c9ced160e62225962dd29e57aca390028ea34d999774a29af0b50f1db0a333d93b8f4fc0b8863650f5da49e51d07c237c61765c90b7860af325ff5ff464b706000748c6e24e8a640e94695efd8c8ee8763b9ebf200a15b38a69abd7c70bb73387be73994033c8b06f9a999470c924ededd781e90c50078334f61d3adf2d2601e30bec147659a40b96cc5fc6cc296098b8016334e9696005d4f0247ab8225c6ecd157a05029f2e8e7361a88ba64575c59fd729afbe955c8e0ed3ebbe4c76dbe733b39132db416fb9630b5ab7f56c5206d11ae364015a61d42c303bada99e9fbfc20dd4431329946a86085254f9895dbaa58b4331b58c58fa14095ee376268cb07f69e67f15fcb3f91c34d8751e1903209ebece300eea59d8f5480a2bcc4cde3ddd13eea47fa0e897044c634787b36d630f507cfb509f893bbfdafc5cdfdec8ae98b801f87110f395627cce5d380fb10388f8caae0ab31d8266a79e4a90e832acb5de0ec10aeee2d35126755e8a6f1fee34670d7e20a8566a7b07bd812b14052e0859e5eb674955b054d4150ec6f8403d9190fb74bac95f7c0a033e4161b149a42f6f13995b95e1ecaaf078dd2656d9768850897034bfb46df0b5e4ac729f0f631f531e831066335c03a6fca143d968b6cdc58039f10df5c8697192cd027febb3f7cf75f5513d59bf97ddebb884c2eae58f83db35aa51c67824bcade9d2630f65a293a2e8bffa57c371b6dd1d7015407b58f9da998ff65c50e8ce77c59ff2d534b06cd564afb8150cb7a24197aad5ce5fd1f76b4f3159d4f87a70a5484e275eca0eea78a3b7f2112fce10313d81b5e2ade32ff834f3e9b65d42542ca67347175a27babd9017fdae4804531ace5b894347b26809abd3c6fc72942b899abb1c6ceedd9eb6a18de5992740aa7f890bd341ffab1a64d51769a7bcbdfcc8477285c329752edb4cb8c950fd51809fd642eb7900c331abbd925ea9d3946adab2311b1c8a331b99f755301a03e76f2043c288f94166e3c96bb2fe2de84cdf03092250a3a9c95c7e1403afca8faf7b45a32966bc4f3ee1180f7af4e4bd842c456134d759ac4d35a749ae730151f86785a60162cf70e3607970d8c04c3542bac5a9684c20e5a6cc1dd08289957681bef06bea19df3df534440b259fb12a09717ef187be3df5b6e79a00e39a3e935815a160b57ed4cbf330b4cbbec50950a6d345be24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
