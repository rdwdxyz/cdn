<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5b9dbf240d991e4fd556e5f9b46c6baf01a1497ab1c1f50c70fc9d3e97cf6f4e928dfba86e25b1ae4b659a1971997129ed7cb68e384e8d9402084bc09d0440a30c5fd109f9cfdcbe223415bcfd4f982e228518638c6c39eac6dc8bdd121496f6464472cdf14fd356bdd136c474038aa6d9d3229fd2c6272ad22b111627779cfc649be25044ec5d47c8feb958147d76b03504a736b5a758099e1d43d7a0ad29f5304dc4d08ef96f39d7f833c89f44e0158986a6f15bf62c223f758b0acb31d37ef396012f6b623e3ee0876bd6d070aeab19c40313140d5b4d8c968d7036e6bc6bee78cdbc577c2e0458a0da54c26339a33422562d7a1acab34a2833e4ef8e2944ae0120457486bdb7e0167d903e02c9bd8416715f96e426903f5130e898a23728c8b12a8f1a8768dad522ed5dab7e846f72f89451e9c7446250a2ddb5db6c53b240d62389b0480040cac7f502575f7cf004464b555ce0916b0412657d039b971e379e4f22200f9e68fc0608e8bfb644318eeaeb2b59e81960b6f77d2fa881d9d230f33ead1b617a064b1341ac3333cee1ee7bb16aa12a84c06f0d135d2ced69e1f8b02e6a78eabee2fc7e6deba96b77c54f652bd600fbd1aed126756fdef6097e6e0bc36cd8cf088cbf7c1b4a9dda11f6e8dc0bee74bf300b7fcdc3bafb5c951214d2b392b58c415a4cadde6542fdbafc81b3ba9635b7257e47a6429d2055ad0b6a859be7bfca39ce9cc01dbadefdfb908b6724713444af0ebee1f0cc0074d6fb0ab09c0bb1b28a66a48f7501ac4649a572c188e2842e43d582248a2ab6b214956c625398d2bd2ce548c6d5c3587405a1533dbf6b56d66180a9fa2989050b4873fc31115876da54bbdf2981b91313aead53d6e4bc4db1ab0ed1e6daa825072c4f0b248a4a521a9c98d9901117152fcc1427a160d5fdfd357bc2bdebf58e193334d9a87f6ae3f9519b2287e563d4d6f53153c395861bc1b027f4397aef2ad38f19d21663b97ebffa35b70607fb599b2a49adb30e887fe4eb311665c7ca05189f55a6a6fb09db3e5a0934851180d6b628c4840c3223ff6bddcbcc3b106c2aa2cf8e3a632ac36a2897a4e7b0331d10e27a216b22cba894a06b30c761ede9f896ea0c1358fb35744d0ab88597dd394c1a463c03095964dd98b99ce15094816287f712eec1b71c5e39270f037c015c1d75eece06706e21e213e8e4607e8d034381d1091a366d88a9a5747fe1930ff15e83a5052860477b65107d17ea6185c893075441ffef406449b1027b9b2ba6b914f629fd44a44f2babaa9b985ee7c2d0345bbce0b5d27b70e18497ce7341d2bf25b4b48477ceb4fcc7eab74aa892326b00cd842c22d54b85b3c2e8ecbb50f7066be9471247d8e319240cbbcf19352fd5f635096c7f2a27dfaadfcdb9f4fcebc95b7a57c5be22d3fd32f8007a4e630555c454272c6c720155d0cf51762148753901b7b48195640532591d2b4b8912b42b604eb6c099bb3c15105661e8f8af6c3e543b34cae03c78c2f35999d4f9c7056b795add4e1dbbda11567b341de35266f97238326d8eee7913e19bf2e1afc65c146260688504bff1650298e8e49c2629d5aa1ebcf2038e7c3e405cd9c0d2cc976e9ef7746b5ac7eb31db5a52541ce4ac1ab6f5e05ff967b032852cae732044c28631518252048cd0872c0a36d29611e4588bad9473df5e9511db0eb82fc7ee111cb8377de7d24a40d620f9e3ed4d74fcda18d8e6cffe021ac34490c6944c5c09473adee539c1cecadbb9293218e2caff20063da4d1a6ff87dbd417fddf185e2e0c6947064b6384184ad897c02f340c99ba04a8267939609e35944ec5cf3bda83db85c3f3d7cfd078f6214ca08571586f7926119b9c7e7242cefc566dd18228537e73f6a59f57df478dc2e464b6c4cb7e3aec5cd3f249c44a1a0115aef405f62dc3d90da09e323b798cb0b7b334b480bc572c33985162fb78d2ada675ac577aa1529a157f2d84b0b0d014bf0f4bbe783ef7f9acb68049436906f78f773824ca321758ee39a52584728b16cec80aa4d23936960404254b8d770de84cf79fcd7d69964883f326d2b8de946e800616c9090aa4a85a6b4c6ec520693d3926cab616e9382d8d4743894210e8af28081b01062237710bdb9ea4a1fab9c6849b359380c4cc5a60ee34f46eda0afe1e3e86b0f4f3db283ed6a3579bcf5cbedfff2c039b2ca9d25cfb5392df9febe2e3575246bb3c9cba20e1347206e804f51a813c62c3723edf06d4f281ab00d35f572f0eae8861a56af30b76d5a609a0f05e82ccedaf65af52c496c476e93b18edce1822e9453b59573144d2e3f303693f1432349e73cddaed1fe7745a2d16777a15fe37c375bdbaf444e8aa2437f56cc79d44e185dfa2ea6edcdbc7a8859c70ed8c1b8ab2959bcb3ba839308c56188e04effe90e59188251c36da044b26b9e7a213f8bc00cb5523ebec34154a3d82ad0194fdd902fbc610842500daf9aaeb583981a8ff88acf7de7d0292e1864c2842806ba7445dc8a65ba92f01f7a4fca5463b3ba8d8ebd37a071308bf6cbc59638aa0d507cfbc9bba41f958cef6653d81316772ed12d5fec2d903265491405463526485bb58a5de775e91bfa675959e727b3e63becc9368dd1d8076d2a887f0257aaa7bf608f2b84c952648f4468d6effa69a55fa41ba023875e4bcafaa700ec179c5f5a6b112c5b4b4b116e079c80930bbebb101b319958669037dea5b93d3173120f6ec7afacfbeee3e5c437abd2d8c761b08e128def5681e7f819aee708996ceacc1927cafdf5fb610cf236b5772e8af5c044fcfbc313c5d94ad924e03c1f321a968350dfae9c792995ba8f6da0c15cd33414c9321b69a3529ffe40c6f17cbb87576f10dd791a11c7130ec1b167139229df773161c57e1878cac6d06d98a5c09a5c7189ae1f55f4d9f05ce5e050a6aa9358c91b6b5e00ebe86dd0476244b1f54a86d4abe1705ae8dc3d2d5028080e1155d443c7fcf9d34d7df09423c7566f8ea8f2148c3ec538b1cdec0734aad189d4b819eaa567eea42dae45cd6900bc458bee3fc0ac496a87a46ae5b827ac38d32d9aec808d5309b66aa0bd01548b834ab65a7b083357759e0dd28b65a92e7354932ae35d7f37d9529c8fee0941d77a5deeb8c2e78b77a8e6efe85dcde6e2ea3a52323465f5aa708ab45cd2a3c6daf54e1e45cf87f739519e8487f4a3999b1f1f3db4d0bfd9dd2c09d449e41917953528f6e82af57e9204e85074950d51357936adaf6f57fc2b48701cfdb9333709695279377968cdd5ad1af122abb6671f0ecabfb62e810c6b889d99fbc56f8ed40a551d5acf3ae12a8c6fc87dfc8c391a4c9f605046330e138390b7452f642727b459436b6a3d1ad71ee411e668a03830bf56d16972840ad5df09fdbe5cf055ef1e8141afd74bf09da0bc0c2253a8a500e8e3b9eb43f4e9086a900b39978b121d0a6c07f25ca4e6945690ed5789c59a851a3c07d83433a3e281df9e408e3ec7b20a4ddbfbeb627ae4ef63a911f0f972bd4f5317dcbe4a0882c91e5e5dabddd6a7dfc80aae638c4a842858fddbcdfa6b5388d2c284d80dff804abfd3e49125637738583f3c3a1e57f66c26a3d4ae2280cbc0b7bd56559f6d943e8fb00a95d76946a7d2778d031e830905ee306ca97e6862a9046834f7261f46b9181b0d40e6af9d1a5a7aa3ccc7c787b63ea8809faf38506b914dab68ca7863cbd33f0dbb73feb35ef0b7b2661e9ac2ce7fd8ba97f88d19ef9451472c94295f895cec0228f9cb76d0a3b0dc2fafe0e3c9074a8f8f942a7d2fa64049145db122cfe2147e1659a5563b7b38dd0d2708041b0eff2cc440fff4fae8b1b672c6ba821db3348cb19853dff730fec7e3445cad9eaf334a82749b61ab01ea4a62a2212d82e03fba1842d61fa0f0355b9717ea00fc15e7b3b0f6a78c658dfe6c7aeba329ebd75d1d2ca5ea4706a4c57477519571ca4be45ca8fe773b894edb8145da8c130246b2629df833292b9516214621abdd50e8a43fd725d9078725778b94d4ce0da8118632e3bf29acc95bbd9cf69480a80e804531bdc946ef067a926a7b3c5db08b11be987f4cf8e0697ba3b6c55e54b51a8d450da869da2ef01acd8ffd9e405508d629e25b1b60bcbdddfe4bacfc126009e021bdd9beb8ee486896b1c204c2d179f14f0a824a00aeece76ab252ed3353f462c0ae126cb5d05602cb64602bd09a10ec3a3d8463559690fc4c6c30dbda534755f1f4c6d4d24992d056330a12e1c0125946be100fddcb1d3da495c9095806fefedde41d81f0a0954f0f3b5b65ac2b51d2f4f66a820420a77cf076fe89cb01be3f086630474494d72981881897d62aea78fb0804562cb288847bbbb993a797cac8a75e808f7f04210d84607ffdf3f81040aaeecbd013ea57d58634f4a9fda2600e70e6e5a06652b8ae52d6506e5d65c7a4994c140cfa94c67c0b849a19c26885c75abb99344e1791e46334ad1b84c88b4ad703035d1749c64ad5c97f07b4fa51fb51d417e3e09435cc3a92ca30afa26fd3dbb5098e86b3b2b5faef58fed2c3fd2a32b2cd7dd3e9df62efff8fca5b08dff295a12d57bb926526c64672dc45b42290f1bb1745314f5f7bb5cf1988b7d02bcb508033986510c8775aa2ad40e49b9167547f8c6be7985ebfe3d001ae30f65c00e378c5804866948734249e3522ea1abe4f58a1843405343c338066e6558bd282fdf0fdde67009d3a3d87895cdbaa5f089468fb609581cd09c7bdb374e43d92d7d7185fd25288efcf60b3f1c6b5c7e217f667e16ebef2614ca1186286632b68ae73467b39acf03ccdcd4b5cfba8ec83c0d0ca5c0bce0c51d9c733b513d15a4b17ab27e444fca2c08e5da372bfa01208b4df2b6dfda0f4260bcd8ddea4d23a15be05cd84e86d6a22ac62ee692223c83de1ece20087dc5848f5c579530928d760757e940bb4f63743c5140a60ad00e1f2fd50157121bfa664238f20032568ad4cc89c90a7c73ef05658c93d6892c8d8a59f0b3f74981aa135a667994af3b903a165a240d51fffcef9f2b53e323d00ac09cb0787bd9a8a4716e0a5ee35cb4bd076eccc10a030c1c717acbfe716b55fb945996802fbbabb7ef5a85cade036f59994f42dc72124aa46cbe3b7859853a2d359d456fecaa42b53f642b31248441e161a8af816c5a9410247d3cd4d0fae184e5152ccffb226c182aa6fe78684669840c5fd41e286f1e10d80530f4d72acf16dfbf59465f16661e6dd6ed800ff869b1a4ef970d924c7ef5f71a9ddeb55bbba8163e5aa3ec7071f8e9a154d7946b390325b7b78ead6c840b4777bf59eaaf89caa294244131f96f6bf51c14a3c8291d983de120f3a391639c1ff4abe93dd604ac5af6f35e45cbfa9df7ba20307c99265ed5c32eb6ad055876e4a892eca1faf16929b462797021698fc461a8ff401b884d4f71a2a7de6541edde9a434e934bcc5fe81c7cbb64b71a519e5a0b5956b09a625c4168da8f841083171ce3b4a42a9875f30fe15068ffd5a7f03d0686530d2c9b11fb18d3f1796fc63a8758489adfd9ee39b1b884d4d1a43c82236e2913a92d70debe03a92ec51235ef39f2e1235ed0eca7d0f1667eab021ee03529d811efacb137b804d8d3cf05426b77cd3ed39ad2c459e9365c386ec97011a4e74f4049658e03d533076a9c75e2bd7167cee904a8eac7644fe63317bc27ecfe30643aa646e47f6f1bf5069a173b06fc70c26c374f3e4c410fb316a599cda5464e260942a2d17558fa1a9d16603e12b4ccb5015211c3d6191d32ed1c21c221fdeeedd78f7516e9a2d9cbd42461024f378331128285fcb27f5b4f1a5e6bf25b2cf1395700ffcb10e2c2bb0af0e656d1ef11185a9a9540d75fe597e2fa8eebee8404fcc4db3fddd9172d525e5e0cbbd16fe72c223fcc6c84f013df217191b1411e1aed88f53ac22074c9015a392a5d560ead395320f663689ea1b9056b64962b30374751a4af64296cfdd45bdc489f00760a1a5cc63bbd88a4ce7cd0025b1db49aeb253deb70352febabf4b2e28d3862a0701ee53f4186724c4969030268f8a73185a7d3efd3ec38e927b184aa0658d6308b8ab96c2013a9d1c898d167379e853afb972bf3f616d0eb57cc161928ac96448f4ad9cf322a497de3cbecd17af47fff9ebf187e3bab0cc67e5896bc14e194c3f9c6b0db32ccf2a6a94502c49a52a8b37efe0e10b521f65519695e50e8cc84819b1c5a6a9594bc6af2b1c5dcf3e53988074d053525ae9fd5cfa383a28ddc757f91db346945b6fd537925498bac363c2974b3eab88f79f68b3bb059a26448e903204ea6c603b08c672b555b92cec853985c53bdbf7fbe997c40cb993d7d5f518e36a74f457fa0a38f22b6466d95d30c6bab80f3355657ef84a3f19f8cdf94c22f5e31cb50ed15a6b6fa7c2ff0b74a21644a66b0372a7563f6f3a6bed2e8dddbe0d1e054748f66d8ac87bf434182e5dde2f0e127cbca3714158cc9570819f3ab497a1adf6d85c0fe41b1701e1656f7a1870101041807aec1ba0277a36fe15a54985408de9bfccb3291890490e6da0b073e0ab381782126d812fa523d69992e0d42917f8ebc0af3175973f2f7e73f1ef9ca8b928ff97fcdf9a091f93ab71a9705cea994c330a880ea33dffa2e4df6b72f945f177a47f369ad334e755d8c6ec11b3cae798457c8258cdbcceb721aa389fa10830417a2b5a0efad31915d4bda1cecb62a3fa2f748fd52931574dc887698af3b462e30fb2e78946e2a38bb30735cf5db9eaff530cf6763fe18b2728792efb8318d5f18c760f9990ba36898f07167218ebf39490ecb49665422ee385c87646216422f7e9fa0d157aade1fc1c261fd0823106d298d1955c17d581b5c3dd2a4bdeff98e7e0360f99364a7bf3d7ccfddab7caf23213f36905234e2237728700b06f4d1a5fc5118d80f1fe8c3f96b1463e401cfefbaccd2cb3fb5a0a883dc3be536dce69a2d8b440c4fae1f02bb58ac621e38f4fcbf77cee0f417f3338def879227a59e3de0d2c92e53e853f26ac2bd6410d7ceb2006c812fc7aca9a04486787a016df4e236bb5cde73deae7ab85ec902939f6f69ef6e6d391ec1736bafaa0e1dbf36b3f0f4785bdf2eeba3b6d231c0f52fdef38f6b99475f7427309c2ffd2f918d2bb523528515c851306e58b9a4fe9328edc14a711a2edecb0ed42f362f4ca826850e1fa6bcb85fbb0cd0d49cb198174c379c28def4416908453c2ab09113279043d8859563fe8a6b14fd06f6922dd57b348b60022f3e573b9e96fc3f058bb72adc1bfca0c8dc973eaf2465b71cfb3ce1d85719cabb719eae3a34ec1467c4e058f5c6e35d9cf5768d6f49cc8b943a44d629c42b4a9dfdcfdd8dfd4a5aa65eaea538d611dd45b745a4e1efedb2282994c73c1fb6e5a6c92533ef214e9480454a9bd70419f44093a36567d08bce172194f1d8553adc1f42e28c60f44f78b8bbf09efb656e7834584ec45c279f0d48d1da56cb724299fb7e311b504693a2db0a595e8c39c86c27267bd8845803f4717502e92b66c9d5752b7312e0b84bb9456b8994044f16619d85ba0c04bc5bac792454b05f7dcc2ec59fea101b2539c996c9f22be59e91befc3ae2be94c89dcb58de23c2a033b6e00d0ce9480b2246db7f9294c7b9ca5ad9968b7f7dd2956dedb3fdf53dcce32440bc5ba16481d29b8d88f3e5a4e8d77633aa69e669c730af0f50a07768987ce6d68e45a9c0cf7c0fe1bf25c1c33e696f74e600f5adbec08f1cefb0cce6f7a5dca1b6f4093b9c847aaa8ed4bd4c4817431b9915d6655afb8231660609c8f3ef4475b8963e0ab2d118738bc4c582cbf96690f05a5eee316b2f523cdd1c64f6575d4df707b38ade5de3fc4d1abb209b6df1859116667693224b089f31b104494f153f9e6c6c8d9918ed841cc2e3508d4391ebe95be1747c8beaa0b781e8938355c34f9de32389c3866a5f561245fbd64ffdeb13a1289d2c78cef919a05abc83d5a3def91c6c6457d9e36ce87edfdf595438bd95ae69b7594ecdfd60c5acc718acb19cd75adc4fd7da997b09fa7135fa15137a123ea7788deee7e13da120795de19df8f52c46a447d79c4d4fd2a865b62340f7a74b0c0f6e95aab0bc594abc1199b53bdd3f2dfe5be25c5321f4715ee1301bbe61e44fe2bfd6d24e48575d1535179d634e2a6a2f663e1465bf8ea08d746a415039e90f43518f90fcaed22a9038014e48b1331dd74488fc386f9724f52c76308f8e65a31542514470f3a574feb2bdd974686dda6949500b878f39478a049de6b658f01b1028b0c97c310ef366327f44e38569489be2589757428c76dd20e9b73d8a5ca795a1b885448f7f46a591df88fa32b483e4f58a016fd8363cdfeb6759deb07cd5b94eed877a5eda3d9e1686425ffd95f6ca7680999a43d4fdbe1bfe78bd39cb3c97f08b8ec292ce5c87fb2dd6ef7e5c78cfbdf8ee54496eb952b1dec69b844aa0d4dde9c7f3d9e0fa2dd6873cd90ccce67ecdcabfc01b512c76556fb3d1e0ea41636322bbd68e9f3aa0709a7742991db4d691dbfc93f90c53d121b9f449cb967fd3f7dd869998d728204ed4b3f28fb224775eca55bb5ac35fba9b0c432c41faa44296b1a4cf871e5c49dd3a23aba6d22f8a9b2b24272aa7fe38085dbf43c04ea40cb7c325a657647b4e64b2e09b70fe4dfd175d58a32cc75fda6c66da337ecddfe29082ef59f1cf4adc10a340383248d0dc3b5d3f98444d49e129fb7f367d73a3ba84d381c5a3ef7bd7579522c19bea63e300dd8819a1a119347dd6050d87c93338560377ac2081ad8267527668d25a3bd6e7b50f71aaa33049a2520184bb6eadb1eb9673b3e31d296be44978c3285dff5adeb6a1e4eeacbbc2320582b50af3b7358c6ac69d90bd44a119676921c90e801be8456ff9cf443590f94b609b0f79254445c9cb47822ffb59e05bae4170f738d8b450ed10d49e6d2dc3e273c712492a02959d2d1181e8ac91c672cd868fc8fdeb0e8822f99c6e1a0a29315bfc56c7ad912f2e645323b6c8356b3fe6c3ae8931f019073f0b021278255dccbd85b3ab4fc6cd9875845218b79f9d20c85a73f822b5b48495c28b651ed5a8880afe35f264d71568325a78e510c6a7511314c45dbaa72fd56ac2415d4db78e4c1d5c74b5b70e93e22649378fc0f559e9031b8e742d18f739fb8c213e44de469a50384914bcc0fafa3ab9cbfae67d2c788a38044ea8d90def948c4af585c348c8d8660ff3894384b2e6953260fded1bffbfd49fd766ef20643c01922de50580dbd2005a8dfb4dfeeb987c414c8c5077962531fc253d0b08c0d8e72e3039957378e12a0b5b25013ddc78de3c479833c04e8b4ac7f9925958362a155073bd7ba6b7388954156b02696ef45d280bbb51caeed9551b13c14b2d0cd1e3873dfd88efa32a20605afdef44594c1995588399ed60f04be102ce1ac8aed871521c895eee402e1d29084bd063ebf7bf03c76951c96d7091a4115d61a67cb7791f095a06697c6ab061b5dbe18b307c904ff0bfb7fc9340d8af2114de015ccb0234520af8a5625a7bd93e6e949c943dc2756f0e08769c49510bd561b2d93014dd0d83786589f35d2eaba1be3d01accffe0acd753891af20d72a570bf11fe1e3708b59dbd1276000a22ce6e9cd87c0dd718e9cde3bf8b6c56715071aaf2e9053761c7920730065ef9b8797bbcd0db7a45d5c6a5a21fa38a491a689d45be93b335ca54e65ef334898f9349cd7dd3507589bf230d8049cfa4e2bcfcda5551b70c63aca9aff0f9bac7f5c3ff7b4a0e5ab5c019b37a1ba2212c4f935e90bd7dab4096be0d94747b58b51aca81cd7e8cf55859612f88b1d6168524261ef372667ac9c4497a63e3163e997d0dea7e971be48fff10ee79c2485c000647f1026be8a56c00778c3751aea62e4f8b38e11de675328a8cc9c137099101e49c0bfa86b0024c9b7b7ba6df918aef74510d3493a2a09ef34794d9537b7889be86c6b88df40591800b781e76975ef750452a7adb76fb63b93ed6ba70c772fcad77546af6fade986f04b811193201d86d4b249b4f950cdd9444ed16791aa300cb5512d8e4486f1880ea48d9b577d2aea4ae4d04d8ef008dbf4a3985e78130a5a96625f03ae3d699dfee3085eba2eaa29c13b5c1e32f9238e3362faaf676d0df858c12b727100db62f7a48df4ffc387464c50a18fdafbaf68620990e82d5f1305dc971c5cdce46d9433ab5e5f2baa136985b194bcde2968ef77750cfb6965963110ddf0a9e422f2becd9fa3fdfc0b8f34aedc3bdc850a7861b51a482ade26d13d8839217642587a12bad817d72bfccbf687723a70a78633ca4dfafa6a011f470bb099f0935f5a9081ba23ddbf8611dff055e3fd9a2cd5b10440f7e8c80df47a8f864e5afb9e4aa50b11110b7bf66e19c9cd47eb94086737dbb19d853a70c6239b6a8d35408a1af9acaa2845f50be46e2f9bf751ef5c2ee7dfdae1601c8d8d89863a040259eb72773fcb1bdb9ffac0cc506401856f09bb8ce75bb8277424488cd944ac713e1c3e352cb321924b9149c6905ff1cf49ad2b849884ee8754583e81640c489516cccf5289e934bd3e603dd36381a6103e736ddad07489f48ddc82cf60b62fc8ffb6679f819e1db3977bbb617ccb2eddd34848720be2b866ff6b9836cf5c32e966de2126a36cc40935d9d72f2538e29204dadbfc835aaacd280aa763a3c2ad0cfe212e0b966622c048d9ae3e77173e5fa661430bc5fda6f3b2bc1b9b12824b33efa929cc5a203f9c9683f37da31f23fc7188ba02340b37f0f358d3620b6a4ee0370fd90082e9940b8120a04c498e37b6c965b4227c73a2c6e57824e57b86c4e7d559e01cbb1a9e124a9b120b4b283c3eb092fa0347d004902daf0799d81a197f091b61d8cd4ae302fc0017a84cea45a25c4f654332b88a58b25e22fb4607510e12857ebafa0ea2c9e47c7495c9894ad6a29d447e5a0f3a38efc2d5bac90dd50c27ca1380c456bc3ba538e5de13a714daad742aca50fde31530e613a651b29c505a9dab5ec9ea5bf88dbf298cdf06a5618b6612cbf38c017a2cfed3cd312acfa03c408245c86f474238cbf4391b94da12749580f4f79fd73f7b7a48050976efbc26a359500dc8a337b261e15a14d598847315de410809a5e9cc8276a86abdd2abaabfe966c8f5e2bdff468b032020fdbde75556f6fbe8fd229c493c5b46fedce1e6ab3067eb6dd68b8f31251392e3153f3edaac6264eeb6814fca9dfe0a77eb01b714ed0693bdfd6cc2b325bc2f6e60bf8222d6cb283302b8c9d107f09134d95b67fdeb5bd3f81cd1f0a08990f9a3f27b36bd2429d28315b72b9c8b15db7605e37730d29cc638f9fb34e39c393c3e304ebed5d87d7b5c52755d04327aa15215cd9190a56a783d48feeddb6645895bfb54b6211a84d970f88ca201208c05780681344d5b34eddf35676b1404cd66f9756b7abf4bd9a06f8467fb9da380e9c295a5ae8624255203e14884ae95f6a8cc77dc987fdb8fce4734c430eea5303fe3dbb9d365050a8e8cec0a83481f8f46d9d0c53219763715cc8fb6b87e0580b17fb69527831a8e4ab4375b05a5df41783d22007a12f14b3a9d88d6da0fb555fe0040dcdead58285d47d7d6825f7f49a4aa76e7441bb8f626d97357a6e0f5d6ee36f88cdfd443cc0bf584dffebe6b465a72961c6433151183cc14a8d94b7e1ad2f091c38fad941a93625586667e572dd4377cb11315b71b83bad8ee7e069587dca009670f99b6f85bf9ca2a330240c2bedaae26d36970ba0d5bb0f50581ddf135150ec183883dcf2b93399fba5ac0bc625e43c30385bf6cd4daeb836d00e00f9dc7b604c1e82a790db9088b746438cdddef4f55e924924d6bb24fbcc98e967d657b08268abe4b04d067e47c5a7c90bd003424a5131b0b6c5b37523498bfa6d5012eb78ed499a91578ea18bd2de70a4f5a1a86ca1c3a570138fd5103e8c5a0786919c4fea6c0da5857e5e601dd485b2ab7addba194d470d314e28c224078d7ef80589af698b6897eef13c07fddc3ae2297c3c724830518636549c6ff2040a4dad601e4d682b01e6d738d20d5f4bebb0284804eaa3dff6ec2c538114526e6e6911f09763443753181351d67746138bf3f3c984950a53bce162ebddd75a1295c03aaa160f4aa051390a445a25663a524fa3e8a52af47100f3579d0b7e93b9ea436740ab75c71cd3c034a69b9b5646a06122a57e01aee9ba8a72ed35de26d8ea63f2974af83137e3aea33af633ed9a9b251cfc1461848febc6de184e6ef40524a85cd927a7b80a2a7e0c6e3202d4ffd35ea45c834499c2e4adcdea6258b8cb6859a0117b52c6d9848fe917c80ea8558dbe28aecf3d3e1a9c18aee8362616f1a7941d94e2310e097925cb5efaa64121001c4c685621565d4d815eebb286c3542bcf6c8413360a6e1b65d73157df6f413594229710d60584e9befa7732b789a404838ab4fa5f8fbadad58d54e70cbbb1fd957ccb497b47843dd33018d976d9c64c4776ad42b364ddaaabf36375026783953312d98a993aad22e664f31ff986fd260cdace37787de39b7532c0826f3fe26fe92fdef298dad8c62979438b6aeafbaba962a9a64a62ac62f7bab8902612c6b68f12d73a7f09e330ea972c3edf589617d9c7a009674440c7eebdaa12a69be4fe9e9a038be8d668fa1bdaee3a2393e680d43a46be60020bf8ba6aa411ecda6eede04f4ed9ecbdd5a75841d5961cc8aa60ddc2f82041501c2c3aa5523dfb1ae31460917c582ac5c3d13fa530ad7ce974ee6dc0b9e5959c9e3d2daa159d69071c3531d2cfed468765ba9595aa57619b478e6d4460c5f0dbc49417c79183b86e780a2ceebea9b74bfe644cf25585eab0a4a36fae611cf72e3070afa1018e1bd64591d1a95bcdb39a4f75860bc14d47180574feb7f9b524927fd78f231fbedb8ced505a92b7d5079b1b99b2e67e1c8bc2fd5f4d8905863df7345d6acf9f5cde62e8c2ac586804879c26dc6951ef2fc3911d87cddc01bbcc1b6a35a2781fbadb21ebf385c5cf15df9c08cfd98d3b8ceeed2e717307a3c28e83c096df8670cf65acda2975721139458403c6bb92eeb3f34d95e073f12386b65959f6366421c10d241fe10be6616e2f5bcf0d7e2aa1c22e55f000a7b91042ef8650da2e29a3d1c0ababcf9106b50acf051202bd6d1efffb25ef228afead83d0732f41896ae9537406d46c63d30b13b39e3d4f809a4aa553e892f0eca6911330fab38aa017673efb3a031bb012ea1b945df3c08f5b9f843a101d81a3922904bbae2c1e649a0b9558c99805f793e537b7c88ef478c31cb9b4501181ee505ce3159e4f3ad4e67f2cf7e11e447ff1e20aa6a9cbe1921803ef0e331f868b555eca4bdb64361e22e30a3e606fbb60b5a63902cc3f966250fde6033d437293182cd273484a40849ff425976d9b59b08113b3f90f73a8ece1017751e896814010ebe3b7ce20c6127d4b3729717ae769532b52ebbb4a7820ff856833f5d174d29d8d93502fd40e277eb7a737405dc52ce49a1364d7c12c6fbf2c1b791e3d9e7fa5aec4a4b54dd6d4306cd356f479264ba704fe7d4f5f989a98c43bfd6ebeb6531e9be72ca3cfdcd46a773d094f2c6a5f363989f7a931691df88a3e353a8e1371985f76b945558504ac40f852cf67bbe3c817b90af816e756d2363a6913f7cce3581b4d2f6683823614082f62e0cb324f3ef02b8bec5b08ac6845d4a9917e8ae3f57f40b174e81e99ff4e4cb2bbc42e39bfbacc1e967934e2bd0db99230ee9924fd2eedfb8ec23e2ff9fe4bf77f4432b13edf36b19a9b2de5999e8d0b3e94ee0cbc4af41798f4c8cf7bb0503c7e87f90332360b63c2095fb32243b640eaedabc2547b39961f3a98370a8c6b51d99f8d2dec8cda53161605ea3b8770336fbd922b5975778149ec9311b7799645a22fc54f3d0e45b7984b1ae50de0c7fefda5235f46eb5e2cf81b5907429d4e4b237c9be938a06c56bdf5550c1010a73ec077d9754755d806d33f8ff8db36bbd0cfeb1e8bf1caa4367ee1c2f313665b2e36e5184a60480077179f7ab7f2f1282433c417cef0709e1ff918a4efc4257810bbbe2b8d03e0fc5a529911bdfb210ed35a10e087132c0bb7634a7e3f7e3b81a5878fb6d0eccd7f488a38750f58f1586ebdbaa67baa72d1b0c7040dbaf2ef8e4b9ec3488fa1417b066abfa5121698ec0b42b427d274ea9f9b20edb1c0dbc04eaef462525591258d79b88e5850d6f9d57289d52682927be0d99afb551fde9b77c0c1a3e84b4db75422f4adb6c1bcf348abc4466a39d2562094954ba051c060fe3b7b30ba96537768c625ab83c158693968e7bbee7ba57355b945ca885bc6c48a7f82cd615a02c9bb96d589f7c8b7e10152d749ad8b21fbdd07b725846bdbafa99c40efb3cb3340bc0b984ec1135571920796fc4dedac8054126975b1fece9c0d96971fccbc21f6b6be56ce6973b660cc778d7833d4d05c06137471102d50aed14c84957c43ab1b16f45ad89388d0a878ead3f333f740fc6f3120f8fa3dbb2dce6a18ce7285f744b97450eefd64eb665dbc9ee39ecb6a7f143afb6f422b11455aabc6d3d454fbaf3e7eb1ad26c11d58ae67c146d54e1fe8f0c8abe30ef95fc1c29acbc9a82334482eda0a712ae16cd4740b2d1ab5b86b36c57202e3794d5def7cfe1fce65eb33f8dc249393e0df62af350bd92bd2d94ea41ccb33ee96a34e585ae2dabde1ffd7c2c5849ab43c823e393d2a4dc51f6285a8b0ce2b90eefbc3eb2251944ea411eb95701992aefc194088572194b23b69fcc2d275f1c70669da04f518267485762f3fe1b8463460724fb415cd366bdf95b5a519e68d5530dbbc062a2647e4f130de813316c382ae409c241c23fafbb7d154c705cf3918c11f744593362c0e413ab52343b5c458ff786448aedca15559127d72a84c638e29eac03edd701223bf8a072834da3b4637e14e097802500386279324e012015faf5d2ed2c1683317852d0bd4ab1360ed2e518c6bc4e1635d40c5076e74815245c16135d45de26857956b3274c2dfcb9eab2ef58c010b6300e152d94c7b6baf36bd280030bb0e3ee83fce915de903c2def925a00970a2665638500080b54e32a108300430fa21f4c2a62de40afe6a8e4d87223298f638b678bc835fe8b6d7de81c93a313b58ca3872bc9f0d2a8b15a2278513029c99d51ebcbe87d1738903ab5c2802884f66d79b0f4108e45ef208cc2a5f861a20361c1be32f673d40a8a67149335f72fd1d4f86b8f2d8b2ed9b4df9aa726af8b31da2b0e01164a4a7e1e349859d2ddd7eabd1e84e9606dac314a03cf16df0db78aba170a8ea843f735aed43607fa8df34e023376d6b5f04ab4bd80279294147697658b7fd94310c8b2a2d8c6496d9bc11373fc224c96b1247ea17b7e5dfcffb6eded83a5065ad901ab28dda9ab50fb29e2b2d5c28d50d433c8652e9d09fa8957273c7dfcfa1d15ae6dbbe1c7348c28b521daa5455d5857b8918515e058e01eede58b3122a70e77c2b58fb8a8e7b44b26f2c0a0030842d7478801e084f7434e1c9bee09dea03c2832373d0a86e91c4d58e0d84ec64a213a5c18dbad9824beee74fb8149a3f4f8c51a9347a87f969ae8ab32f8fce6aa79702a6c6fc8b77a9e2b7fb51b39f4f6d6455fd819aeafce78048c52e14848b6b38dd389f416c551234d6ed939df67e4bb2297432f62990627867bb196f2582d1d294857a1fa55ca419925fb3f76a294a01f549e0c215e0c61a17ef594b93e90dbb4e3f0794b16b1922ecac7239aa52a0e4a289eaad154731380f16281f18878157e1e35fdd78a97af5042774fd80dc8181ed4cd29002c154deb4756b8cb78584eacfe10c80fa7b346ce045e85b35093c674080a4748b42447b7a9f089e9bee78b32d53b421d357eac7feacc3303bc5d079841b51b7aa2693ff9d6b8303b90eb72aa7bed503f64e7171cfa53bb96c3dc9dc798a3693ee4c98ade95fba0b277443a571b081eeccb8f8a7b981246d4741740fadbe2a8f4e313697f9442cb102835ef740ba4b6e294f40a4de0e3b58062a053c90e26ae25d5a4106d6fe712a8961ea3de5e856247f339467528f03a56099947d538b96f7339519dceafcb02135f2b542541770a2ab8d791ddc2b9eca734820dd83ce894e19def412555986cd583f2347cb7ae855965bb788309e2652f2e8ad97ea10869d88b6167147aa9d88e941e15d4a2cc239a816cf745793234a44c4c7e25d0ba6ca1f76710c51f51c3815f507a2bbf124e92ca063514251ab86cb4e3da234a0647401107aec56bde0ea7195ac66fc8c979c616c012ac8fff1b920af693fb533212ab483b5706ce8cecfd168b56270216d963c7525354ac4f08186f0c1eecc64065ff2775049bd1645c94ee49237403be7ab6058fe39fcbecb70618892c5bb3b67834e2d86c46c89365784785aab65dc6a4d9152cd777460516bc9f4daee3a9cf53b797a72c475ce5ab079a508684d8024f8c247c595c0ff282086ed4c8273227e59775ba7e6638dcf90cf8a55e68b4ccc3f6d220b86d9181d6dec046ea5924262a5d65fd434affe62f35b1c91f07c24f55fb8feb17cbca392040ed97dda163118c88badfb82f83c15883699716ba36d7a74b077bc4adc7474e5c431680c00d2407d856cd1d98999aecc5fcb807906bf2c6f628e98fb155de008e4b7d7c009f692553f1749d14475b81320f2000110f43b189b865448018b74710d8a7df3a2dcce261383cbb97f8a1f99e6e0d4499c06d3b3ed9bb20dea6534494f2adfce4c61ab796a08584f78cdd15bb49a4a0221713e0ed85f72c1ff5fa50e0e62d1ad7f02a847f2d558be2f90e7d74ea9e0acbbfc16c768f14627cb2b9888b02983b616bc7f14f77e678b5828d9cacc73cb65ca9b464a861679598688f0e3539a06ae97634c13bfcb6757e1fe1a9de0663e891fc31e99af02a53bc1236fbf1c7b4dbcf4596ab5c68d59cb87d59057d5ad2af78fe768bb8b98add420084f72013c4b3fa2dc3d78d210c9ceab282deb78f8a464319fd885f291a6d2569b0d68db510cadc2b85411cd00ccde009429a26c4faf66a419bed482d3781c4eb6c0c253281a3d56648032e792f3fbeb07c11e43ef49ade8d4db24eb3ff6d870c37ebdbbf02dc52a19933ecfc365576a4bbbffa76f29f7130a991bf901879fcb544bcf8b3a05af803c5090f3adbb080f7ac90df616c2da54c1265615fc224b4852b81cf381c6c689d3320108c1c63765fb5b671e23582231df9bed8d9ba02a62f13d45f129820cdde22a19d79c8495088a1129179ba552138b9fdaa8e42b379cc17d46e4c4c23b90105d12fe0956d17f80be277a98150dce55b647005652c5103f77b3d566dd2e31d660695f2b18e8af21ac88aa0c4b74a17f18257fe9bd633dfd7886b76f5bbe0264d40a296bdc1966b644b72fa2502e8788cabb049501796a5d38e5c5501cd631237d80b0adcde959616521a74fe5ebf4d3da4d5a12a3f0207244073aaa378a57bea89ba64fc6c476c97027974fa6aeb5257fba2c262ef46e9da7cd6ff3c954a265e3fbb5703d7f4b2efc053688e6b5cc9227f24d17838b56ff48386e7a86e58624611b0864870b2a424de9df0a878c13fe7a4a2fdd8f365467253816b5048cb24a94280d844adea23d4d3d01a614652d9543797aa36b686d6cf5578ceda14cf430c654cf82160827dcca327ac7d6906712ffa0e22d5465d8678e46f426df53b321726d18e86ba3bd234a4e3feeaca50fc1fef065401b84b2d4c9ed7c740f248d07c7b68b02962059f85b1893bf90b61230ff84dcd78b6d761292db0fa06529937a8aba190265a8710989f8bac672413caf7d64b6d7c8deb67bdd1037125724098cffd1a6d6b1f47894dc4399a5280ecf0be9516d9be8becbc85e09c10a5b64df5b9015dcdfa1297e710ced782ceb1b7e1d8a6db4d0705b97fea14a10d7811e94c52c0315ee63580daa5e141388a2bc40ac32b2a0fa6e20836429a3ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
