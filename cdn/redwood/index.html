<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de8ad87b9c29643760107ee30a1d6ff520003d4e78e0e6a3986ceeb078e14611feacd3f80e712bba6c595a342e2467816a021d97d8905585845feb12ba157061670743a9c80682830ab9feb4a1900c9ff39041e9aad64488a9817d28032c3088c39424dab950f58ddbc28108ef685538f321d83e4d66444b80fb01c28232e6b9774a6585a5c43c9947bc33b2b86c6af56490414ffcec8bd824884cad5ec9bd29e31400776f9de55ceec68122d6e5e5e1275aaf6faffdb98d71c79ac448185eee3f91611e4c32e0e08b23ed953a922ca5db422a249e10052bbc700bb883cd8c8452a76fa5a0f9c02d0cf85fa4df2d6677689a8af8772dd2ec8563a610ef01e4b57ec46d777850260101aade506616f3907dd559ad25bd94754c9a8e0e1000378f08ce6e74ea42fb9bf524a394d376a94d69e4aa26b053f7a678c4b4ea3100048a5db9c7417805cc622f6ff713f93dc2cf9494cac9b74f6897b83dfbd3717370fde3f80191beb3865e1cc81734c1a009b5bede9c5d84dcd504fda0c51387e8d87e101ad8f0458b3d2d746cec60e10ba7578b00ffb5a77d129382acc5f445e54dcebd4df6abe622037ed22607d223b6d987f8ce639a1daf574b651074cb120d8db21c626aa05058e50831105a4d033d2f1c8588a2f5273a9ad6af8da1a026bfb53b652fb3348369c30912b5e10e8c6934da4c32a6517072b8ec8274685d4deea615c05c74ba4e5b3cb5b48263f9520a7450930132372000bedbb4d28fd457dba8b693f20843209a117798ba7f1988387c21b218bf0c9719a6b0dd835e6bb2f5c2052acc32a4d4971630f5ee56694b70c11a70b2c6c29d5a06d5b2b6be0d5e5a8cafaac249b8ada7746c9a2351bc055bc1c67b7ead5456e8207798028bdfed02d5ca953a2b33b95aae623967b956d118e7c11288867e75d73dc193d72357b9d32e9cb6b4c53a0579b9f258c82a6909121dea5183dce6e3de710ca5aded14033a0fd73993371fd2a9c0a3b3fbfef332f58aab40f6432a6f69fdd81c4b309669f0faefafe03a3d09f9f22db5a7bc1760a7b1feab24e9e3864e6ba7b1a10d60aba6dfb66c6ed96f68bd3b033bf476f4ebe206bae090f2085edcf7a84d6595cb8c6852d37191c244ea817c61b8f0c042b5f1355f9d103664de9714bc949c1c89b9492ac557303326d1a152bc1f36aff0fa5612c2f8d2c36cc9f42200d32601a619977c623eeaa4937a053ffbb18434a4adf0f1c753a4b26b155fc0787d2630cefa3fa0ff1d947fbc07711811541f27db16599850748d77d1e200b8f78603a8bd02d874b80f73475368782c9aac1b0892f1281f1680e33a6e1a749e6371163048802af71ccfcacc4761303f255609033ff96e15b3472118f4c4795a18f5a44361f62d32ac9dfc0e498468e8966e20a40f8670007ad9838fd256113ca5fdf8b26ed2277ce284ccbc790a9446b0133ed77d729919f2aa21c8be308ca9fc851f46e841af633e73bf6aa0cacbf9be573607751125e9a72447c200b93751926e5ef951e628599c19cf36a52e642362b591942fd9a1fc6fcd079a4d1c37c171ce54f6074dc0d4e48f59c35176c5d792709b8bd06f19d2b5d52ef4cbfed1d7df433a1e1c8af805c0696a286478455095e39bc55a3242b605bf5f7260897f1c20ad2ed84331251a57516de560a3f0717fca121d5c5bc25b1a40a651a5b082ff5a1f2e1e31608e7adcfb5a0ce3835983feeb7ad0c4a29fd687879e2b094d7f32b2d046144f81cbd43253b3b5f05b653ced694826d86caa924c00f3c4d7c2e60e06eb2d79afbabbc30f5641b0c00065f3edb2172164696bf567b06a826b37d1436c347b98ea3a648d5dcda1a038fc586038ed18ce3ed74dc77490594c547f5ceb054843258e2607bbb6798d702377cbf03f802ff916cdd0900865d393a72a8971d08837ec84032b5e612ff410709aaad734e3833ff46eb0739c1608e74a53699f82f165de77cf2e7efd0154f82b26d408a9d4fd5d821f362b4bce1b06c383f54a555a216b6c6779444852e672213dff3f7419f393a5ace1c2cff2b0a29d39a16567d88f457c365cf2d534796f12ddb077eeea72c7b9281b2b731354495d7d40e7b6dae5a12be583733aac97698704a56a654c3eb249d17454a723f0bbd2d1cc95144ce41fdb4138f6a9ea7e233271c31726816feae6acee88b238a6a3372432a41622af26a8a94c5e36330c97c5f3236163256c11943bbb4062de7eef1ac2e86c238f67e8546875419a9d6dd2fe416b8833551a008850ebced262b83e4bfe8b79c1cd4b92424b89fa831c32c113ee3e51d2ec0c42f614941f1a9b2d549f661d6552f7fdc7ff90c321dd8eb85a1116e2c5368a3ac64cf92c3b4bb9e2cdcbd77476191a95c42f70bfce05b5a91bb24853fe5a2e280985e60b166fcd0609982ad00fba5c7a8b58f158a174c866c4f86ba4a813c167e06fa5536e347763c66f3ae82f622bd9301a0eaf3d7f0066de055ab41ce2322b6dc7eaa0f7594ce250363e2121aba8e678e0d63ffc35a5c5ff7fc9a666a03ce16f9e9b881188622ede15e8aa545e17caa17cb5575c526efc0ec3d86267930fab3eb36d887db8f749784c282dd3397b5e9c9ad1c69f040c2f29fb8713bbb1f7cd5dcb2edce816069a202ff9a3de6de44d632eebc80bd1e834c23ded412031eb9712663409c23519eeaa683cbed492a4e3fc9eb16e17d60ff74489ac679c7a4de1228cb4fca023bf03223d88fd2c8801302303699bbc5a2dc58089af339784c93f6190904e2942762c0e2847c29fea6bbe6629236c71eaf72c2cf685466d4d2f9dad088ad2b481a775f1018a961d50df5abc1fdf727460b295263a03d84acd2719bc69e6656ec2c361764373604f144a9dbea46fab3ce18f24d21bd7406d533706385d0a47ab455e136c918e020d134117ae4ca2654e3b658737a446cc70803d54b58d24f0c66e6e97b9c42e4d31ff3907f074922aa0845f995a640f5e81e6067a60abab20ca463b64c7a1b44defd8e3e759e441644ca74aa57ac4be6383d8d4ba9faba3764e17c632a51bcf88f3b5a9f35b4f6ee16ac0bd9686fb669bfc825c1390e95b06ab6d3701e324536acce19608a852590acfc61c3d3fab5e173924180164b8c3bc7a49e5babe04cd111753ad8fb3bcc866fb625a24c7a8cb9099b79a125709dc3f77d62779caff5b46d09c1074ee9392bdcadb92bfb9b0b2319b42cf9b555a4eac91e4ff541f73d2b06ec95967c7bbffda28585af8e1db01a67f780a81d2ecb2a891e79c816bb6dfc018e5a9dc22f8ef872ef53627c689ce2ad1fa0338445e5915c47c90b5260372b45b1559d451386b846b01f4505404d38ac5838ad1270468cba9a85ee8ea0e2324ca49b1d5a1cfdb86f2809c9a583b1d92be95dfecfce247b7e8bfb881f8e91623b293b48e419e2110c46350543a36279c2805efe7524ad7ad3e6a7b76a8625bd493186f84fb3942e3df7664c975047d1747ced702006a706e67fc92940ffd028ee834af282d04b989772fd9a9c159f1703dc8fe5861c83ca7d7abdda3e07a5fdc28093b1ed6c26e6891172a022a5bb66d77f5e7a55487c555a15d8025b5d5e024047a5f279ea8e6de455a440665f507c718665bd60462c023ac0ba4512036c407be50dc31b123b3c1cbb70d768f1a75521e96589f19ee2dba8c73fec7c4c3a9bb501fb11f714fbb8286210e2d6c68a2483f16ef991a681073390fed75a2a58a2e260929692011b68d6e43578c8a83a61c301a8e9c54c15baab134e2e2ce5a0471a533c9292510a115d45f84e4800405c36989651215fcff216b7bebd95400b52f840a0911b5fe885d721f12c52ec8036a1bd80fe0a62bff34b74d7c1bd5f3f962feda2fd68569a5773606b63ea5c8d9cfef7cef86ce9268f6a0494fae36998acc44baec98d2c1ba0ee22abfef73c259f6bd2c0b1ac3f3e71d1e72bb1357e54dbe81706796a367d5b67e86e9115a74ae4401c4a88d87c4af780c185627e4addcc4a1a50eeee380f8cc6dbf9be282d86774c42e0a477f368989e5f93dc14e3da5c5b3f3fb608ec6cc69b9735bb25256729dd29df84dfbf728dcf5ec2daeb64ddcb61bc09663315bf522eaeb97990ae906d94e8b860c6c8fd599b4aaf0b80c277f0d0b2864486cbd4e2bfecea686c24145b405a8004944d14ff2fa0c2edb87304fc13a80a6d36febf7729d14fbf91c99a5cd8cd48d8865fd6b29c454435c3f1b39c5de48a23297696ead2aedb08a63bf2160d098775bceea07696b66f5739c97c002faa249f2b5f2b9f5f56a02f49cace7270932b0c394c01b96bcd7ac4346f1651de97c2b2fd11c2ac70098769c39712b51ecb6972700fc0876f0e86bb217edeabe5561609588e2d55bda91e62f2d83e865b1e2de54b154abce1798a20d1db6f8ea96244e2935cb1a1dd449d7dccf76e680427bb70dac147d9bae54a7d60cb5fba58e665154826eff838256c85175f5138cd376627b68ebacf6e4c020564f0f0be853f180a4d71b8b8c9b1795e30e972578140a9691c38d60303dcaf10e85d3c839f1302686aa84fbf2ab5e6e3b7abba1d77de2932248b8db36e05d03c8902bf578d8ae6520fcce0a675c04109d4e38930ce29bbe0b204c58181adf1e71c9c13db4cae1c684679cf350609a00568d1b41a325bcc84ab7c1031ab6e6ab76878152210a22f13468f6c752e25e176b4c9a429666ebb1526829fe090878870a7d1c40491e85d2c751d6af90cbe949901b95f31a8cd3178bdf9ea280a34eafa921b0d17e38aa8c7dfaed759dcc13217de835da21e01e30f6be91c73551141334098dca53b19068f7de1a1c1c7c5f6c9276a710a7cfaba5785d5b082c6765b37d9c9b5047d94e6253ae30663a6b91587c945ac54d9813be7ed8896bc0daf054760465965d9532b342757becba7df7fb2efa07661091be1c2b39aa9154afe89f64d6626579201833efc29b16ea00b22c0c6f4f79d6c4c7342ea03599bf6b6b232c5eadecb3ff4422471705b56d609d674a6a1b30a2cf86ca5f1bb5a8044891a7960f5edc0e23c82a73b724baaf02cce981fd7c5596c25e5e45c772f76a6f47c12029c9b68a4d8849f9964a09601c44518e9bac5fd173f52bd27754b2dbe4cc875162f534e3009ed3557c6049b806d8ceca4acec56593d3920c82408b32b4c191cfc4fc3cacf102019b1f63d1cbe1d404ad8be1e8c8d7d7225a4f4dff6d8ad087b4755be22e98a83874d4e1f62bcee03ddaf5da0922f70be8a8e5756244e24ac3bbd0d52cd2312e96142665f48d2b4519e3fffeda4ff8b6ae1f005c0f3f0992594cb1aee753f5e9c46fb408cedc7712d7c552f4d878ad66115fced053f6e09eb3c2f2c037eb9f643716b43a086cb55af6b78726df2bdc4280e6a99937cd62b7ce4965a52eba42476e562328d00e9d2585e9cbe3da43cb97e05da0111f85a2bcec8ae262bf4609e6357ba4cf85e82c4a97e73a0110a1db8351b2fdc6bb3e4c69a2387684b6be9e230d9ed0ebaa0b8c1db14edcaeb768f4961b17da3328fc8ef3c98320fc813ddbbec5ae52d350b7e6295bd73b124695b15c53481f19af76efa9eeeec58d1270c658bde2d36ba22550de8477c159ba9d726f80bed8a86271bf96c0da2b9b1753fde38c2d300207fe2feed194b9302aab0a812fa4f5bb5812e6db2c53b592ffd236281d0705620889786a6cdb341c5aaf2812227596986be9931d55c8c7fcfdf5943e24b0a177094b1ffac8b2df46d529e02ff7d53b5034001214818ec9d85f6d5b714c8ce29be3598b84fa5c0288951b047ed037ae248777b5573f93031e7281cb094f687c8faf9f5a94b69df7e8bfef4d5d497175e3633d62258338b535442c90508f48d5cf2ede1f71b1f30fc9efdf11fa55647ed6392067302edf0ab58c07a93199408fe08f6950594237de292b506eda54a1566a266e1a8674224a985e9dbbba0e4045182ad8896f0fa252db13be18403ec6368b174d53720e2999af33bfe85feb331a62a6119b2a39abf3cb3a6ac5f4c8b7a18df94f1bbf43c235c2a6c56ecb877fd024cea3cbb642c6a707794412d3580de0643c54846c8e39ee8d4712cde0ef7add05487ec73a07efa49478ba3824e7faf880918352b6975e756d3f61fd2de943f2e6407e3964d4c10de4a0c1aec7608904806bd845153cfda3d6a66a6f7dd683f25a64672a05be5494c4aa932c0c51552ca0a158a312fe13bc5c62a8aa07d7cd6bd974fafd2c63005ab15c763ab8c02c995283d1ea744809eac321fbc11e03c3992114e3f60fd746e26568c54f913b2404b72833ada5d5f0d5d5c472fd807fa015248dfc321a84287202398ea26ac26ce18fd0d66f5df5119e8411e10f2c93cd8591d7cdce80a049a01dbee2ac64b46e8ed696585a633860085aa2d542190ea1caf04f1f78210be0bc41e5feff23ed52b962f01be050cc4586bf8b7bef331a24f30bdd0cb3c155b7d034484729ec663f5d7ea04c901f8e241b8263bb50449124b1b81e9f7e54c9e38baa9570de287fbc9379b7f09196473ee83aa18b213fa5a99d7d46202745ddd40e24d61693c19a454dd65ba164394b3b0741ed59bd42e1a0849ff298aaf6f15fa2136e6c718ecf3a820a7e837a284e3bb57ecb7709da2ee34de3be13b17ae1c86816a89d455dea7e173b9a234a1566a048c25d333eadfe49115881552135290d87f6fc6bafa9c66a3e68c545ebd76a25508f9efdfa9c7f9f66fe96f7db27b8814d622123103e640507eec31ca124cbade5208bde2aacd105e57abd78f8f0bedbe349388d88d0b297031a30bc3095c4565ffa9fd5c65826b88f5df2957eff22e5bc080e351c9410239e1a2e94cec146c7377273e05040a0c48c54552e9a58f69c179d5fb2cb266b3e214560b43cad4c78af7012bf5c9d02eab14a91c72f5e0b5c2b6c8e26d6a1f86c0f3216aec9c932f06072e3db7d9d2b4386734d341038e0d0b20182900c40439708c1d4cc697e555e2f9cab8239f9a0e29e46eb8224696c712327eb61395913bfd3a7488d219079b60b79f41da7dea7e5d100a78648d3bbd7f585c736c8722a81e2f45ae498165642221538946aa1e43fa43a2657f9bfa58820c46fce49c6cd2e43f2434cfd76d8573ea2a151a430152841383e952b3f2918800fa87735b76eae6c2b80950ff84c620a58cbd6d2cad49c3ce17718099233421669f54a24a7107ab0e338d8365f0856f6123fd0e0bb00f2e433d70d37c324ddb9ca38c10defe8d519f03596be9758d807c8407fdaf3d6f2efce140b777c0cd56adea0cff5d9fa7ec92770918b66d3e859f4aa340a82de1387b597effdc106cf56c31e94318e9a1d67715d91ead2ad69cf05fd9f3733a3c33d9e9095bf8f1feb268fa8a92e4512dbadcc832439a644f1e3b2152eeb2b35faf0eb62ae0b54879a2af2d899b5a730c0d428b580237d2a298050bb54a9413afef1a178e7dc9bacbd47ae25f0ddf06e9336b876f3fce01ae91513defb5c148ca954cccf11194204407991345d6bfd264984b72ab5aa78b34cea009186756f6ee030045e5a329fc235af5b09cf8d06558726f1dfaff95a13afb9625f2f34c15b608ddf1a81832054b5a34e4efb80a8a093fb60be8cde62437d64ef0d9b47e96be4a664ec63d7f2e8e372c2de45ffc0025dd41ad950f399ba32441866661f78a61e2458a98c6e6377161dfa34efd96991dba596cf8d7329e800e3cb693891620d2a4c52ae36761e25da2c443e8b37a00ce14859015839d7559e531283cd595aa8e88f0e53339574c403e536e65a703dac786dce2f95b3bb280770a3820d889d0d57c767b51c6c09ac8b282b6e73eb1184284777906620a3dbe3066458ed6a90da705f01d83b53392d3be1fa6cd39f234fd70277eb9a4e23b003a16379eb5168d34ecdadedf82ea0247a857b9c8b437974c31676ddbacba8057cdd94e81ff70ec52fab1cf5fb73c869792cce7eaa0379ebcdd23fdffb93d51f168d2c7270b8d5ca1d797a5c795c3cd91fb268e2d1a3ca9e114a28af009a55bc1bf34ce10d658d1170eb41705ac93cd9fb502fabd2ac6138bb2207fedfaffd01873f31f54f6731c9e709cb4e907f200acd79b5ff54ad57b8d1ece96bb352cbdb0fc581cb1946f7e623753c6f73bc1aab30aff5c6829f825037ebdb61b2657844e000f07476f62ba218b0454c2d84c4849923be6a20f953a2ee116f84f4ac11691061e8d73d7d7d6570839087f2f96c33db35b27b63383164b41ef0735cea57ac9d26eb25ef05b20709db46d14f7d4b1cc57d6b2baa045a45162a31b95d4cce1608b47da2d382ba159aae3100d83f227c5cd78c27514b3540d7078ccada8a3eec106d86c5d0d4f89ab9889497ce51a0a67cc754dc2f6a124f0b705a78d8676ad49f5a2ba65ae6b31d06cf81fe370c9231e4de84e251638277ba3cb6b0c03714327472eaa40893051a1ca8776ce227147eaf647aea66968c39186f6c80493572b743d10ae0e7ab90fb183374f99523a18cbfe840ff83810ce1a6cb8b21e7a82622435b1fb4ce57a8eda209e551de77b6328b6d0b7bb0116764f4a60cfa1b2988cbc659381a2f8ebc35ae69fbe626eb55a4db0e68445e9786a7a1b91084aec7def589d1812592445b1c5e181af70839a0c298eecff753b18cb2b0c6211007ede8930eb51c18cae0846382f7aa76e7b33b8a6253f000b11ef956704d19ef3f9c0545b6f384558c1208767eee891951ebbfd646ab7a85931a1d98a9b31fac859fdca734860274d985de93585a566779bc7d73e8f1dbdb8e979693385554f510ce54b62949705eda9e31c8698eab154776c28892963dbd880202f6edc1e3a16e731cf52e73f7dbc052a4c92da60331128df50ef48bdc7f8367b2ac8ce062915501287b6516819e3a1ca5cff17fa7da80e733f890ab3e457e3a25ac08d4a54ac8621f115003c2b5dc776da1ffc98deaaa4d166a290347bf431bf8cf2434c58af08141600361f8b2319955b7227b39c9910b9830bf7445c584612c2df560a576e718c453e043e62291dcac9f9a8887be1d869a8df855cef8af559346fa10f0bcb9cdfe77bd4834b81bb5560ec2424a88fc90bda0d9371e809df5e52df42392d49de99be4cf84afdb2b28269ec5e6b27f17b32822b799a0815da4933e626f6827eb636e81fac33bd5a742930a3ed6c7409160d4aa921df7148535a776d796579003a17d1c3c8d8ae5aabe20213f318951ab2f54303930e93684e511aba6aef5be2ba7a25a3b81f4bfb0495bff241f858fecf4b93580a7ddb3072a60aceb21fe1c7a553e1e870e9ef831f5f35f2db2dc4d2a3bc025111c1dfd31e01f758b929ce87048e313a70874efa8695c7a9b77b2c09c377b57b828aa6958f7bfd4ce08f3db24be37fa62006dd061347dc49a03390b1a83c31a59a97b9a25393c764f0a085a769c3d8aeb26beb7bc3d03a839621d3b2c6ec68b0a929cde0952154dcb95d28c6d397c49941dfd54c3ba371e93b25f372332a3c1481c17898f9b99d2505bbddd55702317dec63b07c751a0108c049283dc9c8a6c614a9da994e530fc893f4231ba3f6c062337599f9a00d06eba37fd9d3ea3ecc3e1f1a84fcece6be02c421d61cf5d83edf128d7446ab4fda2bbdd5670ba3edd64a5ab1a54f74855a5ff229b6d272b34e07c39925975f11d8313fe161e270f56dbf03fda14bf686b3fb744721dfc8acd4354013eb92d8fb6e05f8128809483cd61b73f638f2f427eb595b3c480ee74d41c3d4c61d35750c850bf4b3da8da14f1188e29877727329783a7f3d8245191956d5901c6b5e57f239f362ce787773fb229aee2345c0cfe30c69957f6a2901e1be10addbbf0822085c206ac432dba982a6fefb19502499907f22c08cdbcc0b7959dbf442b505228431199c8f70a4fe88d157aff9193eb91b102333e2e6aa3bc3ec3021114f2cf4d26bdee3a17333c3d961d2c63ef9e8278bd9c8db16858abab015df0548582a5f5f5d402b318e4fd299c6779333ff274a0684c31502b37ab3966734df24eb2689b3922229ca88bf9b70ac4ffd116cb410ccb28e1e940d11b0b6d90934ce232b4d6b76bbf1e6071ec61b04901326d3202ad1f786532bc25f8e2ea3272c4428b9ba602301222dcec6d0900d0ec60b7af583c6e73d56b2fb4dd91d38b7f053c7315131edf9ba0f1236a5e72143db79cc998f30ffe7283211693a5e4d701445e6ddee8acf36ebcbd06608b519b278faa614cbafc90d9481b98194a9eae30a39d6ecdbd20b53a641dcd963a95372ec5f55e7c5e160bd034bdb21b1ffc31ee8b0d65deffc123c6893df65c7a18de7a9a1042c5c9f801c8c1f5ad31ab6e8250f22327de083891e17caceb5d0cb2e8c467d730292251fb050a86ef422e887bd8d04d3a6a9cdff62188f588f93dfbdbae1e81311eca5b8125df57d54975c5ed0ba83b262e6f545275940df06036d741b33adcead338c87eb53358f1b892920a3a40bf2a31a2ebefd0fdad90076f13a48cdf8ec308468806e5a950945c1560ba4572d4b1ab20f0826cf914802d144757dfac941fabea4de2bed7efa88631e1a0c961baeaa5a91d827493ff085b8f3039da4345347d93f7e948c6c9db2311767837dd8d2917a1ddf1ce179cae771a89e5f11f4d77c2e7c1cb42aed4ce9dc2ce56632ff5e2009fe86817752b2eca162a2750c6b2143e9d014568143de0c5a16048b55a8a71578eaa672963570602034ec8874772607ae2c9deb466f1b875a78ba218edc58d67d79d513c2459a7184bd6c2322418e7112aa5b4ad9f68f2d9b798164e2ce604c4259dda2bda4055126fb9ade24a99328da6c359ef5059c9bbbe8691cdfe587d74a42de934c366afa87da2d86034bb63523a6f3ca79dc93b7f1ccb7760aaedcfae25d6e92efd7fe077b22129a51cbd558e7d1206761a98bc86b30e51f76ec4afa44992c98d47f2562fdb58dd0094c7fda95661f3c5afb0ee552cd6707f0b02b7fe2baf3d81581b8fc34162fee052207cfc91cd0a21f7bd7e7921683bd5a574fe235f2fcfc7d9caa67650eea97d415a93bffc9e386e48af1a65437d67dbbf901edb3d5a35e8fc847decebaa5aa1320aff5474995cb45e4e1f8c1f5d9d1406f07eae74067e75adb06406fc932c2844d392c2b482e9cd5aa2a55bce9f3cc2171a2af77f4a0061a06016829a22b1f33465f6d44dd022dff195685b1b34971bac268d6696e69254da0efad2e2c8386f2cd86a3e484f07e74a987312cce8ecea5be952b1c6f1d6fe1cc3db4e079dc0a758721e4c3fe21758ca99969fe70c5abecc97ae393113e50b2c93d976cf50cd52776f440cd42945884180a1447b8a9c0775910f476bc0b366a65e2eda7185f6ff21e04543f48c3a73bc7eca184acf4a1fe598b5f0baddb284e970dbb6d1705736407225f5358726d13617216f2c93517977c0fb94427e3f09654c90851b7748b22595a87ea89db2db2bfd48b18853904662555a56e3f45e3e00ae39f270f136a2915911dc3f2048d7f7b8d9ca7e108f06f3015c3fe2808146957f0ec8632e97f427a4ad3cab690595c7bc6375f0f75f5fe92207a5b1933b9b726cc28045529f35c0b980892cb15860622c4cb576e08e512e038ee1e858dcd4dd55d169c223ee33c29c9358bf8c0bf8f965382f43c38e8ad2a4cfb5f8b0cf1e1820fd662d9e8732fad961a61a50a888aa047c6a77aa6eda364fca965629bde8914e86782b0625258f7512d542503af016927ef6fb76ead344a3c1fc7af03813c294b4200c5dd72a63be7cd7d2b660384bf80df2ae6f000bb5e5e23e6873db78e400389133a737598828d0741f45e275af8597084211271551112c25f4ecd9a26e91f4986c87fe4bcfcfa21d11c03fb54c8528921e159891e49009efab4874b822c762d84c701f550bb68b518a04cf246bfe72295f138d993ff96b42326ede2a86e3e13bd1da87b06999276c3a075d79c27a71e5b8741546eae0fd29f7bc10c203884bee7e575eb51e50caa6ce40d0d5d69c08205e24f14e2a5a2e211cb4706514b69b7fbbff11f04ef76a6029d6cd24b23c5905197debffe51a208d12f9c3c5f82005d8c53d3531c16410d08af9dd04563d24eb3e3f7f97e34db5ffe5ca8b85682b4bf3448470aaeb40fae2c386dd4a3c412226cdcff0190f6b8519986823bb514005060f64631005b0e02b76f472571fb84c1a4deea76b11e6c6f8ed79833ebf4c4c6427156038037eefcdc48c839fedcdf134852c833ea31c9e7b8ec78cb57d99df059d1c2df994991aa265aee3a298d9aa398c4a4a3f28369dada8080dd399d11268767278feed7e9b4b4f3fc39ddddba0390d05a236091984edc126d9efd34d9056a9df4d86bf7ace8dd12928bb1e5eeb40fcf5516266a6a4315edc01bc45d01566ecc080019625dae471f272f1c222558ce7504629be46f112d639663b37f49398359b45913ec95d3fc910c378baaf8b8afa949ad41c4822722bf6d90a09e92543f80b0a5d05a91ba6c0d5267f184e8269bd47796b50946367b3d5b57d8c112d53e153d62bd2bfd4bb0cc0ff9bc26868c243cdb0bbfc6f778188d62808cc15c1144aaf1a1eea16177b8dd86d61ec9561c093f820d92760191685a0f16cc15e063287c9c24c89933a170935789eb85c37f62797b1d44bf83b716b71b10fcdeda5bc45f0ce42c0c033f77ba7dd651bdb721f41bccaede001b64ae7c7608a56592d06e57bc996d057bfaf2f2c805c08321028f6907a2be9b16090cb1d495c9abfd4bcc030f8793c1442844c4976ba846a0e2f9f2c91f91d6ae4cfc00b7c438a2cf6ba615c031af5155b58da521ffbd50e1721ea4a2a9fa718494fe88fbd3a5805d05bf110b252e442f71f06275f6aa0089295c7b36609b4b4151410e1499d391b18525f8843db8dc8e94e7855cf7fffd52c226ca668dae6c55119dbe0d429422f7a191cdc22aa85835680d666f217bef7811b2db77493164ff7b657d2f0d8edbfb6b9a6dc3712d94c9bd99cc30229124cf73fde8064041e0698abc2f771b6f558b2079a4465f147d268ab9dddab57103125eeefd01da1fe13b15a9095d9d31f875b8b0329fd5acab21c4ea775e14bb29356e7cadcfb4904e6311d6c5a63e1ff1b78e8a63e38e789eefcce4d9045712f635c2ab7552928710f321a720b276c0b71831105c1ff413c683d66b6936db2d1465399d2c8fafc56b22aab0864343944ef523ab05719b924bb78f2c41c507deb4497d7912438634462b04dbaed3585f53a2880c7999b72cc2f5882a0397471305f37d678c2d1e08a33f4b4e58e1d8c21d5a2bb9138fcb5dcb8eec7630c1251d7e9bb7470ff18b2f6cfdfd4ff2729343e7f732d2ab9e1d500cd2b4820a9cf6db1ce314c1a5dee699f5edac43b23cf3a8c47c5622e2ff49bf8db8c3824578f46abeb9e6d02e80c57502f28d226d3136ae88eebfa270a34fe1c7b97caa71ce3f3e7da874ad03e5f5813a989051babf3db0c84cbb39b9ed5b190166fd58a5809438593560b486be69e225900eb531b1082068583595726fcc765b45bb5db8a523221114881aced8735285d698da56ae1157e0a89bb411f8412034fd5dcdbec4f2b487f20c9659a6c5d86f6be6115913bea996268aef35fbcf2460c30cc3ad5eb40355e5eeaf2b018cc7b931c5094b3827ab4c1756628b775dafeb25113cf78fa5133570bf82b306dfc2394c9d6f0982ba39a3dca98d8bb47a76642e85ff31727340bb2085033b60f39eaf3c73a440f24b1514ae7c71e74523a845de8b9bbc06acc6cba66d3940fd162dac91b59eeda1db788b23f2c4ea943532a480101cde94f397941f4322bb2d7e99bcae631b99000485f1122fe31999e42aa67f6d0d582b367c108c533decf5cbe3d7407c93efb6bcdd8647f73dcf6a1da1a75afb7c4a13ae1fe25b1faa8821af8a2e03f0076cf9bbaf75d37df5529f78c597157bfe3f061f854c8ddcad22b4fb1e11ab37a604641f6a9ba55219fdbff1571bc8225817404e265986936c8e0941eb2b9602441c628cbb8ae9737136d93dc080794df90d964f9ba008155025faf8576b1d25d7cb89f520561ccc0bf915e489a887633cbdcbe6a23a983bbf208ae8c060bf704028fff0631d290516d053fe4bf033b2be0b39ca87050f0751a1aa11dd6b2391325617561b2496598e0ff377bd16e0c4d7bac2c8a746c0303e61dc79c7c58dba8f10b1f6f936a09ad10353e370b00831986da1b1d35caac80d434bd529fbc0bba1361d8e3c882843cad1858911a043b4b5032d05e31d873316be5ad66131bd153d477192104db112dd9abfe0d88e76f07765e6449c3c9ffb28aeaaa7855c95f74f2f16e02a600c7ddbfac50d4e23ca75d4953066a85c092370525df6618f27c12439daf32fe2bdf06d8a0448de98094c59a15eadc1055c2d498dd78164fef4623033e1b10bf7b7ce39596af226118083aa6a9948aabc2eab19cf593b65df6826b7e92feb1871dc0bbafc122f9eb23345b21d2502c698dd29f46e2df27ebe16c904415fbc83ac42901875761f403dcbfa47fe57652dfa9b55989ddcc49191ffdb855af7888043073b3dd9d5218470a104697e53a4ac6699daa3e211ffb96230e5222f0826b572f06ff459cf5f4e98e935536c384f2f2b1203b22f0c9e7b644f03c47e040cbdc40a955405d401c5be230e497dd2ab92e764f917068999248328fe9ed7d265e36e96deaacf50b9b23c1c25a1409d1b0eba4395c68cb7c3b0d8e779eff0ebecc918be66528eb9d58515cb08e6f63e86264aa249cb7d3d4a93ef99fd372a04fee6e64633c576d7bd28079b22f9a7365231877b00b4f90bf2368357c5d4f84140c73db786151a0dcd571b261f50a106be8d34a6d5f3baa25037cafa52cb5e7859d46524bad446445f36c450c54b5a499511762db404e9dbe5b2cb3edbaa5440170b6990d08298330028312689e41f86444a05105dbb9026b8e08702ac1cadb5f2e5469a01305ca62b18dcc8ec98ff073ea1e7385ccff68313474f9675875636c5b0a19aed55c1b53d5c198fe3e41505de75badbbe4ed4ec25f25312a16e82b9ee85291c94d93664812dd322996ded4a8a76354d1a7a697507bfc970ac6003f5fc5e679de019b82c94fed65c3063a8b9c2fbf98a29f8819de8e311c9f60a4ba8139661e10cf6e6a7e84234357941f8c3f15012d43c3c35f13bf392b17d3ac933cc94f0ba1fab76378a6e36bae8b5f4c312d4797c7251f8f9654d541e9fc7fc728765028ff57e6d96c039ed86cfbfd2ffc84a35aa17796bfcff946af79427693a1d728b363dbd5e81311bb9e38779d05cae95877553fb0a779a27f903e412035c163e3b0a55e7c653fc8cf6beb9be9599aa84ee16b434b32764a5c0196da05bbdd39d247b6d9a39d39e319e9e9d2375983df657d90d14f5b2808fbd212f85fe21f27f290110f729996ece558f0df70128b52782ce167a82fffcf2328096a5c531b71f2676051447fcfe6d2aaec2e4570419a0e0e02b4294560cf8bdf85e924a1df813e489ae6bdd955792212af88b7ae3c47cad2d93d418044bb68e61cb23774f1217f50771987492ec602488f5eb5e004fe774741bbd4ae6d3424f1dc847b04b5b4777a394b2724b49e2bc3393138d28f2f7f0602b26e10ee87cafdf95778b89a59e93c014e766edc8090f8dc08d87fec644dc46fde3a412f1dec4710357cd8194b6a4a7f5df586b27bf979cf7cf3d5e83c9dc30acdb62ac286c49f0752cae321f9afd44687cfda513b99032b7b0d932b5fdb75ccf98118f13f456da2260fd2abb3e643f1f1eb771ab483b8d1555f81e4e237310ae42def2327d95a6b01deb7db79321e8e461145284b7b5d56951b98d1d7c01b78fcf3a92286d1e14d42dd619183d9bf58bd2495b80eafaf2dc50c210a9c55d7911fa48f24d2f3c0ff4672e5249a33ccca229f802b94b07af5859e1c1e9c65fc8079e5ca69505f1cb7ed9a1837367f52b4124c7afc7f0a2c46f065e23076ffe433b967fb838710a0382bbefbe42e368aa86843019ba6aa4c0fef84956cb88401cc38cb7f61ae60505af66a2b2715deb2a78a630b03dd76a24649de2cd88e0aa26e0ef153fc553845515c8a628b54f69e2384c0d80374485f2194c9c05ef8ef92eb057a721c75896dcc8343cfbd9b1b6a4b86e7b879dd5fc41bb4ccb876354444f2e271024b97ac488dbfed93fca64cbd84dec045829a1ec12b3eb1c0f8ee34469d27cdca138fb4d838a7a90e24343f74087b3b107fc89d5c3d5b33ddda90e192ec1b22bdc6a7577df9896195ca38af78607eb3e56dbd795a6b199dc874498bccadd58c525c83f50cf250ac93b639188340b0b92ec98c09c4b11739b3fecb838411da7d30bc2632f3f68d2faa0a0eecd27442b33b513d48672a77f18dddc29dcee1feba71cac2a6f7535da68bc5a9d7a6ded4503790c55687881793f55eec1fe8ea05ed16d3150569779998baf8bd7983a388f3540f8fbca9af74a5796996fa79ddb95a1d93641623803d806a8f144e1b1ede4f197dc443f45e00a517fc4ac0a93a7cbf0d8d4dcb5ae3ce2cb81e9f5e4e021620bf68621f8caa87ddd1b80713416a2aeb36baba77b54a53865b0bfff4b9e00671582e2951c1a83126bf62d8a53eb178595f16de22019b243f48105df15f58ce2ffd6d1e3d6d448d90910490775e8dc6e49a48617a7a4bb93bc1aa3ee89fec0a9778e4e5071db4428ba86cb22857a90e144b8055de4fc747c741a9911e557f929fe63597bea0087a74dcbd1641d30438efa907a61e2f25ea209d8fd9ec1928f6d5496bae29cc81a419706f39f9e9e9cd2ac1b933b94574fbf2ba5f41cd540b1850f02eb0a7e19e1f79b7bd66654c4e44c681ec77ba94d6f1293c1da6e825aecd47ffb682c4350ad935a9c911044d9e5e746c656897ea335a04365500038788942fc959354dad66919992811e4940b438bb37a096301ea9f4bcae152447782655dd07a93a3c5e84810fed6679fe79d26930900bd73d52665b8cfe103739a30da0356bead92c55be91e6c6bd3cdeca9907384fe03c9d48b563b48dc8572533b0c60753bf31e50988f99cbcbb11d44bc229abd1c56a5b7b0ade472db9eea4a4f217310e51240c78083c55fedc5fb67bc740c4fef4f6a3dd96d8dd0910c740014977b9ef485391623b5e5786a18a5bcf190ef1a8adc3e0f09a6994afbd06238c4b866ee932aa0ca79d89e4bba2074499bfd7730401184ff3b62a0dd09bb85618872bf9b87279147dfd5807a5d5cc8e1686b5b18784d8eb2565cc8fb46f851c6432ef98edb4f26db1080b5036bdf5db19f1ca3a0357114e2d4f2421881e16a43bd8f1211c8a869369169e3e8326ebaf1c9ee3f5426306063a1673137f29a1865c6fd45d965f16464955cea581419280eb80178eb2aadade1501dc7b71b06d40738fe48ee4f41919620e345de26c150a206b408ab5bc29e3d16f24aa42f81c272c8af44b1608156ee3ce06453dda3a2d6624e4752b5254054b0c15bad081a849ab5a9db76dede431401d707158414926691bf89adec3c36812d4c2b2362831b850d6fe6365cdfe97c9288913b3947c8aec83a37e67b334ea9f95d4c3fd4fc26e80b12a48d3a6914ec6835172fbfc3c2f8d22e46646ad550e6698e57dbeec0a90f4c99057a5938c36e6119a2a9c55581014ff7db1d6cf7d5d83b2643054249584ba639962772918cb422c6601c2517920ed89db30886b79405a5bd946edf13a195fb0ca91d637dcaa133f61a6f9a5e5f50567f714ec54792cb5d4301fe616ddd5aab85b69450f19c47aed4a02540c7e8132fba5e29ca7a4fbed2b1eaae6bcb9c7a0a9e506193c8191a85594bf4a081927dba0ef0b8e14a5c815c27c345b3ec88623a29794ffc2caa512b202bb4837f5ae6a9fae839f76cb175faea0fe98026dc61708a0dd6f5bc768f1f3b08e31a1dfd4df82d22b96a6a42bee02eb6056650978d9e0d50b62aded76fa8b7465160548eb84b90168ba8e78f9e68e6520c1ed74c899575b7b76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
