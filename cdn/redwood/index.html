<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bef362c973831158588e093e416bcb74b77c5fe03fa2ea19b0b76ddae0b061c96610648dd65d3c4991b805178e86d3b4eb057edc60bd43376df81f428216342096e4bf356e0a47073527612dadf3ad38ad2dcc9049e74ef079fc40b19e50779f29a02887e5f033c6789b35b0c341a4fd07becc5e3b5ee44125ee676dfb250e9ced7a58bc165a428954031183afb50bd0266c74a694a29004d392da656fd9cc743392afddb0d965c39e2de413e427e9ee63ec0b0e188990447622de0ac7c0b5048102f3bf6230de36d758b0271e53365eb910ee07b1c439f23d1f6257b681be4c266cfc9c8b71607e4cab1a94ee9536e5b91163f75aeb3b7e1ab7097318b7e62db1ff622f1071aa0ff885ee055453bd49ec72aa4864cb309944ebc7885534b64af79be3f664ac554bcfb3ca250280b8ab3fc5704ed8455a1e5afcd56367ad3618b8caca5bb4ac3b632029ca24d4576eb131e5c5b5c517f5d5a5aa8c46032217c8bf351b025e22e4be8fa809f73388205de83fae0b2b9baf5cda9064c1dba25410e840d978a9fc0277b6c3ec2d960f4048a75f183542b19827bec2fdae2962223ca100ebec72158f865ae0278f851f404906db58e276da6bdd6403ccd5c47a5491c71b7e3aa1769811f0e8c318bad75a19cae4c97a5c2071fe0ab1e8538865a8cf103345f1cb449c1aeeda27d10e494bfaa2dbb4016c940019f7fc105b2cdc8c950b518770c52c6e41672167ff24226694328add237fe3a506a55f3fd6b6c9934755e43207c41de38d698140ee578b51437ee75ecdf685df9ee3a9c268dd1f5de1e82ac6df84f0e5c6834cb8c1dcfadc1bb1511dfcf939b9a42e9bf6d4aa9d6f78280d616f2f540e7e5d60efddbb7001c69fcc7d6961a18c3662bf7e55e16202cf65e3bc4375797486a8eae604a35d7237edfbc60c5735cf8e6a266cec709fcaba69794495a22a788b4affe6e9d7ce99f2fdd69d91fba18035739dc708180616677f7604d5fa3d7a23118717230e9910dc5cdca403865baedcb1cec2d95b66772cb0c34194d79ce7f66bb2cee72f660d09248f638507ee26950847a7d5ed998cae789fe996d6ef3f589d35f1e608e838e9cecf145d3f9346ee3bc16010531497e04d19c3e5716e153ffcb954c519e7538b4f204351a9f1b4e987ffffc1a7de1a69469a1cd3c7ef833a438815d823334b9c1cfb46b5cb90892528b5a25c0d6248ae4c6f89f7aa33b62e8ad6d84462cb5302bc6e699b3ea9c40f643f9dee5b77be51d776e91acabcebee7e848d28f1a9c8820dc3178e48dfb1c1a1231f09891da0a0fbbab460c9cacf5473df5476a8df4b1fce82034f74b0097d2b004c3a847fc70301c45e923d79f3825aa047ccc73d5649ea24be12b9724eec33ede23b6c8c516cd3931ff687ca4e61f8868f9de57c4330d2551c47b088b51bc9b442c4a5159ade6e71dfd6beb62a7420eb07361eaeabd8da3f93915ffbc379f6934453ee35332322f6747bf6b5c0661af390a2edd6e4260ba0c250d8f890fdbe5df25ee3d123fa53c2472d5bc25c195f5c5a967900f0ce55ab5d8955f412ca1eec785e6d209957134bbb7f0eaf16e78fca07f7e4e46f31ecfc8b5409b4a1f1906581ed0747d299e8adfd9c6ab25f2aa7a99f2c45b568654d4c4b2818535168632b5edd7bba50443a8ec640dfa3b677fb821f6a8f98d32afe05549ecdd53d098921e724540426722a6fa4379b4f732195111116b3f54751f81aec3833e7e5bc5e15ab7291540d8754076b76aa2341ff3799652fe98be48cf41cd957cc4c8b7df5732dd79fd78d7ad10f76bf03fef43940fc43ca4b04acc6fe71a395f94d05c678857d86595ddcd0bbb40b0afe7cc557d9103807c95ce3a2bbbf043aa4e1fa1720f32c4456f168a6dafce8ed613b8fbf2a0c42ba250cb4ddb20204ba34c5b87522fd374442277d536fbf9df7e2351662483ca08e5131630f44e493f41df397202e2c40fee256a2a7dc7a6284192815696e535b2b8c52cc48825c402ebda09803fe8989e4170e46d462b0432eb565d1fb68ffb10aab38e7cdec3a8dfdf5ef03f846b93b7cb9b9be57b8bd4027b977cc200f72734c814f5f9ab4b37db5cc9c4f34a1b79d4c74b90f6bcef9516a3757b7d44d1e190ada909a2d364fbb07fd2da9f23d20f910009248371b5b4c1d48c2a5757b6f03ca060ea053a9768ac88665e8531b926a2b5e50403de8823b0c7627c1dda46cf5a4d9d7e3145869d10e87b4e638488adce1474c60e2093450848a582a47723013fd0e754d28ed1e852b6b4a7482975aad9d83d233b6b0627c81ece9ff958fbcef8e5c095dad1253c7c132c584ee9ba16ba0d6f5e6c922cb66833317e60026c0604ea2080497381bc316fe30158de4a368ef6900bb4611c471665cd6492ad48fb304979f9cd034710df86f08d598d1a41b4efdfb57723ee45ddeb1ff451ddd1661cda5ff8febbb1ccc3d93fd1f94792f00418d7f6b442c3b41753a72922c73087f910bb3fcef15981fe293cd57e94a843c3ff8ec038671d8233c71c47be68019dff3c7171ae731a5dfe43d4fd891d0a24bce1a7e0a8e66f0635e03eb25ea12ddbc01f9237a0cc9bf21174e84ca2fef16bd4631b7d2932d8d753fbd95e560d3291f7d4558ac078f093b972d1a889dc5332212c330724215a4ed1c7a151ba0a75aaba7b76f0561080d5e03c4e0c7bf0cb2e95201dfeefbc6cf5c2bacfbae3e6da58333e9a7bcffd0dcb6e81c5de0cc6f7f179f326cc67920a1d54dcfcb59a38308a474bda3e2c45547a611b207de8300e90cecc5a51eefcc09ae7df8873c795b16910051617d75e801c5f81d3482ba3ee7d4f79664b62402f5d6453e5cb19d06b6da56a19e499a929210f62295a567b698f3fbfade534dbcce4123c69eb158510201d299037782b777be5cbc6583f4dd5d309b2ec958f334dd7a2659f691c2390825c88c8e34c3a93aec3b3b2983fbb4069afe7885698977cbcda0fd9ab7ccd2626650e818206a8b320acfeb2b1c419bf9d9e19c59bc0160ef5c11af6a99cca7ec288ea92e8a84c2667f17f99afe4770dc23ea30eaf35ba97e341cb52c4c9244533dcf7245730ef653c4e703f726cd55f8bd269c80676f777b413d52074a99049e79f10964cc1257d4a434cd9a1d7d2c374de68768e6419fb2625cb85dd0bcc59780ce9ac1af5aec88c54e04ac0b071be56c0419ea7e37ecbd6cfdb552c5ab235158c22b1759c2c7c16e024a59f44904def5467a2eaf3a948fc859883dee61093d7df44c6c6959d00ecf2718d5ec2021565bfc412a1efc475c3d07ac2cf01810aede553d3bfa266ad2c084497c8040bc289f1011bce2fe11f96f214b5c6049723105b1381504844b985aaecaeb603f941ae85ac138a23fdf1c604805246441e37051a2f4320d9946fb006713313cc235d48948634e6673b3789eac39d5b896efb4021c16ca09958b99ff286a0aeae8df370481e77d1182702d0a89445875d16ff048a14d16054a8a3372eb112213c43eb6d574282237cc26d0fc3a341079e9ff99491dc74f3e0c2da404841d2f07151a6ae8f51a62bedcf810cb28d5aeb1d0a71409bb3783cd9b36892b667928b51603613097626d6d56cd4bab6416e0f58f66af8ee31a129699823c0e76fa4634520a609adfa4aacffb4a5d22a080f5b9a9b825b77d743fa8c664ac92d2e7a07ba35413f474698b6ef2010be04b91496e85f2e35ad550a8125270d503a439c897f52f9f0ae6e6b0f76511c76bc786de6931c4be9d6ce936611a9e7407e82de80e3625ac0dd5eeb8e1cb682431bb827180916ab68c4bbe9b3855d2afb92b90fb7a10687268a4e8f75b7491d6256c72fb5fec682e9ed137f77e0a58c6984e5799972ca443daafd66ea8982faaa5d672963119bf6c33b6178a8f5467122c14537de02895930e956869ef40d424706e2f227a4b5b4c053f88509711723b03342d68609f34c88bc2badfb7879375bc83c45855f3f37bd9a3a994a826dd84b4c739c0de1429be8d6f1add474f97db9415722dd0aea4035fc299b1f2eb304a0f50ca1f841d4cd19dc2f7fa2976adc3020033aa2b268ef64641b0005cdafc2da2c97c045fe86c4ec4f1ab2c652213748cbef43b587ce5837d83a1491078e96e432ad95945ebafc761991f91f9d077db0e58518231160702a39da5d5f01d5bfa28e18852f83fbd1ce3bb2edc560a20c101ba98ab22f78bee191d33d4b71510c62427592f8cb5297a5c9d002f07c1c23630df00f6df32110d591581910f75e670336b6d3585215f2762cc08139fb64603c41e5cd5711144f91524d0d4b3d60307f53cdecf4c5f7cc5b2b06e87e3937762094437540dc868cdf47f27bbd384385d4a26b9787913b2398b54f54b107f19527aa5857192366d982b9b9f4e315a243fa225e028b335d7513788521bdb60285c62d834c3b412fb250cca467c874c821ef9a33c34ed9f4a4268718f204ba3f97270b2857000ceeeb91df1b7b69dd4914f53e540e8c485a3999ed7994347c6edf904070fe99d7ccfd7a9cf2790ed4140f189b591b07a7e9610de99cca24d78cb493c18284a25d8bd3903d610445f1dbba4ffc93a9958295c3f5672cc751c697fdde5de2bd59556670661a5423cb91af299d4c7748cdc61cc3b9692c11b15e82c853aaf48872593c07e094c10c7e4714c42473a5a2a9414fc178026516f04018916372ea78794a2c24f99ee228ffc1d91321c6a245bc843167ed1926ebe7f7ffcd43f6ffe6e878013f7bbfdbb1bb1b4fe22240d9f7e1e70983950a20ef57be3912438ca5d690638ee104daed1cdcdfb628897b6edc5615cf1b6c97a44a20dbb1a80b1bf8e9594cdc77553f4dbbf2059d701dfe608442ac57fed3ae2fe1779e6219e9000f52e1f60ec360fd12ded895589bfbad1012ab635467d1366bad9352db89032220e8f1165930050e3dfe68013d28c52e8a57d1ed2b33adb401e0da1a7f658ed53d79d3c88447eb458985bb30b9569c5a2e51bbb382086e3f6f75d48d6608206b3efc3c4739880b7ffe6eb2f3464435ddfa1041c47af70b0c0cefbf6db974cbde470a0faa7ad40ec067b533791e4fa45371c04357a10682d56b06add4b1fd01ded40cc6b20a02f2e8b7dd14dc1f494048511de0d83671a35529e10fd39feaf79e27dc93c2c9c1072e984dd796367612ca7d4622c662d6eb8de25fd598ea049fa5320f228f9cf75cba9215797fdabbac707b706d2b5fd5a2bba819404f6a0ec76cc84712d3c0e47d4609562e0f3678d4fe0bcf3dd6d3207a70531d3d46acccd6e8303eb3aacf587a5d27a274b0183b20021f05ffb1c29f0cbd1a2d185d79e56565c5c68a0655f927e058b174a3d62217267487c008a9116d20cab052ea50970b73d3e89c40dab702bc76fa56ed1901cc6cb7de387a27de551c23bd8b2ce1263d1a085bf60c15673e351bd92051ea96d20fc41f3c48dd70d4e7adb2cb85c38a8dd566f4d1e5dc8de618853b9765188e12b2712a0d584b907e464f8653d222a77b9f2b4ee001f7a131b7164cdf0c22891f25e5f2b87ec4c91f6cdfe46d1df0e8db6c10683d4c987c9a9d439bf6ad0f7298f6c1b16462c226d5776e29162ea4561954b95aa62733bdea3cb0bac7c496c57a80cfcb8acc5db8f74605e89dd02a43e9e55b2a16971b253ad0bcc24286085074948e76e73c10451114a1bf8814caa13319dd5014cb531417c18d4145037081a6d9d3609776a0948055af1f8b1f65bbbc18583f0ecb4c2a9937a3a6d16010f99f73c77b67be43a45449857e0594559d50bd810d7459f44b11309d3e2b89b7191d5febe85d34c404a2b3f3455af15a4255a4da7e92d01ac5cfdc42a70ac3e844deeea86e53e2f32a20d5ca80db75d59345c4f9d74194de9d9205b9b372455e2858aa5d235faca044a55f3a5db7a6306860ebf416d31353c93f45a35c415870c60210a625677659bbe29098a6d0a7463086483919ca2e01e12ead59bef898237027a95e76267a14f9fa362f306d74d6c57605dd23e2b43cfce871b3f186cbadb0586dbea530c70651ac97aa74757ad694ed709069d1f34391e6f2628c0fed667beb17c19d7b0a24b2d970273e4686d1d38751314faf5fd63a09ac7ff0dc8965069662c55cd1a469c9b8b55d604c73b2712d92e121485ef865541394a70df8a5522a8f93daea13fdcb254eb5fe128e9571bf1d73aad354cdb635142d5e2b63b411a64b79d82ef64a04fd972d2d5283936556254ff21a7d760328dfb8994301d5e005ec55460049755b9bfdc34ed004692f1b4fd4c287b202faaf4c2e42ac923c95c96185f9cadc6104de3dc1eced3078736c1590c26c0e0755fd94ef6240f927c9b9a95d24e62e47b9edfd61b69706b23cac89c858476ef9045f78088310aacf30b9b0b2ddcad92f5a5e42088998bd741812bd83ea57b2685054debb1482ca5069dae400740cd5cba430cfdabd8d10ec285b80af6b0c9517b332fb957a6fc5ab0a12a150be3e1836d763fe9aee6c9d3afc0ca9ecd95af7ddcdc01b7e81330d5faba9bdd4a1ff8500f251876f2a18b24efe5b2453d80401f2e5b7eb79573e824f978230b545147e8e323c0dc7f7f296724c6556bdc4d2075fe3f7b1854164f7f0e6bd32afbf96ae19e0cf4779b11fcc4f01d737e03172408b8c7fbb19c611a28cecbed1ab8882cae3b47c45cda15857623d6b4e39a9a0fed9914ccc7a773f52ff819f005a60d187e715a85633d0dd5139a2156e9fd83e562164ed9acfddfcd08258d3b5f3ebd9d761d65de2d7fd7caf30d68617dfd33e0550524d377a14b4f284e4c9dc0bc9b671535b45073589508912c8e05132bfc53c44cfa80ff13eb275780481d07523b339e8b574a056682c66d04c1c3ea2624db4ddc2169296eae282835422bb2d566650a02c1eb1b7114edb4a7b82bcc7febe09dadebe27b15773db36a7fbe416aa7defe28174c960c9d9f3d3736c341369de572c4642d3852764927cb2b8526e6408eccbe94f1d1f1bc440ee7e9688ae7547fc305e43d56743b189abc9674be1d77410821c2c65fa3e79aa78a16cf7492af4e7abc9bf6db6cf176831ada184239ed9d52f89adf9e35eea52ed5c2b07ea367cc55b632904c0656ac042fa70484f7b404970d19363bcfde3bd31e729798b5105edeaf31e0ddeab06d917cc083c7cddf91a47bbaa5dcc64f0ff2b961a8f80ad821bc6a88b5becee213c6617cf00fbff455ba023da1226e9c0b808f986d8451431c293db28ad8d2de6b3d2f848000e68033a298fa79c3acf2f49b59e157ba2235eb81cef43c77f916829a408aae12ea8570f46843af09dc63aaa1409acbd93458a9bd0fced304ba22ea48f03b6b59f333e5c24bcec96ef080f4721b42597b1c983ee833264252c1f824f403d2bc40e8ea735139bdbed00f49eab4921815acabf4ebe9eb066272606d877c3304b6fe8fc5f5a365af993f4be0f5a39e3d7b6ce6a9a742fdf4329c0e0cded461d68a6875c05a63dd700c13e853f669b0df610a863a47142fa5ee002f094e44f8a45b4ec26771ec686bd786fb59349c7e07c0629f3b11d08836b3e274f5714cde1845087009cee9aa1971df3830f9bac76d6fdc425b958cdc98c4308833de24fd261af38d649cc390e7d09cc864f22f0bdf0e7ee79e497288a74af54343ae15a607012fbddaab613c4fb7247c791ea2836a1c1b5ae5c720c2053636399fdf3adc6460d96c82ffd56225ac746095ee7f23eed1917ddcdc65f2a016c0b8612c33100bc81bb71825ba767ee81def31f1c42a45a4001958a6ff6e4b82b3a29f00f6dcf8b7e272ac132e0d03b84029f54d7eca026e00f71873c4137d2ceb3fc37aff1b7e178b08cc36f0ffcb0e470c81550150de8d7e58ceed27071e7c8f06b03b115a1069d9e6d1ffc4ced569a6703efd9e2c50dd84d743448825cd429826c92170cf85da30d4181c0d5f8f384a04ef7bf225835c79c7508fd0c452ff654ac12bf2a6a0f92372e45ace45f89121ade739ba5f82cbda299af355dc26f9b0accb897861b32326768b8cdea44dc7d3840a48c0a6f13afe2f3c8e790c6faccfe03258ea558c2c9ad1f28b1301926d38abbb8f87bc75e11cb0f5b915e3e28ed96ffd4c1876dfe75e8d957cc74c0085a5ffa13d961dad294e3fefb7b630e8eed16b13666beb187a0f5302a437ebd7262c4e19944cfa28b03c8e98226a01eed482f5ae525f47810e7d89cbd37898895e06b53e09317d726e6c6a9553968f1ce56c138c5ee02e9a392f286c4c35c20311844efa5e6598eda9e571e017e728cf0fc27eab0fc57e2c826f0438a6b7a56ca979cd385d592c4e8034e0ef3fba63acef57390400f9cc862542bb15f8096da1712f711edadfffdcbc596b9f41fe1a8a5a8a40bf587b74db30e20e0070c5aeaa8d1ff51a2661056c7648aff4a8227263cc91d1fe65699e3c511724c81d08c5e2be8bad5605d632cdb92e467a7205f1b93b387552f40ae98fb970bebb4d04e3a56a12d360832303163773d0b5b5c474fd35275409d628bfa1133ff456c31e7b0f1816074e97fb6671e3d221b6db447eb239786b3a6bdff2d87a21351886b70f32fe8f23c50d1215d707a496b8a42ba371a1a30f75c532187417037d89f8a1e67a8c93b78c8dad6e17f4cd6d6cf2000672132853c8c453d6c3fbd3753610d9e3a637f818571fcefc320e60c87e6209242f68beb79c99c0151363cab462bea5e3ce69d44159ee9b5a9eeed841b044d2192d8807bd683aeae20dae6ed701424819eb71471a44de6446ef3974f0ec6468f5496ef5fe1df5ea0357f330f4ae775701aabc8abe11c526b0dcfa522a0118a2aed39579361290ff8b70c9de294a1b468647b922431cd1d160af14b18ec014a80a6cae58ba6af847c2867fd74e417c1a8c3c36aadd186ebb6e3b854b1e212caf313205dd2f84a8938cbcd65503107be23b611dde3e58c72c4e2c732055f086ccb2c20d94128675cdff3ecdef13823c20b122ea389fc9f662754f45a187a91c14a33ecf1870b279d9070d396d6817b1baabe306cba137a6e40ab6afa7a7bb12fbef646e352936181b2645e59ec32667aa14c785ddb5510019b6ce122a5e7326fa6f3ce46fe8a88d0e98e1e03fec0229803b3dcfada873a5501bc5062335e1c52c6d64d527d72bbe74ef81f502da7cd6d43e426b6aec62ecefb45db9779eaca19ab41c8088e6555219f43a690bd1b259aa51fefbad10c2bbdfb0b8df3b0574c74c5d6c9ffeb53306ddc091706b3043a3e100ae64f8dc91b225b983f0d4a22399e550cd3683ee77742210afe9d7faaefc251c2021107856b590179baec7cb313ce8e4de43894b18e74595c795610bfb69ae8f3a85f3b67949999ada6a7dca64bb07047c95df876d032aa632db8378081aa24154b151caa0cd30a16da5c64d501d33eabdaf301a13d83951120fc5a455c7f88af6bf6ae8a1c83353df208b17b222bad6f3aea8e8c263dfdc1432263cfaf46aae8ead30d49a2600130da55522ae5de0a8d17927f88b39548ea31d189b991768c4cfa15f344a9a799bff3ae248d21e54258f6821e70d78ac2338bd276663db2c231679914d18a83abf671fb6fe9d0e4a0f870384782fe95b1f614c54706e04c54effdab3109d6b76a0ce8ee0b626b552b97afafc549e708532c3e39b84affa527d3ca3a5a85d333bab7eeba4303986d9127fe5c68fd722059b93169169e9cfd9512454fc97b4ac8f40bead0579bd88999a113f01d4031df9705c36e85fc417103e166b4834fa293af9bad31cded46cc034fadfcab4fd74eb3772cb493792de5fa1b98469d80ae05a12e0620d677b673bb18128f5530ea98f991703be42b66e2c7829d7d6eb50e34c6c8a9f95591b5d869be73826b3751147b8b103068ade36ca2eb8bbec18fda8a54e1c4232c46b16b1f97af6dfc644f1f73a7e4a2b513121aaab98fa92114303b9d5b067d4a3c44746a405c13ba40358a6413c0d950caa9d9a9e951d65d6ba010d2919f02f166b0a4ead7c61b245bd0a94484dd962ddeda02a6eb6b1c81a76fae7ffc47e5bf22a169cf0d3da960b016c639a163f689f7c61fcb02be51d05f637dbdb2de9f2c962032c2c04dc7a4b6e6fd9b9815a7a394ae634aeb3359aef71b5be1a1605fd7382ae3a2e53ab8a4c6bcca685eacb54dcf08f5ec19a5cb6680d917ed39e331be01db4d7ba8544b548c9a33e1c5f23fffa1dc924160e87cdc58d6616b598487e35afbda5e2c26ec3294cf3982922fb98b86f25c579614582233a14f7ad64b1222f726d27d1216b286411ff3fb5f56021da3ee20f3f493d36b98fabca0d112a71dba04925311a869bf5e8434bac095f09a3ef40290f0a1d8a4131da1b1a0b8e00927f9ec970eac33beb792bddc34b49545efe023af0f6305ab5f993d31669612db91f266a7af33cc505772e3eaa7569cbab766a5ace27e6a05826d481db659acf577b736e403b12de7992ff3757edf97819c3495af93a60598ff69391e9fc65a24fb16961b5d9ea2daece02305ec0997eb552218b725a84c18cb760c1dbd9735a69c122cb68e9175c9f778dc3a29fa1616613c82cd4e603aa9ed1ca472179fff040a0339a64472823d6fdec36766cacb790690019fe39d44ea86446ae10229bedc18dafa88fa2914ea4444ec7f4e65ce52713b97668091a16183bcd53e529aa70c5be6f51cc2d8d23871b02b8576707adaf005709c5fa454f14a0ac445d3c991ab4dd9de3624f743828b40f4e4006209f2dad8c832bf86b54416b357691ac5dd8f2c76467eb2284a97042de1e90660172b2e6b423c2cf89010bc4f193c3ac0094afd83271e18581f9fbfc1653277ecba1dcc6831f83911cf4fb2e79cbe86a2299b258cd2754c9ebe42a3c9f3f492875246c343232dbde0014f7e6f7d34fc9091136a24be5baaff203b33035ba848a7570d6c8ff39c0454d547462cbd51b0f80cd825baf5473850456565fbdb82c9d3b57f78a195e90d839d09502e31398f00c05dcf7b0a72c7295edee970acda2e644eeac84bed162fda5841d09f08a81b85725b8b49b76ba2f37d39ecc33795bae6d503af29775afa6780a9be59210b3eca0dc0f739951cd80a4fbeb9a830291adb68d41bde0e59425233bc635fa8993f541b54ca5d6feb8bd6e9d07dd7614ae2d7f9325aad0dd1b7c8e3e652cee2712a53ddf83734af2a3b180bdd26bca399cf660bac9b63ee0833cb4790371d698e05f4997aa4454f9632a18df93b1bdda4c01fd06a36424c992158a9b62ef40b4a158e2f64cce572431b5580bdafa44d69f222018805d4fc92ef9cd3ba5c0a5551d9bdf83874ef5dabbecd0cb8fd85eece80ce032e663f5006e014d4085b0763018ec8f947d3092d73b1c172fd246c47cde5637d08ac4a7a3bf93c7d165e6a0db2aba3fc0727547c487c2be8844ea025ec0557232169c9d40f861c45a3e252acb3bd4829d46f45b6256085ea6c5206bb83893b3f86942896fb49fab68684bb5af1e877c6342a11faef0800c87b6a6c0e867ac05ff4c5a7178b171480b6e0ebdaba94a7e479c0ae50b4fa5c3a3b60a1fb79b9d35a36c827907d05ff2ad2f27c8e1b51374157f7c90f846e62b06006a7a01b2cd833ddc748cff533657d43aaab746499df24269d54917d7a2b017fe980869f958dc2980f569d2216b66edbe60b28f43338974d6de585e675769adebf5811733dd22636c86c684d30273e1e747383980310f61aa8b1abb4075593f799d4ae2c99c7288960fb538d9567fbc1d039e3037b7b151577cbd20fcd27350a7f5023a2c7b28137ad0f43cd6d16f5b09d954563141910c107e418a34565e22e8015fc6ff31e46e5b65a36c51f3ffa6cef04593d0074e3cd1ca9a4011ff22a3b7c80a94561f7c9eb34d487763735d0260ab7273417cd884db49d227b4e052bc35edf571b32f8098dbaed4ad332b370c9e07224cbfefc4dfa7743bbc2b3b18c2b0bf1f89e4c446cf55900407aed009933c5023c90c10b062ad83b6a8551ad476f781f51e1cc191b0318afe75e5fdee073a36312273275b7dc0077bf99cc0e87e68af20fbbbbf3b00a6ad2fb68217f72f618e39d9438217b856b303d06f9d8f87979e333e2f1979c78eb8c68d06fb74ddd6545b6f656cce9b37dbfadb6cf49c1627af6dd85f40149a583070861084f71fcd6f7f95353423e17e45de6ad152a0b485498daf746eca4febf2cfe312e4ce7ad58409307d4437e80d307d9e4b060110a8911c46a8a745b687093ccde64902eb8ad075896e1f16675fd27a94f2552829b32f077ab1c98ed961a9f0fd295b40bbc6d90964e4d906f3ea27b222addca20eae7a7ff4cb8afef10d56516ef88e222adf90e11d018b9bef3432d76d15bd607abbe0db01f48e1668264452f4165367ca9f8016499df02815da8697bb552895b161525d21f9240b8ffbda1f182010e6a56474396432ec5b5c55c476032933f9cbb538e51af774570b06c30a9566ed27e0fd9be6de40a84266bfe4fb4c853e46836e3ae02eea73a0d4635d98d0b5902d2aa50cf61f531a57b87055da6f5ce3e02c19d754c7dfc6e33e8b21f3bf6dd0a043e7e5c2e77827431b84586ca6ddb33c2f3455635618484576a1784db6c598966e4e020b972b24283e87944fbf85dd4cbfcf188bd7c740fbb45610e5bf588642c626780233da87ee8398daa826e02bc5be95d29c9ce5100ce3e6951435f7b101a416deea9495d8949e2830bf101ae8fb953783ac49e4470c32f616d5ed39ab8ae34657534fffd8e36c7901066c86fda8a2f6246dee259440ab6f7ec13884b21b63ac63e48b40e8c9b88ed44ce7fbeb1a2f9f6ad33810c67b1d60604e4994d25cc842df91780ce4a9813f33074ea7e73ef4b9a1d72e00bbd728a04e84655267b37516779f5405d3b2de9679757270375ac3d0388a14c200dce8d79ec93dfa6a2bb0fbb37813b4635b1f8ddb7efaf4f82a3429d837302b6af97e2f6210645a34d10f36dad2b6e567bba567b23cde6feb56bdcf33dc52581586d8821cbab89decf9638d7713703f469bdbab2d00fe6900ccd300ecf726efaf589d0de9e37d7ad52e0bc88c22d21597322b1d16d065e5c5e9a9f23be388082fc4e210e5f0ed68366aad4a211cab093e840e27752eeb4f39a96021742c59d4aa7f864ecebaada0b3e2b3ec5b4c4ec4de841c1f8db76178298bd70b975f9917e40e698408eab6a837223bf3a7645767cf57d01324cde3f9af2e65d4f71d37164f682ceb634068ce9e34524fedecbf6fc17de475d2ee6f2f4ce4e92d03836976ff41b24b62d8fdbfe07e32520dd5ca6fb88debbc9f6ad5b0df62824f895057bc087a156d700d8a3661e3ef2e1d923db00773d249e21a3d670c8ab8e5aaeffc7cb91722b7850f5ebe927b002faef8da6298bcb404c467b92f4dcb4b8044e4325d5083038a59fe6e2a4bff1d6bd72e5d59fa349e8805d7daef230a2c5b5de33985fe425a11b7c8328414ebcb39f0cf7a395017685aff48b6da84bae8a12f9b237bfa3c190c69454d625077e7196feb4cc8f5ad19d0d3652460b042e658d067e740ef7ba1506ee2943094014b6b7450959dcb2e83935085f93edd9e4f3bda5826daec28af0342f46c1d0fb436052bfb331235dec0f0cc68ded5d12f45872745a17d920d1fc30c44c7f2b5d16a4d8d596cbcfefb662ba0a533c1d8fa11f055c004323f73b02062e8f33224859403ab64ce7ae8773d1d326d8803db0633cc15167fd27b6259a762c9ce3aed3e78c673fa3a1a139e96568d650c5f11bc3d944b5e9bf57744d53af930c5966d6e64715a7fac6d8ee0c2034466c3ae8e3927282f50b171592b2200a947243ac820baacaa51fa7122570f8d55b19935ee1e2c276d1009860d1bc701e2a31cbb92bca49705cd1f6555c7c48c8fa2efd5f9647e7aa2eff7b89cb1040c3f919f336f9e80ad843502a064d1956a9a7da37a8e4143879f6ad2507e254987808acd416b1912a51275d9d783b196621f0c8aaeb2b7fca2cb0099958cca1278e4764faf457fd3d8be4714ffb6452f0fa563746c4530264be757acb3e0507d8cbf2e8bd6ac3a59cff4eada4087aa39cd327af26d9758622423664d1ce7b0cb258bde832215d23d502494fe1cb15ac1928046459fc58f62e3497e584e390ef04ec63aff074b3f2faf0dae2cfa8733b673f65b7f560bde412d4cb6822b289463cbe890f1bd46e72fd826981c25c6ea1ae8f65dfc09446a59a0b313630686ec973cc63358f85dbd327697ccaca22bc5079ccaf4465fb3ee9237e812216af797ce4f01170435cfd6e5c910c2f39110885a1f56fe43fa2b323eba1510f78bf44df62293c939d46e2debe55f19684ca7c6dd08ba4783f49b4f565fb16710c48d178d2fe84a9417adde7f6749f4f2ddcd64c101e8f185b83982c3b18567b0bebedff4645f15621e19ff80eaad343c1ac4eb407d5922e1a5c0abc4a02a7f0b1707032357f3c4204fcedf75103cce8c431e70deda5085b492a1e9cbf7f5fd67a694c0137cda1aa840f9d297ba945f5315c61980b109d6f4847fd91057b36eed16218dcc30cf0e220518395474d8bf3cb7a63ff81bd9b675d41e1a52df9665d71e3b2e9542acad70f115f1a59eaf5ad2f2449181c3c91bd137563ba3b61ef37197c37a094a8bae77488f9ba185be41679221a9d987f986f6e60314730a5d8142a941e3f697b2499eebe55bbd8bcf3850da29c2215c500a1b4e8b23e64c5d5bdc22a21c5ac0e2ffa82ea673d18bb092a00f7e3c291517d186ead2a1013b2d90be33c5be5c78991c25644c4bf93369ea97424809a615265d361812af50b61207edd6f4a0726dca8ce64300a9ed37327a2ba08e9862f3fdc3c121239dc7ebecc3c8cca241dc9a904d84b943f1d2d60206dd09fd602b3a93db18fb5ea5564a3734b290d413c328e519a58a4778015b7bed8e3ce4f7785a02159b039dab293bae6b811d93becfdacc482a32df381b3d02653e7156b335c3dacaf517fc636e9f905641bd40367b12689d73121ec8ac9122835a6e420ff590523d2d05fc3a78f39fa878ddc40b3c8311cfa77f786edfb080a7e89156489ac1e239114c26fea016bd372a3b1ad3487ad10b4593c6038b2241333bb3107ed0d4df0e28c3de06849a9901bd4fa374fa875db667ef4019d4fa3e9e785b7fd079ae23d845c43c1a6801413e333ad2de4b1e6847abdfdb39a14d22dcde8900f300e2e43f1e7052de9613bd405a5cd1d5328f202b02a74f858ba3ea1ae2abfa301a507639501bf064e0a139d3c35a226465569fb630e146d83381d0e3efc536b7167cfe82b482bec3529c1a2e2c7e30615764d20b88dc987225d16ee5b756c04423b2eedda455e162e30ced19b7be9646e72a5a5f165a240406865db9d1c9e47da5c9d1b4034325e086e93c6c04d488ced1b37c3015b25db89f43a225f683aa3ec666a822fa5881af8ce569f96e9f8620d3d7434d2d97d452d92379ace5b69180512a1d34dbadd8147abbae554368cb4d310828afb0ebf92fe281b78cac9d95806aa956c5b2a53326e7ba4de896f537ca184bd8116f5aeef1c0eac7c2262b2cbe079da14ff2f4f6a1272a1d5d4690f563d9e50e46334f090633610984fb81d78746d3678ab8ef2bbf57b56b2580b167440d366a7901bbdc2b73e57b6cbb9d36d74a8c2b102fe7eb1823cc55575bfbb3bd8901005b59e600db67b304251733d315998687a7450cd2fc948b3bdccad4003dceddb4950f657c59478fb97112c4be19652c2eaaf418f62f16c6373229e73e58d0f8d9bd10441185e7b7451e48ea5a0361bd52a8195be6b32c4193de460e7cd57961544306a994efd3ea6ce7e8800029e39df03f30e29d9e1de5feea5f3ec0cbcee22e903d34a891822e8bd6258a95b94eea0ee39b4012cf0631aa53fc951fceb3c41d5e06e3b29b9cd1d5dbd4f31343ccf47ec8ca10f351564eb44fa368acd50d8bf06e16b2dcd0026c6dbe47644660999944dbb3ce88a6a6a0c559e5ae9324342eba9856b69004c98bf60f0ca05846d41c506a28db7fb7935193e4af1fbddf0a4c5a60ec4012abac102ceebb089943bae294235df1638cdbc5f458437cbfe4c2270462ae6dc19413724e126af1756b1dcabbfffb85f9390752f9a18325f3c807be37d0cb401c67ae856e44846f8ac575d75527732f3cca5c5b214655526900e1f6d0522835b0a58ccf0719933e19bec432fa104f9a3162415868824d56374dede4b5541aa6a0ddfcdc8a5535a9c767d7d84765658690b19c39e0cc1d9ed6f25064c0191ae1956bc2261bb359f6475e627b0b13f008095779e6064c9b442e28c4a688fd1e67f6665454fe5e35c70cc177c3ea62198e2d66412195a95552d99da9bce8c830d37a1541225cbede2b2e7e7ff4de3b0350230583aececfce3a6b44df7a23fd2a5873b88a49dac89723b2f02284fca6995c9a80511e455c799725c3e429cdaf41ed7b4e1dd50789bcb3fde300b6668eccd6edc3c177c4e1aa5facb3e3d7f21a2855454453a9bd04f993a5e2fb10f9a3fcbc8fb63c590288c0c3be87ad352a6bf8b630f76e80fa5f5e69ea285760d34581c68f2e6ba26f0e5bf35ab51f2c3e6b81f0c1970a183353280d8164c4455d3be56a5dc91a32c8c2daf32da4e8f933d530772a3597608b218d801350ad75768276d263ab11fa1b0330acd66b53b9d66953bbf7553e671fff16a5a9595ad8abe11d8630156a1b1d0883dc66fd1ba3a70bf9016297405b6718bf469f186859d092b66be9a9eaa8b0f0a7e75b52300db754024cc48e03be7639632fb80782a787f9715e2d8fc02ccecd42f2adcec905a3fedf1f47fd057028ffacde49f5a30516731ac71cdb01d59295f37ceb75a8a6a07fbb658d32190524d31cfddd18792ece738a839cd2e0310168666859bcee4f36ddc552ceee4e4b1e286aa54ffafec02178dd86222fc7a11823134d7a7da37f6b0d28b0e9f26c24955a5dab66af51177f1a9b65497aef0055121b6df4afa5d84c50499ff72fe98e75c07bc67a797027b11b122e6d8843fe4e11012c798b9219736ff9e52fedc7717fae4cfb0dfc3b7100d7dbbde21187b906728b29a09b981b9bad4d890ba868257e650e8bc2ea5395280796b54c2fb1a70677ea955f330869353d030b1ac359410307a63b884850183025821c98663b7e7f0418df25c2373a30e5dd0667ec8e38feeb4559fc3ab86255d5364e324f83a4f750941c546241137f50255aa09340884843290828f4d0180467999b8cbf34adb5f9ceb827c85163cf28498517358a55b64b7f7321dc2cb969fd6f345f182d2643041d3fb2b8e6912e7754f495717e7f8a68e89ced73e979ae753c848898752f2c5a42c2c6466efaea5282b41bac43b437e9a4ee07f2d15380f791747199a7b229136743a51e35c759153b3713d1511dfc371786c58007457c1f9b183af5469df76ac35175df972104d26a189b603540616e41e665ca6b35e729637ba0dfee22e6d968eb048b962c4a88801281ce944507c709614b1fb78a8758b66057108caa28557d5a6a166a9e4d8161d45d1db8f30ba2d0b4b96a4a0225a09193e68916d115ada5b26f9bfed3d7a0bd467c30e3608ad2c254fb2073c5649d330a19624206d3d670432ca10f2d41274f33497e85964ba1459d8f8f70f03b2089312466109547870af118b22b74d2987ee0131a73c3b31c22da08932c2453a854b81ff2dbb805cbd5dc56b26fadda0c36bd29b915569dad9e25fb34043144d443772829a2ec99fdc905ea1919e50d1bb021132c247f808fbcac6aaa1c0e1a06c4bed1ee2fff29a19695575a2afd3b12d6ea8bbd3ccaf9d6b80feb80a16796e7477d2764ed1ca2ed31685e956d9ff6364672dfa34cf004c7909c219e609fb85c90fcd023f44d5687a63d84aca3f581ee1fc40a571c7a5850b4921a09e32ad4aa922a986920ee3a5c8c982a38adec5fa08619c92ef692a89bb91ee94911ac2013d2a2dd8a086d5523c621215ee48273ecc8155548b922125708","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
