<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8f0d0e7d1503b970d951d4edee4a5cc8914014abcb7b51baf22a12cad3771a9ab7383e9f1adc126f9ea38ae1d62c3c83a457d0c0dee68fd91b1cb415067d438dea5b73d1b7d9563faacd4f62ec10c17224b93c948bac9a0448591d8cd613c19b18df961bb0fb35cbe58590fba5246c19f86d8bf773386a952db98dceaa7909ad665e96208d10a3d22e81129ca3f8b2c014bd36724831eec389e8794b84e312e80764392e340c7abedb7df4c9710a0adb59de7c49de4416d784b74eb777bf847c2fa8c01dc7bf94d734fe9a1d67b3988da4a8cf6c9de3689e265c7f18ac9a5a7fb094e53a676330d5c2ebdd3ca17113a8d2d933629a12d4ee73660f6fab440db132fe19365d98ad677eba059da44b78992598ed6fa91b7d4502f735d500fb5c010874d5885c2824fd8f278594a9375d66abe58c7d2b9bb900c2902552e5f0576bacae7dc5519cab0e7f0b178b4983280114ee59b51e65956bd2dc2f62e1500c3ead3d77db9122e47f2dec485d178dcaa39a21cc039cdef4633a47391414f829902c1e48af6c7d3a4c782587d68a15721860a8422eab44d2496490e82e4ccc868710130e5fe1b2a170430e99393b0a19bb3a4834e6fcdaac3d47f11bb1d9d5826340f1b71392e4a082ee8f2e57f8bde8ce586585a90d637ae09a7ac4eddfe1b029584fcc50b5a612e9680804e9f4ce0d2dc5642c55758a860245a81479db11a6a0be774e593cfb82791f354c98b93117b99512f51851281440534a4ab9a0d2c3bd81056ef67d74b953791cba37b1005076465cefe9585913e9e511eb656f46b8161d315bf534f7380c9c9c1124fdcba4ea4e8e362ab204bc8f1f71514b5b29d8906a29ee9a8a6879694176208eb76414600e9173b332ad0ec4150875e3f92d65bde7a4e57d021340e059d7f3c74d18fa81cb7fb6c4f2740e14e2cc87e8663f41cc696e1690309e803b92813990fbd1c6d492578dcb9d048b7ef1dd8e9230c4362968853fd08ed77c97577e4bab2679f0f1973779ab8777f0e36d056ccbd578672b28fc172782b905928c6dc2239dbb499dff8907f674c9a903b40fc07a2b711a70c6d081284ecd7f8ce6aceb30f4f492e50a8171c0f2d4667ead4872e6e1a6c5082c6ab5c934153f5efa6667c3a196c8b8dd28532c40694c5c73dcc96e5b008e9d4c22d618144826a30ed4f2e844e1f825712103cf4e26a4ab8d38290e900777e7810cbb7f932f5a7c66130d7bcbe2b3427aaef01c3a55f41792888239ee52da799bc5ebcc78c4ee8be3d90f83431a8c4182c69e0143ea8623280719a747dfff74b43221aac9940fc370b44a25380b3d645a2e8d789db3cae8b95cc920677b84b27ec8336b10cb366f40c5f3075329d1a792a1c5fd9e4ac8d6e21bebb072b150679aafaab2655fc4ff96b851d398a974625dfea36522618b021805db437d30985311b15bb6ad8dcf9868edfe26c42e7c686a71de3acb0203e1afab05c063d389866d997a3f361d498a3cc51be2e48a002cb7b9e9b734a02f6d913927c3fee958b02090def6c7ea7bab6322936e2c1dca3fc5ce93927f891a784f392f89fe6ed73b99842aa950c3620a6b1b8ca49c396977fd4ddcceab267f53613f494938789b691a9a0bb7d1f182a80468fe2e330ddd513bfce4d4867ee82917c6ba31cca4d8c242d461c1f9e3ba17df344aab2e0705495068cb634768857492b042474b075119872b222676199ae8bd88a35d70cb5f5dd5eb02429d7f3ea496ea75bbcb0930fc09f9d3d6b3602e2d269c87d4a2d3a454fcdfed6d6e4e205e9f5654dc72f13d352878ad5ceade5d0bedb2b36ec2a849386e29582281896209155ca7d29e8a535c1c1b35e92b681c11d933b8ac4353f19bb0effaa118d89e52fade55b20f25eefc8e5fe4b42eda4e68ed43e6172ac7d794d767d7b45aed8dd26a31d30aa763001e79a8a3ec1e66afa4c967fe77c6175061c56ca11e85e60b9faa4346b3dca3b87e2895441e90db2d6b3d7b534808d9e185de8b352670fb6919ac06203e80c98e5d7f26a6cb51f959eb14df8e1dde24dd2820e28b62b9befb0a09b9439b8264a6180a621f01677792b6bde0f44632c1227b85a9dffcc4a9654b696f6e6c1879bdf2b500b24b4d47ab106520da8b97ebe99f26b3cf0943c205d195e35fd260851084bedc18d9ed03f92c07ca389a0f9a2329d9a29f911e8c7f2b6132432b90c1d4296effaf979fc6c9b57ae3fd43c528d6ebc785691f2d49b0d21cac7f13b70f44e2597cd073e94787532fe84325859919f00bb3f1adbfc121023b6082d5344ff5ba2a03e0040c2a4d8b1d2ac1040b4ae8a9bc52cb268c85094b891326666670cdaf39cfc254e3f3f907111d483a0e4cac5138d89fda3b23659659ed773c4ecca731fecf52b553b6a4e6a4fa0da88249e255a07ac3da7022f4c3d3335d4884928b23f1283a45bf9a5eeb4c457592662d96ce59025ee3359ee49e30a40c758ef04b2a34e7ec96f514b633d38d0edab9c261eb30db5d09ef581009d452159d3f8fe397667b950b8d6ba33b5e762f680973cf9c57d75c4909f4342a86527f5b25defa22f6a50182e5e703fe0a2126c9c5a396586d3e7b71069e88f5b388a84e15cb1ce01c97458a89fef29fa82169cad3d60db39f6735134aa02ede97c7441345e08b2b8b5b6c29073d5e86784c37f19865f49fda9a2c5392a19c0bf0b6aa836e8d8fbc23bf0fb7a0c27e141fc79599c1ce2b3c64d4571b01c8a9389b0fae27ba40b212d30dfd589b3e06705dbe1e7a0c98e776c16ae9bd23a339b5a46c922963f42bb26d1885ea762fa48d3bd9009190c12bd1693cbe63f79f835b71b98136adba08a97bb5bc215913fcfe437d217a760b198bf739a02662a777c011bde152ec479f63ecf4a65f574b53fddd03f9f972e7dca88a76fb313044ec4110e79764a8dbfd8520cf00a1ed450fd16d1da8d50049e7e1b5b9dfcbba885f6e553a1bfbb56650b3822152007268f2afe659c2f8da4a8eb55367ba4bc5430adccaa02d4360012799a2bf181203c04f05ba5776e0dddbdffa23482321edf63ef6dd8aad820ef295d581e071752c5a74694b6d64c5d3ddbd8789fe7656ddbe8812a0539a8ebcec73c5456ee9ac4c83b42ac5abe3a95af140ce947a3390529b6d0f548372a2f34ce8b8e27a9cbe3d5aeb85a9ff65b7e5f91f1335c45e87198b95c7ae3ce7b36325542233bad4437b0d8caf076306364e75dbdfbd8567dc6e43c4b2e70bb5a3fa2f62441c45921d64db3a162da48ad12ce78c18ab1789648aee0638232f07d99b3070a4baf1dee550307293743bab7eaa8b338b9f889f17e679166cd0681913e23c648e573d43437a882d9cd71c36f367478630732c115e69b7561d048562e03f5e193b635be722cfbf579d6a71a4b011af8e8b0d43b9243236d607236fdcd24281cae7b24ad0becfd44eb412c7842ab172fb9033e6ecc57f3a611b9baefb7e658689b9ff9f41fa93dd753d62da9b8e0b5b298b6baafd86e310a3f8e3457ca447bcae7eef7d430d8c7c7d5a5a3139350309ca17ef7b07451af3f71ebe8582c4a48c69ddcf4bbe661684f0c51413b463365351799909de3ac4d74584856a057c42f7907832bf0034e8b5e39ef3416c954ba382a420102a77e1ce5a8b83d954f6941f39cca46497d38e1504a8619768c1a76ddf5fdada127a007678f13b0ad060df3ffffa50d00f5650b47aea1411dfa117f026e27a220e8266764a1f2ab12f18741c6821ccb7ee0b42e326d7bd9aaaf1b8a525f1a176e2a61978abc718aea9e1de2f3999af56f67396864f1ec9faa8719684fa55241f6e28591420df81330e8dbb6377cad1605c827dc9a43dc98cb28b8130e7950c9551e73c41e1828a4ddb95d9b77e206afd3e3a60b122c5ebf8218666d4681f35d49da989734b255e81656dfc47ba53aa2c79a25e48f0494cc040191c24e8034ba3f01aa3a26c840572145b5fb85762699f2e4071d968b5dfb88309155b4e0b9930118d93c235c42871155fe8942f4f3de4a628e411554ea833672eaa2beb703905a09b12c0aa923f9915e026ad3ad526f84d8c966e78113f5b99d3bd7db1f2c33ca9ee16719c75137b13a1dfeb034e6c291e96ab4bb528f237ec8a50d8b0a7c9912015d9b306c6d9c52a98113cfb25c0fc3dbed36888926d9ceedfeec56e6f2b26c9b79ff36d611ec45306f5cb79e1dcbddbd7ca819e72f87d2993c0afd94d498a499b80640db95e73e7cd9d4e60f7b72c8af93d7ef77f067329d8bf6db1ad7bacff3190667f16f296c21efa05dbb25133d583ceb7d7cd33b03602a81f21f79c83fff95249d493ebe61a0fb92ecabc931fdecaf63a6e770d8aa02da47438e5088933464a9482789bf420ebe70f6cb30df6fa5eb498944521ff3c1455464e77014736fbce0b56bbad8cdaf1d3ddce4b3f339a9a91d719d015d97315594603d2557f32da9e355fe9092bfff51a66f96c355deee6868d41969756a5e0d65586c5c5ff14fe52275fbd2b7472337af818aa6277828c8977249581bcf54464510555dd385b11f38404b3dd4cc162c1653d7992615575c2ccd4c1dfa774b1a811829c9c5bdadc222aff939202326fcce2fda9129ada77cadb1e889eacd5d67b78f82a3ed37e76a87dd38d1def077d3596b17e4cf489bee79c29116e48884894a99f318e10b5f0c740292238993a6a6bf344c1c7597cc059a7ab4cf984ecd4439861a68bb67bfbc4651d6b84c4be494a746f3f53a64ee0da61e00380107c3aca4729671471ec921b31e452020d9e1926ce0d24bbdcf69f8e7aa81f047e2b487820a5693cc90dea60885981f2d76170e91e39bead351e697a8ee091b96033d681a1cc34834a7889c13d6e5582593c6cc575c33eefd9a53268a556df567eb717f5d3419c6950813e02f13b405bbe687d4f63685af47a5f36b9a8c17665fc0050d40648090dbc9ac90fe3ead9fa20548949981e887c731573a5eb98bdda9af87e06ae3fc2cf3103cc758ebc0060de8ce8edd3ff36307bc2f6b47a88ff3c9ffa5e35b332983c473f26428f031a8a8e15468e8a879239d1a540cd88a8f7513db77e7f0c51bb63ca9adf2035e589f889285d9e799555e66a0de897db79ee7580e9c6421ca54ede22f6ce720364414001ca967f26ade1a5d4c5300fa18685484d940a46f7442d70540747528613e06a01294e4cfdc123d3572be3d0ee1e1ed43082fcd2883d4d18fd415018f92c85c3026df1ec5c2c516c5ffee23b16b30ce7bc579aac6faa674f3f7720e5dc3de182e8824e07d639dc57c0587e15c225ad73b2a72c47ddcd61ec691d83231686557b682ac10540bb3aaa745e6b5613d91ab0d9ef3c669e100e278d52329e919698a9dc97b64077370e9cff9fd4037bc13c458fc735cf5fd4af3ca086553a0b62ddcf77f79110e11049b31fd350db5a5637e8bf34e8c0b7122d797a85d71bc25852fb8c287bcbb8303848b7957d507a1bc674a3a127f151cd3e054044ddae0182178928b069846c914c60eda77126a59627e306440d4648592585782558f9c56a46f364f27c0b520f80ca9e1f2657ecbb04c96aa8cebbfd78490205989444fdc3191153b5f0b6b54013c00392a0c7f1f527be186a2da71f075072e3b9439841c0e55bedb4418a141f8845d37ce2942e186de830eff76001bd8c8fb05670a5ed1fbd1d70d1c83960490f8aeca4f9ae4e3f8882dfddeafd80aabc70e8be25cd33ae962b27d03d516020e506c882ea4ab2f957fb63abc107232ff974b306ec5ac423fab1dcfe910f59575156aec1fa108bfd162364ebb1bc3e0c845deec5b54f19835c15a6259ee3d31a30e7824c941762fe576a84f5e578a3fb5ba13d2623c4b3ace45a5ae4afab78706b1a19e2d9aa8973492dd73638f60a45ff00d79e3fc98fcaa02de47914cf25315589b0373849910e5f0d8258306353580fdfb3bc3121d8e3ce76f0421b831b5b2f0ec35ab9e1f41d2f06dc742bee116dffc8e9a3a764a9c2a0f7a104f3cc3ba95f3b7a985d4472779fe514cbf46f227238e3520c1a77f5c2d0d2cba23bb7a2b3c815aca1c2a5d3dcd99357645c05c89129079bcbd3d34b94d7eecc6c13c03cfdc29e88cf74d5991a46c30607d1a38af6ac4605fc83a0ebdba98463abe646951d84f34912fa8e34e30619c9b86889ce13db985dc7fa8929b1c078aef91a73ee4ffa1e51c6338dbd3016ec87eb318271138f1d4dc4b482c48380b115cc0815615ef88d4f3a4dcee6650ef45260870e81fb6d23e67e43f4d81d1ab8c5abddc414927048739be48245881e1c646175adf2bd1a678e7876c175a14c425d70aac9b0001c28f2b1737df53c99988d95a3378bf1dd9a19b49545f13892cbd38d3805e727f987fdbbb1dd81774cef024ab45b5c799c3a572da772170bd0db65f270ee3566dcd788ddb6f811e6afd78608826555e065733e3651a6e3023abb72b70b81faeaf399c4ae2a39b628ad0f1c5a2065e42e9c432330fd96bf1d7e5ba004c57daa9522c8f5a2356a0f6801134f7bab94e3937d0f3f5cb78787fd4e27aafa8fad80eb4c687e1012a9df276b41e3d63fc73f66317a2a07161e7f7cf5f5a4fab0ae758e8ccf46ef43199277d9bcab346edcb5d0bbf3885720037ce48b57dba22cf87fb35bca0dae1337bc14efe984687f06ce80aa24bceb6f4b6bc7917cae1744ab252b19dc36be528f8a34facc44f69629d27bb1a8c7c035713ec1e63ad7560b0658b37af6feef9394665c64776142c210c8ff8d2e5ec8c06040cc34b40fd52a87d638efd713dcc2407a4d41298c7069499612449fceeb0d51a70355e076b713d5d4c42d1195f5c59f5fa3dcda07280be9e772a53e7be13297ded02eb991decbf47c3bd32e9d16bde62d2f3b2ccdbe5229b3bf2ffb2be4757a3eda119392eda8b7ffb4e4ccd58fe06c47c029263cf275043495ab86a72fdb795fe0a4d83e5843d5ac8fc984db4896a6bca257a6b86de63a764846c405a026ca593c85bac00cab22dd3911e7a0a6179f6060dfb6cb2213d767900cad17177a349254f45b7a5bbe3f3721f7e39de5e6faaf2e798dc8b9b8a3eac7f68e601e6081f27c5e9eb1e1c2294e1d795764b944a48a017ca093ff790f666ab7db89d2b6089def7b8f2f5c94e93165af89fdfac54fc4cacc0d3880aa2589c0b372e40430803c97afe512a89e1b910e8098415b757b028a37c777fe3042be706311687fe587470fedad15768e55ecd99c62fb3b91d1f92026e3ba9b6b8ede4a60690ec6f72de52a8626ca4902ab791a215ca2c59591f4599587db2a305678e02a300deb4e7dc4a6e270b09583f8c8d3a3b96e73ae5f9629786551c10396395229b53e878381444c1840e7306db09f95367a12c3fde37fdfa636cfda33edaee9e56d5af7ebd9eb926000a5368b46b298c8046ce3e0ddcbac19bf6e9fde1afa6a3b72623876054b6d343b9769b754c23bcf15b22aee35bdf16a3a3feb1bdaf39f81ae880c7338e52c972253b66ab5a67b3ffdb6fbef14d8e7a8ade5a62842adff43461b6a5ba110dd992a8946ae413a39fa4748183976a111b6a1b2d26883acb5250abbb01f8eed249350cda6f73ed631e1d54637ba55601ef8e23635375c14d6edde181749b409b125c4e34552b11868d7e1cfa7287fa7062d46af8f8a5b094b4a2ea748cc46be6858fbcc9acd81c1b506e423e1f055ad54978157608b42340caea566cea5b39a6cc2167a6a445cc73b27ba99f292df9368e16baa68cb2cc87dd7c18518b7d2e3c1e8cce5a223090e77352b73ab4c2949f6deeb50b5392d088f060c659611457d8f213797317f7e7037e89010179a4de54bd77ace4e432fa2ead84840484a7776314c417e60e6accf751db6b4e459176919aed33db49970bf5e6e3135e8f8aefbf5245a19c0f06f2ed3d10c20882a0cf03340bf56da74d491e810956ed15b2b0abe4ef97b7d19ce7a72ff1b2253211e571a3d4da81750683a318a8f91aa1c2072e584165c0d689a0ffd239a6839b51adbcf96f8905864138dcfd56c90e9e926303fc7b7851915c2c1e5e5ab4c31cbfde167537cf22cad9cf323948ac65cf40b271b8b90226dc539806ede72a2551cdae39d3b897d6297993209b4f0a5172aaa5b63a095018844bdb98b7d251d9b4c289de55de4a21f51402adcc0a04e7cd133f1bfe57482b48fa6aefbe6f7d97daec9a0485d722bd5c5b61bc912944d12c5d16d8a729148cca8f71b5111a08719bf8ba3dce140c8f6d5585d724456afc2ed6e4b23176d1bacdc649a09fa46955415a7bedb402dd10f60a5f01a98d76e81a1b10b37f7f37fefdc48b9902f05b809d54de0bd4ed39faa959aa114e93128a154094afb8d2acee15eb2a07d63f652241ddf16bfd171b4b48f9c85a17d8923b0dca36584921227db8f7926de4f58948b4bac427e66585c8ff72a4d089efaf209dda42eadc61e0e9a292cdc921fde79a77fc687105afd5d7dacbec8ff096c617bbc3e9b3ffeebd0e853692fa15a396c92cbf92ab13bded0472bd7373d06fa89edc2e50fc6039b789213380eb1c7c37f9e7de51605b10423a6748a10fe74222ae7dbeee78cd03c4f2bed763dcedc3a840da1873bcaf44b4fd68d27202e8c1d9c569682d6f361607d595bd02dc0e4a16ba097a2ca6cadd177252a5376e57d5cdbee2847763b9a8a15708857d299b5e458c788ee295fa5b0a76a80344306ff0784898283a1f82c60fa8b7cfd06eb020f44b4080e90aa3fca7c56c59b87609b9a89df488292791e6c1b17fe0aeaf9db55439e5a10e0c29eecb3231b3358ef09fb085eab8c447cac9ebb3790510b2cd70bd65fcaecf5dad98923236e4b1e2d9d2a20706901a2eac16240ebba7637d7d66e32139c0ef55c893a149e7cf76566f41b0bc6211ddce848f1dfec6f1d11a6c3fee6f2e8f757cc7b76d986395d1d4ad8b2c647df59e9affa920ebfa996575cf11a1c4c575811c752bb6768a46ff4a290133deaae88a416d56bd56931258ea4b3ceba4c7431f592e59a7effbc715d42284345435ab9b2fdabb8e34da82cfbab624a857802731a1d4c3461af715edd011712c75bfc8fe92a9abcb835fa558c4e8d4cbaa8ade86173b79a80ec91ff4b866c9e50d69747801d5687e30687ffe6833755e9278f46cab88606f8203f0d1218ea431f6af7bbd8c1684c61fd758e80e8e2f7493315dd73662c8f08e58104ef9b57e2dca8ff2ed2a1d3f1657eb5f0bbfd42ba1d32ea91d8cdc17e77e450c99965ff98637ff6d9c4d6a7e441e049b84f67ee7bdec3a73ad013165b335161f04383e06f6f85e9544daf1edac30584ab4ff532560d317ffb7f85d62d56e75b2c1bc6650b2fb6b50484bd696801948dac2ea37d23ac254f216689bc6c6319b85f5201c376fc59fcca41d8b9d7f98aa46cf1ad819b247f814466ca55f6d5507a2d15237ae67f201a996e108a1b4bcb592ebebf33227614727530db8141a7de438fff935599f8e22a74aa95e0d01067c341c98b615394424e16e3a1532f276c696574275224702d54bc3015eb91ad9a4f82a3131fd3a7628545847cc735670a3b935361a3714c662f46849e6e697443f6311ab88c09e76d6306b7da06f67888f90569f28205a5ba3d814ff36c540ed0e41b688c618004fa39bdddde202e687ed72628ee2a5520120b99c33d6e0ee5041b417e3cc4ceee5b2ec74b3c28ce7f1e9072c4ed15a0a2708e511eba6d9555d6224c9b929be7fb2b98be1b7961a0b0cdad26877c6a48e38b14ac97caefa6cebfa2fc047c186de747e22ddd12bc1ea158a22b11b1b3c575af4c81d3caa1dc92ea3eaaeb1aaee7dcf939f57695f69c0fc82584139ce45a1b753837b8674dc7535265c25eef7c00d6c15928c0d23cc904b2f0d1f47b849302425b12a07eb12c9003c6e583cfd4b9d5d99e378ca4271d9290164158e286640a5071521bbfb4e7aaf6ea944ff39659265c36df8e67bd4f899a1fc7b2bc051c9ae08be22d0625d6508fefc0df48b88a73928f9f4ebe51ea14fda647669c7e84778f41c312361458585e5d1a9f3e40c90cb5d2bdbffd4abcb5941b5dd5f025c56dcb346c0391dcc9b0bba7e81fda1c7dfab88e330afba96eb8242a1cfc4df356d750cd4cabc236a99d60d7ce3719b78461ecd523381576fab74881edbc1448f9efd2bd2c0ff0148644685db849267895affecb11cf0785cd0c7a9ce5dc799efee7c0d7000a4fb29c20c1a43b5806357a02c0bae1b61ff7abb0145205b162bf5739d7c9ebdb020e10af400b13c6e8905a3ed62354ae05fdf623b00c4f67be316c04031a96b56052877ff08f41fb431e53f413428eae9317b780bb3c16cf02590a0cf4a52fd5d7e24809b5ee38056b3a60f2f381a3db34e6630b093b8477431dafa1178f8278c3a5395c40bbb9eb8f0ab802cea700264cf63c47372142a6737743f0464fcbe8c1526ebd1853b6dfbecdc07f76c38435135a37dcbd398e9cb0e3e21a86f2addeda5216e31e47b104e60e702a1be7c1655b9f2780a96a606f517c3589886313a24489dc60de9f499add5b58acdfe4b4482f8787698e3d3e07285cbf5d56abc8d5749e0ee27db6965bc41a7d22299839db96a0a7e7683a464384e03f5b944a467c33cf53545a3936bf58e68518c06712677b1ebe7d988f416b48e04a12d6f63c995452f4f3b68233a783ed9b9dae85ef4e821da625f280b1ecd6b676d1343e984b908cfa31077940112ec36a1bef4cf6dacac2e8ddb82468d0f12025a955d2bae5a054249fc452c21e438e67684c97b398048a273f0c78ef815984e2bf4f000ce46b522c434c551a9d4a5feaeae2229e226fd5c8d7e8dc427513a6b7840e4db76a3dacc2d436566a7b77e91e88a337fc4497e0bb7a6cfbc2b61d427b06393d3ca2ef00d8947275ef7e5a85e9069e5f3647afc5d65a0b26f0666b40744fecc39b875189937e8656ee3ff260ac76ea514b138e6c29120956ba9da2c81a5a0f4821bbc082036f7de8ff7e9b2579b26cf60bb02f50d68942115b63097356a1aa35b6a4813536479ee5dbc3a1b34964cb6f5dbc86c398d8e9fd265491ad3abe628594ee6466111b1f9c0bee0f12d1cd147d37b5a7d4c1eaef2755522b07fbbd50555d055973d35162b4bdb6d7446872c37ad02b9932da2eebb5a25ddd882f8e4b7ff977f6ba8e128f59c20f8f1b9d3d3870abe844d8921e768efb9f719a5b241f7c3c3964d1d4cb53302df85e944797fab588b704ae6912cf3ffbdb2c1f5dc900155276391260ed1f42633e25163d7d38d5549e4ed63e1e71470067ef165ea550d7730dfb1b2529a99febbb65e56b38c7165cc208d9186a2b026e3e632884012a25699d6534a0241ce2da118dbdd6220614d95ccae2913976905c89bba679f4a9d2d3c4b255f14a52ded34e03d5aff09a712e876b7758d708f0db072e63f237d5bbb1a83151e6cf494aa3829300496665510c387f295f3808440754f0da6d2225a6eb3e13b6e17f12e3fea0d0e458122a0f579b4d958c021f787b46d7ff0fe5d3accf6b003f5df408c17dbd4c2a1925053907a809b5dceb54f5926b5a76992e0bfb9f3bb949fee352c467ad3ab601d2d8bc7178e6773d11bab2a84e6fd096556e052d065d318923edf62eb07825cacc16d3237601977703b5812be796b1793d968e202fcfdc22da4ec45ace7ccaf630df37b2ae292e160cd49eba91143cc537e5819a4b17567f9bb09896634c834e052a095471a6d4e0dfe7b4cfcc22175708f085028c6d4de070b97f0fb9a97fb4652bc647c280144bc8e7c8a3d4b5ec701371c38c61bc9c234158f9b8f756e5468ef58189441ad4d230315ec9ce8cea93252046d6994c5277a6948a7e6cc587c9bea307a7b314c177fd0fab6583a56ef060aa77facbd148f375a1f3cf90a54c27e2494745c732e8d3b2bb5f37cc6db57121567f335a44477734ba28b0ecae727c458f343c54d282a51e7d7b67974e8120ca1df3fdf81814a7f0b0b9b958483a90214683e254729feb09610bc5ba9c38cad1824cf2f0a5e8eea2404dacfd1dff288896febd847d9d95d87623f460225c30a527ef6ddd4d022d23e300b15bfb3c9e2c4f82a19872b34ec5aa28ba71a1ada226008de37911defa5b9a1dfa5aab1527ab0b829064d2da044aaac4dfb79c1f896b7bde7ad77082da71683fde9de2642659413cf9a2149c9fbbd244b744d65ea62c17bb03c80e3e706f3f14f82872fd3b03c5ad5320fc9b41adb1a34b38764e0d117e9346dd6cf181b3d8ceca2327fdcca06960b723fe2843b42237c79ca6d45350af97f86761be24d7cf238f54071fc53bd27319fb5fb57d90edce1827d36a01582cf775d8e249679e7094765a88061d638569353ea5f6a10ee1cc9dcdda435c6bc58ee6ea44474ddbe1c229ce1e956a33ca0d0c487cb02b8091aaee8d9898cf3e380ef3162bad8ce351f7f64e2edee156bb587f3a83b314fcd5d81229e9559654f68c33d93947c05e22776b408810ac4ad99a524185329714c88c70dee314f7d5985216beb72a1d080232cc12713b81f742bdf26aa8dfecd03aca3ea5531c09f3af26e9ee6827286d294f0ecde70e55ce7cbdc850b3873f0a3bab456a4f90a94d7fd0a5e182b09b55e71c0cd6b649a5b02c388414cf5981fd23696cc3921a8db596552dcf4f00fa5c5481fb411d839adf4caaea9654e568b775c24c40b290abd164b0ab7df1e31c851048c4ab5cca1eca6085da6f0390a6bbf8fb04f5322350fcfefe1aa199b72792d98158ba05ed600e3da40994190b99204096a49baf4ad90f4b093091aa34edb72e8af3dd1b338e0b3916d4694b439b5f61678a83446eb6fc6ddefe0c813baeba606f95b6beaa690dc88374f089acc1e6618d00b073efff05daaafcb0ad6b655bdbed2c45b3eb1639e1b08be5820bb0c4b817c8b1bfbb8537e3a9f320f9b6980d63ad23c0901831764060daa23bbb2c3d7429edac6337c0277694cbda5d987439b1ce644feb33c17b5b3c495c450db9c7e33b0c3bab559dd1558aa104062557a46e9f70f86591f9cca09ab42198ed7b580d73f27476345ad54d8fbdbd64d8ce8cf94852496f44e5f7c9334e4348a88faa8d15544e778bf5d80be7affd5be1ad5bd3900fece920d2bcd91d0e2fbcba34699183464b5bec239fdabf3a11877785df7731ebe638f4367dde8585523ed8948d1f8bb638dde5dbe4fe11978c48187e1fe0260e91d0e585bc1e82372c449e29495b5525c0ab4fe5c22a003094bae810066b010f9da1ae5453b32a5c9b9656dd83dc212bceb5409f11da78f2a71d90c606a7d648c7151a669c66386f4d822dfa07a92a9ea1faf6b103f9ff9561b1d286fd315fb32dfa05b079238f12b050af127487fc85c5aa309d54d6fcffae2dac5355eb06f5ca052f81e41a5d5f63305171d8c80368f9f3ff8dedf9691b0ac8e5ef965ac3e919807b807bd4e3b4f4e5385ab524715c9ee0b5e3436b88d22af36d39203fc50c0b5389e7bd0c4df707166106923f8b78b5fb893db24e79215953c4066500e2cdcbe45f08aa63c7ec139a8c19581faf8f5984ea7a6386a1cff1533c89b8b7df47c29f344cd1cc3969998739367314a20a60c30fc7fb9fee0a6956f2a8cc8a0d26b8e1cd2502b0213e6b4301271b032d1f87885ce86829997a7f05a38005c5a06504c6321471bde8270658fe6d271715a1880b42dfb2b2917e5065e48e23088e837c206504ea9516628112028ee053194c2867d9fb9feb01d9feec4ded024769d503c2e00774b91f019ee5849872a554df0cddf3d597a7f6f237e90ad901a4bb682b9ffec4e191e77f05aacb9582f7e08e7175388d5248d2a14379ba065b0434c29fdc3fa58d76798edcdd95547765d1e824c62621c4ada225292ab19c7facd30193a01a19123127248cfdff916c370d5e773b2c07fa49595c23ceee9374b6477b912784ac07e97a72d8f81eda9c3dce18f8ef871ec7eda629a10e19153bc222519d463421a7294ec8e1665d4a01cf261ec3d5e5056d0333e357ad98d01c510afadbd09b92e1592af23937f9e8497e984f754df84619ca6f2604251b5812d2571011d01f1b7d3fd4e55514b71c51c299c4f181cb2744376e70e0b77b77b227e548dc7eb92e89a37b1c030c8fa0535f142b399e235dd768db40a5d7ba26f508ed3dd36bf8359e205ba4ae221bdbe864fc46dd45d87e9307009d8775de99a606c13193e472c2f5038771656991468c7d125afd9d63c305448bc576bea5843caebdc5a98a931f101bfcd28ba0d98108aac03c0e82ca0a57329ce95d1c534c35603f3e97de08a700d5d21b0be71f798cfec497cd7270906294cfe947a34a702f1aaeb1d493d526720a398b526700197d4862580e378bf6107462dbb3e5037be092292dbe14e19194e409d1b47bcddd71ad1dfb5ad2374c8cabc08e87c24e511ef62c81cbe1bf91972b0eff9e1173ef4f4b95ae1c75bd50d353114476a0e8b225721b547d00161ab5dca50a5c1ef59cad7bd53d7b8b7e9c066d720e47f98b5fe629c187daba628c6077d47fa6225f5b8130f1f35f55b6e153047b70b2c74597da0a4c3c05e5dffbd3312cab52ae14844791a4d39977abb0ba3259279a2464191b8be9de9ae044a7704114b30c1d9e43a0c95b6826ebd2cd701eefe8e00a14da32052fa44cbe356430d6ae12f361bcd281226ac3f9c4eb5605768f9956f72ada3fd15121f2bf7cc9a388ad16f5f414c9b7eccea0e99fa2a5bebb7953c18e54b4b3f5cb2339ee7b3bb194bcf61d297c6d4900c146f3ca4389aaae2fb5d98af2949224920cc03b8850e99d2304a309acb67f700e196c490344ceae1cd06ad7ee9069d9725dc35768f8c07d8c6ff3ff4aa5cce4b3376c9c048ddda22dfb77e2d202ea190ba87a3dfdfade581272020f9f66057c816bfc8ccd677be8c83e43175e8b0d79013ac6be66f13c4429ea592c44242fb2dec19f2202c7c610449a9a626395de07c2a3dded997dcbb4d436b35c0ad94b5685dc33a1ee2dac0a5592654c0602714a17d9c0527ef8ed1aaaec55ea70c04436b1f54f90684502ea7cea0f6d55df4c7dae2243c515c2e51f6c2e2014a4d390bb84f9f4d5a459a2617dbb97f1cc30edbc0de5c0d993a0ca65c52263cbc72b63b6c9df36fd93a2d122c2595a88102c4135cd0a971dafce238e3b888741da51e6c1eb90e1ae5c06e051815fa28b5fcd7e234f260b1dfa09b7b59f92425f8a8e28e5712cf8c262473655393a9aa8edd5645c15e35fb9380061350251e38fd4e0858cdbcf0838ab85db41c10baeccf6dc5ebd55e8442b6541220a2b5fe70af9a4ad276567255d028a4e530494483d2ee7b1f68f43ed53a27335acebf782d398d3d2f8512d73829981e9f15e1539c34b30c3394e73b0973e69d68dda0263368651d48efa3f90e77a5a9734be8a0195df928cb49b5d9279d76a804f62788e1c75e3b771f821a0823cf5df67e2dc647eca69ecb7ba981eae4bd2c1c0196c6f8eceece40085bfd03f494713a3a511890da176263859c6b6f88fb090fa96ade6004f8ea0a83315801220e80a541d0e7371dfc139e4ca612b9bcb06f2c719470579a75bd0d824c9bed7d7aeb3ad9de832fa617c22aede35996c633a71d8be9762772d3e6cc5bd3ad0bd8d0d896e70bf6720748cc6ed64a017dd6083c2f2bc6dc14d6a78d83b78f40c47d35920c0ab12fc133701a5282d5e7c1150562a6901f54551cb030f3837b9975b0712e002866c03885cfe0c6b71c342f3808c6fc4c9434ce920e7cc154b13f7359525536cd27674aa4c8042612b7305bf04f2af758033c3383f8537fb99b860e1dc1679b133efdcd00f6629805a51ec4ed63db9a8a28a98f7e096da081fee14114e33d1d05261c273fe21710c05d910c5d905dc94834cfc2427d1731241d8f2031fd8014c7adbc1777aa216b17a6512e1b883b8806ca43a9b9bfab3c03129d2ae6b817069a3df783790ccb4e585d860ef0cbb172c7c0d349e78a9c3b059836c9d458943b7fb0216b807cba5583b95c65b7ecb71cc56abf617e86a85664ba4d2aa8de18feecae1fc0c2e6c51891868586c8c63f5c4a3ed2355297f124e11428e7620ad9931c8a41f6fc9e72c2d88f7b8cd626252408fe9e9dea8283bad0c20e10caea68fee5b7c145a93076a11ad85c4d7e09fb3c121cc0d9053c186a6a8f048930e7858e42775c9eaee31afbec70289dcdac109f19134a9fe65f54b908be1fb6fd6bfb6553556165c3cca675633ea0ddf08676ea28f19b420160d1f8ac4bacd63460eec355b4cf9a279f9988ec060524e3719e7856120e42e3fa2ee0264e00292c1891d8625a1d3f4d45e346c067662b93e34e4faeb764516fc3c8ab2000635e1aefb9ad868fc27a12876c7ecd1aa7e63308ff2aff9893e578f52dd93324202ec36e638ef2a426d284fa4a4b04418dc7c4fa0635443be359e28071879ddb217eae7d6bbfd9fe884c03890a392fc869b2db59693318d7a7ed51aef2d59a530278f2c7811366a800ed8b3fb13d03cd955fd3bc6b48917af01666237e3ec5e64066ab547cc09f29e58682dd0bfb9d4c61ef8d1384294bd5ed5afd4051b20436277361764006f9ee657c50d8a36331bd00580f022625982dec0b1d3a69881b7340f6bce7dc6e284679fbd737c51ef461d559ec0acc86923eb13fe3041648111383a1f45779581c4b226152f4139e64da8a86a42669cf7f65f36bbd95c02d0867399b3c73b7e1774a3824c2fb7e6abb6635d852195399b0de41df9365d6a278b941c3a6723d8b7c50d51c6e7f30b0c0b69fe3167af579cca39cc22c9a71c57f8c6b3c4cb7486941cbeae9acfb21afe887caaa23e44b76c32d3571e421d80380d33cb67cc1df69c0993f6085d3dcfd2eb724e132554568b48606c876f7c55a3fdccb38fd74e29773e004b2f63aaf041d9cb1eb191e908b6ad7bcb75bd036ccde689dd96a9204369946a846a1f023c6f5c3679a85f93104d90160619dd6d6579c272a00b17207531467cf35511edf1c9428414d1c44eee2b43e4811d6fe709a04cf7e22daa86c06fa3b2d26db05d75cc77262351e3d01034f77d42af5593a40847a14a0674c3d679a1a24784895b4d595a8390011f5adeba5d54fffc54d98df30e6f9806fcd6d0476e4b641d9cb8117494c7983c2e9e1e372a5b226c2d8fa609564d7c646dc66d75775fb28c9a82cd730771f746ba1b82df8537580511865d4fb59098da6fcf3b320cc818c230d027e3a3f977a4faf1f1bcdb02951ce8cccaf8271df7a50c4e0f5bff40e84e09e39c731db79f4be1a5acd01596ccb413dc62c7027c5bad2c28d3996189ff52527a6a80a1a40cc4a1516e44ccfa72b0af1b41713dea73597865fdc8e4a368b1b4ec366b324dd232a7ba750c6b399bd7982493b01ea9c95c898a013d115da28bbcce4c859c7c1286fe1aa8331f875b74be04bfd611264f6f92a7ebc8c38c03b9da7782feb77825ecbd1408c3b95bb9a787ec7c3561649d3fc408a1aed0195fa4cbda20c77359f4371fd56a7e613f4102f3b8c2a4cd5c6703f718af6d4718f5a5fdb944f3cbf87084876b1c32647b67bd7dbeb13b9494c82432a3287067965c5de6e1a74ebaa2af1e2612a17d33b6ee9f0d402128ec5f9d492b05562b21af9ea1762e30d0429c52cf5f1a4bc35ebc1ea0f7108afdbab6e758790966ca2fcd2c5e34c21f743f295d9be7589b8638a0922b1aaf64db67db12bb514c9a7e027e804768a0f62d8ecdaa03a5df31eb8048e245a8d94c262b61b6dac38303c8c6fe1f89c487d5fb46155e1e597952e3bbe05c764ecfffb73f77009d80e697e9954bf3af35dfa16122640ffb4bac823c1fa6e230eafc8fdb65a98f347fb2e003e4aebeb503e4b2ebcff9088816b379c945bbeb3059c31fa89e5d4ae82cc1a928737ef264796bac4ed951f8971b30974c191379a7af5d339e4e6294f5e6c560dd6b88999ad6366eba8c99251b1eae7294b089dbe2b644c87ee4e4e88c1f9a587a4402021b944e6f0046483d27d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
