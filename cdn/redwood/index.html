<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"058131b45f6274f4b039b5c369c320cb812f8c5b0f02d72a64d8c3be3edb0342df96a3f12e8849d4fcf28da91f74f9b3f868062ff1b34b0471c55a5d78cd70f623c19e5d46bec9e89cde0569a5c6a425b0c046032013c0582a30e171fc359629f65cde3f844f7b7413281a88fd2a46bc74b4396227a669279b22460c8efebfa21ed3dc8be8264c7ee417b57d5fea1ed1c278dd1c43e3ecead40bbf54c54c0217d9aa2ff66a6a0d02f8c3659348f91bef70574fc5d5206c817b0914c0b301171587dd0e2a3cd2354398ee15b9b88ac22b80604f0b7dc8a522f36be6575ddf3996f89bb1aaa1179443e00384ebcf7ed7f9f677d86140607de428f00548819faf449c61407d8f9b0b4063e6c6631ab66caec9689d8c0d5b0a519477a15e0047e171a1686917d18aadfd619e2d2a92240ce17f38c853c66bdc60e4d9b8d9a680a13576c1f2c85abddd02bc4cea8c4a4ecf41f38761d56a9fd9aa8280ac00cde7a45886deb3175fc2c7c7406640b940c41437b348a8b0030119207a6e1bb3d62e0dca67eda4440a3edbd4b06ea376591493acd697a62059d550ba9d6592a25d6b9a7ae19b1b6870a8f4eaecc534022242fb9b8c72b77df90107925d71787b7bd798f5df0e29dd04ad579ad35a69df858246e7e8d4e615914c8d55ebf1db97d84058c9b3f3cf8b2dddca2c8a45435ab426ab7e06ae4ecb93eb2eeeafc6bbc0cf3018cabfa1b325b224c7178381d1d39e44043d616a016b233dd2cd5572712279039e7be2af853b394ea07c01eaa9d83519101fc1010a6daf4363d068250b9ebcd062f7b738ab799bbe6813ca5334858c0c4ed011f19023e948e8d148411ba99b01ce9641e520d50037b96dae84946deb1b3123392d7b89db27df7573aa138c490d7a44b2a263b0476e79d77e90a84e6f1193de2e96949958b3891c22e3696d844c85ab318b4a8fd8c18ac3091afa94a515c75477893879a999b9d238caf6c504ee59bf4b2fd6c28d29be8562e3fa57a81fa0943e44e8334b4393935dee17b7fdee8862727aeb582fdec56de4fd58a69b0ef39ba3ffa76922ad57a53111805f897f53a4aae4bc79add5fa6fa2f79e8002894aff09e3df47b7e53ddd5cf91fd380e51062d00ee25cf269fc66674287cf91777a48bf0ee46bfcb15409b20e8f062b28381bdcce04b27718c91702991297e41b27625537300735f24d8e275e86a2dbcd4c246d2444a929b2da7089d2bfa10e2f0a623d54d748f1ebc6bc6ee9bf2d0f6695e24d3c66ed721f14a82424f55d6b0ba5344bb251ac284fcc5a60f6a43bbfe6c25de52da2cfd5d39e33f43749d86901051e85acf11cc374140f82097a8040dcae1beaedcb4694dfcbbdef1d87dca48554c59310534f772e420471be4c07a87321c2972b7fe4660da3c125c8301b722e7f442210ca37761f091c9ab031cf781aaf219683336361f8cdb0c97cafe446afc640b345abbc430bc35d2598d75304cd9d6ce80b9eea3e3052b4fd360aa5c2f73e968352d9228c922796074166977e10bc4c7dda675eee79156d1c99af8a451655dfdca23fd35dfa658651a665381dc32926abf8fbe8c5876e3a3e6c5a192335bdc42f9f17461b930cb59edf86c40658ebcb863b6ec3de2955a106cb6773aa8998228d0ca76104d9c34b932a8cd7082664cfb4df10cf89c9a66adf56178cb86c7a619f86e59508d157c11b423afa96d4f6574ac408f5423127c896950f890572ef2d0842539bbbc540af138fb4cd92b772f1e942b5458b92bc7a698958d573d5641720fbafebee891d5e61659d4302789e8d8ba28b2be398aad7a39556ac55f36081fb169f9636084d919218f3daada157312040a19745e23e0512fde0fbcbf637dac45c032d03f6ec4acddfc076e09afc701c507df75f091f1216b8762a01cef385986e7e8bb06bdc996993752ccc801f040378123dd340f0c427ef6566e7239728c5bc262672d6b896b451603746ca1e5d6d0b47e034e9438a8504a276e7e8569e31da76f306f1215b5a946e622d246156f4e2b6cab053ab3f63ffc36a30cacae65fab57418f1be91d898304e6929c2983ac318d33726f9357802fa5815065bec2f5d205c115205b8b9915cfe541094a2cb5cd824d5916485b2cc4fab7435463230da4da333e0590d7cd5b55f5498eb2b8d49d47ec4bb2952b32af3a7e42f139c80bf81c2ed8ee0012a129855e783ac8db56defc1ec203c41a03ce0b96e56a16afa947c326db9e3738f156022c14c2cd85bf7fc1779394e6004232de0d89224488e7018e512ef488305bcd4076ba3d8d08a54189fbdd550328073ef87e967187fc6516190cf3917d9189e5dad1853058a13ea8420cd6dc902a1dadbebde75c58f0a2e966b1912223c42f7d6efa4532f459c1ac752eea8394ac8a0ca66c170de724e78fea5f6f96a1c03d777c153361e30b8599d438967dd7ce678fe0bb5281b15b1964156e4053c4806a1ecd264d7fbe6efccde953000bddf149dba5e3cf69521e93afe22910f6ad8f803f28a296b137fef4ee280b66bc9f7396de172cb17073caf8ce430cec0f04b79b28df51443b16da24967a9f4c37227e1ce483acdf06253f4742c3fa47aec0bffe7ca1c4115e401c2e29dd28e3863d0debfebf01265124cb245c04e0d3a3cb379d346f3a95307b7aa69e591eb45953d4cf57984c1e66fd0cb2a8fbeaf0e48da6b314b14f54301799babf9eeb00de8022c04efa685ab94bc263435f168ff9c2dbfdbb85bd226a9e53197d5ed8d94126dd82168511fc4794b90cb1e6cf440e71b4219bfbac1712f87c387c2f6b37576994cdabb474ab55278be52e8cb4b9fd1f36e4350d483abf91ad908ff8afe3aa124661e2593fec7e9525cb30642e21a2d2b29be2b4a68fa4fbdbe20bc303f3045adb025a557b052f5275be72b201352c182d13362ac377894469e405562aab60d1657434c3e2f40c2ed8fa686a55b105ff05480741ecb131b2986ebb73f42195ba55ed65ee991eff4617e5f56f2a3af7db8808a49d020751cf2fbdd004356bfb797391f538abd6ee217003f86767f65d2055167ad14f9439b762f9e3a6e5181906942a811fd35d7e725d8ff26861f06c6b98ad251170b393da3474a7a76d2dfa151898f2809dac8342e98307023d3f1724b263204cf4d61c71302ae6050198b13e7aa4eb5fae63d4640f72bf38711b94c60c8cea053962d7fe46b262ceeb486db9178e090082596dd193ac4c6c4315b0e8265a750a21ce3963a51d6392e021fe103736d9065b15ea1089011cd54c3eba51360af25de9b1ed90b157c81c84ff1e025215fb441cc095b51b81409b7dff2d9ebef9ecae903e25ab7581e5ff7df7588659e5b17f99816a327532a86cfc4f19ecb434827f2d6a1a805866c34e71d5a0041f628f5da6c51537c6fc81930418beeea0e3317f43beedc7670f46d377fdda85cbd929f2e3fc682668e6e5dea125c08d892d452aedc7f269df6b4f17caa367e8f8e25b651cfc2b239595f5d8ad71dff51f226b564dd2653bd01373edb87a3a0b0f9f2efdcf629c6127131236c36edfc486a473ae1d246e49b8f112c2d0e6d443772f554ab430c074dd779bdd81ca0bd58abd40e79e3a49f322fb795b6f93d0123fe93376ff897fa6fbc7cb110cdcf50dc569c8126f12c613f542c086245ce8a05c094326c0a9c751e1a2ae5947b53a844517cc1df0ce0cf379c1e824197001afed6809afa0276fa90de875043f0b4d4fa8a97960c83608e9bcc939a86900106d9d1152b21d138538bfb54d64bd7428dd7e0adb7f0611831885f946af083fb06a22460bd124b9aac9c131aa93307bfd29728f1eed356e40970020d34883d5741f0fae1baebc774e998da34e9fcae93fcb482f8536b4113ac2960c193d4d89edc1fb801cde0b71ea0af1cf3e8839f19d6abaa4787030660edaadd38dc4760f4d233663f35b675536254c5b06c6e4e374d29216190c79d1db78ab2ef57854923390f260794e90dca82b44a7e08b423b0405d0bb0d0768e0285ae34b4a6193cde46b65bac4033ea192cd84083a68d395ed071bd86b5b37f8b0dd25fe140a5fbdc0409b13a0ecc67afad25ff066ef6c8bbf343be692c0f63907e1103141bc1013e2e1a85d0eaf53dc166a5cd1908e06b54d0cf524a85fa13e2cb7285c1b3d4dc3c5ea8a4a30811d700d22dae634bcd1de45f75180e9e11001653b528d65d36fcf058bb89dee57dda0581cbf5cba428484d86ae15ab4933365140c3b67f8acf01d446d4008e65e9747b3d1f841a7ac4ad40b33bd3d0c073c767bcbfd49126427a3983034d6b88e8157a476a44fb12667ed7e51911506100c121e89b75816eeadac8e296ef16f9fca5e5015555036ad9eab4e402cb25063594c5beae8b8aa5c6fa747e12fd8e870f7d65e0cabda20f9fbea42f35bd92cc53503d912aec2d9bc17c9ecdb22fed9c03491c6b7207fc36f3beb1f31e606cc70e21e8d586c94d51541b928c0950268f3b5d6404f6b0ee91564246583f79b7e30747107e5363c6755a49bd1b670085213802bdf62ec3d14c5cb08f95c3e8855ef9ddffe157fa2cee8707a5b7275006e5039051ff9b1d76174d9b55703ba79d8cef424d7ee7343f00ec573dd87450604210c1cbb5fb0922d8ab7b35362dc943921563730f53ed9670085f30fd4012254199aa048f04fe87d4474635e38fa2dade64da993a6b0aa4d706107cc5df606060b0aca70da48f6ffa676d654adea0c7f1c2f7823184957867e79b10dc7b716bf213de4a7e1c2a022a84315a8b5ba49f8b0d8ca1a207c76fa6c409528aec37c49d407ded622e981d495f5375c887a0e2d0fdd62585beb580686081129b9c4cfe418133255af43f67bcdee9b9fc1f3468c2542e32bc2e8b1441cc578065d54ac2d9b0cac404974bc5b3e8aa7b5bf57a97552e7fa7de9b38f5c55a25090037624c834c09ca15142caddaca9f2d2b82306f6bdbdf243f094705cee8c07a6e233c4c6eb3f708f57a034307a5470016764c0d8d411a0bd2c2065498c810b1586ce4937b2b4501cc544c74963d21a3f275de4184e9b2d798da9c219a5dde9b6aadfbf7196384502ee951079bf30eb7de8187b9e5790e62028347ebb4e7ed477dcba7ae2dfb275b2739f3088668265f83f62045a2e076c322d51df9e45ac94ecff3ef3bee7a7a558db25eaface3fb84c2b9fce2388abbf04cc213a905fb5acc6b023dfb661b7b3302c7e1273c6d5f0f45576f7079fe086dff8a2b1557711e11de46a18ae50d1913d71c4d2ab24e6fc4d64efd0d1e263b22c727f567e7dbd046083e145832352f4baca5d8208156e8fea595c47b9547394dc90bb957d2f92fdd0f5e9d32eff08fc43cd1fc54accf5071fcb8c6bf41fba7ddf23f07a9efb3707cbe82d0351a50025a52c09783cc417c874cd9709f60dbfd68a0850ef44206f9510deab3f2a80a14c17ebd0a43c32569cb4dd378da51cae2f36ec6f6f4f580d72870e05dcce631c057ef49276ff5275677161e7dbcb28e1665cc9f215e7712fc40cb6af63040aeddbe345864820bd07589b10f1dd3860e1106d36938f695e06d22a33c88916c0cf6bcd07b01f8d6973ed25fe37495dfcc75547f82453ff0d019d1f846156e3b447f35505cc9469a259d494fe82767fb33226f0ad5f72c4488ea7f16eb7627711db5d19fc6de1e6561eaddcd74f11be52e789921e63f5d31994f56b884e6b9fb03fec871707fd1df1e0013e887d6ffeb70028f766f593e0b91f319c52c0e966362524db87e82db5d8aa5783be21aa6f27e8be5557613072fa4f3bb72b6ab756f9946f4703f24182f741659a9ed801e4f8e3b4c4e53c76d803c6b557d888561944b55acff863e9e79161bf434b3d50f88cf4e31e6118efea3acca13d5f5df5cb02bcc020f392ae40e713c4dfbda94686cf7da6fe8811c150ed69d01eedfa87898847ea0f5548cb9a4e22e47eb0d874eeba87df93a76baea028e83f0e6a77e4a91dbdc0d7be0395146fa2b31df56a08e59ac36d3bb940b656892ae0db0c8c94cea22e7a8fd39402066946d6b5dd73ca73639a8afbdfcd089561643c91098ba7c00f39f8d27071851a8dac10c310dab2d4f59949d8378ec4aec9f1717c29db61a3ba5cf7444ffd4862c51e6e92e1bad8f0a8066f85f9b28dbd5794bda87cbff3066ecda06d528f5b22c0b17d47b9e05267f1ec5935163c5cd276ffc0bf7b0cb3d9d6d243d7531118474d1d2356b5858221e19178a28bc87ac7487912d8b8c93e4b30739373aa6438d8512fbf0fa8c18fc28b9db0e75d246a4053582fc1c6af5b4d0268ea3b1306f79b03cb0a5413ba5c869837eeaaa444fa8512258a966620e6630b0a1a936eec1d35099edc531d1d3453fa310bc0d99429f2eabe31a1e16d5d70ad6bc6225def148c45393f046905ae7713e5fc5b4d075e18ff042a01c9fcc96ca43626cd4c44dc4b90cf79014ff3287e2759f226f56a50b1a8590d4524a66135544588959c8a69267fc7654050a8f05747c2e472c313f33636ea567ed3a2522d7e80745fff9e6c2a1117758089c436cbd721c05faf4243ca79e72dd616cb0ecc6cca97768015fedf4bc86a6e643320b3f76b03daca31bf9f558e3aa08777fb48a2249f17d80e7db912fcce6b098a73956709c5968700757901a6c118a97925af288865a0212588eeefe66af8660a5b17cac5aaa87221981b82547f2ad409e3beeff762c4d3c624c58bf51c7600bf43fd68bc391e976cf2082b3ff752d35c6e1fd3f56b121d67040879c9b05e21fac99482c874978cf070fbef5ff3971d1e34a471e2dfbd7e90e69be183e8471b1e59101502300afbec0d52ed7520d86634761b38924e58102f656c4759627686f17ee800f144068cf00e82df37688f67d442ab18efd22e6f2979e6ea2b6ee8b10dc9884ca4ee1f3e0cc3c0b675ee9c680282d5871760f1dd0a82f3fe356e7266abf0c00c599351417b03edd3731d253c3e8a799d2616bb3c1861fa5277e2be74b1963170e4ea16fdd65be3d56f788710961c029c9468ee945b5ea0a3141d0559bd98b2cb0057386f7f595837d8afceaad00b46072872efe851e7da72bb84a7e4f7c017f3207d8d5883a24a0eb5948446cf2a03cf03d23e2d1a61aaadbe600176f3034411a5dc4c27d5845695017db51402fa0c12c54f18da8bdc1d47dc161ca67f0f8b043bf3ab6c0b7db2eafd4f4db2a118a29b051942500812b3265ce122b07e4c2056750d434e516d7c7bd93b8fa033872ced8c7d2d2fe134134c033b95aca305f83b6c20dd6534ab2e6e8eeb865762c0ee672a43f2ba397d904c8d120baf5819d7472d93b9a39f72f2ef30340dd825cd43977a9f19ce1bb2cdca7264586207a2ac67621cfa1adda76b3ef5262fea7a0965f56987d8fa8a1f6b7e6348c40e34f4e2ad784cd412739fa28c35256527035b2792bff7db9b4a0dbfc66884b751fe17e9cd3e503d762850ec387f4e6077840c691ac9f6231d1ab4d3f69776bbb3abf2462e1858ae9d386f4d7e7c8d359a53a4de00ff3ae1e4f5d732f940ee15404b9751aa1203cfd221523ebfa1acfee6901c0947fb594e5601d5e3387ed1bddd9c841cb82e429c25e96c375c668f9599a4ca560c1978d22a02a30a3fb334382916bcd09103a6bf53f78432f7c125b21f127c3ad3ee155fff4279d7571c1905c9c9c0a7eb23201bbca064e46fda08ba457da90714568aa789b9d4a117c8ef67a7f2cddc702a6a424b7e5d8f85fb8fb809d3350929a10727cae1d197f96dbf0c5ae38a1c73d4aeb39fd734e6e1094aef2486deae07cb05c30e94f0351d4f771e7a7b860734e0e81786920c77ad56cd13f5dc4653c9ad2d8c4356a97a1e657ce64c5054a7ffcf0819ea70b99a9f18cfdcf7b1c774219840c06f3a4a9b73fce50aabeebcc70788f1350dd559fe0755bee854d2ad18698aa8db5f6111471878d9d69556e9099dc2957069b3ddffdab9a7a401a4126121b7abd6006cfcc68f145f562585f8c52c62168376961181554bb1d4b62cc6ea7c029f53ebd02ab428e6ba3ee48259e6cbe124e954c44a0dae0a89be50da14eb77532483a2660d9043d96bddba085320c987dc7220a41f7213f7c85291810836a45c8974556a610b396ea17a737a7caecc71ee7d14f3f090184688bc939b06baa8bad63f761c392564cea121afde05e9cddcd9ad77b58c1d0c4886dc57c10491b1074ce10129d890ae1414d28d8cd84a6ea0b65642bbd8757852780ee8977dca8b66eaa11d8ca710612741862003b451f99e379e3d4bb7adc3de23f0cf9b8fa482225641feed63ac1a3b4c9d9b0568b9b1f5fdbf65363f77dfb080f0411dd89922e36a55a3108b2c1ba59033a305f38fb3c50f489e8af51b4cb7f0f2ce077ea99ceb0ebd582cc056358c6fcfbd44ac40d7e529d3f2c7b7fd02710c2f626b3d9bb18183cc03a9c0f85a760a71ecad5aee4e2a8bfdae5b65fd4d65b3549ef2769f3d75850f2fb6a9734c19a8e7c0ed0b580e4e8eddc37bda73bd52aac537407ae5d6d33e89bbf94cc37429c34072c9cb7298b56f59fa233d5c3e1ca1015259c2d12e86cccf75032f5d2914a799ceb187595ec572d5ae4b5fc97d88384c3f0c9ef44b4683280650234cf827f241cd3fa05ed57a9f3efb0710169d9a41af7dd69595ec99281ae3f88f9ce37c3cec3bb9651a4d790f3e1ad96c6e08656c9a810e8e6af851bb0dae4976b0e70a2337c31ba3de50fe8c3eef15d0ad04da77a4caa1c3736e71465c8bed733e66aa9effcc8cb30caad065f4e6e20ed47080982b61414fe7edd6c230498005072bb5ff1b322b5eea820ee16897e0e401b2e12d0ad421380ac1a491256abab88ea1314c26a1051dde3da9297ea2302e99483baf88dad60fb3135df82b069c978e11fd344cf67bc91e43ca2c25dcccdbe4b5bd4245eff7120d554b2bc15eade2a1ceb9d7d6daa0024c3029e880f16df2a5d6c29f1da5d15b61e1b606888619b3912043412636e9e6b223ff3f5746094af88a4ed3a138d26a14440cc2c046c3919104ce234292aa20741ff4a72fb4aa6ba6488a403bd36f4f2b30b75f61786ee315e9b34cd6868d32cf39b702915b04588d01efbb423b40cde04f30a9af1b3e98190232f2be468ca3fd3c68f4eed9fae27446d609b1c2c739a7a066b8451198f1304b217bde2f7ffa4333bb1bd4aa7dd10124dc325536c088ba746b08a45d67bd7e212028f35c343461b5dbd92ff4d11f2a70a74142a49528919785459f874c0cd797dbd014ab30ca41edc5b7a7f45134498a84e5e6c9aec743e9eaf449ce9330fba2b5351e1ab1a31087b63ada73ae902a21ad6132e45bdb7fa42163ecb9cc75fc541ebaa43014a68143703165b12dcd960fbd410d03e0957c4a685b8c8a8492fc13ac6fd3706121dc654e3a2227b4899c4415ab20d2543418c154be6991760525d51b282b37ad402b2e5fd38162b471e591b247d4d35dc02bdfcf9f14749ba07435423154dc65d3e006ea3273b5de78d641320c85cab5b2dc9fb2c3106c3911c41900780d193908eee78f47a326b752e52a77eaf8211a667311bcf23482cd08140a91bb517442bbb7343f88798a99e7f23f8c177aa4198a6e427155d07172b4548f325f53c4b6c0b4e8b6d5bcca3b38ae5db2cb6e2ef5857dcf99e1260ae94d91e6ce0abde076d7415d8a04a4df84c6f6fff8375f1713bd337c08aabba6d8be58ff292997140378e1da11bfada385bbf54af165ec9a85f560ab2971ff53a00fc778c08c20ae807582d984f73dfa9e8d53edd7e7e8564ca9bf54576519d3bbd59a44356e8a0233c7f98af6e951ee9d44aa3b4df34a6bc24413920ee52134e052ff6cdbfe04b1f00b02911cc87a993dd3f5af73e1d76491053f8ed5ebb0e3c81a5496883c50ae9a9a6bc48b1a0037a90fd45e3d6bec56d266594df153fc9f4636b9c40d3e3ba505abeab6945eb556f135b414e143a0330fe94658b272f0a7db06d26f490ee0d80e6df55a651fd844e42ccf9da2ff05430efdc2b0b57e7a689e5fccdb4343975899c5d4aa064e6cb2777d8cac9b8ab51ac24974624ad08234f2abb3ea0f9f43c13afee48030af560b6b6c7e04328ab7537c69bff7bc72fdb4ac623cabd59c327cdeca1a1c22e86e0f3d976f60ef4f22be9785c9172978d29212b3f58e898e210671484eb829c11c4d4f8a16bcf0d3039500e110f8bdb56e12c16431fd6aac61efa3e20eb29addf92e359c80d9f28a4c3f5f6ac73e5d3e1878bf673246c508cd1960bd50b9f45e5c005bb84ce75371af36d375c60c775477d20e11006b34d1190e21087e9eebafc73289a280aae74bf32ae0fbc80978e2d55159ecbdbf3a45abf1c83d5882192548c10ec41e917b5fd464a208adf905a62e7e4b26c2b94e736eaa7ef974e3e75aaa7be22c17e2a92467fb5cc6e0159c4a70ae1c1a165d55b9ff61ecbef557ca786d6616ef4c53115c6e1f049ff44e62ee31eb935ab8517946bea9ecfdf2b578c06f8fbd8927862aec90a4d274c559d99062fa4861d6f95e4cabfe200708435e3d0bd4a13b2bc23bb5e8ec7852ae7556a8e61a8e1736c1771687dda39767730dd2f53700224472259797b69d14ab2b4a22f1fc288cefbcfee201e18c821af00f62702c80bfdbd5657065f53b629fa5da0f064cb0f0ee1c4e69fa3113fe66f6b18d6d60b98f0dbc4713ef39472bc26155d7bdd68580b541a26fe4b378547b264b59ff24898a612d7a14c76fcee5c8e944698c072f66f205941ce417463dc28b6a00c13e0d971871c00041ef66c028f127ad146434fab310924092736d34e74bf5da118ce50358212cd7b3dca0047f61316750c669301bce82bc818b600507c605021776404b4a74ba0e8e8321f4f4cc13ad8a1b8cc5eeeefd0fa022298ef2fa0fe92b64cbd0d271ddc4e106ca91372c92564e2404c80e0614b6b819a2bacf898d29d3248aa59be0341f20fa6323d5b5fac063f54edb18cb85529102e696daf6118cc622e07419198f8e1153dd6681ca40e6261390c6b111c29610dd96917dd67883e767732c3a9ee8a3b379c0f6fa5bc47eb57d5950126bdb591a7f560d092c0a6df8e0e11eaba45e7da37d9a532bfaf3976279010d481ffb2fcdb656030e3ce431c0cca1bd0ecad4a4061d08733029da08c2ddcc7f87045c8e01b8709cc67f55f2abb295530046a879e5732c27dee4d20d8697e68457277da7615fc09e463f7c1afd663b5029e3946197f24a585a8fac54216f5fd6d2f56e94ef0faf28c7d668a6da66cef2e51a8bf973f35ebd7a46ff1ab787c84fab98c9efb9e2e522f7f4ad6a3f247c1dc6d316ad9474f4805485fd05e8f0891b8a7fe2a2ec18ba6309ddce17431d822a166e503c5fe7ccf51979753544f3a27875132d885655e1b0cce99800c429e836d12f822104449dcbdfd3ba8d5c4bd15f62dcda66c856b25e4159124228520282d11e860b6502ad8b64f0aba7ca5a714c7937bbe7ed585d9e163a9b3523675dcb4b20cb57b12b10f4b2f0cfc9425902ea866639ae5a6724cabb7746da604641d98874dcc30a66e81f95db59233c33f1195e7c2b3348c2f86cdfa34ffc27f6fda81682493dc4e8a645ff6758dfa96bd5340c3023ccf478929b6401c13e06ff1053ba44c9d15a729ae4ccae092be71c4e3e227d355c8157e3dd8e64f8b8d2fe9252d1dc3566dfa4be8db6370a961a3a1359dbfe491a32de59f0deef2b6e04272e79bb0601de23bc20f6e438a72a55235d61565114300ffce1ca703b51661bddc6bddedaa69030c2ea47ec7d2ec49768927aaf710150db9b0743724a2c284d9a1069b450a59c582879f07a5e04c154dca3f83ea60de4e4b4c89d9ffe7fca99796414ef1a3348aa33469730ff487d8fcbcbb0126c4b18067cb59e506b6862d210f575e8e11a0725ceaf3d878f6ee3a08da7754eb739648756fb08814afe82e3b71420ecdb3269ca968564067b5e31f757af2efdf997d5ca0ea4a9dbb86bb189bbd4cc7705ce4a8e9cc180295bcb051283a8e897ec414c83f28ce016a8ace171df430610823ea5c3f445381ee4ef5e56fbbc94188169226b5788b9c118b54c4c8406f938d7b056600bb84b41c5c08bee6b8c4659a52808ac05559a181315cc36e7d1d6149fe285bfdd233525aa9c7e0a479d5d02ff85b9087f9b4889aebf4166a2fce738843c48a32fe82f3ee262161c23d38861f4b0ddfd71567528f659a189bc1346811ec0030e28899665abf6a13011415c1a22ab2f1ee425623aa841187a7f5f28800523fa8bb7714296043c11deb987a0f2828326f63a322cb6b8ae9428144cf47e5fbb114fae4e23c1dab0447210fbebff5e51b4f7532c49a677de292f17942f89f4892b3cf1bda4f88ee8ad4656716fb68063c0ef2c7eb4fdfb9c07ed2b119495be5e5bdddffb915cecfbd51adf03ca1bae2e451c88bb77013563c95d58b97864ac6ac0c9cec0262b332f6dca6ccad9c3f1e034ba75663bc894fa8f93297cb4a19a0e47553f8f5ce2b648c8caa22422e77a07ff40a8f56495ebd7e68f84f13838492d34eb42f80ac0a371332264930f6be96d562d6114bd3a128837db52863c139e0ccfc6f0fef8d499b56af1e23a3663eb8b1ddf6fdf7a3bbafa9ebfec5072e4ca2ee9cb7cbb181e58df2ae30a755c1079707e954272bafd0bba814bc510247bed757c2c2cf6d89ed1c85b0741937685611f763505722aab6dbd9a8710ca370e906aaf8792a02aca34c00747861e0841b49d6ed2f3b7c211ccd0bb240bc0a370fe5a6889d7d4ee8d0531e3bf239b48185b1cde0c71e915850aa1e7fcb7f137ab560f5e4286429080bfc8fa82d4eb78fc05e213d45325c85e685fe2655f05d7cb8fb1f55c96641292dd1aaf906521c50c41f4e1196a82fb222878bd1a683d72f2863c04bbb88b29140d4501e189063f2d97459aaee7351cd47b202e41c27d1894500ad87c673c572ed45a257c7a7d78695861e8283d34438a9fde6e31081a50d11438d09f6dbffe84ebe1bbbbfd6e51881b21f2a155a1c2858fbcc82c021dad118d8835c203e3929cd8359376d4835f1bfeabeeaf2ac6fa434ff89c0d83bfbba6d3310c2944d17df53fd8bb2c509304752ef909bf51db1e520cf3742b2d81523ef4a9da765003d6857a4dc35bb48cc8a28aa2bc9507cb32f21b6422009c2d836c0709419937d17981b9be047cb1883dfdf9b4a105f8cef18c528d474dcfbd8fdfc676bab4fd3633cbe3416b279051cb5bf47e725247aa2a8d2bdd361cbe265be1931f10ab64fc222ba2f09c82d489b82cf365faa76a36ae8d1cb3f9df15fc96c4ea8f531297b50ba1b5a8589ae9f21566575756023943a94fa930b9440a8ee117782171c1cbf84f67316d53de94bbc05927b91cff0fa3b310cf348f378962e87f773537330fc1a5f76ee8aab8a16252234e32e0b82c0523ecb62c4cbae6a064ac39df51d95f126efb6fb92a045df6452c9c67c11c3230e50e310019bc7725b6fcd7c4decd31ce8ae4f447d3cbb8fe826fc6e8d60994da8323c77c863b7d9e00e98461028cdd97d96be2421167f9f427ed75f9dc4ccf7fe1ab5eb1cf5419a468a9f821377105280185cea2b8ec018b5abe783cb65e3be1280433532a1745f248e4c0f94ef8df9b7b5d169670160252887f2d534854672127a6251066ee9e941355d81aef88380cdbce4598b38b387870d6bb28bfde6eb0bb10ec1519d2fbeed24c6b0c08be5abf7e24ec88d0d87d21d41087d12422242890be0a2e4d3e939ef8018a794d933b0af1ed693c9c025bbfd6ca1b8bd0e4bfd46a80102548b577a0359b48dc14e806cd68d0db0bfb858a5ac0ec67d23ca31e98fb38f520a75058299905835eafaa58b5db1bd90bae2f6509b0ac2c76dbaccb81e68d1e4a11944da936041d25778ca404629035b33f67f306a4c8e38d96f5360a6ef4cedd73f3f86ed21af44a0260ebab121bcee4e681382d7f2e517c257583e5e4f7f69fe910822ec8686ccac3f8229e715cee1179e185d85b0691c738889d6743ea6f2da3f67316ef852bb0011fb19778bb254cda91ec77dc5094e8c4b79c8b4abe1815031d75a55580f7cfb46afe06f66a5c893bbdcad97fb4e06481847aa94f19cf793b5cfb370a9ad74ec38ec483abed7f46e515871614970e0770b2245dcab28acbf6316e94ae08ed6a83bb391cdce81386ae6f83c25eecb0b13be5b151e580e0d0e3a4d397ae89c437e472f3c0976304cda39166051c727c8c2d1881362478ced2711d875b904b6662d4a29961b5b9fe5dbf9da14d1e1c9e609a6b8c5d159298fac4d74b5619a01c3d094f14e16defff8ed921b2a6b91075367a86c84c2f9eba21e11d14c5b02d39ecf527f7472d76cb09b8d499a548a11f5f63e06869717d8c950bbaebacea2bf3ac736cd1f0940f607bd44b182cab771a559851efda24bf1b4a1477bf4fcf3a59aff5d9ce62c0226ca4ae47594fa14d250cde40c7c101a598086f87a77dc1d75aa40c8e2bda4f0358c5f68c062e923db3124d6b105affd1e4a88d49cc31dd979a61b5a388a905891d996f84fd8c0adfe49157e6452e368ee864cf532bfd34d3073e1f223efe05e7df8599c9c3d3104fdadfc4cc3d4c17711afd2173c6a07027ccfb616805070ea8374069da4370d46ff664701f33f058741af35e9553a4d0a01ff2630ea7485558468de4d1fd39a9eb74eca037e49eb5dba070c806f35fe9a581b43466a254ed66fbfaa94d187104ab6aa0f4af8195dffc44ed5c10a677a18031ff00d67113898b7c8bd763c825eccad4ac3b5f9ffb3dd08b216140ba2d195ff1d6fc6bb55bbc75e9808eaac9b1681604b6f467c8503b9923617747fa5d2fe1b20ab92182e5994f62312b855181cfc0c3e960a59374125f7ba1111dc5b409cd6386e3afd6bd70a02dba25ed34cf366d18bd00e4e25dfe522b7e0b78e5f9f90e006bc196bcc064344fba5b6ed2b53301fc6bbf4257ec9d629a549b771274b0c38ac9fd8b7cbd3c4dd6b2bfd4190ac4de6db8a4d58941aee64176145520b41384bde7781af65757876ab36610fb320b0e4076e960787f8ddffe6d056a5eb4f22a2a80ee44af9f6fc89c91b9153c626dda8d793a308e3f925c1ec676bc77c969f559b5c577a9be88a83848c389d682f2da828cb4d8033b929db8f6ccf4fad70dfcc70e93164a1f40dae562f4104f2d7284d794e60faa619a1f1f3131b404b9f89d24adfceaa071a0317368f015db1ff1132ddf6663bc88c648fe533b637df947ee4d49f6eb4bfa9d57525fbeebe70a94bb73695bdefb17fe16e7cd5691d4960777f20c817bda362bf65b4075baa43d682287294c12530fc089845affb0cbcfaab7b49ad8f44847277dba187904a020ebad1c4e84f87da4761ee3fdfbb6c3a51669182ab19a93b8d0df2e258089eae6d90a482c856d78fa73e412f0e5a8dccd6896a3b6e2a65ce4688b80328147b0d4b25e3615ccc0360a585d72e96fedf41011c52facd28ef32b6d9f83ec91d7c4a34a6dc255ad474e2035ce5b80bf903d737f3e79155253917fb2db7b33462676952e3ba17c21ad5a0dfd9294e461f1695798c8c19b789b2f49dd4b663a74887763bc24546941d7b08f92e459809a3a7ce3f8e506f7b247c5981983ae14a6ef47c3a10e8ef767c4cd6ad84008267677a3990c68a3224d4be1d428052fd61b3a69365442df8ee0e00afd91b91e691d586656a3d095977a7ae9d3d12c98438596b71f0041cc0c771848a2e0e61659efb54384a035cef3695282cd1366a9b8e204106090cfe9d3152996bd43de3747c7ffc6d0f92a92dea51e5f4bcf815c78739ed969759a62a5f089d6370d53c255d46694db89fc87394ab24adceb4e3c5f7a6ba092c37a3c93a253b2b3e7c3111698797ce882a358929eb370dfe6a9438964440a517e1d2aeec9bccb311f842803768202e713b4ced433e4e52834ff7822796c93265da45d8f8a17f6fb93488860347cfdba7872179ed73a87b50cea00c5fd5ef99d0fe39a4b28794605cbefb7c56d100e10ee03e3d7fd97c40cc83ec190bfd464cfe67f1f43879a9c1e5ed4d55e38acdad43319ddf72544cea04755eceee59e8b69574cb6d02df20482c826bf37b5d565f25eba04ff9c75d0de74dc4c0f7472807dea0ee5df44aee87a6520dc5c9693083e98144b6b27dc20f5a8394b18fb2440ecb7eebf1a020e4623b9871af7c389eee2d9db97c986c387699fa8146aab6c664b7e1c519d37950b6c8b79545b778a4da51af49588e1d38af207444d950c4a01573520f27775d2a35de1bac7839d91ad4a8946f05a241b720bafe317243320cb15d527774eadbc3033a40a20aca415206a69af43062819df3fb223a2009b5a0c9bca6853d48a09d3fb1395ad1c3490844bec6b1462389c1b0a3e719e256aa4703efc241d804ab6be5c329a42cf01a70f7e460030204b29be12112e644d469a0f35034b85c51e78b608feac5b3e5a30a2557442b05f3bcad20ebdc316981a5373ae746fdc8f8d37b9204bd02f6fa4a9055db98fc1c83d96239f51d612f3843a65f4bb22197fc558ff380b8a543870da85d22790d39420be4a73690fb8bcf4584a5380c9a65022ec9765136543912e7582671c694a7a83cd72ac8076832da060f4fa953dd16ac57e0d9b6b7d273af822fa56a70e8b0eb5ee678dd25bc0e4e3de8f0f82c60188a373fa63455a85e2cab77f0506587d7401bb67d7fa4be00cced69e6760bb97fc254dac3f489d73234e0c06c3da1b96a74beebdab5ff1b847f64b1884eaf497387ac2ba25d3f1c81e2ec39f5fbb5d91ffccf6e044209c835b20224c291585da7fc3aca12a5a1ac61aba356ab91b29207795cc8749ea844aa7da3a8344f86c687ab60150c80c979d20e56706764c67dbc9506541451e780b61f87b1c74bfd39c46777483e8e9799d6b01c4beab4c7857abe89283a9f88c57af0254fe1c430b75eb9959f8a6172c7e55baa5838a3afec652bf800e0df50f1ad20659fe38d8bd1b49a0e43d45e564eaea39e55322f02fcd5dbc8e44dce3ec690ec965335aaee5659fad53dbc6968fd9586e54f75a02c9d259b1a7edf20d6fef4284494fd91f98eb0c895cbc5b511d7b7dd7bc7ef4ffa6eb7e528fdd2201e2ad5ca8c2920512f3fe07ba52bcbedc930b0e9765fcb388e6afc076ba87ec3f7999cd81400f269a41f1dd96b0ccf8e8792abfde37f2b124e4ff610a911662b6a91e8f77fa6213cdeaf3210d626219b4e64240ca9bc26328825692ba47c1444e6e7653fa8005d9bc0f54554c9a58e3e80f5a74c1035e3ae823cdf0e482fe3c63c7ef7e49536c5eca16e017740cb1db8f51bc2c5f0bbc654d77120893e0abfecac851a1fe7442aedb3016a306da38a596e1942d084b33cd0dff40d01bcc7c87836ac76ab8eaae4fc7eebfca1cf6c99b9f3a4e1c68516ad1474f53c7aed3df65b970e63c1fee3189205acd11021a58ed21ccf388fe6fd77888bc852937b2983e3ff76e364255b4d844bf774ac02587c7ad0a00153fe0d2e873a1725818836088fde68a9c12989316f390278a42c1c6b0b2fbc26349e27369b1d22a38276da8ecdcf2a455bda0f37ae0ef501a2b6afdaa4c2bdb282db1d841d7f81c2415b2a010a26ab9c627f717b1b0eb1acb0b1cdc03fec2f163c492027f3fbf59551e2a9f917f880278bc734ab6bb6a031211932cae804126e87d425a3681f87d952e2da6d7751a67472a86fc9e676ecaf21269d52b9b5eee40cd5a8a2e65c54c65e2cf0f23ea255b1aec6ba5fa1358adda4b6002aef7e4a50875e5c67ea8213aaac9347a9defeac43d0aed47cd3eb58c2b3c75a67cb596a5dadea9aecf18a215a6de8a4662b26e52def1e969fdf34302239dc88b72c5706b721f78a87d7c9b4305411ccad93084b0f0abadf1e7da9839abfc23ed50e9394862b3c35157e527d59adc99f0f58d7b3b92f78d528927bf7ed51cacd34e051628cac9ffc436cc69ed54a9fab44bb7576d87643e64800bdb9acc2c35dd81eeef78505e21fbb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
