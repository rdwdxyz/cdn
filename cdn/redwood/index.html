<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3496f842cff4bedfad2c04ff68905d9ca60e0bdbc5d3f8753b0fe625a4778531d7769a2b38d2349aa128f7f2aecb3f593040e67231361d56e30f7c6da21b6972fdcf516e32c3fb3e4df23aca6daa85d40b214168bc4fa77044a34c7f52db1b4edf379bfb7d2d1db1513dc374d8b0e18900138bb93f4d13055b9b0d67b7dec7d8f674865ea11238e2e8f53eab1e313a6a5e141343c021f8716ca31bc6c1f55ab6d8db7475c91b619d48ecccf278a47a36aadac0dbbf82ad2ce3fa2387165aae68f443a2cd0b4fde2b9ddae84a00c754895fdfb7d2d18ce0a6cbf34ee829e83e3c5e6b247ab24c30016e2427aec9299c466e643da7ba9066481efb167d3ee47fb1e583fe38af159f7dea7a744ae9d37e7a080f21480d04aa3a7345726f1c8275341c28db7c8c2efec032efc7a191e801a05fc437b1065f0cdea66927464e283dc6aa1fcced94438949f661acdef4dd4b64a5a734b37e2637fab2d4c5dc5655d995256602b888c178322c681a955112251b00bb8e20eae50bc0e2e07af8d6da96213c300d6b0d56b689d4e4a1f2945d57765bd60ada3d07f751997b38fc2df0a30d8a0461864ba276a9f6493e58d81addf00945d76ae3693a46ee2e8ba77f07daca4f797604037cc17e61ed21303e63ef239334af57a413b56e797f740123fcd9265be24211387c9a47a846b2eda54a36e7b5c3cb547585a270930b48f6121a408f4d3a27eb537acbfd45df7c8bcb7e30a2f093fb7fb87706d50eeaca6797a857d9d5bd2ba39dc5f2a2ce843aa9a9e20dc0d7956f9e310dc73427bf29275aed56dbf1c6a5f10e748528806508d134cdd497ceae618f3e20e284b8de96bc9e886b04d2129f40381180af1d429cfeef685350583cd1df0ebacaecabcb56e83cffd19d02de1bfede2617491aba743a7ecc71b373abe206a79c5c324569baf1f82062f18fbb274a9bf095de5f9888ce78290d911ee6c1aa652a3dbb8784111ab089c4925d73f67acd100facf4e356d384ad458c687da743789177732e201d59bbbc545a910945e47d123cb42e55dc4f816fab4015ebfb1d7ce78416b0be15276263a956d65409876a14f46653472ed0026ead788eba1cbeaf75dfe6e46602c85f14844e25ef57128b0c6c86d4f0b1cf58556a5a83e788704447b309c761ab65b06c096e8866f88ec9a53ffccfb1458111658639687d1dfe171b3070e05a7cbf4df81d5e1206b11655570329645bf5f1ff042c6fe2f2d4df095ff5ce0ce983471063f0d55802296c32978eed575ad0d2077f46975f6bc05ca1cce035a3f62819f8233e12542f8a14c3fc3c613e30d458974772a6f9ca8a2583eb0f091b21de52cf2b62bd0914111e688053c133ab5d1209f725095444f33d118ec832ad663c695cad69a0ef13cf5f2f4056e0c0e5824712deb8e13ddb655650ac4a0542452768258ddba9e822b5da67430cb80a0576bd4c531867dadd9c36d2c588a607868d1ef6fb463539c277c4b058f653110151ab75ecd82a4a2d4d70b0019a3bb32fae11857dccd5ef456f43e232bf2187eccd56a307d66a07021965e61cdf06023c63566eaaed8961f5bf2084fb41e55ba0624627807582da63d2930a56192f7cbc8df9175a59b6fa8cd32e84acd8b1101959a2fec43c74e7fcd1f0b3898e0f149bf6a54b5764fa112b2ef18533710c66dd72e6597c822e6575a4bc1283d5e582fcbf0b338b8b43355bcf19e36a8d61683e76d408f3d0e18b0da421f0a6b066d9a27e59f6f2834c987a0ab020835fb52e8201ec64bbc3767ab377830ff27511f77c69c3cbd8792dad8f2e4d2dc3ac344bf6c35ed4446af80a7abd5e7dd680058cfd3c84f7927327fd12defedc904494ea04f3f1397d909fbfc771ee9f124ef8dab900a5b3d71d4faee2b93d473730e10b0ca1969cf7a4c9eb720c6e425f060ab2152d5fc4ae158dd2d91e3c49acce3e5e2a160ca04dc087f14fe5f0364ab46b0409cd67e480e58b1e3a92e3f916df410df8ee1c066a68571fbd8112aa5be85c44a77585de59ca7b880c1eb1dd642bcbac8ad856117579dd4d06132cef3adcfe06eb269f66c417a1ca6f3edd8b2808bb0cf12767ab7eae74fb2b0ae8752b9675acacb6b222956724d7bd2642bcfa94c7ff22db2d0ce1d373d216764c54d0260f2629eb076f23ae9ec5d11bfd0ed43f5868b9b0465b36fe0f2dc784546713e7e6fd97ec166598f5b3d961492510170d7907181f95ba34682e9ac69f1e1ee3f4d065e7294022d5e3335f04acc69dc817f2d401b8aae1f6d0c11482cfc26f8872f40750791f83646f22b3635ce377b28ecf989597db82b6aec1df35fa23a7efd9215b6fdc71da66308fad2c47df27d2db8e83366cced128dc1aad1dd94d5b7977d3f742ab62873c036c277d4edbd083cf357825b7809cac58ebeb7189a20e06310eeb9c40263326c820c06c08391e89a124d8967905ab415a3176ab6cfbdd8179c42b5247334f88c142af3a89f4132c64d6e9aa14e95ecefa5c9bdc030b9d3bd0cc04627920f09b1276dd98a0f25fac5ed6a91d0fa61f68b0dea881474a89fd5d95efa8c905f4372e426566da992b483ff88067c72d5ff343f88f42e0aeaa747d1efa80d9e026feab6a345abdcda76eb27e367f433c47b3d45cbce4718bbaf6fc71315864e7273309af182eacb0bb9147717638401bbccb5458ad11308eb5592719ed69e9a8d2aa38670f0ff8cba17b0da0d82ff24124d5b269687684ba151062f9feeabc5a3a4f1c710da01335b9816f0acf3635e910c9857d9573c1df5e9501d26dfde31136d9a5ce303f836645fe45a23e442fdda0d672eac7106c7255cd81b035af517bc02dda2bbf1e260df35fb66316a4dac6c11c68ccd7ebbf51018a7692363d107ec765efe977e624790f4ac3a179276e9258e3513bbbcf9e48f401d0e66946f74b43cec0a74589f85f0c1bbcd2a17f70917fcb41ec9c2ffe745e446b82d1d00e3722587ce71d1371f9d308a9bf6cf9e1e6ef329bdac8c897299ddce38f74ba22ec5fa1a82d420e47455234c173435c028dc92f8879ccf03adf696ec276e6d4bddbcb1ecdee1a49a2d033f9962cc4cf7b4c40c74c0501681b4fc8902bed334de26516a5d383d29afdcdd843e263a7999977d78368906dad4a50677a14fb4fe18d5529b5ac74cfbd735e7cc1d917680eb009b8a61b29631af58ef0ef3d75c407e5a5305885ea4e189c9c98b07c2f1c23ec2273b44d15ed74085294151e34f69e833dca6196066f6b2f33849f2d89bbf288cebf054ce247588b78063fac05713b31613539d177483f2073d7c406f27e4794654d226d56349643b2b5d491c69a798f8876712dbd366e32c208fe8346066e32cb8e5a5de67534cc05828794efca6e4826c829ecfe824b26a86f4ed41429fd1ef28e910ff3486925c061818fce91671ecab63a35d1e08081464ca0fb75d27bedb5920ac3dc99877fa032633ad058f5660fdb53898bb48aecaa403db6d39e474b0d7db112db13ac1636757e46963e134875b389f5f76a6e38997e5a91267580aa8983e9834f007e49ed3f01b776c14d0441f7b128b2234f91df8be1ff393ee304e5b484b14069bab1b91e10d3fd5b6a1b725b92911cbc52203ed855e0bfac250e4631f6de035d09b718f5ee7b3e9bc7d75b748fdbcdcfa31f9ae5e359be6ef76bfea55d16e28d5ec07ddf71225c4b231d6f62e9852f0c141354f41f0456a2a8f28b1b1277c2aa574b3c7aefc6aa462978a874f0582777033512cbb8145d6aabd85c2187c46cff3438600fd5dc8aca05fa9bda350a95c022acf6dd1ebd9abcd7b30b2c415826d3be6c3c32d8678aa195ddbaa44a322ecf53ed1f5b25cbf7692355ed26c177f52a03aa34f5c1bf3e1d137fb7850a061328efa9cbaab93ff9bb68aa47738c8c123f4e26025b17c422d64177abc82f5635f13be9e8cb291dc062838b13bc70eb9f0d83193181214edd438602aef41daaace14d2afccaf63dbcc3545a2569f6afbec41396a4406e3da736c4518f2924b25bc23911a613b8b150ace37826071afc5dd9893aac1b0514c6f4bb995fda2626b98e18f302801b5b8df56aa449db07114204f34d818bb4fd1ee3d6b20075e2421b44ba53ad786aa1b31138273ae223f6824a02428b8adfa0d5ca67680d5a63f52ba5bdbb855fe863a8b6a2874a572736a4e9a210632ac3e90d037eb890b21fbb82c5c74cba47c602d83339a29c70314abcb0e455ef082fe6efc88b44d54c3db9e3aff133c4eb81efc9b66de44322c2d8c730733506d8185b09a3885e2068bc5f1f9c165853df138e295c587d10d2e0e3b64831a91f3a48609d40ce56774c1af4c9b46263189cece20f0e55f9c6402260842e4eee5a932385f0a119c2fee5b626c9cd4f5ac74a96078d4962b11bca8044d8f129946019e11dfa6bd1d43d3f536c3c510a6f96b467fb28b6d1308373182b9494e229ae1c3c50c3b36cd6f734a0b265b70b66c89e7f63a25fbe486d87d58df9aaf1732d5f17285c41834924dd0e450d2b3a143c2bcffe2ae96fd8330a33c83c7e00db428ba551fbd9c74d9f39075ff44966e15e19983988ff5f0141ca30839e74bd894eb9188a025b1827dec755623d3604d83ecb40d28ecd9e46099071c07cd6cff1d2bbda80dbfb51f04b8b88ba81bd20c108fad7fa5641c6430749710820a5d21793b925ea24ea5b00a17c2559e15989a5579f8517452017bc71f5ba94b3cee2b499534b08637834c80d2bf6eacb93faab0c7e4489a0665c9383db010a9aaa60ac5fc12946c406e69965eacd099151c0f93582a909d25d45323185bc176ebf471a81680b3033af8f17a12ffeb21f8e7796d8e2cbd9cd381f6a3e2369441de273aecc4f77c1ff858e6a4e78ab0e5e85d3e3a0fe97a981ac2b58c39a69208844bd1e303ecba39da1c117c364bcce7280c962df82965f208ce75728a8d8464fb28431db9cf50d7060618e58b34c2a97e3e42fd04b13e07a0d10e44fca4f930ab437dde76f9d20ae9eca99cd3430ce4528c28064f071fa900af7d561cd0eecc72816ca3fb5b540b74ece12fd3455a5d062c0821d53e80683f3ea9fddbb799641d8cde13a9ed0a6f851149776a9a7c77024f9654ef3a1dd3461cb100846faf37cc95a0efc346885ecfa8bf4a3197cfff7c67ed824264dab4ab5ce0108d114ccc4fd3788574d91cb16e08cdfb4a05bbc71ed215f9c7cc1866e40c81573f4fa23595a8ad178a0836c5aa83c1d54f619a0169621a2d4240ab7d85da5d0e70ac207e739d50e5c8e39acfd5c67c9828c6424b58c0c79a3615f4f658d5b9c612041641374a125429deaf9ad5ecc14f22c45a818251368d6b4c71a061071ac9ca3e09c741d47c8b16b8ec3d68efd43158211861ee8d165ba546e630ac7f982e2f2f364f2fb677eb29ede1c520820863a85ccd57f0d8cd14819b221b446acdcc0cd8d6604a69794264c93cd9bc49bde7c3e3e39f021225f5c12cb23003a703d2c598ff37cbe72348854846744db78dc4f0a50fefbc723ca592e819bdfed6773e8bc383cd405b278340e774fcae77776c9498ec1c3229cb45113116fa055aa1dba37ddf62e8e3e1568bd6b91f4ee4866c77749403d89a17d47dd89c74dd86657ab05f8b8a74c8eb8c074ecefd1f8b571490423030855b42ce4afe42ae2eb7d28285b96457a1e3215349d309063d662565d943ec2d4f27a3b459988a52f85bd58c7454fcf966e77bbb3c0408da8c04a57fe6313c714377ccf5b9995c00bb39429a4ccc42684c3954804d8ae772356f157692c50a978e286da08d4762f1933e1a273b5419b957648e9ccc339dac5bdbed0873f2fed8d7027a7ea58683ff5e166032aecc8c1c751a134bc3334dc07f8f90dbc4fdda81d7c7ef3b356583a2b8bd7d4d2cd185801815f944439303078770d92373b35f7986726801a13d07fe22ced44d6c68d016f7a217f71bd596cff2a448b36dffbc617899edfed228dfef2b0d066225f5f6b3824dffaaacb77560080c266e016c1b8f87b3b38d5b5fa0bd416b25e508e089a1a84a13f45c35e3f03f993827ebc763601383542d5e6534de00cfc95d4497414120dfcb09d5264ce8de2e2311a8c3909b04fc2e7e191226fea21fbdb37db64e841ba3c8fc0442a3634fb3e941ae0f0beb548efaddbb1a2902860ea22edafc3ef659cd4f5d4e9bfcbc4d7cc62fad3eae0f802b420d744c1e25ae102bd329b5fe466d852d0ec32180e9ee426f69dcabf3bb3324e2642426d4d5770121fad7a2ac3cf1cc08220c5d55941f9a37906fe9b53c67b3d8aa80ba77f24def3c331b15a9ba43e155e3cbece9d1373d6e4af44ac802a361b51fc5f28b307011a54dede7e1d6cd421d4a8542975145a6ef643b4c87897de9efc1e9a42c72f920bf52d4acaaa40b7ebc9d18c538f45925264e6b7380fc147cede5f2d3cd2da30713be8f88df81f9380cf99ea426415e4b084647aa4357dff6c469f380bb002eb81bb8b466b159931205483fda11a6384633217a84e63ad19abddb0b5eca12a1fbb17100bc2cc102118083d9ea753db15db6edc8794f4ee295c828e8593c9219a01a9ce64af5d9009fe760b162a51bf9d81c8bbe59c968de181355e65255570c7e4b875a1dcffdd4e13ed7d1905473df46d328dc19b4ef941743bd1df5e940606f29cf61b8aee01210ee6c2e449df861d3f50bd65f65581fbc03d940035fa8f37ac266cb3d6336ffd487c07c0078ca3fa6976fbdbb247bead5ddcff8322afd73486059290073a0c56939382be6301b1119edae9a8bd2a25df5bd2116e4ec6edfb82ee17477fd3a76b088fa9b6efb0fe48c044e4288aeb686498cc595977ae287105aba6feb7cca0439ce7bb1ba59281ff78b5c60d973111b98f1d56e4fe43e02a7f52713bd8e874dd5ef0609c1ba1833023eea1595464ac37fa677ea6ac251aa1f6c1caf3b6a1b01f1cd9e6a67c8111c3fe63459dbbdd9dc7e74d931edca412a8c4d1481f47db54a400740a8fdcf2556db689c501c6eb2c3bc473fe14922a0bf299a3b60f99f07a00a1464198e195f429ef977d965ba0768f939b83bbff44245e0a52698d2dea6c4b1e5590ee5695577c316de82d6c231aa16495777b36f79e0899868d0ca06410cce354c2d93f83dcd3c65527a75a4e5263e37212833381765a763d485e274aea412ed662e68303a7f8398291c338c56052a7915568516453b4db0c2e88c1101cd5a8885325c8a83e3ddb04a2ab86b82e8e38bae27dbf1111b839f382ff6b82483a397413a058e1f2b9dea71c30f291ec14d079f03be7c9aed9e1db2d6ff3dea6ad2109a221a7b59efa53c9bca169735bfca6dda0f1f2f2187c3bec15600d1ec3d12275048dae3a4d56d6fbb4dca2f76c2a51dc9b0f6ff14063c9d251dde87aa5c80126faea62d3c56030118db9d366ef7984035a485f1c3c1da380d28def1d4a3c900df08a12ca2de3c1b7301b1a503e93f5f238fe34d155cb5d2e9e8e9e14d624d4d846674fcd2cadb487a7d2f74be8c3a68ebb12c4a1a6926cc87af497224fc4d8a94f78df3157cd3841d04ffeac492c5496a3fb4829c62441e5dfe8a75179ea59bafb5ba6da3c66a637967cf152fd11acff4a23b846221d1c25d1856673f7d4737b67aa4a15000b06f7e6fb373a1bc6a3edcf831cdc26d8974f266f8ffb9b2c6e6faed1922d8c999c025f4ca978ef228f5889bba5c8995124e9321b2dc86d36dad46fdc720654dd0a02475f907f8bee863e13cdbea25fa8b2228fef44c0ee9778e245db81d3ba4f6dd770ef7143bef0b1cb9f644c9275711a59936e5da899afb92e792b6c2dda6c5a5ae5eb43690dc0e12a39604d44080ec9922963b0a290977ba57b69a2bb428095eaa2db9bb9d5a9baf1e89b215c938d245911073d9ec19d06195a1699a00d0bed978583b9e9dd1a0accec1193af29da5e32f7ceac669366554854a9beb8be4c34e20d11c975effe80edd215b7e2c65fca7867ad0183f98deedb7c7656b0cd3c37e49df41750f7e58a798983730ae7633ec018eb5b43f310a10655dfe0fc34dd4b53375473e54a4b6c35afe5ce121d915c0bf0bcda49bd265970c612e23fb692bb89d97afa4f77b484edd52627afede05115ebdeb7e243d710d5ceab616d9d85be1e5115f913eb0725388f8472ec5ee175584f41b7d12a12a9656aa3c458d7af30f8e30d452550f8300b05f92ee77e1cfe4be44409e88140b411b07f29acf17e8da2b2282b21d25d4df91f4c77c15d58554bcfedb39c126747c6777c5c0f67b990a5b38aa7df974bcaa6ac3a05153da3012846a1606c8af851435115b98894636e4c9ee8019ba7c941424d8dd91c8f0573a08a0cc8c78f28245f751b8bb4a3404318850b374372bc8ec4737f5ad9e39b7f14755ab8c0176ba45e4dc865fa34cc421907996d93a03689e805c4f7f315142502a03899daa6dbac58f68c6c5374b03d587b515707ed6cfafa6e89709fb4d2b9db1a92f4e15f95355c9cf5c3e656cfa126c1f6e8f65652a75f07ea7095fa936d9b1075b67d875cc14f674425815bfe556688d11a446195a1fff0eb7d6ddde1c299285b866435af19a3d34123bf427c4f4a0295817e709b7a10865f528ff51d306bb8936f66884ec460bc3f4d472190923779cfd87557cc91ef8cc86a634908713e25e37997ccda71f1fdf11f54a10467becbfe2a8628d5f815ccaec655f4ab7280a163547b5e458dc23d369427e6d544f9334b93aaef9bc2ec47a9a93cc382d3ca36d88ab61f03a8f379a39209ac7603eb1e46fb2ad5f0783d2e2708cd87a082b5a82bd78ea1f7e2740d652fef3f66d7784a567cc11fc242296f8bc931875de02422857019130041d877623612a26847367716fc6edd88cbe1f0939cccc223f1517f310d7d558a4dd32a45bc02dbddb174ae4bf2c3749e9b346d65f270118da6ab11c68494601d8f242ae58217ecc17c69f613484fb644d25d3ae11a8fa70416bc634961263853068043b8bc8a60916167e1702b38f4c606509d883831df693060aa7ab101d262a11254dd13c1e5deb289cb3d0c1cc81797d68ae413187efddb23e4323375bf7732f3b7bcca96e45056a41c41a18ce2fdb2b943f2ccf98b362ce5b68dc7c4ef86a2530ea645f6e6586b02a3244640a7a2355174de11c3207ec0addbc7aee8b43434df35648d67c51da724bc55e689202e203f1a325a36c3d97dd85d0fb2d06e518af4686dc6144985d2089b2ada3d47a857e1ee697364171075c6311444da609efb34dc333045c5f8006bad24cb1ed576eb2b789f428d0b32cdda9aad1d6537683446cc73eeccd15b899031385cfbfa2275ef3f5d13877e34f10dd58ff5d5c40cbde55f5a1dd7a143f0f9f50943a0dfbc422c2a4779439cff8b9724e2c3c50030cf4dce0ec6a8ac2ab320a2a2874e3aacef46545898bc57f7662f15bb33752a14e18902cf06617aecfd226be04287e37f109aff4ecca6c2cdd89b439f93011789af7cdb6d483d8623cdc26bfc5faed2d4544347b94d1b371f4739c893bbda74db67f70286d47441bf7e3de6c04824148eb6182f01a5eda6aec5371cb8db348dc716578cd344e7e486a185df4f9a2db7be5d712a0cb09656e52cac81cf38a051aafa9b13f19c0e3a6b47c50afdb7ef054d0813b3551f06d72dbd652a846f4c158f71706571456d608e5047fd0e2864a162c96647a6a0b847d51532fff86c08347699d0b569cd69850a6a3727c7ed9a09149e5db2d777d7fadd045adffb89bcf08cd3a165e9260100a284efce9c754329d14051f499df389edd0234209b3b02250ed2184d03960debb7ba437b041aca3a5c0f6c4239ff3e82f36a836201da3beec0d6fc347953a6b13223782238226cb1fdd0f417bbe9327c34730e2a4b67f74247561020380c369a351890a650ed412262e8842d4091ba2cd477b198a1b35cf4dd1ab3b5ba79cbce23ac07ffc21e6e7786f93b003912230c91e98643a5a0e7c3eaaba59d4be8294041ae215bbb330ccabedfc0cfc397ec65bb6180f65f3dc71884839be9d9b9037afddbbd335281eb9861a24ca8dec1627d1797d9cea83a76e875e24180cea2faa6f1b9204901c705107b9b65883d5ee6429c928e66fc791d67bc95026846bc6b16c516468ad10189325379ae103546d2cba58e25ecdffe91096a3e9a455d44328cb879cb8f533517d151e9dd3d7b71fcfbc86f6dd4f7e415f33e1b2a26da59c5e59d2dcdb16ed037d609f3e5e578e5e66fa17fae34fa5bccd902c82c65e747ab44b7552ccb8ee590dbad116ae989690d22e1f8d6522eaee2d1476bae5c75782f3a22007fb07fc8c17fac820b563395e71d2b0aa6f4d6c40e1b3ebd06f38449534382a0a12f87b2bceda37d7205c61448d1794d9237353f3ca35fcbdbfcfe718a647bf0bb8030c9550a7bb42157019f6db658c55f83195a2141aa8ffa30f766386dea79f5f3ddf4612975b67edf4c1649c4900951f8622daa7b58641274820002b67c2f3d562b7fbd2c79b2ef10c227d0ab12f16447d93ef4a32e051cb2f917fe9bf115d3324379a7777d199b359b16a7c3bdf63a7bb17bcc6819fdf73b8a908a471d159f3e2cbb316483cac444e0cf3562241ad7eb0ec5c59f6f461353e270a3749c3744b6c0bb8d0b1e61d97f4b3341a298fe5c49c53a80993f6ccd2a1853498b794a1c4b9e9e33ee304e03124d649fbd17cb39baad5a63d277c0ddbc333ca3ccfea21e54748a003bfd93d8aee9f7e76ee572b94bde54a9b7652c1c57acef15d089daa24430cabef30ccc0e475934a5960cd260b6ec8a3baf2b9752b4febce4a62c8fe458f1774a2ccf84899f92ba8d59f853c8f02271589f971caae7c8cd4b6dc0ef123d1dcd108e56543016269d25ca9d874ea8ecc6ae73a47aa761d4f064010702f499ce122406760b6ab02953a4e660b592169f55a898d38bc9debfbbcd2e4a15abc1cc3b3666fd2ee8b16ff286367d23c3ca2a939812571fc741076a77a9a5d5077105ca54a7b5769774834c87a2d1a2ede7eda581564d26b7e552b3e489668b4e4eb1d1a5f1a7e275d1f206e498d841daa332cc4ea1a133042e276170c6e9899c054a0e0feccbaa88710def6d130ee7c75c5cb482a05cacb94289667f0cdae587d5c8ef421ff421328a91b6c333f7db5c667496e5a07e028743589a26793406dafdb1ec739d980fae1c5bf34abe7077eba1d90df354f23e4ef33b5c7cb47c516a3295ef1c6f156777e5559399c733294f6f3d919b69ac55e00938aac0055c1959d92c828b1af2af228075512be3805751e7c21d412b9b616663f09edf70de2c3dd590b4f5bcd90f66d06ce6240a81f6c4c65d5be65782c745c9a6c0b3b70497f226fccc124e99bf4988732972accee7a7d5800554e5b14e5059e241cf62da3a08751ffaaf502a75a85e92805d159f292fe1e4995a183d97faf771bc9cc32079647068348deee222b88d83ee4a948b9c36620cbd82a1befc61c4ff17f51b063d693fe64a83ecb24eb03f97093a20109ae1023c8fd5350b594dafe1b6a9acc4a25f21853575d995a8200f9f29a115fefeba83cbea5e1ed97eac26e35acfb996827037a42572644e565e5173d1bed2910937dad455e4a06030f0c285a606c14be451df4ed9ba08de45f554ed2b03fd1af76fc7bef4341a77d31e40bcdf90cf06f004f8e0e750cf76e03d51b612971030672a8a83cd5d360a3250cecd632e10b2ff69e51366c9cce713e9803dc3e9c1524d11b58f76f4fe226452451904c1caf1861a6932dfbc2219767286d2e04ab7a5cde820814a69f6122fac5143858daf84f91b36cda52a6b9c1a17557dce60bfc07759f17c2a7648c37cd86fe43f6dba789a8f95c42814d2cc9efb44d6e39457793503bd24739d2787f044054d3822d61c089a11428a52b8fee61e3c6c9a9b63d31f4761dc61c5da9a076437688bf55cc2892f9f5444363c729b8ba088172dd46a3025bc876a634c7dff49f695e9693a8959816d3be6492198746c9e0c54bbf75d8224223f6743ffef86dae709d859f07a0564ec0dfda571328980479bf1bfae09021161560a35ecc71f66750c06038e06d630b1da5bd44294bfe189cf5ddc0bd66dc517fd0faa9ec91a8961bf220be68265825960a05a9a663f0708928a4679db8589bb8cb61031f8ccc468cb5d6f490ab57c224ba7f60d7e308ef04c71616404fdbf2b6a660d139cefa5106e82f000ace4827656c4b0e0357cd7ad520c9ebf6a2afcc7cdd7743edf1b3cf6c8a5f3b5944cb4c40dd97e016efa7d4e5d6983549aab11dedb62aa25260d3243b618ecef43ab2d33a078f53cce8f4ec9cdc34897ccad18b3663b0d54518f74792e7820782b215b1c705f3e362fc046e8e1cc845e5e29780c1ccfbf775b841c2034269932292f950c827b1ecb864e2283e4109a8e13592258945806937993c9a81b6d7f08a2de44ce619bf4b74063e28b514aa3339fc1ea1ab4298e70ab5c2e9ca51b0f53354c9514955df1517e85dd1f46277aa9de876d4cdcc45d034807cf7b9152e2651738ae5e971b57ece017bd42b7a92aab6629f4327c5ae364dcb0223beb6155cff737eaae01da0009950fbc083f7c6801117f8018814b49673e1faedef51b59d86492d6bd0630277b715f520196097acdf809acce9ef835e4b6f55f077d9fc3c238516b6ed01c275dab4d6646508ff73add6c21245cbee949977f8b1e58bd9281655608ec2cbff6cffff97d8210ddbd7f3717ba1f869ece6af5f37fd9d68c343045fdfd6f0b1bcc3f96ab095efc4d65a9ce3df9735dcfa12470b0855fe3b25e62283ee09e6579c918aaba29eb51fff5bf39ff6fba4dc48f427f195f1cdd65a108c42746d68751c1666102b253c16ab7ebb93c41a77308e0709698b6e1ac0fdae81baedeff3656ef44127a32ef1b5ea645b61e5e229924c4e28a16dd61e051cf53ed028890507aae7929fa90484dee0a644bf82f09451a7beab1089b7e030c0ecb949c513d03e1e34cb0e8f3af98840c3082e29fe8727f11f98408a1e4eced886c3228874137a45995170b4194fbd91817e0738e50cd9b40aa9ddb642da4d241010371afed6cbfdd1804704e7a4fdc97bb0f7b11b023db35d00388ce5f1ebf328345fce008f909fd1f516db37029752d8d07d05de663ba99a5ec8424d5ad0090824af0c0546b559ffcaa55af4509838c909aaa27c88f9412971c739cf1a079b1aa873b3cf6b51e4ded44d9d93d2a3f7b05ffab650ad6d2f0c03f45339a138075aa55467bfcaccea4b832cc6940e48b0b92695f034ca8efd8200645520890405e26f5ddb40b36b5ba1d7d8e22ebf285ca87dfa2c058b779ba0b1688789a0b5d75b650cc25e012eb74887590a2f416a6a979dcc536ad4f95f344f1e4a052733b61810cbf2daf25d48453997c41397194b7119e03edeb7983b4487938f5e847323dcc10afe7f7a6234024e80dabfe5ee3c363f895ef1d1713bdebd53e9086403907262b8b858495006667270e80c59bfcedf0ef13c0fd9485b1813dd4f4e5442b4879bd66cb0c1f0f571c704be419444d93c1e6baa4e9035a0bfb00cd63904929380eba8cf7fd9abc7e0e28ad071d0f43d99bbab0fb9186270853868d4d05f9e1e43e3a335448735e4507e15f8cd5825026ede4b670c3bb6ae85274249cb9c0216b172de2c650046d122f8c2b28e2d2950e8527439262b6eeb70fcb544528ff2505e9d6ec7501fbc64f23488d08712b414e35b5311434b67bc68d0f4e22c7d35d0df4762864950abd12b73c7ad62157a9953f925231d5fe3bcf442e112e485f157f6166219269eb9d8c4dd7a55c94bf8778f1d3661787cb65fe96f9c150331b86041bbf6b8369d75e0cc94d0ab446a1d7e7580dc7b24bbc441ee5154705ebe64359d41b97ef692b838413f33c078736ce89ccb48e571765f910cd1bbf7b2bfd3d3182347892c13987879b41099fbf1596e395fe3f67f88a32d836b62d27b500a49bd15a34fc7928b4bd1a41aa14a495325e1b9af0bed708c06d8e7abfcfd637775102024c244fe5d936eb5d5e47da898d450b1af63be089b0d8d8b6b7229704fe799b62d9b2f039bf84146a1332649166f3b618cbf41ba988f1562e1fbf7b5bfc23210c22c0709d042df9945b3dd860fbb01dbb77c75da7de5ab030ce3b0f6c261229a9b83d6de08aa17d6d66dcc89294d29ade32d2fbcd7bd181cb7c5bb7a8f86549a264ca38ad76fecefbb428ecdedfbf7c9a467e56234a6476c6cb9c27a94de3a80998f528ff9c1f30ae572b9c60f149950fa2117a61612ea17bca64b4fe86462f80c9bca9ef38767e8f49b2e2dfeaf63a9363d408ff359cafa72b1a575a91c5d63656785560134fb7562926ec7c0caa6a80c8bae184de6b52ecae29f3e55900197fe19fa34c8949bd4da80e881b4e5e61da25a9ce444607c2b226c3b105e7bb285040a42f330c3b2a42e911584559b366497e8d7d26c15827ad2228076c93290e8f92b3cf838b4dd7ef138c964d48844e4a7c661042fcf5b41dd7a73fee6fc88b4eb28c3c3517559c6420a85eca0b905fbc8bf66457e8024d74f2570ed4049f64afb40cba56e3643c656cb02004eb418211cf87e4dbf6db4744c79889748a5827c41912330f3acab1f3b0153b7f5e0afd415a7b221fae6bfea44fadb9f155b74e31f0570ecd88ab10d28f20db53124335460815d102f8b11575e7b9975c443c101e1d907469c19307327c80c63663e2b118ffca94609d48c7f558376d81b8f055c3cc3d842ad1dd9761cd3869eb362369adedc75625bd9059ef11965973b26df80729fa5fec755a40349b0b03f580fefc70ada4ae26b8fe83d03327c2f98d3930d70f2f2a3fd5381a5f95dc54f70ab172aebe94dbb2b7abcf36c4b9689a26af027746a94039c5c49ce88862eb685e4968b2678e2db0e4e084378b8ece31c697847ce1592a371bd1b0bbcbb66b72eeb0ab4b1dbd93e7f9392dedc02f7d0d4f7a2bc1a6220c7c0a93e58e1596da0e4be7b20722fee38da1374f94ed2c242fc7519e97892dcaae3a12e821e4fb82927ca03c39094469595421a748e7e7ca9d893e27421e1491102706490491ffbc65be25145d61d26717112d941594ac169d7f48ea0b97fe11e156b99d8ada4032ac92c29a6be39918999ffb4082174abb49d9dc03893367fb0d0884453c445948b0541b4b2a9e4202901ce04ea1835cd273a0ffc6f60a4ec307378991d61586ca0e5a3be5111cc622e8dec09508dee5db4ebf4b048664413ed9a07801ef8b84cc1e1878921ebd0e3d251eb27730b956725a43d89728f3db1a1ebf1b7cebd02d48acc41acd5469e2374e15884c0d55c1f79da31d760d61ec5f46aaba384b60fb925066dcbc194d42a39443408a49f451a88c0b26d403637f8c18ad0eb52a982f92d7333bf13cf57e2ccb08a6d4bc9b413bd8eb3278c49905e3fd0703f1fbd67a2be344ffd78f16c266efbfed0ef95365c4db9cdf141dd4ce352601ef61024228f38c3b51b0ca21dcd2d06ad9c9f0ef3b706e8dae1b2b76519f79951372478d60e1dff27994b82c5c7590442b7bab3aef3549ce750251f9ebbd63222ba4d891a454699d30c4eb8b38a2c5f499c858cb5baf460fd61a70981e73cc03cda6d52c49df5746e134fd983e5864039eb22dafe84ff49728d0565371caf4c300eab42a0d782aa72dc588f99cc5404869faec67b64594ac1aeb1314003ff4558626601b8390d8564a63bb7928718ee77ed4b1cbfd04daff62f9a20d50043cd16e0157b8c804f8b456afb96cfd1f438df75bf5bdd65ff65b2feddd3b3323b7eaeb540d9d5819c3318da652a1641f8e062c74741e17039b1a06b1c82484896c0328bf14324241be73e2c996b6f34c253f39109837dcf0e7534decfe5eb7930f7d03767d8110ad64578e3a86ab6da1130280862ccb20903e55e1ad4e3599bd9d24a39149051d200828ead590fc2254731a72c49b7f5a522d0375883dc1a47bc2f6aa997d4f13d4a8dbdc12b5a1ce2cc519968b88340847b4e43b8a16b4c50d562536985639770cf91be4dc6913048b0367f6d5f589c53ee33a5e6f9299d0234b962d1b66e1b7faef148714857cec90878d37a19d005ef925b1fb41040b5ca93384b3d405185b4556d38297f1434bc95d07a63529f90797b78dbb778b5bfc1e0ce1b89acc710303f9bd643656f43ca84e9b9301dbefd6f6ebcffc128f018aea323679e9d778f8edcc36905146097d1d202c3416c66869a7c2b0f812bc5da6924022e9dcacbeedb314f3bfdeea5b324ac55c4daa0c983760b1f3ef0d48bf6779c71cedb57c53c4ed5ad1796266bc7916773f41ad67802625fb309d4a0981812c7145804b7d5965dab6fd96839f62e5ab845f3283a1055e91be8cd62a5e4dbc87eb5032ce16e7e719c8ab32a9b627712a3a44f71e4855c741c525bcf0a6f1f86efd6825c1003af231962a2d1585d928f7974ba9542fd31a0031a06c20f36ea1ee09955a5df997da45c76133d836883dc0b76ea609281910db249352477aac8a097cc333ec337a71b48aab4d260b0d856ddb57576975eea76107efb4faf125f49ed5cd0a61b8d57aacf490fbe9b2124c48d78a6469952148fb64f48df5dc8edd5fe4d3113d10c44862138227a85f0c5e3827daa68f4db5798e27328ac0f6e7e6aa85818d403a59613b7ed26fe310b5d84170c1fe14c99388d4813fd9eeaa4dcece4e85030f43c1aec208c41edbdecdcb9bd8cec048ff032cd6c4050f50720b3c91d9485cf6773dd7878477d09b2321b5c8ae93e88ef27c1a2a00d0447e477603a0542de8f059d95e6b538f17e5bf887b12903b7d50d6a0898c9d33187fc9a43e47d02b8fa6d613f10ad0208bdec7bebfae44d3503be8a3978d8d3f7e9e2baaaef92a9ee9c337c82abf257e4a793c6a92498e4345907cfab2574dce4fb0f940b6ea31b91da67df39c8d7892b3123732c98d5b2fa882cb7172e22a87294f6bc48e2eb2807490151ce075edecdc965edb44464469f68fe0956150ffe32a77dfc9bd18f58bf10b678e53a2ec464cf6b46714cfbdb793623741e47049b5d620423d574d9dcd00d3d523bb77582ec9ee7368934018dfd1d66a600d5384cff0f1619606f3b040073fc190687f725b15ef1a2a94effece2c46962ca84fa6cdf6f4bfb45f0a167822c4a5b7edcba05cc36bbf19626386ddf3ec36a6dfa47f2bad58c19b7d14b49306962f2cda04f2e6756e80a3e913d51d8564f7348ba0c37d95b417b82c2f6183480901722dc7e063a3d9c9b396a0415bf016ca439eb6963d84a1e4d21d0ae6a6777d03aa6bb974d464f300e494020993c2724b94ee034a7481fda47a552da3562d5f969c175f31e7246224e661b9f35ad55a96720a58cb3006834df3cc6c84bdb1a1041dd86c657c5b1807e87ae8b02a2fad0d48eb404ef63fc6daeccdf0f8a1126157ffabfd9c5892b92b334cce8bafbebba60d751c68889ba8f3c9863f4ba8cb5dc3d6516182d42686f51d1deda34d36040a444d416ef9458da9dac7ec1c37535bef2ae30ef35c611f64dd3e7a88180c8d0493afc523df54589d0726ce1b090e3d6a2353a8bdb6f2ce59e317a76ac3f51a13e4c0dbbd108404d58d1b7d858fb98f84ce4a69e5758eeb8e68438b81217051ae67808fd6fc536cd2a5daac8271f2304635c4456285cc5c9493c57e06c9b5e16cf203670bc6d4762f9e4fe4b95c00c612293e6207084ba713d578d694a8dbe68caa0441d26dd058741207e66480754826a9a67bf5a74b4d03a6dc0f7b20c3d5cbd007cb8023f24a0b494d69ef903063410a7105490f05319885ab86ad5ee6271bd174f28baaf77e9316297a83c6e98089a371e262b8a5b8f8fd845520023ef854344ad1c3169ae3a54949b294e96760ecaf37312e7a844b459994526845dbde6dd1c3f7cc58a1fbce80b6308decf045ea876bd27446efd4b1f60e26231fed259bbd5a191986f8af4fa78f1120eaad49feea96fad6da5ce90ed20809beef9e1fab59e1baf0d60b965239a656e213d56","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
