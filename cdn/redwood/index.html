<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf763d231648097e2942f673774c30950cdcca3e149d879b8d776f76d7ec4fda25ba86a2e733d676079611636c977cb1f900f67f73958fb570f2724bcb9abd77fc214167150b8317a20e4c1662205ed7f21159da836d1b1d0deb2bd0d71caba6f719cb540f0111d6379695270f763f49ceaf6cef8da1483a831dee42d7e46fbaefc41174ca1e8c8f6e4e4d9de5b5f7908b5a59bbc0536e665985b1f79908b482821f8344e2a7fc8a4c03b48100090242063f42565a10a4987f705c521a118bd40b62396ebdf31f33ea205accea6ee4268fe20cfeac6afb3796d8ecb909d851444b1271726c553e46231dd49577c34f704fa3334d06221d6f15ba79f2bd27abc51c1e67b67718ba3dc383bc628194e842302e927efd921731035d295b2ada1d36beae608a208b9bc2fb7aaaca3b5b30827d8481d036cb2af4486245aa687dd8089e8b0c3ed0ed341cb72f5aae6209ae563c8e22031d9b0e3e8940ba997753a459b8ad65cc613970d252946bb9ee0dc3eaa2fb0479b7597f9829074d1dde8cd348781613bd1f0bb388ee7800d5a84624ab107ae61f73b717add995a27fd0b071130f575a6d6b98ef0bf9b99178df5e96187124711079986a6f8bc78b3a9adb896efafd30fca845962ba48c1d488f9e6ebab797c72a5bc7784228183d4b7187464a4075c658636305fd17029404e06dac818e1042efb03ca677fb6c6aec5d3a2a45db40b55438f9fa1bf45f8861cfecd4a78d3c3e7e50fa7c1af2f23e31bb37d75d8d73f1d174be2b9daa971f7ab68b4bcc4f2f41142103bb78f2b76fb1f64162dad09125c0649fd9f2ff6d89bfab54df55fb59d788eb1c769e1b168876cd73635c11fc0cca63de4e1559b40ad2d4c2276d58e5cf83e9c2abf96e7c7ae76216ee405f955e8c7ec4dd7517d8aff4582f0f3024d29c1877219b91b12127b85c308e4f7dfc2c9ae14f598fe98db70070799dae73eb6a7d905a3e86a083626fde865954e583a612a35ffd5b00eb48b83036b14fc0c26a248bf5290f5b100072b2af37122d450778509ae921328233ab73081dc69770ea4ae6013568d38e19c981cf17aae9a969a405af2fc7f6afd669f421e3c705964f63a9d4240de999892698509d67bd60b754061bdb51c8cb22d14ba34972262b0ba19c6f8e7cbd99ddb2a46f680461b87fcf7724fe460d0f4bcfb6b1edd7fcbc73eb3d91ba9acc7236eb36a2c0659b86964527e32bb4cc8feba0233028b104fb5cfa257c9a3ebb5ef90c7804d935dec0745ad06a36fe7357f208f2c6056eafd8d1014599c3e18c8b4fe3c5fe50008c8c4d93ced1c82dbcb2fd8d5076542a92453167732e94ac4da86fba3675a5dfdd00c3d989de3cb453566a064f5a0d12b7ec5b5924a94c8f0398c0c09086948efc3d45b92bb9c9bb727b365f478b69ba03ad0875e5450c175c53b08955885a68e1acf36493c205db8ff9d0ce372d947704416557a24e754e0fa36daa64188a19f3b1ff5b410a08bec9287c7e58efb099303db721625a28f0e103368cc7f0dc67fa91342c4b4277833dea11ae560adb32e4e9c1af67f16765266766e1129764561ab564f2d2439a17f2bab6198161e3be861fad1bb54b74099aa86f34c80287d62c2eb73d1b07599c528ec38c8fba3bd226fad4b6cf8d17d1d03623642c058d6bbad7078d91045ca1605a89808e4b8419c2fcee31f0c6355bd84111555e4ebb1f3edf006724025c6efed607c52798639f1279de48a683f32a648c05a8a335579fcc2cf5ef28d0717c900eb67096abed58eaea107ba348db0d34c4b36b906a37adb9879ba6c5e87a04bc94fd0070611cef77dbb5c19d6f79acaaba99f900a365b3de3b73d5afe9120db5b95f56006551df77f183b33ff8bc643fac4ecc65653bbe697ca32be06c57db7190e611259f4ffcfbe4299c231da10da7cd3296be6b03b6f0b4b9ca68fa67a195b259c44185dc412e2af46b777511dde05ef9dd866517894ca6658055d15d3baa7b5432f42f207808b9f1724ccacd8858f27db022b0c023426353a2c1e0f1d3d2ce35b37996bb2c668debbf18c80aceb68ed268644afc60c4c2aed5d87d48b6baea4274cf5ca93af52a5412294049ab4472953eb38b7ab37a6ceaea4ec7f13722f06ac8ba261bf4dd642cfeb03143c71c904bcd22001026716614b533f849618de9331b8d5984359144f3bc1deda35701a607a9216b9cf83a7ed9aa84e297195e6781dd4f41022ce05a1841aa80d6aabc2c9f809d0ecde84871dae74fcab5d87e0742b5ebe86189df640982b6a36b0984e534240913f0d241b5de6af8a4e8c03d7ea5ef61db47c1016b79b911c558642db6512b0451a5a0795a78755d60cca6962c47abd7db14118f9c9f0483adc600afd8d7f39a825d0fd126f6f19db3f4c1e09d9133f820e6bf58eccf5e912195c45468e03cef3f0b9af4bd6594b929618894328be5e13dde8d73af4f7e1ce686be3fa77fc18691018e47e2c80f4af392601b6e88fdc1b58bacc5e44203eb59c6eed8c418312fd9f5c93d425b13c487b311a1f1080062fcfc5e9e56054fd4ac91234e3c900f3104ed3199a061697c03a20dd7e8b1fc1a3b301433df53b0e193397e7d6002bffa7828e0d6d2194ceb987cfccb1b3fedab98d857ce70988936f75a49135b33880d00ac1fda4c96fb5d555d021ecccd5c728010d014dd47965c213a15bd6492713fc43ab4f893acc3f4f284d0bce6e0927f682b2c8ff06902b97268561947b3dc2c49647b5a69710937a149c8896c4e904b46c0a6c2af04ebb45c10e552f4f6482b34b6d9ce846d5846a2ae78eb1d17daf7dfeeac87d1d4341ab0be0cbd7150fc0471c2e78d7ea9cf402eb2c1660ffe5a5c9f6852e9e7910fc93cee66e77b1fa6a4258e6fe9c3e403b91f1d9554a3aa2de06fd34db20be36e37af6c1ec9c623bedd04b477280d58b4df0ecbdb9d2559fd8bd88edef6b3535e2e9d6d027bff4f2788f984d7d48605f2926da97a6e9aed2c589785e90339d86212744a9a3568914607e46384b60f11f3022b9c6592b3d133e0c79ee3ba3cfa1da796f970eb900bceed102453521eccc36fa2811e6392628a45a4dfaa59c036e81c64de4319ca49e11d93a0210814d7a706df2541d774502ec9c7058d4e355ac6ae7374dea8f5c5c531fcdfe558c050e8ad12b631c4e746d4340065219c4c0499bbcf5326a1e09e3c4abf4fd8531812f0ef06348010537500bb375bf2ac4f6cbc0d914279cb684adbfe0541cebdfb25b5fa98b72d7186cb1582d586eeb9aaddea28839fe8bd93bb75c2fff0cd683eef1dc4d81107cb3789c73adff7814f3625dbaa9dcff1a2cc9c105b64e364ea6092ba09540ca4c5fd29fde429c1a820e9c52e4c1c12e04be1a2932ecd864d40c05286c635ae48901132385a76f79b954152e2f32ad42cfe31a3ad76d75d6c5053dfaff0bf92bc89eae20ae88a4b677a4ced6269e768392285733135e98d7acd36272459ad08d1e4bf6f123951cae3b4ed1ecf3f92e4a881173111ec40df299c40e471f084c1fe8b642d45ecfad9d290fa6d39d706790fcf2f1eb1a228bfa915e328c7be4aab74b98d55a2afa2fc49411cd53f6e9d8848a6d984c76784ae7a44cc57b5e7eb821851c3d2201bf5e3b45f5cc5b166e3c390a95e1f551e1067d2481ec2775ef45705fb391c5c8faeb2a7bae26d6a4214ab867fb73bddb870d3a02037d174e429fa19113a8cf75aab1c4e95a5960aba261f428804c85e5d2313cdf2fe2ed3129d4134545382d6e3da1d035f655d000404b321f692e7f35bcb8c899ef7a258b73cfc4d640a2f3eedd411bfb37eff1d86cf35e5b346d647a6b068439bbb406405f89221168885244d6641aad515bf2a1e0770c6666f6ea75784bd23975788a8368b81fa04d1fab8485b2fb9045cd1d8a3f5341a8711b3f5ac53e672e4700d3cd2f0bc4dc30690dfc1d20bc4d409b4a56c45f73a25394ff565bb500161bd410f8718d71dae03b590a238fec4da895b48d83b3ad1fb53bd060577814101feb12afa3d55081fed5150a7c0dd711d23907445e7d10ea52e095f8393009a6dc9709da62f014f78d2bf049cfcf23164b18ae26be192cf307cbf7c9e0e0d3c766c97a3eb3e002fa4b2317de31bde25b6d43a53bb480874c6da5e6a37990f31d21acc630fba900bc4c013fb091d0c31febc2c3fbdd1e4efd6005241f1bcf10b140495aa859cccd09dc7dc4f3d999566f4bf4ec950a3430287b1043ca84fd81735ce85d2b694cd67cb6019a0801faaf3526451f9a1abdc05ead5076d1bfac979dd7a9ad890792dcc77f0512d28227b3105c5b164d423ac5ecef7095334a65ccc8a14cac50a4594f7a6dafe1afc8b1b7e095a8f163c33ced49c779470c7fe1cb7d01b7bc866d39e4e2126b1d5cf3b0fc46c97e10694929c747be622faf8ad0d45bf79c4ca22dc1d354954eb5859baf57ab79f20095358dfc10eed5cffba273f6256e0364c0a3a6a56c2b2de9145487f872d2c8c0ba60a0f2e7349722dbef83b5fced0ae75404766cfd6d8dc45b9e949f15b856a9710f190f7e44c2075d217500791797b8b61349a19489d4e27c726013b8147950f25857ca84fca06eb33ddd313fd32a05fd0423e61785b018f6703a948655eaa4dc43155ca359eb31a86e0b56732380b7ddefed98d0b084cf04617e46c68b11956490fb572ec6e9378a19c81fe79e6deb65c55bf6017bf981b83f039f6981bdad70691e4f951284f5dfbf6cd402b8718c7860571fe8dd0be71ba92e1872fb4ed92524172ca47a335982ac04b5558f5624ba08e618068cad5a2704d733567e1e3787a66e3ef45419b49a76e08790993816c7d2e6e5e60d3ba893a32a3719e19cb8a7398716139a696d764a249fce0a133f46363033f74cc58ae683a1d78e8d1cb22fe59442ea19f726bf5f720583e69fce00f7528401a9ebac2d5dad0e3b41ad358bb8d5871d1e4092d177dc0d761876c9648c2b1846aa637d8830313b40817a74727be1819a99e2489e9909f526bac2afd411a7700377d31fcb3b6602700fe339c21fa59ad2765c28fe8b607bb259c1879f6e89d4b319e7c2cf8d1e5f6393e2a1963dc2a2f32d7b6698b08dbda5238d3835316aeb3398be406d5a3d74eaa898eb83692b8df2258f0b556e25b3f0e8298d8c7a37b4c08eec826adfc64e81563844c95fc2a55b7e3f9fe1f1307c6f8c6286f19966da2fe2cbaa0c6a6e11aa3413350dcb9324a4d2718dd8445b0bde08a432e46292c7a23c68d1b2a3805f0684d4d0af50f4991c064de9efc84a3f39029cb3eb5fe39ac12d38f34a5366ac1d5836d296d0d984d68e199044fe7c14b8cf781257eece9b35179805262cd743bd56dfd56575c30e704a573d5c590c41ab5687e102cbbdb667a1b94a845a797f53a3c6e18e46817b15a8d1db21f9ccadd1666373a9f177ae02fc287222d0f939c17c342fa3cdc5250490c7045b2c4dedb12fce3250613934d858894068d82c974c7739ca7f12896f5e2ff6a3b239a8a344ea0a5bdbca382491aeaa7200603eeafbf76672fbb589a5b9bafc009339986470579a2eeea28e56e594bcaecfda1aa3be2bb88a61734fea6b351bea2c8a5ea27efcdf8be48aad3546f55cd4b2043b2c5eca2720f4e37a2111aa67b3089f4d656ec770b30bea68578eae67dea56ba0d0956ccbabbefdaa89ab6f1bfa55366e0c6a6b5d87adf065eb6eb40cc3304a427e1e1e2a62461b55206f82392bf5f1e1f3c2452f513c3a72bf42b20859f58a99d6a698b67744ecfb369360ce3275900f42eec6eb2dc0855c7aec545cb353cebfb8eab74a69f2fc72aa7d8864302766e320b48d10fc046635cc6133df524cd39212e779685fd62a3eb44285e478ee163d6458820ac5fa31abd57aa7b02cc038d5e35a8cbcabdea6d76979ca1c664e60885c5edf24a8e76b49a5b755dd7ae3f136c784edf606d5cf6ca01fa29e48cdc0d851be292e7c62c9b06b95d674be865504965bede5075d1dd4e991ff36fa4674c51893bac26cdd85b459b0db844979bea63ef69b4c4f9d699c3c4d2449eeeb6dcc076272ec00570874c65b9a07741032e2b8712bc45c098681d9e4fb0eef900ec393c15fb1e34c74324728a0845ab7a3990f2f5e27d5c9b334d36a53899fb5055dce4720e5564e892a7fa7bc5eda04c4389e6c9973c0226c064d6d2191f46ddbc2037f7d7e5c14d4d09dd053e67ecf04f7178046d6b109bb828a2d892f1d894ab25d8a9247fa8c51cda289b0dcc01686499b155df73fce961f441542b09738c267992190dd19a88fe98da2a552d672ddd8b5e6b63838cdc75f685d4c59b73ae5e49e5dca4344b3ac4413ab4097a6e6bdac68f607f4006cf671664554affe7d3522a1ce3513f7edd5ef605a86223bca550826f199e58f320d7345357ed8715de5ffe00118eedfffa60bf9228b0e0fea13962605696dedd95facfebb7ffedef578c0c07bc84f39e7c40b7dc9be6aefc4053b92146859ebe2c1e026abb8d86da22b44395933decfa7dc014228e925a02383b3ffabab5cebd2575932c72d4111e0ce31be74284aacd818dc82e56edb0295f68d13d5c0a7ae5afa9afb2b3f3f4085eb367fc0783396696fa869d6aff6b01b92c2868dfaad721da467d3c348256150cef111640fb889b25006f837e54febb5fa14e47a4b3424a529ce37a4238c8ed90315dd560658089e06000b3a942fc3bb99f34e4ecd65e21f4015b92a1816a87274c5ef3db5edf42381ae8e6b547f010a4b9a2f2ada4b60ccf1dcac2f3f0e1cb882cdc5355f6dba7cb7d2405fb681533b51fd64e5e5664db2ece92a1d7aa3558f939fd31713caeef41eeddaff99284626cd22c383b8d69ff99609454decd300f87888778d4b14772d392e2674015500a0d0dd1e7245fd6e8405b3c698e48e657f32885cee99eb6d3c4b883db13ffd8b9e90de55ace3626af2dd4ffe7ffa7d7ec107ec20a3e6a3a05b792a7823f1077bdd3d1e9f72c58ae329b4578da598a3fd2fe188a4f7688f98550cb4280f8167373b9955e3b165e1087ad528e91005105af4502fc30117bcb427e428bdc838e5107b00d5f071ac790dc23c742d26b86ed489250a3d4fc94ac624edcea35bc1cc842135d68215762c87c3e0cfe5d64f4d08f3a8653fbe800672ea5a2ecca9732d64c503b7d16726e24e11f0f3767652434d548f7ed4aab19a25ad2009385ed5890a536e007daafa239f1edca68a329be3122c762db5b73204edf1ec764a8ee64150982fc4302c1964e0def5c3e32c4428875d39e32bed63f2664d6630778d9536ed6027d3b4ae480009135e29c5e4905b126c26981dc8dad1f456fb7398df7f1e41da42b40737886e01fbc2b46d4b38a28f05660122f6124f644aab3de8300bd23a2bfcd2732efec02f1aa55336381bc242f9bc1c35fb454d88471534e6d32c1860bee81af802f074d81e62e82587e8f9ff959e58a3d6b153e741abb1c1e0cc48952048aedb9a155a450ce0b5660f8e607f36f9a0161c50f80c88dc4567964d1073f61b024c79e2b56b7135a12d7b78741e343c145de75083523d0036bbf29da3160b0c39d83a3450187c9e22833e206386cac28be891f3a2bcf748d73197e8e05d4a9f6716ae705728a30826bb60889f59b87e188a3ca0d57899a9d9d9a2f6d0b7e5b5fcdf66fd883893ed14719d816f974ef54e618ad326231e91564828eed064d90fe993edfc43c8ca4d8635130d1f316ea5860bcbe7a548aa55f2037b788e4cc232972fb709f60f116bc1f9f6c206cb998a311432a10a4163860b1b6e5b6f48bc0c70c57a9e05361500a39390bab61467f45a9cd5d2edda13421d9073694859c6a6af8f0346282ae1f031fef0df95644199cf0a08199d6c9391bee3bc6e8a63201439b63497846b122024b738422574ed5a3cca417d38c6f2e0487b7e3712755bc40ec332a1d9a44fb29dc865b273256f7a2aa3400686e459e3a61b2fea43967de94999aa099c55ce92cba274836acc11b385c21c14f03841a7757d610c0b158280182a94d7994d3c2ed53dbe299333de25ef954ea3a0443d1843200e14df4abedbdf3c9473beb868ab40b8102ade492a4c8472c5a2e6aa00639fd1895c7397d968bfc346e66725868997e5d88cf16d07162be5210258e948ab29d97f9ad1b859c7c7582fbacdceaa0af5cffce902778230701dc0ab0ef768712f40d92c6c9c6a578299454ad94786708aee058a4947ed80ada096c1543be86351878d58656c2436bf3c8b6e4838d654e1e9ef8bd554ccebedb038c65b841ab347b4d786e1d359410054550390d92c286821bcc25a9f178e9ce368b7b34405c69702f5b78812a7e62d31a801f6ad1f7a4afd9148f1eeca35c4028e788adcbbb74afeed59b453df0f11df0b921e7079238d186f9747a9d64ece96f05fbf061d641c275c3df53f4e7a31fe3365033f3c394ef05cc8a46e490129d0f05ae23d8991dee628101a2a55faddcd90b1082ea6196cb09b60090b8708c0fc60d6ed6ffc5194531b46fb9271fa9823abaac332005ae1cbae63d175d3abf608f64af5afcdaa6f2af4d0b7c8b945aad0ae22532b6d896feef0044faf532dce41fa6bfa0595a93b6ab92ed95b3cdbec51dd19dbecb22e1146a3499ad74248f423bc1bd9c9e0f2ae451aeb7b81b887b581e988ea4f5712127f78340d4480d7fb0cd88a7ab16af5e6cd2d82af68fef415d2f148ef31523a26082af9787720fc125333b2d9e8514fc58a8694abd4c1497052a72dfb57a733b2d28289c95a7a17b3c790e19aa288992582f6c580df8b92feda1450a9821ecf86e097f0b23c21406af95c4a549e216c07b9e3196758424730e3169b650816f90b26420f20318ac1b30fa89c80034eef2fcda4b20c084f7718012b18b7fdc9f33457606267e57430e492b2030c8179ed38fc88f46ddb89c7ba6735862bdc13858bab97ff929860a1805beee0a7e58297fb0e0bbf795838b1c8e77538d0fec816e804944a7309663f76420cbe883bfe139bdb7d9d6608e70c3263469a9d514f1db4730c4d2fa675ced15a5b5505d0fb4d5cc09f3a078e94d21f09838aaeee5dfcbb1132bd2170e04b83343f33d79a40b813739ab86d104300cbc0ad289d03a74c0e62004d37f5718368f072d083864ef217ce5a6e7b77b8b46bd411ea4d1bc7af6198ed3b2ec1d133ea90c45024ce5d475fe6fec865f94c76513777ee680cfe5070517d0b832bc14792116e03b26cc202c9f0619a38a0341807634bf3cf7210de3b033835a78c9fe863dbcaa32f28faf745799fe60e9c156047551eb9df75fb5fc6520873851e67748a3ec811734723fd46df488944ad8e2fb1090474d8d75ae20d606516353fb7c8a7c2b781b08b9b88f16fb337e6285ec87012b449d2dfe4322e31d312341cb306af67260b641b5e3c35bfc36ac1f1717fdff70f78a632d07d2639ba2e48552c3a54065f4ce680726fe8207bfae69aeae81d5163f67846e5a4aa75faa4e8fd9f4ef2e78667c63b363c6dd547a6a103204859b835e850607d961415cee1838832945fd58c034b2ac761e700b3cad9cedc0ac69070aac2078acfeaf558a5548e63ff778d88ee5138b3f829308926d9c33e5229230f3a65a3e09865596be784621d014662f287383cf40d4f99768c0ff3b70cccaaf1a87cd26e489191daf71da548c0e18e7a4ca45be3d4b38fdf7b3d1389267878a58030220874c94e81c79ecc5c032790268427bf7ea61bf0fd01e97f0c8337312a251e56456fa677b25319be3161dd01a8f1cc961bd44f87d345e7d2848a471deb3da68082d2ae8eac7454e18cc869fac754cdcb4f48dcfebec0f126ab8af2a09010310365b1fe71a14e93e8afa44cc239278e4f4bd4051c9dc69c0909ef4d1807bf2e4df9ff9b0da4329fe3bf5a24d7ec568bfefe99ecae62b32bb4a6b3219fd37e4c3079d5bddab6268efc3d31ffe906933857462c04921ab2fea67144a57e748c65441d29e68768beb0930e3ce6e66c55022ab60498ce38fa5af01d59532d2ab07e2c58b4d2a925b2bbc7fa2163fe4bd9c41230ab3359e0fa5dd7d1078c1d7319a1f0786a91b2a6992b1e66f5cbc4f2d873de39b9260d6b204e78de09df2f4fa25bb3f20bcb53515e4107752402f56c8fdbe0263f91d5722f46f9c860e478569a86ee261772cc6050ae3b40d375d7f906ec32aef843885ea5728f97aac6a46c9aef602ad90fd6fd2691e2ad6e6218401aa65ecd57e2e34068bdbfdaa32e406a946c7d106a89abfb35af390bcf66248c096e6011c070078b4832139fc5254ef194b116fb0a05006bec2474e9220dada8a9bd667bc0d077d57b23deefafff8208391bf568ad962fc1831877284ca4e9168f26eb7b7379c407f3beb4a958fa52d7ebdae08c2969bd218219eae7bbaac701c6590ca5aebe00620add6a5d0c0afed9473fd2e8617f9c60c7f50a637ef58a65a9be9948a9e39917993174b74fea9ba3bbb1064860d6471199e97d487cb7463618e4b800e3a86017cbd780e4a75fcca3c6a11381f5a51664b5e68c652259793d5cec22c0ae55d9d2325f57d278cdc3699d7e0b20f13e3335e006739dbe5b28d27b17b27430faed6b9cf3402fbe5a7e1f1ad52a38be72f8f2f427587ab989ed3c5df5e6b07ffdbb05e51bbec6df5d240a4bfe85b2f7f7f2d8e9e1488dcf34d9f607666eabc2798f7f74ae9ee3f7d7fafb023fe5663d11ec26a4c23d067494393c231e81215e94977be9dea3cdf4e8ce36c78b7eb98bc12e31c5bf072e7add5fcd589eee4e9c981d7234320ac2912fd38d5e348338b4ac23d6107cf5883ba3a7eb56538da04e7521a3360edf0948c295512eac0e25b32ca5841307181f76dd4c51eded5996458b073d8cb94dc31e588e73a6248fbc0c790fa929bb77a66427529dda6ca24cdb9ec317a7ae766a7f1d3381246d02932e546125ca4b8f85a4cd2d2d899fde9fbf2294864f7df87acaf72efb9669e984cf4c89571b898e9c798b639434762838a51702c7b0cc2e8bf987558c79509b71166f7f0c30cd47ff4ebb4986c5cc6bc8af34397fed46d54addeec7b79795cdb4b15b2a9e6e7275cdfc60c5af75b19abb613a524af07ed35f3fbc4c6690b2aa0d0e8e8581989f05dda32a0370f62238c9ac10444c6f55427985bc7784037f0337b91689cc8b0aa8282e90586d5ae4a1551291742dadfeab718407866a3764f5e273e4c672782d37adfb7f80a89b1c4b5a0c6b781c473b6856c333c353f17f838f0aea1bca2e1399268d8f039cc222569939e3ecbfc65eab1979aaaafeea507652f72eb1e9a8621c6a547753053bf38bcde59f7446720baa42c8b406f6c4fddbaf4c7fdaba24199dea818b60d03fa7e71e6dcc9ac2efd4f334b3a63ff7acf9a504a3d2ee989f29d3d253b6686d9f73f3ec0b1f3e8d7c7746d0cf0a79398423beabc7cded75a114aad4497118282b17025b5c6d21981dbf50d1034b5b24249b4a6e60d16e537e94eba702aecb134233ef5e4ac2aa8624504a151d11be8d004898bdb42a2878a65c343618d972754248c40724e980b6b6f5c43e831ae24a9935e2a3e0c8b74b96de44d57890678954e7ce941816421138802014b602ddc826185896164e6c3ce0ecb4a74fc20d362b532fb758a2055d2ad004152c5d8421567b291845e7a50d5fdf2af3a96a9f7a60bcb314a2e36c673ca135b00e774eefd31fa3f9fe715eb2ac201894aca90a5573ff739905695c695344e342643979da7b589383374c8a8e31372acf4fb414747b98271e34d9d8adba98caef9af843a3c557e4a2390fb11df78fed5713fd5e7ee599963148658b9b5b70ecd2d6e771620573045375974d39e2255c7267ddd4056275384f1d16128503142b814ec0fbcd06e10a4418cd5febb4b50e1f18d7853652c24c94b96d9c10f0f8712d0b7e91ff179ecda5035446f928730dc2e82a73ab5cc8a3d8bf20d4c1eee06e15c5e3fc9e9290430fa90a3364d4a57f0e71573a26e53f5febb367842cdaa40ac2f2655c5d560bc332a5430b38ab5783346484b8400cd1c57fd6e764cd92bc33a983999cc7e02e0f0f7d5cfc88d60f5794bb2b986e2125b86c26efb70a9b5f72507c381189cc05a4f63376fe73d41cab30ad22cecc6c8a2edfd57a1f4893c62384e382d4e007f3dcf823df7141fa491722ee1fe516376080a90790432b2f9cb1fcaeaa752456fcba45273ef34f7b1d00ff0c0d0d88f34f73e631210e8aa0638d8177f248534679005b32dd0f66880c0489e67b01c9bed29a7a8a09d0853498aa8a4ee38e082cdd8132468e517518b7b691146795331c0655379efdf08b0fe6d25e31332e451d1fe851971470455a1e166345314d6d81c91dc90191abf351f254ce645d6af8ee5c0c51a3673bd8c5939b711af84a345f2f5debfc5d9b2de1d327d9734b254ce2267a861bf5f4b43154cd4c02b5d70f9da50fc737168c556d3b542997f175c29a761e1dc34146edd0cc051dee8175802e2e47172aa380caee245b07924a1523c3bd47ff44d044c55609aa72277bfc1be60982b874e45dc9bf600148185ace1985aed13f46ce852f007ebfe2b4b76065e8d7ed475590ab89d5e7cafc293bd44953ab0a042e21a292431856b669bba3d9a59823e481db51048678b5151243146fc868b9e5b2b077d22a92c810177ba9332473b13701c020efe38a2a8daf58623447536753621eb9ff16ce5871721c5b7bb56eb7bbbe5f12dd303ae023efe33c635290a8a8c4fe6532417f466b097f94ef65a6b08dc388d96855bd433b287bf2fb4a5ef8b1089abcb680387c5f04f6e34bfe3cedc5490a8006223855bd39441ae7ac673324bc45b73be52d1cc0e08420932a457734b58d3f4f4af9ef81f1cbf15beeb90ade25cf543ff56725d8ef0c27055c42c6b08d50fa6b2c069f783125a4d8482772072c1a7d1a4d63721f525e8b269cc89be677c820da08bcd0c39fc3f8a5f8125057beb83c352528767ca831a01ff3603e3f8b02ed43e57217cb857377036508090cb24c20bd7b9fa4057a3d98aafd8a42001cc954b95985a99f36d4c2aa32b335d55e050122a3e52014e0f75426fbc8cc9b3a7a50e43424d349641a6841c01fcfdb15f463aaf005fb21802e6dc21f17f84913b3e792cd008b4fcce57775f595c83f2f097999e0ac3952eedcc0955408e739ca89e0293452314a341fdc0f244bc4de8ecb4255a9cb4848d6ee7b11564b92069b5626848139e127aad15afa498b1df5cbecb70a8bca923d54a1dc7293b2b1a7bccb82b3f283bf3ec5bd12a39b62462d9b0c0842e53c29026527644a36035afb2f3ee20a0d511ef54469e247a799ad5861ccab883b9ff96518c537514c2bc1078e6d9bc10cb92f0b9bea214b09e38af179196f6d55466401cd76d5656092ce9915630300ef5502c032dccb4172ed2ca1ba29566ea7459a24a5a42c0dbbe52cb73afb7d3ac8599ed42f8bce6eac7cceedd38352e9526d31d77d5b3158cde25ce8d9e888c14a2fbfe2a713d0f00ee4c4d2cc1d40a2573b631c46e40becd191c99ad785bfd4c04b82e88b46e787e8b4929bf0328d089cb9f955c8ceaa9da1737d46559ddc400ea0b443c34ef2761e2899693026ddba5660f0b9db88fe8b8d937be640b683d8968c0eee339e9a564ff32400eb0c314767b473e4f1949cef73da9bd041b4454e08b5272d5ed54416e80b8b4ce467da5cc9736dd8058939c61b5a24ff8fd62715b1595a8ab19405c45e57dce99f130caa2edd99a07c80c1fd20be50c22a8b347def904cf636cb2d1c87b5fd7eb9720f09735cf67275466765d697236f2b35e869d7a0453eb4271796914025ef27c66b29e303327836885f226fd5718c0e72a18324058c183c200bfdab158b3c4b207b0e903314e7331408ee2643b9678e07dc79914fd575e95e3d395d6d3762f08275236ca003d34c8115f8a3b98d43007f501314ba498aa6faad8ddd12c0b64070e2370322ddfc5fa713f058d6120e4fb318b508e82fa17f2377460cfe7afd5cabe1f5cb174a118aa5e7940e5f305c8634b3241d07ee187a8943b3633cb51660bff25ea4d6b97ce14ea1637b24778f92bf8ec00168319ab26bda9f82a6aaadb31f12ae1777a6f0d22746169f99e93f322ac11940b12f60b6cf006229491842cc6b189d693a035fc4bdf8c505efeb037e7ae180c7ba8e3eeba91bf425d6c4740fc36472048a2ede5d48c7881ff9df905533d9f94e319f6cae30c3875444a668f2d58c835caf1cd68ba099b33095cc13f57efb2da10bad6f89e1efb1cf986dad07ff6be13ef5212fbdc9ab44f8ea756b8be50d5bb3d40187646b35838a2ed7d4fc83e1deb0e45c33a806bbd9274dd6111c7eacaeac06fec5cc3725ee3b88a0de1b50d12ef80d3c7cf12892c6eb3e077ba3fb07c0688d87e85fa1d68edc2275f1bef569cdc64b979640ad78f9cacb0ef6936a7070084354a1dfa41f4da230ed1365c35e4e79746b633e3d923e8920a239c4dfeef90e0e9d3958d6bfc2930c6fde46adf615ac7f2d94f7e352441be0d9722ef88e72482989444ca1b69397904789b60b3cfbac6be027abf236904d9140820c088f0b8f4736cb5df763a3f14d46f6fa4b1ead7ba8ac4cfdd1d418a16e3e0672fbf81a11da17fa3c078095b3487437b3009f3ec9695178523042a5e55e781e8019820b044ddd33262d027a84c98c97a049438f0cdc80c9885b1517f89ca1fde52f4cc82b26b32c3eb9926382865505d3ae0f15c54d78f10a56ff036ef1054def660439e56b435408c147d91c4f4f0ed92a010c71ff7e380642a8aa1a0648dafe6992236e861048f4aee82156b290095e6941a9304c908c7249413d618b3be209bc9136748de8c80f1fd01ae2d1f18e08d38defa0cc86353941ce8f75b503934208ec60f7542f08c6bc04f2a77ee5ec6326e4855982f24b86bfa400107bed323ae392cd693630907302d21a8da9af4189ef968f2187bce5b3a0d1bddcadc4eb897636b4bde94592b26b30e90ba0ab8b651aa5911996182cf69ad98b9c426b270411314577df1948c8b78d4f4c9838dacc7b458dd3b53463d8cab80a8bee0c542042afd0c6cb4a65b4b4531","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
