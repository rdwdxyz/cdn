<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22f4455aeeb8eeff5b9eab648a2d59b407aabcff8f793db5c40464e6bf1ad0888082b872589ff09173149fbcf07c6aa1595510815d3e255fc1bd6071d58fe959d157582fe5ed621a054e2acc1395c766d42303c120bb76d864ccc8a1d7e9c3d46c5de88e2b88326e1c7aa02b61c4afa9e2354877a7fb803ed55677894f55a406f677cca72e5d2e22babcedef4a058a8a4f3c215beb5e913a71b93a1557b214213e0afd631f376f3bc4ddf5f6199a613537eeba4b0216b6b2483751618b672c1ff5af0c80e2e02641e184fa23ba82c7b2823fb93f44539652c7d1116b0c26dde463dff8a39591fdaae25f08960fe4bd363b90d78e19667d17a12f5f4e0f1973eb65284e750b8043a904c11753a60717f333770da00229e652542f31792ebd3b3b34a633e7e8a83bfd36fee43f4e689121b7619e44a75b089d30a97f185b6b9ef9d293333874bb0cf0caa1260c7cd025047bbcefef1d6d35945f5256c0be7d797f42165d3caa021c452e7e0276cf3b767c9f1913818edd8015aef3c428702fd7a1400eb12e55d687569de648f9a71b5f29c0763b5f28fbaeb71bd126f773cfd67e60fffe99c56be3c149984b4d50bd79a2e12d990aa9b2612015787364a59d52ee1c3e97df22a580d65201dc2dcd57d614d5c466e7783ff3d04cc7a16f0ab02434f14cf20c873a417d90c20505b28db183dfc55d84272cc379ad096b2556e800036ed7f3ff8bbe5be2cf2e7e4f358778f4dd7d4eef0a949d45bcacfe35ee0489caa9fdca6205eeda9fb66975369d8f59e30e86acf240aaa8d7ba5bc4ab20235c8bfcb480ce90c022fd6d85c2bbe6bd0ff8e08ab1f224a7de112ea0279cfa4519f1f47d433b7dda235d1c6d19c583e7f417158bb4034bb485c4c2bc66d879680ad7babf03ee270fc1065e9b190a1694913c65953bd929cb1be15a739bc5b738861c6d0e8f8abfcfb8921592e2548602ec209d260616beb401a7ffef43d64a89d0e37b89cbe574d1133e89ea3cf983956e7a5d00de7370349e8e7194924cbfcf45c09b9609cf0068d783fac42bb902f021d2ffdb2abb823cebd600c7627b53fd2770846c3fc60f433776e6366f5dcd5fe98e8acb66422bf03500cc8b7087a349a3af932c319b7b4b5b018a1660acb0540e154d95f84c21266a0d589e4d214c70d36725ecd37d7ae75f3eda33559936dd4700897b7ab19fd3ff8fcb8a5d3be8acd94eb28e67b61fa7f85d6e97195b5207efaa9104c77d43e7848d8ba2bfc14a1a524e4ded7ee7fa662c31fe9e310ac5a66572a4c59ce1edb1940c5e18dafcf7f7bdb7cf9d17b883ebd1e3c103f9288eb288aebc74200695f6d6ff18671ebe2364c8e04fe6e353289b0f2ee4f8d065ea585e85fdc9ba55173aab0a05b8ebe5743da476356b8c14b0070a847794b65b111cd80c2705f509cde84bd0b797ab48432470b15d4aeb10f1b1cfefd64680d8dc639604440c3d4610c33a7975ce0c9dfb297e16a3694f4aa739033a2950ab84523b858653670dabea3de9dd369d64187af1eef95f7f90dee2810297ce27d31a28a95f1d61bdc2e196ae8c8328a40e499c6d0a9a0e1e3accb45446b2b936dc55294f99efd166d6b2a676ce447ac3e7d581e86f932e7269b472197b766a79fb48dbc5921d708aa56016c603ca662b3435ed23fb89d5a551df50bf4d3fab4c83e1dfaa7b7f155d76b2dc3ad4ca349b27372d520eb1717b0daa4c6992155b506f71d004cb06812bf45294babcdedf3da4ef3affa0e15e0bac9551ceba4e4f8c58efe6e1afa0ea8a2ceb5bd9cdcf02cb2d89ad231b332d3176dfe6411f53cebc4a739228d7c2631ab8d05734156806d3eeee8fb427ef607bbe5f780a927aff5ebc00b069c647703dcf2af5a625f542c930ea8263d41764ceb0838fe4d7fa107f44abc011fe075d9e357ceb1321a936a2abe33999dc0a6255e995055e727e904113ff5ccb14ac9ce31b9d4a95775d3c5aff697ae45a69c5c3cb9f541d908e5160d8e7ee632324e3854d3649ec90cdcf0ee0712c6b50ea0ed95006a4d6e125ae496b2f23b364c93b85052818773554adaae30ecaa4060664f03f7cd01d4d33fb44f72a60d3e9c787723ea33d750c7a8ba02b8990927ade2a97c30584b23e48499fee2788bc1c18b3d86d7bb1cae4a9c9de6b40cdbc5bea0090014a562408ef1b43813c8f520be75d5798e25fd3538d429853df75c440fab704d4e5abb51c990708f761992053d59551a36fea037ef472ee17529daad6f7026fc000c15d5f92e4f4121d7f1e1535b2d9b99bbbe81ba7674c5358567bc4622330abfc8dd0f4d154b8c5b12f54703990cf7323a56effe13d7c9c6452f3d275d7a1c59cf050423edda99e5039bba64f7c2a3bc53bfb7a0a6bba18fb8d14565bfa55a5e1e3618d9fbe11137bb5872443989c0ade8aa0114c6955c5aa091c4a34bd47cdd1e1fb409c7109029e24a0186b268001e5ec3f301ff2eeccb84212a0ef7d26e88272998ca3b7454c3912d88068197f9afd9c5fce2b6850e4f4db4c08706cd800de4188e5a90dcf5455ca53c3a6a9e7dbe26af680bb82ad4828b6183f7cd920f15fc890854ebbeddaa9a3eef24e77d0de94999bf0d82b67245feaac1dddad3fbc54e5c0ba43a04e9ffd92e7514be28da1584bb7c8905080bb9342576358f4de531a5f9c29926f072975b911bfb2c0ea6990f21fd9b6009f7a90e239d4f6d31112de0bef1e7716105d7a673c7490cb99ee09f523363f9fa094cd06539bbbee2ada94c488385fcb1fa1fcb1f5f6c3af805c0c4e401aad8b094851ce6ff811d37bc428732cfe156ed58459bccfd1e09f69cf19c29c2aaa69a2c9e25301f054b44561c7843a13900b764808be1968030839f3bbc5fa4efbddb4b0b81d057d046a3f6829108b6faef89947eff141420c56f38a3f591e3c9e51e6a09d257355bfa81e9d0910aa871ce55830051910c189e300c9ac633aca04db9cd6a6880897d122c5c0b721b3d820bf6fc3fdfcbdb38ba8d14d40a133c11a0e79cb9e398e7a98fd5006cb992ee4db8feb2399ae17ed8da71768caa548942e41dee4401b909502322a0aa515eecb2bf3ea5ae327d25f09d22e5bfe21a1be1a84be52f1d81ddd1ba3ed34ab4662ca393aa101e055f8c4bc4833dd606dc7146a6c42a219cc53293d7d1b5fa66579cfbc780a5cdea37646bba9bdec448a7cc640e3c8221f8d6debb00978194c83abcb925de00f3eb8928387bfd636aa1f981f79e263d23c163122ce74e75130e31f410f48d78c6ac83ca9a7cdac9bc27c96ef8c1021c429e343d72d186fa2f3d7e7e24e1c013c43b07227517a6d14befcbff457a29f6e96d8bf75ff67f31d48258dcba5c05312155360e920cf49d3c560b153bde5ed11327f71c98509d59a5cc4acf52f75860dc14bfcfd4ec8d97ea9d01a63bfb27565a4722d7990168a263ce769c865bd2981c359ba83dc2dfbc62d512ecd8585fd23598ce794d13f44fef0ff81f8057bfe245661b21a2d12e44b6d6a185d8bdb8ab2d3263f004fd167e76f9a9a9654b5cf25e77e1aef7594a11ec649bbc7ead6b328736e057e1fc6eb3264832fed510680df417a783de8cf0cdd514915d3e9ae0c88959e507d237eef020190afe7a554bc247587cee8495f14ae71d3139087fcf71e479374d6d3f378971b1fe6735c3ef3369a89f940026c31ce4087edcaf5b9836e3f0c49defd7612342b5a5ef2b0e4dc5d83e4a2824a8c0c5d24198a944fd39dcf8c079dfcb7d752368b3beb178227290276e7936692877429898be294fde409fe3ca61f39f3fb02f1fcef95c6897cc32e103c3e842c788fd3a718ef0b8fdbd620c8662907076864199621e665895b1e32583b2f741b74605263a20240a4fbee7ea33cfba83fa6cad5c322ea27d0c33c482b33249086a9ef3ebaef273afe966368df43d0be3f47869fd1264bdcac205b46f8ecfcecce86a1e7c63d350140f0f65dd1c581b0d0f8cccec531f8fda49b259e45ea2eee733dd9b2e9bc5f8e0191982916bec9886533e2fc782d9cc0ab13c4e67b0c0b08244b12602782ef81e6d24e769e0ada6e0cfeec6b48a66df0b9a8f2c8c17c5405514d12c7f51a57b324faee1ab45e181c49541ee65517980a73bffbb4f57923d16b9a0d454e9629de5fde51f997955da857df7a3de12b99118d2fdf2db91153d9fed4dafc71aaaf0cd71dcbac46be3b300df3075b082ee2978d9841be41bf1c9b217d585db480d4f35739e12a544b5ef73cc238f6d9c5108732fa5aa216a9bc178385b17f7bb8c52569bec2e929dbb7b3aeaa025c980b0ac7da5355fb5e8e9ef6f0ff4c07773c9468bfc2682fb8c7468039eff5e760e802835b7bfd0dffb2a0cdc3e99aebb8f26302a25b4d378664b79ebef897d641ebcdb915d58e54887d0167c2cb66c070a3dd931b95ea7cda4027abca9a05f20c748f67c3c512e7bb9af20e650be31839534869fa989ea7867d488aa885cf820e4578ff247982ea73891a4062d84f16dcb1b29585c3100a68667baf18ddfa32e68d5dad804db30c7e0745e8c5c903f542d55c9dd819eb144d2e395a7e50d992817abf69f98fe6e73690454e6af7c0aba1503d2b3b30017bc7ab65e2d30693b654d09d73d77a90a9734dd89b84c793d8307f3e3430e739d0c85abfe148f0ed55a108b6f1732e9e560e6b13d5bf57f7ddeb0e9d57042d458ea2d5ba8e824a38d0075e5c6a72561a8bab0172973fac40e15b9f0adb0c608b80f462bd522a9be3bb1ccd45ffafa9956a9afc4f6a09c12c3401947644069eb122e3e095bb77ce202fed8999e92ed1edace7bce4ed42cd11956a655c699081f0ed20b5232057899353a539790a7a030ba456e34fe151fdffba05468f7ed8a0ab2732a7600b7c1c4627c235b8ce609d7f3c5a67e9c2545e0b51746a8f9d15a4f61ecda81c4a35339b9eb0e11373352baad6b16e37726e328b617b9f75e51999ba9f8e4c9897b445d3369525cca1ce43346bee88b8c6cec97c2fabfc09c8615c852f5edeb522bc36d44b593dbb663a79fb8f4d8656763d09735e487e4cd777f3b1d13e70890879f2d4ee5181a856ff2dfe6f93868558fd5e6beeffe8c85e27e9310a46c484b7f62afeb635f45e4d76581eaa88537ad8fb4c652619e84324e0f8d8ce626f4a2ecc63f5a1ecbdb4afd75b4df0f1174886acb173ad00efaf324a3fd72ca407b8ff32f189ce1a829f15610e3e83dc2af4da2c1e39168515e6c0cd46f17e03ddeb5530b3b3f7ea410a06c8881c8c34ec4a0e96c965278051263e2937ba7071e568c6de919cfb8123d8f7bbf641f9bc3422ac04ed06c54dd2fc73f51df5d2dccf974b6f7f93a2486bde754a87696644cac0577dd3bfbfd12bc7571dc6d4078f5bdb86a355ee50a1396d72767c396a1e51f1dc3f0509e0f64af76e02e6f8903719aea74b4681b2659c9743ad3a7836bd0746542bb3cb317ae4e02759c241f29a301a87894581f2157caefce2d30c2aba4b3431823e10bb7ebe2db3a3c03a8150b222807ad23ea7cae0ff38ff9991e1f175ac5f37277bff3cb6e977063d9e09c2bba15c91051a36bf844e31f21df6d7a96893dd6b1972e53ddb7233602af1cd4f87da4c0874272499247ca29de8a433e093b84bb30f3c54185ef0d4624489383d126c6d264aa18d8ef356b1f6619a6bf8251d5556ba9b214e2b158b400fb5703014da424704091271e41695739c4cac8447bd582c48dd88e6f842d0ec144d3172fb9ca5667bc24c5ce1d662b6406904e02d681f53452e76034d8293306c5e540c733c84112887642834ffa6e62755445a637d5d5d908a4ceb642c1b1ccce0a60e2c310d86eb50ec6d2a8b047d44723f5505e3eedfeecae4fece8481c4c7907908d92443668c616e649996d18cd5d8259a5dab5a0e540642ff4f3b9b832dc96145332d2e290dbc6033e4e5d770b23d66a3a3f64b65e947b0891439995d90a832eb2a6dc299ddf01c72019718746e8271a438561221fa91a34fb853bfb7daf59d5680fe3d8f6e3e941a80e82f9b19cc23c94883c56ad686d906d62fed306fb13c1354b0ae2be5b16706b00edccf8b3594e12103319a446150f7bb1a10a4eb9fb7a1379e0703417a2d5480fde796c6219499336c45a03911652b948215d069ac4d0c0c7a0a8557399e1cfe495f1a9d89bfe03a34a2d54323dda21b7b6c83940a7364f2c8e467d77ec6632f5c017eab77a5bc220350541578932714b5885e0ceee15a1be7c96fb2cfb8b7280975af29d6bd7557eb79ef1795c6536193c291b604b341b6c6e29d139427a1f3639c1b67963812ac7ef1b6590bed185b12b28bb50dd09ed1d5434f626e5fbccf4ea0c53f9a22f25f67b7768621ea1ad5c48139ccfb3c64dce8ba3794f8d67e6b43756b184f1afee110207a65da5929aa1781ff1e689a984cdc440fe8e801f68985a87298bf616153ff1cd14a9818011ace0d1c677a4d7443c149a2036d88a17418a28eeba484b3b67639eef888c37bf73911cafbb39e35b3a6a34a4651da83436c6095b3e7a5a88e1e46373f62f29eb3b55d543fac815f9a4ce916e72924364ee26f2e00b09d4196af808937df1a9dfdddf6b79f6f57ced532eb379fa438071f2114b53c4a4b2ac26cb2ca982d3b8f282819fc0f4aab9fabd3cc404413de94972c08015738fb2781913dc4156c4aa40fe79e9b5784cc8e7f24f53ac1b0d95cb2c69d9b278f4956af77a4ab06583b6d1432566f0d435474993101cb037547bb508f1c46f00c0124442cc6fa56a2025bb71e4dc41d94e98dd6fe8a498b47bf05fd8969dce39ebd48ddbace12d1adec74ac2f29733cbc066d2ab0536a99be7ac5f4444ac7b9e3d11c07503b1e793067f144553725f18b91265b2fcf836fbfd7f263b34c7c43965c5c72cfe781953621340f4eb57c66d1ffb4a63cc3ea52019a60bdd1cc4be899e787c0648ea74662e346268e8c36b8eef8f81e86432ddc8d3a16045f2c8d790bb9c84d35b65c5947245fc92d234fa66e06a07d0f6bb51f084071f25f3cf352409d817c41459d9ae0c5943a5222e0a0accd0847a48ac040524d162b36bd689bd5dd7bd955d2ae4f0f1e28d7af275ba1bbf26441a84c62052e9da83a8f353d7562450e54eff880a890d9b04fc72663a54f4fb5200f848cfd96d13f9e575b3b43b12a3e56cab8120981bb0bf6c4a14f1920093d140f992955baf59d22a2e2607c24ca55733607c068a88d8d3c132353dcdfb2398c0ae86ce29761fb25b71b6822c4bda8a4078d47277abc8ed32edc0c0131ce57ab0e403a088174beb9df41aa26470f93318997d9a120c30a69c372adf1f10effb37b482c3e61814830298a2260c24fe388e841a60f544ce3121331acd75f24ac64af1b88a962448dc666c3574f110a28a7428ba933dbdb0fbb2a1be1b5029c085ef029d6456ded7f0da9b49bf0058f31f60f27e85eb79e2abb1cb724bdf22247ac4f675a88e6617dc22385571d50f573d1e5355ef857572ec29bcb050a71346294977fb50af71ec85028e6c8fa015fe30d39a12152e7b6939939e9fa5d7fec7699363dc97b9d5719f33fe9d20a5c97df83f7ecbfe0fccdb61aafffc9614239c59e9c99e19ddbb0566c03ce17aad273c75e31a196b6f04572cb747abcec50ebb2568bfd970d75cc2b9479067cf9b5a0cac664a8a55b172acb26dd5a475307a41db57b5d4684379bed22a8b6fdbf7415d88423632db93eaaa6a6a6a4191ce55367c5c8b29a4abbb411d7f5b8c666a7326c9671c8c45b6027182900726093ff96e116b3c2d7775208af33203ac05aec4e924ace56b31da8a9f892e984c56c104f3b7e030e912b3215c8663c1a8a94b511829e8278111f0c9812b4c14388688184dd27fda7ebd9fa75c537251d93cdc855cbb8ae403243d11584624fed02320cee6c6c681a022edd6828acfc138afa993c1f9f34887bb8f556e0542515082eed130c2a4729924fccb0e80cbe0c538bbe5569bbb27c1af747e410f6ba13e10c32d426583be80065d7d2c021071ba2dfcdedac595acd7ce0e7b46ca9e756c2046c9797700cb380828a40ee89aef6a44fddb64ab21b3336e9b25a7eee761edc4bc8ff620382632ed8f5af6eb7f5f95eaa56600322db182d10927aa8b0b0b7077e4277ee3ddaf1d67c2efa28d5a88e17f4c950e805238daa2dc8a394fb5ef460eba90e498d1f7a7176eb0d6745c7c485a23a42f56e666c8ff89fd96df26313226ca3c9ac88aa104634a3abdde04d60bfc306ab7523b511ac3dc3d2ec40299b71acd4e7dbbe2a5072b006fff383644d2ab2486ac3904271e4e841b26c7a8f80e23d3dab803e57b9a2452c7ecf275c00e6bd59a55973ab88738f57ab2c5485bcb6271bcd7ee1777795732622623ed94950d43433a7640bb9a679d2ff28f3e081eea01e9d746cf72ff998f9c09e26814137eb71476be646325a6247a876bb8005e9fb7f274d220218fdd1f96b8ae7b075f041dcf469b18b3d6d98f314d475288cb6ec54965ee1d73f1b2ec957675eac2649439b2a7051c60b8e8b4abe9e0897bf50e23b7eacffc6e93f5d6488ddb1ea675960c8a87825a519b069780b7b3cec01957b080202bd2a76644316036c558af539aecb34f6b031bd05c8746610f33b9973be17b55354f91a6c1eaecd48d5a10720d3ce364f842b56d4fa0e76f7c915b1d1d625a8d34382ad6bab5bc162b535c228263a8faf7a8e44d8dc7d21e5433aa35d95868d4c8dc448d0442d82fd649bd06e5d02673c2bc6bd8e6a54db585640435bde789ba4fc539f12720645b0fc4f891db720d83a484d70fabd201a13d3eab71ba730388fb6084ca30abc3d3fac70ad12a8db634c1d23b6681dc92cccdfd608f760d5ae6f6d07e9d93cae9245c5d35d862113d590828dc8318e91cdb15db5f333ab98291acfb3d161aebb2c9e457585ebc343ca44ec910f47142db9d8f4467750dc082641f78843dae29ccd201e1eca2c79a69be4c16f5f9447e323293494666f1dcd9bf452f235b6be787498c9b491671465c2cf15287a0704aac80163e539bc996922f0aa4c353e75578e430ce6d981ef1b6026c16b797b9dc4d6ac4509d61c02da0f5ba1973ff01fa85315e5953904ccc23ee059c803105a3eef9f3a5d65fd67cd3cae9c00559ba42a96767832d8c1a5b86c4cb1b93894cd5062e810b0bb205f7538bd06886ff46d47147759660b45ab6dee81e54d3fc15e6f99ac00fe096ac660ee66718cecb2ddd926cfccc384ffde43cf6677ab276ffc25a4e428abfd90dc5bf31585ccdef4ef5162e41a8ac04cc9e3a702e625ffe6d28e3c28721a8bc4616200ee937029b82378bf16b909645908fe6b8beb78818416b2ccf32ca2a3bee5e7d4f5548d6de8b592c260137a634575897a51811806012424d38de0cce86cf4cd1916cc16f47c7ba9371a27db6026661907ca95e136ad9b2cf920f94f67a59221a1ea2c81c43c6c051de5f349d1c63942a13c9881d718946d47c6b4178cc4ac97f83b34ffb1909bd3026d60b4998d42b97d66c020f6e4022c809bddc0461ca1a852d02ec67484ac0afae044587c3cad204de5675155c01aba051e7e984f047806d7e1b31f6b224da9827d77a4cb60416e389a7571bd59d742626199ba28c9b20ab6c910730df4e9831e40f60d823bda9956bba26d8b1294ada0a1ef0b24efc3202dead3a8d707aff645b2f64e25360c7ac23d2e3b4fd5798353b1a76cffa2b92a1df0c300a1ba7a46ccc880811bd4d700b49ddddb7b4945894ddf82d0f85f7f48fc5439255d053e0544cec8126cd96b036ba1eeadebb335d362ac7eaaf670cb4982b4024599eaba5111e4dbc45d9fe8827e01843f3dea9bee320989879a34dca36f66a395337e9a4d530c714f62973ce722a82d715a9fa3a6ae76eba6c6474ee3f7fd6084e45b778f7dabfa8e4ba7eb7e0a93a452bcc10e7244bf73648118644da4fef2cc1b631daba5804443b28c98f40b92b7425467f0d9c2ed6b73acb17d47dd38653364f3966f6cef07d00c5849645d37ceecfe63dda6d553566345f4d481f9da575560b5f87bffd5c51548fe98f6f977ab40f9d757cf403f36265175c5217bef5049f86b187286676a2bca56b2ef8c7949dffdd3f000765014f8e70f3864d38910e7c507c64cd749d3416ab7823444a4dc19b6a8cdb509ab4165e748aae4c8adb93b14894bb45583f59f20778a57675b75380579d581f7908b85e443461c69ee9cb027cc78944f625db7999719294a0261675e2cd821bba800c40ba6a7900d118783168148456bbcae151bd7c5249967e4121f61d30fffe6c9b46b42d84dfab723f0459e8482575c3408d83186b586258c8aa638c4008c80155ea513b178c44df550c6c17a07e5e9e6560d8a846e2173f2b1ede23bc7a82b5dd4b568c72e6def65dff186855196335847595bef2d7d83c2850ede2410e67d0cfb5c34ffe23c3dedfaca47f73f19e6b1793698b91fc966effd0b3be489dd09cf6f48da652be7a9f6e916b9352d656962238c93f7c49456fdf5a2ca3e71a4e1082087f16d479f1ba0e3326bcdf8c890a790b42cef88ff746fb928d872122c051ab5add574ad7ab9098d25d8b32dbb537183548e6cebf45760bafbcc3e68a3067c1fb19d0bdc77d4ef4bbfbb53711cf2e7c4b3943178a57ac9a75620870c89140c191722da234f652ebdf8180ad62d0d455bf900159a5a889ea34b71adc9bc86499ed0da2e68f86bf9f5d4069124d40c539ea2675e7830192560d21ad34b7c09eefce9cf389373f4a7cb71677f02dc7879a5b9672d725b45baf838ddd614450ef4df7e7d23f8ff08d60829624f6a3126ccfea2b30528e8417d78e1f3ebb9e63aaeb842c7b562b2ad6c8a2a0e530cb9c84352b5a08b31ddc0c75cda4d0fe939e368d20f03fe1fc946c17687dbc3b6f4b057a7a461650371870909629d16ab258ddc4e3897c53f8ad345a30ec3a32db8cb2d634c5cf7a10b523b7c9a197d294a5701bc3192dd1497aafc78a96e5ebea8acb4fc87ba3efe9522a54cc6f38f98b98327c1e74fc25cf08e6d2e3a2e68d64102d68ddc7f3be05e02ba7ef1106cc80a8f9533512387d9df2b0294cc2192762d37242b736d1548148670cc39dd86cf299bf6abdc84599eb0d5da64990b96550f3815573f04b8998ad50f5eeb5a45f583b3349d55ff34a57ee51f671d71a3bf65ef6c688e737ae9793c6f23a15a013695c348c895a48d6b4770437ac955295961c85135150fbb87b3a15f99d3cadc8de15fb21758772f38f5726f373531d2c047e6622160d182da16957c2e09798ac23d5378100df8ff3b85fdfed2aa62586ecd8c11b875c61f802e93235f11d6f96fcd5b221b23bd8b5835c6b803164490180c3cd01106287b208a54fc31a7d6c9c94683e9fe7924220ca5f21000910bf2f3d6fedd667d7d26823bb38c42d7442ca7faac536ebb5726f3a5d710221adbe6e892aec3ef43c18689c41bef40a2f047e0898eca08c57dd81a353f6b88a8b79af98d4a381d2310cf3a4a7ccd6a7579d37a9c91ee550cce8bcc8c28c1a96ee8d3c13fc2e7671f09d77c4f79cd454710942b71d2f7ab715469f9e827f28d33317f5a49de4622451fb0354d5b6cf8a3dc100667558c544387879426a469368186c3e29b212fbe76e00f66d6f9062a06a9bbcdb87116a03508b1152daf98ce89659bf7fe9bd814ec3671083eb81389f16938430cb5c9cae9b6dca45db2b22681102b0c440f7ff4113d196e75a740384aa20e38d56c7dcd89c98d5abdd7b0677bbdcdb81fd1661c45b43e0d547ba16c8558ed6ce1b4d180c34a0ea887fe9d1bc2320200459fa3fbd157ec833494bfedbaee97055719786ad4a92a564a90c2af395d2895e839ac1d016cebd3e8d5ac56d33ce65179ee64b97d2db9882deadac6b5ad21844b645f4e0175a7b586f671efa6e7d1dcc041a0d0dc06c2caf876565c5ace66df55b6e8687481b003d1c1c1d37b2d1777b8146ed5853350dd3f7e5582e0e89a492093222512f4f035d51ea6df4e8ebcfccd747c49b11f4d4a2b5b643e96031cb75f2b22d6a9fb811f4fd449cab576846b61d08e90a177a71d78b6b3abf0d45237a5ea4225fb5cc7aa1b0b53a650f6b1f07514977184ac0db895ef48f8e5c153a81fa8bf6b868d3448837fb76a82ddf28320cc4931e4c47c793389a116f3add1935b4d39e9c45b5f6827cc45a1ba6cdc8487ab7bf7a4378e11e09f18bf2fcfea1ddb52a20b2994d0699687f0d20c3876fbf62db5ef5641981e6e5d6873ef3edf01839c0d569a072d57316c0cff04049e8e947456d635592dbc6deeb977ee0f7c4e2a625fa140e7b64e082b7332741fc35d0e0bbdb85847d54ce66fc081dbe8dce2b10b2fc360ea06889efbb5a211e920e88b6d9339234ae523b414519cd38be522bdbb1b842404f530ded7bad4218d8e4f333ed8ce0c1da5807b0ccf34a771cbee35c91ea20f0c07e3dfdb08430f37a8204c60ccf43379fdd08962201994156b9df31ccf08920d63da20a9caca713c896708dbc8176000ab1448aab09ee84f461a10e2e569066e5f8c97d2dcc5eaf86cbdca73de8dbd7f74d2c47208f31d966439735c0d6aab638940b82c654949991d6b1515df506a334894671c06094ed1f12400c8f6dc3121b7e4e79e48ae2ee82c3debe42439197d181cd5409e76c741479dec2fc4aba67237d7d2eb908677ec490ca4b9d376e12d1eb57aa03fee2d8fa2050f05ca37f6f6b708e17a4c6e94311a6e7b2576d93022ab87f8e694ff6dd2b394d39f0283721784176f5531068612ed180d0fa98baea25c527a425c67178e985fb2a4caa26459ea7c0c53755b1e0367f95e4515f411aac9490e75b17f9a812d04c7745297789488512574d4e8cdf70f54e80503afe5fbcb6902dc27ab1d35e702b298cd8215759a97f967aa16a30281d26fdf6f916b14d71974b7e856d09076f1b736b69e3e0ebb24d42a4d0787711d0c74b403ab0a9f2529f74eff40d1da2ad44d5643fddfaaad5a50dd4144429433fa9993104b9ca37df8b88eacf4c4f9e0fc52230fa740bba00267193f01411ffc02a1194b1787cadeb0ea9a4c29a05c84c8fa583baa83194c0a903348648029942d6e684894eb696b68d2f0df34df4633971c0d7ae5b4b2504ea8e93f3d2339961aaa2f03af3c9e26b0cecdb544403646601588b711b1f0f97ecf08a82e085e5ffb581d2e01180c11fc5335b828769ab4d53bab5fbd2b5c9b56eaa90313a563dc49236a11c11666e912725901abc7a120d3e3a74907bf48dc8b854a9e7a62c4c9029c87c445119bfcea8d8c94b32e2ea993c816957123384b6bf659a2fee70c78854685a669af8247ea91d5b66d7083682e8a9b621ee9a16ff23e73457adf9f994e083969dc96b981c75d962d3349219720318014071b3359a497c4c17f2e47ea71e993a6586ad5a6c0c55d9430a0cd3acb47dc7f6221ae38d107071ada28949c0838c5c57b23460915e7c67362ed5c7236a7e6aeb612ce2ad7af19e300f12eb3745f7121d15775d7b2fc930fa2046285a0ab704b37523a435ef876643db6571b85c4630ac2d7cee24f3deeb9b810905ef6909fc21bf98449fc2c8992381fda13f4d277d52265d6172f63f219a6a54502b1564736461d0a73a3267c8d73bfcfd718381a80731e764e3b3239069525500996a4042d735490b1e08e1dfc7e7556fc8b17d29ffa4bdc5a30505da931bde0e99cf1d94f4f560257074f84ad58b0404df4a322e54220ae28f7daebe4b1c55c3c183ca6b63a01d85806b2c07bd853f7608ad4d78d993397aa3a186cbe109c6742e26b7d98d9117194d4db5fdeb472265a5546721072aa52b6bc4d7cc79b8807c97942849a0a41314f66a1a1637f64d2d474b87be10eb7d3e456b7de154cffe923a61f821e45222951ce0e78add414ca459f17b44eabbfdf1b40f4f9d2ad7a0376273b8bce1fb1b283b3270f177d9bf8155fe31ace45bb4cbe57c4bab6bfa5844cf53bf6ed931ec6d918ad52e468f9645cfd4d6787334201777dea5be332e65d12ae533d1949a62079bf0594601933402da1aa8badf8211b731b24ba1a94a0bc596820afffaba1d563a90c356539fb15a2a39a83eb9311dd27d9b6b5385e90c1b87bbff390d8c8a04eef6c35bc439c6f9e30d71fda6159b460746b7e13aa5e882d2b5adcec53a11220c47c8f867df5872e6248d55717da29f92d3241fee6b1aa318133ddd07f653c57cdb479460626f9f0b33721d60cd40f3cfb6073436baae650f38dd5f7475b4e65b075d4e424fce877d352ee0e92b47a62ba01b6c2dc811dff66b1fa2f8dc5d9f2bba9911b67843da3f5393b6c870c3349c35a5513f02040cdd4c138db891d0f52ef34c3d0ab44878ff0d71f70c35d80f6e5bc8daa7a42f89205611d343939a1050d57250bf8c159bed76daa9bd50fc339b884c058fb350c76affc801ddaaa9fbe2d08f09f68434bc89e23b0648f994d65bd68e76d2bb7bdc25f1e887c72da0adbf06f94921dcd4ea49a912900a0e733169cc5ab797310dab3d35ad6d3e1ed0e6c85a0a1700d9a0826b521f34cd12fe91da769b5564dddcf108384dd49ed2aa4472b11458ef3c6c1a42612de6909bc6755881ce0b2925ef96c4366e1211ec4c1752aa8cd4661394c04d4dd03a62ff11ccf8c5364cdf96f63c3b4abe21917abefafdfeeb4702116aef546997fae67c011c1f2f59c7b0f23c1204528a9f190af43ea855aa47adae3e26e08a43c43b9df21c80f2d939ea8457d6e74c5884b351fef4284b8fda26a3bfc62008514cb44b8646ec63c6faeb060d81a5c2cdd67fe5ba484fd7c4772748f0368f0270c1f13140c187d3eb4cf89a97b845de21c139ec33691e31bd9606f1f29b0fb1c7ef06a39237d8f76315a3f1225e6da076397e23b6b6a0f33055c6003c0b578a1d1f6e7455bcc5d23fa08ec1a30be3eafbba22bdab385c8252c69dfe6b017f6ada58d71eb5fa44466f3f59250e9cff784e607a2c1be42d42d6ded3429c3791a04ed10d2da416649cabeb7aab7a27413ae7a4e58172e6eb50b9d5f0bd1c89eaf3abfc126068ff9e20d850a3ddc8b06235ab3bd6cad6f874adbcdd6bae1fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
