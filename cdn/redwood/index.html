<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22855afa91560da655ccf750befbfb15506a7d41659e28fbb9549fb1ca2cc99f716b1c40de9592e1235318919990053f0e3dbb4e7a320cbad5a32f572a57d32bf4ea3a755b071968e07c835dd5ca787b29a8119d53a6047f54a187d345dc1b108d5499bf9bd9afd9284eefe5393cc87999449c7cc0b602e80264b652d9c4bda020257796383069a03e33794ed0e86f3585153a1abb35e14ba46a7198eedff58be9c1399e1636c5ba8cceb3d210bada707588062cf1a8a064979e0d354962971b36a85a74a09c266653d4780e47b8cfdfafc82396aec49373e2a8b086c1ed27e53c9359f0fa87f280a21fd524bf6f9802eb33a99bfb70b80e411fa12f30eab7020391b3819b955ae2643be83190d011dd35f5576810538fc997ff2f9c635fe0a313c93417c31ae27372208572d88d558fa7296cdb09d38c135b4e0e79160b49722386fbca17c3dd7f9b5bcf2734f075eb82613ce0b527f2936ea7668fa08ea70adb8fa387db0a7af8f4443f86d4ad716595a8fe2140c10a51c7bd4f23a6f50e8892234026e271c3e5381612b633411aa9831416321d56c94b26521a73c459a359a6db7a7f903bb9bafebe43612b90f99d9717edfefa69ce23efbd43f08e61c0ad871993f1106450bf30a74cf573a4f1924e619e2e767888d7b34f121f1ad04bf0b98167f23cb7192eda0cdb5de92b041146bae0a5e32c2095834d0cb8d275b367cc6833d007b1ea05781abeb487284c491c98e6e30aaf1ad841d8379b5aacc33ea084dfd1549c3e20085fe257b83b6750725041077678b42e5d41539665b480d67257e6174c07b10b150d6ae5279dbf43ce9499b4c562c922b93836aabbda67e047e3a81bbf3f5c1852af6f240516b391e277cf38ce527a19bba3966605508cc9d4c63b7f4117072995bfc008c689da595e5fc80fe9c0ca590255a99ae4e5ece2327e2d0d6e05cb9e42dfa25946d267c2baa791b9b2193a402f616d653ee91726a91ddb64361dff1010179a38efa9a6267b74d8f93badbff84229abefdb9e5ae8339edf5a15bde862cf46dd3799069e96d4597543be29c4bb2d85d3cacd6d111634939cffcd73cf0afb17b7564f6afbececdd98a5aebebd9706d91f4eec57e39210df938f7c024a8f9e0227e10e8ac585998282b5865c801f96fc5a18e0eb24ace8cbcf3eb760a42a61f2321c651774aaa178a2162bbd41f5b07977e8b63ed79c73d52f8d1d1eac31045d4b79831ef983ad03fbc931c8ca20030200cc715aeff0a25c49505207aa70e2d421ffc068141d9f02d8f288f74c0551a466d822f46827b376fcc177e078b3f578f7eab5886d0c078d772bfc30b9094ed45f73d1b59c0c0964728d3540d5022fc50f255bb1b3e7d5ea7e28875702d2f57822bb1369cc038c9686aeafec989daf991f94f3395c9fa4f3d03c94b79db95600286df5a763e8dfbe75cff76e9d68a857f4e768a33ee8e680664df0967474b2715972b4525ba765f2101ac28e97cde77f1a331a34eaa312425c0c0f6958cb0218c314baeaa7d05e978af7736579687351992bffed81c689ec1c9bbe6ca4c3684217475d29b151d3a6926fd1cead7fc2fcc919e3ed1aca4ffc96be1fdd11cf08d09466141691353494c30ef82e1461780bf5b6adce936b52a1b2978c40f520fccf2e9c5b315c88cb983b1b80cea8b00d4dc5f16738c8841d49c124a367b2ebb6346fa271bdef7bf103f4958b659e538c6439b5108b383792464614e3b5cca3a293ab28ecf197b7b25380c711a96f080a0b1d7220446dde4689cf8007d514c577d669d4e63983f89b3018a504f3c681b57ea6382e91abcad3d26b87b3c6da102add2cbc96e94eba9e7673d697e048ddcd43b907f10c5b863290d0bc352c9efa7c40553f2b0a7766ed5ca7a4b27ff9b518930fc3ee4462beb80138f646e9530d1979bc219db15d120fd22ebb06817aa64cbac2ca07eeec6a8445756ab412e3c557ff18a0fb71307da0cbc04f07a864a55edb9a8b5215b064fbd87095e682107da2d42ff75b7c2c8538c6fdd9b3a49c80922a0a6e4aee000c08532df67afb6197363d26076c9e36928bd6916d9e873939e3bf309af06bee465bce041f2e4211140df0508954c0c0db81455917bc200f1768d83090b6cd3fff9516b5824418b4d2eeb9e27ea5df8ab5cde61738ae8b92c4a70f655f183c16bfdea0ee4d962a3ff08c15c716003d671da4b94be04fb68526da7dfaf057e1221c94527b86938458d22d4ebaff81c21a2dfd91fb5b3253a7c561b66f9ee0a6049113a3e343dc27b6d340660e4fee77ff8f401433e563edd17eed26009c34a306e10c10962b76ad8d1af09f898dd27b934dd0fdb1fbdad7bf10bb1dadc2b1f925a9611f4ebbb90b46cd5430df102cbc6746217da77ef8fcabdcc56175756ba559303e5bce50008ad29d2251a18a39bf97cdd401dbb652ef7c343bd185ddc93d367ae4d32ef5c56d9e75eff1d660721e6109c45f892d8c51ebe88a498145a0839c7be8d1bceaf81f3c0581d65c0eae35daf2fdf32a5a4f204a8cfd5e663d73db5becf6ef06da71b930c7817dd9f4d563af226825c8f038d444e2f745028e2bba87feff261045020a92db46acd9fb42a06005c992790785b484aba5350629c0ccccf65256078117a21c3bb7d58443542408f9453428cd2eaee6853ee919c24b93a626616f57ce32c7d97d8320b505ed5a5020a220b0cb0fbb2ff7c9352d7ce733b391404e38901ea9fa75dc6b76c9fdce8ced1434b18d0138c725d96b064a1e24d3a7d997b4620b747d3727dcbe41e882e02fdf3388acbd7e15d1639d9e947b8ce559f3a3d845edc856128d5d8ef64207fa0f224effbd4a01fda6ae6f6282c67f8685cefe3ea3711afd922bca60bf878e327bc5aa20717f4f2c238321a44b4ac1b999d8add60defc8b3eabcc0a8e18e6711581c66be6c444c74641d01322ca24f27c6275d3126406c2ef6e74cfdbe950610be3b57df190cb1aeb8b1f4116eb5ebee259c055f3f9c197ac4419023403f6168a4419939e0728c2b76abadec2571a4d485097c3c038d26d1ab09cfb5ffcd3e143a3125a8930161750ff0ced5adc5bbc41f541768433ba295e604a3d3579927ae377212a8937fd761f6078b5b8119c124982c14c2172e1d7fece61c4d60eccf6247990b454cf262dc3d316bd13a027cecd704c53abdc009dfd5a9c7d245a7fc61f52b56c6dc23d970a82b7c550a9d2de77d438292e50144775b045f093fba799ed3231f9749b93588fb75be5bf670bb12e425f02ff2708a5df0e2139ef796ae6a1d49986e8ced09861a908d54e8723451e48292e13355bd1d5821058f59727941000701516400665f0a0b5d839911e4109de363fee2429c445e4c1acf14a8fa236a6dfa8814d4100e14e6cdec98aa66c38a5c2ffae0e6ab46d8297b5c63b389332f1c38e8391bded6bb7103cbcc46a80a38223747a6fe1004074acdd265fa1b682a54ea2417a36512af11043cea5a9bc60dc39e3deb8843e687d3a55e51dca3ed4c965cff398c7f761d9c430f97514b7e1f2504ea80d14ade657ec195d468a36dd386dfbf1bbba5d962691f309dcfbe54ec258d2b1447cb19b1dfd0f5357ca7c4c9b8fea1b0c6321141d72bde1bab06d24b0013c08d63c23e098681bf3a86bfc8b1f994616edbdae963f8cfc3f063d5c9c6375a2642eba84b792d4b97a7e1e0d549c5f0a5e6e23792b245ede3e0a266ec5c745c0b593ee0e958b71c7691e1db4575049a954d131704081c0818cedb82066147470038165dc9f4ee5d27b74bb083ab420272454e17aa505146a8a7f8a4d3daa86e398f16589507b339d981197b08372d663e3ec520fde6ddcb238c5ba7b8569086c4808258dfac276fef415cf20b0da9353d7244e5f7e27141575bd92458f9ab92e650cb69647c718ffdd759b9aa84b6a11cea0c856cf5433070dbb6f8e3efc58211fc8153d52b0b0d5436cc9cb631ff950f9dbe8b8add5b466e739c92e7a8812d8372df98e0233e9377058598fd39fb72b607a9e2d3f98f7edb2d50be541351bd86972ab75c5569e533b2d6f6242b9202bd46131c93450f65eb9c3b70abc90ffca5ae7bce6e765069a92ecd375c16782860d5f155d487fd3c1aeaca0a12680b04c8420f4612445c86c8275cb64b5a16168aeeab0bd7ff18d7fa48e6143653c40cc7ebeacff6d2ecc2efd78ca1223e315320887f4b39fa24d244e6ae2e9d790b6acc17e4c18c6476b6101b6db514f0a5067b7c538646a7d22e65ddbacf1d3343218cf2d1e1757564f0be5e45ba5b28fe32cd05c18496164fb5928612767e6efb5dfb4ba7b47fe74cd064cc100dffd848b152c9df4576ed6385a278b138ceb07e84fd1036794bd61f3750a79f9079467483dd8dd363bf340686905afdd3822bab73abc8298ff031653696c5b2d18a0efbdfebcd4b12a3a3d1fe7f85ce00224e4b3b468a056f4726cc112d8c274db4565f512125fcf75204e35f84ea09c9d0c642641ec8d6435181187f2ad044f572b44131f8cba51ba6b6b3d8b908ce353fb4db652db45ad847aa7fa1e555c7ffcd50f5dc1f0f7972ea5b3fdbc193c0efb75bda96e178ee4448d7f45ccda689e4615b353f94ab1446460873e2c024fa5db98b0a759735fe9fc809c7d1d3de96614a45455ad65e4e8202b699f2ae3e4c2d205f781198678ea4cadd00d0b902a58b25e3831ce3d130603d9e1f512785020139df368004e20d41cddea24992796e3047c7b37dc6369174de74f54fbf5e8c18f7403f223dc10f2b1c9182f9605162f8baf5333c658ddf08874d2d2ecc598da09c18fdec8659f6ee9a27c5c59da32c0515b812656a0dd26bb2c71e25105ba5a85aadc8fc4271318fef38268e379d05eb1c4b51e8602e8f82c8ff57d42e5b2d89fee348ab17066b262638344782c30bda0500970c7731ae879056c08cad534bb4bdcc765e871b9a523bbe10fc8c01ceb1453df8c486f247189e331f48ab9cd430d0ef9262a7c39cbe09df70d0b488ce758ed097558d5f5d095d15163ac4bc1aa87a2fde8d034c08e92b2825c16214ea069ba81afae06ad3b3ab5f9749d1ed19dcff1202d99da86d485ff39b5efe2460ed6d7ef191082fd48ca184d54ab87ae83c03c09ccc9b2103dfcc170682246bda2c2d54dfc64bfa8a665e72562771e2eadd27c8dd9a72f9a68548e951e539bc17e4a5c6d1d5ad16310234bfbbae07df1d4b5f0c7ee37cd17454d95cd9054d2c66fad510efb9b924c6c1c3dc7730c931f01b83cb791133a94ee1bc087d545b7e74f60ffc1a32651d366867990af65e35f7f9d4563a0485f78826074393902f8d4341a982d970b94a4f1539342332e332e06cb1ef29a889de0a6cd7254c752453aa8afd4960dacef6f0ccb68c46e7ee04cd9100b5289a2b7ba18ba9b0b196750c6422ff065e1dddae55ac1cf31f4a5a020ef252bc5d2c576295735255ee240b18be172af9147ce010844db155084a6760e9962f56d49b998296f4e524edfa70b47c279d63bb2b1ff2f9fe2c7141f386c0023908c26d7a439cf216711307a08d1006c94210e64d8246181096bc0c5110a671dd2b4eb2616d44d42168390d19d0f5164dceef3c46b1c72ad1fa7b22ac1c86cf9d282cd1b6327e8cfb96bf584cd0f355f7e80eed0b929046cd45c65eb0868027e8e44576c630ee347f31c23bc433259f5801d11da8886c351f773561f2f5ba2f556a0960ae312c98d3aaec8ba6f16ce0431596f396a64db7569a349cab144e1d85c6c5b424e56f0c32818f368992a74291b6519f1416ef5957c93a368bdaae35b5fcbb1d14207137bb01bf7817f51733bd37a960ac7a82eab3cb63eb0e913f283465e3eae73e1ff13090bd072e3851ed70e9fe17f8b3c838dbeca5aed8ff1e5f7a8d5ccf7342a26b4c7b55e8f916e976e129eeb67bb6a1f72be1224e230666e6bbcf9dc5d9266523f4d1dbbba9c67671d067cedc77c5e117a6b5ed2bdec4cdba2437602c8b2cf44f2fb0021b8c89063f363ca611e0320863333ee2e8ed9cd34f82013262704c46df03c71c26e80157e7988c8fde60583edabd8d0f2f9a73818e111330b4ac463d3742fb0c861c5acb1491aa4190440582ac1d7391891d2cdaef937684b8fdbd0cf056df4e2ecf7c714e70348ba796f998d7d83b7f7dd2ed6a06e7c504b01dbb2edc0724edd9b41f4ec992d191fd69966a400ec487e9fc8c6738641ef7c978f3b384c0807bc6b94ba52aec692ebec48d5bce5e545b7f6e2034365823fd32a73c1c005de9c4d098a5ca4d3fc82d748c45e0643de77b271f5bbe273f622046f9a32281d762089173933b8f03066a7a200ed5fbf1df819896177b3fac4d0a4fcec754151e3543f013389c133103637e8aa37115bf889a16db5de73a43141fc6c7043457b31c585cd78e8c0947a80eace71f381ec2b92f60cab375449a10fddb0d01b6b451248202ac16477e6fc320f35f61de1dc695a1fdfb38780281901826a90db83eb15de226dc7d437b3066e6d52ef7532c06745e9834df85a75bfaf8430e2ad75287bca6abe69d21b19a8a302eb2e60a4bf8c5d7ba2c9fb916493ef03544ebc26b24f6236b21390f44f6af92922be54c3fc25e33f2a0cab65cabc1395c3968d886237a6b84298242d063e5bdc7b7a066b6ded631548216205d3cdd84684dcf4f59fcceacf1e47883d4d5cb3556b8cbfe5623cef94ab2510774674319caef0aea2046805101d8ca5b16d940d823d77a5bb68503d9dfbc610891008c8519dfac32d9dc910ac11398c631ca3c7325505d42a255a7b9c675c5361060df5e448706aeac0086b36fc5284dcb76b613a12b34ffc123843a16a602914998daefa732fe19e6227fc45a8bec968712517f345d757054677eb105f275299b74e4439b24ced71672bfa8c7af76ac026c3743e033425113a67e98bd443aa6147f2e276d69e9e0d46b48fe2e19ca1fdd05362af4474134b9f2b93816a00d0c4223d1a27d0e32975d2edaaa79f316d087ac980209e917ec005a3aeb16ad86c2e76f9123b29980d86cf380a613c0ba965b5bb255a549589e96a41df3bde66d96a41a3bbcc68b166b42f2773c006a08614929516ad4636b72074c6c245f05d72a007fc5d229eef1bd51bf69857ad3118545a7e1343bcac07885673561d43f997bfd19e90e2ab72acd76d973111a59750ab598016fbdb0477a65545782b12c0d6f6c581fcac1324cefbd7578b37c0b3c9e2e0ba9dababe0bd3ca2b8bb63a6f1a2732b6ada1b21451074300629f6a152923d3070cb591a2ff6bd1a7c448823f7a1f865a1b12fec0f1b6316a1aba2ef70f1eac353bd34abd43c218e2c4b0bd13f5becb97082ac6bedc8c64c88f22cc742f1c7bb462cddc894c1d5dc23149409382e898ced8777443b22b014fa272aa63fbf8117900f37df00440ac447744454d0ec91bd4cc1a8aba84c0da4e01f215abeec4b00c1e12e851670af56ff41d193188aeee71aada5b500bdb5a2382918286918702df065d07893bbd1e3e0e71d1ce3990149c55e7812625bd8e3ca0f560bd8878497bd7aa476e919f850c64b4467fea56f33b2e2ac4b717a2f11225f90b12a743484297594d6b6501948b6652f5cb1ceed2a7450eb8edc93f61ed8c20b4f2076baf303a4da0c86980f4eeeca7bceb8f446b80a9d01371db2d429d2c959db8184689b971de4b094d56b065a04ef1628c94fbbe06eca8d52ab0b0484302bcd9b891b7c9cfdbb1a380d54f9e316a9c4282478f26c1dca0ce7d1f9e9015b27d4e99e4b9ed4fc4489a6f5c044d2962c85de8d9555fcc98df912410bb0cb5036e40ca57e18803be1345c44fc4ee53f1693520f98d36601813e0e2360e93da8840531ce9d39a130d6bbafe5c5ae5f3ac56cc15fafcc542046ed40f0b73fe774f9716b1804f5c2cb1384030f04c55656d10a1dbef7598ff9fc5aab5f7169265fc6b74a0a3f4375915091171ea59417933c3a9462d73a93391277dd8033e6c9dca1129a3534f437ce05b6b6cfa1ce2a3d3d57f81baa1d1ea6064ac038b3914e1bc6f405d60401ee3fb7e49f67de83f49f84914d19bb50c77faa348389f67cb0a0ed00067cae3c0100c3952f1799f62b645d25cd92b01e7a039c8ec3c9aa812b2ccc34ac69b2893d4f2c21d58b8f0e2dfbef7da28b55aa13a4321232ad2d2b2273f9782d44adc518625f7ce4f3515f4ee6caf8d0019cd900c2645874f5f3d11321b1538c2dd24dec14193f28cf912ea4b576f7de431a88cde5ccd8c233da6b1f56af5f8bef13cfdd86a5404c604d2911ca161e6d07a6c83bea21f633d95b5dd9e0522d9272859fdbd7293192f0cefd5ab07f217d428326d94cd8a1b73802f25b67bdb08200f8c2e5c748cef6fcbb8eb10f8201a33b13418f8e805568fde6eab39c2b83d6c6908986f1ffeba1fe7a93855711a82a4fbfff6b2bdcea29dd6adfd19c4bdc8f863cee0b2a604d84308208839bcc9d5021d08be6ce6b6832107e7a835a0e141d16cf748ef30275fe18a09e8bbe841ef93bf36cc3efdb39abef55fdaa3d400596f47bbd6506c5ed042e1c38c0160a4b948868153cdca4699dcb7b5a1ca83a2efb61394fe823078b5e84b51e40f6879c05ce6385a9731d1805d17791bf8a23cdea1d22a254f4baf59dfe155b63638aadb9945bb1531508da7fea3769c67fcd1570b5d4441167505a3a629ea13bc77ea47e58b6ca2fb3d8b5cdd942a77c64781f7755e663d6c5fc9a990fe04cfcc22938e77289eb325972d1f22cda0af30d74f3241705aaee4a2b4ccd3b4ce0af134bbe0f8ce1ea3e8afd237195a1c5e0698833dd6a21f8af7349510cb165bfda8e2ca63a1348f874292682ec9b324c26ab4f3d0a34054b12fc8facbd4586bfd94aa9dfed2f8d6f6f58146c3c31234090915a42e092b47dcefed62e5e4f3719035924d14c4fa59226ef6bd3a0bdb2b48405c98ac45a298c0fb0f2655fc25ca9c13d3f36216d5fee4d0bd7c7b81f6d21e8e71aef8445ef212f37020572f0c01b9100531589037192bd311900c09ce076f4eae340f69b23d8636ac1e04dcad5e7238c70b6959593c166d582aff1820e82645dc460bddd0028bfdbf3d853bd919165cb51ac4f669c19d1ea57a6419762488e4df0a58de67ac9fd70f5e3ee5add6877ce15942f1408f3a712157c7d7d02358a455c3f55d09e71395c6355bd22e7427a2e7542c94b56a2fa79a03f75b9cfaf377fae8a85e2985113eff0548e67b5c71be40da4f60ebf70d04555438686c515778fe101c47a0489f16d1d6363443324366688a0b3b2307dfbf1e197a765b23f4ae93a6966a7eb38a49dee1e300132e43898bacbc5b456efc74637f2e47f793857ccecd4dad6834a0f90a955e597609ac4a4587883dd5a9985cbbcbc2dd7f7a9b4d96f86eec4c7a5dd11186f010ffe83b774db5cc9cd6b10a7978fad3458d5ab2d43a01a468b866ce6a4ca9fb7c701ca6a011d09486e0f6d99c0bbe4da1768a495940a22010158524cd33d052d5901aaac6f2bf30953146f48d0df48eb5793355f55de0807bbbae3656064cda2af3f34e46810f1f31666358b08b8f1bca3312d7ce226e17486dac5b70c3b6eab1952fae3b5f09c77a28948bf270820d1bb3f6107658a8909641d76acf4407dbda33b9aa7ebe96a9cb6ae122fe3a0bf21d083ff9ac8a6ba8bf8be391c59a3c2cd93ef6a2ecfcac583a1c7b711442f56970c7806addd335920d1f0e6aadb657a4db96cb2af6b253b9e2897268463430bcef7ec5d76ba4aa2a348e5597ef4eb57db5cef88e837d3f6aa8d1ca0f02e0d0efdb3a7504ae9ceafaacdcd4e82c6d330ac6896aa7c0ac23614f2223a722d1a9beb6b3ea382efbba3bfa624bf76ff4daccde0daae265d42f0098df47c0c509a6341d5a610fa7dc4ff4e402fd0fb77f744c2ba574af98e27e3436f1c86d0d7bc31c137e86932dfe5eee8599d9b7fa9a02146858caf99ea114319af8273c3bfd9df9847bbede52415748f517f7ed8c7ca3d977fee565c29f676c65d750e71b9df8135ff5ce45f9bc8f66d6cd17d07c08e717a590f7cd10814f25cb5c2e3c3d5daedbc2064d2d73104fc5484fc295c75ffa2e74d2bc0988b2f91b3137f490152492b74eff5a054cff9a6bb969d9b2bf4272355eea2bfc1f111496b81c853875c50d63546d543e209b1f4df2859a6373fb883c06ba512feedc1f59f57e5c1853207de0f600fd2843b51f094f93be5de2d0f7eecb58f899f2f2a6ba700ee3403a6f590b3cc0f07d8effa6b64175560e526ee738e33933f93296e788e873330f443bc3c7807d12570574c14abf43aeb7b9d720d3fc8dffe7ccece58e65bb825b4bfc41c7beec2fdf5623a06682a2d9a91b008f6d3e7f27916dbaf2ab0bc0132a01449a6185640ec03f3295c3b4bb49c69101065cc3b371fc4f2c3077d875d367ca4308d59ac62fe63c065f9a82414824f5046576b2003fcc6cae5c2877f809cb9bac6279813472c462f4da862ae27c4f5826a73fe7b0d5303f0554cbc3c91ff5a99cd154415df38d0ce3362494b06aaacda82f61f6b34026e2f2b40bc0f9ca4de06a25186f7c724c7774af04532500b17f9d1a911701df1d0df863cfc2e8bbf23fe7bc263e593b723107f3540f65d099892ac40216e764bf9148507c393c18ddf378f06d6dbde2538674e7ffc6387e4143494a5b3dcbaf109f754c26d5510b3c709bb100107d7a1b4166acc80666224aa0dbe3b9e55c6ff5956ebf022fa1d5968c9b4d369e1f0c31e03c8d9ee6dc04d0e3f812bb34fa85e1e7001ec27b5507875d3818d2f3c57421c72b62ba679293770a083662032aadb41410418891598b023ff11e50db06fb7665370083f6ba22cc811e1c4225f6e7869e940625b7fbc074cbd9f3b6438ada9bb154ad22d4f333d6c287b06ba7ca178532557a6c9cc0ba1d2e88be583c2403fc5747bd1f8460c92db22d31a6d36ac862167a540e226bd601345685b45f7f81ee667cf9917dad18bd91e2082a7b6b05457081a0cad0281fc68bb4628a9bd569f8ee05663bf0321f75831bde44a761c479b62092a807846b9778b739e2db6cf2691c2553e8a25ae2ad0a83f51e57faeb1c9cec5881653627e5577abdcb0517fe3c2b48598728c368fde97df9fc0f774016a1f8be6468919931face84fc5b85456cf54e5674c58cc5c9074bb044515dea70d9ed4da41223471f669f268b197f09d1ce81cd80cbfb5241c19d6695dbbf50904302e2a80e7711bd3ede8b22d79c3c1aedb6df7f569a8cf4fab6e93300979545c11a61c7222ad55850a2aed9e21c332fcf4080f82922b737ff8b3c2259f4d3cb7ac8ff8316424321dbebb15131615aa2a5874565b36080f060877eea94f53fc0af367f049dfae4027e3beb4a2fcfcaab6f3497e05d59928f310b54fde01059d494b82376a55f7c4dd22ef3a6b2177b2b536a3e5ecdaf722b2f523e10289b0a40c9c0234df0bb75c560eaa5c50af312d359bfc5c8b7aab57b1c382046266f8017439a159e6642b7d60098313105f0c82c1578d7df8a28f8c42661877ae795c69918ffed0f00348cc9595a9246bef7534e82a2206bb48113007fba9d6e3b21e9435e9fd259bd1fcccc6ef440a1392e854f5d8159b001e9cc5aba444daf1ece81123fe88d243eafeba7c8618ca8999d1375661d9c773e32cba312d92c199f11a43ce5bf27dceed8975f56a3573c769c5a868932df266cb01f0a8a1e3725649e04403f862402d5b4b00a79a07a4968a290f4392660efb2d3bd5fb0118ddc188f029e56aa5d1b7aa1720c93a655ea13e40f552dbaa956dc116a0c97e2098fbae80b2da075deff1102350513cc99fd850315c461fad1694e0cc9d41af692d3c0cf4159b95eb511e46a597bcb063f6cc713f5749cb77222a976036e9cb6bf47df0dd2c533a90527c93abb6f7d700fdbb1a883dfec576d03ea56d3d505de1a7139dd5a217560748c09e6756c1022c1e0479e5d75195f403b4cfff008e7efbeef293ab69d01b171c2de3ef38e7c47e9f4e65d9b82547f4bbea4d6ca965bb4ab247c8066b5e41d5b95ee195d9e3e8a04952defe1f83c60a62ea7a1c57ff90a683a1b8c225573f82bd152865091a00286a26ac8dcdcc2237058b0f3f8f4e739508ef61b1b45bcefe61f57537b3ab5153f7d065a72690d9f7c90647d4f14b39b2625d1fd4ec4e835bed5f35ce9ae5524ea2ea3e9bca4e78909e6a10219d8d8bd458971457a41b9803930e1c806d1975a4d2f9819d6beb56a9d399946f22178fbded481bfcaf3d891e79e866b01df1596a8ceef14ca47670d0aec103f4b61bd52ec538d2fab0e6b55a6ecc64e76ad4664c0294122db2c3ba953d96d0a616914e88b793f4cab548b8227c217900fd584e2871c851cc3fb0ec18de274615f9f95b66be80316fac386fcc6b5d41385ca5ef6ec3436d324eef231b7a7938453ff2a6be9d17a2dd7a2a59a8b93ea8175705f6318ac2994f0f92781b28acf8d1402f1866493f4fda434a2cbb2cdf2363affded2acda81e6277cc05c0baa8a3d3b0a92b75f3bb118f29608cc52c86d8c2c66f59f732854d526a17d00049e1b7b882c289ddb7901f19ca57abd85143b3b9566eb5a92b977f360fb033a5a8dc2cc54786c507948e6072723e63751ae0fae1ce8ff8e1145538aadb4d266ba77981f8686f2fc0cccaaed6e584354120bb606f852f88fafb651fbaee8f18588a3d3bec727b586e150f467a87f57d541f5dce41ffc75455310c642b0d874e7bb0372cc3c4060b7c2b7b9ec9ebea96f13bd8b745f9d81707a93cbc8cbbe928c0280d68126b51e8e51c68fbbd5b2fbdb45ff1069c64be351abf15c077a21388ef361e7f2e45cf7987b7b089f56af92b13b9a253756ebf14000ee9f7575cf0d9c963e56a043be412c534c8168c317563f8331a96ad4186c437e7a5abd80492d5ee11b4c2a1632c2b1357525ca090bc09e9dadec096035f8b53208caf4f3455e133395f2cecc8870d20b202bdc9da0885e9a9cd7eaa9eda3523660a5b4e25754bbd0f65b0ce2137551f821b3498c704e9232708401e204c1e80d6714be00042a86f94c564c47bd6313bab1e0503f5742f15e4fcd74f366f9714155639f2591c3ae8f0fcaefa3b1a1d37b50b0215d120679ef9e59a8c76e2429f3f0754a26187bde33ed929e5aafc6f93f7fadf32349e2d66211cd499add4037f93e58dae32bf6a9e9ba72c4c3c9bd4e7a8cb9fd0f197f692b1d07b2f914882678d8f6a1f81c32173b37e2769f26d6b72d2c647ff4ab5706c4fae32a1bdaa8c5ebb76049ee687547cc89dfeddb1950bee6b62b527f41b776641b34bcee5b745dcde8d0d25598ed1d9e5ce932e37afce1602e54e03b789676abd3305155409df576dc7147bc077422ce976f1c5b1f30b44c466d2bbab2eb95fcddd034a90d84af117dcf13a6a50090dd14fcdc78a1a487f85288c238d3623b0eadfc36e50e31b3b444094359a3f3baaa2cd3e797d7b3f04ef1b2d58b86b85b7b92321e7058941b0f0599f3dbc861f92b3fbaccb3d1fb6251b1eee246ee57383c4b36f35e8b136c778b79d406dfb3cf90c7e428160e3b4f1c66d518a22fa22da1c1f7797ce6f7f20e55d768ffb219e6754af35acd0855d082f8d0f2b1d6fd8100aa4ce73ae92996cf7d975fe77219d543c04db3c12981d56d9f98b1a661dd9628baec80a8c809a30051ae9f1477131d5bacc9effcb37fc98a1ad708d702d03d2b0a6ab47cd36d6b4f2cc4ef731f1c52da9a61fd364d5862b46a3e3f13e07d78871a43da89bae4f34aa80526249638a79ecac7bd02fdf8a310695b34e729ed00f92af2235b6f51b36974f3a12d1009d3ba476b103f51edb55502147e96b216d62e8c3443f4d1a882c7bd5d5f5d1b728b8eb72ee2c1c12206001411d923a5c55c011792c2e41f9dfbdd3dfbdd5a114e78616d9c9068cb8237f4e734f9ab233b89d024eff70211af0f5adb6edd9471938049c1f8ba43c0e5090eac6c465f50a7abcb256456a3e1cb8dd461876591fee5b8c13321f9a1ab7aa660de9ff389d1c5920c64ca8932925a64c88e3357f4d19b7298e1083e06fd9dffafc27c97b5e25737802dafb8af84c8f15209b128aed5a821bd08645c17a2960078815b20c909ce3bcfe3f110681348ebd113c46902fb42b8312f29d49679fa86ddbefdf4bc9d303e8dc382d02bad0c50e89ef558279d55d2e822e820f98fefe6f00a6e36e0c629a883df862f696a3c4e9bc987ae5ff5d3032e522b81773527c60f350d383b3e31731c7addf05b63c1eff72e7ecfe2925bd16706c67ed9aeee417003d0821c713798d78bda2584f4b0c42081bb8ce964c33b93d150d1ae500d7eea3b17f5d0127fee720262607e26ec30c4c4700dce1251ebc31685d57dde24a96a83e74ff2a74135f6b5fc55bb33f1d050c3fdea6c08fbc916ebb55347e32dc9deb90bfd7e8c21f2e933b69003200f459a35058b4467d305db24b6a791c556243d0eca500355a6517da23d11a8493d26efa347bf02547f170633c325bd13a4d91f030014e1c5b347d817ecd40f49827ce6d0bcbe5bca4e631c0d0aefd058ea117e56b9243eda182b4d94a8f6687e2cc3b0ef17475958e07bae99a9aac156026772ad7fc3a01f2013d7aee08e080b932d04279a5f2918a80a37f15f6492df39793fed425518a2fa8d76859a1cb37ca14f10f8924afb8855b7b0b70a45bff2048ba2e287e8f5e6dd813a167582d004ffcf2b0db5ae8aecfef9a4cefffc3be06c2528f1987fefbdf0ff029612549eaec02b449c670617d0b45242b36b4512f5a6388017cc3183fbb55ded42b43e6a930f220a8830625ba480b117e50708454fe1c469142823b09f0a8ba0a7bbc188cfd144ef350bd22c023b2ac655c24b9a11eabe9ea7a051ad70c5fec523058365150db5db430db150ec6200a9d6b711313a94fc1d17f8453fed7fcd4763a5d31706eec92a225d3b0b545070d18ac157e663d90c40b49f8bfd65d07c09accc942da27dbb0eac9cb0392adbc0e62941ccf599a2dfb2177b3eb7d5099a3cc289908705ce2b2b785dd36d825e0023d8a460e7df9506653f1567bd61a077f0f0e6525a98e3ca48c4b2334dcf628514c5a8efa496e101ce8de03c8ab29789fdc08c5e7d43f582aab39474bf8bc646e298f45acf2dfb51f89de686dfb842ea20edf3c522a54136637d2109481a561d88b905f37d8f113cd00dc68f59f2676074f45966b7ae1fa68fda145e21eff6b9aa4fbde187933eb63b873a0351e89e823f004fb94e093268dccb5e50fe0a5e20b6e07ce2b6beb66df291d4bcd54a08a1673f54553dc83d36dab3fd7b1e8c87264549d2e04a5394053b5e4b33e944074cd904cd806f510efdb156fb5e50fa77af55a58667d8807f22c5d2e5573f9d4e0b7d67bdebff93333d457eef172b378ab2978e1e4f258fb2b37b1fc1045025c7ed1eb6b5e4fd7daa7b8b77614de29050b986c859aa9e6ea1e0fdff6596a4d8a467a261fb56562b52b022b1cfe6148e094716b2759330f22ae8e9385475cabc02645c500f920df2a49d88b2565e6a5d02a5ea227dda53777b2bb8e2b2d942ccc1578b1023bc2f4d5aa364118b269e67df30c9f9b6eea81c09a62544b848ef8b8210c906c49b635edd769118426f0a53bfcb1d6f80acb839018e418ae873ebb6562ebe75175833fbeaf81809604b58d33f46030f82e144cec63b3cb3f44b9a3352d531aa43da211bd2ff0639d5d1ea03d5b271fe0bff585361301dc29132232a40162e8262bb41fee2b6184d7b30a68dd4b3eca3dd8a0e72f272164e4c97654ab6b6d52c9f9c4437cb756fc330d52b77de057b6c5f696a91fcba2ab8fd76cd4935df2c986123ceff457862f2b1ce1ca7a3c84d34dc2a824320b1506cc475052586f8ded64f17ba42b64e814316be3742f9a6620702862c6d6cf427764c11ed3efda28d44ca39a88363ec613c8c600faba5fb5c3bec96ad971d2b365bf90f7e5c2d58fa0579b7e2a0d8095d496e5e6ad0128f2e3432c46da8eb67df44a812e0f42b9ebfb2461ec1f009ea0b42e43776ba775e4a20e15aa2bcd24294ca71c0d4d4a54be49ec8f34f1985d226dd841dc927bf339fd7a03b5b23a906a86e0b42690ff2e7be50102e66bdedf727168fb6d8e379b79a9ba5cbde60e932624c3e7552c451f50723e400c254bb69e984b0083543f7ee43df0930862006385125e18fb2d69ae51d33820afe162ce6c0022a7252acf6f798b48f8652d481fa6f3a91d02f07e2d84bd746cef9e4c2f892f35a1cbc501fb5968eba55d41f800f66a60771836ef6e9a0cd6fb08ee0832f1058b934f68ae78eca2f4dbca6c893da33086d86aa9bbd37f1e180afc1a1f6a61051e9c8ea819089c578ec79a88fbf1783cb9e4ee7b8541b3b17b505c3782f5f51bd3bb72d5b2dbd1f011a21aa6ff4f5fa88bc42e12c7eeaedee02251922e890da4828ecc8fef88cf4c80d4be98bf16ce72d93dbe7e5fe64fdde639aee7027edd962c1568420a66e3f64af8552b05a9d1e0914fe042c35fa4c5d9ae257c30dad2b2ea958f1a33d8cd64ee46b671fb142e25fd7364ae83943429e516632f2d5fb70204107e9fff26bf7766d3bc194a9ae5ae03e524993f33473efd43eb743da7bf97402185174d7fd2f2ff9e4cd6d99e349b4654f460b8b4a6673159f962a7a044e354062345b875ddde0808034f38df5823b0bd97bf2590f2a1e7036bef7b97831e35eea40c908e28ac41f234f30670147efa08c9c873315504eb5459006084ea0c1f85e61d87050ec935126fecf21b38662d20b7e3d560be204fc59af3d9dea9f184070be637b16bc468032a470b84e02bda1c2f2c348a76dead183d5d17f7eddcf30450427eae7bafe7b35a57e644b72a1bb18ed58954e3cf258d56505b610e237a207a252a419de95063807510293765102a24438bbbd7b6b6f4a236cd4f80315cf3c8608f4d828ed183e832395847d67ddcb048711782497472a657f802253086f198a69e0dc6de1553d182f602b9ab8ee619739d7fc42e0d081fdb91bef72534c4cf92eab3813988a3d9ec6d289d0bc0eeadd52d2c563e30b96ab55c5b3377705e7c51373034ca5408a0bde908bade765811721bae36cc1d0b87befb8c36a9c1af617938afdc9328508613da220c6fa551990a4d62903b109f0e363d297cbefdc32368e17f7a6b81c8a811a526c28eba82b6501ea72a396f23b2f350921d9a53c3c2a2d41df872ecbdbc860010de1da7c57f06c0eeadf11f25acc7ac000bb3eb6b4c82fbe8a01d95b4da90e6b52db61bc24ac1f914ddc2239f55f09aff306c2c8ded2404a3b149013457e3fec59cc536d09ccffaf599ead56d44a861d18ba38a8372cc204e81e67a73c0a7def10be9877639ae3fbefbbf20e383d09668b0fd4fc2e3ab40f426ae78a69eeec1fad7963d7fb996e2d6999b019c12e0d3112467459c3a69a49337d7c30eeab490fe91f8228fbe09815cab2684caa10e553c86160218d6541a945bad1b3903c29fb3e94c03084adcb6d43335df2b2dee9f15c46104ed9621a69bf663964beccb71100c819a91080c546f6cb2e57efb8a1ce9d2d3fb6b34826011ba7711c9b1b5cb72ed2d2cc7806a4f89e0a409131e2ffa066c420f30548d87777475f130797f96b591a65204be8ee8b551a0dc9a22c4bf8a93be188993d86d74f03e2ec31dc84b046a24f7f04ae8fea2f0066762d4bdae7379b6a369aeb5f30d610174a9cb09fa825e7f6698b68722d6210a9db4c3622524f32d7f2697bad4d91647a97b269a543f9bd3f1d2ae673003c0d70c0b5d4851de8ccc62b38774dcd5d4aa64469fc0f592e536a8fc9b9bcb45d599ac573056c31377b4ff372c9d2de542371e07434f1b91a7aeb0dcf8b34c91aec7b08035380ff7623ab4cb87e369118710537311a291aed2db7520843cd77081a45c64070a738a1c634ed74720a4b420bf80abca513de6d128345c16e4be1679b29634315d422509c03065fc201ab9b6bae69424d4ff025","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
