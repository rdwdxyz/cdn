<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8cdfff1a89c69e7a689ba0597702ba74c04845144b8c787d326b8d2dccc53b91c55e6b0d902351917683114b215d405893358cc1359f96bb8e70021267d8aeecd09c92f8ad4694554378dca60090946126f8309c24c99b457ad37904b47f1d3a5a5a236c20654d57f4b9ccc9c89d31960c830907b449100c9b6fd8b59902347d43a64f0b38aeddcf78a4625100cc51e338998b00dfd7c5fa446307f740b4b7bf010e5633b0c9758d99d8d7deff637f6a774ee95e65626de10505970ad5da501f2a1154304431ba0183bb65eb482f0efae1eeb3cba80c5bebbcd76cc4f30bb37da3a7408b6a7d7ac9705e73a9cf7e47cce22788a7af24f00ae684712ce73c79c5577682a7c741109930e3121be24eade84f3141f99c15e4fa06e48d36252a763af670fcaa676e0f847a90d94a61823678eed4c49d91bf2915ccc4db4b0d56ae20cb68dff075b1fca9f27950d06f767708452a3484a360a60d2eb08909b5e3cd67ae4100c975d3d292515d8fb363d879dcb7d19d8d1e59108d07177856b8334000b75c650428da2b8401fd4590fe77726bff26baaf24f2fc2adae14ab3907451271b6c3774226ccc5d37e93e7fb237d1e22249541926d418a69163da1674e60f099df8c499c91db6013ddca81ee489760bf26fbea0d07b07afa5f11976a81901611233a3a868d190bf5e6d4d185bba01c1e3ed42f8f28f286033a8414106b5e20e75554c7721fb1e73abf4c6eb550fc0d17e8809d9987ed4326b54d876f306319d7702a8f64f1c8c610312b479c53ff4ddf040e797e26e098dbee03fcd5aa08d981f86764cf66fee2d22b2dbd9c9951aaca5acf5f8293c3bce1f03e7ba84f3715c09b7d781a3466bfa9a57fc5738853a78ade6f2b6e444dd71f1a1594fd2475925fcc623ab9ac73037f2229e35a1c0a477e59b27295e6899744576687d0ecc00967d29c1625ef388604801ef87529ae3d7116b7cde914064c47f739658b8f56382f0295fa0c5dd8386243b4ea1b3f22d53a48c0c51afe08d5ee148a3b522b9622587b8f2e7d24ad2c5b12b6cb3c16956a8cdc761fe490613815f2be85f81158cdd2ebf5970c10afd500ab8bb670dcb8ef84eda2c6acf2d6caa59a2aff54ec5f893818611e107c5e390356de9130d1fc842af4c643b4878c964d8075f6a7e35c62c375d99afc62c433d17335a3f7358f4a6b10b581dc40a83558911d22b8bfe4117e4c6212cb011eaee5131f90c9b9f31c8b3cf86b9d0c0032dd6d99ee8114d0d54c8f028a237637fbe5204435c329921d8145cf1ca3e9e4ebd728fda238cb0529888fc429d8a5e3e3e5ba064d4b7c2c849c24fb6c44f2e417903103feb00b21d610f3a35b20ffa45156bff0ce6b4c5ad8708f41a371b157f822b8991fbf1b1161e308ce84a45409c0e2b65c4dbc78fcb5a988776936627c28ef0e3b8c992674e604748d81c6bcecbbe93d2d129e6815c634983191c5c000e577e11197831b1a9353afd6a8b3394e2e6cd1f5214de9f923b93a4d6529e85963d8bee2a7f9162f7055f4de3af11d9789264aeec6e251c4f671f135ac67078348a56144ce411849542b4a999b2f1903af64af9f1789333255f059094dce869aa61b8314fe297565f544b35809ec0e0042c52f1d38a8a47c62ad1f7f966b3ba9c6b3319b036c997fe672c3661f3b74dbd483b5df5ab0c78e2c0211c093aa442a3b21d83af12c080bea8bb53a201c9eafd5543062712bc37ae39e16928370912cc65a5a55caca021ea282f17396720726f85a146e7c96e75a111433daeee1b0fffbc8d65b1359a4d622322d2ecaf3bb1da1a294c5b6a59f8a20bd6339ded1ed34c4aaaccce5cd0ff9dec66b2e212060cbf52704738fc9fb83bb6cca443efdf390b776ac1ca951098e471e30b59939a7eafd0db05edad77496919aa975ec59d46ef5b8e1f521723fdf6cef3e3dbc09f5e4412446a45c3eb97abf4a676a5a9f654bac5e4c246dac5c7ef98376c636af2d3edce050c8a618d929685e0448f1cf8e7ae87ff326043d7dd757e7e673a7291813d809ed3b7b3b4f30882592747652d3118d87190bc0818f1f5f3c480df8415d7c133490579712277a9d8550369a07ad6c1a390b7fae28611bfaaa85e683a32bfec89ddb3d47c412c9442f35cb58e6a80c49dee6285ec0918c34c6afde4c5f66e90a0e5b9a27902bdc1da93a0d7b3ef8e07a89294cd0c4496f70c7be3e17c9c3d9bc249e6e940fc0bbf3dc48cb1c9253ad0859524f47562ac692d3a88c922b0fc0df20b68d3e87102b6ca59ab225fd7e182f462a9881a2f955da1023dd05abb2a0656e6f2ea617b5e45cc8e234cd7bf3f6f06b702abdc176de0d4252ea1bc7d12f1769bba62869da360a1537f45c89442dcc5bfd08975764df22c4558ea604ff5cbc248d701f5989a1fc0de1aa0039c5fff112dc3e960f3a35e0febadd5f933ed289e8e9880b19c42b9d64eac885c89198624679cce68357b70524741901f82fc022c2eadf1b6e7818cc554909fbadf035488ec6fb42599445466d2ad46021fb648dd9bf8df5e13df95f321fa9227faeb2093ee77deddc27409e6e0a3bec83210cfafb35e61947329ede4c2df3d42e22a5809b07529ba80592fb49a9d375f0b86fdcf0c1c1970de6a02a30964601ac2663bf9bf6abc6052064aef373b7b4734e4a03fe0ac66f493c04f8cb42892b022d7a06335387618a168a0c38cfbd109ac2e46c2141310d4310f2a175ab7c1a1ec614275bd14d2777ff69fe9318dd38a3749e1f4637fa52706de7780baa12a39c942440a691c992fa5c300bbf21f7fce467044df5bd98818ef7015aa66c304cf464240d1654d2e1d276abc9a099f2aabf8d727275f531f29be476e2425155e5d6dc3092e87e7720906ceb4795d44095f0f5e3e9d86b0da28b7c8a84701196e93502e1546167091a555e3b450de5cdf6f0a57f9363f3a6b5ccbca956fe60167d5be6364f4d67cb4b75f89d7dd09b4924d09a43ad383b30d4c31dd9f57cdb4d48a172169fcb29360af22884bf49a41ad6a54e288d2c07c5126281f3a736c377076f738ff65739d1d89e4f529e7bce435027f8733044da35d2e1fb93f1ce3c63272915c4e8a84f30fbf7ebd8d20159832107b608c725ca6c3927d211bad6d74b53a35128342f62aed8b3a5d5053a2583afef69eb5a2cd15404c71baf00c549e727a4c3e32c41734d5c4fd0bf28cf319ad3c4a550e36e9a3f5d25721ada4bea82467d6842dab46aa6811301c3fd6e869e42f2f6567db1fb7f52d10882828455c02a981572fe44617c137a64544311788022a1abb59c82966219a88ae21f885cc2d91cf6842427496a6855eba965c1100d1af8f57815e13faea0b76564bc3eeb5f2efff83aa3138acfab32ae11af8c56b60a40d9e70f63efa33262e60ddd0f203903fc83a109b51cc2c64fd7c5771c9e2e0db5d870833d2c12240956be0ea39140f38ff48a289fbce34063b398ef2a177f004faa692ad8d5924cff12eef7b2e3ad38c325089911bc7613f2f26674529cc3c3d21e9824904696176cdcae9ed1d6b25bce908612f4b56d8dc1cd0466363be425f1ab4862bdc4a47c337ecd269ea16a445094bafe508af781444685e7314001d97cca985715dc2bab44cf348d0979cdc2b59a58262af807f4476476e75b64211681f2c18320666261304ec2520d75ab0efb16ac3a31f88ed0306a6bff88f208c073c3085c726417fb7fb49b9abdc18d441ea1e9a538c48a75218327462eeb7d6f96bf1166b8683b1bfc4b2ff5ec1c4e226ca6dd4b4c175df1340ee2d8bfbac07725ecb580d469921fc9d25d6a60a551edebad268ff2443c3f26686e3d94afaea1cd9385e1d70f87cc846847a4926da4315f4b0aef92094f9dace38cce38c58ec4975de3fbf447a334b9b0f8f299a162124f965104f2a52d0bacdec6b7479596135f27f72da9ce1358a0a743a1d18ca489677cced00e2d388020d28344f8b74a5ee2941df25b8bff84b8e3e0209f2bb003339fb4fd8d54a47c1d724b697ca88f17b4c720724d93b5ee40f11bbef1c6b49d865cdb74c32b12c8410ad7b3546e75893f21062a360925d0cdb73d7c617728bed0cca3c82ef08f7b1df5e7c85f82571365c86f8fd3eec2906f41e8a90d6fe3eb0a36701caa2cc5919e97859e2e9f82e53bc27ab41f721589628b2e96797c89987d0d9c9c0f516d19d5e0f3ef5ab0d0aa0848d159acceec0ae34709cd30437c813b2cae4ce2d39c598788901568646a2dfd34d5a9a0484d311fa61e12912acbd055a238220e0ccaaef11f45207ccdb714890913e348b5f6174ddc11f79b242b738271b0d4eafc9f7f35022c241357dc512e5880bdd67c0872a6d50f022400caccf059cda6a8dddff3b69d0e9f756f8e6759a43d337a4e1687d922435753f682cdc1d44048eb33de5d2351b5c15e3054ad6ddb8cc5a5b15a7a5f451989530ce6f21dde9af295ea9db7e6a8017ccef213a592d29a34436bd4328f12064d0441300f810ddb671a93d4aeb052d155a798b0e9984edd88ebd986260f7e722ab48e95b6e7ab0856f4dcf721b005ae0affc8a2412792f77cbc6ef1cc96f67e5cb4d9a3417adbd0684fa0581bf414aea121931489c8dd07da2b80c836540604c252fb9fa87039b40201d1a2ed4a5d67aed572572ba1f9f862165c1828e6fe21020f24776b50e1351f1f6b7c26f57e38627716785abdaf8c7d0e6e99f4de819afcbd2adc96a2b9c6882cf28009981de12dac7ae2e191589cf47e91f682a41ceef153102bdc2aa8e083f22ac67de6151cc0a610ff0edf858c8aa4d47c09699a42ea136a374052055b0f73cc258360b3751a87d06cfc2b8984b6d3d5404050e37643ca97d0c3902dd346e2c908d49fc4ddbda203fb815dd2a7dd3cf1355bcc8fbd29c6fc39a5d48dc71cf4d55de7880d0128e52f8dee4b7b5eaf82fa025c602ec3d757ea0af5da441c07c4ab4dc733fe216fef250e2c5fdee49cc3d5b7f55ddc5a468315dfc15ecbbd5de010ea84106be97f46e6ce6dc481490a173211e1f52326afb8e1875daec3bb7a1ebe61c1f56806b44bd514bbdb9841ef4147a876623042295d9e4461e1468708aefb96f8abcb2b3a79dddc8dbd1ce05d822771175b49a3dc6a422ae8b1ebce47c58e500a3129116cbb1e414e72db2bea99cf0c2c443460e39ec79e5caf17cab7bb2b55d079b7810b90c30083a636beaf427f90f9267728d26fb101cc76de66182742c15a1c1a302ad692a17b1b209002758fccec0fd3463d078535a38b13370d6fa5398fbea4c7e5e4d339c8367b8e73951fa3ebdd47caebcb3ceff506b055a23400f0c42abdb3797530e9966799ef05c3cc311977bb8216e3b211d18529ab3aab81e3c23770300dfc760ab62453a0f7365d8fe3a59c3301a7cdfaf63a466530a8e90c3bac5a5c520e716bbba39d6f512e34b9e5a76c477235c268b91d36e8786538fa071fa66233882247883e8db88993dcdcb6562a34d7404fa4c0f8470834507a8de9e9520bc75dd41f0e0d98e546d8970da3202c6f76920343de9261e4a9ec0d917c73fd04c675840c49a00057194df93b96c16271f74f22d3230893259d2700ad4774383e14bbc1c9318bb3a5a33af1b1c337674888e2e6aa2cd17b2694ba9486ce18d89a8c13f8bc2722c2ee2560451e778467d7b0bc78ed8697e567f8574ba292fdf0b7525cd03c0fa858950d1500481eef58fcecb18e6f9b861e5cfa29378e5a44d539004a7066d8ce00da63c57e80bf23392120df2a1249e5159a1b03a3358daf4c13a6145919eefeeaaf9f852496bf5eb7008ada0b8b940adffbd55213a308688637b0b9280ea24574fe391138bbad84b677a78cef4cc9a74b6dbe96756bac47c412013f7f39505260b75bc712e250d6872efe5959e6a06611da8b92051b234fb8618de6178c532593b728c55ed0e71cac5951c83f0d532bbc282271ff1baa0fc34b33118f55581fcc5e1820279ccd3c7f72ae37a40bb1589a2d2690f64556f3c78936b16fa733eff177fba1c241031fee91b8502bfbd998fe0185c9b4be305c5cc74eb7050c0ca51927d8ead39400b06c3de960a9481cf8e3eb3749f4be524d2dfbdd98544db3fa0a7beafe27c01502d7e1f4ba35886481cec78f5cc030d6de77cf19db64304dfa9c4d2121be01b1c463f3123a23e2f8c0aaca4eafd5244f7981a92326edac7abcc76352648bd27674c3204159a3844cf42d8701bc39fb72181fa9cf485123207511e7a62db20cf5e58203e4e3fe31e61f7b1a0d622626a7bbc4c8d4e8aad02bffff9e5309636f8432628aa5cc135b671efcec3c9fe758c907731d67511cceb30244b3d1e9a0384a07b297d2f74f7a4275bc8dbce836875a5092a6c545c82f41ac3bb8f486eb8ba6a256e8ac4b33ba799dd301a43087a4a14230c597c8751ed3d5370959cf9b84e815e4076c1031a04efa7ad456e66e73b3ad4517d60de351278506dde21fff84e44f836e94ec627142c75c441c9f1bb7b6332be1b0562b135761675c1ba7c3c9a061614e0ffd8f6fce5c73610873a6e08c65cdab31301b16cc122cc5ff39136e13068ea820dcdecb425f2704a380b3f163834a0f11799210b5e1509586b5b9c4fb23e60e20d88a3ab8be90132d6e1a39656eb999ecd191be92519ccbb0515ab760ab3bea3133d0194c7c0cf21e78ff7b9fe282c88951f6d76f9d2e2b25456c286a5044265587dbebeda2a3b2b8f2cb276628082eace4a18ef275b9ead7b821b7303fc85a2b21d2dd39acf9158f24d3e66578a42940b0b1cb9fbfdde72593cba4072e4ca8a0cc20c91b8df6c15f4203b7ef20bad85eb203c9d90209b09136fad51796914c596d8bde4b9e0cdd4a0f83b3cb3d98133b0908768227a5cd329294ac4c5c30e0d7288906010720e2bfd9202482f1890ed604ab3f1058e9a3f74e14076b1b4c587646c65c504437984e2810881098724688cb9a7a1a148a363fe478e20954626c95bf48b12bc8fe9d7f226514cfd557fdc3a7cfcf4fc5f4f0d207307d8c44d00689c17d64ac178d208ddef6ae06113a81417e62b7a5c4d718fe7849312c6365beb42a81bfd1fbe52529a6b70814e33ad4deb2970d5e06b83a940fac5dd6b66ef9b3dba5766c9d159e9c82ce0c02a53cbc9c9e71048bd194a1c0ac37e6034c86766f8e0bf98e51bad68dbcbf22969a61214f9cdf7ec38544c9791750c37034323b03a6a3cd8e99301b0ff705df8c03ac1b5030d55f45d7ad991bfa5b911e49c5d640d21536bb62371d6207644d85ecc0146495e4f0aab619fd471b287e581e97c8d7e59497488ff5a3420385166cd079e9599e61c93e026bc0615036ef27a6d3c282521b1477f572da58d8e858d7d2830b2e1a2dedc6d119b175547d6efcd470bc1d6d8546b0c1dab7c96d96c325356190a340a03c320b75c6cce4f95405628251322a41a9933ead3217376784efa3bc562974b8ae120cba2f94d6ddd58d5a880cfe428dcc9606cbdf3c51767bfc7aa3584305a9be111cece304155d62f7c7fdd6cebcb79927af115844338b68a56138b28d910a8ee33ceb918327ec968ec76cc7ee43b0b01c1960ff156dbff46e9d10d3a141f1e6084c2a4c8a2c5143375aa9760ee59d710841d7dc44f430d39dc0f5393e55d824e7b0b884943baa45ae590be3aed9bc1b39863581cd6fc21de385d4338ea87591d41779e08733b42079d211075d1a45163246b6277b2d7007c41f40c134e9efcc7a16de0d5e58a767e9ddb00c1794a6ef12a72d9ea901df01d9a8637ef7b3fdbdee8f133a3b3feaddfbbfee28728e2715585ae017404c2138af3e0d66d91136a472a800bfcbdde789f29848f4e9839b02448eb8dcdfb820a1adeb77cd23177936f5420a44951e0beb124f577b6c173372be8dbebe7d728b4f67d89a6a9006d22a74858efc1bebc1d14983ec3e1b0462ff322e33bb8baa4a1549d6fbf26cfe885f7ee04fd3f10b61cb22d0bfaee0c06df911fc919c912339591cc6d04fe2dce1ecbc234342e1215bca9902bdc494077ef35a2180f0c05c3266b1e0b44eee67933a6531e0a7191c7782836d79a99f38556bb0f8f9129fab04e3c537896d709ef7b5ea6be6acde997cd4b124c391baf7dc89fad22f36dd7b79ccaae1ee77989b8ffeacde49e574874d5db1e1ed163c62a917c06316c53b096eb063cea1bdff2532da04d7b863b0670ad80a0c9ae95a75d0fe20fa11ae03e46aeffca271c0d92f6114fc22704f3fd58e52ec0c036fc6792fc386048c0f3aafcef13d22be591adf6d86233343685c1c9a36f7942044da96d77aeae53fa0af630189fc97c74903d989daa8315266c07aeb16282c9b54652bdefb31b58303c04e9d9eb6e9c7da2d9b8b55b717a438d43bd9a94bb5ffebb04ba509c4111978a58eb2f88a653a80cf3a9ca22a87343d5a2dd381fac56d57966865e9b7d2943a3ebc3e878da08c0495be71fdfd7e25afd59a972581ecc9b6ea6a7932daeeabf5c851c1fd097d9874f18811dc59bfdac0d0b6c1476826178289da7c2350ae9a61ad81c3471ba678d96366f0fe7e3bf38bed93b17ad5d0589c0ec8459307fc765cf479fd311885efea85aac28bf8158653282ad4019c770a3adda412de8108ef1bccd5979f9e647d50f34f6885b49721553bdcafc49ff295d5f3d107f406e5f9bc6fad6e32112bde46406c66ff375afeddcb8fefcb470685d9b05b0e45cca1a03d7badbaf72721d02a96c49fb2e6f59b4e50187e7f58bdbba44d5ec291d597a786a3a288f557b4f7440e451a3b98cfbe3b885b24d14347ff84463c84f6997e9ef6bd4b649084a59f16b207e4610215cee03beead9b11ff170bec6218090194be6e8c60ecc8e5bc1e7b37ecd9f61a75ac2c9eda8da105728f94161b189673595c20a377874eb8b76fb89d466589b759257ccb1bbaa03d7a4a79acad80fd44bf4c1463dd3cf210c3d382278ad8303d75ae1b29b84c3893718cd1b90c920fa16f067a0a0b7db0d1f1182f71b9981799deadfe78620f62ccfff266bac66202990235e47095bb3a2992c259928ef43891a0c4e736193d965e7e0610501e374ff3d052c9e342deb6b4912986582fe003363018daab666af82ef8d566f60f17a45c25e61dcef9356f905913baeae4db856d81318383bcc68448bd3868d9f5cb0dd8ec868bcdd9687c25552036d5a0f0f973c92939edc0852eb011bf507e548466d8aa59a99cfaf027ad3dd76c09bf48413cad575465d51d55b873859baabf7e46dbe40f17dc4b039d0ed29165b1d010c4e4f723e47fe8b5f820880fc3c6a4889d8d48eabab8d14047bd9b62760f272eb536f9a81559470c63a62a22537c97ce8d0709a07e937dc84e6f439e8ae2a68a32620ffc6cf9f66f7b8c69e2a21c38acbbb499396d1ad8a54be5eb45ec18de98b86c3b8837294317aa2c6eec00f89e1a91d1cdb35396246915888020dedd0675debfa1afd489b8ba92b812064420acfe9ebd82a04085d39f7242c7e06c9cfdf8e51fa7b2f4f9ecd1282a0731c91bd102204ac502b07ea09ec3e7687fd3938f1d78513dadff36d16b3c4942767870eb538f41414252bc34e3bd2af1c4a24918cfe3add239282cb976e608831f7cbed91a87cfc60b053daaef59d4d804ae0049fd6dbd681bf964b928e5b226f4129cd4500b9ab32a00a6dba7ca8d55d78e978cf3794255f0fb27146a2b587b19151715ce1d5eb75b8ec5cf9e9f758d9627ab2a3366acc02bd7f1592e5180f6f2e14563c129c61ec219ac58669a49c97cb94f22426b1380a4d6560f2bf0703953fea9d41076a09a17956bcd3a89f1a7cc2739efe084b330f094e22e63a4da14d856e9e8a040fbb23d8d826d8bfa5a37f45679c887032dff57c19359deb749a2f7ac4d93cc0ec2de998747c2d439fc2ad20db3bb90248d615d931c6a8b164b720a2d2e9c56966577227ac1ad80c7f3fd844f73e95a7f1f217ec9fcaf7a8788f62bf815eac7eba54328aecb4976a02195d7d309204d8def93e1e02051692a10659fc10135a085d64e10564829a7edd8e708d35b74e07c5179bb3cf2a441869b126652e86da097709021dd6a7c828733e6d92934752ffd971f277c91b2b5ecce26afe6507607075c643a7e102440d39a816bb5307fd5657d31d3ae42ee5eff86262b1410e8d2717bddc099aeda6a31d5428d0ba8495e5c06d41a7ca678f5d5426021c7a2b2801c31c30c0fc7b93adc50bf517b6b8404d8b0be0437beabf85fb61ebdfbf7f388ad5824220737110d77ef4364a920b6fc10f8c8c79eecce9204efec8df337d87563adc0f4b28e7632b9ef51f49624af0c5bff1509b484808f19d8d0796e01a797cf16a40ed8fbaae21e105148ade4c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
