<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc3e6791e4c0dfddd382ac66f7f85290b18a1a7a564d6bfc2f9f4b6aeb4c061b655499cbe15a5d925a07a657a494ebb407a5201d5d852c339f98befeacfe51ef0c4898f8a876a37fec365d1cf313cb7e513df1a3bb6c1c297b44791208d262145755e77c4b53c0361a949f6c9de3b1e7268f454d709a60d0497b29439aa42e9cc5c4d6fcbbfc1b81dfd7424e2abea98511273ee1c083a4383b6c43932e8f5665d95d094264bbd7b73638c893b7eae6a569a50eb745ea263dea1bc5176771ac7cb2d1c280340d143a22915ecc339d837054a1fd39d55657cbfb930ae4439e8132761774eb476c4f71dfce9e9c5df3262962924bd1be78642e26556e0858bbb5216a7ea8c384f3a89cc1a52def29c08da48c0583ddde584dfe5f59b8e4f3252a420be767eda3f4898715842f43d819a2ecb2d8adf3b4417ac2f4783679a95aac731df979d5cb2c408975cfe717fd94517d28bca98838a019c2f9899799e6aa3386972963ceaf8bf62b86d1c0daceb69359981c22e8fcf5cdbde1d64c515841aa950c3f45c3bae36b87fbb1e0d13880d5d5d2bfb5a9871763ab282452367bfd68799735e3b5b06c698c1ee6a42062b00bfdbcebc70b67b0c096ab6b932c34deaeeb5726ce4c9519303a9e905200467ccb0f7833459add88ce332542e24680d93c3087d13cb8c0dce4d4e06779acb1318cb0e0e8fcbd023c4ed19a12541f430f65f8f18bb99d41ffb8488e3eabf3f30a151c35607bf8fec5434e4de17b1c0e7c623a4c9e110c804f1e86707d285cee4b8bf6f946255c69965998238858ccd5a9ce352c520134afacadfd1fb2cfc46d86d75f8af6d23bdeef57f4eb3e9a0510b13059a912eb79c444d6b34b2ce10d6f73c704d72204cca08e06484896d15ff88cbea9fbff1512954e695e6f6c8d3b851d5d0cf9a66bd3d9fc06f4d98a8a5fbc9cc7a7f80579394e930010d9bf60ed327f93318962187fcdfef31b645e97ef3371c67f06d50a4311c524785eb58f37d18c76858fc4c099b8aaf4f201b3b4c6b4ac377b504b431178af704571e681fd77696855b61160716f2087c422a1b1ceb2f163b6d7018c10f9e95407deeeddbc59f1f5edb9922e6d953bdf6ad7033028d300f2f99988e10c0a1e96d7ab01660a9ebe7789671b1a1c681b4d4e409e037082122921547885b957c327337207ede01bea5278dba25977458a43b3505c7a737799aa720ef027b95cd09c5afa66fba14644f14bdd7fec7a6ea4b5f208590005ebd4f4c9e1801c1056a6b8b18fe8052540a3be2f566e50bcf29c33bd7dfeabaa79f67f0d3bd98564f614a2ee1c2c5262401a714e08c41ea199d9e9eb5b9f136fcceef42f8228156b414743b1b50fb3b7cae89a07e81f8fca7fc3c39e56cbd3bfe2f8dbc9de6ea9d5793d165c7dc013338acd3f04aea6d14e6d211a569e5bd47b98681dbecb4d4dd1a994d5219a4e7b3fd7b025dbacb03c6ed0b70405cecc4562a3222188b0eb9958d9108a5f8f7359975fbb1f15b9598592775ba40a864c9e9695f17b166f2979bc91ac6c28b4a55a660b70f31cec56b7fd1d7f3cc6929de26b1504506c012e648402d8cc756b830c71d843430f187fe5fac38c5a618cdac5c64a5f02b68cd3f97bc9a94b1c64e4e45d3742d5940068bb5b0ce7473d31a5f16826aa48e23c4f103a878d1d4819700e29b0a636cc61e6308d70ad19bcf336b0417a5486520d59a476db6d943b11f49027ffbe6e0735980a39487a1971593540dc64cff707d338656d5b1f664c4b91abad3fa224abbcd5b54aa1c118d9d224c7bd2ada992ecc96931200b6d1f0165154e7e2eacdd9569c6fd174e2c1a39874ebdd179cdf1381906b30915dcebe0b279348fed97681f3e6f6e4bcd18aa7d5494d55d423d1cf7c67df9dc788bc014e7fec79390ef0a5164787849018aee050f5cd5ea8fc328415cf8c51e8592a09473b7a4387afb6a7e61e3390808e3e9dea1b5a2dd2ae3b83c1ccb38a4d22892d99e03384aa041d71930d8e7d918d8988547488dc37984d2560877535a383aea7f7b9e7746775802ca54220a53e38ddfd2e6f3c80ece6d4cf08f414b24910fc5ffd497485ed324828e6de89afc75d230c135e2340960acb388dc7056363fd09b2bf7e5d25faa4d4297de6515df3d1ff27e674aac248183d4fbd643db3e29ef301bfa31bc65df566a5873cc83b979bb41838931674abdcae46218879cca85aabd82e6d4b69a5f0815b3e534fa64fac74d9b0ed1e41785999d85acff5b77ccc38ca685c9b8454266ec162d71c80506910e0efc183c98e56de77c6c7f35688f83e933b59631752d8c4dd3189945c53d51fd849bc761a22916d4ea96c477e88e6a89b2bcb9814566c12855e8a3b836b3d67c45881ad6b24d0fee98438aeef244544e63a1ca58e2a9cdbea88c063898a10ffc6755bebd47c6c7dd65154a82ae43fd4318571090616de4ffb23a708f9f9132d9f736a3046ebddf8fa34f2f7c492a760516843063fe4e887b14de684c046f0bc2f7df9235c5e4fde096ee79bff4df75079ea4b82773805b2f09023d2ce621455aec84abd0c6afe6a226b1c57b993ac9a208c882e5b601d1025348c57a521bef2fa97dad419d94b595e0203b40cd263b765b13dca9fb8fdf5a13dd38c99226d7405bc38bbc728fceecf07d71dc35273b0a3543dd77f4962c095600415b58ab63547eda25fc41dc98ebedc0a1f063e0498fb74658e82c921008434cc999d01cb24d69bb683e134b17d354f9d1a80c27087f29e532da823f8c256133fdd04fb92bb4a98c720bce40ff27084cf4f67207e53908417fc1b99efeb3ac5745554f4514bad653ff565cda5fd7d02beb6a92d9b953771e5d5c3be9cf342631e7b5327aa74b9e3e418d26e66f47ba3e03df3e432592d7ca8dae5a8825d72acb96e0e36349428bda10ef0d524040775cc9a0c1cfcd2f38f52c9bf948b5a04e027e3e73d37f83b2bf4f96673a2b7252c9c39b91c1d88a81838679723705cd9a16572b8f64f9ce7abbe2479311a082cc39022edb04dd3927317b8d87a3f36b8a97c654307b1f25e1f4d7a5c0d51fc2c6f31d20f0011b0acb53778a41e078056d2f038984b119052a214e217ad864b407038955398322c201dcba7dcfb7df7af7d3348f5bc22d6b2f16b2598250f2d51be1e26006083ac8da22b8e81164e88327fa70fbdf6bfa7f9b9c5e436d723b97030eca34ace2890d5bd0ddde7d88c54f7460898038da2bd0bb6c8f824ff6ddd24df89b031511e1ab4b3dad0d1578a0e4712536e695e405d07c56d202d9250cecd1b782f82c78523af19c47bcea7820349310fd7002441595f69067b111231b95793ad9b1c0f5fb90e093d8a7457e00f2497930acd3db719225a5dca90af5147b32fc1d1160504519fc4d3f0c7d8752730727778f44145453728c3c8c04c21aa4bf241055a977fa47101f4c0e3709886041116e34378a36d74bbc033a34b333a71f36565c9ae05a7e2149756946989a303f3d2515662c7d239f226a5068e58bf9c998b39cd17d5f62c1673b4ca2fae4e4db5fe6343e678b8e7f6a6dd458dd853984db047f5a74a5ad87f98c941b933bcd0fcafbb4d0cb04904c8e5b66d3d35ded012212beb01670e6ef35bae29341baec0c9e09d39f0d8cd57b0300121ccd5837c60d75777f26968916dfae1109be18b90e55a891f613e3d0893462f86bd3e2fc9ad53c8cc0ee0286a8bc5af25b6adb57ae7047f538e043770c38fb390abcd079c6718123eb9d27947d3cafbea5644f4f39f91949a0add917e97fc95cec78544e6d3cf543be62f51ae5459624ee3a66d09bd42431ba3ba74e89c04e645b3f690bbf2c0a5e9041dd3805dcbb49111e07c1df14f83b0d7e79f407ba3a2bb77b8e409c2a399a93b2557810c68e876398ce2cc040694e2474d78a9270d290217151565f8483a3a7cd74b1f2ca62f92e8a6077a9d2d7f081015aa3d3a4d730cd65425eab0374b0a42f15d7330a8299b59992dc17926e25aae1d8052d807ea90dd87fca72139c4e03aab78cf3dd5c0b47c0eeab42c086bc3a19f07aba24bd3dcad293f18300e272734f323375660be3bb685fe01a7b8ac4719f546fcd554326e1ba8fc2ee47f0b73f9f0486e50fcb50606a45074074cd24b3795f8caf86a47a56a0db1c3f273d0ab427e1e107f89c2195442cfbebea260d89c15027d41fd8d7949337f0069dfa7562c78787841ce95c85b09f0f0f30e84208c6ebfa2a59b6136ee21bd41ee4c0f398a369f44b6af144e36fdbc511815c6092639ee30c37f0298829b3ffe9b32ae94b275f390c927605920f99d5d5e8fecf089983a692c3d8555cf7911b98109e22addf4bfe691b6215508b8e0425ba199ee11a88392d230177127944b3d9a5d1a4b880ee44b61452d31c3b47722980ff31c03d9b8dcee507f0df17e6c2940ab8f7625e5a835b9176fbd14c674a705fc8c43cb0b624a2cf6a746acd247d7bbc89bd13657baf888d685607daec54fb4e2ce02ff70da6f9a92dc3570e1bc2d1b35c8f509e535f0e495fa2f07d126dfac937f5e01c318952edbc212ccd859a46682d26dd8b793ba8ccd6aad4b8fb7acafb4333f94f7ecb18fca8098c74c19a3e60c9556e0030937e8686efcfdb85051a2f6c58d37713cf07c6863be02cc9fad5b9804aa4473feaa7311dbd450bdb7e83b67218a007bfccdcb96157ff00a49bfb01e79586507d3cb933b7f5ddf6a8034391018888efd0b9122d64015d7dc5af5328f29b3a56607b24d6f929614c424fe36df75b5ef6197c8ff6704a06c63050d80f3fcbf3803b284a3d91347e2d3f9e6ce7cc89b6230a92c1620ba7cb54779f99c745379a440476bfb3c0b3081d674a7c6aa12821fe7d8aa8986f2ed385b1dfc947a8fecd79b8f010dd7d47730a4998760e6295325ce161f44b4813246a6374d48437403431917ebc787f985f589c088ce49ecb6384ca97684e3db969ee6a57b279e578fbb4d5a4aa7f42aae12302383727f2596b7d401e11272fdbc571b28b0a330aa7e45aef5af350793eaed47a6897e0c7fc392466bd16c5b837b9541748cb6b13a2f8530af49c61d93c3864b7c27e02494a551a433270a2b0ba268a7a8ea69fe6ccfbebe8ee1c98c5ba012f64dd67ae1e70412d4c88694970bed4a222e278e01abdad8b7f8d4bf26824b0aec65a6a59d328c9eb708ffee2f688acbe2072e5b2bc5069c53d9a847f03382ef8695f268aebf98da3c2a78741c5683bcb3f050419f446b028b44de749719e1621576315d53b91476f4fbfd60a8ebe855aa444eeba0deae4153aceb2f8bb72c7bdba94ec1a8c269aa5d43029ce05f87851a1a8b9144363b2ab127b00bdad8ebbbea216395ece4c2fb7c71ab883316a22d7b557de4bdaf5fabecd78298f56b3d7b320e8f9f7f171fcf9b6a7ce2eb37a1a42bc9f2214ac882fbb960fe809c41e72066c6cb73a69bd6a0d6e99dc7c1df3a649f4e08fc59abc9e05871a89814e98d3f65d0a60015a6fae3739aeddb799d04d28ae32cd9cd7dcf4506026934a04c23bd8b77b5279ec9c59223dc2a2fc969cb50640b88dd5a05eeb5424a6dc0e6ab465fe18ffee1320ba70199717765cda7684c897d220fe046c193775837e66b2229bd194ade725b2d14b7984339a0d7896b92c28939ffe122d632b515b176068e8d2d3b8916f2d6d8b29129400252ae84575c5f0107b186af29768340c584b11add5dba2c1366d1f45bca303283299b9f6e39c599de764ea3851ee233cc042b2ea2b95eb6a1043e696b19d38d5f37202ee9686173570e0311472d879e480963d3a3fbcf257c1afc8b9d7a3439b136ed1397a311455795f10854226e9e7fd7aa989a7aefaf4453748f46c1c074e4dc92e8a82585a04645fb84c831600761a2b171b0fd3c418ea4ae13eabf7988a07689858fcb4e991aa0fe2c1f133bd2e29e0c9cba653d8c63159607e173acfa7d6dc733135dac0a6c142f0b74e3d47cad4d378b3cf6fdbffc903a0777f2c82a0bd7c25c696dcc68e18aac37454d71808ac60a867a89e6579fd4922e1e054228b9ee1a8f0149deae225c449745366f56524b85e66870cb83a56935cc13d35a3a087444384990b78bdf94c38d4c9ed144596391ad7382550c79931f636f40c2843a4b6734abfaf96fa7932fae220099f487d7f6c0c8843049ef54f5fc7802f53c06a5c8785a01494aa06bd0dd1642aac9c861b6ae00dd4c2f87eacb6cae822c6638e87fe9f7e5b4cca018f4ccaf1872c478409d8527a25cd927ceeac03a68d9ea858b52f0177fbff12b7cd653867429cc577f0fdfa38f6fea18ba8ffc91cd0bda073614fd5961f1dae3da78ed8509ec78f2ba79c5a2f25ff2f07406e7cf37d8cdcfde4973ff66c67a34a7601252b4627dc505fb29b78af24578ef1b33c0e2588de886683b765fb3fb5c154f3ee35ab32391ecdd6bafef7144031724eccce7d3607d8ffb97b65c6c4ff7795add1f1766e59a0e3ffaff08d309d212370316c88deb56f1eb80b17aaac958271fbd4a0081c82e023fc74f530a9472f7cdb763eda03e6c23c596b9ab350f39cdaad7efad3597d11ddc2e14e28851c12709be3bb8460c5b5caf7a6eed24dc76aba83bf0e4e2e02d6f059c1c623783e51ad2221bcc20bfa94ebc26f7f0b3723a437ae640e36e2ef0fd860e077d20f89c155feeda67632ab2d0563d55236779388bcae67ec363225188e990527edbe718015eb0fc2d1f0c230899e6f940319289ce7b349edf7081d082d62539bf94f52fc841324fbcf4776d3b091c56818e847fe050faea186bac0ca2281bbeef59926477cdc4823de84f6fff15bf8ebe729358a8ee2b513f0f4e52509016e006425d6fca49bb32f5cf832c4063b126c0b8a94efcef1df67044d48429681b2cc1bb03942aa0796eb1a2ee8d1447268cbbe31d26bb0607e853c82164b95bb3f2afc42027f7575ee796d66c1971b12dcc535f1920a1d81420df7e7f72b1c4302bb9c63097f4f245bfd9e55ce91ca9af557079f521ae10e7280bc490924e4c9e4633c4c1d65f10b89c2ab9a8bd5a8cf0c08d6eacb8604d08b790d8a8799c271d2ee1199ec33496d9c0f5e56ee11fc031d67fd45284d825cd5dee8c9987cefe9a4114d9a7dff399af14d1c4c3b111d5155e4d4a24a63a4b0d98d5a00370ba6a92c1e2eea9de62d2e0fa1d495c5f16f0c5057f0e4534461106a9c15b364a045a9c12ecdcb9ef6649a53b93637c0c24e9495a9147af4815bc4f409204ee4e0cb274063eecfd437186fb95be19647b2791b7a306bf3c08c2857281b57f1ebeff65529b936b127b1da46b1373a6eb3f7c8c60d54202702f0de414fe84b81c69f68fa5047130fc9ff1ee829f763c2d4590112eae564aa957640705bf33ef4fae934d9ebb352d479e7199e091fe583875063e0e45727919b920f82aeb58cd396506df268a193ea59e77b9cf3201a7c4e41114f67c147b9fa6e57c6a9b14a7f19067817aeb7283eb0598b1be85f7064ad37eccc366cb673a3f08f2f6ea27128be65a75c559d792a858ae3a9e9595dc7be7db816e82b5fcdff830255b4988138a7e91b939e21688ce17a3c34d9419760baf037cd4acb6fd1531b4f0bfe77f5c9b61715bbf7d32b2bf2b51264df8468af6972470cad7ab399ea7671bda7fc9e458b2245ac7b3d59bbda6fbad12851c16aec4ccca476342ec601c03495237b1f65eb5275d2ac9c63751903f08981e37b6eb2ee4dc846f645fc28a5175557c60f0b65fce33e30b38e746b0fb807d2234a1a1904089261084cb4990792ae458b094a1d9ab1ddc32ec9bbb754a86083e5b4d583917af96f4e73bc535a0c28e27609fe1fbfa0dd4159a0ca5ea583b23190872595802b6bc0c0c3056f12c7d748f6fd49d65a042be86068f82bee8b4492957c23eb27eee643161a3a56171ea08cf5c3b08e8b83ab2023262e637b2d2064e3a63d787b249b6e104823e0dcd3b449fdf5fa2305f53c6fc98f28ff3205cda3a66ea53fa1444f59cd077c03f896c8c3ea7d4340e6cad7274d09161210bcab7707b0cf09a001cd532041364cf52b651e4bb290ff44caf1c655937d151eba39941def248d027a1922512cf535e01c4b99d03b7cd21ea154f11b9b817cb67fbaba9975a8c506813b3a27de154611c1dce5eb0b4e0e085d9846f31a56f6eca0ed0c07cfd068f6d05f1ea9af94b85c955fa86508c4f01f2f28dc2ede50a3b12b491467cf6bbf1b5a59e19040c92ac6a679040c2775c7147bc9f44f9f7e53665ca83a36695794391b6cfa1070b6ceb0e7d603bac41f9bab1257090793e1f0888c98e721a029ab9ceb342d92bb6a29d689a450cebfd5111414f37da80bd562a8d8b4d0a5eac6e4c74413a860cc172b0d9f15010e708ab05164e4d5bb977d3eac9597e4dacf901b7f357362c10f727455fd23e9ebf006498d79dfc3eedc8002f4e807ae97e5539f4f04d57560eb586796da0edb287956e4c1fff767926417834f17cba66d324e910bdb0bef4fbabf0a0543e40e8fcd040930a2c45c423947c5db45d02ed4eb046e923087663dd9a45686d2eb5bd3cd0652ec8ae9b115b7ea5ad60e50a0f78155dbc85c9d04118d036941e70f89ee72a65ed9bc20a531efdd2dfe4c5ad44c33f85f25a0e80f57fead7f94ada7b17900e75c9121b875f1905d12ba665b36187725fa45b35e359ea07162725687e125f0c284dbd1ce8408a976fb0cf32dc1617c54cc3e2feda913f235356151a7e5fe7ed2e4bc6a0382a61adecec3b5302d18a9a9a623058f650d0b806990c0e106b6235661edd3f12ff95df3279c34be768f9a40e2c8a7510dbb1aba7c089de286d067f136205b6f8786ef156737e9310b7807033f397d71ff2688c7e33ef4081a9713670547dcdc3d8ad87adfef235fa2a153e993e8b65b3f44defe11566f4b35889c52bca83abb0b1161947e81d2cd47dd4a5ace41101e325fbb3c488b52c117638f3fb08a87046355e26ba79884705b6abaccd4acffe117f63488657346a86e2c59c87fec59ffd7f96cf557cbf06e823a788345596b441014f68474fb375f6cafeed5a834f1c5e1dc34e040401064ad354db4d0f86e5d80c9ad28a33c2a05b2fc010f228ecc50d1efa3d7361e045af61832901198293ab34d382e45dcc320c5840217e8eac670bb63a22bc8237de892e9373020901ec63ba5110bb217bdd93a601fd8029832d0db0d9fd2e740324368c4d9a1180a4841a884e1498bb2ba3f608ce494249cedc90e94fb660a04e73ffe204009dbd99275e761846508db30c2187cb20ba82ceb2929ed19060928079ef748ce2f6ddd8081b08bf757b3d6d90cedf44c9cf38b0258924048019b32f9d10e500664305c2626b2f97b3b8b90dab92b1945d7b7b5818cdb3aef0fe1291b3efc18958579b6ae3ea15ce5bef46ed4c73ceaa387ebce465bb0933b1aa43e54c307544b3084f3a23b82e6e747a4b3a8035f055959e2912a2b14f2cf778b77757f843b981980bf38a2b0363683556c6bb996663facd7b31affa13f5e2bbb3900318b635376a5a131fae3530fff8194a0266f741887ea85147b6a557df25399e445284614efcbae470b16b30c2fce283ae43d4be26aa1ed2b799541d4c576fd6a9c67b98d8a7575d54433c44efd592588bb38f0026bbe3ae89a9a812c4f00b876bd499c7c114b959640e60d80f90c405dcae78256e7bb58585af9e89dba81cc070d3c6b8662db537f1b68cf8691d935823da8d3343537bee93a5377db92c2ddca044ae82acbaa073de7d03732a90ff4bcaa86c2b046729f13188b03dd615c6581498f70584d958f402477f1409f9e8c142ba38f40233584430ca595894a8b9447807c7c9df8476050b7c509d185e6e0dfa0edb500cffb56db97ad351a9dbbe3e9ad6809fe1bf4dbb35cc18704da64730405f2a55e2282a1d785e291f7c9e305adac539ef4d99ef9e5f58e9df14eb9d49a1d878c6f39ce8de7955a498300dfc8603ae3f9748ca42d16321357ea6f8af7095ebede44c6e4e2ed7558cba3a630db7d1e3cd6610a5be178771824d7f2599ac435b8f5b4e773f37e0120cb06f0b1e245419e0a64ff82bc3a6cd616db821c07dec911ff8af55e85cc51ed361181ba7299caab0e991a61eaadbca42e5d96b13a1e3148281e9e0df9a381abee0b44e94da76d0c3e43b02380e1068e3f6bf23861d1f87399e9a97ad577e1c665d2174913ddfbb645fa813266eace981b8affbd04c174f66aa0c587c4775280818b42867d35874529597e007ad0bce0ca24ef8025adb090a5038181910efed9627d6b840a65ee22cc7f7ef1ef9b4ef189e7f5d6f779fcfa89cfb0e7fef03b7ef11b12196ef8a1eecf0d8ea70833fb174ceb4e3f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
