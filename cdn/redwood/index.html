<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2574ebc4216b4140ce817cdb44f3fc5a772f296d4040bb2d3ca6b64bc7738cebc22c59ccf9eacf5a4f3ba551eef465d8b0a842aface618352448200db3c6531f30c64d4d0969c957d7df25178eaa40872a4aa7afae5f1ff06a14c708e17228ab95da73955f2ff0a03301da10ecf7226e5b86f2af40b91b6c676fae9cff6891a4bbb1a02a132fc70f2dd7ffcdd54163f8bc5937bdb846a185db18cd52dd2eaf02b9e3d6a7496066de6eb8f9716c32f6ab2f22419af4c98f4abfdda964d0558db9d746006d524b9857ee01719c5efe4b7ef913cad13f2c16d447aae1134293b856e38917ad139c161cf4db51210134bdadb7c584f4d89d513c0c235a09e21417640c1bb7a2f9f1fccedc10323b6736f7ffa0f769b978cde6cf703c73e01208085f91e4fea60c5f498ec1b7ca817be4d57dbe30213801f2d4a6b8d7e1cf91b05c2b6a498ddf54b9238bd2658874c118e0868a4b10c70b7e090833696e225293524efc9db93441a41874cc62e0b015df1e701395c3d18afeebde1370b4eac5ab6b47fb821c6d03997704c1c1c7b72ef321c7cb1d3366d913ea86741a78dcead9264bf12209d15588c6d20484c08383449b32d0c53245bbd9a68eb19279e47d8c72ade6e10e3d30e39b753f5ab2bf1121a8cb570f58869c3c6e4f90c0a2a5b9f925076d21c343c73756f55acca45948b64c5bfa620f122d97e4a1adabaf2ebd3632ba8b3ff94fc0e67654b0bed72ab92da3e8a8e381644f24685eb48e1c2d751b1a3cd82913ca0073fe794d3628c0a9bfa1de89746ab17fadb0631e245ef5b4efa92938236825ed076c70062b55765114f9f6939c81d1bef54d5e9feb4811446319c67ddf158a976b639d432a5c1eaf884fcb3d4a80a1193573f3e7c0aaa96d81c18edd23c3faf53a2db2a7657976e122cc7c8649a7efef103830d236f123906a2ff551f1e0c8a29d757ab73d8684098257836f5e1d75a7493ae9afce22a798e681829781ad12c90497abc8b1e271a8b9dd5ecc0dc8289c425370e0dce9c34e5d52d63a9d6995edc9681acf6af49c61ad2b1906c127439f3de96a5ad459bf7b0c980c6f99ff2ea9058c8ce0661343015dc68dec1895391ee34af1e58adcdd9f5948df9c544b1a910e5d96889ec6790c152c57eb206d8d25313e4f27c93f4d419de38a14f9480c49da7480d44121bee5f5e92b9638bfff73f5359a237ba0186bdd8e74c588e0e66e8c253981cfeed09f272b5137fd8cd594d2d642ee7d33404ea21e85edbdd69390ed89fe389bb545adf6f4ccabd0104de8d46547b5296011e30418f7b1d200e5f4efc77a4cb4ee758203b2ee9faf4af65469be71feb2e50d9dc6cbd03b77ae51088429db5476ec2d77882ee6aba4932c8de1f7ac52c864d5ed1d82b78e9312f8f4331b0bf13405902ef242b2dccc15e99e71dfa881e7f7ac9abea74df6883905cc2acb04ee8fe0b251974e3d468f316b1736cfa98b4637b659a48d4796c5738441842c1b1f8daa27866ca1f14a4ed846a4af22973612a38a84a19e4a3f4237c34db48f2afe388ed8b95f299239f63b86849b4fcb6b5034474465fbcfc2a9ff5768d7d1384d55db035b16f2a0cf7c4994f8e782941e560e0de73505fb3b91611a25354e5a4ccc1e27f355344e71984fc41c455883b858a8f90f2475bbfa9e937f71c24f9595c4c9e58b93ce81998bf36a985ae8725c13b5c0a0b1acb0c5acc3de314752f3f28b98c17c38753ab550d8b6c61943daf394e480869be8e251a131206265dd8ddc27d780eaf99a5a55aad84c059f9c810ba8f7a166b94c920163103ccc45b64636de536d85b6b0beba2ef7ad1184ea17e9be26a23f353d9e8ddf3f2651f4c302dfb3f9fc62706ada33360bb8ddd969a6d67b950bca2a42059d222ed190ef07321ca94c36ab06a83d1acdeb7cbde4723d49c2445dba3c2ecfe9551decf4b90c0471f6a56eb03e2761b89cf4d17fc62750246e5afc57d7884f0350059b98482956e862117a299e58b49754f4dce6f5ebce703935df19efc2ff3757b4232e9c7a835503285358d2e89295b891036e06b636ff5768c36a0ec57e04705aaf77150d69a96e30b22d8f489a0e6471f32d024c34438ca1b78233da7f884e66be4e9358a5f4f9eff5a25c624ead1cefac3281358910a9490536b8c08832f044ba598edd7eecc16544c3b6e7bb7438da80fb08ea5bff4d20fc0f5743088807519ec7fa5beb3cc162a672e5162092431b8cfbe6484d3411cac94038f35273826592456fca08baad4c62f9103d47b7a222108642bc53e471e696bb2f0e4a45a6ae4430c6eb0e9b288ab5e11f1df2e8f087c8a54102904dd075d87ba391480481b22caed108db34c5603c1ae167f7b35a26075f21e5c571a8063664b4ab565c2a59ca5336566fa3abf6065a7465394b8d92023698fa4cafb44b19299118ea5d28387cdfb3acda6c98b70ac9a67ad72f6afdf6372801e8a55f03fc101c05b3f193f851916cd3fca7214a90dc61b7bdf67da387e036abf515060ed1a130ac746ed4003d5c2481b7d2b361afe453d068e1964095458d0bd20b4326b3a84adc8a5851f8b96efb01b5d3b662b35fe8ab8ce4263dff29b338c3706586b0688351da7ec4681a8d9e761b7a640bbf5fdd71275c5114bc5c1ee36577f6082c51d90868eb81f64042e9b6ec7fbd562c009bb49d3f8db1e3b56a423bcf2b95c3feaefaa0655108572e45a03c1a830a3ec11fb148a1ffac7e55960aee61b35b5a2ad87f56b8c7b9a42d2e14dcb7b55020088efc5d37796d27b7966579cfe15e45a1a4ce50c81c263248297a08c98cb1f706c2d067393492585697767d9967cdf4cced1488d48d2b07daf890924fd6c5dc217bc9d6ee68243e58d26ed72f726c5e70a38f15a5e4629bf1dde369c791d6666bed5ac7a740cf19b7de08f3e8a5c23b1a7b5bd5f0f44d3960fe29aa0576c6f362ec71b4950a5a6585e00a343fd7489e725a3c03cc1f9e644f2a3b6d63e9df273d3ea8d3e6073da8672f006c3caf3638ba6478596438696505d53e465a411e0738bb3d0458ee2de9ac8bcff6090742b051e231a33fc566654333459cfd50c599ece54da3fab0a3ab1123baee5dfbd21518914033f2add6ed5321b4183f7bb5f3f6d224f8bf7dbc66f262d49b3a4adb5c303693d00a357e83159771dda9e42f2db6e1f87686078ec8038f5a6fd06bff8ea78467b152dc30022620bcddc87e27e2a84d4e0e7118861d9b44c5a5556232610e3c3a7d56e7af081cf0949cbba56851fb3c12c8edfd8952314b0091c8f8923189d791e8b4fe4797ac1c8186b460fe9a47f376437879521d03da275b4d140296ceb13bc2754213da3dfd87a1cae44218036695dade9e446451868f1e5d6ee93e6516ca1a81522cc56a0ba8bd608b22bfbbbba96ad1993e7328447aae6927549ee8a98a776c0448703de7e6ade76b2bb3089be252545a89873e47a1878ca01fcd7fec4b1e9ad3ccc154312f71544b88aa49ffa8032d5012a0dd4cac6e9df839d25600cc913e936508a04b6aa7e550aed0cce91250b47b140078fc8ed26b3f81d96015952637e0c4fb4e3b8b33f00d422dad2f4a84b59e730259829c1990325112f94991e182423c882db25505ecbd108f028b0eb3e6d141f0ee6b813970b97cd55969dc60fa011212a41d2bc05c00ae5c386135b28e78c885f775a9d4e509a60d0132a09284d48ec105d23b00a1c68190d1e9c8ae7735b79952718570ca79a5d79a8fc16478394282cbc798005333d3177b34d287441cdd3fd16126b127de58d90348c8e3c45cbfa86c87edfcde3f0ba731bfbe4fbc39ce65a46f4f4555d7a2eea6d624ab4dd391ed8f2c3167667c00cf4b2cf08f33986804b9291ead7449e9487bbe52a7e9c5ade29b5b2fa42e7b857c508126d891f6672efbb15900c4fd97ed49a6136d1cde049fac67ad428bd29264bfb9e3c0cb738a7cad289a78bb7902bd5d92ed1861ce59bcb093d0c1fbdc7212eefe120b4476d63998e90cb5f21a370d4175df70276ff812a05790e4da37d732bda5187014e3f1c4122c16f1515e18ff0ffdb75c8590157cdec77ca1a08d7b882580dbf8bdac69933c355d28e7acad4948e19de9a51b8f30accf6177cd1ea226e5c93a42721c8f51df594426a4d025c3244c678bfedf6062cf124252f45d501496c431ddb52789789c4111ece9f851a19b5101a1967fb70be9f68737654a595154441e69c5b4a8e2abb7c398b8b569080e95e72fd7b5c6200f2258b0e48db6639ee760e1132752bdca37d016939c1b661fd1c7ca8a323eec1cc9c4a413cb2690a9503c550fe8fb67a7d08956e4ed2175e72478c7265df0a4fcb4773024a648ea7f9c679523b70164280fb05c098a9b35f0102bc7c82d64942e79b7d1a5071c106b94ae93d6e7027538dd432739c2fba72d4307e1839975c74bef2a613226ab21f2e5d273949ec65ace6a66a1560b454c8d6f88e38fb5631433b67e8722b0cb3085dc63c650e041c3c1cf9c230908177637f33cd8926dd615c4f813a8f8c520edc110655547d31f56ea49f91d030c30110ead845da19a52fa40b876cf092bdac26b9e519ecf7dddc5e971375d29481b721563363ad3557982197b28ae14fb1b47e57d8eb25177fccb280f5cc5f939a9182db45f4a7d2602e26b9d09b3e53f101b08facf2ede2624d60b7816a8a5db0b466af29ffe9b1d4399c07c2b37af34c26d3c79500f5977ef9380539cdac05cad64dea2e309c79529e81d2e4d4e10dfb04bf65b683ef5074b45b96f38d62f64ba5ac97c87d8f623f9aa303e2e31e53533c5ce140854ecdc31f0c996718cc32ecb53be60c4d8ed01628196c043be3f746b58b523233fe2735920303f37ea864af0c90fddcce0a0abafbf71ef1aac9243e9aec3b0f64bf7873e067c57149dbc2a04f50e32943bfe5b327c907c6ceacb75b2b3575a6fdd1e8f54630878950b75b8b14d4b5aebab94be9028764b205ef88e0825741cebc41e5ce089562fa7d8625d3fdc3b439b89a6d11e72d06ba329bbc34436303bc081be791a12a1106ca0c1efcac86b96d3c65ec6415206f74c1bc81b5e04b9cd3a7f22284b0c8aa4e0418326abf6361f15e12647c5e30ccaed950c13d0af7b619aa01aa8d936ee3554599591b34ee0cb34c1f635076b2a195b1ae9b8ee4043895a637678c242684ac3c072c645482c398ecbff86a9b4b2c5c93e59a7df29020466c6c3f2aa2de8afabf5b7078750132c6757c504591059550c472fe2e3e0106dd30731452f911494671f820ee89c4cedac9444732d06a046bd9de09d51e194fff6e4453bec3c4543ed2a73811fe353ec2d08640257457944492322d5a879f25c019c1afdc006f7cfb330e3f7ad413d5fb804742c7be7d77749192ed23337bad860766f670a57983f8ff878610d5a4b0f56d18500a08ce333545405f4ce259d20cad5d66e203159291c8cb5b5aa2002e90a1bc1d1c80f6b28f4819b2bd4e0f8ca9e7e2259be631fcd8eea0b4ece3ca16f2627b5316817bd63ad08b498612442c6990becb2e1a1b29218fafc2db28f0e7b4d4e593213dacc4388c4a39b03f84d70dcf40c6cd1271d5644bc43ebb6b9a72bd5d09ceb6d090c72a8205c642f600bdba6db76390d3421098e8619c6439195ec7a6b96e469184beb27ed7a7d217f8c08f7646a94866d267be9b0f18956170d0cdacec60ed7319466976ec9b4e061920e0bc6b0fa6e178ea0d125c63bd9218d7b83d6db6da36c4ad446fba4b15660e0ab53cb01f4c745d656ee2d58bc244783a52fed4e92b3c5fa4206d642b13299542467e07cbb10b3507dfd8802bfab341456998465d93d690c58bbedd755b6ddaab21d337ff07ddf52d596051e567f217b893a640e285e9bd96420028d9e78922660eef2df33e73f74ec234002dd291cc42a2f05b90d04037789c8b266f265b2f7f6e24f804ca0c00bee6f4ba6d8ccab0831c8f02a6c217c2423364e3931a65e6cd7276295d83ff3ed4dad1ad396deca0fed20f83f9dea76906ff436f5389983077b1ca1307f59c6e66edbcfce8d339c53061cb8e914ffb05a7369270374542149061018bf1bbe712b4935ea8674faeccd60b9dc33ef64ed9155dca9c4bb92557368358b0ea2e2cd898e887df5118346e7074b4b448675630049dd713885bcef09be32bdcba071fdbcb6f253f7fd89a7e4368a35622f66fe365d2694f3279bd621ad0ebb78f5e0a2a754c827dc13039251c97959726119712b0c98071dd80178c14312e9894b894b6335fd340c3b4f71526c17f52625e6ab21ae9430e461ba14216b121a9875af5fa50aa2193f04643d4e672620b76505e5e41ddeca43c3cb444f046d01ed9f7ad005bfb0f4795d2734bbafc2ab45b1048d6801d77ab6f868622d3dff534bbd230bc09b3b3c14b6641e43d86dc97296819c1a7a581f06369333cc01d2fed08d5fe502b5ec122a05ce48239a36e24cb86bd8fff5c09d16e2318a634a93b28047b692e6d60bd18bb8fd58ba852fe08eaaaa4af73147c9059e4e4ded9b93945eb3c33a0c5126fda6c0f3399ed58fce93f79654bbb7ded9dbb090ea3959b4648cfdcac1403fc8a1b22b80a366f7fac93b9052da8a69e0d878f329b0e08c27fbdc6fc05b74e8135426dc731d99bf198f317fb540aefdbe86e9cb0fb70180721a1a4ccd96b5562a22a9af00648d106d86960541eba576c5c5f260e12f548c5277e88c7525fa9b7d089d132e7c5570e47c6ae32c315813af0532127cea0dcdf4fb58a5b795a14275a3410c57d6b542a27c9c4e20220f1108e0416bbca20c10253533bb80d1877e04f42422037b001f1fb0acbd5d921453837bf49bfd007880137f44af127aebeeaabf8f1b63aeefcb65062c8f7989984020157f62e0e8a4afdae9363f6b862f22e19247e4471edf2508013500af0a9f806eeffb0f3a2ece0a42075fedd670fa53b1a71d44bd24d51eb3353827dd35e91f45382f5d3a5e57f6776d8ea3de43d8f911b83e6b0a257908bfeb17b0deee7bb444786c7d360a2d9f95a91083124ee005112bf4e5dcbd8289e345945d73de0c396d00dd9bd3877b10ba136126d9bb1ea6412f1071c0393d42ab4d268849f26202974f64500173f30902924110bb1f1394a5e70263658f0a080656bb40186b51bfa435706c4c55a540a9c7f056b859939e32f8272d73bd797c80ce662e7b105bdabd2ec7ffa8953c7c648bcf8f7bd6e325858e705df95722013802f8d179b4c838d3d46a60ce8b61dbd6568bf28c182659ef4832d7a7fb2ac3c70db9ffa412f58dbb8653931d08a50d2989b14b56cb3009d801ffc0d6c6c51e39c8d557b5dc081530d719205aced30b42478cb772b63818bf5e2593e4a073febdd071b910d730666d2e9285199c5282d329653920d63b810cba60845bdd8b0f873f26702c7c110f11746427407e19ca29f59e564da247c905ea647f1b0541299f752651561dfacd98638af0e4f668e8459793a3129ae92d168317387246ada73af397a0fbb5337a8ff19d1c8cd8ab6584ed40886caec4fa9294e81bb3ccbbff21c7ba715edc4bbb9fe73c41d17aea9923640c706a3b42ba5163cff3f3518e36d936ec9bad47b3be8c12f636d3398e0a06e867ef7dbef24d63b9f019fe7c371fd91975f205ed2d1b18790a2903d5b9818a966466dc063b2bd7f8fb41085f47936c7d9da7569e450e190e294788aab71f101c6a5caee9b6745e50b0b1d4abecdda952df530603741572dda700c5c61619f8789407bb6067935b070f6d198f4b39ce93cb3f6ea995a397b016e61c48ca10db7ddfeedf653c353f2d251d7c5892955de43c3772fcc6ea0c3e0e1e86805b7cb728c445ce570b6de36a1a7e2ed0e00e483a624477787f441329f58ea8dcf19ac6e13c279f6b088ef3dbd5550e868982122cef42cc665435561a943527d6e2e02a91a78a07fdf3e12819baa58e2ae80be372ee998b5664d526c5a6c53956ce20cf34731de54535e4ca922658c8caa6542df8b572f135ed11ac35650a3c488ecf14ec4b54fa7bd99b41787f98262009aef031b42e6e7c99e6fb9b3cd851885a61faf3258d91a6242b1908543812068bdf0f3c63cd77d8263c0bb58804914a66d13846c62765165089c5fbebfc9798d67bb0ec9ff31134d592a1fce8b2d5508024e90b08f1789e616d7008f69f2436ae4c193cca18c4e6ea7fa975aace9037be6ca510a1106750e9d657b6acf71a42f04f36ce1980e603af9c605cb0e5701f953501e46d85451c2dad60b459a46af92bf9a759fcc7979a332cea6689afc0dddfb43409bb66499a7d106bf1bf081f0220f11a8f48ad27726f46973a16328dfe8bd3ae1a4bb009b317f31120e4792578ce667490d9ef6219330427e86e588fc425b27dd85001a296a43b6d4545fb5d81fa5e022a79b06f62b32368b0c4af98baaa27cad81cd5d3b043bb670fd0bb7c540d7686f490f6e07d03476394f5c57bb41e80965455e2afed20960b6487e246e9cdb1b96e64f2793071b579128ae84ee98b97f3edd3474f167503455dd46f96e623a8c034035c7ae61fdf5913b56969410bc0e08e865235e03fa3faa88916d8199bc2a85a63f93c6f2361ce07e07a5ede50dee77e6592840b24e556cdc209cdb9368e4bf41f4a96d077fc6f0247487136ed56e573bbc691745299cc99114aaf3b0f683a84ed3e8600188ded42aab3cadd4b09a35a421857da95c40a641a213d60ebca8900c8bfcb9869fee0b04e675bc9c01462f428e10f03ae32e31f54734d6088a9ff53c4aa3edb17029c8551792bd727d0672f8a895479abf06dd49b1528e492e24cfbcd1f5cac7f373de753b8b73853bcf7e5c2b6339dfc53b5798751a20b2854bfb69cf119be5bb1a6b5b6ace39bbc78a3d7496ead47ad901ae85cd9ed514d4b30e865431da8d976910f48fa95a48a7bbaf0146090f530e8a4411acb4181c6504354438cf61384da5101096a354ad5f8372f3a53836d49773beb25eba858736e1b8dfded72f729213911d6e06bc9ba9153090e98463c68473efd7ea8828dad17f562e83b82af1f5be4cbaa0b02427665edd6a27b7f792f937384a046dbde243079878e233de57a80cc9afd5007f0649ad7fa7cea9ed9678cc0038bea3333980feb6ce75667ee0172ecd1821a480a5b0db6ac36e86168cc43069f61f15bff9b9652c5a27a09cafb1554cbc5cb409c2d4a2491caa7fa0be0bfb1513fdc119bdf9aee22ee3b1b1f3af2a2c53b874fc408a73074055cb88fbd74afbf62eadae1b69ea1b4d3093134f027f0219d0f16f3688878c31d3f13e06f44b47eee0a14006fb85b32823f16605d1908fc57577940ab0a44a7d355eda9e0f7a6cfdf7ba78cef80b857b07e9ad18086ae84b5d331de8ba69f92f38a78347cbf7b4314a41e3ea2917852f1cd2236de44d708b7e86bcf687812839f3362f8fb118b905b024a68049268ff07ce2be84547b8c960d54f2189061070edf787f3e191089458c8224499e4dd6eb5cb6c921243245227aa92413d4cee2a5fe6e3cde9b69e6a6769fe4fd8b5fd3612cb1d61588964fabc9af0b926fa27728bd209618c5fd096736ed27aba973ce3ceb858ad6443326c9fb3ecb1c11e796ecb5a4719c5e0635e5c06fd9b5fc4a08455c95c0d37cdbee08738521210737ddb001f3b313552ef40386b8054d970a0e264f35b6418d05b2f8fe404062d176c7e5576015bffc3ab47bf4f357ccced0f5ae39a9805c9e8e6718ab6a044bc76d6d63406244cbd8d73ee2ebca5dd2c6ffe2ab81d8970f88929ae36e43c0ec9d8e2dc167f0cb63ecc90a5f9cca56214d010de5bbab958d5bdd14bc43f68d8c76ab2d4c74fadbee32810ad97d3c2290996ebc6478fa0e50e037a91b14a2198df6404594e2e11b1eb0151eebb74dc31a46d340655b8b5cd4a0b9e3881848660838e17768161b0f77d338b92635e170c4be50fe624eb1ae4293478196d7dec07ec962a9c22471bb6fed33808448b22410334dc0dc04bb66f4ad06aced0aaa317a7b9abfcee8c7906a98b98e0b0f41c1b3ce1b9f4d3babfadfff2e90c48dc872de7db8e34082ac3c703153b7d7558943b219febb26b37ac8c82b66f7d84ab438fb73eafc8bbb01a32c75f1d7494bd99e79031a688d4b62872ba00670bd5bd2a746375b5c27776da33a61b606f1b9e331d1b00460722689b828214b9fe9cb010e4be507db140413dfc318e3698d7b19c57db20b5513a3088285cc91c7e64b7e42bd64a9a62ed61583efd47956dbcaa89a2117149bb7fe2b0f36ef5a7ad9cfca0782f73ff3127861ec216ab32d4673e19a0188a50aae5d591a624693c727bd35413a05b07fdfe87e43bdefbc2ddb85a28632f96100061b5410ce331df06896d6363fd107b1586eae668cce7fbec13d028a5fb1fbc0de289b3c621ede4c0708bc1ee5c29e4c08e4be3c692bf7470b2c339f6a8c24c21b7236b35fc0e912c50c71463cd35384d1463402e5cf978b02e9e9be7b329f2b4a22e4ff264c218e055abee0f2751520be3ac221f58740b76121bda1f495b3de394a0ac94e2b31de035a6a7c126890a9cdf9c0afc6bd2bbfbd224a4114e57abd51ebeee2d2d88ef1318e877c99210b7b6e145b5e3ca195a163e7d381de9dc4fd4de525c0d9f8fae82209112ae5cacab771a887484355f8437a32bbc2075d277fbc881a2f4b004abc981c38bf64c4db28e65ba504a2c6cf22c4b4b8157cacb5635d42bdfd70be1fa5f1bd9129a336a5f07c534d2b27371d4b725f4edcf12b573167643dc3da96dcb91b70dd0603d777db11aaaf505a22b1fda40d24b13976dd02208b2cdf97b230d49b43bd4d55332b16802c2fd4e10d34299d9e6c1dcf6a029ace337229d89cc5dffc798dc1a159f00b8ce3f6729d6d8aadbf31130ec5c5d3b1b8b05db04e7a039f126e8eeebed5c075c77f6543c4b41e3e7686efac1159ff7c0e62948563641fe32dd1a3e2d8410658229a58b7e9dfd1253809a993f6db2117f629a37b321889ea57fddac39368c77c10523f6b4ba3a2bcb3a319f0e99a419be52c3e69b998b572555e1bf03995cefd05c480d6c4e12091c648366165ffcf7105bb9dc5e8e46a674ffd1ada2b507e08a054558e7a944e33f82a523876b984fd23fa0d753220bc84596742e6b146ce8675e8a17fab720db50ec049c4beff744118c545e90a467205cd63842f0c7521fa21b3416e043eccd4d046c59558788c67767f9b516a43a55177cfec85a0e73f6bb6b37d995bab84a7d46d33d23d79d3b84ac7b6cb9124503b5de32f9e3dfd4ac5133ded57f454160f9d0474feab3f96d63001c8fbedfa644583810ecfb402bb2cc43e9ea3c4d8ac990cef721895996f48641bba18379af5e3d2b1691a867d4b9a2bb7dd4aee1a9cd84953382d7fb3f343ab667ad8f98802fb3d7c936abe142718ea50e0240cef15678c5f2276810d659c8e5d7ac85a4e51a7667a7801ced379dc5c89f52587202814b53629dbee44c823d9780f0bc70a90dbafe574451414909cb4bfec5f0cf470b715037cdd1b6047fe8f1173aeb667aef47317c7cb3e243d310688cd37dc2f2d0c56ca390521b6ecf6c20111c87e2cacad90674d2b730f3af6e3741d4bcc6e0f86a2c6425397a1257510b8287d004d180c4818014c8af271b2cc3923a77c3048d165ae628e8407d11e5904043050a6614268e4500a4c6a21fdbcf17af61e87e887ac0f4ab965238e399c5803e13eb5238b143e3f170f67293d1028323fb8c82ebb7f502a7913206dcff9d750168913119cea85f47aebdbcc24468ad202f7ea4de6bba532d5820cbe09ae528d4519c018d3a520263ac918f85aabf66c2d30a152ab4011dd308cda0fd3f0844a1e1e52a354edafa6fb14ed3453e714b15e4541e09256a58a754814eb3c7207e6be6fb9dacd008f02c5fa82f2cca69bc379ec619d66a08ec26351d51e734422f75eb0a0c0d9c4d3097fe6c3fb689abe70a63bc9cbb638ae76e31fd099e6ee94b76017f853d778a2eabd1b5cc68d84e4c4de47e77275237c3ce51755c7288524ffbe63d021b6967b391dcd0845b3ef6bb9d282df80c288008503e82496a91dc1a1e56fd30549be86df9f2f9584d930b06ef303b5b86a600020f10d32b734997d3cb26bb465cd7ec8579a7366faff3660c106cad1e8ad31686df7bca9888e75676b3356ed3cfc35216a875a8177200e61ba0d759ba3a8aaa7ea59ecb88c478284af4541bccef7a6bd72eae3e9119a55e5532437f1c50d765dddefbdbc8825ecadffc9a12127e3dcdbf4c5322d1e2857cb865e95a01fb82e1e987800ad3f28a9d540b90fe6f84b9e59359ea6f48cbda5af1dbad7ab570502c6807abc76d050ac62e16ce1f5b800d32f72114f7e690eec3944a6887d9be5c207f951a76e54331f8decc32bc67c146fbd1b214db207f1d829ec056c14244f15b684b846bb6708b232b4475a72ad735818d0078e41833ddc6e168a85ea08bf4156944bc06c4e12bf3af9b705b138b7fedd41b73dfa114d2c4c50c56ff636063a7a60c282051b4bb7a7881b7d80f91049e6cdff9ff282104262655fbd6136251177cc8ed2aa45a2114280fe5240a0d01a7ab21d5c0e542fbf06234f8a5cedc239449e9e6a0789bd4754e6b2b35c2103f2a10ced1c81d1c11b744ca492dfc594d45699fd38c465110d447f8f73e711414aec7264b4ab3fab3045cc1cb853b176cad6e9065ca8b95773190b7daac4a548a349b5a8d852fa63189ee805702e6c1f806b6e1c3713ca2e714b59bb9f5be1e073381f8e900fb2a1fd7224a9789374ba2ec79c0b3b858a672e676e7ed7c070472d3e9832aa13af434f3b7258e7ea0a2d3cc1cf325ae482f6ee3c678ab417d0a2d752b7620395fd813f57bb6f1426f9349b2cd9227e7a68787c75f78edae136da604302a928d786bad5b1d3a9aced16233865b3ac6d070fb8e7b8548e13920f0e6045adb4a6ecc2a7465266adbfc2c9b7053b240d09c12abeb47e86ec315ddd15fc04233e41380ad731c8964e0c17ce247b14b8609c784165f57869551544190e62ea31d5e54a5605ea030e28254cc793dca99f2a74df18895952c79d62b3a34a8288a0e9660ec954b858db08a1eb6c3ba6bf9ce1437ea69eae8eda8bbcd15afd71fa0042d1557542879aa063c37243a06a051ce4c397c1331c7ba952fb67227a826b268f841b0edfe0da57db0b1a3de9a52cb5697d4b5e4bd65b61fa14cbdcd80a10ea67ff5049e6343417e17b15b5e3ebe53414d939479d3db042ccba348ebe5e1f0cf03a8765061b23256a02a90d4e40c8d7a0ffa313eee450b661de110a564cd9b06a64f00ec32854cdca365aed22812fef74f5645763f5565e7637f6401edd5c67480110857e7c8abf6e892fbd91a1461be5ba0fd4903a7df5d03f0cb7f7661105a4d64f9b01374296b58f062916f38a36231dd8b91c7f5ba41652a3f85aedea3a5ace552bbf80814dcec8695d5ddef9ada29c25f136aad22ad7505cd08703a538ada294064a10df228f55a73fa9f862473690f71e5325ab17de62cbeff60e2ded9fa8d5684f74536e39add948647227a61c7792f69de00ab94d6ecb77b3960b5ffb0f2ddee164575f6cc4905e36d1deeeb47f19b2a1a15068198479f472e9909a7bb2cd2e161426e3d504c5aeeebdbb365094e98d0e872647116519490fab938e2ee31224480fedde76a8d3548a16ae637bb5edf089a48da5def0fd3b93afa668b82af8deae4b910135533dbc6447fe9692d47007ea7d95d1205f3691d7b73eedcab4013426938a8d528fa9df433fdd637c0f32fb1930d7f804a5e4d2a1c41f2830a56b7aae8779c541ea05b8a1edbd6a118082f19e0059ae75bf81fc5e356a711faa5fa8e53755a7d146acacffef6ca556f86a8f9eee0774100efae7bf9a3100450204fd395c02d15553cfc9665dba28ec7479ad26755b253b459eff761d49937755f6cbf28af1bd2fcaac441cca3ec018aabc797c6aad0bca9415170dd87aa84b3dcb79c1f34e108ba68ca18a543774c06d08dba869b96fa8ac41ebb33bb62d5e3525dd9071c61c59de1503927c30e97a4bf30bf4994c37322dd332dd21877911fd2aa6252b6256a9e4ffed7b163cf30f5ba1cf1535575007f4c182d5afbc97fbd2e78d5673ddcd955d32c7ee0dba033c5a9be0dcc410b88c58c23ec1d879c9c86d5be1826ccd8fe28b4afba65b0d8ae3d514063a261c0e1a4521ba2272fc5d3896992298fbcfa71bd1a1dfd8ab8061238e94b267cfcc8d9d904008c5ae4913fc41ddc15ee2a67ec80af922575d76eed3cd76f6c469a2c9564e64fcc438857a1f6e947ad414ab25d9b97526dd496c488a017d235510a9d4fe4ef36645121f5d915b3da1343f76c9d2df0911f7793a0de7ffcd0597741db74cf12c921b61b8f29e7d5c620d2ea49fb7eba192151d7d2ef3dd88f6253e56c2b1838a2e0fcb9e0a44a2420d61625a6873edb8e7502a661bbcf3e1089a09e34b063850aca47b153597f7db6324bebea87e955068eb2d7ba31dcb8b1b12510143ddb87b89e1ff937d12afebfea5318b3f21b3492c80820be16f8c97675439e8da498c66739af7b29abaf2402c6d7d8c73409479bfde2b15cb14a27a355f4da1ad99d779fec259a8f19bc7febfac08e03e3f83f0a266523fc584db24bc784e4bef492763b2a0a043ad32d1d8533996d142afd80ebb3db346d3528bbacd1bab086a7f7852b341b7360f927779511fe4da1c1811794cac653872d1503ceb6f36b1e218486c4318ba180e2da83ad3061e8fae7005516f330817c475f458ecbb2356aa289a4a3d370504114cbef353ce8107685b527609aa19870be706a311201c989af7d3f476ebb624677d8ebf79189347e4e472befff38abf11dd487668f637ddd84bf8f40d74fc4ed9f0559c333d5783270a972bb4cc6406cd1504dd9212625fd17723fad60b3e323af62779925f340a6c1fae74eb1f747efdac2b7516d3824e7965178f7b7ea90dc4420ac66862eb02fadfc9f95e247d2a8fa00279add34def99ec315effd9cb3d5099572113d88502654870abdf80095c3e08995c869916c9561522ddb1e0169bf8cbe4879e50276d4905207a7433f6af2dbd99f7d96cc701754283d464674f8c5d0ab9e5261a77d175a73f911414fa61cc5dadcc31bceb9f342e5f681625f0d07cf064e150e91f9f60720e2b2bef24d5a718c92c95a9312599906d5ef183dbdfeb6d8a4e7444e78cddaeaf05ae0c309d119bbb1f23b682b69975a7277d2f0622002324af713daba3f4326db03dbe8ab194c70699efd91120e4d8d373a1fe337d0b01aa8a4a05c032ccd6526f2436cc98d54d701276bd5556c6759202d33106cbb16c2134f41c412488603b44c0689c3d9291667086da6eea04cdcc1bd3aa24ebe80060fd3f37fb8ace79ce0d032c0f52b040ac7b962f0417e16e0a63833e9de6a4178dc3a6e6f8adf523a8bfc46eabcd91394899bed59c75aae9ff7da0824f0903387da536c5b5eb7b6f9197ab59a7b86b56c59eaeefcfd2770bfa2e61ebb0b43ce0c717bebc3f8aba73e934f9b72f76e42db5337919204119a0d7ec5f880026b50bbf180fa354de93b16611c7560b3d936a784c5219652835b9d3db9637737e0ee917c501db3e3aa941fd5fc154d7e1a6b74a56265b10688d919ca58adc147d90f82b8deaf39bb57296bedf024506ecb337238f9b06845af9ea603eccae641a8816d576365b9f420965b19b2c293e112ba2078aafdb43b14e93ace5ecaf8ba82b559c39512ff000940dbb16e624b786daa991f125df46a35d8c0c49bc3ee980d0e9751685dc87825b8c760025f5bbf07e1e30d6d9492d7e0d12c734053bb812f87b7a9e158c2ff0c7b86f9a3b4a74378d5d28e9a67b3baaa7835024e66a203f8915c39d7809677984cb8f16a4a58b10f0a18d24e41dc4ee9bced89f713b7721c18b9439ab2797bf2e4734a3c80802fa2ad1bf021ee4577ba032db80fad9c8a0757b239f60de4ea19d6fb116d92350db13b71846de37be80efcbca62a552c52ac03d9ed2bb4f1216715e5e2ded8f95bbcf8c4d6937df7d030f98ea96ebdf4ba912a31e0c7069daafd4628d88992f87faa038b6e9ffe74a88a5197b155bda8d1ee043ba087101c84343bf2a4b07cef56c79ca19524527a23afe08f0f586395e53fbc6c3c5d151ea7f0aed2cdcecf8fac26d8556704d257af80ccc6a33a2b1c4c7da445283fc7ad0356f6458cd91ac63993e5a16218e49e144403cda62b818fb3d9b3a95f0cd115caff9fd45ab8e97fe802f5f831976bc59fe1742caeb7876d1db0667d7a175816e77e1d448546f392c6eea02c3ff2cca987e2f2d94553e3cfc441d0fde63db94f91265059fbc79fdc6cb46eea84430b12a49149463dd1d0280f5f6fec53fdf44f060776f516508abe6d3bbb8e5f61e09a022ffde1cef6dc472bbfc049de24359a87fb26bc357223a5c8868d2ea06c6eae0ef3635fc241abeb6fe4b1d6d28568380f2a2cb54d377d96aa83946c8c7b681b3771b01cd65f5bdb78200ce1031ab9650555160e4ce801a270dc8b4a9b524ba7ad48050dcdf49eca581433624fd6ede35f0f27b6bfab1a572eb8da9d4543fe45c697343744508f7d25099055d278b60f7903f3750c6558400466a74a472612b052e5129eba0adec6bb48102abb83790b292fb726bd9e2bf44a31d5c2a63b83e7675736dd1c902c08ee7d699245b14a45d38bd822bc0ee92acb5709dfcc7de607f6d1a5f879b980e5043c7f8f67aa3e2880ea54e1139888448358d6741452962a6b3c4ca67c856477eca0e03a9a21113c7b0627c9a6f30ac3baa5c45b511af1bde5781105b14e748435e948550ba13438a44f8ff8672f79f996875e369aa0888506bfcc6df3559ba8ff5d5ddc4914bd0f70e02fbff219e39e867e1ad0e3f92333dc108a708e6c873f4c19670b5b4dec4a916275f834d1e954e03df21be96ea2d1add24fc3b9106e393dd3ed13b79fbb7b4360e3ab376a911b7c609af15a23434c7f998d996b49052b60773f260e8481013c4860470807e9824f34684d6f7d6794ed50819f4eee793c0d05e7a4ce75d770fa91dc0fa79e32d1f5830f6f0fae1bd1e1bc18d3bbbede59314abb05829a6eee0d5ffa6c632104b7f39ef074e54a24494a4593213d960d3a4900fd6df72b969a3b5b212dcd6272648c084eb3492e632d7e41cd8bc79ea14442ec379c8d59a2eb130874639db1b9596bc0862d733adf061c9452fdb6232c64e4d89727d3ab77868f47fa5621ab4471910852447d17174f71fe5fe3ed8261cda45c14d5cfaf0b8dd7fe165860eab2b996c91f21ae9542f0fd6303b5729d882a47d42f86909bb23a40767365fee26538a6e6bc4e049e8660f6b13c5890ff17e29aa29ed5257374976fa78e8d2921cf9db06b4dd06450646a717029ee15099576c6c30d97f1dd6e037f04e2f471343da67204cf67bb01607fecda09362a2bcf840f7e788999e4dd787999a2d8776aacbf8b286bfd0cad3b47ec8f39db62e39a534819a3f25a53dfdd8e382ef40f22944a151cbf5772c41e6a87b66d1bc43e7f610b5bbabe38a15b1613049a6422eef091a3867a0fff72fa65efb5d47f610b744fbbb90e2af2f515064813f72cb273687dbfbfee4639600e5d27b2240a90fcc45dfb3dbb1b9c3fadebc6f01301c3883daff9685b4350a2fbfdd19ff82b3733742fa20552212d2cf1c1da60af0d6c616abb983f5478303159fe47a9ff9d1a65b8874efab3c2844e31e48297ee4f6a7f8bf76c741c9ce5f33929cb0ce6627436395d00d507fe07f65c018f64cb1af73efff355344389be43b7084bcff52f42511d665d65a53dee7b56d6dc6c89c4d45ebedd966511ea1d0f36652f78fffbad8f9da0cd006177169dd16e5615fda6a2b195f0982b64527bb5c1a8e6f82fb965afd3d87426f771767f35ab63e07d08d2d72290a06949ef2ac3a53f061a27a9fa1ede070a04c7eae52d2df483cdb5d01a9f402c50a5bc328116017d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
