<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2e1c8b979877292250d149cf18143578fd2826b6809822cf229bcc12da4979d0d6205981918fe6ac0b62ac656de064719cbd50c0f624a70eb91c75c5b0d6d08628171b47efdc3e22ac07ca4e8c5811d77a20cd7660a4ab68c3949f90d1e79d67f72abd4f62f06782b423ae0337a38f56ee907a46012f8336e9d952e9363caa8a0cb99c8bbd84775ba4eaac2319f9d4cdf9929716135793708d4a5bbc286292428ccb36d4224cdbeab8f95b6ef1a206caa7c08e35661198903f0988c71b7c709a86c4ba67d5639b34c42e4cb4e7cf3491424f1890c22d9c79004836dc9be869c6ef317c7288d7887d51a61ee6eb1614f09360ef38fa3d84ca2d58cc15c29ee970cbb29738bcdb4dfb59bea1a152e33a9c7385e51bf9ccca49a0ff748b7a58597a4f92cf46a69b6fa2b917abd325fcd43b025739d98903956c3e3524d619eae05c78d545972507198aa378839579c805d4a7d701935bd77e28b36f8204626d720b0dac87a7ef3f5e2e657d4290e102dbf55d5cc7396eddce7afdca433e735443013f81ebf7d66ca4b05aeb26ce5387c05bde3b2415cef30a0a01818523337ddb13530ba6c85881610cfd3a5d9cca565d8412373e561784360031ff3c94c05145951108dc7f29df76fec245daa4d2d40366cd64fcfe3bb730f987a6604b0940057b58c867c1fad2e52ed91def17123051bf07531f269099aafacf1307bccf365d464b5a226051d51c5a0e4e513c8034180209776c0e566fd25b27b8b74d50a5d58fc2ae7d4d78b32b0c1d91bd09c9aa2333e4a9ac91e440b7f3fa92f9c48192ec80a2899cb5367cb2cd123d40f10b496aa86e031143a37dd0a618fc56bed829631fd03fa2f409f95073c431ea9451b2ac0bb1083ed43a4587f1486421da5a9ea8aa354421843fdbf9a7206c51ba27c826925e36269b0d5a5517daaf366593a038e1db0bd01a613962972c914afc240a4ce254e6bf12cf91cccdcc9ca518ff159cef867e68f51828872e44302f540f3490d89c6bd1762685a22e20869c4eeb66775d2c91a8604d84376247ac37690a418dc1ab88e86d3a16d570efbf7e5fd99b3cffd44e56254ad844d3e05e44b4f003fb15261b808b62d03d8d7511397c66d7a76af8e3fc4bc0b44949ed3993b20fcc9d96e133fa2b48215ab5521c04617e0ed095c1f7e9cceeb2a621c3d83270256224c2fafb021a4c23c22fc724d8956fcaaff9c6959efad8d1c60d25013dd4d7c5fb91c621bd02e1c722e3febc8b845df8eff61d3e0603bb5abe7ea6176bcd691fcd78e71f584d8a11094cd3dd24921109fe453333d4861be6df8d405baa02ede8a6b0a59a9c242bb30c0e59971da9d1c1aeb1472f65789a0079630d047d099f5fe3668f9051759e51f4170acc3ba539c8e3175b65a944ed39c498fa9226340b3805a5a37647261a15818908988541275b83e9d6c7280eecb33277b8ba3036adeeff9e33d35ef5e2f28c53c36c72954324296c723d8d1c60fb7fdcc1cbf730950cd672dfa4e6125734045713c20add4ba4c92fb1be8e24a7cecde141d887e7df86710451fe2148b391f9d888a48ea18dd564fe0985a1f4fafa7e06c3154e841a87cde7b6ba9da627631c11f817182d476aaddaaf3ca646e6731b9afd67da2f0b3af4e10b9ad98c6499e49501ee10e84ec3748ff7808681d404219c746d802c0cf629b1297a34249a6b1ed1cfab0065bea65fec2be7709f08c3a480ca560c28fc27d1e51435aee977f6403541e7fda4ec733cb044d55138ea8af51272cf6a8e2d1dfc31c8adf4fe5a686261ee5ddf7dedea87e200c9c19f2a61aa4afe630535321125d0c61badf65395222bbddb509d691753321c7802dcdcd0f8502459234767f02808c45447933a82da13864a774b9bbae3b0b2f10e71dde3a6feb3510520b7b69a1f5bb642a55bc005c5ed8dbcb7e5a401a95f566fe94738ae0b104453e487b5f97c4a86e5e07a94c7e5de7ec3e629a39a2f7deef44ad2e5e0cc3e6321bb2bd02e3f16ceec03cd1194aa2e48fd313a5edbb60dd1d4a93846c7bf1a368051568d1bbb48acabb85a52c384976e615d7d3782d83eb71a337ffabc07dbee1915d9b9915d86033f28be62242341845c3b633111123967b2e8a11e321dafe5265864d65fb5f64442f4790f3b828e463c11c48a6ef4dcc74e93161ed86d3b3ea9d09c29fccd446a6fd477f7e9515634eb048db4e9ed7c6099b7a1aa9956c9473f711123441aa29f9561d53a08b0a28eeed93dbc04c7ea38969539983f8921a80cb4b64582f948e6ce64a98871d8c482338bb6831c4b3b9c5a036ec11e795d4fa24e346bb3b85260ccbbb736b093875e9ff402dd7722d9db8cb3eac51bc5445af7e425bbbcf89c561440819a6301d84309dd6d2d216c9ff6886e03b64dfb913d6978d1bc0a5065a7e2cfa2f5cbfb632cf4088859b0113db8c46130b91ef1c00b9d3d693cd699cb3a84e7646b92d5040d08073aad8277dc0362a0b09346bd559cd28dd953acfa705590e8e69aa996a31ddc024732fc966310427571db4cd34bab128a18447964fbdb5bb22af6475d9501b31fcaf3f83d46ab120b8a26bafe4245f752056c23e9917d0eb554a612ad791491e65c81e993479c3af823813ea1d3b16c4fc4522e0db98b3ac4c57c33351ccddae1342945aea27830970287b165799b191e6b37378881c086ebd6bc744eb36928db8121089847086884095e0f3509aec2ef019261b81ba3ed5d53e6075443bbd1ae23e4c2cfce8bafcd305d5a4e75767549482857ad0692fd827208095f8258fefbf29f837c151527cc961472baeefd46ea3f34fd240ab784304211b3d9cbe2ad6465630dbd05af0cb6c46fa6d39b2612deff52baeb8afe8075ddf2acdf82a95dd240e999aaff1564b9d29c5c0cd145fb555d2eb27333670faad6d80bc14daa105c4ee3ad760c5352e08da253caebb40c6a5f9e96b9abe35fa8a80acfdb1ac4a090d9d2129d0a91a2e3892bc3f3a8b93ddcb286fc52409d3ca56f437ccc10f793ef1c22d8f3534ca9af483c4f52fc6b52d48ae67e9f54f3beca4b0efe6123d25021d8ccc26e24a50ef3e32a1a9c26255979975623c18313dd28d603d65a91dcf9bc61df62afef0e951e792f1cb850d6e34a4168ba42f15ca1c4ad5d086a99447c0106734fa495b53637f03440a0aac791da681743fb089b19d20978fb40221371d6dbb773b27051ae3f9a1a0408e3487f0475cf752d10d5fc9b778f64ba492130ec701df37aa22992a0879392fbd68197a6b9fcbf057e6ea80174269673a4f04622886981a3cb5428e634256e5f59f08494b07c90a5420c3b54ce944a5473984d3967b57fa43e7d575f528df87275e96d5f1291846fab9084af55201793ecebc81d0f641835dffab05e120285d0667f33aaadd78c4e5120f25d72029486a4de1c3bc776d304e57d081a587284e6d57b7ac47bb8da278f6febcdbf7ed67186a85ce6d0ca524f5de0c1e8b081da261a233148827791d1f9a9584db14f7b7b124d7c89dd0d8c7435fd3eb6213f6aa90bbaa1604f0686f21657b8926a74e6fc552a7303eb92592b2d87d9c54761683a0e8e1df16feaf8d7a3f65266dbc9b40112e491475cbc4044c734c2c2fd646b591ea683813c8e3a3c5b433ff60df9116fbba05dec4cc37ad564bdc07a0cd1ff7ce2809595864680d8700c2ccc72c8647534b8f9bc09c0865434eebf8d4900a9cab50eaf52a9a0c328d4679b38f07ce12970ffb1b293e103d32915c78072daa04bf7646866b5861ce853eacf3addb8b1472df1007316827393a53a64aa979382e2034ccf85320b66faf03943ab6b70e3d0af408ecc396ea8630a1a70845b7f5bc67a03e9b2245d53ee90b28055bd2e0002fe542f975a66901fa1d72fe77a1237a03ff0a2676c93f2b4b08c7d303871786629f1f6d096d265f1f901e71e33a7833a6e08cace65945233c955fd80293e8b7f86e7a0b09e20654c69bff29988a13383ddd951333c5d0d49bfae7e359855ab96fdb8c25dda34bc31c3b3bc5b719afe7bc10f626359cc20d43d76f30a784e4eae14fcc537cbef46b9f997ee09eaa858ac67beb5aae9518d8091b71db182abcdd3ce7908aaed2b6536c8e7b876760dabc169fcc994f271168424aed5f5f691afac0967f79edb6496c926bfd40c397fa92a4deb4a8f730bb05a288172dd8f074783470c60e59a1e38081d8b5bb21a02b8920311d880ffe3ee20ea8e55d2c4d27d14c8eeeb7dc275524f730889663d92b002f11e13ae9237386a88ba8de5787c69193f23df80ec409a7a2301ad3942dc1c9ee246614ddea45332411c6047e7bda78c3b6a41d50318509b679a7b300ccb108cd19d7a3287d356e80c8b1844cdb57b4aac107fd2eefa6b594e755667b57d6e63f7fa552cee4389d077f2fd1f78668a61c236837870311ce8c8c9748ea0a98a68fe170ea9b7dfc28b8a7ea974ed917c90f908ec094a3538c3aa9f88550d634a4107d5c20191ab75a0c9b550a4fb515686f0171e3dfed23c126c687c55eeafc8ea592d005ac38a7649e009e1890c4012344a9c38767576073e1f05cda5bdb4b440a8726655e498274ebeb8ec988750cd73a4108c4494384de823aeff1ef1d65dfc324ce534b3384c6997484d545457f3eb6524dfc2fd39a6683d68f5eb5f9a38cab20de10f98d3bd4c5ad4d470d30ef37252832e0bbbf73f0ed7cb251228718eef9c180fc92e7dd7f780b6f0a9abb8b75c0d868e733cfe76a8f7abf33ec749477cd89d2e0d5853b10222b3c753920fcdab796dc239f2211c6ea7e4381c34083591d56026f27f32ef6d9e17b0f51dc3c3951f50460b23e9d33b22821adef805a23d8149e0b585aa3145a77496e75728316f5b4d617451e6780dee14ccc6ebbb7beabdd08f3fc83ad600bc138745d007d488609e2e467bc19128d3e77a499771a546ef1f35f273bfc0e7af8005e485b436ff9ef61df7a77d09b13fa3978fa2cbe5c12a41959ae691e0450efdb2774cdcd1662b1096f4e6a9b457a506ced19086149d22508eae81ee141c815df755651c552dc62c05f36cc0e75e63e9d14322adb6b6daf9dadbfa6739016a9ba3c2f2510611d9ce3df9f20aa37c71a42e26b7f6e1212214d6981ff65f742d0f339e4d4179247e91595b3e216708e67ad3178d586dc09de73a0a2335aecb9d1e998eabe1dfac164eb2e5489918a011fe41c66fb68576be8a612869522d9cf6f3276e65418c7c7ae7a30a890b98ccc2fc2040048735894f87b2516eaf118a207cd89c482493f30c6c1fce4de32f09b17a3648fd9643524ec639312677fce703fd41383b9759a7214f22a2d740cbf133de25e65cbaf9cfb335816df5c5cf2d0c4eafc8786bb2f639f31f54f50ad3351ab5bdb64c140e82edea9d369e26a6c4588014bd1695bd2b4cdf27e21f26ff14bf61b79afbe93d07e0a89fdc0734721faf7d5819617bdaae11938bbce050e03ae087c90b9f4a3d380cbd6dd280046639ec478a8dfefde0b48475d6c26ca09a8af1d1601a3e386049844a41249a568e9a84662c129979a1c8cab121efe01b2b550a055726c6dc46a904daa995da2c89543f453bc7e752c2d82436ea174552d1ee02166f0ca65f4b6e6c01e7ba1f0eb3a2a7737774df8ab62d857ed6ce2bb69186d18e2b9187e943add066f39df341aa25f378f9df88e93cb3a96c43a335ff6e15471a66ba7de18ba4bee38893c1a23d8c64d6a30dec268132a835e8eecb1c110d124a1eb44f61e74208d3bd3cbaa402279b11bf93abdbde194cdb681930001280dde64e13d9614c782ac4a7d360c307bed532f5c5f00373363afdfb5379c102851419dc1af5a05397a1a0e23ef684743384a2b9b5b1f95c30cabe467d4115ed3bffeaaf5ebdcd52efdb88ab304f27e33a2006735092826a85fe14c2ca071809154a48a851f4082c7648411853485fc3880f489a0c68777ce72a560d2fc798d5462cfd82b2a573e912baaed5defa14e4eb2a723de2ce647496fb61f238111ca39e1bbab4d967df6bbf23ebb995ae172f3bc806a19d54d3d5b083d01538a5bcbc77f4349990517449cbc403e5d6523ffbd26d6eba1bb74c8954074e057067b9a47ac1846c122cbbfcdd303d21c1ff43170e2c54d91aeeea3a964242898c7afef170e70f725e7452951adbe376bd8b691fab08385918876ff8c74050928982d3671a2f70d0cd1902420d4c57af515a028daf198c17726f0fa4764aff40b90bb8ac622ec00969c7e8fb2c574b1cc46629f16a57222f3b9cfeea5ea73eb4827267eda8ac576ee07033b92aa7c66d98125f8a36eaa7b93c0b4fafcec307feb38d0864b4ed67a356a4e9d9e2a6121d5561f8c408c2d43529729c01e42b60ca4f572f611ce07a851a116f4f42ae373eff90431fbefb1ddf3aaad823e42a56ce8bd4073422d1b108508ea9177bba7990aff6cea2aa11f36a1a26b14112da88e39586d5161f418dbc30c51c619a732c5c451bf12af62f1cd81561a0ce387ac53d4a1fab1376400ddba1451202a7824f7ef57cd37a93714135ade873376ab2d2875aa61ebce31d1f2deab9f7606f49e007023df7d8072ba1e172ea11b2abb540fe5ee20338dd6e0315d3cb0fbcc7148ebbfe1308ebd046abdaa0868e70a58f0e665c9ac72aaf5dd1c9407bb442870dd730e71ea0abbb549e40fa94de1179229f569e3f403d74ca9d0350bc8f86f52316a687adb3fc9fbf6c4e4855a49fa2b665631dc4251a29ef10f4b63ad4df3cb431ddeccec89cadd81647fa7b3a4dd2c4fb76c73fed060b43bf254732ae3fc569cf2d9db110440f0d581540cb3dde62cc6b42d2f44b1656d98d5a8a0e1490cd70e355ccd1a9c919130a1280f7e14b8cc5631a0a4038dee9663c94e4ce739510834997ed9567208582c05d602d6b91241ac294a17357dc257388780548ef5a108d18a3f0d46f285d59d0596bdc0e3213c82f37e145d986a3c71882b5caca81452314ab65d53e769bb1e9738ed605c010a9281c5207db032ebcf84154c0cbcffdbdf0448f18a8bce8ed594ae5feb5c0ba9e984a4eabf0093f92284a101ce5fa1e6de3c78ee859af0b5357febe4d8ed097919dae91ece9c4c7287427bc73e3a35a7b2f6044bb4f8563523bd11ce2ae2e0171c1a17e7dccd40da96ec7e9110470c8236796eac715a8916c89288008a7a65aed9e59d7871ea8c7467f4f5c223164974095b778c23f5381ec6e48cf6219a831ae6fbff495a48df999c406535d5ede94b65fbb9c6ee7fd4ae5c035bfc2d957274dcd3679667cb037944fe5ce001abb7b9071d352de575a0d00504c87f80fef1cb27360345706ad28d91c376e7338f393a094306fe2a2f04f4dcc5f018955ce5d2efde0a7d9cceef9728010e76ff093daad949bbaa224e4f7eeedf6e4bbe7d8bf48710ed2269fa59841baec9ca9445090fb1da826b7333a8d5ff89599b02ccd5a0b916b4fa800224a59a88112e4c71c9b943cb5471a6b114f56926c3fb5f2ea75c710587fedcdafc193fe1a212b36bdbd426efefa1aa58370fa8889733f403557a6072d394383d659b6cce9e92c2be2d49dc05db99af69bd40f2d91354d053b6fc699e325b2953cbbf6fcbb78a95ce6a59e60e3562fc224283facff88f5c68426ad99c5eedc8e7b20747f5942b8923d6a0e7bba2079c7bb1e7f241c28b6f4d02536859d2529eaa513fc61a34b35c434fa42547b087f09c9cbbf4d7fb2094f8f91387d6e97cc8670f6b9e81900bed319f69daadf2e58b28dc57479cca03ab7c97e28ee6318d65c17330ea676ad7158789e4f5676028296ceb637a16e14baa7f77b63b341ef63ed0fa8f7c31bcde2a14f71b61c6b17bf4f62f534a39573da53ae92f493c04fe2ae552490004cad0b4c3045b7b4f6f34f3f6c8bacadfe454a7e27e2ff9dbc492587d2c33cd399de626380c1eee8052e696570e5aefebb5c3f3c540669b956bd03021b06dc6b54d1e26cafc0d8000b6d74060d605ba91d7f6fe60e3884d46399c010010f998551f10c08828b7e4526b207a7abe3045e878aece634422c19c1370c472d8beef2b37f1e6b5b75592f3142b483e2e3fa9ed09ec96253b5466041f26142fe011c9d6250054d03161ffe32903256b5e35b46a71aec06adefdb9dbbae6bff98512c76497c1c61e14d1ee0dd734ee1b4e7f6e038b47d3dbbbdc9ef2e07acd97397a1161a237b7fb47a411813fb5bb713719916a29e55798d736184a4010e7c65a123fbd18ab7b7b88d15e9babae92c88f12586646e58d4cb7f30f1f3cfb4b03510bc63568d75faebaf0a581d7fe19a88795ea978c9730e3417a66599da6949f5aab9cf62b90070cf91239a58e7e60246d846ec3b52c2bab4a14bc04a3fe39945d4c2413a964aa1d00549f00aa9ce36cade3843cfbbd087483af762a763560f50b7824da035cce56b2bed62c493c46d19782ca598c9b64713aed4f43d0a028fb3e38fb08d428473f835754c32638ec8f94a7fc0906086a65552f6e52448936b3dc713eabac75cf407c6e3414248102db3b52c7cdf7fa94af1f16fa794815127d03ec720503e8287896cb8e221a7775418bbc0bbed389a6ca49928d60551ed11fdd9599cda12e53a4dde1fbb2516ab83b4a45188ba90493abbd0fdc58b4ae709fe611e40a5fc7b3449559c4203b9ca4e99e64915672e929114dc9d6483b3b3c99b0f934dcdc88c7638ce752bc70904cf231b4227708edab30f805d51906c7d21a6b7a851d53bdf4162e0eb436022024bb151e15f23b1ee31400bd33267bf4a0c203743fa84df21f05f7bb54a72b5719202e33c0e404d91067f405c95d5fbf02e3db6fe72f8ae2365e62c0bbd86830dac7e1fa356aa59a15fd7b6bb0e9c5b45718063cbc3d9ba98da3034be114c88f3dca49235ab86104bdd9288d4c7dbf7b10394d6bffa927f2486988acf478e2415488fb51c28782628e19332c880ba59acb6d846a7f7c64b6ce29df293254bd66b63307ee8240873e0b395bd5875454292fc705989e34edc498160fba1abff98d0d296bdaa6d4603d529da8deb31637c304cbb33f849037ab69b982258edc81e0c48b3d99e21b0da17b18a1e2be14bd0f02c528060ae1febab2327b648a789c7be47c2c2f80e24c0f39a14a8ea660be06e91b427839a42facea7babeaf4ce01d21e77ecaff968f49ce8d22a142a5272c33695f423f5f87e148898b0acf63013950f3f7ff70b8498097c01efe25b2294049ee5cd15166196542d7d400707d7ce8ab2f039ac0038baf9d78c23ee2fef11c4617238e1cc0904dc19903899ffe132f0dbd6fd5b063d647c0c9c95ef786697433bfd3d849499096718bf089c149985bfa665c45609c1c54d64cb7e509d9233e645198abbee732ce749eb4c6514bf99adba9613fa17d7aac675b4ed735823c4c38d61edf9ba7966693a03f4bed2f0abd90bff17e424f8a716ce8bb31ea55cb0006313c370e3fa73df878c1c81a31fb0ea7b41f0d46913f837c267e036fa4398a6960e968fedf2e5c0c59db093299e83c23c22e104e8b04f2c1ce9d5a7586ef813083c32da5d9b50f358b0614772c0017139473bee18352ffb8e5b37da4b9ee41e21a28c960e5e9e2327d820b78ab6ecc0dc0a4ebf5fff3835787525c07095ce6f7655a01d7e2eea4191119d31aedfbac65597ff273d8bdef6143a1c81dcc42d0534882b16a5b5ae908c6db70e131a74fb8e0d4d35de5ece9d39584c23a67d8d024deda394328d8118ed4a52373cde9b2d7f66fa22794a9ea37774f8a671179d32c2e07a55ebb4244c4dc262e74ad348ddb433447ef75f2a9e553e17c675ed9ecc9995593c649bc81a3ffc6c71d07820fa1c49e15f4f102fabd8357d0b73e7b5255a91277c1a3d6f7b52315b9d642bca62cf3f04a28d8bdf96b9e3d05353dc396383c41a73db757444964fabad372cbbb26f2cf7786913fc7d6b55554bd850698e46c48aeff2caf7d4c3b3637d6e91eff79e2150307fc3ef8ffd7d7bfdc99cc5cd0165d689ca15cabfca4e7077bed5e1e0184722692f0cd1acae7a2ed6e4b12a87c083e96e802af7d37cfc942010030a825ed4e5f94279601b3402c9368d8eb556b927901e1f021069fa363108c096c987455cd098c898201942feb2f2c5c66a68dcabb60167977572a035612edd72cebf70a60e001be332fe80ce3f5b1fed164865ff8c09bb866d1c8c0d118821f0ae233a7248f0c1f283dc43ef8c06209a83f78ac0840c0961569a8a6e5a1bd327f380306af2e7b36b46a7274482486d1d81a9596b2bf98448ab767537300572f1a4d552706984f8fc9499a0e928e13af33c0261cbed38f4d738e7c4f68d0d01ed4baadfef54d853ec10ebdc7cd125e4fe3571ddc86c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
