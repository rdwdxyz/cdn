<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9015792f61f3debeb71b3128c1c433b512301c708f71f777dcca22dca594ba7ad8a0089a6bc5c18cc47a243d68afc2dc9f1592a5a379c859ce47a6e4f3e96ad527cae7ca6bae8e2b54aafe2c1f34e8286d3b7e07a4e7956d6a9b4f27f77c32ff8af5be4fca610d3a0229f00588376f5be380b8eec574343e8cf3359c9f1753e93969c1fcbf2ae1b85e9e0fc1c356c3aee3def1c5b39c4c257a4280eba2f710ac506b05c35a21ab3c537cbc5ffb8eac3310935ebaae702b354ace1ba3b7e5010153b22cd9e8f35ea1f8f5957785b3d588b3e86364084ec0a3bae2e74a5f5a6775c66751d3a64d35766312f014bfd2d8ed8294a74fa6f11e09d12f912375637dd58143f4d8eb4617beea80c2a4e478e548a6583af05fdaf28642c27c350f1d6b33e1a2b14bd4e395b33ffadd134aee4c7d848e685b2d45fed343a2c1ba7bdd9b1cd21178d29ddd0fc6e4dcdf833503fd0426c4367557564b8d026dd92043350c8d7557ba4655bda1e1240299a0be867b2dda10a6f2069a9bfb34ec196d55eda557c4fd046142e3fe9d4f23ff681c9e05ed76264f2e19ef580abfdd3d7482b3e51a80a236ae306f2780295dbfc643497c58a04586bde4252993cd8be00a8443d0c021eeba4a7f1f879384cfd6407e282682792b8523b46e15691b34e1964b0bf0bfff16f425915a26d016a92066be2b8ac6c91373c0b6eefa63976e5059ca82bd50d37c3815511293b70d9fc669829d1da63ef9fcfb2068ef2c89b562d3f9f000012854890392ddf44ae191fc9ffa3ab146a0405e09f281bdc774133a1312ac8824d597497f74faf60d913657403022a9277be5dbd214ec0494aa2fdea2ecca1ac7e80afe6aaddf88bb900aaf538abf5a79b479b0e5396f63056aed5254fd21cd407d0d0d282835e9d7ab1047b6748bf8f9f67c7e8123fd58ebe07861fd4345ef79ef8e4c0a11eae16204fd57f6090c302946652658a394870bd14fd407b058dc51e93fda141c48fd052c0c0cdad6e5ca781ff3703bbf5f2c92100839991a59375c82a31dd0c34095fdbab58c5451604d1a7fa406cdc2b5e73cff101468a6d27a6d305819919ed859d1948f9011ed8123aa66ed31d258a281740b1f20b0266ca67c52ea4d751badcf5ee43111621e5a7e9deec94c4b97177993aeb672170e858dbde41ef69b9b0b4b8074acdcc8b3cfbd5f7df33f5bf5e215098c6c178f4788b3a59abce040f285b55d8dbc9e7ba36ad3ac55d780d4eb8b87f97b4c48c7866cac558fa0ef690e4669282a4ed9f29a5bc580d8d97a5d67d19f2dc350d663b81ee019e0b0fd56c75eb3da97c6a3687f6a4b89aaab0d5f969401851f6d1bb95298e05ae2fe091b3448fa62faf5f71289159ee4c0468850c75411102323d9d07e4d3d9edcaa03bead5cbde715918307eac77fe119224eca94fb27529859127d31ec9e09f3f4119acdbd84360c333b4ea523aa9866b19283aae3cae7c5bd9bf7c8a5f59f0ebfb86c36f2f0941174e39f98012e455d1c1760a5baa8fc27ccaa3648a339934d410d7a1d1ffd9372f4b6210b1d64c868cd27f5c5e84c7bc272021f9926340e505d5fdee66a79963d1272b631740b3e0aa04c194d8eda077f7904f0191633207c0a8be8e8fca31eb46e6b52424faf3c0eb3ca9aee28aa09d1083bc55fa92c22aeca30397c73673221fbe115c225bb008b5ffb0e0019389901f9c698948846630403d9e2a70edb5a5d5fa9bc767d70d25f0ea74f97de87714b13a6cc9b9aec8b8140edd9553cb241cab0a17d5d01bc7b4c0f890ec799a36247bf89befd443b8c45e7a91b915a3fd1dfbc13aefcaa29a168fd84bce1cfd08fd3758be705fcffd76672602bfd49e015c5c634720c66aae4fd7720751fa8a54bce953e87ffb1cd633e3bdea4be221e89a15406b4ddc44ccc9968488d981afc4ebff96e8a944c7a07c905be544de02ce26e27c52e1d6a7edb4ce69d6143891cdf6df83ede7383c58e8ccaae04d93bbdea62713e1241d1488807bd4cbf84ccffef03101a30889f185399727181a7a34cbb7f4937369a291805fb2a4df896611519bf940f983cdee607bdae01fbd491077e4f03b8b4ab438978395d165de3115132611b2c69b9fbb31f31bc64533b73370209d1200db2b36ffb1bd673074db09ec6bb0d1bc164a2bb336d71444afd5cccfed2cd5b54deea86b58007f8bd99d5a6beb780637ac005bc0ceceaa74e39f394bce4890aea68574355dd5c9009cb3b5593880ac4affe946aeccf93eb14fa410a422186ac1c83ddea6b8338de527911a3c0d5982cd5d56ea0b02be07afcf7689a4dcd14367024cd4ecce1f6edb0507ee4276ab66168ec79334aa680e07daa8d79892b7d90a57583b2ba0d4f83a10a185abb1ca924641f2acd35ff456a9c47672dfb86a04b394b201e10843adf2ae3bf995c2c65bf876e6047906315621927961843ed4339fdc51cac0ffb0e6f55063efdef93a326ebeaee133ed38bbba98f065e6f7d13e3fb7526078764890b6bd3f6d56c07b41ea5666a4b56a2e85252a0e2576222255fbcbe981818351441c11bd85bc51fecb3c00cb070db2d6ad890663301c06ee246f2b873f89000f5e963bd90861a5c13c36aa3cc9d379476c22961832cf31a8afdca0bcbfbb196dc1066256a67a2bdc547cbe7af40ad319e419f9ae6d333e4e4f830e73fb55821828ab3885cb79a5a213abc1f4651162752bf96223c4bce6ea4e7c6f8263e03b3371faeffcfd1ba438062a21bf1827379e20b859c3972ecc31c761afa2c7ff4ded31663010a3e54e5e56d505bd48d769e80204e1abca96889c02c7a4df756fe74e60dadb90c0f9c8238ffca886dd2adb54d793bfe23b3f1ec7fa174c5a410aa8b009cc2d623fb200fcced0e57c2d0afc76dc34f10e7988b1bde82f7bb94b0d20c0c91dae49e8323e93cb9518882f12231689654fbe8fe62c5c653acc4b2a5c4793cb7ff72fdb5ebf5b7034be0d11f936dd849c89f1960ce6cad5397834f749e37fd1e46f7579731d0c287ae5f594352ab52b71ddf462d2c3da6401283b760575cd563dd669f3abb86865c9576327f833c2d339a521765c2b8249bcc2c444995a934359c6a56edb63e58e053e7dd0a68f487cc95f7795104ceea1a1da22c18ffed428bb5720011c82d4f5d13f45414d966a51066a525df3f9f4ab04db4d47d16ae17f374f887075e4cc5bcbdf90f53ace4c4f602a307b75fd9cea66a993b81c1feaaa549525aceb57fb9b09f119819750c37a05333e436322e36f5d752ca3c784f7d869747f64dbc817f2bedad3808a437815c6a90baf054bfc82483d90a0a85e27612cbd07b0b8d4d5975e557848698b03faccf48d247c1703bb638ec9443c065904f5610299bbd2e491b9eddcd89c3c61433dad72d3904502b71a3dc6aaf048a0d9106580a194f676b217ba9aee981ca51fbaaac2728a8ded84bc3ebdd6d4796eb013b72de9eb33682d341b07e7abcc84d8a5d5aa482bee099d0c5afd7028392c52ea62e669ee36e6caea91bb7529d3d68de7b1b6aedaa58f0cdf8c4ebc1048ee0bf577f15e87dcb829dbac9e9373ca1b1265124fec3dd4129fdbbb6e0b9ce85c78bbde69357e5e99839d4cd011441944a86e91db139e01c401f315b9571bc6ee1fc0f940f9818b8c2934c50e8218db18b45fe18dafd76af3df1bd8aa43fd3ddbb289c1feddd4bab618d4bf5fb2cd28266a71cbf861abac170e3e58139208aee5c03f8c08e018a56cdd938f31eb8d02e97a32315221606d82f51b933984cc9e85764d1651e52f848debf66d91733bb95e95f53cc792ded722ca850dc879c4a03209d7e6e34ca05bedf3a63435717f1e937775f36f1b3cf43f4dc7a03b591563c80d6a09d930c732f13e2e4b5fbfe62afee35e76bea03a88795c133127136865e0db12a680774f67af172802928fa6744f7d5a1d7239a4772c3aa938ddf7e5bf14e7fec760362adf81420075a1909f0ce5aea3bc5aa0441cbe201edc2f94949ec2df0e7eca16fb8444c59a1c278d68abb6acda878a063515fa2dc5f8db56c77c3d2c6aae7fc3efdda293e251645faf1b98b34a215e6829a3b7f34fb6f429c4347630d9773a7f392c41bdffae9b17c6e69b6a2402770d98d9f9b56f88005cf8eb759ef94d76f16ba15282de04a53b41b3161383803b9c16c5d29c5f037514cb53644b22fb7e247193dc860ca3a3f91bf186f3086bc653144a9fd7767e84c7e1d8a5dadc64499b072e7498a42da6a6ba3a0c94b322f8852a2891d845001b757a0eccec981fb990ea5444b30168b868420dcc88359b3110fb4fbebb770736d5d33c7e922a0c59906b8b3676fff918223122fd83c6b2053c4a584e60d77c0a1cbe9d28ba3fb76fe4cefe6b5b028e315406ab0cab4ccdeb968ada76ff91ad1d0dbe5bbe6001a6a3a4f207a9deafa7376663cb8e4cea055309f1d78927b4f5c52c4182f75f28640616cd10bac440cfe08cbdc30c2e899f9ef488f0c2da90b3406e8dac1cbf982b9f1cf109283a802b9d16f81fcba1f7269429a1fdc32a5e9aaf4cf7209284494e55bcd04c253ae3ff4940ca6055d260450d22d924f916663934a4ea27e14b8a41dbfd4961d7063c97d52e02ad711dfcf0250a90b668198550a11633edfb52f71a83fb066a0e08abd4f191aee5b73ec9e16fdfd3f67c9288b755a0a8ff6121749e03e27f63a921f4b212d1da4e5299dedb56df98f1a011966b5f31b48b6126ca31167354b5f06d0505445e593598ce3c1397e2c4cb91e675336bdf037d7dbb52e5c2b86ef33207d6936597491f6f742eb7f2b349358f45007fe923b8a2ff3471075d47d6932c92a7e93b6014892fe0ccab802ee55bc959ee773c8bee8ba1b843482ce4abb687b1a05c947dd90d49796161b737db5bcc8a89418edef641a4d269b55a9c16c14c0d215b7ff3f0e08f42cab869162374d422b7d70e3926953ee9daaa1d1edf75815a35510fd5d846f4741b7b9179b3576471b7c4f3414de431741e1abad577dd47cdce519677fc7f219df371ca17ef5a5f61ef42cbd7224d483fb6df1d24a3f6b295c13dc76bd2f4b01136c9e58444469b25f6bf0bb584a478ab221752e56869c00ecb0cabcba79dd2073e86c1e5e625a00a9e9b332212e83d9991e9bfc8d4c4409df47a74f3f73cee86fbc3621d7c44f9811f290c716ae0e8b4bdadb6530cf8a92492589583330982419235064b02b4ab08a5845d43b73ac6e427026ccbd0dc58388508e83806e1f6ec1aaeadcc830610ca30b084295b88f37ca5e718453fea330133499db5dc929c074a036fb8f8ade095d0963cbab913f90a1bf608df30c6788562a05c841eead8cc79b2a76ad4155914aff50d3d747c1f16b93b93063ee0d236fc9d3f4def177af3f615ae5957fc4dea845467431472dbf1c9fc125ab9c55e70dd366d608cefd5d67fe647e8cdd8ed199eb174b619d261f81286e1e6a459736275bf7436fdc388a213d149ea645d1dbebcb5128f5988bc1896331bb3ac1e80fbcb53241399063f85b2462ed75ae77b7a60ae7287ba868dd86f3a04f3edfabd60e826060b5fc2a391e79856ff1d1a9ad530bf06939b0020d3be4c5377043b0919ddcdfdaf276bb4a47a40bfef6e2031727a5ca92619de6297070ca3b6a6e616f64386a108eb64c92cdb32d56a85fc1fc885c185f7aafd0b951c4d8874fadb873d11fed924caa08dd3b4d6483c3501694b064468cad30aab794706e5dd328502ae9c4808fc0488864afe9bc10c9e3db0e48db104859408b88f1ff94884f2d97ab3d597344b126b4eb9fc480cbc8867a13cdfc37461dae99ba03e2e07701475a47137a2f95394561012d1809014c8e39a080166e63a3e3ff94b0d96c740452e2d462cab9ce6b71a6dce128e1bb7a5907bccf5676a6ee54707671bd877b3866331f6ff538796263f67fd4489491ab92e89c976dafe4c412d654d39ba189d4fcc854bcc9f9595f8ff4c4cc545fcaad6298e0b7bca40cb0ffb2a8073382e8b3a68b5835b0b37a2e1f8f04024df9470824284e41c5b66d54fe4f8f29c89fa04d5e38b366109d44544579211e8bd541a82a4a040d779ef33aea9d91367683bae4e3eee4a7fbb55f3eeca121b780e2aaf3cb7b2d231aaf669978897c161f2d686fb4606eb596a5e6528a1ecd83399be407dbd5733efc1da48fedd8c499062c2c06954e38c40054e26e4f83d560ee2ea28bdaef477d78711e94a36a533542d89ae800c7a20d110625806889c0c574dc61f7a538f804e0b2b4f4bcca63eef8187980d33d6032777ef86308d9dd6e9b5662866e46afb974d71648b6012bc4d6b6583adbde9f0d429ab7cad08d092e8b023b1d95d215e28d7b92f2cc105e0215f5fab4511aee6333074a95d43898978b34b72157de80fce45d69d2b3ffd6a96f9242d7a58a4cc5980afe35daa87704ca18f4f3d1d3d40cd994d246c59f727f75390a1b2ef700c1e9bd1c5c884b0875808f09605856adbc8c3c6b2876c4d1bc007115c47f0f140bee8dab459f16b2c86e6834a2ed9a0a7bdede256ac479a6132d4840d8b69fc8d1741a45841ed990efeb3f20bb39f5d4ef831a7e5c1a8557329c099504c202157b923a9f92f466832970884b81fdc91610530a15c418ececee0a9dfc4854b92765a4365187f7524be60e32054ff077e382922b9fffe5fc000407001e34b177e4900ac1a5e8aeeaaf13a8c74ecb213e055ea019a08296c3a4ccb37ecae09b40f7d33db618ab54719aebe7fc0e5ff20f081aba1ff29ba9618ce6601c91f865998a4ea153ed5e0c33f400c208248002d72ffd27ce3542342d74a4d29c5091f68017a058015490ee4e1baac639c73fcc67b5518361edac116b44aa62a43b53c256ca578ee43625b6fbc73a12c65a372b683dd4900922fb8d2fc5c34cd28f60a82b9526d4d1e231f8cf4773db5ef8e0271c34635da17ced62acbe2b3cf1fe1832d8c57b8ffbb6224fe8b88089318cfd1511eceb6b36f8c31ed32981c5409baacbf956d59bcee07db49e59c66cdd507c0ab3d372abb534aea00af2927945c5717373e56f016f89b8f49b1fbc1c7a374ff3125034e9a3b6a76b14b69ec257d4de2079cfb54ca235890ba08eb7d49f7134c4c43bf1af2a57403a1a9d072f243535acf2cd67abd2124219e8847ce78d9a9ce61d6ca22b6b1f6d64b27cf01c0ee996d1cfd012ec0fed62d2e42e94997d866712fdd87280556bfedeb1f661a649604ce0fd7d45f8326caf84f8e394197c026eb7d638ad20027788942b2cf759539bd70e9d843937f4d97f17ea1ca0c2e081433fa793d6672bbecad6d549d44580a965b42f29b894ad52cb294f88a4985f180a37d364f30eaa786435691a4d2027d6f65774cb4dc5ed80de7ca10a7228ca9d852e6101c7e17ef617251f19287ee5e3e3199744b89502a5d0bc7a083d2e7dc8ebe5c8ca55b487af6c1397d0bfe16220b143709f51ad3c2821ff6c6f6ff273fe02c7f84c74b441c3b43238aeb6de7d740224a99604c8e01d9b9c3a97b0dd81c38cd94ab25bad42e9fa159e816d32e92ab600e4147cb4a8d824bc562ad9a4265f6f0ad57043a91233e4febf13ce5d6381b038a2c056c361e1a01db2b8699afbeae73c6ea3de2c97100e53efc982b1b42b251cec2f306d3c4a3d6df112bd2d5974630b494930b7e499112f1123f676e01942502a1a4bfaf6b3f538ed0e55e161e443b005d0783f5a15d278eebce160717975863cca93207c72f5957fe2b8c9603eb5233f31367a425a12620f60d853a00b190e65e77ba46aca6f62c58da7ddede9b994ca25109fba88fcef39e8f3dd7c18c990293fe552dec8688c183be1dcd5c655fb38a878dd8c21c0c84a7b0051790923bb4c6be1ed263457416998079931dfc663b16f78d80302ffc19aebd15a88e6b6f45bceac02a6cf4462dc416e53ac569ce0d27b5b9613c6932ed7a52d33fbb7630afbdd4d77d8b90752b12274163170dc7ac0c790ff5ab7ba299e8cb705cfb2a2b5a3e84c750f2fbae569266107ca1d238a97b81158d3c48648b1e6e28a3ed2ccf29f078f7426e3b6e7ea8bca200086e4bef127d757f712c6cc4f584a8e2b4f4a0c65f4d4459198a06403a15b0ae4f39e102ddd82533c88de829765578eef533ee8ec198a7512d0c65061b1c321b6b2e64f62f350d154e76139177fd66181ba1cb52327370d876ba9786c67208d083579727d4d5a22b9cd79558b5caae59ead93e4a8dd49c051ceef9a1acc90fbadff9712c13ca550a315f789060bc2963c463f51fb54c0b8d20f71f30a1d841b31cc0e281a59be05231d4f1621050a67e1ed1ac082f36199ae5a288cec477830a9246daecf60cc65c77176c9c36f058b77ea44a9e71f769f192eb499c2d963506d2c5112aa3d9399a4e1321f9a6c97330eb10cfcb152603d2b6e4221850ecc8dc475797b4fc71aaf1cb0eb62ffb92e0453ba19ad6785f1b387eeec0be649fdb5bc14c03fa6f816a604d3337305d45f2ef6788b1b7df0b031b37aebad9900dcc1efd085ed16a1d943d8a8c2f4eebb2adb355c719e49a70f76700ab6a404359739b37c2a674aec2374af1bfec7f328ddfdd61846d78722d734fd92b9cb64537d1133710ad093de3dc71cd59a0f870a050dc5b026bee45903306473b7b7390ff1d98d0bda602a3d775fd4bb587d454201f46b2158a5d077fc77c4712068471b78bbdb2a018e92029c267b0f4a5788e816e83fdf5e8d4d7a558e86bc0a2b1fe87da42b733633610401a27b63552ab5734c1eed3f5cb9b11a9c65ec599317b6be32eac1e80f3cae78cab7721a75f587696119e996c1cf09786d559fdc8ede2ab2f1f9ae1e50e3b377b997b72532cb10142c95deb2776db4d1b9944ab45b9be84d49e6ec8338686e194b5744792f4dfd22dbc11933118a00fd7126fb54ca0026a7f1ba378c39d4962c62cf0b3448f7d8ad15e363858f974244f0779e3462bbdead975024bab90ec30c0c22b13c215c4535dfc1aaa4f1d47cf0c0700993305eca99020e6fdedbf56657a82901aacb4687de3f3949ee6064bf6c618c0243ea1984e679b40e71538c996bae5618631bf2ddc83662738873e233fc37dac7af16af34342c5a45d1585af585c948403e092d082706e7e975f9550c6d58c4f0bd1386b4359c191a8f31347cd014adf992e7debf0becbe91163a7612615d19474b872a8fa0708bf36f5a80e1bf3b4612d36d4d36f5694b63cfd714d00acf9696f5ffaa963bf6283c588f94f2355010f469a96e18ce05bc4c34ffce98dc8e4c3647a34507a1fc405240762b98031941296f2669bada69cf264f582561fc98f53a35849caa1cab8b4b3482c09939567af8d1cb706ea3ed335865b074b96be702acc42826610d2cb98dbef7da38d64f7d0f1af29849ae23493d1c55118e4bc86ccb50f8be7ebad0b695c57b730f272bb0ac289430121a117c2f59f2576dcba03e6cc72ca50038193bc504ce64b338760d9f78765544d5da0ef492c127564a8b78903faf8d1d7caa4193fd50a2408df59a2eaab68317edf173007946c5cfe473972aa865a7cbc03693a003fb0672e57db43f6b9d6d47413aaac6505177888c004cdaf3b52e4b0302191768132df11a1618b3e79fd05cbf0fcf66534ea4006a2163170a359107fd1176f715d04f97f36a6eca77dcc03c54fc2c7532b32ba1b6df82b45f6a0e547460cf9d2257f92c0c1dc60153ed4ecb1f672503fc862136dc821b9fc8562f3a81103db48c6121be47cd1577000598cb050ac9b4214f0b76a270eb8ed266a2a30187087ed418fe24c1e2a22a534995d3a3dd08a655add306d127b6d738ccfc5a67c8809f7db1de053c4be87bc337760fa5153bb2aa356cd2bacdbc223e6edbf657d0d7ec11d8a4ea3d4878fedebd6017b26e84ab4a8ff41450b5825786ba4de4f03b414e5aa1907b33060b9d2a3e62fdb24e6062845dab8a6f41ecbd8136aa5667f206db3b8e4b5984b22f89f1a97f60ddd09ea52a0e2d3c9ef9fc9d1daf1129a749d55427ecb3369dab04e662753a4662ce121a19c6cc75cf6fdc22ea4ea5e0c039fdfc97d2cfea165c54649a13edfe8580b214071468f5c306378fc25c7d834bd0e2839ed6e41f80477be756df42f7cf4a3c0b5f68d838ddf943f1ab4b41d65fa7639d5335c86b01ec5d3b7e088ef3dbc7eedfbedbb747d6f2f15fe9788a6189e6f85aaea2aeef96266478a431bc34cd35a8dce7cd12c2530a2586e65da4a026a10a31fd9a737901068ff059402b8ac80db942e790aece09d108114c45c88489b3bad891a777661cfbbfdba700692b98705327085dbf00a2852b43996fee8a29b2dc68567f31ca814523950a83c1fabefd439b6bc58d1e656454c226bcab0c5635233992fc416a6955e0ef9de9ca01ce8af0e306b59b69b0b4373c6eb966b3c26dad1db11033ba48118804965ce2704a5bd481ba03f300c393692b6d86741d141b2cfcd57a63f321f58f22d882027d4cd4542092a31dc387701fbd6c9d06069106f9262f395a7f2a85ffa4d9c8247710fdb2092fb11ee18903f2d46a5ac96821401e44e66cf7f421cbe74df64a04e0b393c7e136e390861817732fa2fcded16548de250bc9e1a228bb0ca17b032a68e78d64ff27c6d3e2d75a8c855c8a70767f90e22681d6bb84aefd2fad8ca18037eee1e72e6e25e89e65cc7857c80e309c874a811a056bd8ae5d371a6c23722e233a1d78202cc35095c389c3f6c97221363f1ae73cd2e7cbd4adefe89ca9a1a1bd8b0fd212bb4cae63dd3abfeda2f3b962f9478ae485ae591989d6582d70e0ee1928532d7f92e7054d410ee0c414c170d7b1aaa50e7dde2d6a41c09ac651f34268b9634e1bf292c681fafd805d97cd87dcf5a0daf163b582dc47cea4c050ef9b535a3cbb7c234970cd2ab65acb00fc437ea74c4bf6bcd195e176b3cc23702aeb982638005f7436db7eda66d7372a01c3cd179d68218609faad43386073d0d930710636322f4e3b5983333c074a0b97450d3abe2d8eb39642483e218b1de74af7fa674a3a807faeb99c212c24a2adfb84d9124435c717845227bdee808b007643361f1e10c3d18c45939c0d270e3ad7829a8ef9bae299e329136413fdb617b74fc3531c59f75be27e9d1c3d94fc9eb0071171700f59403396c2ba60ab162b89c7b1f97f33814606c061cf7c7ada01fb303524150f8a3b07599cf5f8c933effc50176073f4fa8bae39f5cefbcf9336ca28156617f10f2ba5510fb1baf9d44639b4bc9eccac666b87a271f72bc5c689bccf7c5a731ec58456c04755953fa79ce985f958ef7d65a76f037b20dac8ad29905821ade5c343641212ad6f62176821cf7b7a829874a88ba09e6b0b6a3866e8322569e96b500781e7497a5c1737e5ecbb577d0e5b5bb7dbfddd15e28e979ce5df38e51d9d1b8764973ba737053c3cd1462ba9ef5764fd607b3168e913921617c2fc1959f6c9f458b08ed15b4ded9adbea1c390ab089f6767a351767ca8df81e26a86368bcb0debf35230bd1ac55ddf85b7080e7cfb1854811853982dc476d9c6e5792fd9393dfc28053fffb5c2a9d1076d6be261a0b4e8c54b644ca1d660e6434a86d1ceaf5de5b4a69a5bf43c7f9fe9f78d3ce9630b0f1a9c757b0ed273c47bf77ea0136720719dcd1d242e9626786efbb03203b9c7ce008d21a93b50f33c840c800fe2d5517a011fb4f9b2de2bdbbe27ab182501a681fdfa344274979080f1d03c1492d3fbd00de440aabf09c8143703f1d352cbe5f791603bbdce6b7958766df607516e6dbfa407a1395594948c02babc909d17a2b310236c7790bbca9b1f9a61f77d3bd1b034280bc08cdf547367d70adb64fb2bc0b66c3127167e1ae544a095538ff3bebc0cb54f593419e9dc161bd8b1776ac3b8da538be1aa491e68e5289e17d1ab7ccee26f00f7f6d77ce79b632271ca8c6e29c89039205f93b4934a40248744c54dc5645a46cd5e82dd74df840bd6b6d2f7cbd2ffccb9498e699aea157c93eb461809d6f1b34f449f8d7ab4f5b1dfbb7015f566244b5414afa7117940ec2351a3edeadbcddbae049d0c2b9e35d83e66b9e127509358e4694d6ab69fdd23ae484ba81a878fb6afbca9e9de2cfb928f2ad441e48e2d188e38ee1c7b559d1300b34d796e6b81607e09eb421ca0f5ba95b348a9db8a1dca7e0149e4619cae393a280b1d38c4139f5c08f62ba98ea4236895f4bef9f8fbe525eb6de4ec210661ea529aa92920378a8535a28571f547fec77780f488de031935d04331d162f2446c1bd1172b28b8ff647b6faa8f15628a72f013cd7d27bcdd39628d3544d83ccb2cdf1b6897d3ca757d590a744ab81a42f0a52e8f0ffa3317d43eb05b92bc402640c29fe18c77ad89ffb93a37366742592cbbc7a1be795c182f70e51da4ba5eb75951cc040f9344edbfdac401e89d931d5cb82290b060c8a527d2bcd4ecacf7d4bc3480722fe15f1e2d0dc8cbdcedca41f62c3c1dcde2c53fde27c09ae4604c9fa57f7e371676bbd5f0e10235be96817903783175a2c6c06826e25951d2c97ca9a244028dd06cdaa41c51a5d489c925cd11437fed2b3e700739231b47dbc091a1a3cce968ccc136f5a884028fc7a5a4049163a971d9c791f5175fc0f3b1566c0c89d7a77b5096764a9d9a136d23c9ab4db830e4add2dbf50274874b2332f5324dd33876974c8b6ff9d552008fe60fe97112ded3a648ba995733dc4a4900761976b6bfa97a515cc34ea68391eca0e87b4aec6bc08f8ab4c8a70117c560dfae8ab5c2013f54ab47900881aff40ab4b281d55c8bcfb5e1edc7963a7de8c3d49f3665d7b40a38824f289649a47f292e1c9b99dc6f2a8682d7937dd915031eb9fc426b146ad3b687810960dd299d27a3c79607d94dfec4e4a452c8c2138cdbeec5a5c975df0f0dfda9c875d31c6d3416b41497b43bcd207ef0fe0cd47d0ed61b3d8410fda2b7a2a806877e5eeaac33f5c9bd153d1acecb406586625604c2431d7a6bcf976fe22aa424844f2ea74d35c0c09a7a70bda346c6d8e715f4629178be060001ca3949b4292e47a0073c60a992a60e5075711dc8977bf1a695edaa3c2b993eb63643ef20f5b5940306aa88a5afa9d6433cf7935e4132e2149da4f719d8179ee2f253c7357debc9ec27fe3d7cdd1745b735192bfa2236e543f673b5cad4874029a5df8b5b12673893a7c8a6a6914ba3fe6e88db28dc74469bc2ec29f8b9e1a62c0345e18637ee572cdf2814a3e62f01c2d2b904b73f72bdb7063fe95e40c5d7389f6cc7222ce7d5d92cf4a42586b3ee9e92035802e14dbf5ffbe30acd04726c6b55ca854243335b113312109a016e95a57dd0a40061956e8ff06b3f5ea50c0b7e14412fba0a040d70cf266bd9c09fe24db011b9ebfe6b27b74dde8c9d48a716958222a01f50a2b540c8b7f9352330a2254e5171b69a19557f0f292e0a03e96a244a1abbc36318c6624206f58a94c7f2a264cb91ed18cc6d0adee1c06d6039cc09acab1a66aad64fd20b6342f13c35eed521c5c076026067af2f80507b6ff1a021d87eed3e486baf6f55822193ae3eac83500182c8022f41b9ae72c531b9fc1db1725f8a8124907e122d7b896f351748a0db14d82c71f8ceb69bc3da08e5a9bd3f39de7bdebba165b920a4586a460fe24214d73030f11f977730328fab890d226a8efea011c6b9eb49dac10d78a1287d70f69ec855ca30e12fc7c6073e95e33289493cd060b625c85a0cf4121d455523260d7d7bc12eec3cf03c25eb053da6e17f3221a9caf1d28b72c5b7aae788b0d9fd514f6792e9295a5de902010fe6fcc56760b50b3bffd8a48e844758c442a6b39dddd1ec3e2005a9309b53a76c59bf7845b197a0195811d162ec01d751597627fd6b9353581cea2f96d457a8a699e28ca063e32d65d03e67766d5ee3c732e24e572ca37f7b5c2739d4f4b78e34289a37209d8ccea91598afc77cdec7a2e29ccd4c37e860ddc0e21bc04a80b20a52a8b0313f14a62bdf2fc05ad05fb79f275d0557aa761b97102bcec06c8303c33f81beb46a51b97a3f6da3f8fd2768d44f215c53e0aea5d0751890f23b9e8205d2138bc372991520451cb1590ed9a9946ef19157e5ee8d462fe5e628340c6dcd0b53ec9d80d68add40b2023c953965302a55575e46b20206eb847091f793935ceecd7a2e2c9e2c6a7234035936f83cc8a2356954f6c18f3544d0823e36d2c7df007a2e2e7d93d549a2e276a132af5c97fdb071b91fc9b09a6ea5c3317c87011275f0d4318d6e28b92978e5551564adcd99a689a35b2441f217d5b6ef059f080dcbf64a6f18f095d486475b6a2fa11f02285a787ce8bc5159c5c336f9a9cead8c5b196fa86191a060d5cb4ce7c7eb6d42dd4f5d5d6fef56cbd0d8b90f77efe00bf79490caab4c14a24570ecce4c86001b723dc92b25f9346c7b05f57f22b3ebb83746211b13d47061f3e0e7aa6de335ccb3be59762f86f032b68949d11d67320f0a8626d932b782c7b6765f73bcddbda93d9488a4aa56a2f8eedabb07e65202d85141441659f92a35b23bb8789af1b37e6236298a92d2e727b75d95f267c2742fd91237e350776e4dea89ded3e49768185a47a2c5efc6e4b45a6fc7db727d5c247987eafa6d2bb624567c696fb31bc51e347657fff09e0c968449b55a10baccd5b3244fac2917beee4cfff24673430543724a9c82d03dc8726f8b5d5999ac45858b25f4ebafed8965a4d7b1d2f1cf30c6feba67b311f6d01b7cc9a04bc751082f6256025c1a3119617df109b167bc3d1e8b4641641ceec8a80787ea817f790667d0d41e02beb8dae178fa971d562e8662213b96329407bd587bc6d087351b3453430b06f52daa32a7ef62c806838a70e242cd41e84415f73361c5a18d85380c2d2c349eb6f5ed38c3da14608eaddd116c66e14489d1e5ab23c638e997b66a38bce28f2d8e72ce389072e5acc2fbb8c375f2c44859442b52dab457e9af118394c4b17f41b3611cc687000b0f4bb1856c2fdab95e0313a45dbf2acc854978384df07cce2fdadda25ad52ae11c80a74588176aefc04a28ae1ac4f6cd576d805725ef837a139248f79d13896d73fa8f6ba72830ebe3592fd9d07eee25f88e1356f4d4b02af408940336fccf9eb32385b5d02588cdfd0bd42384862e77e69a046f8b07db039651c9543c074dd424cb9ca6dbb2bfe5cf51bfd40c329c055e246dc01ca47b2c9704e41742fe4c44d4d68f8f03335f5572209800641224f68592ac1f579170c216378a5e98b68db638c99955cb40b4d9e3bb8ad12a7ad5efdb96f28db82eb2c2752de6abed9fc9a6ddf2fe084089fbb2ac61c36eba2be1a0c3540d7c83a7f5a4915f6e2b67e3f0fb448f4a1340a81a7379aaa7046cb671b2ce650d8b4144aee30b2e48237793bb6519bca2b6dd256ac73015f214d2f584b20abeb9f3dee649349d0a4621f7eb4434fa5eae5e79c6345f482c41c586e365a0b1bcbb2ff53d42f6dc9471a9cccc99da47d394e1003a96b8a84eea85e346dedbb176260eecac06ca73165c57b1faced51a264aa66d05419db86a3ccd85906671d8b6a6f4b2969f266cac90b03a8fe5d027bc2da92eb87eee599ae65b7690f074fc9733f446ddadc47834ed64e25b320376ecf7155281f04904bae93bc3ed22a2c54a3822084e94fa675320b2899087a899c12a8afa4419950ee3e45e7cf6e1c0bf8a40f0dddc4a5811c91fef912e15251a6feffefe98700cfadf27cc10a6cc42b84b329422754cda4f3b26c43238d5457ef79afea09d8e5647cdd0272d94f08a1a9cb44514be777384ef1aa21a00b3920d801f38eadcbd692ab75c4ca808fd8be5a81f44a348bc41f3ef8e867a90486bc3e59d73a6585def1fd0687190a07e9f800fb02f5690eac0f9ccfd5bf7381b149178ba49ab1b7dc19e80ca69b3b355e1c476c8742ee8f2cd92676b65eb660c003b545aae5c2bfbb5af7ae9ea521718e0e59c82e0153362e7a42334f57c2a6ebb6238fd4fdc5f975d45205a0064a27241d33c5ece2a9fc3ef8067adc6a110a1bbe051fff9d55bb37313296035dc756ca66b5902d84dbe544cb8c71925d58a5d96027c6c11c083bc857a9510dd20fba4aeea72a95107a6a233cefccfdbdb4791f2ab83995816f4f681f2213a7d990c2c1d1370f991cbeb44ff706f1b17ba4651e7c8407d466235d01ae89f74369db52a478da2fd90efea12b2a0f9ca3ea0e04aae0df9be66210066fb21f492698415e52e626b2411fd51ee23f9d8315916685fa7f371e90e70c5c76623812d901405cb8d4789435465bd6f176297d78c9721eed6bfb98d4362b6ef3a320a28e891fb48a0bdd794f0a2bb0242a0292d6321cb5747d41b7083b8096e98583bb762e8567d1fce4e57403ed6d3a99f660d2f05c724179714516118238a53b78817d5468c86076a2045402398971527d7c4c148949df9e03fad0feeb9eed343b47309d49d066ca5b38bfa2d7a946ebb900a526103e0fed359dd2cbbabe01deb68970e16d5e258641cf00bb6f07da59153e917041e95da4753b02e536ecce3ca8e6ee1b9d0298cc30408bad73a459cd22b8f6aae35f22e5d15ddaac1d6df7fd453480481216c1a54bfefb0e5c2ac43615bace9ad0a88bd538413070e0984f0cf21f60f517fad273c120e5046db9651e1fd75a28d169be1ab14b94ad0dc33d4e865f0912aeb0290fbbc225254ad1d43629b92d23ab49bc3be96af286abd0cf97ce4fcbbcf43223a94cea4896f66bef15563370e1ca100c05a8433cb035d2ce03db8e3c48ce5279a1f0d60e7cc8c3f6777acfa6b5b6a1ba92fb27ae082f71de79dc140cd1f1d09b607c2191c41f05380eafed621a1e89a9c7f992c7b9b7d38c78c52c4687c3661e8d352fc856cc604c2757923dfaf9d539d7c52b9940f8eea98874a2b1c866c4c411c8ca6b415608fbfeacd650344dc43ecaa327c1249c5e929c824458cffca9299bdda9b1dda6b5d1ccae32a7a6688694c9f6766f9c6628d60e0dd972774b022a8e6c5a00b02177fa2dbf5530684d20ea4967a028c4ad8798a37be098a9c9922094c9ed1a1a022bef7f7358c4026867c62f73a4b1bd63afcf665ae2ed45137025ce3a40efa57ca30453ad638e1b5841681dfeaed70555e72ba7f26b4ff9c5f500d1f1767ba60676e883d27cad180e83d20a6fe35e2fa7daeffda46ffa2a96f98da651107948cdb1cdb41a67be9cc4e0219cef789906594170981ca0570701d20189875212d962d4003b5980f1f537ec2c84caffafb2fde5d388f5885872d392ed771639ce179fb32ede93cc85ebcef6e224de76c90752656a23abec05b06222681d46dd422ae340f8194f74dee9460bd653358d89208c5df16a90fd636bed8f1706ea67cce5568fac0a7cd0b6f44f808a5f86a3cf799c7943a3aaacc88430af6ad5f09ac4fde5826143f90708687fd1398d4d8f1483095cfa26798d9fc37ce62e00020d59a51890764c6056a2f07846e9be05fa5a698690120b3776cf87b928efed931f71da790522533908b6ffd65b38a2f12cd72eb9721d1c33d3db00500a26c8ce36e4155b290a2009cb5e6b891bbfc992e2917e8c78aec9f3981fc84727263fe731300c2583b620ee19396c2aeb4a0accbb08486e4701bea23e6d99354acc156e270bd02b850fc4f9989f2e6fdf5530217db8a3954193b93870329aeba9bc613d1849544d0bd10c0bc4155fcc749d6ac8f74a0703b1ce3e4b32bae9c2f627d039a735fe575a78ce6a3a9a514038867d09372984ae9d00ff0d5336fcf37356c7b49564fc9f69c7c767edb167f11f2924246a2da5690ef54be58d60e43aec73c5ad0bf50cb84de31b67289eb096e2141e7c62109e86a2a2ddbad184d06a482aa1194fc6dd05fdb4587fe032695a2fb899807b3d3acb59d3d2abc83a885588e6c589d938cdb5a2b688ec4e1f202b6ecd9af0baa22bd242e337a97b019b9b59e18a52c722e3d748de9079e8ee5634af3c810901f5e65517a5f4d97bf5423553006f9d5a4789984e101b7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
