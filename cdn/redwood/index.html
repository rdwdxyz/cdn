<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48b5080929bb5ea71f20d77dd9ab7c13daad929d431caeb676e51347b305918f5d23702803236535328d3fc8defeb6d9c569d59243d2954f0c787a5fc41aa6d5bdb95fe9f8df7e93adfcfdfb272c51afe0a10c2eca7bd28aef776d29368e6896013ca6acc8af9bf38ab92f2f7ed7ab8879d4cb9cf51a69824cb235a2059d0d617ef6d86e23ecc58e211542747c72dfa2f9427233c69a31a95d8714b0a68a08572747c832686fddb4aec84f2f8a8e7f98b5451aca825f880dfe98c2ceb4c6f6cf35384787a8684f057581340bfcb05508d6670a15edb9db781af0cc36ce97b30e6dcad6f8b0ad1cac695e9a7631e3dcaad7294a5be906359002fde464def24c957e402b3e0022f4c8dc292910ffa2ec1f8339d52c097e6306c781f7418e20db5d31384727f2303b3e5cd35c9ca9021b3e062599ee1dcef0cf3f93884a5a9d726e2496c81e1e7d166def26d24bc4888c01c0ca2b281df5e37f4d45ded712783c482a90941b04e2e6e22883f19c9045dee187e9d9506dc94d4152ea4ef08dac2031cc3c749fe96c2a7d116b4e54d63e2681e47d2499a51de938b9845907091cf01aaf2506ea0d5008823bb83c14ead4ea418141a0c49d26daec23ea7185048760d3c31afafeb092b8288322fda41e4d32e90b6e6019eba84558101cbaa92b976066e8f7f6b44af4a98edff4a3ff701e64213ff7c3e72521b561add1e3d26077bfc4303c4bd4311dad94315da27de5238c323eccc785ef99c6018e924333252097739d696c249705a62cca87f16157972e7a6ae9c66d28dbaba9eaa21ccf23cc126f759c4c67af67addb92e1d6b56ecd283eba987d6b59da93f7457d0738c671762be5be026bdb7bba080eca5fd8bf16d4adecc83e494911cfd3fa0782a75e824d0180610978944435b5293e8eb4f39466207828b38c4593ded174af29b09e3ff4d12a96ade50d8e6efd944631eb519c9821580cf9a3d7e02a32a0056f3725b445894f4a576fd581f89ed9c2e87115ac8dd96e6e918c60311dbbbeb2bf9110abd2ee38da5e3758d3d18681ddf80ffd6202c6cbf5bf58bb8adbe1e90181b8eef062be8c5a56a4aa07acb533f0fc718b8574557d6ddd898a8f9292e3343fef98c53102969c446efbd89b36efa9f3e92f530362de80c57a9095a36635e643fc0ac7997d18bb8d32b4852aa7cc49ad5b286912cd0dd2eab6891412f3a2183898028769d64e2a38156f84f0d6df6fc4c882f75f3e88555dcb9511af6ce8189ce2cc871d2997fab22e72ca64e11392d5a25d64b7eae46748a318801cc6cec6a7df363ca218fb31116c75d22dc9531b1b16cd800bf860638de928667f49b1de56cd2fc534ca9714667f6a023d81db15d223d93471e46c8d14c0db9d903be51f203d0b0f03ec8cde2238117c978d1271286ec805fcb0e2ef826393bb4b7c937e49f199b8925ca42e543153300b65a7dccd2dda18c50add4ef8db08b7a14bfed2ba189d5c509e5cd04a44eecf81cbb33723b76fc2636bc9f8ed5bc4c5eb0b721e3c44e55aab0d33585e5e96c2275348c28c17f9b8ad3d6322ffb67cfadf654189b99869ec2165cffff7254f58a465333ed0393406c264de7f894862ee3b14fef9453f8ae77011f61f8e3cff20bb3c3f697c532583f1a96c6792d0ace47db08a9c665b38e4da1741af9fe99d752f302e008760fa523150442b4aa3ffccf838595c78a5da12abd680c8ab980320027abf0f17a7346a441d6a1df5db2ceb8bade020cad73feff409683b393dd41c6f2fdba1f4118d4fff3f12249b903de2e0c96567dd5290530bc0deb5efaa77b2a5860bb4260110e108c4d09e123fa1a8cd4b3ceb137cc63dbd331d6d48cb7e03f595d6a32da48c90dd8e80170935f6ce012f293460f01a150dcef7bbc91f77ca97fbe1319e42e168af0ce37c776b42b33e8661308c806035a66db82b803437d3a0eb46d3f36330a9c28e56ef0cd73b8ff55c09d09feb34d88df9ef1681dbb9d127e6a79373be784e3276a78f409301772663dec386041ce7d429cb5ef20cff85b4fb9c8a87490c4ed17b93e16805893c8d4b889cf5e3c16ea59a35fa94b9512690d6fad236675e2d681bb2bf17dd110e156dfdb2460d42115cc1ff5bfa3623ebbff67bd6af12d788a479b32e30b27e5d804bbd92373a733e68e77efea2138a79420344f17f182773a5ad86b958ae8948a5f24b74077adca4256cd4dba453f4ef7abf1c47949c865126c6c4e0a5f7c22e6b4ae03879c1cd5a81b958fc18b3256bca941de1b06fb20166b384a6d7892ab442ca2fb9c14830b53caa545bbd6846ce6bbcb3af3036e020425dd4f211517d0daf8f3bb38fb9453f4ebb8d5b6608407f8c6020eaf140e7ef23581c141a81e5d03424bafa9045219f76c39d1c020025f56e6b10883b4cbbc395b89eda011925e006222a1ee8f386985d7f59dbaaf5d650e0adfb5f8cb5460e4e51b5e4118d427fc9337545816ee1d0206315b0e46f40c233f68c75d4f999778dbe36c4152661c3ac600b513bc06d8856b2f85e0640c017211e657873c87e9c0e7f85dd4bbe966ca932803cf216dd38dd99ee16dc6da889b0d076f5eb2eaf91ab19ec2dc933ad45963dc04fb1c4cee82fcd14cb597b53f7dd06ff7007e17c3a8dacbdb6e5c50534224bb79b7c08054b0f959f7c5ef2dced93c24ce770a73c75240e3667035a81ebef7f0c3a1e3615306733f83546dd948472357923142e1e0d819d620ae276de3ec202bcec09e1380d2d60ef8970343774c7efa1b53c43444be1a199bc76e6c46e91e7fae9887abb41a7e159c1d653f3a18fe973266516c72a9562812c6e4d4120fb27e636537e465fd7d01b1cdcdbfb75aee3399f860c76ebaf4dc0579f93b81c8e64d2325720db9ce63024efc61bec4f146a149a1bb34efa797a466915ce41ff89081bda9c55423c35003b1a161255df2782436ac75ce8277fb989e78613c57d32f095bc10322f76c53a2fd71d554ab15259529cb628f71c9148c480cc8fdd3f266d7ca26e0fafb4ab400dcbcfd57bfe80e5c53cb9fad2807409c6dc997eae48fd25b518639a344c51ab1237bac43e0ef60b19c8c3dda351037f2a201c9802bffffe07faf90050e8ae5bd48dc0af1298c0ab2b61782bedbfe9d30ed560b9129177c738be189acee0e06a7ebd7d1205402c75b785b8a3bbec784eca53f4f7f9c27954d1402e0d2a4671515f4444def9dce449293485ac0367d4fca5f43924780e347018a771a92f03ac00f978af58480950dd1dc725888d541e47928c663ffc914ad203a83a3463083c137f58d4d18587500bd653a57a6ebe61eabe613d82bb7dde05fd9bb5bbf299157b5d0463df13d01f163c6dbcac29ad1bcbdebd8a8bf6e03254742a57a285317cf30b505e0d0051c5c234417bbf0d9d2a998c8f866f6eac3ddd66788a75d78692e3eefc3b0579a46caaf5c1bd9a3f8afc7dd4e43dfa63f8a434ca9c104aa0bb0d45174aa6185d2653e3476880cb0707d1db594d739117ac19101335393abe15416a0cb0879c9d0cea09d7f75d3ddc6e01d34d028014da4f21b3f107cba99d7830794a1053537a3649e5614c2f30a0d168df1284a7814bfaefc11c0bd4a1e1addef8d8837aa4c46403f6f90f5d0b9ec4265b4a649ce302f829e81d159e35e77b6f8c21026d7baa23ca182b2a94c6077ccfc8b5824c51a8ee326e0c1e04209feb0d524cb2094b0f248552c033f71e4fb980a61b987c60108861d5b212ea4a7f1000c32f479826f9d41ae624c232fa3a098a0ee56db9d4b9fe5ba08e2bdcb5fb5d1b76723cb63badcf541694fead2841ac695d3bd1694153346ca51de1e00b78f8bda9bd5611b9611deb090dc4bb025b8fc5ae746f57e692366777956f0b295fc464245da38c8182921dec4d7ec743512855596bde36bb2db02151b5bd66754051b5967ac0ff39fe0639e4d4fbceab0c56b5595bda088b9dada6b5fa8f4d2b69cc22bd2b3233d8f45ae5c3b85feb070e198bbc3247d81936bfc5e4da026969c2a555ed80afc6db7c3f77403f5cb77a889cad4ca75a72f4cd0563d72848b62e9b02c38b6c9fc42ab20d244bcf9d33e8f412981d90d088779161a856873d6cbcae14cec8bd8a6d8616b659dbe62d74f9cfbd04256eed779e385fef831e1c416c793d8fe532312d3758920b0821da7b629b002130fa20905a83685ecbddddcbe0577e572068bba5dd6f10922163796e2c19962f55d7ab1e13821ff731674908fc7224000cc49d95b26bbd5c61f7acdd1b800ddc6f3adf680f5de678a9b59fe4fbfba8b57d0018a53cdd17676da03777d34f295a4151801f8d1c0c6bbd7065d218494b0d71bfdf8d83898cebccedc91d2358a335335e9ff04d9c045764e843042e8ee43c954dd65de837142e70f6769d4dbd71b4d23ee4340a33229b6f8ef9b96b9fbdd5c2d7a569eaae4757db00c1af4205025fd744b8cfcda4ff7699da8d5dcd57d356b864b22dc4e0f3e81760356781d6d7130132dfe3a7d9d26037f3ecf0363265f656ce25fe9436ed5de9b62ff696a1237d11e095bd814b67f479eb5b30be8c6f487b259829a16f3ab25d4ec67fa39193326012d7468c4b9159994545c3c903bda8dffccc0d531f627aeaf74310ae122f1d6a7e72c464a81da902bfe483596f587cc15c61a6e8a295093c61c3aec5a99563eb84bba463be2c372c58d694dab89fb78b2d55af766de6a63f70976b2d7d585bb28efcf62c3de796426245878c32e81db094c4a3f5ff358352804cc3b7dbc3e7b1f44d3841e8f7a72ddabad0227cf7ba5bbfcd72e3930a99c8cf0707eaca8182d0723c7f84fce2179fa63f59027628af6afcd81d52776482c5ed97c05604537d1676bb202fb9ecc06a7817829960494c4bd7ce0510031aca10946cc9f59cdad76c32536b890a661d66e715f8029461ea8a2ac2716fe3ae15bdd1906c3688d057db3c45902dad910019ceaaa1fae1e9eff66c74014b409f23a4be16a96f2aa91e7e98663734d8db19b673c5515250ecaedff50bb83c01fdc78650c5bf17a4c0a4be1e3bebe0166f84faed4d2a45bf612f75ecbfd46be418d542e9813cbcf330c261dc23c2101885ce260c9355bd6e9f18750867e858b519626f9ea9bc92aabd6ea1613f9444982f736b2eaa78d1074a30dd995952fe5ae9ae0999bbc3c98870a8833f4bdbfb938d0e284ca9f000033468f1b9ec06c198f06d064112fa5625e014dc8d47e3f1b1c6e4b7e7d60ee065fc76276843285053a747abcd8bdac13766bb1d0b2fc04b19837d589bd866eb7cca24ce442df4d7581463eb224f3789a2ca9b6ad5e99170a02683900372bd1b5a92de5cc5cd024fa938137abd079fd4fb79b7692645aa76d5d44ebe453099eb3289fe7c54beaccead0a8310789667d593411b5538899b3f67f866509cc5b86d4176a567765e81d88af68e3fd65ec8c351b4528ac790db9dd985bc28ec295c6259f3d82a09b4b3cd633eede913f2b678723d22e1dd1617b76300f740b344a74a6e1a44d0bb1ae0218a566b6b7d91cfb68a9266e4162cbed0eb2d082efb265db8b9fa5e3bdda2d40a615b8b4dc1f036bf1f00b3e2fc232fa5e96d28156c61aff71066b885ef27850be91bce6727f0086a3b03301ae2f67de3ae0cbf5a4525869b490e9c10d4aa3fea27e7d250ac05becff17b8325c4a0e4f9feb72a38aa636fb5da3b9825595e7a400bc3653fd1e5e1861e6eaaa4345592f17e6870f4207e330067f201c1b47b7fc3c921ecb5f51fba669b5d4d191d49ecfcc07bd41c3616771498dcf5f57ccb9e21e0a202f8bc8fbca775f1bacfcc0d1ca1d580523d0c97a82e2d8e29ab51cfe81cb8ba05eda3919ee9a5d115f49078d9840a246c27f1bd251c3efdd573421c28d79f11fd745bff344725f03c1e4105bdcebb317513582287e5194f31e9882ea30fe09406128ba031ebdc632dac0f84a932f9e7e0798994defdd563e070eeece1f03a4bcb3d1832119fc66a9fa91c5ba418ebea3114a89a044b1105ed3b9692472e1c2d1def18ed30d5d8416681983c6e46ad6fcd9b1538b8cd5a913d48f23ea070cf8384bd0117130a5bd1ecc196bf7ad1213bd576f80ac48a345ad5ce53b3b4113b1a1180082a7993ff667e3e17a2ff5674e457cfbab43e533e334cffbad9b16843830876082a8bbe50892d064c1b14f15771e7204e31dc5fd41351d0d652bf8753c5b06e0df980726826be81bcbf463852bb825ec6f853efaf6be63eeccd2f901ffaf3733cac5e5322d7f18366ef84b47c1421aa2ad7b34a66c61883e68dd4f7d98edd31cd65d3dbf54117d478728eaedc3eafd0cd156b4dcbaad7b78630428ded78ad27be6adc375eda061f9d0e41838c6c852247a41a7041d5d325feb4eac6e2741b6a0a3a587398bcbb6bb7885b249088314c44b6059d074d5f14f4c8d24ec919d0a37a6327f93b89c4e030b86cb86c17c4874d3964e7f55f9c2d57bc6cae63ac6881af12ff3e635d7a06adcc0db67e221646c2f413cd401ceb77d39317f5fa582f66928b8572ebf05c7ef55bc5ca22a83a24162e9fbf53d7f13211614ad288d86e23b9900a9842c6620f85748e2f0fba06d5d09f989b3a5a6a5005eb34ef085657816fa1ac159f6e6745265bcdc699dd2b329597d572501a5a7591d007226ec2044f71ebb428f7c290fb673c9f4f428681f287314e99bdbb162682b2857217df45c5136c8f6e6ef2467ffd5fc128b88dfa27fe98ca18460f7cb0ae45c4ad1a93fc9f26e2b570be4ed895bc6bfb4984010fad84805d45b5b56d6135c9423f38e278bf0a7e7ed3371905bb46c742fc96b7c2759fa0c944ab51f40844ad7dc6bede6cf81c5c4b107d67b98c128ef7cca1ebc2b25f5bbf7a5ee956b966ba3bcc244c2faa44c5124e1ee7e8885cb753da928e29c290107e13117f6b02a7591262483f3c0e5c35194748b546bd2c3774df068496ee0339afc673d5c1f46996c2c78afeb12f1613b7b2090f88dbed99799bf35e74ce33dd2d3b6a5433058a82ab3ebba4bdb717549f023f1cf9475835c2349d6d349bd58c6fa675d03548e1115018b9ed0be9dd22fbbb3d0bbb2c8a1bc823bb0988e2db94d758d0a8f7b12796d7d8b05e0fb310d4147b7eaf83272c1898dd88329f212c6d62b1195de3a478e9f2b15b15c74b3167a99933653f0d3508a5eb060a0afe6026a861eccef2a5799b206fb9bf47e5442dd38695aeefc0232e27030e5c84874295de9bfe9e60e65d11f00de384687462d8e18d40f9b81955debd3d4350549fe4e519f990b2a0db903992c839261f97c3933d5b27cdc3064a37451d8f7ee5b6984adccdcf3dd9403e03d52fe722cc1cd83f5a7ec466b2dee7df6de7f10cdc942a90eb79bc86175cf57356f81a09dad9e270e71a9257d1a338794fdde36eb832c7a2362776a6e9dd524c6480a71f62cfa18dfcad8a14b8b9153609d920cc4fbf64271648441056c74a62182b046ad4f08e55a17a61c8dd887cafffcadfb3cf2679cf8a5f1358679b47b17c8107ac6388432cc67d4fef75869c07be2735ecb4a09d344f147aa49d185f4947498dea8159130697d940d1957f5be98d0bccc36d5f97f3a0a1671d01221f9e1b3c7e7abb12d43c13c96a9aa12593499176441a990c6cff16297175b6835078399704d402ce0b1aca04a80a2df9205ae6e24eac45ad2630758284152a2a76577cc7f3a6daabadfdc136cb91a5b2b8a577cdb97798d2f43a6e56846417b54389c87eb8a39b28ef4b848aea53f41e2168ea2f4c2fa4dc94dd87370ac0e45ab3d563fcefe34337290067563979985a2ab34a4b181bb70f724b5a5e8cd0e075d1a1bba8c43f17a56dbdfca5cab28582b191a8774e8a33a7921fd71149ac3fdff0c59f5cfc2ffc9c343bc9e16ee91a4c8dd91530b9efac534bd62c90ee679bbe7dc65acf5d82f42d254d8488c824c939d5c59859c0a196c3845b161e7eb9988b56f33595dcb81aace6a58654ed250e9c7015e3fa76c1cb4ec055d8f04d8fb2d9744629c6a6d88fbfca5690ea6198d66cf6f7bb6767ab7791d1580e3aaae365495a496ae8cc67ba3199c8b71e574a06c136dcb2b1bed2ace655378207278956702f615155675b13c0ab1f76f522cc50e5913a40c41473128ec7e78b20d47867b94c2947a941b4983318a5e1d79f997ce2703cfb8a62709c51063680b18158eb80a25607bfb81c55752d43d71c57cfd054e8caf26955daed4a0ac223efd20979ce7d48cc20784b3877464865c8f403673721d7d7f14a07b8d2d8ca1cc6b670887c24f8bf8d70c97f0d43fb66ca96d0e6ac5b0a37c22545883e4393716f9e952ab809740bec6014a0ca94c1d44926c31ba842c1e61d286a8f5573e4b75a4b0d21bcfcf5ac6c13da76dc367161e9861606fd28a4af728b169f037562141859789836d874516e59f3c5932ca1c5a4f5616156e2a8078adad7718b923191913dd22ba050b0185da133cc8558412cfeed5e55acefb89349c6720f8adf69c144b1f8e2b567794a30c0fdab117f9cc6c06dd92bd12da7a04174ee257f96901c40a4eb543e48dc6c0f0f34cb3fa48d5491172eb37ea7bd8ec27ff5a7dcac97de5e08815c6f6b9a8c0971f8035ec69dc42e344ad3053c32aeb81efc3e1ce6b698915634bb82a47e5233868ef083b0d954cac58c9d9de4566f4090cebbb92f95afab0bd26eb781c95f45917a4cc0c01816cf5d5ad6427342ab14d6fb8212a8839b91927ce5daa60669859991d27b7d220f84fc0c20eb634977b12f328f1ae3b35f161d5acd78da830179a7b380b85538bb6d4fdf11efc5419ea3ae29616314b2799e28ae0d4920e5796b9a5e49d693632563422a4de2d0334b0f0f7f0075c106611ea38499e6fdaac4af1d2fb398aec5f669f4bae385788418c29dc6c959bee199d3394ab149d3780492f94072551212e630c28f0d65d2f9d38195e2611f4d27710663d41293ceb8640b7e561bac4b41e8eebd0143394ed90331b64f75f79f9001fb27f15ee98b845b4108b3e5b6244dc574e80b447741b01d308a0177430377218585b5d10471e8e4bf605d0e91c405750508977bf1930c6d72c51f583c6cddd9cbee2ceb59c6f7495940d783a46ef4b6ef9dabb7cea58c6c2a09004433b56872de559f25683b8e36a50c40932e115223c76ef5ebb038e800c97772575d4bcc77c15f9a76311681ec63bf329c2163d0f376adcec655d20df479206f7ad42babcd2545cda70171f8afb3cefc795f439b00670c04e62f655ad28226079175ee2337aff29ec4f4f7f410e3ed59066ebebe5f7863020fbacb96a23dfaae933c9ae87071cf5f01cd21f891a92198b53f09a689fcaa21fb175445715119229e96587f80d3082f7b38aeaaf844f268696832c79b5754ce00231d6043b8d50d5e9da0f7ba0d6864f945239c8f27d438a90bf71cff3c1e98dcefef768acbb81e60f340f61d836a10df6a5c0a797ce6ade9f354917ab7a418c55fb89f708bb9bc113764b490e22dcebe6926bc7c11e5539606d27dcbddb4d65990c1b3ee1d31ccee4fd43ecc938b445990f9e4fe0d1602a1ed381caa0ab538152a488fa33df11bc6f0d11a5122a85f9e9aee8f9fd5509a20b8ff030f51ebed65e8213d6ebdc9e46b3a7fcaac22c5863df10353f99290b779ef84fb772f3df72cc917573fc3341d275306756b722fc9e2d0a65bf4add508ac8b7c2516a054ffaf694e28ff81fb8be9f1d4d04be233926d8fc45549c6df741a7ed9b0d092dd36b59048d84d754f081d83c8d18fcf1af3cb5372d648492aa7df1029a478b74371bfe3dcabc29cc3e89db7a29822657820a455491664faba2335064f5370110ba95b1bf341a44431dc33fb835e823f82d08c816ad93485aa2a00eda95bcab574e6a0cb9a9b71521fb9d85bd177f7d5da8b508a4363af760ec24eb80befc6b59029a0c5bff28389fda7de72b83dd91a22800fb5902b08cb366138f25862f0db5d9398c8d35386dd16e9da1f907c1db875cfe6caf40a1a1e89177e24a6c214cd9f236a6d4a4e2702c3c204495211e09cedb160fbaee99a13505c2c2af0eee6a5808d4ed4fa807deedf2a7499d0725dcbc58f0324f362e053a2eb69833ab15e2263788575c841b1c2ccdf5edfa9e8cf2b2ed8d218db58eeefbe4c6a3e3592d4c0648ce2776780936d69e583a8273550baa338ce3855318f42062dfdbf659ac6f8f4e5ebe9be2124d8e66d8054039a4feb607be405d68b906dd964f49876be764d2001b7e9874d04f9525a737b998dc6d84ad1bf7d20757954c5423b4e5f8fdb8b2ae3c3b1b45feb8baf413f7ad2350caa5465b6f6961c7a5ad18ff80ae78cd0c52bcc4bc7242f0e89dadb7eb813c8c382f077febb0c9369c42d9b4c5ea42eb537d7f870e44c4afaab50470b8d364e9018fbc7f9f8fdcf5fbac43349f33ccb363679bf930510be3d872f4f1d01b3778cc99d23b4110121775ce80b9003a774fb57437831ccd0bdbc3e1d3c75ad9ef394f8e357a5e9a396d02ededb38cecbd86821e7bbdb57a012146d4199daed6f3e8d2c54689f87953ddd4973d4bf7614226714ab8887cb3a042387c5c880373b1bcadd9c93eba23da08cbc34f9afcfb9816098110d60e258d57a782dcd74f09daf3333977cbb085fd4ee04bf14731d5c94097dfaf40057592fa4603c5431c89ebd9ff925ca4d5bf4deaeb2c1f1cffbb4f3e5397b28204551324167e8c4fec619d2067555455e2f669c26b5d750bd06e478fc8aa94ef5e6d0345a2219e1716dbcbad0b88cec22fe6e2cc8c732a594187ae453951708b81a8bdcd539182ab661c5c0d4546d6b578c52cf28679b8e4c979794c519109a029260b124aaf9fcb25ec77580c37aa2c1a4e4032b47ed8cb5565a4a12a7ce8c5d0110aee0644a0943e613bd758cef79087b07e7dbb5a1c6bc8836120e0537b7351f2efe55dd9760a2c317999d63b1e3eed8ac04cd80209417c295b12fba1ee0e9a4b0a2a731a7ec6b1ac0743e2a92b94ec2cfe225af8e70bd4e24d0a25e314c2d7fc8abd0a3f3bd4d4db9cd8b7d87eb7bf884230d4bcdf610b247d860452c5e3853b2c50652be2605a9d92537747e1f87775ede7cf7497e6471a7905a21ddb0aee9ae027c7a1d1ffc95f8821e3c6322736a11e15682233cc31d9e74a8351cba05f144d724483f88e35349be1de4010518a1d5719cff2dc3b26f0b300f3cc103935e14acf9c0919d1b9bd787606ded9da5173cc81aa2f04df43010adc8165bcea0736d63fbbc42841b1a01219f7cb9f60091906ed88314a78f4590ada66e3a27b3c0b446d9461fda94b55e14a1fbda5209618c445c006998906e3f3f075020932a2cabefb937704daaba8b9144005476f6820f4edea38c3c9063a83ebdede38a1699b2c61173a83a066a7f2935903f01fb0918e3ae776dcd899a2ba2947dc45a9a23e8f98d89b5edca986e24bb6d96d3ebfa0c7d204aeb4a190c63169dcb6cb4eb20e64b062b177e741c5ce4ba8284720ff868e487f7e13568f5ff57ef66520dd4d181d8113616f4ec6fa4ef49eae3fcc9fa40ea73d09dff2f60b1b95a415495cc433c75368b0df0733e8632e5e9ef75507826cd2ee73f7394c2318eaec4a5005d2d518849094f725dcbce57720fce9c166175d8b1cd077270873049ccf801012d318e98f7419afd2f271711d02a604282476d4caeb3a5e17dcb8594134beee9b5c2a42c4773d9529b0ca0b0267b355b2c52455b131db4bc503261d72996f94ef8d4a88174ac3c995b8d0e7b127f35ab6ad0f913a87ef3598fc4095331b8a46609f6d27f8de2cf4c6b062e0ff5952a96ee5768d937f02e0bb1412410c4553f747291f5bb18914b3121751615f2621ca24e95d477e8d11a2859541960caa22eccdfa8654899046464e13fdee102e2b27bdc6b7af4160dc8fd8731009c00b7fa9b5a3d571ba02b6c792e7964f70358e2c08d29dc0d41abecf701c4fd39821ee2f1927799b4aae442a9bc9e3449379c340fdd2f73daee9927d58228c3eb106e6dc57fe2b88a3767636e69f23a89e87a02052ceef0b3ecd9f31003829bef4d1dc15664f014796881d5a1d983f3d16901424d74521667aed1324c3f01ed238bf9053683f34879b410fd4a8c2004b06c9640ebc6e255096ddd76e6f236f194c4ffde16e40e2cd9b23c73b8af0061cc09a2d13e2ef7ab1e11e8b8c35bff8a7446f92c57675b8c689f5735603743c6e1cbe181dc9eb5d06a5cffb50e55c396ddf0832c87d6a86e05d65b3c31b7d383161b7cceaa53f1d55d35e8cd4340f14bc9a75969bd3ea4fe159755a065f77381850c548bd20e7e658dcef67b6bc1dfae57ec366a10d42f175e191f824bebe7068485ab36100c89bc19f4a5b5c3a40d403a4e226420558284db9dae27f3640e4390c3ce421c9d7d58337d19fce0b6b63d7eee0c0653a1a9f871c9e3aa909389e3c4aa4a94f8e2aac71fd2213e8aa3593d6025197390d3b0dd49ece404cdea5a74066cf13568cd4f445ddf1745d9e3cd1d8e374d5982b80167945eda0105f3c4ce6a56314b1bf59236943c6b50acd2eab7e86f6214a443e2e3084cdb090a362db79a5c8d88fe62e111faf19c44010b0971a1013465d4a3a5d0f2081ffb6e69af2a198f12b8c51d33b261fd671c56403ff26257a00a9d0a3b92476afaced6305c97e9350f2d121c7c13ebfa19344753eabde7f58f07b0b91c737529b2b995611a33436a6f1ac3cf9c0a1613f9352829b1789adb0c99d6c1ebd88215a43bbc5fb336848fe7f2664fc4037fc8aed73676763e4e0c089c8a3c38f16973964be0081cfb48bdc3160b10cfc3a5d3fc4283fd764f04e4afc5d3f75b71b7935b3e2a19abe690ce9cb232be705d858e4799af21d922312fcf7668e888d8aeb2368c20dd057c266afcf908e1ebf2db0da95be6d27433fbd48d1f604d35abd15bbc9fc5814cfcfb12f074fce09ed2bf4cf561ff26ca9f7b17cf925dfd159868ac41cb38d45c31abef5c31bd3f6d99582a5393ab0cbb92a33436debf97d1f391de27011fa476828ad7ea07c75ef9078e0a85820db0712a7dd2b138d0f9ecd1e07c32418fb50dd044d503ee71a41c029414a27d49ab746ffa9045322bb8c76d750dcaaee6361cf6c335f7cb0b320047cbc994dfbc06a2ff378b2b19539fd834b27c3345f8840c6ffa0a04cf556921312b41d4caf3be237de5220f3cb46ba5b5a595cbe3320ef2769ba9f546f67021336614c109019cada008d37d79026600cdf3e2ea0346b7c489f59be4583a5a90d34a02622be77274d041b0e99bee416cf4dcf5c87057d5d79362922f5d48ca6377fe5003c5f27dfa6c866895fde63f79ea6238dec715e6d3c4c4ec3394abb6d8a2c0288376a5355ef22f87ca5a072be035bb854fd5fc9e848066639701b2d036dc56cf176078b4f6ca6cc8a1d6ffe7f9e0e08a69281f347e9126a2af1efb1eb599ebfbfb6a1f0da47790a56fb83fae04ce107a9889afd7a0f17d9bfde474825fd2566da85d6e0964aa8de582a0b1a0e0fd1f6dcb01c71c70768be279f0305ba1d939dcfc5fb2198dbbca60748c0a919d0844ed13f8bc54709d1b2e388b28db0f0afaadb0351538617adc5bd4b8c775b8f6fb622df35e9408f7b490eb0bcfefd7b2e84b547e8923ce2b2333afaa45b52ab1d83d8e35b960ed0e9f4fa42462b502b081ff7f168b35cd8942c989dbfdb7ab4c0606452b57eabe26b3cfbe9809ee75ce13a27e51614e866b9cdf867f80c5481f3864de24d88e959bb675386f099b0fedd8e0c23b6f6f807a4650485dbb20c1b10c29c03b2e270d1a54076b6d3c2b90899ac530c99f7448245272b3a7b7960486a57024b8df4703565643b86ed8d3fa8bc158cb5ff8b13f01fded81245d86dc15486fcb90d47ef34f971aea5dc0f40995774ba0eb6caaef12903728d6a218232344ce2cfff5d5be0b0781de32ec716d327e7a7bb7f0984fb906153fc0b52b36cefd71268f01a46443b676075f42351d8151cbc7e79a5e70b63f7fd33f2bde170e3081b9b919cef0b62b4fcb2cade002e6e24ae8fe9f2687b233acc74181c316ba430c49c05dc35ac69c567e09e1b99a98fbf8e59f5029d43f3720cfb8ce617f2a8de7cf186429f56e2b8a9fdcebd42d17500bb37c1145f48cdce2497c60bd7dadd8ef4de884c5c1ed760414e4a006c9a27e4fa362abd4455b10cf26178efdac334c8c4bed1acf40ea4d97dbd94e0081e7dce3707d1aac43f898b51be0ec6cd844c9018f46459840a409b07b55e19c22f402c3045ec38d73ff381b66303e679373edb691fbe948cd5724a240bd41bd09be76ea69d0fba12d6c27bb33669bf91671bb01f296e527b5a8b5af0eb28824eea9e779234e102f24f1ebf9c9a21e523da10547b554a36ff6eb8a2787a750fa476a9ff84a564395621d36f5b489113813d8061c6ffb0283db3f7ddbd57e094de54149199270c43d2771a73c7506f55cd1d0c2f541b562766831ba9c8cae54fe7b4de39fc2b1a179da0cd9b39a507e7c15a161eb2458a6fcfcdc043cc3f0f00193748b7f3f33b89926fc88623d7fd0cc7d983d80e948048c21d5bb7dde91dcc1cda1990c04498d829a8f1f573a50b94ea4f6740c7b5c3c38bb692461999534d4442dcee447adaa014d3e4d825d73c4c67de7fd94b81b15b86c262a04534cf6a7eeed7497ec8e5ddaf96ff716af8bde8b8a681fd835011f88fd337d52cae7758354e4c3eecb6aab8b0e90ea01b773f7fd5f023075d8171eb17968cdc4a838132b2b4b267cfc7cb77f4b898fb1c91a541d8ddf15788786b4bda0af83dd6a88576ea6c147400963821f61423c36d636d785adb6ec48859639323ccd380e08ac815a3a598f4b96a99b7cd3a07c605f43f684443e414459c0cc4ad003757b1e1a11801da860dc1f69df48bf6be413b0843134f59417793887cb6eb861e402d6afd113a6e08fad753257260018d94951c7ed443a86ba164b5b366109c3cf03a652dac27afee014cd708e3c78b903a177c6d9904f7d5acc88b1fd17c6a82ea58d01f3acf53293c4418cf00182740c098ba43644bb696a64a74b4dc7b5a674e46121bbe8c2381b43dfefa6add73de726bc2a1d770f8773e4a0399e57018c13268c718b8f85821e2a0d9c1ab13df5c4f7cb42f7b0577e5718cbf222c9d46c5b40cff564d1c6f6dd2c97fbe4b12ca77eb646ba16da1128d069596031955f3f61b9489c38bb6cc013cfaba7bd27d5c8c5acfabdd92f6dd693afa687c59763debbcfde23210111a449154aa9c95edbe1e788bfea7640775973569af198c099c08b650d97e5fef595ec677312e44e9df8cb43f6f0d5b8d16ec8c531741babdfa9d319e3f4c1a2feced93cd9d1c87f52e85cca94fc16e0f5f36bd2ffaa80f2d2a2d3bbc7c7fd7a08251b825c9c65ce789472af654983991caa2ee3a37e83aa086c9852cb4fe03ee8e954d6b6233b04a2b0145217a79e61b5f6a24575a87373ad7eed8b5034ff2252e12855cb89e7a04983ecc717b30127bfadf2dfa38a1a534fdeaac46129c5b69ab0cd4bc107438efa6a61671055554333d2a903d6cb52a92ae50e2cb57cd970178ff292c85a9053141616a65769c4aaae30a63da3e01815e3eadd11b8de1174990bc626d846f3ba127ad063cf27066456da6400cc72e07fba3c8d27360f541557f02393eb3f23194701638bc16137b19e80dff88785f4bb3dd92c46503196cb33ca7056387e9c146d78610d213ec52ce5a4d10a0eb7199ce704def30217521d099da6eac757360cfa2844556d8e063e820719eb5a870bdec2d75fbe35a70635a6c6285a523e36b4fe72cf51e6c5d559fa7134e14ffe5ceac57ab05bf43a1d30ec31e9a5787f09c21a7cfac9099d2e8ca331285b832cff9297152acf5fce4fcc7cdfe9b0f7d5049c442fb61d77914f4d907649e8aa79b77639a1a56aeb89b9d1ff80aea0f6a8dd10fa652aff7ceca611f689e08827ae7c58f4929029de59489ef0683b76c3a6ac4e83907e2704ba600773345dafcdc84034ebb284f75c8512b46107092488b60bd5db78b3b9fb9c66bc345e2322a6bb720141c2cc1ae2d08beee2ba969bd02877b012356450022e3fb027849eb7350d50904c6c505e9ab310805065fe7f8af71012dbab9cde27098904c9efed9ec145283c5434fae3e097a4a10430266162fe535bc6606febc979d9302d486750b0696f5244a994aa9d0d8c460f5873259fd0da1c225e39483d21d4829e747c6eeb8f75f7487e6f509afd7ca323a47ff20729927fe754b315dd3057ead92df535c3997f75798fcf4518a8a56b5b36a55b85ad4f9c539303058797231adb89b4eb4c8e9ea870a745579cdb3c55ed395e9b90e3ac2e019efbe20d301adba59298cbe4a595f2d9e0c6ec4c5848ed122349adb40eda0db0686070f127a68c6de3f44412336729d9caf33eb95a20bbc8698400d90a598e87c3d290b1d148b4c8e86758d81f965d45e59059c78a6a713ecaa1ba2fda53ef3c3ce151c14ef3617ac464e71a4725d0133c4294570f8d19be4e6c41732e9d808eb434d3852c5d31510da0fa4d8c821f8394f5f6bfa4f3fbae1e6ee087efe6ba2dd63d85db1eda2eb75e731c28f54357682a546b01bc523be41dcc80b11e47266037546351818a4fcdc4c3465c0a8122bbf7e0ce638412ed903cc94582043adf590c55a730f5b8fc2e900ef7f1d13a2eb64a1d5c51e53a7aadf365f64c036003e38846ea36bcad3748bfe506fa1dcaa8a2fe98a2b494bc71b504d689168a0f43a6b8f80cb34035f63c616e617043b280f6957a589a54ea82459beb18a90b9317bf9a985159dc5052eac3e7aced2b36d4132355becb7f559e3a7277c3f70cf18f66266f47082f678e45f034b544accc8a1fee6203e6764a80f8f520eb34e5f216c1a83af3d425ab1347ce5b36edd3a4687054175b7369349f56497d074a5479d6f31ad990528b02f0aa5091026c696fa902df6994732d97247198cd23c44047ef7776957b0b0c2aaad156f4f68fb5217d359885daf27f2d6dad0b51b8bc561644294f1479ce4a6c33989d1030f77c0ececac8ff8bc4c50b50432164a4c8e1da0422b4f3e4f1f222a74717da0f8e9ed7c9da42a6b99c9e2bd21ca0b180a5fc3353ac6e5409ffdd3063d7624e557f1c40155c7ba11e7b1ae6cbe0379d5a6161f0b59aeedee512761a24c2ef2066a86269c4fc8a591a2f37b9db5f63878135a5d9d498151e8489c693cf7f14eddd13ce32732a190ddb491f75610385847e94249235476186a514d6b946462d1816f5838fd0170f2c70ba61e212d52301cad46b7b9992bb880ae37cc4eb617616483c7ebcc418cbe3abce1d56151da8124f3132cb4ffcc1f8ba37ad502701be56e5b55aa1d5b4ce37800cddf022ff6f3e2fc8760d3b861b3319f98ec823a5ef419662ca78903ecca186e28ef0191115b82914e4082e9c4dccac5b92d0af55a5ecaaf85e319be8121faa94abac43bcf7b976dfdb79f9864097c013b2a793688c0fbc42a439c99ff2e5dd15ed9b305f6d8b87632065f5722a8b60df31a1b66f330e7e9098d779d4f3cdda670c580141c867b4128727e7bafc8f1401370187a76ce16702a9e91e1d5d27a177045b3c1df9280e8affad0cf9c6ab0e4824f0fa1321e48935734d24d397a8c4152d2bed2403f9f295124b7840b18c0cf8331716e0674ea4bae2050dd3a213c2b6eb7f6cfb3a9bddcdb354e1e9a61db3218e559feb33668e6f4bf15906e3690ef03a2d585f8e0994981f3c5f607e019a8afd029cb43964948b215bf0d5dd10425a2ef3cf302b4f2604424954827a224c57418b897d129777a88997ad624e20517473f7eac862a43ac92d8222b3c2eb214d5487571e2841f28f7f4d2114b590d0b6f706d3dedf49ca180321b057b50aada195b61b33860e69efa7c8f9453609944ffb8da93967c0037458d6075a18340967d28b2970ddd3b338392fca11e745d3b2031c7b5c6bacc43e90e0c15935f9effafbf54fd27f8aeab390bcad0a253e1db0193d4be3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
