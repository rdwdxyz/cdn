<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15e93dd439cc9345de3178f7fa718169c91e1a12f97372c86eedfceeca2d302eb201937cce1d12f526a27f95a019f5d6ea03e8c5d752207ef746db800652efaa32c6653babd55e6f0be834ed1503d2c36395a9eb264343be9c5d52a91fecaa1e819d36593c297b20379cfa49f0bdcc71bdd4c6890fd9de0e90285be9364212a1a495af11802784dc6763ef4767fe66b4578fff5c38447167d6e28a51d77f02939f298da6ad4482eb0941bb845300b3a26457eb84e1fd1a4453bb707d591af46ad6343552aafbe62b1e6ceec8512d7d796353f1c62728a31284f163154cd464b9dbee68c6cdb98d47d48324f745e878b10ecb7512858bd85ab2b68ef3f62fb28d4bc2ee3e0aa7c11078bae6a100f5b5164cd36f817dd5e6472c164693bed64c946b820f21e4ad5a558e58c9298e900140d1db825985a3b3c039626da69dc54331df418ed5182c106c683f8198ccb8071c2c4c2bc6850a244965d8c486431c45313fe7dd09db8bb26ab5175ccfd9d7b80909fd30442430413847503745c98c957c6db6bc596c0b725b415acc491b806f9e8fa24fda0d529332757365b16eb27e65a3441c3ca37c5c9ef521e9854cc64f648f78078c6b13566dc0e73b29839013ab3aca49be5e8d663e87434da7d286a1af5b8741db661c3a1e9d88b674a5903dd98e4ecd4643313c0c3e68c9d07bdf1a4efed49e7fad25c970a10a9b822fe39b9a3c92890933c757e733fbb0640b781ccd7a2db52f2bdb874b13eddadfa5177cd343843141733b65e5f1259cc01632d3752fcbab855505a9153f21c12bacdf22caa038b779d8838fb6789e46ad2efb125e41b957a307ec0e0d797def383f5726f69373ff89245e0ca377e3cd4a6a48e99a921ac623ea2c0c157b00b27a340ce30e88b14dc292fff3a2ab05639b6799462dc1a019bf9418cbb74759f12247292ed793ab57a7c8727c0e3dd9e7035c8aa0ded8207848b6603d0c6e37adc44f53f94a620126ebe3dad6b5417428398e8958866ba368350f2cd25b0019a58ee6901918363c0ca5729235a7d596879c8136e5cc4d2ff512a475802f00da6aa9f3d456448519b1eac1b64e3c602a92d4fe9d9582cb38a5f075e543dc8ed9b22839aa5c46e7fdd8a6aba6314f299bb314692fc6dbfcbfd7157ffe735e9ddc89b5077bb7d1d9d658241c4266a5ab821c53d6ca88284b98a7e479f48f264628a5b8a1f1b347461b4381150e558855edbe3e148d6fa2580a6e0b151b4c44d92b8f9ff1a1b6bdb8de9aa6f22101246ee15b2b830494b0775d0bf7d6db81a9487bc9ab4b1aaaf0944b1c78e5dd29d327a3aabd04d08107786c7d476b653c5b2f723e2fb2a149039bf643745ecb94889d7c2bdeb5d0cbc2c45be9e4a996a87d8d439aef94e268ddee04f4f2ee5ab71b8ba59cd1c42d5b5bbb815429d5f846819f562942e0d187d2c382bd2a60afa307b8f9f1b8d519e8b457cadb7e020cb71e09b05c80dd2ff21043f67e54daa368719f7143381bf94e3e6e474797cd93a747acd3395fa4bde6bd5f4d44ed39404a1a0f830a5f4eca05448af1e7c02baffbb5873f2306d97dcbdb143a13a7d4b019a53a7daf3719b2677b59a7be3653636c4fa86b9fc7b57a78777bd7b770a4f4d184ee10fbeee1f3e84744546ef868a94c2bbb7c0ca56291fe6c22dca54bf83f9f8fb456bc1524e523f22b77660795e5caf9183a01efa4322d340aae8468599b00e70992d7bd4d09939c65f3a30c353d62db19349c84444a59ad32c4c6f5bf880bfffeb712e658762b7128e10d77a0fadbd1c97d056299d2a5418005248431db6546a4ccc2505858b6ffc7405a0469c85940fe0e2fdeea9142604711df27af0e7072aa6f0473720a3b4ea88863d113c9cedc0a9724c4645d1a15d13bcc7fa73eb058a72611b68f5954bf8bbecd67ae287454d29d247d9bb6fe722554807dfa5f717364d452939acb5b06680d7bc47495979808f74db849c49899b189d08f3e986b3b9c850b9db33ec93b4f3b489c3141d8c0d6d1624cb61443a679e24e3f0d9d0ddec42634180187c8b7616661623fb5222b4282b28e9bf109aebf65de1f89ea35c10142dfd1218a771894a152363e63a5a588b181710c86508fe652f0dea9ba21d9de8552e975c22c9e6b6fce848c4bc9f607b29b6978cf7c506ba082733f7dc5f3332b50249b893e572a16a8dd97d6a72e6b5f3d8a579b13e580beddccea7bf1342d9748c9850f7116bfaea9ed9c923cdfe7bf75eb6e766ded6f78e933476abdbd83ecdb35b1f4c71544bacfdf48a35e7fa6b3890b465bc52a31a569c0283b34527dae08a0b503f15c79baa176e167033191f4130b2ec1d1d73bad8bcde633a0d7379f7ff755e0e42ef8bbe493bc22e43befc8ad893c86968cde7a806300258848aafaaaa1119c85dcb44b220e213cbf1c8551605f8bef77c44e1b6defde3506059c9c04688914a4282bc6c1f183d7cfbed80527731e9145e5a25f299493a85a4da95af09560f68a408e6350eef6e674ff819fa4263fc27b2bf26519d0504e6f4857867f68a5af22823fc8a8bc2eb24547d33692437fc293fe3bcb7362235a3a3b619ef66cef51ff082bb38d8699847dcc4425c417c0edf27e657ee9ec2febe192b149c140609cf077442f9a2aa4911bd38f2e99911969c5422c88afc6ce192068117d11acaa306e418c76d8b2d0402d020cfd912ea2a0438546d3d3fb4511c8b91ca5bded6d947bc9f76b87cf9b1acb88626066e0e8daafdd995ee4aeaa747d55cf6ed47aea46124f1aa26bde36cfc7476bbb70c6dcb9528756b913c5a5a8cc9a22738814a2e6315d02b461c4d78cdd8a404afcb8a3675a5a87fc24f9b9f70747c99d26e16277509cc18e915ee2531aabc6c1e5a7260144928d6d46f0735bb4bc4dcfaa1eba722eb7622fec7d4d61147943120fb486fd65882151f973facb6409e15a986c7b7eb7b4bf83f294c700d98cea5406e4cc3ded50c9305f758f0d3e6f2f61ec6051604c2207b9211aefbad9e31560051db11ef83f79fd46e7c256735c54e5bca2d7721701e09b9c7e330b81619018304e6a56d01e1b9a5d6430fbeaf09b93271a81da2d6e8f00684df300415f14c9901bafed6c18c0f4f658d9388fd1ebcee82fc874307ba1e6c503cb600af6e796c5b5b5cf98e331b875361acde82e491b5a7e19186fd4649630d0a8c19fa8999d69b233cd2d9b5a2617238778cc607568d143d5427e32ea4807b451e44842d09444781aaffdd87e19807e1659f3812259772f309081b57962b1d7b7995b3d07aedfbf61955c903831ee1f339840c20f15975341b2e626da6d5462980bdf0a1bf283e011a92c96252e0dab5cfe82573067d2ad38a8a4bf1c76499be37653104603e9c1c9daf41d9355efb3b93dce2ad2380adb340fd6888915a3cbc264c644bfd6939a9479d0c0bd269051f1508823ad726bdc6a1adc4210a28fb3252d5e96e7c60f051bfe21a142011d05bd3c847f6711ac776003d6704e5fce9c77a977e387ec315cba580246245af38fa8847c9f593203f7977ba2d803ad1988f319dfcb41422e0c93dfe6f0023f6e6263a359b8770f650ab9e6096044ce933729cebe9bf5215e5dd3e8a2e479b315a1a79030dc4b9224e88442dfb555ce4dd0cc4e4b4c261f3fcdaf3d6a8afbc5e8c32bc673bf33c17bd900eb2befb13bd1b542e8bb543cbf29a2feaf846b5f923d93924fb93df0258a4d6b64df5e1a4cb90c9438b040c87393dad9cb2b9a79605b710c1293a39ad8c56cd241ad3c1907abd1a2121a7c9b6f7f1e40a203de31a8eaaa3264decc73319df9d1d9e8db635089eab02e2fe46ad7861da2e1f7f175c80fd24eb18477676094bb04bab3e325450d6b16d7d2311acd36f58dfd3f725aab51ccd4c537b721304d1f981f216c0f04996c4230cc0bfe73d79c1d2a2fc3583ae5fa8f2ed1b04d35385cacd247a6cf0f26b61d424a033ffca0e1f3d0d90486cbbeb619d8df5f006b2d0ae0d26a03a1189ffdcbe43112e3058d337f071335bb077f290e9f9be16a632a5814fd6cf8bd52ac1794a745562ca782c9eee058e3438283b53d3a27fa0cd5823ea17d6e648a08a1b8628b85b29f553665e1269284b8503f19801901c960df09f9e67015cac42133829c8d07e40c937bde825de97d1bb0a1f37db1072dab79c72bff889a0ef3508048011b24ad95ba537624495ec0f36fcc4fa0cf94d34e1191ecb75444e189668e2c3136f0571df42708c3fdab242ede028d519b5e374f75d8881f130d5b5107e7fa8fc537fd3c1fd4139830278e1c27953458981f32de044c55cf00f7a2957897eb21d5f8d2a212f285f895b53864e961a695aaadef73e3520ceefd5d0d325ff0b1c47eed017f1335a1bcfb46eddae541348108b918243c4f486ee32ce7d59af1042b60f0c89c8e008681d59504e399a90c4237f520e71536a2a65ad5d59854c44811e3be5bc0531a211d163ecb0a3bcde483266f0b969e70d9e7c4f81a2a202f9886159cf8a40fcf9d2ef65eabce15755c56c546bead9ac30f2f19e3ac863581de7e7fba40831ae858cac4d369fbdac59b210e648d787527817fdaacc4a68a66fd082b7cb6c6e19987f1b71f15d6c9bde265c7f6d8906fdd2b45d0f86212a8d2ff78a5906dff3ca7123d8eeb4c6fea8a3bc523cca31985d59ce22d98f2cf331ed2ab391607173149e241f9e015a668d66a8af0a93251d77452a1bcd13675a8749c24d8caeafbfb9ae8c871eb44ab2ac5fffe4cc90aa5b125dfd0f519924219f753e3d42c40510aaf55bf9a8b4611189e293c3e7f2a90e12881e9d8e3d4b0fe36981a9601eca449bef4dc95efe8dc04988f741fc2ce9ddcfe91b3f79c37f23ee6e60f5df694ee9dcdcf512d701e86a65650f84f78a0974f8a63d42fb511996228859617f6470152851c9f99fc416c75f848016ef6c9d37f61b277ce18523826592adae21b65e48cc9af93e6856e81cf92b7bda6e7f369cdee723089fa32317ccc6721704b3c2c89465161e6d717c552c3728f528c4447fa144a6130e7465966a762fbf1fb909c4b9009ecc4809f9d4a784f97dca8195a859c3b7db649f9a6c2c529ba33b18abf231be41ef208ffe85b7ef4af044a02b83747ea394412346460ea12d40373d06172b0d371c8aa0a805e6e1783718e386e487f041e844ef4fc356bdc9d158611e3ca41d617b4b9ab7675e7fdd246da2e31d98e6ec6765d47d6163a7fa60ccb48e40b323a980efdd7a69b2f8438e0c6f73fd23f18cfc42d7f43a7ec9d1df863871b41f2bf91c122f3f9018da864e9ab4f75e4f859fb83cd32c19912622db21b718e51c7fdddd55fba4258d72b50d7f3f90635c85e128f16f78e2ad70b56913d2ae5d05a9422dea7765d9db2ce51a5717fde34523175dc42e3f2dfc914eaa9a934c73fbc9085959860b41e8b3445c57d212eaa13b8f11dc8469bd43d509745c03ab398a995fac961ea87d2c148ce04db4944d1f2e754f5e02b8b4add18c7d95f4f67364903fe6696b7979c397ce772a3afb4a4887a94e7f3ffafdc720f3574559d6b7d9c58ba07a8e0fe86ca9fa94ccde924b413b1a6b2ead756f2aed7e24d37cc906ae2e24acbe265220c9091ac47e3b1b8a3be1c36398dc6304c39712b783ca4729a5ae62e22a3c0eda2b8f899569fe304a47f09e92fc337c1affa03123dea489bc7d69ced770752dbd750c941d4e90644eb881e152a55708c746f9ab8202326bf5e3e49896d333bfacb5ed5ecfc14235444ccc08d33baa2fa9829b9397bca1f7d4e04e5498cada7c8ba0a289f6e038f04912e41276a485082487a4be6851cefd34a6752910d72f64696c6d507c57c5b29d6f4701c23015c91ffd0884891627ac4f70ddb12e81bcac611e12f308e4c6164b248634579b59f75b9f48e7eafc87ca609860dfb24ca332dd2fed1157586de69522d41847057c197235a2c41e349f639570ec2d5a4958f8822fda8a7dedca7aaf7ba81dca13eb626a40abdf5e07269ed1369e0ad838be0da6d171b7804f62831a7bb853090cef64a6b8fc14f0b74a83e1bc3e7a5e82619370c770f8161f754bbcd778c13a50ce9b9b083c61dafd47e4e2fdb27bdbc16200d5d75e74fd50b13e64dbf7938dc3ae84143006f60cd879c7c37106871a9f22091ad45e76cc553cc1a5a3b3f6d8ad91979c82c0b8c5a80431dcdb8ceb1c4b3db4ef5c336e02210221bbfcf1fd32a63b1a7b7fce241e08788d9b3c218fb5ac9e19b50e31711e3047de291baa71e43e5aad869ba780a04b0adee59a2f17234e23644cf955d05a3f61a228139c100fd67eec8f3a73cb33c54a52614a69c175bd0ae2bcebb81f57e0cd138a0803451ecebb8598790e29ec919a3d4955a58fcd7e4a7fa82129d982c10960978e9189d6d0e5b2b5aad8b8806af704e56662b04454ff02ed1ea62c48fdd00d7b33597dc7ae93a0f4f047127f9b34c76913f4057d7b417f6cadacd73da91e665a2117801b127a08b5e573d847dea15157c577de88316063f0312e389611b6a692afc0a50252fd8b852dd49458ede2aaca7c5b9c5ee017077545db418c47be1bb231727bbe8df9c4f3a87b1a2518410cbcc26eff3878338191610ffd5a98c3cdd6884f4aeea5d7059efd836b4cd00350703501233b677fee2e9fb8b3b18363e45a3b35f66a90aa33593bea63d9a1d7600f337b4408e04e9f7d802eb3c1b1936cc8e11d7dd552c77f80882f502355e0b7cdf257bf24bf124d752d8adf0c1c4d81cc5acf35bf68ba7b6387a861ac4b75e0f6dd07f23b533246ad58444c829f455a69ce87855b07ca0ff1bc83b94361bd038d92acb4d5b52530cea2eb16672ea37c807b6d6114c646a417ab71bba939e05eab35d3af6644a24b6606ff765f7ffac68e208890441eef6667ba007a444e492dcec1e4d73e24c3d97cc5269557e47bc5cb5a4609c754912872e6366a38705b4a9755c9597f197e7eb7dddcd5e3a58f569b86327ee26b16145154ebd84614bc6ca233ae3a75acc25471b265bef1e4a2e62150d2747d433a35d50a34e9c8c34bcd6006764cc620d3e8396cc92e621dcea63c77024fed1c9806825c4f3fe608376942557c84808962b077cadab2fb26ae8176904430309b784e974977641cb6d2d149b13d5ab98c4d99826cf9683488ff08ffa313eda6d6a665efc7853e658206e4bf57a2afc500133da07a9ef0f8c9ffef4a63da8894fe865b99d20a34164196f21c834db27042c6109cf9f8ed309ebb601cfd0faf23ad882f6c5be59d2750b49b81bf0e40b0133d44e8668f1a7b21ee3b75e15a8e4ffb14b25118b378a0f5c98d5df2f326d8d6ddb907e59a6c7eea94ee20f72810b9ea2aa2ea0f5470993c7f214c2a349b021d9254f0c022226431b5ff926ef40d5eecd503e14df81744799917ea14e8918b0199d8fa0d39e0d378de3761a8eb982d0618e93066f9875df99daf949eba3639de6dda9c731d79c783f0a5efbbfc18c2132757a509d2f702b603ab4340311c1759048dba4d059d1a1075e944c0e86d6d9e4307ebce011ec0aab46ba91ca04e73c267ae0639e967cb674d210b36641240e9dea10ff78a00e2d5c732a5e92af2b699e49f22d94eec6f76b4e66a3d411e80fa8d2c0050e78d47a28e58f238c67d62500771f9766b14c8de74fabe077999d052d1edef275502846c4905d31457166bf674d5f9dfdab3437d570faa2ede7f475798ff292e9821982bcf020339b4c70bcf2e0ac314730e4b32979edcfcd919c7926a361c8a1b96e22a41d41d13bb48c8734941d3025a48be0214275709c8456dd89739d7904e76ff47ba63a2caf55b66665494e097826d5ca5016d0c36bca5f8d5d68561a042de792cb95753ea21d6c1b9951f7e28d3546335a9785a2e45b0dee5e45571fe1b06b18b7e49bad8c23eb2db0d3914c9840962423d5519651f46c917bb5d69e1ad7a458d376f7af3efa18a365ad62227d393d6a25f946030fb0790bc6fbe6d20212127e08a89bce315e991466df7116183f70f2ca7cdf0f43d87674eba01c11539e790932c9da579c31a572dd4996f24ae169019d7ef82bab442948d8274216bf7fd0eee8cdf86361b3bb986c68f90205434455186d710a6cfc41eb8db2f323bccacd36dace7e7993349bf9592debe7201aca9be92321d13233cce4181cc29d49f1119a11ac38e82d54a17dbd3c0adf0494c15f00f00d771a1cf4e2eb4fa8d329078079c7a2a64505096baea166b33a938313802be9561a2f3883f98b1ac44f1d8ad234b61fed3c8b7fc4de2a72d482dd80727d3abc59993f26bccf2f9ca2420cdb731607b9d4b7a7debd6bb2025c3ecf5d62d54ea04df1baf0588639489a119694a39e0748db3981038d88bed2c31757fb7ef5b008a71fe875d69499b18daf205b5b7986a94ad559ba7810d3e64b8d1655c789e97f61e91cf35d3de807e01060b17a2acddda3781870e9f1adc9721eb9407c86f6793fc84e8347d76952901b87193ebbf24d64e27383dd4e58892e52fd42f96baef619f292f976f94cf330273d31a7aaa2fac7624a9bcea30cb3c18ca506eeb8208cc43f370acf4261393acd1789510ada2b5559c75a2a472668ae7079a7a68253de498020edf19426347d96952e9fde33aaa903b9e0ffce3d355f09fbd467b2ac797d505669f6386bb840091d476ba9f94da2a227a1d713188a16dd9da6107ca8ff7b8ca770a8ef65d6a9d3227ebcf0dd9929b8092285c00e2b9edb40f021a58f367269ef0fb0780b22165422c71d28c55b0c46c12aef7a0f234c105f04d9ffe3b1c3561156e9bd1a0c1cccf5533ed99e217622fb5212aca1c0600af40229204ecb150dd01e1101c8984ba51a52dba4dc7ea4112c92793197da254a5ff06d95cf4ba370462c2b4400b4429673ebebcf9af85cb36d29b7dd53f5b9f80036fa61dfb4682104924626bee491200c8ac4227bdcdab76f17adb7c68950245b23bbd65559deaa7573cf2a41b4e8ae820376db5dd33d198d094c084c8d451edd73d345b64ec030d97ab82c01f405aa2068af8690e8bd1978e368bb66b406802ac1aee35204f9c19611f8dd25d53fdbff18715fe1c8fa06d2199c54d8c252fcb9fa522e8eec31503b8435c66fe4cec126f24a880404fe509402e214ab637f163b96d33d79300d087e17970a603c30f7d61262d25ffb314bc30aafedb9b041a0d14bd48565d560b5d9fbe43d5dfa8ba7d228bc799e31085bfcc3762adb91d51376d92d74f7148a5d8b773fc882d1e3435f5e65a43e13cbc7868e6c5df8c97a53285a8526ebb6ceb8ae1a24c65bffbe0c492c366f5f6fe6a7b60ca11b0cff14cb52c489b218adc11d8ca40a7191580f2f184d3cee2a05de95659fd64cbfbf114de41d8b2b1495bdfce3c68656c604687b1480aef008c8ad42938a2b891d88c4590a2e793435894a7215118b4c0a804a69551b5649223b72928cada43e93f226a15180850418fef80db2cfde32d7f52a914e5dab597ffcd54b138bdef3b5d798bba1f2a1717549ac051c7d3f32ce656be423ef4ab2c4ff5a05193e1026627658fd328a6d467256ea1982bf871199ed70543bf057d47270428ca6bf71016e7810233c232544b9b930f72a078fdf6e7c84e44e549191619ec7ff43586809ba300b1c52685e71f5b73edebac72f8c5ded5cc5c87ae955f284476ba6ed1aca85f56d1e5ae49c07da9d94d1ebe20f2b9d10575910dfff1cee103333534e917547e03f41359a133b2ebde1fb68898e10be8d1223e2d773b948b9a8218cab8fff08c44df567051fe97f225ac9fa82252934a4860905165c39ccbab715cb2ddf97797a4e7ed00e1e21749f4dfc8bb9850f24a93613ce1eaabfd2a0e0133f75c67a5b4e8802c63bc20e9eef4b54cf1cda25d14f0e3ec571bff3157689a69d3c93636b7d5eb927c048acad3ea71295c42e50b8f469a7ffc74ae2f02aa4e78ac120fe524534b318128e763db255773faa4f44c4dd7567312f8bd5e1476184c6702d01cef0b75424fc50e7b6da6cb63c802671f244d0ca35606fee1b0b968a45f6cffc5ac38d5bab0a767f7a4044d46d55ac8c11b864838298d20ce54d94c076d3259bf16e29fdd26d9088e4a54ec8fbeb066d175a6ce15b67f0d81983a3274f81acae97906add18bff1aaf5bb708b4ee9bad629ded3a8bd80dfb4cf9d76e4412be44546369104191e904e751317515a1d064c3149655c8c0436b5318196107006fc8917d67c150e30d8c8ce46233b64d189d3916eaf9497ff47c007c240a038fd00a1bb33b7224dc1e379ec8d20bf4f5ce6129bab89f07c826c2097553bbb4dd611fbbaf8668643eee5952146f60cb747209982d6d788e4760ab6758c0c9437b76e2fbf651cfb159c66365e4d3e31cab092056c8941b36b62d18cd4a2a4b89b5995c5c919aa1d6b5e973f616044e1a35a0751b195fb13033d3cd333332a9e48604fe108bac70c382aeb5873f04dd92ec159625baf6c4aa4831ca2af59b0542f49ebb820733c12f78dcc0d314a04fbd4bdb209b17145bff516c9a4b8b62866f65f3ecc3b0af0b69748b5f57416884b499d4ebce71b9f430b7ba16b5ef9a8cca7ba9ca7a2cdacf14dfd6ad7e8c69dd8fb639235f5a174b58d80c7ce2a269fec156b0bb600d2001cd403cdb1b7eb027038726e510e95cb8aa35bbb8bdf4b46c2b69948b295650e7c5b5ca5c58739e490dfedc801f4c74c557323f157d7675cbf37178b1e4df914d73db5377035ee90dff12168de74f517b05d3165a462696a61591a79d936bf7a8b0a33fdc4039f649d75ec592665b63d4a950fb882fb3e8d00aa2207f93118b77562552566e47db9a969e112babf05b72252242cbcedd3ddef0d6fcfa87bc335f2de155e879cec63f9ff618ed8cdd6b15f265f825b921a74797bfc1dadfcfb09c16d994a6da674085d4742d20a2cf5a2699b1aa68afe0be9871376ea7963703cd131ecbcfeafb35aa42864295b730201d88f71dbd85981f262e76f071620f8cbb52ab50a3d859514cad4f152b3df3d79bdf09c9460b8e869a53a5f48307d6d040bdeeebd8d5ab44ffea84234167ccb6d864a4c0459964a378d4814e53661cf8f53b9bdaf49e712e64b2b890383e8de7547cd69145dc75b10490b3d4d21a00f240cc81a64cb5f7202fdc7a6219d6f4d08d1229138da1f1bcd015253510e27017f0ff45cb2f0170bad720f6bb8ec79115c8e1ef77e3ad914ab3ddd504085ef7e6d17beb0492c3910cd51a1714356a2f774de1b46d6027dadafebd7a61a848ad63aa535058272ef9b22a70b8358c3146805a137c8b2b79e4d5e6f9522cd48084e53177224974352b83150c7948ebd7054059c382086850cd19e92c7be6e22200f73b9aba612a5e300f6f814bb0d8c2b1c98814b60e0ed11fe23599115771efe4a08d12be2f79410545adf92cbb19355c74b8a34f1ac2a7e9078c12a42f8c978460ce5dd2a5280aa06126c9e4632c17e63f84ddc7bba494f02a8c8775b84e93854cd26d9f17757a59eaec78eea379a0ec2fd91f91fef84aae49533cca9e41fb1fce09851c43a66ff20cbd6add98d3e2ea1ccdeb40e44176d2bf8eab11fd5aba3d6880fed3ea99afdf2b3d26202b08a90f0426225e8acbcb7b6ed41dde71b7901d61714ac0c9555aeae6bedb5a2f49096ddac919978fa64e5e99956e92229ba4d3693110c89dd39f347575ab264f80aba1694d4173954d00fa790fadd35b27a94aceadc9f16a2e8c238049c24580ceeec3e63c0b8331e9321447176e2f5621b5cc4ad4ae9574b330e3f4f2ff1e6fa966b51b27f80c4a25f30599482bbb0da5491989b2647f153cbfe6c7b010e7b51fe4cfc551403b8972eaa2a0072dfd48dba254edf571b5c6043724c502ccaca34b38c2db0cb2fdf6a0ef441730e612d6e38b61df192764b0bc5de4055014c66ae39cd4948afe9af447d375a600011a28687338edd952c4846df35d35aa424eaa9d6a40cd9d1e9677f8ad22afe39f337d4b9ef6f65e1166c82974997fbc867acd74879efb84c8684847f3595eef9418fd1fbf257da909242ee3364dc55cd1565df1696ba4f1629390b8da77f29bf4207e5c70fbee292913aaf68bca732604690d5a835b23eefd3ae726ab4da2646bfeb5c3c85f013eac6a28bd67c299910188ccf6e0d87fca729c7255533bd4c26dc838335ccdaa18b6cb05473c54238ffc11834e7c1695784e15f0cab4e397b3d8aae3e7137bf090c61dbd89e57458263595c14d6a455fab3d83ab39810f66e1d3d870b4037827edb4cf5c6d1cb931a8f23e075c2b7a93e55e927ce1e390db960f1f271aabea87d9b38c8ab5131a8d84bb54e88b8e534934c51039f51a5454c5e957aa9f3bc2e32114735a7e2e7af6e17b1e7b01b2ab44ae70a1b187fd67fb4ec8fbdb58c76522c74a0ca73acb8e8d8df143535b5af9ab31e7108a5d49cac6f1099d89e11085d7dee1c04ab9b52f3ae213ee478d67df9f6ba56d6f1413437cb015fc0853459bb68bbbaf95950973b7c9396ec30186a3e99f66692946ca53f6325dcccac23ae2332b785785e5f32083f7d5ec3d62523d88181e41501f00166c6a1998079576c3aea5d8af85aa2f87d469f164554b6aa48448751ae4e4ed3c4ee7c34ff99bfa90c78c574557d53bd2c82935cd87685f48675ce33e9a4ab703714850a5b13fd51d85a3b6eb7316acb8c0e9befff6d5131cf2ccd6913ad5d80e0dfdb6ba80b6076fb94a7585e89d96b52d08426158dcb81aa0f710cee5d3abdf5679af75e8389e8676601765613fc140a92be5642508820935e917e8113e30bf34f906f635e2d20b9046e968c298ca740ec0ec741e1b22e6357a1d9871e2146c553ac96ac7b52bd0a7e02c1588203b98aa3072000447f6724311d5b1f17ad9cb8a1b66977e56f906743d0597244751d8524ac839d4cba53f42137c317f6089aa41de75d42e4d1cfc81e32ea5df4e37cf2690204d2754641ae8c1546dc42bc9f98d4a7a50a0531f3c39df54165d86f34e856e5a41158e083d69ffbccdbc31dab4367ceddb9441fd3fbe479b27668a8a3d0750be682552524d5b1f833e8eb5448645e73f3b844a72f45136edd78c840e0b5b38806e4fecb30866ec10c9cb0335b7afce7caafe557b466874a08b5e3163061cd305591fcb19f67024078faa0d15947b12c763156c65c48c9bb8608ef6026bf6ea12efcfe4ab587c977f02e732d1312bb17bb63819bcd1ceb30612acfc79bee5e17a7b3a178eb99883bf545c44cda33fd11110edbfcc79fb6d384ccd54f78c9fa4ef0443b5d9fb80d8577595f5487bdbef8857606ca9220fd780a77302dc09106208c6cbff4b7649afa602e14a25c99c6717e21091cc9e8fa5e806037fbeec92f753629240f5727493cf816fc8e7d6b75b010471f7f6897d87ca882f63cbd9101a73cdfcfea912e54ebb254261bd974931271afa42d3bde6805ddaaa00a1e619c23a4249a84570d12c19a2f2ea2206037b897a96a50566049c867eca37ce3ca14fd738e0bd9aec969a3effdd5551829cb9a765c8eecfe7b2477015b619cce1c264e05cd04c99cc3cb1ea7146944db2374d6b258f6e8c4da71575ed8bc13717f2932b4e7303d01c4cb80da1dd69e364aa3191953a8f021a565c4612ffabff1bf89c42c803b6c7d66da4e42fc52ec83932364bc588f9452d872da39f76e8e2394bbae3bb221bce9813e3100c34ba09e2de5f4281c3663cd3d4d95d8ddb3ad59c5c60fa150b611477110c8fe7d381a997ac7f64b27eecb79c5b53cbc2a70883a1681706ec53b9433da1fa207343e99edcd755dcd29c34d56008134cb164bb02575015198d2c9dd14012d84b257b8b1ab7337c29655c4c409738cfb95e7c4cf8965bd5d6bca9f3006196906c99b1a7b401e4c621af2489a2da3c1e57e99f511e9e20b5750b8d91811cea002750c340ebb758bbc81d4f003293b4ebb01015d905b010f64c9d50ae1f86dc3bf6871230716b07e0ebfb496dda7e1a4cb6fffdc1bb340d9b929dd85af6e2a5ff979499e85bfd4ea7fc779953434382d63a611f29d6299f42784dee08333d2ae89fc3ede0934b0f90868d491d5e0a2cec5ff82e0f8392d499fca706b9fcbdf60fe21e774775e1c4fc51257ba3e868441411a2aaa8222e4da9f48971d93b090bdd675ca4d2c9ad6027f6ca37cc7d4d454a23138685259b4d24d899db074067eeeae890af34a3a98fd125114580fff0ba62bc5bd7d157fac2d6445812b4c159579b5d198ecffa099032eb44b8f31b8b725a6c52e9fab9c64ee1fb0829dbc6833a7f7a5a80bc44f01ab95de7f96788f4dd9e8e1f1a52a89629bf6878ec629510e70f39a6257f7560593e4ef86aa3705c65eed3a3ece1deb35c9488656a653d1dbe2f14af58d82f7ba2d454afcc214bcebba5c83b63e35857777dd609b07fecc96a4f3996ed7ce736c36166fe5af55303b62d415e7e0e23a28f4e71f22744f673a010f19bc2721c12ae51d78cda2f18ff7755e27d7061a752f9a3656548f5e33d539dd45aaff42658002ebe3f146aefe4ac160de50db10cf4b6625d1f83e0ba9d91b4228c43e2e20c4d0d6cee529deda8f4f65719910105f8b61c0a693d0094c3d17793520d3fad0abae70d21506efccc565ab96536a92fa1630e0d1cb6aa30ae55903216f9e06ae34d133d9eba1a2ed47a9c3f34e95d9a86dd9b1391da7cbd6d183d3a342ea4d03c715b1d2fdc1743e4b3372e45c615eaa7823b98ecd6c49dba084dedd7fe19da89010e25aabf5fd99dce2b512ad6bb8783d4ebf592dbad08bc742e4ee166d7466fcd3743bf873a6334ddf56b821fd83abe820431439d6076272c2490bfaa3bcf89326eea017ae6e47a9529a26745c4a3181b9f1976713cb9d25b6da63f4c7bf8f3b871677f9f75509493af01fec2a708f18db5e571e04ae3f70953924746e4adb1c5b7d5a50f33772246a0d6b7763ec9755abd0672716e507ae44c72e7ec8964b4adbf766c0045ddba774bb79bb60f6154c4d7bd66e8642d63299a9fca828102162f2e88832bad36b78726a58f1301b8b51861c98f41f2ed550f63a95adfff9b7be256e0dae8c7a39efb31016417d96260dae5f0f2064bddbb7efac6040ff763ce92f7b60f074032fbe58378d753813163dbb7e5271819b1b2b72ee5359790750fcf41588d3ac2c6df2d8d438d7e411a1c2ad7d98df7e38f491d5265efe02f09f287ed980f96dea79ebca3b7f7bd26890de5e1dc5a3d54e32b9e362babc4971ac4268c2fcd44b7e67370763f88ad3112eccfe67de991911cace4f26230e15af6a1de9508cded28523e79214984cae9b9dfd15378659f7fc6114b6ddf5ba4ecd26f10692093fd0c77fdc9e3e4c22c53ed216a8b07af94d401fbf6f88af2132b3fddca5b43d703e572e90f34a07e5097f3b9d9e17778afa524b0caa2da53b805ced13ff06a442b398b3a6dc2f5d505b046f35762da45ec63660e165425521285a15899ce785cc4d28b1f70b758f19f00f2734f9a391de7a28f20131a888760563b650bd6caa5c00cb67a78a51c12adf347972ad00147f08679c664d6b6d4bd8f2b980cf535781f31eabb1b2b312014fc0985c5db23ceffc5822f591082df9a17d1f7b3811255ee3970cc629706d10775f95eb3e75f89e58becf3d075d20dda5fbd41a20bddc2a25e002adc7c74010d62eaa51262661c2366215dae733e73ef862aa6d2966526806584cdedc8f84f78ae5a6d2784604eb211fa40ed951c58cf42e646ec58394e9f2bfc742e3f1782fe339a46f37e3c20f0b066f8991571c36a0eba5f053065618ccdfd2d0b41ce670f97347fdc50575b7edaf3d8e2664c42a0b80f7ddeb50127dc5af3d39c45391a1a364427d8f29fc1bef87c4c6d713397c9181ce1651cde4030f3acc0be7557dc46e27515a3bdec11f77071c8e3ae88e539591341c6dbdb4c5f9f25de375f790f61110a2a2c87c0cff4688e8870e74cb851307b9d23d1591f0c728bb044ccf11246292bc7655a2296fe7c92d674e6770543d4b0ea18449f0dc3a57836a1e0cb4047a4fa42fb17e6dabf6fb1b4090484b1f47726b05dc24e9d09a95c2d146ee9847dc0dc3e3d0dc11baebf9f5339dde0ec51fc61f6af739f73ecf67eb76af207344066e758e4be4ef0ebf58702737d0e927713023d16121a0fd9fa76dab586d0a60bfc6cd9bdff548ef6ceec046e88e9230df11a1606b6bc31fa636349639f046c4a1ae39de3e93cbc649762f49ba49af582cb9ee35b504331ff5c8b326706a6a3b8638667d0422cccb1fd164c44e5792fcd6e80146f62c9457853f20b8be70267ebbf61882cf53a547f00439709c49854d2d2c30957d0a1ced6409637d8c556136d02ebe4137de38176bb4daea30c26552caeae928b14fe0833e3ff44d3b98d41c27b655213ba7f8e6a6a49b615ee22cc5250a89fefebb5f054da73bf8ba1e2e9b451c08d82a61d6d2bd05577e63313b5f5ee99de662f28e0e7bee5a32110a90d4c74adeec810e49935d0643d2cc36bf3924c72acd608beaac8a48e260da83be7edbb096a25ee8c29b10f5e58691465aca950eaa4df38fae054105e23e94f3cfcea7194049044e8d10856a6504a018fe0bea87c6abd1f9153a1063c8f22519ece45e860853b93b81e6a8a99596a3af8d448b8d11e06d37a73724e6a9ae16d748d0864c247187afeaa0297bed43f90eb736de7952240eb7cebba99d58fbf2be492eb1353b03b9ad4194062e1e8ef03cda6d6aeb9e50fdaa147e9dd99ed5892b5ca35ebc2651c16043428fbd809d0ba6b876b4f8bc5018a9de5704cdde8f44b48f18a9c504763e996fd434c4cec1891a501f361c0f825d104fc8d8a1902b030fe2af2672692ef57d7078b3fb234a8b2420b70810a48e9f24db49ca9dc116d21f621b233b997de05a8056123e15afd45952948cd91f08ba331b0587cd5b209dd70b45128b531b1ee291e8d10caf8c034b93769141561335c0957da60140618ffab373689e189aca29e27ae91246b1703360467454fe32a49cefb0ccfb0e2674ba974fc7b28e29ff549067bf0dc382053c4c0a28f149354df498898ada1f0f3002c11f2e1585fd603f7a4b3ab14f92c40a5ede20e2308fba06c035c075e66d5e8515a85172509599700f9926f93f6398450bc10315e2ddfc8d2fcb2b1c9fae67958fa26a2f3164d3922d7a86119e812a2f4b8bca357b8a68aa38edeefb92fffca07e3650bd2600dd2ca1721bdefcff7bfdecf020cfc3f82fab5c64dde073084d8ad6246d0e7bdd669d118c1affa697edff463e49b5331b3af48df9f23b863db8888152b7f8188498ccaa09efd821279e6813da65101f9003c5dd3c430e9e2ef6b97d4d6439219239ff4e68262e7b91f2a32c2144390d4edd3f55aacfc7de99c4eef3c928fe38da0c192e7a4865d48b8c6a9ed44c9988cc8aff84f1444cf4039bf0b00b319bf80e7d9cdc81d4e3b01d6db5de9f615d8b4d72d154071bd04295c5602a44a28afb501dbdeda6e1dd02f618d34ca86f193701fabf12707402b183c56b43b75538fbdaa6fd5e66c352d3976f5dde76ae40a6a2d74b4a7d4371a2a3cfeb2ffef131aa0c0b48052558ff309c6f787a9f520efcfc927ffb37af1fa5b231bdf87ccf40c3cb6588f904b97d174ba5dcc35af7460e795ce723904a50be146c25bd71ccc83f9cdab69f1f27b734d80d0a2f66c265f31ae4323f0344ae611f3414f9c1fb521284ceda4c58036524ee23450b4f3ce6fadfcc03b136effaf2d39d42d977117531ac77edcd651ddc7e4d1175d1d66766974fff673ce99717ce9f7457fca4c617490d34baddfe75370de206b1496baab68fe122bc7067c451b37276a656b53bc68f529c733e70badbb0ff0b07b3a551edda08b7cdbe274136648d74fe5f04803754ff78bcdb7f676f7bb13e9901838a5942b987e038e7b73a1a24c4d964fed03649644eb4d124ba728de828aba146b9c3805a2cfe42b4b4c4ae5fc23b85cabe70c5d9120aa937c04241c3577a210f3f797fed7df6e7e0a2607af2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
