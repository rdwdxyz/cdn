<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"775fa840b9583e7c6fae4e7a46dbc41268af5112bf7c7e08baad1db6e846d7bc8beac60947231cd4a627d190ca088d8ac8f344d7f1e8610836d6f0666e86eb98e26de086f34e0e11e289fff7c127ab0d0506093532119df39449a04bbbfcff650f26e8d967ddee2fc3e07d570131a3d86fffd20ea2c24990c507af275d0b857219be90b6d0a383b6916ab2939f5a824cc6fc5573895129f79ef8bf11d75dcd89d85c9b3fc27f1b5b2f54b8a530fbe6dbe012498eb88460c30ff42ba058d87b45d4cb83600c8e5cfee52575f41c836f2c7c2660561475ad3c19eed37f293ac5aae8ca8064a2920963aa88fc7246a37bdb88b1a7509334b2c48573f4977d1e9e7cb8fa561de6433efececf9ef25492d0f1e568d427e217b0df881e638af83066f9b977f9b0f871f5d3cc6bbdc602f266ff7e2884bedc2b0f7a491b28ad3ac4b5ec61acff13963b2a3cab9c7e888cf679b820db43653a2309eea4f326886871cad4c0a8b2e7646a70ed5964a3a1e2cd2cfbac50abb687e0adb477728debaf3bab5bde06da9282011bcf97ad00d2dc39361957abab4ab1c1cbd53950a68a871a22b074ed01f7371f79f317200e8baf9647a6baf91c126c1afbeb0b7fbcfcd583d0a20b1a6d875ddc08e4d3f33565333ebd4c506221e780c834c846a0c3f709394542d047ff30a8a5be250e20e4f7df68d745169076aef0e8464289396a7cffe9214c12751fb2d5a35b49abcfa069db5d655b62bd89bf77f771ae008e44807013e8fa006fc3286ac32237d15fff80bc1532277c11d4c209db840732766a0234017b14c85a4da1c76fbb74c723b56afb9d9c0a364e930dd14ea2ccca63d211da99f2b6019061af724b05bd875f2a2ccee0f9db90d01aea6bdd71c5376531a27b5b1495dede8dbde9f300cb250d44ac7d0d510b87188adfb42c1acd536fea815a61967e59d9de6f99b06cb052cc3e42e7370f208c4d15510f16e0a11a64841de7dd13f3e1142e38a19930df7170cb9a1c0e4f3600552c5ea2750dbcc3299420af8ae58aefd5ca1d1d6fa35cfe1570f2d26a90ed5b84ad2b2f2cb07ea5da2836cdc7d0c2070d3e1f123f4cf708eb728b88c72659b33cc27df74cbfdd8f455f9c4c3f34580ecbdeba6efa815d18af17e45b7389a244d16df8fa453daced02c022fd9da1463ffc543f8531703d0da6cc775b451b5cb8a6e837405b8e1ea1b157f8c7e9c3dfbc3855b91fdbe3461c1166fb26665d1ff8eda0569260bef7f4cc0791756d05bb80b18b595f506b96597bd0a5d7ac7affec480830b2c809338f02fe91250cb8afc3b1b7bcd76a94eabc48eb3bd1a68f3dd8e781cae9db562438a35a63a1955833257f127cf4ba3e5a224f8190c7134b4f1112662f35ab398b7caf01b24edfff9ff589ee57d283cbac3432212d3f96114bbe59e0ef44efb4db37e82bcefd77eff49e9a8d211d23549f195affde33c5696519c68f7b827d2a35461324a5ef9aba0a2a763240329d0a8430227ec19ebdd0299c4ef9838c9f65e3e33f70f66cb8f50dc9b1adc0ed69fd52b3a4d0956edc61dc635c76ed2abef0a837e4041f9c48dd589a04d4965e979170cbfb64f5a9208f6d748487ea8f7e0a6da5931433829c68277ae00cb320a7f58c4242501e6253b8b8cc9427d0b0c8b01e288729ea893604f4ad4a34a66f2634ce5b37c4b8ba03601f4486b0bc694c11cb271c2c7569f9859206d31ce6d23c91fd8356d02374addc4a0407bc62a9199f2deccae9d492753edc59a020d02cbf1ab8e17c04b534384380931c2d9cc7550cc157f56247e660bbc884e3c39ec1485349a1ff1247b5ffd4a28ea14f58569e62573abb0317121edea373fcb70bb92c0d1c53a6f4622bf847335a872ea5e0d588b8e8da1d83df394ec4647ebbcad4563fd108719926bcf1ee0d71bb9be7869c72b730b7559a7616dcc57cad53f10938919f042ccb040bae53b4692f4dfd216a5e0144a70f9b050e56cbad1c7d81534764f08866f19ed304ae5b431c3f8b7beb58012575f07a6082f6618681c4138f4056e46a6f0c6b756175404106f6afe1cb2f13ec1320aa055df21f26e0c01d3b988efbc98ada23e9de24df7ce3efa230d0d3caf90a54b9eb7e8f696238131a6bbb822484b80a6f56f6037b0c3200d9d09f1f9969c504cae90bd5eb26d4cd1fb10eb9830b2fb67eec770a87776b79d556c345593eda533cbae84fab5412facdb804eee71b44fda2ac5ee67418e42977b492959e67543337cecc0abd2e6a7bd67473b9cada78a344a5132289aca94cb20f116e70bf433daf327f7258ff5c4a77c82dafa8339009500052fb0ccfd4fd6a92ace62c12051b10e269dfdf3335ad8c34f8c616307eb0d74b9b0705383f3635b616d294a5b40fd2ad0c2a562a4c2b73cfc4ec4f4d91f98c7fe4b3d89cf1e23ccb0a3b03a367f158a824463e0e72d39605803ead754547ae69f8c8d72233334a082491f8a18ac71b56e3d0c4ca5d3e71c6e95afe1540dfb3f292ecc8810799f1b32ae88c89d96bc5308dba7cdb236e7cbd6a65df64cd3ec68c85aa1cb85d8bd8032ce987247a60591d3bfd4dc6757aeeb0f9af1f46eb87a76a712c6c1d71b8e5589cb96ce665a3e4419ad4191fcab9135f45ce981d46d7e87ad808dbfbbf0e44c2bd657ca0bcd115db9a86f32d5f40e202b1dfae0a3e0d47f8fc6c5e0fcdf4bd34ba21cc7f87168f02462293a3ec31f98bc09d43e498a701d5fa3b5474219a9f6a8a417d642d92e69c627ed55a0854a74337267379c7dff0ba0481ef5fe230efba7620ad2fc307679690b5917c4742e9a25eb501c7ef9ccdaa4c17fb1b91bb4b202edea39a4a07c9656e49be22d0a2c1b681c3a7da74fa97b4dd315f899a8366a60f91b13ea364ecaf2212b3e5c77d00d6817955f6e6dce8816bdc3a4f37e5998babeff6f622f26541c20a30752b73ae2460fd0c0df2edb958fab9b4a671d64f297eee0f3b95ed00b4df764acb1d88c07bd0385e0864c0eb3b8ff1d08b0c505a466c3a32b63aede5425e72c48fa2b38f1a7c8c5c5986898bfc5ae4e2ec5440c95661756766d8d82e9a57da4e20da03000348a658f268b37ef0612b9d27191b5ba9783dc8b8218c17473d171a8cf8e16420be2400c500189bfeaf6ab0e2709d0974ff8ccad4d5d0a337142b6c1402f9f53c0d90dc4ff576c632298eaae8ccf3f54413e77e22d34620bb6f11024f2e99a1f2847b0509715e8eaafec3542e674c01918190727851a8f4e40f5d40221be3e9ff0bae9cd62979a1ac6ab9c2975d5d81457a5de6f2473132fc391837b34f4e150c73a9809b974dd60911c64872d8bd2527979a2038eca81dd90cbc5edb8d7d28f384fed8e016b2c246943d4f9ca3cfa104ec39e102df7faae287358324c36e459b914eb68002156ec861a83fefc3952feb0889addc98887f2369c9b8b378ac9de8a533bc9c260cf4e67c4b7fe4efb2e5bbd8852586698d918e83dbbcefcad1ab1a3a0688ff214ed1dc9d991b5caff5d33b48c0365f98853f3d57a7096637912c5ce734c452749977723a7f8278ad69525a98c68927b723a525cc3b282936427a96c7a8439d8e843813e73a4a2e69ae7caba775b5920b16198a16b7277ba247c131fc2920041d66a6d416e631926bf42588d62f5522d0a1c741c2b210eddde9e9c9ff31c3fbb69a36f0a2069594c69060c21cd9c02489d68e5d1085d3f8268dec0d4e60490e4e63a437fa93a6f6fafc282d100ca0fc41025c43deb4b225dbd1a649b02f2f3e10171af4b9cbb15e49afe962c2dbcf970096657f9d0ecb68a3f0b74ab89fa1b0fedff558ddee22ed7af7dcdee0f817913d0b9be99b508aebbc9d5742484155a9e0a2d361e8a5666dc74f7a7988c485091198b5f149d87ecddab66e06beb8b7f52409ca73a037f04fa7efd11a2301e43fde68498f0ca73d263a48a7478d5dc6edfc493aebe7e067bc729db8053eacad2898cae3f27c6c2fc68fa117800e4d42127ab89891a3251d860aa8de1a16f2c36f7078b0cc2ff7e6ed05f0a8eb7655ccd85855f0feb21023cd178dadc77059ec99c3c3bdc2b73a5b22b35de4422678f211429d3678872b3ba5902eb9f7e6b8f65593b10bee5b3066dc4f963bb5ce78d582feeb86beb8b09d8f716040eee038f1484d973833dc2b5b9ac77d95b5d68c7e64b6f0baab1795f071970c6670e56514d4f9b5e440b03c851c30319d15286f6fa9274c7abc39e5b913d81b0eb1a74e8b2b4c167656268a1e1fefbd9e3026d695242fe6cb6859e9666dd1612144168ec78f6871b5ea7cb992cfee254e041854fad2f6cc878819cca0e9873669ca4c1ffba7a6f5bc68c1e7be8500a39141d49349212ba88307f6c8d422fbfcaefbcda96f1a3ef92a6b1413cf317361d4a489e4b0ca7d2a91f0309eb060ba1fcbdcc183a93b4dac02121e27bade4fb22e9af54d3518ad9dc9b065a205204fadc5c14cbf115a3ced74f5a1215e0ed5f546cec826350ca3d5b1ec31f6caca5397df59908971e47f7742f967d53b2efbdf62374593d4863cadb5eacbbb180df3f35c4f82b5b07797f56d95311c743c22738a1650107fc37e39caa7e2de1e6a23091455c68300cd04e065f8800c6a15f037a30e32197c6f8971cecad8a8feae82b8c4bd673c8fd9e04762733bcc16ab0b2421dbfa19f7f94805c2e62c13ea6ea50b729abd9e8bca47a57e107190e17a19bea76e1c60e37606fad91a362e705cc0f6d71d71a2e541cda97450c4d03d1c1ee3314b9980636c6c290c13bda69f2a9eb40f78696e62ebcc94ebf4c0577c08204e718f8687e264443ba4abe506779958706d86ad058d21abbcf78713793c83ddb0d59f0288827432b830f2c917a916a3d2bf6a66b64d3ba89a7a4d590dd37e283ebee1209f18695ab32863ca3748366bc02494394308faae37aae284e5c2ffd3034d9f6e17935571a1c3348e797585fcd94be86c99298447e729bac256da6533e2f19c703b57810d8a9dbdbf7952fbf8c1a29a0c4cda19917e94cb643de9a59a476e47864f8872b3251f5db39620f7c361ccbbc82e816aa8fe4c70b490e13768552e04f8b7bce9ca3708c76af0686c8cf761ba150bd6380a8244403a5170958d370929e80cc8a3652a014cf3d09b3c8ef0b53bd64a1bcfa4698d177ecccb7ed7bd3285986022bfbd6753f66510d800c99305f9d18d640240beebbd6ae10bdeb51c361d8c8351a6a6154bdd58899ec5486df548d5ca20e70e22e97035ecf3a036b3939107a6bc3219d91fe9131b0a39fb728609a8616776c6b36dcd4c5c1af87cd1053a23c34639ee63945a52c38e3cef2128d67c29dd1632781212bb2587ae1547472ba46a901b9c49977a0796fa9b39ffdc2b276344622a578b63a5adceecbea17f809afa91af93f8341cc6dddce6bcea0895333bfb251ebeb0b738658f65043095c2f0c86e508c6502367db2e9672e6e0cab8392541968072b03336de72eb566b07c81da1868b1559043704a846e84c24fdbeaa1353e0a744fa3cb778d143f07112a578c1972ddb371905a90e17dfee86697999283629084c943aeadf02048aeaed28d9711ed4f085856817251897aab0ea8339b600c8ef361e869f89dad4b3f1565deb5a46a3080133ab4138885ae6bb566f8df477f9464470e9c54f16a1d8f708b172f0c4019e2ff8c723590c0a33dae780707af7a8d3b38fad0ecae1883da3246167277577d503a22601d5931fee76d145b1016781e0a5282ae9300a94957f6d7bf9bee1adaf79c67fd146cea950955ba42709241d560d820b3730f2f8e416bb64bb7f413551fb48635801c6341a06557c7b5df2e31e34600741ec0fee17fa05589094a737ed1ec0dc19fb7b912dad5a1356a7cd243e576e6a91229bff6092ee7d6fcb29dc163d51f7d388b5437b7cf6c14463dbd5328734fa40e54b463bc085d610d3611af59bf848055e79962d1a2d4780c814801e8476726fc5bed656065419d7c3cb0f3bf648be6f8e268574d3268b8a3c42715e76c116a5457a65ac0d90cc23ebc29583d35a82e6985109c5f632a6c2dd73e590ff9392fea3509cd1e437a0bbe76b81401ec9c6cf6d334deadc27b648db658ce5b54f8d71e98f0881baefb72dc4402ee2fabacd5953dbb2668d34b6135e4e7c9391354bd258c5a8a5de1a9ed869fac131b6ee8cd09b22b2100749052ec6a0d5fe400d835b6b4ee172ece4e12ee33d93c584187647b7fb97fe72ab20675a036ae6bcb6b872781e6b7013cc5e68f34fe5b9b0bb3a88466e4cc953e5ef405acf757872fe1732dee60fc5c88e58a24303bb6371465999247612f4580dffa74be905935b53ba98e130b8233e6f31ac69ea2e33cf0db5c565581e47ace21f1bf5364753cc14edf30cc22d819394385b03009b81bafe83cc62cd46dea7765ece9dc8f4e8e00c6dadea056748f939d5fcd045b59ecc73ddcafefe0c0b87912d5022adc12c47b0fb5c15049d000c240e1dc99784dbc12af5fc4ef7eacee2094b3b060508fbfda16bec766068ffdd1d1223d5b8e3cf1c06abe4002d3f50ad801b25b01cafcf6880bd753ae263f43c8b150692f693c7244e80b3b8c0fa21e01aef8f53fcfa693ac61ed5008386f8a72296241123f8064aec99bcbc38c2dc4305561e011aeb3ee78127e8f13359714546efcf844ee6b719cb3af169f9050e630dd44a1201990224de54819dbc8c60527203b0d010fa012146e3dae567740ae2d205493e0143a3b5b8625a75b67447cebbca083abbccd4e677e57ae9890b3688246c88b1a18b5396326e4b3949ba31e7aa25e61772614fcbdb3503e28b74994f3e7e264a591d28ae25452df2b29937e2b788f7915dc1dcaf1b8bb4d2b4e1c1e33e517491998b0bc3a85d47edf6d60dcf996e95a9a411eaed266cf33ab354f08c4eceb665403b5f6a858e1e6ef4e8d2eb025ed8560c03819587e1c0faf63156f70a89b04a5d5adaa38bdee4a239668b84a04533b063feea0b5c337460a15917d0d5260ecb51159255b01f1254aaafcd9b49ab47fc4e77c0854a174682302d9276fe68e03aac9b5fc7f9c0e31a08ceb78577a6904e169865304d4809d541fd08dc304306699f131ca14bdf791a30def0f25794448dd240508030980db2133710121115ff3d35c1925279095c5c762f1ff34eac3f292eae9aacfb9e16d2a613520785220f813fa6b95c431d3e5e4293eb1ac42a59c0ad90346815ed382e258d54d194935608a966507d58428ded3b30320d6e6193ee3946dca0c6b429639a0fe275356d6f1b8364831b4538ee29f0b0c8d080eddcf31442cdf39c04dd37ae5bb678ab8521a9b997dae6fb29362aadb1242d33453d96cfc65aeb5d2fdaff8dce3cf301cf9ff77ea485849550677310daccd72b6eaa0510e4831a1864adfd56c1535cd6ecd9481f0fb4a252cea1ada7a7b5543b8b57e9fd1c2c367a2312a2c5ca638bb52244f2579643db618297e7144b06dceea23af5f6a6b478d8de57257b8dc6a821eca7bb9e1fcf6c764d3578e0bd56f1154d99abbd4fbf4a18903c6f2115e2bde1a3acd057e8548c937aa48104a76ceda1e7e25f405221959f99dac02a38532f66fbd671fda0eb4644d5664c47d223a07e335099dfb05efe40a9d64d079ea06e2a8cf5c58804d8913272da59cf652780a3a060bb6e8e3a75e45d5f41661e13b68fd9d3972a10f5c0d02142c63713f896e9099ed945b59521c5857a2ff946a38907de120674c4be083145854920f733aec9802ed9a65fa131a83ca7fd9e3510fc0b918897dbe8e215389393664a945f998b11ed6eabc568362efb37eb64d871fdbfcc4367155100bb1d82f108733c38d0e3e84c5eb10498f64db414412940ed9bf8842dbea087a0af99b801f1561e10c62cfe08363b7b5d0eb508371caf3a9fbb4d22479b0c1d3047c1d1627c7758e9ec9c1f47f67eba7c730e567bc5c1849b6a168dc2a00cc68b1c4d0ddc0555e23def548c55437dc25879baff810b300ad7ed524f2ac638bcd9d57acd5bbd538a1f50c612a57f3cc1c8a35ee369d0975aaf75673dea84adcaa031e58ffd08c4a0d0909fae4ed7306b9bc8965a84f76953b9edaaf17315f477f4276ca6a4ce04f9196c846cd34402495d987f72c2f332bc4749efa5655d4caba495347f3b695b4d301baeae6d493833b441bdeafba7cbb106e9e3cf53739f3535cda8e86fa710fbb97032b8d99d9cfa69ec9b9b7771d7336a4cfb3c60c1ba52b8f410bdfd00cedac7d51cf2d2e951e72d805b7587c2c5be26fe7f20f12778715a311bb54aaa61cb8e3fbd616be2e5a4b68b0153542f3e773f06e9cac8f66ff28c0968391bc69bf8c4cad9ba25c98f518647fa0cc44d7d74c13d2a592a0d84fd35bc14d7ba44c978a980ebbe63f4b07bfbd49b1d5f9ca29090e251e6586ea7a83aa3fd029405449e8a9ba0352de2b3d0e126e14d2a80612060fb39cb61323e2451b2303011130ea0e56aa446a5e2072a5e053a8ddf2556699d99b8ac6cbfd546bc810568de178260e85db41d9bacff10ad6dfaeb69835b0050a1601b4b4315e036b0a26a08632df4ff0e2a3a3dd750886232041816cc5bf94bcf2c5026e7159779657d1585f3b88b3cbb0ea1cfda83f226b6bbf19da26b42e9bda91b2ee6a5b54cfa065732b7ebd828f629be389cd0b733198aba20caaa7d59db432e2e9e94008172a1dd293ebf404babb5f9855437bf6c910d1f5baa8c90830e642ac308901b646742cd8c12f9144eda1badbd507ef5a022ec95675b38e7d1103f02cfd50eec8a7bd154b9a36a41bf0bba35c78760b9525bddd1e17345351bf989995f7d1969d5708605ac1be5be7897cc770c04d0786c1067599bcdda6539a6b943288562aeefaa7f107ee328f76d77db0e9ea892b414f37dc6bfc63bb9c5019af0cde30b60273dd99e03a1ece446a1909decd27e5536272339b5ee5e27bf8467d80f9f73be86475f623bf4ee3ef67e592d73022cd1f23728170c1a35130befcc3653f99162f83296b6932d707f2832f44f42ff277c415f2cdb6e096c9d4662f11f68ddbd53ae7ed57df16e1fb9cda544798775bfee1696360bdb0814191aa17633c85d53391f21b505b7d1e5fe3b9ec37e751e01bf90174e99156fa9d6ff8ea0b5bb0750e086919440e254d3db2ccd7a3214b64cc4632c7d17ae672add579892999617a9c596503f68530e4dd2fb0482bc57c0083f7fa0ecd723ba4898393fb9b4fffbf1fcd5af751a61301489045fd0f6efcfab3f67a9dc7ddf7e91e1302b71b4234d41e4268fd5be7f824cbe683857a5bbf1c4ac23481cd4319ce82b996b40d91173afb9df195d8d3d5f724e70532e36fc39ee8f872c31a3c30545e4558108493d8763b3e9b63860353a4092ea0bf2e17e2a77ff2f9d5d79e1a33e9c61fce1d16a1df12ca8efa9f0e799f88449452c67a842c6fb8df9dee21cc479af28d20e931776dee4ea8efa5b15760ba18bb1b91644217234fbfea1567d01941042c141a1050b1118ac04fb8ad36a09e3c153d9ff053980e9a92d6a7e26cc51bcaaf9f02bfbda1c8400f088d557e83141541cb3c37fcc20a319575fdc4a575e1e700c55e7255f09d4145789dff2302df54a1c4b26bb970d4e512ef6e255c96131aa4c77cdd8255a1841194e51d469eb22845ac2dd73caf41865b410dfe2aaf2ce4f52ccc1c3b5c4a84d3d72acd1baa3eba27876be0f56974a0e324403429095193233f72f7f63a1fa163dc415aec87cca4b9cab2bc75836e5f43817dd067a4b052d4aa60ae0826dcbc6edc3937d3b9ff5deac207a00112bf1fec7abfcd76323d0ec8c733bdcca302d7ea057db6889455f1a34c97723a9c3367169363f85fbda8ddda85ace3eaf97693ef875217d9643337817b8969c1d19acafbc07191db9522565e637e60b4b0a9f522c77d327a468da3775eabd228d611f48548d03d50b37bfdf46648d8296b70d58c279a92fed196036ff42e8800e46133b003789222ebe41f7730e0af51d54a993b9d418f9593b2894510b8935123bce6865def9a52cee9e6aa3aaca6ecb350dc767da179e87dc24558055f452c6df060da9682fe79a864bd2161c79947ad13d960a2b6aced2c7f40fa680ed985295cf411daf593519d95b4f3b6e8f24e78ec0fa3c4c1e6acb58f1a23a237217f273c2c0ab76e1857c2e4fd0f76b8483701314c18147ce0a904f26dea175e929e9f496efe38e6dbcf8d48fe924bd9ec7154cd89c4165019e7d09197198e04c6c3d9352fb8a9b1420b463d085ea961cc7ba64851f4adbf534d0d99bcea2dfa23d9ca067d79bf20bfe9e7f37dc4824fc1a2eede571cb599dab73b3651d33b847a507cb66a116fc6ac24b82519ddffe20fa9446abf4a4661016cdefcf1f578431b9e6477204e1feb4006bd771b95a2a4ef3b5b5174f967efe118ad72129da947af917bc4d1d64485a85b6788a55c2175461b0c3ec828ce6eacd2fb76f49994df445ab2d34316c598c2574b7989c443281bb89bb39e43dddb23b527a3f508ed0f8c931d882a36aaa8c244ab99ba606dd3dfa45c137566fdaadb8a6de396591cfac3342c83336d7d2518d163b0426bf347ec9ed72a6251b04a11be473d8bf2ff8ef4ddfc406befd79f9790aa3e79bce18e904fd4a063de5afb1d07f671db92b74c4478acf67e8188ab21ff7f00b4c37d35ed1ff97a8f36da3d3fce9064d9f69b13a3bd2c595c5b78191c388d17e44f1c5fcf81748dd0e2f033eef083dc3bbe03039a5e16a00dc10c62e6938a89e69f5309d217fcb3e277cf7f5d3caae3e82e7d4c796951fa5d1bde098ebbc1273441de556bb81d44ad5270e964dc006f5e4f9682a38862a13bbe0f31d201d3a5363ba95663fcd06fdd22f5d292003ca0bd61da70b73e79097fcf38b6094ca666023e3d7fdf3df18b74db8cf2ae83a41288953781ebe601e4af936d24995500baecfafe56366d103d477eacff2f23ee17d767298f84696683c97c7c9517d20391a429be927f9658993bb19a684860511e031206c2ea19b9a1e206a22ace41d2d92a60dacf413a1532db464d2be80fb79c807d3de5e481839ddaac252cdaf728c75f163fcb89be70c84a2054a8e92c5a0725e4f718660335e5ffa263dc650654251dc5a09c59f48958f816f624da16ca36b6629a3c4faed70d4b6d5aff1be3f561872487f0a34403904f468591c6236e3a1b11ac8464a732e0a7310d1744210990d7e2b2720d4c92bb9c52989c808d6cecb192d3d2c5dfae46a56d1d83c36de04c3b5a2c7f660add0710799a8b8f7ba97f4a2847df5b22578b012aa3e705b66ad8e19e7426a2270c371c1c1030b44d7ff0c25c8d523ef0c60e60ff8a051fb8b69569f792994fa00b855b2b2deb78ea80c7a4a95f5c8e057210577d1c238bf4e61e605ddab14f4ca9961bf72ebd2d9a4f80ef861c99503034ba3a4d1c08ab74a539e07c586c1146e56d159bfd2b1915a9b1a16894b1aab85c02245608cd762076bf632510b47ad71db6e5f193fd80eac313835fee4a81d1d7a73e5022353ed2cbd66e8ae0fad4089934950a25a9112497dab632e84021afb1dae262ee1e904669394909e4f03463ce91878b186f5ac3fd9171d8fb6dd62de75d23eae860c2f43a1acab3b4320d55da699b4e3284aaff266af14cf9d861bfc689290c39e70553611d38ffcdd16671a776a1e02b0f7656e34189d724f1a64a468cb44f277f7d130f3044f2bf85cd916482bfb3353bfa8d0cd25b344e8155872040e45eb3b4c625a16db5cc38552c0c9be8d009450d9119fef04d589d60d7e8a904b2875d4278907ba53ca1183710f48f468527cf9092c19ace8e1fd5fe82d9eec21d0a5dd12cdc78334c5e35aff1cd21f3548beec77d80d41e3909c29d24484700cb05f1da6cdefa8428830396295fc61e7f0538556dc4f29f2cd197258ca5cd93f44dba46329ac4ba419a91b650a158389b1f71f758b88365370275bfa53b35cc8e53982a671f22da29776454feec02276044f0da051ec466d52b8a21971e119f08dccb3053de6d677d7c190ce7fb846b0e78f38ccf85be1d307ae68f981e3983259bedb1ef4d9bbb7ba77bb17f4bc5000b7480d4f568ca56ced897e37676240b88b887299c10292fe83da4a66554a4a4ad496b38b3ae5cf68dff364f72f1561573df4673b552ad9669c705218c6e55b8f68c6a06783ee18be0e74123e09206912e0fb2686d7e258598909914b867aee3d940a54271375e7168612e56eee71612569c3c99d936bfd95a6fb384817cc40ecc7bcdb519a6bb333aa45c644d0d3afde0ad538afc40d9a232fad515c9f3200deb86f85352b77ad38133ffe565b7d13c18cdbbfa0cc5338726c8be07c9cb2e4f1b73cee26cd30edaf3b35af58b1b2e226dbd1f510cce5cff51d7519eac71bbc2294b7adb9324dff3ee661e6e27cf7dc5b662b9799c7bbc09d1fffb635c2a3794da22b202f1db0b720f967cdd72a87a7382f0054de8c95d0cd4f070316b0d9c5495779f917ea4a8b345d40d82a3d377e89e32b2f6759a594c5ce092c33a696e7d0001553d34f76f8f470f23461b9a2f81887ca34e3490330a5ea100b498ce1089503ddf9fa5410d377f237113f81a268653c60f7aacb1774b57afef064cced38701b443360d069acd9cb6fbed3cc9b3488fb67fa298b79334009d4a80197ce95e43c7d0a2335fb747761d5d6dc733043a85490d4d908bbc654836eb67ab8ef59b2aaa03c86e085c5b980f2ef9f1c2be0da5b186f4597b542a7102c3eeb2a65f43d8f46c2ec7411fa1fe79a2d71d84356ff1b7138c8e5efcef2388bcc0ba7560881ac2b4271977353512e65bc4375d593bc2e5dafaeb3311f108f08854b421c450585496fe5e4b148119b36fa8b5119568d177bbbdba95a6cc0f73e6f06e2271639a68803e3a0ecadc92bce2838c83614a9dc0c9b8bfa761216d75dabb63534dfde8ddbd59e81b88e1db73bd547618689039dda06f4b1032223b37018139a1893d0b8d43b2604ff663b375c777f23c7a3cfb953e60f051b199f7fa2e5f7e07405176fc3340169dea2579a3a14808330955b666ebfc8bc7d7a201d2c25c30dc37c6195d23ff8d30bcc1b488426c89db8dc39ed037685c065006f77967c8b8bc37236ba31b03621c09b15f66eab762dd957d2857a08b65f7d0d7cec957f5c0db434ef2bb9cc6c15705eea8f994a219a4e2bdec198b41bc8eff303e30ca1dd0c82de3e5d3cc05d9a69d82de1c8f28f1060b47480fe47df583d8da0c2741d089059f232bd91997632851716fe0978e63f9d02cfaaba3172665fcac45279730a8577e3b04f6c05cd842248016641dabd8ea1c047f5353a0671ecc898a5df961a1e68ae9389aa0f226f7609c518c4a65de07c8c6ea7a5b5888a4a4ef9e2274d7709f6e8a9581bb85abd20b950285d0571fccdcd9cae40ba03f3d21394f4a8d6497e5cbce0bd04e9ef7e46ce2d8b6205b86b08668c14fac18755ff595032a4a0e4c1280133d13df0802dd498a30c258c4561693f994c5fdbab349526eaa5eb4c52dcd17e310c0b81d1e88794b3a85624f82444a976341cf2ec798200a9b86321672f20a74e7f25c47c0495a799e00b7e80f69e966f69267de6c1676c4b29efc1ad130fe36244a9607268c202cc6a83e7af7cfff8dfabf6211cb71e06e7425d3dca4007b172890d0c237821f3213021f897a55ebedc4f6f87f92420823153e74212b8c165babf7490b233e04aa42a2fd79b0db6975fcfe05e82c0cbb614e1e2f583f27e4139a9366b77c72b80e95e310881d9b40154a65660612a19ac8c1e8acba7d6ca45cae380e34aa94ab62e84b3907efb67df615fd0b526e88a1a9febd70e5ff8d850558606fe7ed764a879ef6cf8d84e7c14c7f9ed8b00aff318db44ab88d23466c78da591be56bfd57ff37bba32c2b91f1620f4794d6f1f4d1bc4f69e3dd60c33906270aa3a9633af74084c25c6ce42b261ceabd22e3c011622f75bc0502bd85f15b79c5eb1adee1c0f600dd786b5bf66945f807bc3647ca8c4377ec86fa623156a844cb6ca95d7c8d02645c180d6d17bf659f20e4040236111be90f6175f06ca5a6f2c27b990a1a5241866ae9f1a5fa95e698a610d3f54a127dd1c91bb6f64b7536b0d1a24139d9ca44e3b3f8cc87a2fa0fd6eb94518a210a82ed50cfca315e8cb6c85ef40e48f83bdbbcb347ccfb43ed8891d9e87061982d67ff5c9107a4cb8f6daf5a1a9b98039e733be52ddc868d649ff88d4f1f42b3780993c4dcd45d7a49b5d379c5325caaedee9998d9e18169bba139113a9cd22323aae337cc29c7d90acfcca9acc05f65a8604388c6b29b3551db05b9ab0e20fcfe7396daaade1e7466596d1370cfec881494607f9dc9b44ae4eede1ecf83c1bd023e6f39c65dc2c1958e5a97ffae42b2b095987999538aa94e1e6605f3150eba3346c798f320804183853f8f0e1a14a0f482ad3a90b463b8a04b3ef6c42ca5e50bd7cf8eb3bfe148cc068a338bf453e438f7b407afc26835e58a11df97792e7ae9c078e792f594ffe0e24bef57e887bfbfb0d47f41bc342de090df514375df9cb3bb0dac72ae2e611ce82ded6a84b715795a579716369dedc09999a2d954aed02dde59c644f4ca77f64904d36591f860785561eca3a11d84eb04cb45ce47252e839a5a9bdc8e76a0dfab48815adc8a67272ad455adb6e6c03f73614fc5e99fdfe266a160f85586a92fe2e4c57482172cf29619648ee4c64b5ee048af50da80d7ab081539cb6fa5f4f3716584f468e18ef35fe89b4f9deb72b6a24327dca703fa68466d103ff77c6e55bf8d8036dcd98b09710ccacbe40b37200ee968546709e174475fc2bd4b3a2f0e06cdcab2ffcfbe02002459af3ea8bd6180861d2d6dc28d9d7b4689e7febb5ef0bf8efdb045e8d44e2608f247939e5dec58a7063b68cd238ff638d73ff748b0f1df680a6b2924f3ec09469f493117f5df9c559dc6aee6de21ffa405110f5bf8a89ff260240af54060184485c7e6e5186a5e1255499bc8ae42eac8dc2fe99e4b244c921e68bfee3f3cb52e1115ae683b99824647bd2fbcacee688fc885928d74d788bb25d437d073e8ba2a7ffb4ffc9599f19c14630f12c37b90cfb2c9b5ec62285ec5dd1ef1c3ebeee33d2fb7acc6db3d3f4a2319a14b08faec3b7d966de0658e8e161a2fb39c5da035d80022b1839fa4ba25307c5a84e619586361ed54e050fb22a19fcb8cbc620777546c7818c63cb82a423579ddccce3242aad636fc3e51ef5c6c0aa3a89986a4429bfceb2254bfe464a086bffdc67521dbe5358fe4a083c95d7d92e0c8afd2d4b0a19b4fa315e9a899dabb4b814b60b3706f38bf43ebfaa9f7c2d77e496543b1ee5a30a5ac5ea2ade96e701ee45debda3c5c7e28a12781447c5f328e4bf05e22764449ddc8fadd11ab18131b3175b2f6f698a4a39d0c8c795a6f071957cbc44a46896627a2fc11d277d0923d746fde173168bcb754b411ac531cd05cdf01168df01cdfdce694bec24c99cdc1bceef5bd6e0e9b667aa25ee12b49ce737d655323a0939c7f01d7c9e89c27264d208f8ac16d5bb7efd93418b64f02b6682dc0cd3519a7dd8ec2f8cf432f431fdbeb297388fc9d45e7054863964d720986cf09d778dd8aad73c6bc2e4ec8f3b13b2b183ccc05cf9fcfb84fd5d354d5692e65c02b30674164b76a26866bf1dbc50b9377e2d7736449a78ec0330447afe90a6d5ce4552f3dde9265098f3790845df235c18d4ce265539ecd76f7f6eb89d015b01119e5ec82cfbb19875d92ca80a972690f36a79dfb2fb8face07e66847ad16340c200420b22d81c4b8ea0968b4d87b40886aad2c15aed75d0739b9c4a3bfc09c83204ad132f386a024b0fac8668ae83b646a267fa28e8a630aa7842612373f1c92621a0b6a4fc10b7b3ff241fc95d0a14b7f31f2f8404966e2521ab476973da046933e5f4f2ccec702ea83ac714c255a84ed0c2de1e6ceba170391df3e24c630e15d3640749b68a02893c2343a7cfcd9f5c2428e262d1a78e7d24764c7b8037b92a9312ed16e36a422573a417f15d757881a60abd9c1a2586bf824127e8fdc26a54c6cd16a7ebebba0ca1ebf8074e22a91d5a65c1508fb3834e937f0acd2e96e861765496b784a8f6cc8aeb2e58c833db5e1691dcc342084abd625758c13984f2f14634a7e008c394541daee752dd6b4fc0bfe548b3d0ac8ba2a4549df6279b3f53776f5673d1c7b096a1193fdf4c9d8700dd00f0d81a9122927d7c1a02347dbf4baa4f7d30a28a5178a9885c400ec4272c5412bfd6ff0582826147ffacaaf1fa174f9460c33eb125d1b1d1a9c61b8a6e70725fe5b3e56cbc7db1d7ab7ae400375ad017f06209faa6d5d6cdfab881b3068570cd61cf7863ca827c642f57e3d19ec0547241663fd16d6d24d967fef287f5e8e54dccdd224695e92deff526bfda45416400192c0a8d4a203ca0a9ff311e846c62ba053fcecb6d020211016e990b9a9ede7516e4fca42b19467714cdbda0a057b4aa086c944ca36bca949275f770384f179b2b88f355bdac40bbd308cda925f166716238e594d718559b9d30a64714764f497d4b05b2222b2875be7260c0f92e8065cef078cd0e6f9c1c15a2b474a636ad72764cf1b94dba1d67c19366df1db5fa86d0787d03e576180ab3eb8f79807a230517c1e839021d0d7c4e5eee180a782f9739a5aeb6c450ed3a91b3fb5e0507f7f0f05a6da5859ab85fccab7136a79a982387e734000abc52a19eabe3111a88b96155626608ee9e80c40bc46f7242a496c7c9d019ee093a818ed058201534c5c441b402cdcbdcbeaef3122b1545dabe13cc4706666cab45eba7f85771d6134f1fbc90d75cb005eb79a705fd5133c7171a5a1185b227f009411fe72840eae0fcb949891055a15fdd8669ffaaae2c4a92d6d1037c8695f3565a5a26013da14c4c79f7d4415c6cd23059f722d4ee49815b1c4e8bed1cebedb2e4982f31114ce60727efe12c1b74615b7b20bcd9d4dceb4cd7fbaa30e8891830d7f396c431eb03905be84abf708139b0cd102ec1ada4b7f716ae30748decccafe9e5b47efb7abe339c5813c60dfb8aaf519dc001e4f01960ae898de3af5756e29e32a19dbca7c6c3e01b14bc7d7e3b9a3d5efa1ef1ff9a38baa80301ab5d7ea26f3f9183a4691f83c8a6042e71adab534f861a1577acc54df63c12b7728b734cd8fcc3bc7d3aa450e27c7d7fd62570944414e48dade38966c661de9f09b583f5098ac91724f79010a4b422e04a47871e7267831cd363b5b1d003c3c38792c63b0b24ed1908f2e093956beaa19e7171fb8de5d6dbbd235d1f3bdee76730014d893aa41612d04615e10923ff3986a9057bbd3a84fc3a8ec3c01cf8a03b55a19f6d96fd512cdc7a1dec0fe512c398aedbfe35e80c7dc7759b57e79b2e947a86c8665b7571f89b26d17b7722e2b77925284e749ab98e72a7c6cb124f059c389057dd219c11a09a4fa827c7cfa7a17403f74700f5ab395d9bb470bf88330b76cba79e85f87957f1ff654eb0104c744092370f64c3d6d156c788e0e27594eb9a9f15c3d5704926009c063781e065fdbecb012cf755856760b067c1f20588153af4a31f49a4992233d414ecd1961fd355a6e81e9b694b1ab0a34de09ab748e9f9971581a9a9fb3a36ce07431d5fbfba13d4fea0f5d1f54f4c81017fdb10ed0507d177896a4c72545284d3c984a8f84794644c0aa1ec460f507c9f6087c38bcbbd5555c1a582338ec4bc6c05a765a1c4c1c622a25ba486b704cc9b3847d8e69f4b8cbbf8f4e58945856d63cee3d884c9ca5dda42a52c8edc89ee8b2c8945cff5e135740f1d8145f3b3ab76dbe0f6b1dcb7cd8ec08f8d642fcb896416a75003049e8ce182190a816758c018ac3532c743efbf096f9b9fffc627d9359fd676250c44eef2fc9f1e6d2b2bd802dbb63b1c8bcc0467ee4205f02f18b87a03d32db7eff2c13c29085bd9de1bd869fd2fbb4bc6052d1d89a42cdb56e5c7625a357fae8246e0df20aac7495220e7f72b90c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
