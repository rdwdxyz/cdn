<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85d5762c366bd481406c7e596d6bc2f8fab3356f8fe2b27a3daf20ba17868bcce5c1da1914021e6f40e199e93231a714263daa7d7756dd6cb2dbc9e96ecc899dfd221c5b2a802303b3393f68df7ab7cbdb99d08f3f217f48bbfe6af241af915351458445478dd37b5fe9564088fd29a84913078e58623aaa46f6d0cffc4cb53544278c39a1bc8d32dba57e726f5ee3e1575fdaf56eb038b05c10176302132cf571c1d35cb14486fc498755b041cb7f86d0a18f18ed5550a3d35f524d024dc045074b2f5a1aba99415500e97fd9e35527365109008878c3e3f04a9ee9d3ff6803d9752ce8710b372ddb02801d81f9153be6042b06b90b6872afb34239d2de1b7328b632652e956ce116954ddd0df33fdc8d85d750616203a6f456d60d5a2fdd51595d4bb120a6f4366093ea485a3ce43df9933801b0831bdef53b9fb718d42e1a4a235f4bcca9a27e78915db5155bee68eb91cebc2f8bc09b603e541b74932beda7f80876525853266aa3c0d0c9dc684c0da3612ec1d66963b0d1fa54f737ade22d2b2bc55868a8ff2338070e73512055c79aa0f696623300cc98e3a6cc823f0c814e5daaec5c801d73ff30c23e7225cdac8ec1e999c99cd4db4b41e79d1700fbbdf719397f9a2ba3954bcebcf8c648567c94e03ef97f10c2fb20bb922febed10eaba09fd201d22e12f57bab94a089499c7ef230e5cbe79e67149cfb9f1cda61ddbd4aa15d4cc6fb77ec1fe1d44fd090d492072d1ba896dce6de60446698673877f6d3e6f562c35d5ccf21d1f48559916e321a27bc8571bec5a218fec17becb91779647cb38104aea3d92718a619fdddd0892865e1eded0118d12efe1871f4c42fddb97c5a634d0de8f78dd85950bd6dbf562297fe5c68465c02115a63b5da37e185669404cf34c390683fc491add7070869fa05b4bcd1ce3d8f0c9eef66efe0790aec5b0aecb3121bad3e3be718e3c6985c639cf4a12a4bca95a57ba5aae54aa1499fbf2285fca28ae9a10df80b2e0cc4caa750b8c181354434dc087eafa3e69c5558f7d2be9534a33a537f03cf4c088072f267506cacf83371c931b5f2259b44708df03722846b45144f1afe00aa83f5401f27e8adef963547b355bf5b326a4bd6d2d1f1d5027c183aa2c3154f92d069b07fc3ed91041c82b44405e2cdacdc45fa776c11f1e243a4f9b92994ddd50c3f0c0da1fb33b4bb86346596637b63c848a2b35301214d3369fe40e6ef9351cc99060e3b7e22c411129f4ca552d87e5db661e9d552bd00883f78849a31597c95333aa91f51ef7326ecc4c19c3ad8eb6d82e699e0a5754380a1691fe229032b0cd0f1c121d0d4f0703a08b8a9a34c22d707f88d0bdf803d8bc7cba69c46039729659f1d913bf069f82d9606fa773ac9ca1b2d8360eef933dd4d964a19d0463449226e31ab758bb98bbaacde72dbe6c0034ebb84a7ac609bf4ed240c91d01939ba467c6da8fae30d42df47ecb0d4525af4e2873e4cdcc6e87f76d074c8c1299adfd5912c72eb69021c3dbd8eb3379ad5ffa615656f4e2c3822e63ecdda7a8223a5029f55e8728f1d69f3a69d04a900e2209202c3fc3c1a7b247bc9ca84c99d067ea552b2ad16d35bfeaf45ec155bf67c4477acb3bccddc21ba01d99057cfa1fe5bdea8ce541a73c74e46247b1a060f672759f247bd9ffd9590041542792604b2cfb800c3e7b00c594aa17459126343e31bc8ed7a41d61fdd1956ab1e68eaef7381efa44bf887fe494f972c6b3b72a782039f4ee1660523798a50cbd58cd81be8c75299b541f38c17ba2c210992b64d6befa42404bc71b7107e397d97cf4907ab975e449e7c9b57f893d114591b90c2b5b9a932b73a92d3a359026ce34d0424289a88f702b0581ab537b07c5544610702692a414c2ac82b4cf4dd3564af45e3e91bd3b92284678c629446e10e855d08fff3279acb43b2867a119b1c2ccc1b0c3967a8cb60790cae61e28e47a0256567f3fb018801a1dc7574946d34eb3636d02aa2ac9ad0664ad59d48afb21d1d307e59c4ec1a2379569621dea8bf8b20ad8d150c461b3d31899404cd79d5c42e2cb308843eb1f1b05f42c91beebfebd3c6387620e131b569af9f3212a142017e2e327f86080835221dc339db8562c57443880545595e5b074206aeaea4b7c8a62ffefa9541c93533424b9d0430985e1b598a8db6ae7b8fe9457ba757e472cb4d32f1eb9e4aa475fe2626b9675fbf53c4d4df26a0dbe44bed96022633a247964558dea2ca8ed9185e96b6fb5e5f561477b3b8bc5f13aab62099a1d364f7aeedb7a4c99f371a331775d6fd5af981ced1f7121ab09dddf45f252cd109b04b87cf30816e5a9e055ffb2e37888ecc737ab4de149b205ea038718bcc57c1b6409e5e1a9c29e50e2165731db6a532406af7ab4b8581e523819b9d772d69f49a93c57a651c15a9cdf0f21e9e107fa83a64356739cef859050b742cc94cf473b7fcfd11cb1b6d05b6070379d4ea0bd8d6a5b957f30b9f1d507c58ce0dcc424409b3082376dfcf6e1b277d7f9d8096f791877bf7188c73969eb0dd9e5d0254efedb2b1dc8fdd27506317c4f2adb7324ac2e34c37d2ec638db144912d8428c99ddcb53a38b1508f4420bc20c6413a02e1640411fcc4f71a4604ec9ac57957d38dbf9e1509ec7e1f0ce3345b42948d68bf6f0708c5b308bc461d78d2704190c29010fd716507849673370f325f3d3cba03c8d70df8d2cb8ada5ff1089090ccbab60b4f15c61eefd50a22838519de04432d665fa22150e8a34b4f2b8dba9f9536bff028bde6d5b5782b85d31fd3de7597fe3f3bc8cbcf3f95cff469f63092948f7f17832cefac77f2131dc6aa1af99dfc0936b4156a1e1d5ff9ba34e5aa971a68005067a778a896913fa4f0a33332cc30cb333f4ff1efb256598029144241daf3f662491684cdcde736f68abdac2e2e17906f41ee27278878cd5c1ecc70d9b64cb2225198d28782c8ddd98b9b7a31cdac234e91f87e23fa948a3cf21e0cc123bff57ab4d587bafa5d9adc1f42d0330d4684fe41f1d150ad44f7705958fbd66063b1085e7b5bf840887a82f64a08660133518c03b8988015ff01715d291e4abe5586816ae2bb06f17b5a585f89c62647bb89c29bf1c6cf8427d07602adf6de10afbc4b09e78c7dcba2913e13b7bcdbb62c88d79bd049501439ab22e5f77a8dc92223843c6dd8d45d59f23f2ae8cd052a293edd4908f49b4d6d66c59379a1073cabbfd19fbe039a18396a5eb8565f6e4ca3df1c46180cc2b2e158ca5e75ddbd9e9a2bddd7e094addabab3eace6753f3775781593925e87ca4d025f703d99be121be332b9185758671b131deecc9ced53b62744a1eb387e864d47cd5fe8e1c7639d7684b814bfa4054cbffe964590d9c9fc62311324f0c293e7da51bedc03b7d72546b82d67a0251fdb88f27093d17f2a152e965a8bde79a31a889bfd833e024ec2a2beb2b36218d952a15db55a00ee60c0768766f4247308d9542dcd196d488a8ef2e5c47739913e84a76a6739c9d023e177780810518f95e99656c465f3b939592aa3160dcdb2b67ef56bc8286d3214cc1ffc8e8206a1ee77dded1ab3fec193974ebf2bc7fd41eef92e8b7e89136eae7df13be6c8116341eb82829472be7e78b4aa4c156489c84fe9b63a20ea337146f1417ce17d9b23a577c847bbc3efb5fecd1ec730ec67b29758a6a3551a935ae5421f711ca3eeabab7b9a7ba39bfe48b3bff8da91691206445581816c9e2e777dd1ec02f82c93f75a46eeb8e8135acdcddee61bac1549386342e6240886c587e982de3a1f0942dfd7a20238ec24347e61299e8674fc3a19dc47b7257b381d01c2674657fd792741ddfbe2d9208bdf92a78f7b53b723d56a93fd6d547a6d6b3bbd821c8b01c9b02cb4f2df083d7d2c7c0eea120cb4c6cdad75742c1e94ef2d0a06ae16adb0613460c086752c6741c485fdd7947989c4beea43bed5baff9ef52ccf27954816557d06d685d014746ff7dbad37fc96d0fd7ef3e59c774523ae54292cd518900198a8f90d330e1e799d98024cae375db1f49d06c15f2a3bf3ac3d741ecec3b7e883a2684e1201b5680354cd1251ff18bf728ec610e4f5a6d635e3560c4d7b7d7e3e203c5968f37abfeec4d428e854e64fe2b0ce9871bdf365a20c2acfaebf1d0dd3b531f9a92ca19f1403b6bfe37db813ae405f4394d515bfa29974693317afdf0d8bc7d9d54924f018be067b7b7ecf99ac42709b2695b8ed92d2d1129c695ec141f3c0cc327d8f119eef4df43e1948d1f7f52e21e342c5f36e8d8d97404ff589d87555cc3a5fce8baaf8523b6f7271aa19ae80ffec3de7fbd447a5f509e7c45a31afd5f866ba105c8db001fb4a3755686e51b6088aa08c5218c450590fcaba451c354b6f9baa7ea7abc55c8ce54fba3652c2c7d9138c6c07c56fede26313865d24aa898087e0d2470ffcc786db2886254b0da7556d3560f34aa4ab266e97f2236cd7e7a8276daf5f2b1c9f6af5ccbb7346f86ae730597104c9d63dd730c6e247a67c778fb91b0c3426e2a35afe6e13ae3786c46e28084a91369e737efe64bb76b58546cdff8d42f3b8f135cced76074a3e49a5ded359c2ab661e878454799d0be278481042a9bbd41a176dd75ed837ae66531371a6a9480df7df38a078c23e6e040e9593f72d61dabe0768bd6cd4752f15fe5c4ccd2c799c2d9efdcd635ae5b5527b6f5ab66c70d9119416d95d3b32e42730abb743f0f1c3c5c7975fe739550c19be68e2764b73c51290811607790fe5fe98a6748c5954ffe1fbac15bf970b1e3ca366d9166d50df5b465b1d8c18a983a1ed8e66648e5b2d0619825e3d2c26431beae725cb8a7f5ecfc21b6c6d840696974546d8ce953aeeb57b207d6082c49bf82b51dc6c749af0d4f5ebd675b23d822b8ff1def011b8ef61c8f696fe486fba3cf76268924d6a3882d5eef3d0c08d1ba12b4cd1104e0bcf9cef37b9a1a9f3c5ca2458f390a9232f9150c228a8f7390a4bc950bb7db8d21af1726a74ffae8b8f9c4f238fbb097bd5ae009519521271179be9912a74e9141dd05fca2152457d7a6ab4490093e154ee1733b2538437f15735e2c7d23c2afd7a20d692362048f42faa29bf46531d1de0c81c7db9679806a63a76fcf040dd7a04c6457b7f5d10ed3875a5a24071eb52f51634cf030851c6bed129d12a2b4671ed5de4c387d8edd67cc74bda03d4df076703829d8325c891193d347e59c98f1ddad2ab82e7d965b3c3fff087a314ed832fc94de379815c01df72c07f79dfc2e699b4ce03a819c58d24ba05340e410df1985687745dce23dba27d23abbbd1b4cddfef48f116784dad553fb62e6434c5a4b2ffca306addcd83d05adab65127e0d1bb8bc223828915086e6ef8a3193f092eb63c43a9a3b9b4e82ed33bd02786f4e2afe583b5c4755629e91792446295d14614bc72cc6a8306e78012c7f6dd6239edd3d073908c246ff3029a3f7e316fc78f7ab74440c55ac795fff39a67145aabed70e5762087ac24851e07217e04e74835a3005cb82981d31acf5642f9b44d9573e83af4f498a64a95e3551c21fef2e8c09e71f92c4522a79d23c2447961cce22334ef9fadf1a4265972f27a9ebc65eca3dce135d7b9f632b850e11d201a61214d5c44d0ed3605b0c711919848977d2a707e83dd3c05243800f63d87221b66c925575dc3d005c1597cde6f945441070f00dfd0e702b0c10441d1695eb9143702ec113cf90de3dc464ba20bbaacb9809763fbc3ea9be34bfbfe5fd337bfa6632660532c4105d582d12c422878b6e629dec9788ed3dc6ecff1e075c29bfcc0a4797171a0edbfd882d831a3d14ecce6053d8c5088da699d0fd40234afd48550437575739ca09995eea0e4195dff3803d18495a457bd85d28f4d295c3072bff6c0b6a2f9ec7b03c3db5c69b0e656d020d7a8c7355f53a69aac96ceb310c1fccffa0bf5d3d0ce310212dfa629f01d663e7112aa4fad0ccf2f119271949e106ffb5ca51366139a759c855955c16ee529cf0aad43b9e33ecf8934f39d253a9e174a1826b71603bb66ed55f43c9ed0c70eb2e9e532671f66833d811a7f8c20a0673accff6da6af6784a05d3cc4da0c957f17b85e751c54b60bb9fb6f60fc6841a2b518b387edfe90a659973739a556d8a52c1ccf4edb2b344731636f502458cf9be4ac73fcc3d043edf53e00ba324cb19b3ee7002860afaa065840ea7488f7dd2e0d0ebc522ccb5cbb4de91d35dc16cebcd99a42829c7aac04c335773e4a481ac14c314557851a130ddbff0f8d7a332388b4bbe9c601a4a114a5759cf0dec76df41bc9de96fe87430bb82b1d1ec146ad48fdf50cb0faf0fa4d4d4ca5cb1843c84fe5b0295bd95dd9773fab68ed2a5a33c0303769a9584b861d2f44adea6977e45679338191f7d3ceabc26b0ffcbfefa4196b05d4ef536939c58371e286100c0c9aa925b5b75aa195ce86d7784859a816d16987eb0bf6b1afaca084dd95877b52eb6d3191c0a946883592d66fa5eb2131dabdfe793c0c181c4568b89747195b7c043ee8040559cf290379c1cef06cbfb031eac9871dbc33902647f80692c84b541da93865eb352d7ec5aaba1cc1bb1eaae2bfa0bee63bba097751b3fd55d2d97739c75fcd5620e6493f2e801d9a037836a8eb4aeefb5f648d5178f9a09702459b2ba57bded60abe98750e8a65beaf4fde3bed79abe8b3c8d36f59eb122c74c5dd7de8bae6f68a518a8cabf079f4749a8e94acfd6645f52b495ad249805921d8abfc39e8dd91206ffbc24617b43cebbb306ed9832937a828c30d2822385b1b3518bb1743244dce197d266c2645d17f95df1ffa3022bbf1d1c62cce70a955f99848d37ac3b9a27a967d8fb35546c8427adba22a30ff9f1e06287ef2489c8782e7509754650d661a306b29cddd252d98c583eb00dcee127235268330f540558fd3e30c911982968acb025da2c5ca3efc649faf33f6b2506b2eea5390f48762cddb65d9a9f555a21f5c0bc960e6e79c0c85f8f71fbec6b7a369cf3ec1a7e92c687b443ab6850e5ca5b2e89e813daef1c63dd84bb3b0e1b5cb65330bb9b7c07916ee36f7b907ebee0b0ec7f3758062930a9ac76c361b9d5044248230eb1ad29aa16ca075f1d0c6487f6111d74ca216dd3ba759360caf1d905b3e84db4ed84e9edd19e77cba90f988a8f94d72bcd10b68b5c47748bfaf98a5230d5326144d69ed55dd8c75d720b3fbba723f0ae96b62538798e42151e96ec905e286864d6f62ec66af04c4c0440e02294c6dfbe79b9aef521a6edeab2e726aa5f59f02955b4cc90e23ab8323c553d793e3a0fa5bc01c7107822118aeac1b3981d80fd8b0ba751a5b3f278c8df75d1871776a1bd83a43053e8fc891aa05f558591df3584b1be9d6e78e4645f7c0d735132b996bced3f815bb08ea2b9b21c8ce79b9f5be299e8f876a4b81394aef9aff685cdc5f389fab85bf332ec8096d4ee68d51ef6a2220669f33a476c58ad99a50105899467acbca8cbffb0aba246f461c5b53990962c1af3d88826cfb081ae0515866e617b4de147a55bf9f9972fd99eb4f49517fb9ed14051b9059c14230cd6d4e0200eb0079ca1adebb179322c238454bf7a5e7f223f340db09fce322f871e44b8871214b35a1ed1cc24ebb677bea5ed92884dcb1373793ac382c8f9146f8d4b8fef9aadca5a3bb8b9d679192bee8b9390c0733636ab0fa3689f99acbf40cc9dad043d1a9c89032fdf271c6b49ba81ae44d58ea0bafd31d911e54ac9eba2512deb88d662f5096cce5a2a92ab6991d0c05b8d98eaf84b83e14388313fd3f50410165dc820cabc5b474ca8eab6411546b662042d0faac0fc91026f863ea82c1e49d8ee1d28368ff6fce7a000d488092d18942f639fc143a230bdcc2538eadbdcfba46c8aa7f4347150fc93db4caef7e5d23a2dbae79bc0691b9673422d31fb059b591c47bd7fedffefeb0f849529091ecf6758d9db07f5bae597bb6144163e7a42e3e750de30e45807f30f9777698eb8fad9095b8b19d436dfa63465e4f6367708020ecf87934b182f01c3ab0ff4d80f5a8e686b2f2fa7519271326887cde09670edf76f3e9ecdc2512676cd36aa6884909c9e9f615fe460017ff57293b81b31a1cf38f75cf7616e836a3f877d238269887b1715117c71ebb75ac0cf5e7442ca338c730bb91e5ee8e2d5d41cb5b07782f692e00bafb9fed8cccda4ae87e42553dfb23033567add2df87833e0496c0f2931a3071eff532826889a4bb569074e2e3a0530c9a60505b3d82920257ce7bba341c568c38d52baec687d49892088c21507487bb8e34715a30dd65a0ca85dd2a494ab9b705e660d2b78ab0977917ffdd2086941cef0aad48352731ab8d3db3058fe769c5666268acf7454e5fc968ba96b003a86ee71d52859c9cebbdd4b51084993f0071fda59ffd82473ff129273695125f816598f43f48bb51bdb126639193658a3dad8f4a22cf5d2d144e66b1ea6a775ee7d4c791d2ed6fd2ec8341c49d0781094a73aa74d7a7f720daf95a786b9f53a792bd9aa1140f9ce1a3ab27d4631c29de306405a1e893d87a197abca534f5f2a2d2345186321c6b62388ed0204ff7b994c9f17e5b0564b599023ccb0c4e8ed8e9a7b558111aa54620c0d7e5bc4de37fa1a94cf2bdd10585e197d4dd51dd483190dcc36e262f2a4adceb4995f5982c25543b5a540d2ec62c7c65ca4af128199f0e9b0da5381ca33a53146676801923c291ffff2f0524d2d3e2a2dbab1e6e83af85331a976a22169f9b9c9d9baeeac80f0f105ca574a5b01f001a2cdda809ae31464721f77cd23caa09826be75837bfe835d45828f161d2e3dd67b4ea4c08a42485abf0849889fa09e6b1907951b793c388c2e58227f63aacec85f3559c5e5d2cfa0f6ced032b68f3bf97afe4e98443b1cc01e551551054c85b7700518caea13ae07a8652f2c3ec298d8250a3c42aa7926238508eca75752916a3861fcdde58039f5e264c21ca05c07af06a27ad7fd189343c76ac6c4856ced2a03224d51934eb284a4ede7d33473b05f03ad3981cec2f0e9123eab33195349ba98616f9ebb465f654ddf7050d9aeabb17847608fb50bad5fe47ec1c4483cecab1f800dd80164b54553ee4e7952e32c1219752d49fce298c87f65367fcb00c372ac2511a7ad7bfe811ca3a5c546bc7c09a4b2e66133fb8023371a979b2a6d4ec5d403d9d53f82a8fea605d19bc7b96e2c2808de1d41c60d03f63cc547478de927ba38c64bf43f6154da375ab187c72f9006330758b16fdacbed6fdd59c2382c43fbdb5bf09807c1261a0699d3737c70b3a671d97d06b04f9ba2908381e4df72e1e1210ee9ebefc3ce2054ffe1dfa28d15eea3c345a47875d741f88a4e90619198d8f1fb2530df5230cb3c4a1d3f1d6a2c470311c452060131495f2b26e24f1ea0dc495c3fdff8a27190952d0e65c8cd0500b99b715083ac97a6af4fa2bad9d9747c42abd08bfb3f92a34a9ee91ed431a863af25dcf4eaa09246b02fa09d0866db49ce383ccb3403d9c96538566b994b68995e9fb1586786e9e97035ff18013e0ffdec199276a2ba7dd240d0b1df9c27b276952e606eefe461176ef0208827848171df982b9265df27934499895bfdacc20a4fee22d3a9b2302e6d3819df8e7e47efb241b10e534144a41e1da670ca22b4273413af9004aca7b2b9896b5dd07caf827a8cb59f699e2b020c54ab95042d20de640143cf9e9a14cc80455e9fa6c6dff7729bb9c3d26a1c345d4d1522644bbe4b3f2c06c15e8d4167cbe321d9d9354d3f28cf7b3a4098c66ec72e7ef54211bf56e3d154586c855d14e757b76c00c47ef93db5b1c85e2b7ca641e319a8da917607025e5dbe1920fced4aa54ed3d74b1dcade46400bf25fdb039c156ec9516f5903feef4c6ccc4edaa821b41bd63ae09d9c955ba8027d2d002fe6a2757221ecdb18c618be8d11145d2d5157bd1a52981a3d592061d5e2b676ae1a24c8e7bfa1223cbefdc95b121780c72a62dd419b9fffb691ad5b7fc0fc6684035cfaf76417d2495aec698e131068653c7e11abcc6316537d95d91836c5decc7fcb3be7645b9ba49d02ef8857c857a4cc743e5a33f7104379d8bd3a7c1ade112ffe1a13eeb010b88ea451e51a7d316dcf80f9fe3eacd1522166b4dc75e274268adca4fc7d9bb036e16a1691656a36188b49101c9f6c1616eceee66eead90351c0c51ace0e0b7afe0f18fdda7db787ea3e7ed08a72e1319a68da4a94f9a7ee8f26aec4e988ff43f140e66a8300b9847d202fd7807d74914e1ae78a494a36d9deb45ed429ec71fa53952d4038726abce14969d507f5d4d640a7885d227588b840f278f0fd2a7ad360d73170038b77681cf8e309ef7e3e47ab389eb236f11067113629973c7ac4435476d9de1bc536c8ee861fa36e0255520a3430933b1303cfa23ae3b477b211e099a8e014b21cbed9e1fd657b2957abe75f0b9d389714ec4ca6fe2cd8ed9df64d0f48a2e5b9d9d08501248be9c451e54b2eda10e9536200073d4966531e1a5a2d74a091739ac1aeab2b2c7b300a8f14918cd72cbdc48a010a69c4554f501132735fa95bfad847b2aadd108c5c08db9ad1da560a63ef106f3d6f2a55b806fbaeb9dc318ce1e996272d722e97a8acf7b0e5ca58ee5bac185e60c07f610bb956bb5b78dacfc6300934c7579fc82ae7fb267c0c0b698ca74e3b7a7a20258fd082eb95f47d7115e27026cada9055635a682b791409c7acecf8c4c06dec3350beddf41bb4ea86d4d3c9f4f37ab5d83304627d9371e0007e56b5c456e253b05d72c8916a70f4ded71ea7d9f1dea3b10e6d58bf9fea5fdf158068faf6cab88e6e01b26314e86d5a48f9ffadaf3423c520998e292749afcf8dde299add904780a5fa49148b88f3a3a7e1137510e822713d7139e793416eabad1b3ce4c38df7c149e0c7ebbd97a385b30ccbf478cd87868914994385c2859a185b111098c2ecc26aa54bcdfcdb65019356774b181f09f6e803e1e25691d2856dc3cda1cd4605b52d4243e2813e00d06a0b0bad3e4fc27e6158fc7948310119e85f514d672667f1cae4a0f6439650d2bc4d62f3f152a12dc039fb6dda791e2601b16cd4ccdc24259a46d1b6eef0eeb3b725e14667c7fc56a92acdbdfe6faedc1090ddef8986b5873348b59e4347bd16a31ce6508e957c8a2445ed821433d344cea546170491ecdf0facf794ae0dbf35065470a3049a818924e152d6c4c1cc4b0107834648059ac3786c4334a892a38b1fd27550dc427caa7bf38b3409f07444c87b317975e5f9a1a24e7dd48a5b582ec38cc8dfbc8747bec8647550b1d5500dc71ec38b9ab2b280b97a4b919f873e1231aaf0ade43f5a26b34e53637dd246135e96a14ee506029c7b1c410a254dcfa94c2682f0c20e08c2266935aca196981c289acf2ba0da24ab47c33b70fd7882961ab17a11ff6adba8f3253f8af7d21a9a0a2828966ede40e6b99ea58e0c36661f006a4868735978bd420abaade3d0d914b1af1af4f17431064c689106ea5bf0d8f8f3cb6df328ccd33a3837f12b82d6ad561f36fb31bc0b524b4e51f161f706644b49a8cd24ad218dc07fb32532d2e5b26cdfab0b688941bfe39929ac8c5d3958fa3d26b62260e4c56d7bb2b508d0a3f1e7aa7dbd23543c92f91add2653d8046346e88bf1544683f3aaa77301ccad0d38b211e352f19399101c89c09088e262c6e8a93ddd52745d4142708603e29f205a6798e86ceafb4c5a432f10885b8c9b4a7c612defe7bd09456d79fdbecfbe5ce2122e81f7821c2c32f01f414687ec894af82c8e73f199a1f7daa406c3cf79a62f9b4cdaf886708e897f757d176a043b404eb994ab05c608877676bdf0f9a6fafef8ec6facf30b0ea0110fc3eaa6b6b398b8cbd1bddade0c4434139337acf7008aa0f20e1707248f46021505e30bc4627f59afcbfe484a16fdf6f40abfc0eaa618987b521540cc2a82a8ffaa542759810281b96b4a865c7f8a0f56cabf0ff8ddd1ee123f1d48dff02fc61f96e9de4f12d85f18b9af72e9b3e44b43d70ed63ebc19a6c20eac9bf919f029d84113fa5b1e9ff80b678e6e21d614064d1094a5cd5d20751511baaae6089c74c85237ab6915c719e9010283b2f6b07bf676b497422f2af9188796757b08a8154f568a0db7499f8023624f1e123f641469f217a1685271c46e4aef2bf4efea13a4c4ba0d99ea1088a6de0fcb9599fbf76f8c2c1d9a80faa5bd7a4cf010201864343c429ba460d1335dbd491467921561736f4197f6af686409db6c706863588499d52cf62fdda17346a8acaf114b2df4b314a30d53d41fc0e22bdda3d5cae66c5b15cf2b827f3206d076a734477ecc00ceac730a3d2e8722a2370e19d04d8d65a26c5b4af04b5599f02b1d196f15551cb88f327a6e3790d3117da572dc0978c008248b706fe88d7f476aef6d1efd99e8f99d0c06478720561007c875e2d6945b622b31c20203f324cda0db0aa2ead8622bc9cb4e0e10042efd4d2bd828741f157f7df2b131d48c0fc2de05ed9f41ccc9c9ab52e68c75139f27809bb8b95d9f8e6e2e2670c07671a019f1d01a10af37b9a56c2b050b8685d542de6022b3e102405f4ea805548787450524823cd871a724d13fbb4bc09fee245d0035fe2d416366565e86bf2d99b9d7355365d1db456924bebdb1cd8d98969a007e171b4745a17b99b5233ae27cf993025521476f11b2fe19687efd1796c1c50ad162aa146ec2b4c630df71a941b90cf3d10ab8392c0c204d8d4f10c1a19fce34caae678582c59ab1f9f65148d26fb4eb51fab513c8614ee994c6ddd5fc0cbe88715937d04af96b006a69cd8b5f58ed4236bba4d13807f9bf3ad35113866330cf03d7e0a3c11ad46b4dc47ef40b1c7d29d255151556371dba5e07821ef6993e52ae7d2b94a843002de666d2de6513e2097221c286d3ca784274b68ba184167b44d63b459ec683e94d14cc03b66f11d405db9dbaae6d355a67582eab13f815b51cf9bae6b1e2e7d9f35b4d21a1317da507427c7646dac026dfc2a1cc42c88894383e7d3faa47f4aef22d7cd9d92854b429dd2a94fddc2b843671452cbfc37a9594b294481c9b87d5694139af0e21084c67bc1d9ff476a823e67dadcfc63ae737008cac5fcbc0393ad2ad9e8160af0013f205c9a8c6f896cfe78c19061d2fc6d14480f35e18fabfa2c390dcf87ac438226bcb528bdb6e16ba491a9fd6130081eb8712a1a4bd22ed7c278c21e372a7897d657b3c831d16ef0a386110e1f6a4a1fad0d7612e7237a9aefb086aac448701bc09f83f83913938ef80c3a8827d47b2b67ed6bd0fe3b6bbb8bcfcc14dc025ff24f415da3eea717b790e1785d4f7ab254139fdceec40bd532123ec2c8b2f2ed108b108dfa183a0d843d51007c469d475d02e9b59fd7f34036e9ee5e35b8448d364cd8e92cd59fd3e4348185651bf290ac14b7ddce23055f25e488f69b6703f8ef050ea88cf4c96d27761268030a3c37a3388fd6d619802e8514a91302a223c62785035c23ccc2638a0a358ed918cea40c358777adbed316626a0c5715c1b1551b2eba0887b6363ca37589ede61a1464c5b3652763568833199258b61c181f0575dac59edf67b1946e203ef13a47bcf342a1f16b49f0642b8ae25932f20d78875d27e7140f40bbaf616fa29840085fbaf08a8faa7355f168196cab82be1898cec35e454665826c13672d47248b7ea1bf19a5231a2a84dc9ece442169ac7dc74c1ab5b6b61235a3e85a740a0a4969da9f14830b00d8f2559f223c05c39d09c1f0bee0861bef53bc02465c122f0f5d55493c9c2482f52fb1876fc132d91f432b809e54a96bc84a072a49b9ae3d327ca5bd3fa56d2615afb38947749b2c6e746955d514de15539d6856bd65e93d68c0c1d6312f09b6db01730bcfea3fb3bc4f94cb65f20ccc4f0fafc77bbe1feac49c8214de532710ce26695fd139d1dbe79958d530f6cd634a6f9eff924b693bb07f5d62d610698701e9e72ba6a7966b67281e5bb384bc197f25be4568a250502716f17e2f0d7a857209063fa0be9905caf827f5ff393267a154e8178789a306d28523b721dfe8d43ed54180c91b0220842dc5fd0d333f70bd2741211e9dc726c4279e0b0ca72561bbe1707c23c8cb4738345ae31fd12777e6bafb47f48558b69c7cdce2965ce43e5303a8da6a5aac63d1bb6d80641bdceb40130d20e3d552fa9d5c04f25eb0e7901fb47be3c1a77ce0afd8a04a7b5e8ef562295ebba9f157c8c841da7107ae641255cc7de2b8575b7dcdcd0556df59155365453ef1fe7dbe550daa78529d21309a2d0a98bb8f89a1bd28ab76ed39c3c08ad56ca444f809119ed211a52c66cb01daa85a80c1b847b9e5a680c8751481b93a0a76164ccc15ce6dabbd2103bd51586b20deb6886130c3c0cc6decd333ad976c635b61441d9099b612c8accd4f486825ae39b20befe005b70e8c6b5e9b06efc4d9b0149a0465713ff28f8b9c2758f72bc0d2a03b56b3e8a278b2c5a23abadccd775679ae560c9239f826a915a829138130c9e83319d9c76226a4c3e05475180807f80a46efc04c39d6c609f99626fb22c737912cfc5b0887a2e8684228bd4a02f3902b7418a03cea3ad43b3b7b50152e21aded984d00489dfe08e2dd3c50888f9c52a634555bd331d8d8fc0cead50f99c5353e2187f5bec6c162a92fbce70336dfe767548a16956d083431d48a66e825f57925581f5b2de555b6fbfb1d1fbb5eeebae4d212b7042d3c20d50c29716d195fc005d4bf9559e3cc15b517dadd3270dd3e9e2f71d7e75672174a741fb0c987467df8f45ab220f39958cd13cf8aad183a38e65b899a3fb2c6c463e9da6af88963c7aafe2f008759fe99bdc8cced3a8a79cd584af3ca0d9c8d0278463b4689458d96883f9896743f59474ac655ca536ee9fcb974a7676d2dc13555ca03eee003c54238ecb6a6fd9f12896539125254ff46e412c5764cb07440dc77e6cb929f1807e2774605bcd76672c9ed140e310b247053bbeaa2703d08b6119c59db38263dfcbf252fbb881be9b7cb30844fbb35149e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
