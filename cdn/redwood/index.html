<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1bfad821b0c7aa81579284a4bc9837eb1b99c50425262e3b37592a547ddb756d478c07e94415ab1e9240a7a97893e810b9d05483f86d6a0f2ce595b250e2f022c31f49fa75252c5df5c8c5d04246c6ae23697eb7e66834ef8fc0b0eee4ca174831d00c983dd17143c0d2bbc77c897f9a83b4f06b770168a949f41db5cfff32f25f9bcab96e148be1e883dc0829a2e4a66c699fff4a512bc1fc343ea65611c62ab6413bdf99bfc5c3ab886cc40a8fff33ee70cf146ac8f5d3c85f16c8ace984d041aec0564c0cceebdc8e95cf0b25a80713a2286a6e5433cefe649de46371ec0a6dda58f6e61eb410fcc86e3917b108f29da48f47d3fc12bc56fd87caf81c539f1d8aecb63a2cd71f8b06400707fe86345f8cd6adb0d8f6117356e88cd1fe71060f2d4f061828c68aed6c7ded98e9f52875b2b2d8092d22ec428ce5425ea3280315d8e51b6ed2a06006d749e253d432f8f89628606bd03f2490a6d59a28409501b773af684c01fe082ec55a4e5788492f4505aaf290963e8593150dc77f3e27cac29af047266faeee195a32ac5cf3d152f79ad18df266f6be16d6a829423b192e12f987e597b93e79fcae0cdb5462ebf169aaaf924998fb3c96e82bde48420d1ef7a30197f517dcc55adebc6e499f985d58c84f6d2268b57dff70f0872cf9f24de5a58c123678cf432b91cd145d205ffaf5ef24f4a6e800b3d29c150774eb3123563bc669a0776509a24c96ab64ba70240ae44331aeca6e56d20cc65453f3706153021bf3c39e70716bf82d143e39f391265234a19e62b736e94154023e4ba01ecd44b359f960eb9c1efeecfe7f4d3cc8d9ba76426ac88fa78f18e0e45f4e634b943f23cf1e5c912149d82396b5fb54aa09a8b66b9052edee55206c7300a7797259d4e33d106382bcf1378ecd0b9e9b82d4489734683ff7fa935282587df4ad6c10977b84f1e0771a85d2c24226d48756e7207a934ab0b288f8e8d67b422d28a00dc606eb2cdef61eae8386c1265bdbf362cf27ce6ee5294f606faadd2763b72f5f314ceda1fe19d21d0c2674d9c24b0e877630b620ce03cb1515c874c70d65d9883c022b16b3939d26fd3ab3cf6cc8ab3e9b3c86e608142ae3b9de64190e2dca68646c4e6033d6d25d6b805b269902bfec88d4c23425ed081d828f62bb2592aa5b90e934f406668191492113fc493eb1154ab7dbdb135ea021560de2ac976fe42480672e9ed445357085e3d7306a8d316345538ebfe1017827ed262e9a176420a73e68796b2c48120dde801c7a2a5fc026851591f2f8bc33ccf620e50ff1e420069b3ce066c020082a2bac1d6a9f19cf3970741da2b0003168c2ea2a5d5dc27b4996565d8a728cb38cc4c68a2e05e51cbd7b5c01ff49ed5f2158a0876b11e3df4835ad6de87dcc39072a4f6aa53c1e69df072ab3c270f493115ce8117f18228c09780f11c7c7947759c67fe3f8221f66515af2fe5c432306cf62aa2d0b04fbba6e29958cf3f1290e78ccb9899a1ae47db6880bb1b906947b2a7015acfcd035bc0c1fe713053961e4c95a689bc854951b87fdeb65dfc4d861dfa51cfd8fcc9c3e70c3921d90d0893596c000475a73f9935b56fa95c44b92e94987dab99d7b083fd4a12cb2df30ea3490e29f89daa6ded0b7a9d344b923e55a796e7f15ffd821b708fed07710036d23fd92dc3215fbe79c96a3f7c0df4accd391d5f4c033f5c4d2cc6d008a916f7e6d12c44ac80c5130255b423de49cb7d156af166a50940d3175c2f15e8b7eb29772e86f966544fc162b0e1a194b5eee5249634972dd698f72f8c08859f6287117587d06f05122ad6adade8be647af0cab38a1b497d285ebbcc8ca4fb99c0b52bcf8aa367b509c60ced1d4c1dfbc5f0dc3444f8c430826b975c8e396508e406bf9a559c59f7e1c3e1236c82eaa6769d0ecac4e6d87771de7a77c68d9a2bf73f57842e810277353aa5d8e4cffb917704432b1c572bc3a2b48947e37a3db7b84dbf482cb73911f8a04913968665eca7e000f668e2ad3cbc9e908cc57b185084167a0acc0ad52f057f5804091dcb9aae96596f298f926a72e2d993b951690aa39aefb8eca29a37543b353a045152a7ef0ef4798b2ee30a53e7d66f756c4ef6aa3b15c3600be85be718861321b7be4ee5a1a06bd995a5fa9fd50c304527349ca49f0d7d915f976e4cfd06f2e3cf4fa80c096bfed945c8681ea1bdc1c90fbf11a5394230143dd5539d8ecd27b43151f374f581f393fd79b1643d3e913fd664fbc8e910ebc3ccfb2f400bcf372dcc4567ed8b08f84ced0d20a5f6e9cc739df9ca72560cf3517d3b1c12beed917ce0d8c5c2b47d61d7514c43f4169579b47ded0eb595789ee372f8247eee2b253ac64888b893c9a6aead0a452b6ae539318f8d46df1691e42d58410c7dc8875c86369bdecb4010b4935a25fef3f216d3759f8bc37feb003f3f91c96877a5a28b5f6ef91f0c33df26187390772ea76aa426fe4e6de26db525b431f63867777c7f9e653bca62ab64ec01b6a24626084812a74163492bd367f9503cc67b2bd68e0bcc84fb09fecd8f5f3b7d67bc2bee14ffdce47179d69f649f17c26c85befc59ad3ada97984f811a351e3ec8db2ff8de5b124ab761a454c618c4035ceface4986ccb1d6ed8d79243826228e85b57552ec58a4a8af30eafcd48c9c652a3997f156cdd3daf494bfffd84916f62bf68af6c1c56d31b6ecd41d784c30c7678f3986702de8fae8628ca7bdd7423576f5f4dfade72d01dcf428c4b16e2c4ae2ea7181889c11528e44f4ac6c91630badc832ea51faeda0c133e98a3a143621f652454b15e74a6371e16b3b9b1650d370a678de8d031d7016d93f8f8976702b3e792e55529ae378a85ccb2da41603b92045cc31b4ce9fd8831a3db3ff42f3a71093eb41da58d30b78b768c780aed329e5d3fffe7af7f69c3a13bff0a964015e56969c800849577017b82190342fd1adc2a4642a00ac9bbb4c1109a3af212a638b1e31a53b8b396464bad028959d681b79fc271210ca45a68ec1f0b66fb792d3767f5d7cbd301a8618ed83a4fcd1d976e0ca3243653217e9c19778c7394f5705e31b4f993d275cfb1a5834a6a689fe91700a7e2da256ef1cfc5d71395a2e4611f26c0fb85704a26dc657bcf6391b0658e04b9982339e1bfe543cfe4f9b827aaefcd08012ecb736ae8b94f535a658e3227b5203effe23dd283f9b2f53bf33ff683be40398a60090000490963d3840d901f2ddb686bed5000cf20c4df85686174a128e1ca809a985bf4acc6b8d4799a93c507138ade805d9508a69fbf1a67ab54979ddbf65a2e58ced591aa726ac9dcdd60016b2a6a85fb3a76f01b02ba967d44ab66494583e076ba79bf49a9989a33ef4380916003eca2a2d275c515db1b845ca62a7599bb11569a980540bd371f84885c96d0fe305a6ef035ca4874a14d4e6f097ff0cd85f67714be9300213706f8067bd5f760b00907716902eb8173e41591f291fcc923c80b41befe086611b4a549c169fd78bcbe9d86940511852b987cf15e2504427b413cba1a355a7015ccd154b0ad57e64d1475c24de3edd96c892956ec03f2b447d92d4703734506cb0210b9b0d3e8fba096c9f92722e1805c53ef9de29247f184973248da2564c82380a5c493e02938c8e8efe31a907855b1ac33c9ca412b5c9a038eaa8809adf6f39728e2a4e97f7c76a23cfdfa871b1997671b4b276e4e374bcd244745dca04e97c0eebc8f32804b95623a7be2c22b8b5d0143314b0abecf95b5ea96e8e0c22d811da3395e1e02f0daa98a8d570a27249abd4a509ae62a89c53ebf3b2a0e69b35c492cb7d2b17b836ea4ea18c8a8d04c24ca699851900a82505281273b1844f2418c9e9bf7e63f32fb10c257e17fecbbb95559a88dce5954d6a8f9c7de90e164a95b1e0a5bccd79f9e1583b946b90481bb6c8c67af879d05516958c06947360521dab518c133276f9cd55d6504a9e8f1dcf6f55c90ca8b50fcf358ab03beffc624cb4c656c105630bc2a96b900cad1905580034d0d0a0068020eb2240e17d4593ebaa0234587860187a35eae0921f839eac6f90870efd0863872763926ac7f369541fae609bd250c996f6b4d780edfd106afe927acf510b1a7e4197c13703a254773b5c10f7ce297f622ddae55d4f5ecbcc4037c3be197e96f3407543090ae0b325ad93f1c5320e2f285d2e53837654cbada34845d1df62b2f84d4b13ef9b8eefc6ed75923993f04cf58c2bc62a03152f60e9313f8bbb9f51ab88d96916375163b509ebcd6b4011f3d40e5cb121fd1d90f91123caeec1278c21c6d28c2f53a51986fb8c71d261cb5b8ef021555d523d8b2695a5aa1e40d31d132d775c5c341b7682ced5fd6e92ecba457491d61b91dfc1b561c36e62e2fd633b12287f74bbe540f136029b65b0650b228163a5e3faa346efd41ce1f15bf50ec32e23d5a2f75be2625b97d2eaf449ccc916954078061a087148f2c9c57073870be43e8799319cb0763813fb0f1574fc7ccf3ebb63dd7b15109698212f6983a000d50a77498bc448b2d91b2867857bbfa9311a526d4fabb9a60bdd17195ae5ac608b0af9d86ddcf4da82ad5642f6b218fab1e3a0b6d98a16614ebca2f0df422aba6ee7b2a0f1ea815ebc715ad83d7594b40693bc2116ef48388668cbe59b60540003c16f441a0e44f1142bd69d16ae7ac59f63b1c0237851abf9d34fa1f20f8b8065c0c829ba3a54558086a7132dee1ede0ff333e5d5b23fc6011e5b16a87723d275df6e2ecb433c8e8eebbe2636442f4cd6befbcabc457e3654c26f8ab4441fcebbb34d46b4036c207cf0315ea35e3678083694369496eeba80eab838cc7067140f94e53d901580b846b143321a7a138da920b4727f0103b008fe2b1dec61a0e8e37434a88f95dbe9659ecf32265f86ec086b6bae093093653fb49b509e3745334466191ed58852b522c447f4284f74c8397389a08791c5706e2f56081709b66a0e550f1f49492c2216d69a071b5994f7b8131b357b0c1a3cfbe4fb6b3619ef2899d696b3b37df830aaba1bec75df0935c81652770c801300bbc191e7cb8f271177aa528d36ec2dfe28af19fd469cac8ca20021e903f43d9d490e164f24ba7f122e11446159ba79b2d116dbb6fc65cb6ff4d24b3d2b9aa5cbb1cab3d7ce688ef92bffb94c22ef7bfc62e3332b655ae2e814de9d0321aa8434f05a995b41a5a02d732d72fd59a1f35ec131f76f62bd0d5b30330837f3c02cdbaa28673681c11abbead6651e373efb00962fcfd22c2de8079ae0c18805a97cff440ae4c36b52487b79a8820b250ae0669663ad9566f42e29aa47c6d6a397f90e9d3703cd5bfe9ac2b88a22399b30126511d94f265e1d8e934685415ea6aa2deaf094b1fc3bce9040ebf812cfe283947525dab9b55965592117bf27512553749d8384bd56059bb19a9c185ffd827e3e2202b2cc108096780a342343c92537856a6a5e7b61c6c466c75e02a09207b81d30bc589f66ee7b63e0dd2f57bf7afda3a9a947c757f1592596aa45f43592d63ba5314d494ab95e691292b85e57a5787540ea90e4a0e4619986187d521fe641def45cf6de2b1c696d7a39c22fb493595e592f2086cbefee461aa50d467771cb42741559ec5c2880a18538ba9c264760727d4aed7ca36c115795a054b7bbd483eb48c1a9e48bc34d626eebea3b70c09564573fae16db2761abb3c58de99e4f69cbc0c8951274a8b2631ccfa5a97c7a6dd9730f82622d2714c174ae7ee51b35ec2169fbfd8b0b7682ca629e3175c1e2f5b017e22f3fe692dc559414ed625216f004d79537501265d14ea9a56b4c6cbde61b4b2df30e46b4aacb05ec4bff3d4d2589a80e1cffa1b4fc60105b38fbaf81b10503eb61046971605e175bb9fbb5155400a7d293eb786e011fa921dfea122b090a865f879927877faf5d5df76793197b3c37eab8eb33db6673919c3dba45161da2ab9327e94f1ed18087dbf22f55797ea1a5a1b84de53851293cc7f422b6f9d33b8a46ed026bbc33cd9315607013f622591945ed611b3672cd9607e194c74e14af1bd420ec7c42a947018c92a5c8dd3ab932592e142a5e8aa9e9c6833f86adc385509f6a0e0d3ffdd9b1640c22e34d7dbb0ba76363a0726d13c9a3c87bb5b2e1b174ae6e20ded9b5a4f42a37f937ad76db3a2aeffafea2ea66dcfed988e161a00a5b759a1c647c3aa6981388ba7fa224b7b20a836d8e4b75356135f8aa3c364164126f9e74565139f8f76b3bd76e983439eddcb53e371b5602c12edd1c412b8b1b88ebf5ccb59643509e0ba94a59e9caa08c62b9b8600f8511ffe1d5f8d44763808a3ce93165480fec89e15940e1483c01074d0611301e321f0e66372b14cedeff5f7f63fa4d0092cb41448bcee9516c87fd5c30139375f27790fb0760d93e77a5f150d270a1aa8fa2d6b1ad7918ffc1e6060d8b7756027dcac92c884f9fa1671449f9c895cd3f05ce21a10c079da1a254b7821641b4c34f2763076a91520ef3bd3f75623d2e14b9cbd520da9b6b6b2971ebe81120752fedd490ebcc363de5110ea7b9cd7edeb68edb74b48557c9f7d5c7f07cc3c623b9dcc02751cb69c68e5bb81aab6fa6246148b90abbf43bf52b16451708a9dbdc4ae7eb3ddb5f84df9380861fdf102c65dfa34fb92f3731c190fce244dd8624b4209503a3f03a1719948cd72f396eb5ebf763c04097ff43a75540e03c251df3c363c01d2386f5c19302c15236407a731e62f222112a3a76e08459f7556c827f678c02c748b811e8b16acdb0bd87db1073d4b822687cf84dcf4cd3128585de343cca90606c0016e06aae92062e7d1530f64592020e8545e4658d989c52aeb7ea7088c7f4c9083e9945bff458490be960be93eccdb8aa45deb7a803e94e7cd47e76266f3bc38807010efa2a3d2b95bf0544ae425e3db1bc44d2b61dfd8b7d5e2cdf3f3bb7c378f470bbf31a17b0018b9466dd1e34415297e4c62661d4e5c0eae3403ffd513042224307545207ce8345bc3cce89c50ad904dcab371a755c0d9186815986be04c2dcb4c65ce7c0a6d4ef21a1e1960de39c7d42646346e2187ec24a4dba6ca90fc81741712b9c99575b8f41803d00be0b0d50895819d5706eacb6a5f4f61ae91e3f495657bc6642e3ae9eb57c2880d6b418e2839efd54a31e2d7ea9b67e86f660fccd68f1c907e966f521e769936840fd5d9795b1135378328b987cdddfd78bf879e50b9e54df5cc894965971db900f3163abb3268a94cafb7c6e4a06d7a7ad6881096b45dbd501b1265ba2adf32d44d1b00b5be1416b8b693d8c8a071f0cc3b6f228e00fa891c0fde36bc69a78e1019390c462f07a3931374ecb31881bd45a25c92bae6ba095ec8e0a86df1a47acb42a8c7d823e81d7afe2577c204bf397b50312d6b3a1c6d4edc746c4be95ba657a14cffe2dca87ead6d3428b47fc1a0d7e137a97e21be97b2a26ab6fc492dfab5bacef765d38d75f269a2180ac6ed732575b80a641afdbe8c64cbb55aaea3ca63b1c747d007c80df1da3e52b4037662d2f94d81464215b71fb735fae194b7a4891d7ab579e2de29bae0c26575b390a972c81299532ef4c5b0624453a4d5fcee9b75c185d158878ea0a68a6eae618501fc85eec39a532aa84f3891ce5f3df3bf8bf7a342f3467ca87fbccfd406f2a75836325affb4cc7a0ce93d92f766cdfbd84a280285c768741ff8e399c348dee306c6092284ae0d858284eb417abd90b2c64b88dcbed5bd16bd5bb0fb949e817dedde7003ee965336083e6767f61f01ee0278a3fceb846a31ddb90a720d43a598d6d82eb97d054eddef227454eabaaa790ee37e0e525e351bd81dab9ddaf3fdc8254218b7bdab120480bc6024d35fb86e8615e03fbb08470cc281ea454e8d95fc9ca5d25fc3cdfe685aba0fcfc9f9621867ea10d7ee080c6e16ce19ad87f0ca49baca1b380ab3acf1dfd98ff9f9cf7d272b2ca6271b31a6c1eb04ca63d084e251e3fd17e23845b67d7177b33e57202571da68347f31988dc8c16257a074dfa6c914cdd6ee0388a1d72419a7a4467136c4d38689891b64be894d381d46856754c6ff6de3a25d501219dc4c03f15c3199736bbaade1e5afede8b75f11ca7110ee6d74b90690e86d45f824c72148b799b3b8936cf1250aab7b0f2d6afe86cd5b4feaff7f8aea8d8a7d26f6ccc6903a4f6226bdd43e6c05e9c583e8e60b0af7d51de9a4a828f2a85d33f5beaeb2660c3852b2f185240e80d847706a133a325268918292054ecc7b4ae3cc83ef8a4decc08cf665b5b4253b56e010c8546b3da33c0d460962ad60bf502bf6592cafef863ca9c9e8b6e455aeead063d4e48a98c5acc7329431d0404594e7d9f5c4dc8fcf77ac8c0c5bae9a3b4ecb5fb0365e193cb79a6ceed759487a973c34937073bc4016225c07ab8ee17b7453797d04ea93c798eb90b480c101e6029bd9ee731bd23e0e1699d754c7533f6d1e21b48b79dbe3ee7a47f05f50cc7337888d15c3d713bdb58a0b82cf562aaf2e818d45fe07636e97b5770405e97ae25d1304cb20c31dae73ef8d8ce3b78d4ad205055fc4a88e714c227abbc78d6e33953e8c43891343bd34e96329094b4b66c055b47f9fa659c7ce384a525209a7bcbde557cf468a50f61abe573c531bb4170046779322e87f18bda139d18d104dd8cf3ed4bd37cd15206b3aa85b6df22dfce4bc5c6d1d52cb302be38a1971ab249e0bff4dc5f6067278cfdc7c880f4b930e002a8f362e5820be65ba9571c00aa7932ccf8632109d2294cad24532f3faf4024f206828be522cd5d585b149cf7fa32545a30a9e2b2a58d0d2ded990425d85a991f4eab8a2336b733f33abfcd2038a18e73f4ef1b68d3937401b8137ab32f06741eb88caa1c442f8e4f4ae6329e8f4692ee094181a2a19acf85122ff6ec2f551db096ddc49f565d2fd1ab8157a54a2411930cb2c764afdbc7de3768ff9df019fe68a56a9a3618101862d1ffbd897e6b918efb438130ac0d2f088bd25814d14858eaf75b5f598e7921374ebffd63ac50018127758b422bd9f665c6d4d693dc4c7b07f056c29c88178f60d818a9871cc83f7716a426b05d3949411ea6845ac9b09afaff2edddd74860ced325de4b5892b4f71b5835c69b5a735a95950144a4d574826a04a348c615f5e67d8723a2e467e2d75ca9e6d15c38cd10fb83200c580584cbcd9ac76dfc2742d2559b5617ce289ec5cfc587e1e5bfc4ee165acbad4b9dc021c831438601779a3ff145e89e7b15818363ca2824396c1ed0dea33c6ba23372f9543a33959ebb950bdbd59bb4d0004bfdd28d33b80f89db5eb52d989b15bb00ede8f1be8ef6b8c08a3513e8e3e8c4c60e81e398313146a32ea51e16e723c01c98563a11d3dbe4296a050dcf2d5098ba2e6ec795324b1403ed0920c6e622a83feb3731349612e7eaf52c3f26e5bcc793c53896fb961cdf795726f0fd71f4f8bb574e53557b5a747ab187b6d6a2f8a53c29a2d17f08aee563f05fd95ee1cee9b7c44e56236d2ddf439f9541045e183a7a52fe14c687855aa9154add0d0e07b6a621b2970dca7cb36051288beb38c197d3fb4cc37aa4d7392b2ce8d02105864d136013e30c5168d3035f68136cde9bcfc63eb5717f319ace8aceb6dc6c27a47ee98ee5ce1f26f2f456d486f6b922da10ce231a9cc5c01a89718fcd3b287c14464a9fe6639bb41f9b3b064836a9f32efb6577396b7da6403394488da398333b0989b6fffe9212f55208f483a06b5aac88604bd5cdb0db4fd0a09be1c5a9e092124cb4004811299b7bb401055300bfa96d07892cc281cea43b504f59b96df28c7b2aae37a2d589012359e6cd9780f162638f3e26d52485978598f28c0fdc062a788878298b12cf93ef4aabb403f8ea31f2a16d4babc5abc06694c7981fe3c9b12a17ae648a085b58b669336dda4fd066678ef61565be5fa815397346bb48172d6f08bbb37b45ea8eb936adb52d7397f2894ac332cfc630bb65d2945ad8717df359eb069bb8b507e56fb83aa9adb34c416f7ca87bb82c79922cf11a70d3141b643f4dfd457fe7e7329e8237d28de9fb6b667a46a498d08b45f76018767b05b5319da00557ea501185c535c9eec85e01fdfbb421e65ff5581f0476731847112a30713b4f1ab4531b1a9f228eccda0b6d115a9c4a0d67beda5d93842b4f21d7a1513ed5c198426b706172e35a57bcee39d9490434e414ac4db6fd49482b0ae2365462c19f235a9eb160cd4f1e876155f8ee2ee726b88d1aeb98de10086ab49c23892643f3e4ca5efa39b74500c02d21acf7fd81b19effee5468786e3e727d8cda465eed33a771f3c09ca22210f7c93141ba0303641480eb7261dd6492a8ada61922830abec4d1ae7c9856892dbe3a5688eb619f7e6e7698eb290eb163ac9d74d3255133df843c4ae8ffc9666491caccf03e22c2980116ae76f91e6703cf6f4611663418d6e84be99ebf9abfaedc2870fe69f9ecca92291f4c6e61171980d2170abeb3a8ea924194e378990de2c6c18df99a436f7164445b645aeb4ad22e82901d1c29a7876234d01b4a0e192b218c38a247b1fd69b8527e9b123af2b9f7dadc4b46a6fa40063d9fadccad94b0b4fee962d324ee09f89890dba7ab1cdb76ece5b0d8b1facde0131a5b4eb52b0d0adfb92aa6e51c5a3e75ff95e0eed000b0f3bf18744367c98c53ae188890b4e4ed31722e960f219bd798d30a50b7c8aab5c9419a61298b688fb7298e3a1d73ccca55b79e42fc17b0d97b48dcc7f2201c6bfb2c067315a8c997458de5b5d8da6e5ed0f107e90e25054543ab04e615a182fbfa49c02b16855fbe8cca5175eca4a64bcad2dc7244867fc977d286ac83d3716ad6fcf6ea67204b39f179999ceb7aade26b38fbb30de43eb69b50ec58b96afb486e24b11ccf62ef30074bad4b5c398d7c2b8e7b18c0359a59c0a6700ee75bb09635b4dfe9a62b7ab8b4d20bb277d5418711d584b285ffa148735befbe78c46f52aebb5cbff6f729189793285ca1b88293375059dae2a639ac75d07dbf1f48429c229cdac2642ed976dd012b2a838a4f5755863dcdce8acb52fa6a30d91c4c9bbf611f6e1879f552967bf587d719a8d32c875351f2b5bed9f9ad073f0b76837520fbc8b3ea953e4b345bb5c10858c6a548eb38fe4ddb21fdf2f4932d7bb3054efb1dc75481b0ff037f7a6178d1ba28ce6495d815a2eb1980c6b2ec725c6402110fba9c832e23228c5cda100e3bc21635ca584e25591de22b22bbd7093e0aaacee8099e68a9e10ca87ca9b6592d5f7be38e1bf33da15d0229abb095fe988ccdb2c63e6e9fdf709d41f2ac231a252b018f648163f8def38c7f6368d035025774ad54cf48be8ee8d60e72590f67c7ebe185a4e0bf1debf19735288c031e3ee367391072ac6a5c16b9d49412715ec5bb114282225a32a3fdbbcfb71fc309846a28cbe7e1d54fafb13d72dc90240448fed1f1274732c0a54aba2985e63c7876bd9679c5c317262cc405c02f31573a98ebf215ea7c05d3f9083512eddb778510df44ec06f582218c01c0c6b256d2576a697c9e6598033da8c716be80c1bb76ba00c0374dee2ca654e9e1c38d1edafd3d7929062ae1506baf87e66a52d20e77df4bcd37dec907158a3abe3c9c4ce878cd1a7dda38df130df5808955dc779ff0c88aa806215ea83c2ded3d52bd226f04d2fe1b24462dc9ee02a15285f7b110b0af7e66c7f78e7fec9942b9ae85c1eabe0844ac83e3f7148e52879e0f4414e47033d0925f1454611d53ea1389997941fd43d44faaf1b5870c969a5c5e1cf06e6b52e75fd7ebd084c5c1a98d708a881408beb19ff432fcbc3e57363b897765c60794afaedb8b8a77c63f27ccda1940b51074ad1b6afed2ebb762f8cfcb20681996d6a04ce540f6a01ab3829193cda86a29ab4f68b86c3a75511dee0db04dea3f57a4701b3e6c79ce18d3192ed331335b4ba793631d24675059ebdb6537e2e48038be50c96e60c6c49092552a5aa3d88f746427300c08be36cc3dc22861537fd28e0551a9fb82b38612df74d20f35966788d9a02b29bd2c14df51d35b7b30ef5187780669dcaa764a17c74aca3c14176e8460de14d8a027695ae3220247fe3574f1b867c33d8db4b90498db756c7daadfd4d4c3deb5560e9ea38b422c3b00df76302d331528a7cc32007b9afb3f6a1e28070a2f4b53eb280019764eac1c459b59e433ba44c9442f0e5c7aa24ea21195ea2e60525b3b1ec0b56a917adc72332763476139a250a7278454dc7b51e179fc69ba3ffaa1607d1ceb306c237845a4e2735ba2442d68d1486989742651796ba7d6873cf0644e4f21b71afba8a971dfcf50f2b1134bf0dcf4dc93f33ef896fa97745c722cf5ef1a3e35f8b960d2f32cefda0412cf4a6661b6375fa22aa005166800f7acb7a51300cb0764854e6c23fa23c2c87fb95a6b00383925a40cd87fec1858d0088b0d9e4aeb03f694230116b293adb6dfdd286f61e33e97d4b93887b660965ee3b1333773d5aae9564a9bf00c216dd720670d254589d476885a8d6913328ce0be2a606fca30dc2a69d3b98e4fa895bd145d83cffa920b44b07d4898181303be3b17d5264fed36a7729be431c49a0cb71b95b3a10709e6e7e58b954de2064759319cd01f5435c17083120877226dc6652cd5894981d50c186842cff0253fb86a785f794ea7d24f4bfc5a67961601d4be9ef210525b15f42304bae2cf9f4473d8a033518fd6388b2356c27af2758741859b8476e1803ee91499a3c8d6c0b72d18366397637413075bab932e3cb1c4caf78f219865788e3f87bca87f30618e0d9c26501dd7d05339a95e37f11d42eaaf291797a1b34de50e8f1c6be727dd693f600d04a73cb8fb8f716cf25ea02380884b6337a3cafbc00879e21b375ae9bb80fa8fdecefaeb971fbe7d970964c3081a3faf59f80889005498973a8851163095d847ce4f91083111209408a008b500c95231e82204784c8feba688220c8156868171f9951acbc86a92a5e8cc09c4285e318fb411c3911172cb7ac98faa05ae1c3fe457d3cb439992a77397b41ebbc7a1e05c7254b591f77530d94f5e4b02b29952bb5581a3322fc0b27adaf3de693e9de0283b17d2babe83624d8922142f13a155782627b0b9bb3a9669c43a9a3984b5a9a9804e96c2d2065415201a5c92720922c7424a0f95040e03a08777f034460bc4210ce0d5068ce8cb3b428d7da693921573804f66dd7992a0f2246cbe2e900e7207b9748a5812041f45f5ec67148e07dcd99da585091a4b26e9434aaa57a1bf43925f1248fb4b93a279148b9e9b24512b21ff2ba3c650bd47340c591d5c56c5aa80e032dea28b649c42c0134bea99af536b2db6010a23c4017fff559fc7dd727494feb8fdddcb987b055d8af79d503aff0e4ef5770bd7fcdad495d28cc1deb6f0708842df7bc92fe1bdab61e8fe3b58c7f1061800b756521ceb6d7ef719fd6dd789508ef351b1533c7e6494a83ba86279e267fdb9a62978afd37c480237d5bff673af13eed07b26337bf763a6a3d3f4e63397f35f677f58e74d90dd8f016d061488cadc9b6c9599133e83e4849f7a8210b5d3ef140e82e68c9f1e19793fa02faedf9619b5343404eab8321b6ec5390f5b4f4c59dc3fbe92f18ae382fb1f68cd11596c0ff3bd0dbebd5f81254c76cf855eeeba467074063712f902c2a235debf6124994d029a3f6d371a098127a47b22c4952219bee821c864daba36826f3786b7c44cacf2f5675f68be1a54aa7c01f1937349bc8a7f36afc6b6046ba3e9534208054daacde3d259d3ad51c5199c0a2ba85c891c6c5270e602718b995fea2212a16ef5e49bc552434aec69027c479838eb36618c1d700aab1461c1e54afc15c19db96852192043002983f2f5ccb0100c3d719bdfd7a6e73408c6fdb19992670161feb41f89635745bf7165ffbb3f4c8c55b570777bc718496382b3c91098667c893134063c001d672d32888769245f5c516d9feb63072415a25264b0131b92d042b61dd159fdbc1672b07b88dfc362ecf35d510f403a2e672dea14adb9b4ca31366c96d65d20975b0d20fc56aad327e7f9e6b66bd2112c199b7677ac94c1f2a19f1c5829bbdcbd3ee8e2c3f174e850f013a764dd3401e30412a545430ce51183b554cd58a6db75975e5762abfac8cee1c6f905c525c96c9fbe6a1c23564487ee3856503018e83e6a14127850af0ef8ffaedfb8c60863d489be9470171beaa50b83f2767c54bc2dd27050fb61bca6b3c504e3bef542d31eb3c7e82081ac812aed3b4d7f37b481051d9bf8a28d767e2b49724f1ca6876c1ae3dd10602c017b35131a3f602fc6ac5e0ea3284b90039d6ec2b4fdb50e8edd5f4a6d5f5b8ac05c8787a87b137d6553f7ef282527779463a36061ecc0b761be5bf8bd0a904aa2e6ba2140acb9660f6d6d0fd2b2942fa9598aba661b99bfec05841498ea1d74c9392b3fd0f3aa1c07e1e82cbc516b6be7d5f979605a3ef29065df1b7c3fae6f1c022ba1fca255564e599fbddfdf4ae9d06185f32fb29ecbf77d6b003becfedcf744882f32a8728ef706ec347d182d9748c4b9c4e4c3b852cb396cb6df9f27c63a9c34ca9bb808028d91e985cae749cc0d24439696399f770c1b65778b4fd71deb65057de0c2f057502fffdde9408c23439b87f24393eef309f51ca094ffa06728632ed7b21dcd1a50a89525d6efc039a82586ae0c22ce79b5834a7fc72b709710410fc656f334596a79b756e24d327ccdf224ee96f8b1e47f6ca89f02d2ac146f0c9d3e2847b9f44864170aff5ea2c2d839a7f523c6b9c014ceef6ab40df85cc8ec7ea6b2d3fd0a6c7e5104a173639aed1fca2f7659858e9fd4153fb974a369ea67f929b2b5aa0a0e883dd40c14107d9dffda9bf9ac2e44f3ac6cb4565ea060afc1c1978e8b672f37b1b82a6ff3b8db074eb271ebe5d6e4d8502b50e6e8c245932f26c0b1c136738b6378e1d1ceda1a83ec2322194dbdd082a0d45f93a96d35f1158965f4a1410d3fb03f3c18d24c2afe21447013fb9fb7b66c7ca82a6e66cb46f773f6a27b094e2c926a824d332828a406621d2f5102bb8605d524450e6a39124f06fb824a5867d411bf880db18412df400415ccdce02a792219e716f3e975f6763ec2f293a2ca25bb53c63632f5925b20425a460422dff73470c36d6b5ed65e7c0603a6ec77225a4b4475b4654340da51f2ca77ce3148beeab39babdf3c94db3803fe80b5c4ed867835ddb7f33351c3f146982d4bd3b35d02b200a77591bdf5ec8e84781a766e0964356d7d8fa8e4238816f9cc08b66383cb5eb4adec3d40d244ebd975ec18fde62c8e505862b8ea6ae864e398173583480448b048a2fc444017915cdba418fa683d5f5d5f7405e7e93f2c9a19550edaa0ad44f14040f476622bbb30dd35369d93112ccfe405dd7867bf777ba4751daff7ff0ae94cf217e0be85dc297d6a81343bc21a2205e0462532d47a422fc44e5fb54e186d1b760db416d0356af7b49f8fec113efcef8448fa2491d70e070c9f4cbabcb9a5acef53f4f165191584ae78813655af4c947a95e996a9ea72137856ca574bc98bb77613bca280378cbbab5e4c5ce685d21be1e2d61ff967698ea5c3eec3a0395891c53b9eb38b47ee2dff3d5658a017d0b4fc143adb748b8691c99ed6f4f243059d06acaa4ecbcec50a9d469c9f4a3f7e1dff17d5f876dab6159cd8b0c7741639d2a582695112b1aeadc891eab50171fb2f4938053b0a1b36f1a9ac7c02a651ce07d0e6a9aa90f814b596ef5239cc854d4a303a5680d1c8472b8d268df770cc3f9bbe29c910038258ba179c409e9606298aabe0438470dfd44eed04f8d1762d9c4be2ba75f245e1b59a63a32b37bbd9f3716fd86ac8d29546d07928c5f3896f3b45fe24016fde047ecf8ab780af00b4b9cd8af0e143d08a10f26b675660671c32b08ebc4db69301b90ee7cbb5e524c730c6a583e3382e16d649ec9f9a2d0121cbee882004af6d3d216bd340ab19e28271283f351be31880eed067d689ca2a48373c7f910ada218f29fab7064224a90faa0f7a51bc2ea2f3d72943444bcc2bb8a2397cfb8db1359866acdad1485b34887f9799b2dfc6a4192a9fd060f47575ab53b158ef9761501f58efc9e7b6f3c3aecdb5c277077df72fa6f63a9370a857fd85049e21ebacb4d261e32bd6ad551f82c9985e2a168342f23aa134bd3afd9365ed76ea1428d52d6022d7d9d794aeb79804921aa191cd6496fc904eacba5c4aedda424d57faeb7ba8516e862629ca41e8b78341f4bffd698447e0e7b9c953900e691be7f6513856a40c3e4c810f6c60d6b4e7a2ddf6ebabe0845267c4fe16e6b0574f91dce7875f1fcecc98f97ab6131866ea36bcce5f059efc9c03abdc875e4521b92516ecb198c2d27d5fd7d322de11d856a8e69dd08f019227df9d10b95d9f7772aa72d1f6cc5837fb9777bebdec885040e48bb1ac9cc0f051f47fee1756e952e1f7ade0a70f21a2634029c62c1ac32fb07562dae51fbe22732fb4ca882c2f23fc6244a9afabf46e6c7c1458121068351371c4dd9784ed7dfb5085f926b517c0334a4a377a341ac400ee25dfba92037761dd13db4c87c99c8cf19c5865766b9aec2d3c3b76d9629e87dcb631a1fe2e4cf017545916ed2f3c375508bda8fb3e07de5c157f3cb2bbbedd928b767f19bff12c1486ec5afa181a5b5f5d899fc5e044422fa0b509013bb64304d0ba190b166541fb7c0986c04f9ce743eb19caa00620c2fc09dae0b533294d722cae3ac7922160ac464acab46395802bc64e02bde4f75a7fee42ca1bccbd2389ff038b31f80068dbe244be18f308125738f48e8e4b05891d3b36e6ba4ac186e73064b6ef7ae71bb9135f416dbb96ae06a154d1f60a1142bd8b5725bebf601f8f3f282b10acc7b19f1701231e261341d05cfb91f8603dccc91caf2ac2754965f8e3d0830f7b7aa65848c94820b322fc4b1ccf0b860bbec3564776e7b7b16c4866a6f8353c6eaaa62c99e6d124ea9fd79a39bc608088b8a9676bfc7e1f6364123f32142fbc90be316f23a810d257ab9f838a2545ebd28d9c228b3ddbf8d020dbbd286e390761ff0161ad33dfd0ab5b097a4ba9fc10ed995c6b7ebcafc5a5656eaf5de011c97aebf9dd7e386fc77ddd12a20dcd8a176ff8869ec09490490b5fa1d6901da02830e1ce75b11f28b37445e01748e2f4fb410dbd9ff65076e433d905bebc59b792a12959f8ba4de10b37f4cc679e385f9c8fd5cc543b7f08aa01631849e03e7b0191f41581456258f2994d7546745044d2f32c0100762672763c63d8402ec558c09b6f9399b4a2ed824378353af352507a7c216036217a0dce71900c929bb923525f4b0b827a652a0bffa3897c1a23c874ce2350ae30284b9fec994400b1bebde50dac4fd672aa0bb0c988d07567531e0b35f16760e7d8843aa9ed690f2488201e1e2a6022d5bc6c94b6e298327e0cb5f38f10d4fbc71608c49d5febd15b174c712b1444824811224a7fd419fcee11b43e859862d83d4fac4349e5dfa07a2d58e1b517bc272954bd70f4d106f2770b19b6e80ff4843cec25a789da8b51e7fbaf3698adc892c7dd10206240edaf1209737ece1cf0de73fdd36ed9cdf7ab29c136a50ed4a53a965480a23a064321ab83c755d9ef18490bd37b2851347fe471351f7ef3d51a8992f78a78675f4a641cc50b5d74d8c1558fb7daf45860b85f9564c826d2cd8c74982ebeb574ec10f5dc26cdbef6faddc9e7895b922a5526fe888b54b959a98c7d0a5ff45b99394fd7b048b26ced6eb04254ecb2243d8db3af14a476a82858bcf84dc5ebef6740146cd9b6d2c4d37521c8dceee3956ea648fc7260394c201eb8a6bd3f3513f9123baa230848a9f9a0cf84f66498c11daa46aa6be5c3df8d824dc385bbf6ca8cf8a5deb00ed8448130cded44e56345f6ffdfbb7ae7b5597131e861b0db2aebf653c814da0a974df82238ce0f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
