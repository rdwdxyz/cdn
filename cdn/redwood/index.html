<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"743067d4407771812acfe0ce62ecae6b04e034415d58e021caea1e7d203e6d29617687df5e50011caa42f1b0c09bddf58bd2c4194e9434ca7f770d803491270a9ad9ae52173f13b46d9c5f52183207d1bdaad3fe2f6125aa7d02b02f283ba047faa26332140b4bb0051f196806ea6281f41c47bf4e898c99d9178feaeb5b5d84972ad83ad1728bfe6c987dbc65b9ca2531beca2dad24ebda11feeb1f6fedad687eb41ab0382ab869801b053b28c261887813c61f7492470f41d2c20d45f0209654f33ac96088608745f3561aee86d4d7c4606f663edc14c43f6901a43ba2d3bc5d225e66a4dfaf7be4e5b72f2c22d6fb11372d56857fbda1760142bbbe0b3a98fe91de3990269049abdaba02cf91518cf88e7369862c04b904fcd16298330906f0c74311eb4ec3b0e973a1747f797699322dfc5b51a66da8c76e7b5e1db58f5b7edf173a467d26f72219b73b9d4fd0adde027b739ea366a6453b4fb89d77846e5ea3834c1ab41c33951fe3e5196f7a19bc25a1cbb4beb2baba511d6e61e8b82aa4be874723a7941a6b10110a87634d63f710a432e604aa5db714331bba5014916cf67b0b8439947b7a4be1def9edaf70b85c1e3b7a63dc8b498b3f1f31460338c92b5ef01a2bea301431b8f9569cd5863d05ccb9d04a64687dbcd251ae0c29aaa8344c0f83320a743d91ae513dee1259b6c15454e1cbf155b68f8f3453fc2c82f5207219ac7aba76a5e26a7945e76aa08c660e9a23f40b70d1e43f550ec7a09fcbd55aec1dea5f426a49a8767a5fa526342c4c6f50a89ff5ad4b1bccc72d3b09ba8826fdbd99fdf1afa3be69928c1d14598a19a869c075ea415e0b1717b891fb383e3f46a34c0273c8de8033600b9819aebdcee53953fc790aea99218de51435bd18df4a9a90db2602a14d5e370e8d81c0ff0c167d78e0419ebafe6e0cfe162b95899ba519fb0d9d73c22cf06038ce26e74e2ae0e4c0f3bc9cda0bd9fdfead901a246b5ea88de6710378361b6dc298b1bf2d797e9e2ebf542ae486152a12f1c553f9cd77271a2cff54ccbe5f7f950cd942de18dc40b8ddb78b224627911153d8174edd9977c72003dd44cdc6a3d5a06b7164b4c4d889bac0c431f8362e384098cce6b66ca4812b5f3180578b994a0f43f09cf3b5c0171eb08dfe52774a116f91a006667360a66d6f6144be3d9f0b44f30208f3fa56d0ad6b4bd4c3a0854e8c9e094d6e54fcc44daf3d6c19820fa5a41dc84e47c703022f6ef0ecc95902a44365f26c7d8c2b78e6b0042523f7358ac93242eb205068e902e5332a199a4d92654b315bcfff3cda64a70014fd21645446a5f805e097746e373fe7611ed3caddd36123d80cf22470a6c52fada016fe2f56d9e8e3553504035d406095e99b77a35cf13fbb5abd7e0ddcfeb778e31b53dbd396b5ffe7e3c040d67a29407e59d48048adfcd82177ddd11d12da8786e6cca7e57d151a89ad0fb124424c1dafb860044c8f307d5aaa86b9a67c99b1cd54050cf5a005105e945b6e70889dc109cd8e9c71fd90f5f8a9f922fe289005818babdba9378e539c98c82593f27f57fe4c198d776fc474c451f8a0bc54e3827474c47042661d31f22a78c182df15c0af91196ec01e9af0e786493a3bebef4e62347af8a495c744c15f4ca4e560d79ff735171ed4ec8741e69d5b18d405204585c70e63f8580bc34d54bc6284328873749c87ae7e1293e2fb5b8567bf04723ec816eab63bec7fdd51916cee4410c7e4065f11dbf68970ae4efa3f9f3b87a1738ac4b5544107550aabe05d947205cb4d4d835db5671db4e18a34d9dfae19f6482f65311aab4da5102969ce668b48492848b95fa2e3e825bb439f55533b5be50effa29aa6b4566e00892e7d01896fdf4cbf5a67500c4d65878281874dc1f274eaddd9cd98499547d61ea5cb74eb1fbd66b34c7dace06c19b5e0444f23272c00de403cc6c359fcc637c1ecbd1727ece997ca6fc3a926ab764071662eb0494fbdfdddd623bb1e9664d40dbf6294f8f1249505164b06007c36f2aabeb05767fbeb1c1c8ffbdf9b075271896ecd4a30a5c2bfc0b9d1624814a5aa23d50432e60d69a15f76d3f50a3ca9b5c118c2e2df5ac91edd12884788fdd6d8cb579978a72c7d3ff0aab798401235d85822dcf3fe8bce42a8bd903bc863dbb6442c039a95bdd6a6cf14b6b96ce3a21559e789152b3b5a7a1776f0730f07406e91a54b93985828c80608d80fbe8c4ce9116a205fe9436b2eb820cb3e2f404d1eafcb719cd368f2263032b6e5c1d242cea1bb24c9864c047084dcb08d0e20860ae9fcbc17d327c6f470ffea499d4a9c70e1587e069b9b4f7eae5d00d6ef3ab3861a41e9fc2897f113d247d8794ab7b5009d8a9b04963a3ec9a772f9add2144740bef74fc0e2a6dc2c40c588dd0a4295acd7c464915dc3e94dda8929854439bb80ab4b83ea0d0d83c130afef7e044f972814c7feacb743e29fbba879518ec93728a064913f41fad86808b2c5a31321954550f009f0020a61d1741820aeaffc9e21082449025ca5aebbe2ba6ae7b601be5c113dc8c79410b3a1ecdf11c1bfb15d676c2aae1b2fcf7038863e8a0338e2d00c0a7b9eabd46ad9aeb25054c909d7d7bd5ebf3f897c7d9910f25138c04251ecab5036e33c74e26eab4d51ec330441778f90f6fe64ca46cda6ad94fdc4435ceee0fb1629d59baf85d1993d1e88a236a13a0a0edf2173483642164bf0aa041fc199cf961b58ed3cf9b055117e14eda52d3af59278254157ef42610c8867cff43feb51bd38e9ad09c5fb306d30e1388a78fe0db29b84df68c1da9d96e42193e10511eddfa78c778c67da13a649ab97b2ec47949532a359baa96da78f44c0ab89bb7362ec0edb5001b00e736ed40dd12d402da559febe4a45aa4935548f3e5d6dc6363fef12e8a670607bb8fa74a743f45f83732adb004150c6e894f0b73f6164ccd0bf55f0a9666df611320569666fca50ed96ea99303b0202b64badd034c542f4003f41320a973610c5f8f70fd99dd100963d25b479171088eccbb48e10f422314397b8d57207bc823fc85f142c8351bb42626d609a85740e3432af27338e3c073641fac31e5e81637ff60d538f4c908fbcd12bede7bcd7cb7899d5246dfcc91a98d81906c53307c7bfb117b296b51632c9e3b260dacee5ea0f8e7ce255c3a730765027fdf1c13f36738ca0cac490d554558f3ae4adaf35f5c90937fb27bf9aedb26274a8b2b0e6e796f08db2e4c33df207fb1d3b25fcd51c012415a896c67c9991e719c4f21617012b46e7daa706d2429208420582ca68c5ff7e5539fcc3493e97ed3b8bf4efdb7c8c38c4e59b1a5662d484a457b9c0954ca16522054d3f025ad32ccfc63c734abfe240ac60aae1172c89f72942e41d8b6931c36875aebbf1aae4722f7918bbb5ef01b93ccd8ea7e606d703dbcec030382921963690344ecb59aa2eba74d07acdd6074c463e526a52e7c4ca7bbe3ac0481f6fdaa950cbc6831efd7e28cd5d63d2a6923461612ef5552422945ae6a17ecb1c1770c06c5e1793ce651f6d8a916ac7bd8b2730bd5d7bc6aa7080bd82f1da8a359f436e844ac8379b54ef06cd8432e6c9a208c53cac601035ba61cde9334c9a6d904ef7ebcc7188eee32036263cd83efed71876f54d1fb2a5f09d7efe49a4f63c414566faceb9a9b154c06afba366099a4d0d206b7e8f41f67b896006f2c5b0214862176586c84868183d68eb1a7653cab9dadb4a9ce7f5c9eb567987b795c1e9a6fb47de05eaf0b0f0e02164be8e2c02485090716ea0021f786755ab587021fab5597c5b0375b3808c2617f21d67afc706c057e29f874de8abe67d8e9514feaaa33836d58b80aa32c2e91f7c70a550bc11dac61bda31ea171454dc35631a052697bed46310bb0a44e2a503bfe40809371104e2338975ab2ef21004a7e291009c4e2aec1bf10b31ccb9cb53dfb830d0100b4bb180b2e2c0adf596731cf5e0442b693de57098622a5ecb92aa86cc480da1f595f9eed55630fd730e358fa3cf3bad4eaaeee9a6e4963adaee0602dd107b37119f512bf0e3559be9fb971163f1493742856b619f4f2d4419156eabc4f0c1afabe1a80a34682acf3dd53289bac54c8bfbf3a27ddfb419e58882c5c8f16ffe9ab9ce1da421c1ac22ff7700c95a66934e4b17a8e8a8bc7ad61c08e555a1685634ac4f408c83a3fdff5cf8b0dc081f695ca9ade8b535f59a00888043e33c11384ef4a6a227ae4fbf96943bc2d519f081b7ac5adfb4b4e3c0a8419741483d714947b6d706e62ca6acf4e2844519ac8969cba8d24688063cbe783a26033adec0e28d25833393d70d9e81625bdebfc3f78f17816ec3e64b9868e3e5a0fb0dc18418edfb967789cf6f0225836e4d0fd93dee931424582e03afb3b2fa75864753d8860fe7847ff1e16c86ddeadde14355e4cd4868af34b4856dffcbd3a3d7acf334984a681d45a4b580b673eb30add624e54547dba7119c128dbb00494887038223093d6789c6e01c5c83f1e475a4f32d07f2ca9e7db6c2324b59e3abc342d3994696dceb396ffe21b9bc3f526afaa7181e97d143df7dd920075144f9d21abeebd728e8af78c19eab09bc96536525f10de2f984d060a95524f15f00770e4e705c06f58d0547af20058e26d315021aebdf1b26d5cb598fc533d1dfefeb1aadd007d0ea7d565e404fe6b87735b9ebfe184ec306757ccafa6aa9bf526aecdfb7acfcd79575a1b47372058ad64f8e37a9aaacc04a3581b53746fb4d5f514fe0ecc05b5b916b7ca0d345cb968e3682c4444932a8680bbf6092aea0a5921b0639d48b722cba9b22e345f09307e177c2c0f5ccb3daf3c4bb4531424e0e2d1398ca9a9f1478c00d77f7daf1eeb83871a071184f8646f8e7cbe9083817f7d77da628db21cdd9733e0b2fb46bd839b0c328f995fd2027fd7768ba83ec953e2c6ef650fa4586cd376189b5e198005dc2eaa12959e03092e5763d66220b0772ce62f4eb4e655c4bc3e823e1162126dbba3e1508ebeb392aeed8a9a8e8e8274ac87153005a6ad18b969a3d78244abf70264feaa9fe7530181801d7fc7e7c5daf0a02b3afed453f098325c48ee45aa81e91788a4a53677c486a98589dd1dc2f54b66c21528f93ddd701622a7da379c82c72ecd8753553162a9d18a89ad0a26fa28f7aa794f9ff8cb73866d60a2d364db3309d6945825ab932f48abc94deb3cf1a3b54ad3a246691cc2b7f9fc5235917cb617c4db6fcd31fe57cc8e1f43ca381b91de3cd6310718f50b57ad9160c1b8c3c5e7325980e1949de7434b4e113abe3b7c29ae70a80c9c0829348f75c0a1aeaf2b21c1d3c59e4cc7ac5ee38f4d9da2b2a4c168214be674ba9754cb606cb28ff56da65c809244421c2d56390de1444e28835df05eaa4371c72b58b39c4a5fcd9dd058e78925d8c9782a973409d257a58df40a55b94d5d60cffa74285e2ca2d93e31e8130fa24b5091811dceaa081cd709eb120114091a8ae28163c29121271f67e4706f4fdf16d6b8a71059dd4973b9c197cbd234ed203ef7d16d7ec6fa622f598d0c950df1bfd01ff75f3408372d3b9ac2996065a50d718488084cf5dc653e2c68afe33010f2b6ecc6991bc2777b8b65bc96c52e3b30dd0f6235b176839bc20b385a6f5068928809c40c7c4a7abe4a915a312f6ddad4f75cef2aab1549ef25d71b642ddc9f4be733873f9ca0071235afcbdbd6171535ce8ed249cfd4de565a4d7bfa01c4a4e1d570f75f54c2205c7c0b819622575785a5311b26892d21122663f980cfb157d5553c5b59481773ba9c653246152d8f56b6a696ba2a63d06cc02eaf32e27d6889430e1b26c3b66ea9b009625d5f2678e2482b2f3765214945e5072ef9e99192188f134c1cf3c3ad851e4ffe955fe25bf6310d2160d6d9f56f464bcc4c5f1e70bfe73e8ad86d80d63de68c3c12798e425fa6a58f59f1b181ef78f22aa75d86bf0680efea9c3488b9d5192ad236400872a43ec9a904ba8184e40a04fbcfa3a365d2eed9be4a737db84c5984da3d80f994e62642ecbdf0cacb1c98f26c82287b9f451800ccea8cf7386d556dcc1ff37af07ecc0e773e5f75161e39045042508fdb752c92568ca4bc9d39c125410d495fc9282b408fd5a758b900a44ae3f67c844d4ddba33f12263ed67b835a837ced8385d46d782b996360b409adcb1f0605840c4076d2b8cd8e986be47c786e84228bd6618646a58db10762676e583c22debee3c18ae12fa12c15a4a016d5d00b7aad474a9c9ecd20efa4bb5937aae05d264934775c54a06a87bc4db2b43e5ce5b89fbc4f3e5c253aae098581e15e08a8a84dc3909a616cdd1120088739e6675ab7f34e5facb74b55db70cb88f62e9693c659f199e280a3cfa0ffb5ebf11cb24662a1482211187399e9c779ca1de6900abfc7578b38d6229f640ac7e6fe2cb92d0e41bd44963060cf095eceb21616bf982599cef8a3ca93a9e303d2dd2b95f489f594d16fcc0e344a4880395c2c7c0ba7f9a394bc4cef6b5aa03c8159596c5e5f9ecca0c3a6e13f873606b891cfc7fa3bf5110170927427656ce51ffdc530efdbd83d31bd7a928c90b7b204f70aaae67b72cae3748ec6b367a338826b98aef63f39588eddd4c6759094c002380c6ef2a8e3fd886aa069511acd987cef049fbb6ecfdc2f9d4c6e3cd4ea29844d5758d9eef4d52113f8948acad3ac718a56b6583cc4b87d59d482c415ddee97b805f964022e23fa3642e04cbda2ab6fd4ad591e1ca4d68c82d9a67fde1952db06d299a00b3c4eff52f6cc3d39895d6bf23e72bddef64fdb5069f86e303d28f8d200ea8fd97b2c6e221cc0c7efb9e3e2f0d517eddc4c78b5b9f10d64fb61d04281d9429bbc7cff613e713f519de783ba45f7b362bf769672fde59975d1aba535774fb9327f50cb3061c2a2dd43eaa5e3685da1e4f0f48a2cc5c46754667258d5ecf904f4096fd1e1eb22dc1051a30c4a1eb527cab9b438d870a85baacbdf713356fcd6ae7487e2294c13ead449d428a6712a6546f2c10a94e2b4f6d38b37dee5228ae7bbda6ff71f9369287db1aeed5d1fd0f29ecdad41f34fc33fd3463d7ae43f4b5ef2b6d4b156e28abc990b210eb2868211ae1e0d2d24eb1fa984e37cc2ccf9cbdb21821baccff3cd662bbb028967014e84a3aa5280416c84d56dee2480890b2b35ea12ad78d161139d832dc95d12349ae778f472932ecbddc5b1c3b61c687b5c58e5e38af5f0c5b20bf0f803b9a7aef1f55314edbcc26b31e96617ae8e962f5d4e1fcc3ddde30554007d97b1581306c85bce30f9ede3ffe11422095ebc654988a000ec0a67178b311d19566a1b459fc019f577ed9d6a934c0621b3343affbb819a1ae20f089445f3e13d81c8a29ea2f79c9062482e024f474ec2064ca4b7b27810e504b19d0872b04633deb320e5269374715aa75a8bbf54073cb310ac65db516c9c2cbb69dcfd4414d4e3c9f04d05d31d177f394e2dcb286d5221dea6214a9f548b1ee258293a71ed78487d0a498c916371c57f79536baf518f4619b9ad783d77d60acd2a10e3d5574993a6699b49595795d9a370d23fddbda7d54dd31f6de55d335f467a69f0bfed84425a03fa834a9eb7f5b5cfbc2e0d82212d488fc93b312795a42f3e6126140b27dea4d30389a902aa062b2a957858b6dedd5c84319c15ca1a293a2b6b1f0c2eedc666bf2ee41a32d74063d7ac974835e6516e532b5eb40fbf994b2d95af3c5fc2f9158e606e6807bf40cadcdd7fbd1ce2926014355def74ab6ea3ad32892faeb18e98bef4a16eccd2bdf21b17b9b0789ed1c8ecfe290a2e42923a46c0c30add7bd4ec36911c241bafcc084ec3707d077794a8dd4cc7bca7a02ad190328e1315de930df3f775c56e6c1bd56d57d0538569327e5c40ef9e076f63151865906398d2f36b526d219122ceda24e2643053da9db34ed196b0f957084e74824e1a5adaea1a32bb604e280d7325083264bfe9d60acc10e1a0bf747a1b7f93c60841ec46123259e9c0b59d945cf0fc9d56a92c850bfaa9b1718f67d1f70de29e58bae9acc6f302c4e81726ce609eb832bb2655530a54118c650d994151b066d0ed12519c134e4f15be50cc86ed7bf7f7a2437939ce6383e146e8317f10526e58b86faeaa23f4ef324f6d0ff98f66e80125b8164925a3b254d845860cafd518fcfc97ccb07859759f765e6bdec3cac81d4d33796ab038d7db2585c02cb770db65796ecf38f93379dac0cd05d3d48c5c81e461d29d3cb083eec43c426081d67cc5b07cb667ea8fe32391212e6691bb70b862b01838d7881748fb2d29f30bb512aec0da98953ddfebf7382356961e3b12178e31555a96e5bbc4a6651b32b2f94865191b69a13d21f6e0336ba297057729370c9600220d18dd71e05df86bec7b7c257b6caa49229a667e064db5eed5c1cda12bf6bdae4c4c4110bfb20b733927c395eb012d9f04d71a885a8ad4621ba7a010e82b78eccfd6a3f9a790dcd7ea35545dacdbf6e2453461302734fbf55616d95443726e10ea9bb82e6040a5fdbcb6ba2acaeaacc982273e46d8b020267683907509beef4caaa041d0c6e5122762bb4975fba99b8db0d44c246ee3748125d8a3f20fe428e7afe7c58aeb453cb87659e6ec79cd44f8b04e6d6d4bf5d435a9508169e44042b834677bbac5b3ea7f29a6215d432d94b7078ee17bbb29f7d07cf1a1fc89fad7311d087f9520e5e6a14c05ecdbcb730673bf96ac3bd29c4564cda62aaebc4f809a9e73566aba2ae9018d8d85e145951f5d57313c9e48958c318b9d2301a65064069284c51c8cf3931e814123d6c7a0b380085c280073b8862426b8230b4df1d5a6c40e5902c32cb9d479611fe6adf1f60e3d062eec33d001b090c40b49109e4748b620d8e5a0bf672f47f3e9043a35a3e17d8066447c086e0afcc9c0af45c61d82367845092affb1236832328b0570a2f5dcbde6b29c8bea59d01b8bd3f10bef2345ffad878a48c4acbf6f8e9e6c30d2361cabaf8e15c8cff3c392bfa7bf03256781f3d94f5ae72ffb49cc781f3cc0bf2d53fb66172f5e064a26c7192d1e625c5464e825e230a20197677d8331039337bc36d65b06812230c92ad549b61f8743eb4d3d2d707bfe9685bdbb88c976e3a8c176a5a97547ddfad497624c96905634540f6e8d56ce17e05f603b2babef407ad6eb58dc87e1ae2cb1ad4d7a39c68304f5b3c632095e675ce269505fbd74f721304eb64af665919f72b9939c99467151a389a0e4afe11fbb46d61e0626548fd344a57c52f098db234bae62af8f8801c2a6d215dff8cc78049b904a3bf7c60f3ad99120d49e2815c2e18665cc727651985d02a71a6970b5572d61f57fd771a1c5faf86c806b4ba1018528f3f964845affe872324485d6c87731a67e2d7d69358dcc56c2120e0cb64181e75465d205ddc96b18d496596e6171dbb89aff340f0ba6afcf9401314ff261836e16bb9e0ce58f1414e5f10d27bb9adf7509d4642d0c0f08fca4cd0824a207583afd786a6dba1716d2c5f81446eced92f38c6d29ce2a77e7d87cf584a97f709eccb42a5dfa91766281ed19ca53b644eedd255b55693ca1e7ace02e640cd8223561ae52a0a01aad8e3144b6b80606a3dc707492080c41ee97c2146208c6f6dc05a30e9e84dd42dbca979074d8b1159e8f2a71e6514e9c4502f2cad18d11291d75b6a8dd3c1031ae3a04d71d18a2c06a433cb5a4b1714caa17cc45b104be3172b8fd95018dd776da8097517ee70689e7be44c7c10963e9a035f6d541857df612123089841bfb1ca497178fa200a2ae1678c69a7c929c2861066d01a5d4da1d59e3e7f79ce5a2168933d42d2ac3a9aee25aa44cbc706795149809995f75368d9f4dd3b91f3440893b7fb6a55994fcea2a3f6538ceacf5156560a4fc7e2c5f2164f62590c1d4af8454413e3d4a0d01f1d70c0ccec449d243805d6edd6358d4da9a5729a69bb7b76e9ff0579a39c1281ae9d7e1aec4aa40fce84450465ecd6612471b3509ab8534473d911526b6baba1d51d9d718de357ba9344dbded3d896cfe826f44bb738f3c312ad6fa61473ff9f6ac5913e40fd8a1404b1d2448c0be67c76b3eda646fd37b758376964d97cde6cbb410b1060c46ab94b67a3cdd4a8b5cb912d55f32c533b316767da2893396aba5dccc03cb4d5325e420d21d8c1bd1a59130854d6a897999b119416cc30ab391ba5e26e52434c2b7a2c77fc9455b0d3f98d9825a790b7a5cb9e56b45e273f4832556204b95c32896196dd9330ccb8534ec632edaee0d59190a4bc907e42914eea3a0a15a6e34b599b92141110d2536a8601a8939ed7f1b0490362828d7f08c23740b4373b099d94743f9f633d05ee5d68ca6ab1321e97ade9786754dbb3e9c8ffe28c1f646532f477f1d5fadb9ebced98625810a4c5bd04b12a7d56101fd3c651a049f4898ca45520cad1975f8bee1c5a684695a13d2779197bf36812882aab402b758aea781c3bf036a1076db67fb9686fe5059193682c0469e1d7835053b50923f465184aae34a903d825a8d82c12df12e2047ca2452b69257c39776394e8f9ed393e2c5c70a5418fcb7b6609bd961915a44fa09ef3e0a4ba9011cfc6e02c4fcaadc0642ef34367467c14386bde4252eb9200c6d76dfe5cebbf2a6e5547d49d73244e049a2562cc83b65292b55a7500585c346086fef4edf36a40ebc536d1cb4f8e9b5e9ce927b14d01f9b93885ac03c85f16ddee87231d2bad3d589318d598a8436df177d5e167abac1c34b825a983d24fae8f9a7c3a729834bd9e97bd46572416deb129dd7491805d54034c2d0c8be78eaf25955ffab09518b49f04079187a7cae5b94594adabc1d350ef4fd7cc140b67fc54884048bca6f119841b66cba845ecb9c22df66202dbff6cf1a434675cca0e920852e52ee692eccbc2873b1c4097320a3f967745ec4d6f9fbb82f183dbaef510cc9345a0585f81211e47a0ff20a7d6c936a743a123df37a09e73f9091c9d403e4ba49e851b7e03d67a5eeb4fdd1c0ab7cad74514b702b8d6034478aa7328fa986839f293ba50226aea61a4d3ccd31ee61a55bb443d7ee64849316991df211cd27462c2c5e0bdc7680003386d44c1593231dc0af1890d1257494d4e16b27851530b344dfeca4d7f9b1a972473cf1693a1012fa10ebeeb00342bdb21d2349f0e81aedb8fa602c847d093819a6c6115472d4aae75274005ee13a8928a243de0cf6726f8bf0e3509d7e2fdb635a549912213410c9aa354583542bae6dd745348c240c4df17f23919f756be960bf030495e5f512cb692438fde3bbc7f6899c4f192aa113869d56b13b68eb5d51bd08ce453b2071c42d3e500807ab8bdcd9c0049da98df811d613c40ebfe005ae29918df89d02eca8c2961bf97618fff47f6c00eac7949f112f065c4dde0cffa59b231f20ad1ffd8823b5089404c767869842a557e49e5aa2345de672b8a728d659947fea93fee4272903bb608508b33775eab497fd8733fa7a1e211e29913a23bcf48431db9bdde81a918a12c21f524c6eef2c5588591400774c42abc002f5e1d6379adb66e617bdc4c354cf527586211a0eada8d31685948095876fea4e56f5cedba10b281fa811019a6e36b25cca75e8a93521469d8e551607dd949b4233caa6fb40585eb69d129d51702b73011925843e93c9f0dce58214bca039ef709e9bcde3e35403b6d71d979ed8bd4689e9ed035f3107e0de408824ede1b95ee071c61ef91b1bc56c1e15739f757ba7c5dddaa2d0365497cee141050d46308141c62464d6fa494a85687dafe03fe2e79b272664b5fc37b8e6f12e13efec8c0c128305bebc71e55e550d41fa3e79f271634a4b06040d23efef69fde25480b6a47a883c4c39653d706a919cf07c2b71fc91c6f323ef902ba54d2e5ec41475650b6d8390fb8f38bff029599314cc6ab36549118497838d58fe9fd0d1f37da97526cd6e9715c6982de320fef5cd1a3ccea903d5f6a3f6a08674bf0c75ff662ad0536b36d37be1f9885448c634515bee0d0d3e49d827e62772774bfec1ccb0c6da29c8d72c238bb75dd204db9f1405d35c95fac4930f1f9ced5d61ff793e5b0f5394ea4e29a9debf0f52386da68b4e744eabd081d18883e7d4c0b2b37157758ca2aa4459c215eb04bb161b6a141a1f293c8e44b7ac45b1bc297c3d8039ed3a849255dfd3b5b28044fbf94f2ff1f06c5dad28131efe622be510ea6bc97d86a0af6b60db1e0e68dc7dccba92dc635cba584bac6e3f7933f0ee43f7b223cd349bd0cb64f3f6df91f243bfb2f19a79d8b3cf2d2aa7cd81edde13b772f9223885b101b800422319d7fa58a83da607f1f5025db622e411380d2c7d71b1a0ed3d67e64d11a039712962d374a80cd74457e9d2060b008e307bbbe94a73b8b8998cf75966888391a1959f753d64e31b7629cb1995d429cf30f69a55e5d70b7d1add9a9d34f9b19328ffec5443f7ee8f2e7f45b797ae0ea84b642c8d90a0fda87ee1502149959152efa93217a656acf5c0ce453a629cd1a9b6df09d0afba5f0cc84998450ee7abf3c45cfd20cf98f34f2782dd5f384950e2b36252c9c0dd35ed364f475d11c7f19e2a1aef6a3f63dac4d7e1d5e121a8b301bea303d0611c33bb6800736a8de08e33ec3a38b121eade268610e2b52745b2343c1e9960c0da78a1532fe2d35ff9abcdcda9817b1671a60fcede951f868c4e94cca4cfc58b6c0248c9373f47dcff036f98bf4b077060519a288843397425070530d7025faca07a513b41b24ee9a9469430a23d2acfa3cace53163519077501466182cc8e915d14a3cafe751d93044bb811940c25d74aaa992df280287bf173a6e892110528791323b91b5e160cc6bd10b0e7cfd5e79bb6d7cb282ef2dbbd6ec1ae9e83501d75e29636670ebbdfb096d4d7a3ae1f09e9253d27bca48da052fd6d37a5981befaafc69512ac2fe38108da723d1a705c7d3d380658cdb85dcbc38606beb5778c73af7518cdfb70a9a9a20e691ec4ac60f12c96448860ed0abb4c15cbfcd3719254b07e029de6ba23ce72cc7c32777a908d4b5521666f87dcc1b2f8fd40c3fc24b0605d7f97b6c180b292862805b48d73d14701bc2b76765de310c6676c462e9af7291d2d4a65e129a12a8780669abef06b28a5ecacc8d2aa8355a642d890c8c9286f4933d88de061aa195de95c46af26a400ebb6a0d802203f2774e2b3735a169af6c215d3ef839fb8519f2781dfdbdf3d08c6a86990f7dc81e95f935ee8d105c39b8c4a1ac21eb8fac57fc958ae84ea77d9bd04406b9a11f275674dab17c801ea877c588725d8710f178d3d978fe54c01ef1bb1db0c08965cfc833c97f24e5b578845a9a24aa308dc16c70fe2ee234a63e4587ad2a14ced9348c253c5e80ca1f9d7f174c23a09d66234a72a9fbbf0cdd1a4428c7258726731344728b323b78095dee1fa0c63e6010a891ccaad21b8ffb6fb3c65fb25e675d3b34cb0475711c6d6b32f1db546e5a3919c044162a978d126ac7e4b87ea1cda4762d2723b3f8c0caba0fffc7d4e63c5ab0926a06dff7a516cb8a44caa2aafbf7492972be3d4eed04ed3cfca6718a412675d7a4da5ef08ade4bd9c697605654f4309969961c6aa71b3e43111b8f37cab208df10e6081d038ddc10e6224845d744d39937c8edd932441103820362666512549e59a92fc6e85ae32b6c9f19c6adb32da14a3909b657e5768c0cf60661ef7dd3427ab13394f72e2b77bf23c41795cebd3cda99393fd6991a672d32bddd6d6e1ec45f1d7481b3c0bc47aee3b5b8d8e4d70b2dca9c81f64013968a9711b3d61053b045d4a52ae0502c51ed911fbf47001366970e07d25d2c01ce0cbd74171988b9f669988107554118adfb6e057c8c8def1bfec515d8537ddf69fa33ed66fcd453a8e4415679de4b82a3c823160bd4ddc5158c1f9b57ea1f5a1736b7bb3deae15e13e499aca278d1469f194d98fb68ca26f491e61dde0211ee6fd263a48e3d736b51cbcb308b9f54d5a961763367a0348328fb8534c79de3a86d7c61e5b1b49493397e6dd9fc0820b44d6946b92bce6d6114c606f11e5e69dc59807904019f8bae24ccb1de7353a4778f1f2d61db591b20e6ae3ce04009c607a7a61c632f4abb42cae50a7f5fc6fd6d42142c49ae625fbc5902087cf84def833da4cb45028c4bb675936679fe093df464b131b4e35e4d914d919f5ed93b9872c7f90af2fc23474fe75e2f39a97d9a9fc9e1a75edf7e25fa214796d6a147d1a26cbb260bf8e63a056022b315a442e518e496e72c31bec2867f7ae6d9300dc6794abec40b088128dbcae2b1eba42fc505017f0808a66bfbe23dce13584472db7a47b99ed24c6ad8763f23d2cb0b1b58d80621b7e593067e6852a8075b524c11eb2bdc920e50003caddc14ed312d596cad531a599db6b3d8157f4016b9dde09c08c14bc387c3ff521dc8ff8f54d471c01bdf2ef794adad1bbafe33ed29fa3a9b1fe1cd7356627dae06cac6dfed8f288e2b88b447f5b82e73cd7e20e198714a3407b6cb4ef690de16b844edb76698a4df878d3dc0f5ca8b8aa2d2c3bb95f6ab76a08cf21836c9b14f2989bae27ace5269950572b985bc5f8ad47c9a0f0065162e6cc4f56037cb57c7c122b5ce1a2f9fa7704f84ee31d9b32a57905cc9fa1fd9364e29c7066ed7bd9479373f05a694d2335b0a21bab4d2051ea7bb834616f37ee0d1fdcb14ca3d5ac65b004821fa7388f3cb5080e0ea7230a536603d1dc109fe3fbb5bba87021abfce6c24fceca0912b3382c4dce0b7337ed47e23f72807ef364e4cf49689011623e08da4debdee4f349422e5100e504e1b2462adb59e3fedb8e83e949fb981a5cd36091dd3d7ebfa7c487521082055384f7632fae9c9725a614019c861c86063931966abd3564df798174c3b1d1043e582977bcf39850aeb55f134e5193ea0478b14dbc02da5e4f5ef4b98e37f25e3466faf48e9ee8729541096556d03fdcd6d258cd8e3f3e5740384724a8b69a3c2b890a76e8bde3788a93bdd7e4ec2b1dafddcf16b77897daf146e7f9069c7d0709bcfa183ac3151de096489a2e5de2dd6522bf57902bb04567413b9edc09e3d5f2871b519815b6e604950bdbdbcc39803ceddc908d10bb4199d88c34e019216fb51c6b03e2dca6899cf028929a58a155a9a06ff0cac5299301a468032a37733058a1b221be7dec205ec4ae29e7ac0de23fc7dce38efe656fa70712d088b93ebbda9074d243031c60ccc33ac709e2d8531f8c595468d38a762797b8bace3b3b1849e656bb9cd1db760bf08f2448d422b82cfdfdf18952b39692145b5c3dc28109a4ad3258c07d9f98c1f09ba758f8b7ffb6375fde53519e94261f62df861a773f2361097daf4190e989a8fadf380ff5a17f657a600e8ee1ecadb772fb9ba82c31e6f0c4d9db87f2d70ba148e56bf2d8857c510a8b22e639652397c6440071bc861b02d3f736b82e18e4a34ffe29a2a305063c24e4f38084317519b72c2c2b38868f84d1be63eb7523aabbdbf652b9ffc06a40c8a57c9c3d9bb599c70e37afd838d9a77c5cd0cc64299c7a8edd0e8c11757e25bd6071930351d3fe9699d57a056ed25dc2378b089356f35a364e61636e7c0ce4c76bcc46eebd7a320058847366a1cf46bec2273f36785e41faaca8a29665e06643be7447338525db68b02b0885a02bafb3e82cd7892a45edc86fe0802714ad222234ea0e2c5acac58b4cfaf9424e6c5d57823a7d8c49a7d2f12cdfcb41c1b04496649c44e6829959a2ae3cad758cb1ab900cf83c54b7f8ecc04e95e0d4f07ce8189065f7975cb42e9fd42688b11c6859e81ce67c8b498e440f588e6a0bf06929c575da1fe4a7face39642c7c087bd090069b3f3b03e6157ce5dac71a57814b8ca5433a095b667c35a07e6b828f91e2b3a5e13542e60e1e2c6f416958cc6a067c9e6caa29c97e7e1f8ce711a5c07364c9a363dc5ec9ce02439bdf554c181f7f368e23b8191b0c44a95285bfbacdf5f2c00bd9805cd38815e5163453beb547c1c55535b5f8e3fd0f0d8892b67d5449b5672806528ee1216fffc2820a6d0c922e44ec8c823e7c448d00252099ac91d65dd37269c18a586047225795cb794823b8cefd83eb3813bb38a0a57ceb677188b0b4e9cb385427fc955490dbd1ff6266728ac2221756ab9bd1d53bfecafcdf951e1b48a29ba4418d15130f158631b3c7c3c348c0528aeed9c1808f725e1d89e676ffe3631bd74af5173e62187f091ffb72252ea8746579940fde340d1bb118313000476911fe188924281034c8d93404a03476979414d197b80ad78a1ce23d5a6dab31420b3e52afbccd8d46d3425cf3df5b26e172c84d45b7f5547ffb6e97be33694a60840924070783ecf5cc5d59f7575661b7c2695716579f35f82d15d10287ffc0ecfc93f75d0725f2dfc848eacc4dded4d8bf552688ffe7efd6ea3ee9131e62de93dfe7b0c2250988286eb82f5bd9e5cb4360e004cf24be462bd18bb7086698a137f124762e278b9181aaffa13bddd090edecab38b279c0a082248f7bea7757f43134ff1c2a7ebdc49cb88ff3de3163488c6e149e7e4e006e7f664ca4940e046c1d6ad53c1b16e47cefc50535d693681200333773eced8bce1efbf26d61fb73b28bbb83414c68c513fa9a9dab83472bd88fa138e42e42406a82b682d4a7f764e2018481e2196f803e5f4f5b038c73d5ca330a41bc2120ad050452fd22920d65ee8a006f35982c6f5fe43854d5a53fee86635955711bd38a99f334cb0f93fed17723ad70e41030b2acb306106e222199be21ee0c9692d3817c889ce61cacce0c8495a2f64af3089d5cd815bdef7f98073cafa66cd85a8355895f8a839f0f7fb3cc62927278128917295d247268c85fdb8260dedbbceaf7631b75a36339c5eb34d9de2a0cc6bec42ac19d211a37536bbfd997f33b21f3fb04c24d236c00ea9588dbf500dc2ae3d10fda612a16ccef30b8fc3fb997eae8f19ffe274151d6fce9e48b6d547ca88870636daff38063d25af3f25ff54069a5619d2c8d4eea2c62352bf168b0e5cf9ed384a01e897b06db6fa45072315dd64d66cae2732e98dae0f9a874f01ae5ccbf489530f7b9ac177021557e130742d9dc7883023b3766c06fdc134dd1b2a9e8576d710e574cf3356bdf7aae33140eedfa07a155e9238ced40d94212c3763cfac9dbc5adfb50c2bee4f2d4629b161cd8d74d8da9c238ca2caf25c48bc2df8a49b0b97676b7e1cca2791e20846a4930d12fbda2466095b3579c2ddec3ee8666421a45dcb938c616ac5b57f79a5f6f5b645ba6f0aa72e7b3521d269a0b1e5602ccf261f3d8790d4529311b816833cfff1d30074ee7ad86600591d2229aedcc7b2b0c708ac19b0da1ae3b464a72d739fb6815bf3ec1bbdeed5802724c216d19762dc719dedceb5107185d1a380db5e24e3a37e2d16076f6d5bcbab76f0551b0cc1417aef6925739a2816cc9f6d4cfdc669a935238fa8407e84bd74728b23f5740b5bab794582bc41927611f685e012f23a20d561bda76cc703b00848294080ffabd042fd08603c92ab81d2e624ff658916e40a027c7af7d66f203597c13f9e70c7f7ba3b044f06e8a7815d4d80c6164f1a911414bd34d77c3f12677ce374a917ec0ae67f737e34e8badebfc09d6947ddc9e1d98a912c9b3cbf1bbec994463124ceb2aeb2454e79461f10d1c14bfdef2846dbcc4e367b194b74c548560d1c73e596786a33f9fe5f29b97fe31052d795215bc5e52e9482e1881485dadd6bc96089bfd555abdb7dc98302bfd2f03022629f87886ab0576c9af50b0d1fddfc8e688aca0ab7913ad80fdf0b8618e0f133b5f29978ff33a6a3ada5973dea308db4aeb885aa09be7afbcf95ccee0c51f47e18889dccd9eae31438ca98eafdeed8df8b4baf9134274c52a68755fa4c2cc9fa9febe179c38672a61dd36044d8536acc33296082dfd204d0112ae7768729cae58ded5e9886cba0e2f364b07","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
