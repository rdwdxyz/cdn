<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e40df6e62cd10b6a853e8483eade3078f76010c201c3845fba06a3e275bee868826f7ce81d27626c916aa3e6b95760a082a5b2e6f3331b48b6e13330581206368ea605b0b35ec040d0ff459e588794c3858c5a4f1248de62641890f057806b4bfa0f7e15641a4ea18273482f3aa3ed924b34d03a8a372d877be3ef446d282abe1fc471c7b308f3dba6bf9d5cb2883d7ace77e216f63a377e89418a4377f91f0d5aa0b02ea6b481b918fc5a3ee51f7fc6108df27fc8f56187106c0e723e3435bb8aa6c362bfb099c4f113b11cf300b1979d69ab04de7b854ed22ea9d96adf1732c97772773df9d3ac49e2d8cc7dff6230d7f00babd4d60d8a248b3cbd398bfcb9f2aee0fb33f52a220601cfc43260edf3a6fe5e8bfc11659e29ca322aa742ef79e1d9a3cf62bd72c29d273a8607d3c5a8838ea37efb23ab02e1e4a65897d745bc5b651f12fce89bb3897b66cc18247f452a2c1a8e4d938af812cdc066670ae499b79bc8c2df2a5bdb6b7b202a9a08c28d80ee9073ea82ae0bdd4d66a3995b4f58dd3f2e6ccdcca114fa63b4420aa62ba9fb2ccf3e46cad0dcc5b388a39276eac098d245abd65dad6dd42228819bfdf84f27326bf861997e4ed39496db71a3bdc5a5c440a0e989c91b2cc4436947538e7af95d617d772f879ce378bd151a270252ed87858f633e88d378fbd0c1e43064be6b7eb0baa76f00f3313bc618bfb685848485da5523785fcad642ebde83e41b166f9b87e71ff59ed6d8efdfb6307f647f2068a01b6fb70a28576d32886b08f7e1bcb31d2c28f0b024b9a3b33666010bf5dbe60c981cf2f95204f9f0bb17bd506b67621ae74aea300678b97af062fa533988aca0c0c4946a7c2857e5b52e7959ca48bfa4e9a66778a59c634692157d0e030a4888e0487b09437d81689ecad79a1e0ad4359695b444a53863e114295621c2ca721c7125eec7f98004fc884f0a310ac03966c883cfa6645d1fbde32c3a263567beff4fcc9b22f5010eb02f5c049cbc6b20c1648efe5a2bdee7a8d0d46e3dca07d37b8bf1a30d29e8b80fad788cf9879c8aa948d2be35f6dc129f58b9fbf749020d17c25b4ee44da9f9c9c63e62d674e5de09985af4591c7402f4a0e0f5ef97dc4e6e3fc7653ed15337ef96a7ed5812c843097c29c18eae55dd1875847876559e2acae972bedbc8960424494307349752e1a7fcefe468c9364b11cf17a85dd8342d4466b55913fdba4479d6e0f6e919ba74684e74ed2b3a22768d8f709219caf6967619584a7676c8d4851f7bc5c70b29c95c152b8d450cd705580bfa6a832d5667ab4d0c957741110c4412bdaa035481ced311b221c16f6f81913e6ac1f15e8bdbc9b2662064ba4e3bf413a9bef1b86673d8ace3111fe7fc57cfc98cf89a1fb2c7f4d01004978c264c4b0b3ca696c723b6df7976dee8be867f51965b29f59df53c3926b6002f1e25eb232fbdd8487843b3a6d2e9bf64329f4f077f070be35271de0d8f6df2b2a7fce7497dcae10337fd676b31592c6206a018620dad46f0125a4b0d83be9e38d9a219128cdf7a4c5c8e92358f063a67b41d78e211351f34358b087d5d165acb0643ff22c8fb0a55b7d11890c6b2af1a36194354f4458665086d13346317e29262bad5d5a20fa9435a38573049b16c5e68253e8e06805ff296cfd4580db6ee4847a4b4078a50a8892abcb1cfe3af14693dfb01075f893c6a6c39529cdf43eb737aefcff21678a58304f54932d589087b9138a398bbb4508701577cd3694ce62226c874ae6d69ce37b6c2274de06b2d812c796ab4d6cab4dd34a4a13aa6df1b7920f81ded041286440d33ccb819cdab69310f004e9cb7ba57f129054d7224346397801392e2847016a781ce1c3b857c63ebd87902b67dc21c73eceb0f3bdb339c0218b691ed8cceee3c6d259bce4ba5a8daeb720c195d841f5a3351fa72368af28820030e0e27fb94f849f9ec4017e1bba4c43c9eba73c57b45474f439c864965f082740f72c9494e1e1f0ca4376c498ceccd4a6161cd50c120218d0f0eacd3391bc0b7bb3b61ea9f3b6c7f6cb46618ac6486a5cf1f96743ee0f7875ce4563da4d2783dd121b10a4f32f8ed1433c7b87ca6384bcfc36b831f73c7bd272f9aa55e0d8f149f22bd614aa72a43f26493a84574b40cf166242c361c2787bc2a2b2b9c44b84ba2767fd7299f6f821793ddeaba9431a6d4c14043dec6b1192b7658db2bde6dcca8bf68e9bfd219e1f3671ad405fa29aa570593b78b5a1aa6423b615634d4fee8642dd0f62e941062252df662b7fbcb003d89e343e177a9e7eeae89f9bc06c654f555ea12e759a8f9c49feaa2eb3919a40a98398e21030ef839a72d5515290d7a94c4cf21e516a83600ee5270f19693a738e2ef8430b48339d9d9b1272825292d203d3ee708fb8b8ba5173bc809c520172af8b1b758d9992bd96da016c0eaa73e222819aa18e1be2794a1b9299dc92d43dcf803a5471b39ca38f10699de62770a6c70be95a5c39f56ebdd3cef22729e762cd3b553bd55d9de9b845f922727af1ca4c968a47ca02924a710d0258f49c5afe2b47fb19ba267a552c1d29d09e775e9f2e9dee2e3b0b2671bdd54ad9f113af3ecc0036d634f3ad57acf82f9ddd56d9e90492bf9e77b9292be70292f7c655a199254b939028b46e096f6fbb689477296fcc7d8f7f4abafbd9506d486b574905750fdf43b8697f4206c014820d9a98b592c1b93a7ca4a0754f6ea3ae796712d1b2b639220fa12665a2252b89584b297c9b60cd22b99ab16aa23dbe12bef9f638a44519a450fb3fe3857478b6f14fb12912ab51b2ee795e961d81fdbf001fdecdaa2bc5f75d924cfafd71a16daf77f879ff63920638fc44f0639398a9bcf07b20f61e3664d8ac69bc11ae2d38c74532265d31f4bbd3ddbc034a2e22bc9033084585877ebc152be1b269e6e2dd075d38a7de912c910a2ba64090ad07f98d97b6dd6bde01049cad452cfb30860537b23b37415773a4c838c56635067158a7c3865ea1b5ae5d892259b6a28349ea98df7e3b2afb204461f2eab1d3bc7b2137e38664633f9fd89ceba38ed5f6cf8e569917750224c3c2a0c627454c45f6dbb679459df0745551877d79319bcc00797fe71d051932e7773dcf1fe21b8371ac295322d6e6bfb4456a4caf7cbfa3ab464b19745cf8e636dbae0464b659b1f349c85ce2c2e9a32fe03903cc9ad6dcc5d304be177bacbeabf11e6fb3c501f1d2fd0d07deed36cc0264148e9143d5ce0dd1546c2e891139a6b4946abe2dc02432641745739ba2d3d89f154571c3699f66699fe5a4180ff88b47fd12235576f7f8dfc91ecd85c3069e2a247255cee3d1fc73a733e1cc34dc4adcd0fc6ffd276024c7b93ec46d1d155afce14b83e489d002b4ae18046f10257d675ad89addad5d9c5a9efc285d4d5101ef5f1220d66b466f15bcf9c9843d55f8c3af4b1270eee0ffd40ecb2a6ab6074e93e8c83e12efe2263166f23be5079583f9433007077835d65e2262d464d9134b337a685ea8704bdc89b3ba2e3234770165f0d852b5bbbe888bb241528d84d957c6c375398f82566054d38d1b3bb0e63366b2314cce68e1d3652af79daf1492628e3b8a8149b449da31aab6d4691f8ad7bf9add2b191a0ae8afb842fb90da090dbd82b477ef07118708cc1863bde069faf76d3f9b62e5fe85b651f2ee918ba1bb2851bb1c651bb853609629c000ff1c89102a1bfba0a6d4a7a57bae4cb72c453b60c742ab7c971295a2d69a0663d8417a98177aee9c4ba2b8426696d274801bdea82fcde223e064897572963f5c137516dffdb25af4692deb5f2ede6f2e8f7ca4cf348d16c70d5161414a34dfde768078fe3f2b60ccd75e83acd2f255e056a14a4f970758909b0207e1d2e4d579e2865de1e3916a0a6f753bab1b4a4622a1c0f09e49e3cef5e0fff03d2c45db26d9c5d2c8600eee3e787fb0588f3e37342b50743cb23ba3f0a40a64288889b645fec39ee761b0497d58843c1b3ffca836ed6c60eb32862aabee702d3a9aad58ba610e44a587270b9398412ff61a12dd88edfa802bbd5893b7d0f081afd85b041f9236a927c7c416c6e79ac97f29dd07cbd8aa5f7a562d79c3e3987c19f68d5be73bd1fb65becb88db0df210968e8a482665febba89565142f95b09820eb32eccea771ded8c30957fcd8fcf2a840e6df9ae6e0ac0f4cf90e3a43341018147ed1906d3d26f2c7210cbbd3f399c749eabf9b12183ad6eeb266c3c7b42d4297e93da85903cb7df72b5ffc7ed9074bf77e496316a79048aa69c47be265185aae215a88e29142b3ba3f798f3de32a69e846862e9a2c12185c126a46f58324ae3157de111a50e19bb7788c54926b9ef6281bdee8c8d30f771b33e70d6dbb233546702d42667aeeabfa22cab10e721685edc04fa579fc3f2d5dda4b8482d557b7c474c4f78b9242e80f12b41dc4832518846b0b5650756bebd2ccd20e5bfb5a794525eb637f98b0b4d439535fad4c5ed9166dbdb5aa0bc638b9ddff21b6e39b948301cea397fa67f198465b73b8ce17f4159c7228f669f80cd8c5bb0c98fca30a7dde87309e5e689fd1c5e8c69316534f73d042dab7d2e59fb5484ce7fc74fb59473ddc4c6cf318f1d1253ed82c2cbc75c8823c576a9ebe561bb73b242b9fd9894eb726feb20b9c8d69f35244a30c104a769d9c3d92a5df465afccbf7c1d17a2ec08493dd65a3e6cab3265515e0a8908c800d6aead98ffb680bdc35b5f2113ed56c13ce019a61ac727fedb3aa5e89fc4f6ea3c9442c4e56e2ae67229415784101b00f721abf25f5012caefc2c446be8b19f29246778b8e2c91667fb074daa29ead8d6826d314afb2964962f862f44df776b226ac3daace91843dd5e96dd633ee0d16a6c1882ccc387169cc6c018cecd45c8ca766c5e290a6e35657145d4f5534ba9078e1aa4724f195057b1efc9f235e15068519cb6e3cae48af7186e35b81c360e4e7f933a4bb93241ec9f6c10c316d25792ba36943b38a19dd6a1687958effb54daf1e1207e5eb438cad3c6f2b91cec8af3eabf296b1fec5c85cdce6b8fceba71990ad5a15df311868fbeb51de74d6a89c962c6b3dfcab665025bd26e463512a8e9cd8b6c2e5b685ddaf53444f7273d19487c28b22550e79771bbbd708550f666959508ec5ae4e868305d5f2a18cb6e415f8ec1b7ba8b4a8c53698e5772c7fcf275cd03a435f0a8ba175d3bc5bcf91eeac6b0f2c8a2ffd6cfc6b145a5cb6fd66138f6633aa6b6617ba571109e3cb3ca3210db513acaa41aae15448340ffbd0afc34057541da0b0c32266110e885861d0f47a691e429a72e96e30341ee1c0990def51e0b430cd7ffa7b50e21ea26300f1a4b26508e643c5d53d7f1dada39ab98ec53a8f4c922f63258f4ee3486bff294605e33117736c0974000eb70ea3c5535a235dda5fb8dfedda8c3fffd7cafc3b1a178383f2d8ba3ef7959cab41417c4543887f044d483fb1df1b9b92d0253d9008478d78a6c18fc4973fba4b7c1d0ef97f3d31880c010626eefcefc16900351f03d0039a4b1ce4ce682fb83f54b69294cc6661237c7fc9dee0a9cd8ac66dce4f7e74d5ffc5b5a82843d1eb6c00330b029f8b72fef6442f2453aa51326e9d4366efb5513679ad61d03441670e31ec82271a4a3ce93e00c1eb75f3ff5b292de061c81b4c56a8c263ca30feb0c46b68d773ff4de262f9b0f205d883fe03544ddb3e9a8b8e03c59bc8cdd983af415718847d79c71c551b08d8e4b66791d0f8a5408cd86675404919e0cb6a7851f5a4e519f022eb4f09e8016b265c0f4c600f1405fda90faf5147eb7c07c995fb8cccca99d89ab6245498dab885fd8ecb5886c0c7cbe468655742c81d231fa73b76fda2ca96129a0cde565074a4f9ea0f60910de80a8fe9dad1395d76a29ec7c2713c641cb42b0abc6b773a85344ad2f90c4562dbdb1cccee2a009e27403c509751d32001ccc27f0d24c78c636c4a9461df5bbbf9f6c7bc9e869819714a3f7cc6f32aacf155bedfd83073ccaba9b84ccfc8265a182252aeccde758ca91b10669223c2a727b16695e63619c3384fa7a86132c89dc85f983395afe5917d4cf965805b27cecec0db2681bcb2123ee0cd20c8b8701ba2bf5fcfcea7e180767a9098b36ea02776cc1a74bffe1f75702394f9a06fbe7eae059a6dd40029e1e734ec43a0a1b7e689c198254fd10fc0a05b27323392049030707b202e1e4dd92fe91c12839452a9d99ef27b02acc6302a854696d493e559a42646da2e85dc1a0ada1cd3815e2cba384a1f16f333f85e9f1e82239ec8be15629ffde9db8259ffdc8865648bb930460638d5c042745d46358088decf6183524fd6c678548b67949c512057704910e7c0d11b2b637e0d3a53e987a56aee2749624621fb499b84893b19734856d3fc24659d2b4e4717d48f0d66dc75eab5ec79cf0252505c382e92d37ffa6839747d900c60b21debe7ce0ee6e9f3391d419db8fccc1a34f33842c84d7274d3454fa4a818c0a74f6c6ee56a972486a53ca6d630eb371a5dc93170880c6e157805201490d034ce3355036545b14cc901bd1c39ce889bf1b2107c14a524d9905f754a6004a05e84d566c6286bb1977b2b47346a39f388e883be9564d78e0eaf6945ca126c3cd371119e85f8e3f671fecba20039b16060cdd98e17de2bf22d90d4ca3bdfd78027ea8e34e3bfd32c7c4e3137a2e8f17acbede4859561cda2855d2be5a9cd9cf27365303e035e3600da48b8987b3f43b855a2d697f054fffe53458286f26dfacac8d7d4c832f17bdb5a55c75d4e3545c03aa8a476fcf45936cfc16089272fb0d17a3de7ab001fac6c441ee39b7c21c132c5133803854f577e636f66ab5d6b3295cf9459cda4ecf67eeb5295c9cf691ad72d680234c1bfc870993b405d871cb518f537b69352e2e31bcc5fe76fb99013cfd048aa722c9f3de6bf276bd61c3f09b1545801534719b379f574246321b1d12e46dabbb4b7871d1d63fa6315a34251d2c1cf84d764abbcca98ba22f0b26164644a4458892a02b0f7fbde161e6715e6090438abbe5efd7c191e041c005e0d00b9b04cce7adb43025d79276b0aec95665ca6163767194e11bf5424a73f971ba096a87c46b5e991d7b1500c493aa7c43ed1da00aa0782fd2b0d780b50e28da812dc35c5bcd668c054cf81c730602e99d4127c25a1ffdd615ebe0f57c2dcb356ff648161844c0a17b1dead6048100f2afe708f39aff5a6570e276de341a2c22b88b1f40a1e0c1e75b9005cf94c4698314b03ccad2dd89fc9b9fe97a2f5f3cce37df896c2c233d0224dcef17023a1cab25e87300540f123b1f712aa761c5d265d96deea9dbc7e84dfa4c4434fac0c19c6a5958cae62bd259f26774370c5cbc8fd2105e8203ca9ef2f9cb3b243f24ecd3fec7010c3ff413a3effe4befbcfcb10b630358c4e62afea7c56faf525543deeaa9a5fbda75795cb3f404d06c0dc7c1e4db9b53603f2169cb1e5bfd675dfc7ca1c3e8de7dd9ba27a6f760cad69e3f27a237d6597f4668bb389709ef66f4cb552e62a0a5e63bd94b815eb5d06cab90bf8481fd8f6cc8b4b3f1520ac050ab075734312e064a71fedf73c80325116d7508544319d568ecb74e6ac6bf4d60b03c104e971926a489ea0bb164ced467a12b842a360d9e4d13c7555c13fd68152edff8e93bad4961235c99cedf5b4707659927d9329f53d49ebdd7e7a282874c4b0a03e36ec15e3fd8322906817a86efd90b965b18913edc83b70c140b6b47c411640e4d2ffb7b1cf20a9bbffa532c6c404566ea88fa5cb3290cdc688277d357b45a5305b1faedb999507093fb7e7cb14c2d33377fbcc3747b422a4e916dd3dc86600a3767bd3a5933b96fcd558cac98a8dc8f1894f62aa120dab13d98d4fa7cd685d16fb9d3f6cb96e87dfe2dda3be97cfedfcfba39a2af907a709b28754d802ac4bc507e3dd58306c3eae51bc0d3bb33f9dafb81254225c458e5186b7226da74bf8ef8d304da91b8cad461da71339fee892a63deb68bd5b6df51c50b363e21faa2ff992f84030635ea0862c408a6a112cf44f70f4a2b477255a1f3e331472ec9a4bab7aef4a575991f4a3710042014e2559342bbcccdd6c2452e5b731e312b54e7382de12b15c4c9f13a52b7b583482ea1f2a037ac4e9d9e9789290acef888404c26b920a89a02f7d2a67e70f80202ff9592cff0451c9f4f6948dee64d740c98a27c5341d04fe9fccd0a8418db8c3c065320c983ad6a91e0c1a62868bfec844f18156d8bd5f98396fda0718cf43b25d6e5fb885825b33b4ae973d3840f1c6c9ae74e1357c6f43137f28284bec2e3858e1f4b28d5dd3c12a20e566fecc41d9014eb40514239a41cfc38c01566f2ae6a4c3927f585597cf68a26f3b984a2b83f6d87b89cd50a9c7cfb6d5f008afb67a4b11bfa6ec8f8ca18bc47504d818e97df8bc0d447b5a6377f8bb2e79cc4439f5371ce5d8f9ed90e61bcc67c3700bd63b3e31674baa08e467369ea8b7130a5076daf74cf44db1d9c8ae807c53867d483315e75403319661d20a0116792792771327d02ee597a67e1f82a48262fd1a16fa0711f895f582076448c7d35401843cd7d5fbcb4c8f8c53f257910c81d3b4ee64de1d54066749954c5d5da560c023406befc9d9f5e2c6197ddf984092da84d25c58867827c622a403ab54ac8ef6c27ebb6c713eca70609111e121861d1146809c9521a8767d0cc9247299aa82c60ca67eb0d727ef425934870d5c139f6445ee28bbc376e2a0e87847752473b125536da26ac6116ac6fdf9b275e9692ae91fee89ebf8282bafde263d6ed73424d075cbfbd7c637235d90e6fa9746fbe001c9c8ee130e6d710b720b000702ed7f94cca3a69609df4d711d36eb4d5640f67c3b4d048138c7144fbcdcaf48d74ad6d2bfaab335a754e4d5733c922f5f7375518bd887ee2add1362938083e8a3bca20a82e295efbb3445d2b404a8daf03f043020ed66210c345290ff105ac653fdf82354785018a7dbc4d5116a4ff9b1a424a4e00ec85f71a77f39464169f261a50255290d2a015d8c7077b49ae6d04ba5723eae8113c22769c2b581f1b522295b5ecc40a4222c1fc7ab6182bdd7f77eae9fbc206f508b5d25f18a60c099f8256f517281a85b94c5c77ceb791b8c255c32f45d60390183693fc61ecd0dcd8e7566e9556c50f9161b8099f9989b6a3447f3ecefd65ccfc8515ae7bde1042f0381ea247ae9392012d2a92eab7999193ea0e6a52c67d084b99db4a78af1e83d96faf2907641e2db625fdac2589fccc8e8891a24474edb256c8785b51e2bb130184556ff58f4b1e65270c8596dd62c993881d52393e0d1889cb59aedcd8169f1cb9b03b68197a39dc3eb0cecbc6ad854fd91f7de290c4d091a14f1230b327d609a92919b1ce13d52b407c813d1ea601a932e8f5aa1eda0f7063af72835b2c7a955d29c8f2414a54ae42e0a23efd817a59e45a7de36a64b9dba2d88240e882495e15df8678e8704344e41952c09f7b879553755f0aa03367cfc6aed4432af9acab8963c568dee5a266312da6a012027765f60432c4381e8318b61b0739e85f9bd2962e4a01328a30d0b67cafe2881bd0ccc6fe774cac12fd812f0bc65886782ff3e4ab6cd9272da71b614f047eb9d798b3eb50eab859e687afa9539843353ac33199ba3a20976a4f2474071e49e4ebf3559b3ceb506f73e1cde2feba8cdeebdd49fbb3aa40c81eaeb7abc99248ac359a5aac43b014dbce60eb8a30c82f944302a5f6dde28e5408193a2e773e922df1896d3f465aba8c0bd29a3ea66f22d3cbca4dbb34cb9f4b4bc34cb827143118d1ad65d4a2cbf9149e5afbdff5ca63f10a3aecfda859a7296b1b26a7e789843249f263b4d477d61fb0b7d5c2d179b84e474a6789628939bcae418ab49327d3facc792ebfc314b144f8e40d55e4a6aa7ba8d33cf73d37662768c61d0368f7a5a680b1f6ba239ef6944e1c78bb144c0adf629fadc323534c73646cdc1b142a13eae0a39de7df23a9d1df06c80797c33d1fdb8ad2c9eac1ad5b9420cb5bfedf339877a2871be4e1318e99b5392d6262d876a0b7e58ea00f7d8255ad8f2cfc5b578854bfd734640243fd653fbf6fe33f1c7fe88366b263c8898dc205d55d4b0d8892177ea01f66c4d64ba06fccdd0f6eeeff412ec0ca95496d9e6da05aa080a7c323f7274f96774714d58d52aeeff75721e1b9c2ce3906faea6a43827efcc313fa37211fc6726eac06356c3ddd45744df727ca13220126fdf3660e33b27d4581f7fcdabf4b97d222e35715cbb03792e5410c3305f10f38c6b0c1719934c75c6600c06a1a5e820c61070bfcd7b5ce81f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
