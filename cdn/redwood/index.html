<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8f2af00d6e9ea35885f57f4a18a8f5ec5e160f8c870430df4a406e970adda106277a09a7b7ea3b7fc2babbe3dfe8a2ea1b58da4bf61d4e342cdc7d8d0ddb207aa7092c67e85d223b84ba880638869c1ca9d2ce1a30c4e5bc9d8955db2e59f67efe9d05e0f38be8fc81004f6957e1a5647cbdcf4f71f22f22338a70d7d4660f1ef488dfa8075c33445cef3dacd645507f4e5737668da505570faf885f119e923e8ae71881340d5bad7be0220623b9be75fcd3967334a7b47b0a3a25e3e32b7cfa8fbac2aa3543d90bec4ea3222bbc414be9a67d490be38ed2d51edaf1853b66d95402ab60c82ec1a446f80b26662b42c0a4163fc3b14b5efe849ed87530ae47464a34cec19a03ebc97a641c269efc391c1465e6fcc898c5aabd45c60cef6b552a88f8bc3371d122c87e8ed5eab7f9b70455e75c701e95268933a65ee3175dc9dc8c8962c6869549088c96e087e22f14a2f75a799458e85a57152caac009b7f85f5214e3acace1572c79fbee7321fe8987e7ad18f8c38c72b1b730b5b2d10b9fc96de210f6dce2035d139e5b42fca6b1904822f4a930de8d162e9064b5717109c816f58780df10a06b1b2a568bd33b1432f8457663872f2c7c74cc81412041c51c924733e909fd1da3ccdf4a476e76c70d2fc7d1b955f31626602c9d83eff1b0a8362042d65cd25ec46c51049fc3023516e5d1bcc80a2e4623c91e3c2749518ff2bebe2a384369aa280ef111ae7c1d860a8f0f5332036aebdf1e8dbed4e66cfd1ee43ea529bf02463e2a6efabe6da343591d6ff66428b7221fa0a9a7ab30ac42f428f669e040a9724673a91a545a6dc7554c43c0b0c6b608b10c8637c7286764aa5bd7eef55981883dcb490f57d231a143f2064642507f99b406ee1c51e0566082d54281870193aa52faca3d1c9575e78d30c2a8d3b325d12f508b9dcb454a188041bd175a864704af62c6cc6cb0a3f49cdc927f0edcb9e3ef192597b41d526593fc037232121a30adb5daad67226a3f9b0c838d57724e7e0271dcc4273c166cf61a03e11ffa13fda905747da3bf2b1c64c57979c1963d5736a40a1ae2bf33e7125936a3598e3b958763c9a30f935251c4d2286475e928abde2da29c021e5ecca989fb9871e756efd82089cc48a033ddb1b6d185ad213d9060e75f293a5c0d61a15b5d7d86ad1049963570bc65a0ce7a2d7e46621d43fc9293c4b3e83193876bfc389dcfd7051ace1110b37dfbdcfe3a51feb7cfc62f6b1092e8984e1c8d08d49636488e92fd93f227a9448cf0fbae0829af8a1f004c45269a0d480d1b9801552f78f0326c79d530c91e881a835186771f7564f93b55693d7adc036e4e89ff3b60767a5d4745133d9310e5a8c353b72a2d2e0d023c7600f478806b448420fb309ee8c545f12c4e65dfc883b13cd93a492fdd391039aa986acf4d096ed71c59433c43f421dc90653c4d343af3aaca019c1a59ea5ce33fafeb4647c87d3f52f88f599f30a6ac7ba64d16c36dee76879d688425529a8ad1e4418d698bd179188277af40963a544c59c3b98da954778a55510f54ff7e612bb0e274feb1ef8fa30aafb58da45a67fbb4b49635ea7bb307e8c50c43361e17ced572fb26c1d07338103148e67a18b2835cff96df1b99fbbbce0a7c2a6f95fe8b080cd931b9bffce44813cf34f20471bd0984cbaa46c8432169461c9eb1d60f6d8bb53dbd241d55db4aa0541604fcf6cd416eca4b7d8470fc427d73f553f3c844a672cc5acdc46f2f3cbdbcbe2fba4c856d2b564eff9759021790deda5a53ff76aa0b458202ae97ac4f60f0536dee545a9861639dd3d50db939400782a1d44090a355a7f69391bede0bb672202e0a7aafdb703a6548ba0a8473791bd35dbe967b8e5f7ba4df0ee037c65bae513bc9ea55696f4b029a0120d5f4d7c21f708c59c971da3e034db6faf861a8b7fe5b22892bedd060f8c3a16419313d4d2e5effcb89bf704aeff0a13beb31273c338e923a05a5de0df7638aef66872f66dbeceb3a8822136e4cfe636b429154c5e6b4c49320bf5b360c71065230922f0a29c4432944edd62c741e1329a5f6cfc22f678b3e61128ed7bf6ca3c75118e7a98c3a6527946cc1ffb025e82764c93076c46960190812ecfcb2f48ae76259f3678b42e0f9175de5bf31182cafc9de39707dcc47797179ced96f5c24017cd53362d8bea5523bd5c48033ff8e8a376c18ab70320d22e18b0d5bc9c2fa28934f7c8bb35cee228fe041364bf633e11a718115f11fa5ab7c1dd91d838b846a3ef79e509071de067c45fc04609ca95f094754712ab0ac4819aab72f4d59e49993e7de3e5a2790b87eaa02e404d2ebd27a8eb8ee79c4a890f46cd5c3654f16335af3686a90ffa700405b8e867e99875c68887716e5e8ce41418a08827722b1ede24946e81e504983488d32013ff9fdccf68c2fb661e8b26fd0424ecff31ecd8ff5739b00c0f49928cb3345e4e44977ef51f618526063e1555281dec68c6ec63e80c5bf3c8d77172c1ac9eb18e6a8023079d08d8af19aa6edf3364880f0d199f13bebe543a52f38217a5daa4f83ca1dc0e59e9e95dc72a32af78c3626e8ffc0ed5d4302110205a82656f0b3ef4da456b431e7c508995a72dc270ada1f50cb70f1125d83dcf143c9b73712a83c51a39f5551d334d32f14a3aa0373630c5e9e6efb7473865beadf1d62b1f53e552d99cd50e0611108d1105e3c9c78122e620d099048c3425834b15f642eae6aa8f5fb9dc3f0236c7a2c557aae8fc5d1b0a2f4041c1e90f7c1071bcc738da7c16af36df4a7239c33b2977729b9b0abe6ed84b8309e6cb38309445edf7c346f510b4a07ebf1ad50c78b57bb0dc763fb6c55cd4424d5393c7e9e9db1e982633c59e1853bed44707563f46c625d45ed1644b2aaf99b81cacdeecb956528bd5de848fa9057f4f9f523b4e7f9286c155c3ed8353ee610d6ad523da08c658721f799b0ef2080501d1456cb8b1fd6b2b916cf44c37f4dec36ef46499969327ff86df4fa0ace35d0c9a1ade691e90e93909fc93a04f36494f8fa3701663f1b984a570eadca3702b296d422de99832eb7a40b7dc7bd70b0f5318852e3ee192ec74e058281c9796bed97ec661df2a5e5491952e212bfa657641323de2ac840d12295c3391b3d25130c9cbc1bb515884d123640b733c7f72abe880da87512d810d407e3dcdeced56dc65c07a39c45369bc1f2cdeb7d2309ae979a00f6e23b6341a38b4423e1eaf697c25aea8d9e984180167ab9f4f1006f0a6dd6845f15e5b8e0c03930d2e5fe5763f5db17779103a2a335b28249f385152307507af0f3f54cf55df75521054cc87103bf8617cd903f93fdcdb17fe8d86012f77d20ffa28fe030ea7895d075db46c440c1a9df5f95eb15f2bac5983ca8eb2165d5bcddabcb45166741dead43732690d4c679129d3d0ad4c0acbb72e7176c6584d12808b148f3daa8121834d2c8b58f93223ea2f1edbcbc21de0dac6504ebd71d2ab91fc95060d54c3ac9f369cfffce017f934913cc732e6bd40a2955cd94e9759db6ddb0153066d7dda4ae3a9f7cf8d4758f641ec3a8c3b08061942afcf05b35f45910de21616c1899fb86800c9f97ead8043208fd7213b5c0167ca08a806312cd88cb04f21bbcbddadabe5207cd812c1aa4c158594f27d277234d18040f958244f79905c888478f946d8d1dc8d9a7a609bda5d69de5f2a9e7921e57137adacf8015040bff7952656fc1534c40853b13fdfd54917e3cc6ec61f34f7bda5839bc4624361509cd1307659ffed63fbf0dd600b1a2ef78ee8becba692c45545382d33b252360752710a14b1d042417459ba8601977d843ae578646ac0de5a89803913cbad1fb3c669954fd47c41666ad309ca081c4b1d9e935148601bfe1c54e95438acb58fbaa4b4e5c0e2d1894edbe00a1d4258a0355aa56f0347658dbd305eed419cd2a15cbc8a7f088640ac4f44c5978e1eecde152ec2dbe2c0a57aeb04de6c4facdd80788ff368cd93f86e8581b05b7a4d7a5c49b65bad2650a9f1e8e2ef83d596b6f384060da94bcf233a09a1f6830e149d344a85826e99670d515131fec5f50a6b6b1195bbbd76a36056eb006b8b66139bd288f7589f6e1d3725b2f825aa1e4fb8a0e31174b4b2ac3fe249151eaf6814c353c9288621f12028fda66d83b574186644bd85617566121abfa3666edd50c63627af71170aba1b0610344022088b87764574a676ce6709a13ce4e5d1b9c7fd1a123ed19ff8945b81047f62568388e5d8757e0c99e04be4efb580ca264095effb0ea15346344d360073e0738e1aece0f73c31d691955b6206a64666ebc27a0ac83a0de2becb51d0df2e53d0163bdf440c4e13b7fff27f4cbd15fb74e71b2314f8d954ac45be58505f41a1ae6495fb1c5f1d0b95d5e0c9d666d09f9c47593abc514017d77871c339d745b056c2bcd9a418d445ddd953df387ba51273a68ba2e5d87574172c50e68549eb96e62316547da919d22dd367616a68903c2cc0abaa4277e048fb600d0b50f02e069ce76b199de74dd8cad7b1b72e1796c2a8eba859a49fe28fc76a98eb7af82f78e33d0a93ebd3ddad93b503c202a75908c807f7c2742992940ddb9eb5c99c9f3a58e5d45e620b304b53bcfbcec6c3811b2012a338164250b70e61f4f5b8943f753859c7c8dbce1965da05d5e2ad6bcd5ad0a0843ee9c802708dd49556770f21b2745e5d4192908a235e04f4ff18354f20e0c1920059e59c6529edd4f1690fec5f2fae313a61554eca24b32b0d2349e8a25c8b98adf2d1c8ed3d4827dfd2574b599f1ef39c3c6a613e987d281efe94d30fecf400869a31ca32041436a0d9ac658d6ca7949dfbdd7087cb9eaef5fee02ffb95a12d5a8c830c045527f90ca2613943f74137964c1452f18007b77bd2bbce531b610ea7ee27a9b916c7733dc0a429ff426dc6ce547f2c9943ed4ff8a0bc701544cd7e45d59f1d0cacb2b752851dce09c5ec5889e327ac6023d2376957b19e610517cb2d280c67b97d8dfd8ec76f8d8f35913e0a7ec617006593371910e816fbaae2b2108c3d1cc7922d59baad93d301773885108cb6a769c4b854d8413e20b324ad2e9abae71fd1e64e9408ba7ba4d83b7d87bbc7fc42c1e068f3db89a7f30a773cea031cdf4aea9841a59cf075fe5f05c482a6f09696d367ae052da24a27388a7ffea92f0bc8f1b9e050beead0d4f02c81a4d189823eee0621b460523ffb689630c64ee0f28026d7da23d596344ba15ff50147f970aba5c5675c6ee6b7b1e4b9734095a0306ad953bf8a39f7b519773fda4ce4f0fccafbe86ccb559103223c1f4aa5536221d19ef6bc2e84391f43e21617f30fe5c5ecf5df991bbd57880809b0173f9c7928dd2ab7140c98b42b9840986d5e930f6d62dfa3c21ea2112727c517ffe437603cf0327661f1f282fcc7519b78b8d7be580bcac208db55b600c7bc162588d8ae9eb83492d91c91883b6fbe87e3dce3f42fbce27e393b23524805683d441f7677f94ef35e4d7a6e1404d560132fb3ba818562eb6c785807f05d1908730d9f2281b0a485b51591a328fa1476d9ca7ffabb5d7ddfc98c08632d153ca5f77a4ee4647abc28ce1c717ee122b2f86171f2aff4145fc855ae4d35558165315b3410b7e1fa6095bc4e680d0bdc84baecfa3177ecf7bc7510ff3e7c9e9769c994dc2ab2c84082472c6c379f4fab96075f3728199c79f598aa54c6cc3dc455b82c16d7e9d0ae674e93ec91f016b8aaf25ead24a2dab79d6a1127030acab670777d937a12d786df26265783e156a794a2c30d3fb106444950774e193a3c97254ba095e20aad3b8b2d81426a34ba0bb2538dc3017e4e03cb4b96aa5725e99804c636975c81af55a9e55470b2b8536d8ce36a780dd2d03a74a91eb0d86f7472091907f70ccd51b07dc0a61a3c4061e003c3da0c6588afa27b208c95bba3f5ee298461446848572cc699ed01b7ca43ff9bd24d9decf665564e44a53cd9f1a7e8bccaf8a4011b9dbdef3be41dac5962d46204a5f324ddfe16d877f81d5a4d731c512af47f7a91ad409d3dad479fc2d9860f8aee4dcebaff695cd9cdc04aead0d793358514487922eefb07df74859de64ecab75b801c5d39605ca5465c076fbefafef58121c8434b6bcfd027972974a8ba2d1ae161b798778cc1701c0a22451ca50e63603d238c12df45a958624797a6792a290d7718b0d90002612b599973c37eece236f0123b70ed73da0dbe949a74cf4d08597b023fe3a6f163b68b7768b80423eec6fcb2bd69afacbaf56161d5b52794a4f35d0c06a33e17843201ec57a6a67a412db97fc048c21f456d7d448816d892df0b56a7d96ecb1f82ba0fd64ec5b2777a1cb4847c758b1afba7df6b7e35889b6c4dcdb1cc35a8714712867c0a9e4d5e2f953e822595c3cf6b9af311331df9b06d07483f479fa8148aacc0a6e24f404c02e088bb62b3aa8746c1b62548154d33cae3b783e46b506d5cd9adf7c51e2004c62ada626118f45b8ed4a4d93d517943e704742d2ef46f90838a1427a6b29e84d93b3f451a9f34b1250c49bf599dca3675e54db09a8e1aba394e148779aa3165c7fb7b10c844a091b3c1bf15222c86e401c1fd9e5d849f3bb54296f73873008ca07672cdf529edfe1e8e661e0267267d6adf9c0a8a261d1ee8b5139572be45fe8121f69ba9ff8965a3211a562ef141179bba23adb0bf7d0d69d0aa4c5695bb8b951155f2c753b4ef0ef6d2485c10c25c2274b9fd5f28090281868e0f33bb124a89b4ae90e7538fc7346c024a66d6fa547284a4653e263ca2181ca1b83699988233ab1f3fc2796859d7c4043a267e558ad28a4d6315a94ac3c09166792cde30cccaf598ffcf786bfedce9ef6701c2036255c24ef17f03ae030f4c5be655a1fca1a89dfaeaf4010fb52f2457071f2f8c4581a3c58c6974ccc37e835259ae1ec67384345b906f109e7701b37499e3f54b88178cf502b31eb6d863b1061a364a4aca5e9b1c9a8bbae8b9c7ea166c3b395f7b21b645fb88b90a8d4abe24e4544c9eba97b5621c21c4a6a05680f5daf97a5898d3ba832b7508dba60395ce46b737c28e6700f68d5d807f892b557d6e593b15983a3ac90f143bb093cd2d73d8124940cf84c05f812139b5e1693415ae93501a910ed1f87da7ce6d9ce537ff30743989bdf94f0d35fcf77deeeca54760492d35f5b536b041149ff9a6179a9540d16d7f10afb7702b9d0be9df1eedc9c237fffe351d712458ee6feddcffd753e513442c15a8a89b9096f97035952b97cdc03212fbbb4122af5fdba56fbbe37a621bc2ceaa8e79e23b0cbd82dddca4c67d50865d37598893bee270264d5fd8ef3200782d5b2a925f30b828e2f7d09fd8bafbf5c655135bcda0aec8efcfd4b2db7de816c50d2789853e33926880cfa7c3be53afe08353d61e51f48976256f3a2c9d71d0664ea54faebe28772be817a6e84cbda73f0fa8e8a8dee5934fb7abc3432908ce9e38906c14b7dd75359766d6cb932bda0263adee3782f1d7ed91822b22bdea32737af24dc165f9edfbb2bc62131ecd35fc2841f7b45b24b3c063dae22981dfd766dbad954d086cf03c9421e231ed12ebd0467d2ef2649a08c0461d51765416b2fa24984d8a75b259b15f24fb4cf595e14416c28e7eaf3acc6d18313ec266772697fbc72fe7a60f115f807f273cae32f878e64aaf14280684f9b6e97a98db17a093c3df51f8eb79b3ce5a438eb4eefa7939fe5936cf8851e9f516af574f7ba0cd35ef30777c0a0b40f4dc811532081c4feb636faa370d816a16ed40102784c6daa5f2725f9950c205ccbca35460445cfaca97cfb87fb092f4897f458bbda10241584346d4a55fc1f9b043e30b0fee807e3f5998d34a0fe3594fba71c9da2d04833ab577b8467b5607a395cd73408f3e216b22a1bd394f0c2815a71ebb9b89732d2a6e81fd36ed5504c2c0b313d4faf770d7600916f80d9b7c0e8494850ed33e6a1fb2efa90e08fc59755e138ded457b40705c6dda1f237c9877cd19d0d05aef61667ede15ec089fe3e9cb9e00f1de58b09cfcaf491ddab940b748a3763a1a49629a4cdfb6c3c5bb85351ff8e887608e902f4447babfde49db3a3c5e1d8f99858802c0c97541ffb24b6e881c7818df3f586d664f2c00591925e38961b1ded9314aaae42e6af7f0e07a46ee65946acd1fe64af025066ac1390da7b9723ceb34a84edbcf267b479c6c53874c46a8bc7e687d881460a314edaa113fb0cfdda6fed66774b05b87cd89294b5bfff8b4dae12831124a0e8b90789eb8b12041420d4e2d44d46a3237fe299ec477d4ba6bf8c97186fc94b1cca13448ce8238c01d7cf65e21dc79284efe32e783085b2611dcabebfd0213c397b3bdc984cb48f0a645d200197ea9fc6a782f7f3bed5e28c3db5c48bb28708ee986984be240514b8ab09ebffdf91027d49f64ed913169a4a821b1f884fac96719d6dbd4ecf8180cb03bd998b6395243fd9a6f4bd8f654efb06254b54128bac6623297c52eaefe8987c0f610c3cf23d8d7b95a13a60c33321625403c07f3cbc366d4cc4f4f416c8b3f23b1db130432f07ba2a9e08bfe8f06932bf76bb6ba0853719a7ad4663563cbebbeb173857209129c92a40eefb4a9b1d1c0d3bd6a669b1ccb30021b87daaac0aa5701375e50f75e4faaa2f6aabe64821c2258fa3fd9f6d68e7b38676f63ae6ca7e3ace51d78b359092760e9e92ae69b267432f3a79d620a4441c83a04f1c260e3274768f6dee1865270469343076a55353b6bd90d913ae747069ad9699519b605bc8c5b0ccc91d4a275feb83742c4faa594774c8302f084fc2bc2b9b51e950103f4800db54439fe201d03852196a75cf94c60bc0835f850adbcf67ace557a6b61b556aae368f15a82095b11d8efa30632135cb00ca08528d53280c401ed3a4b8d736eed6d53ec4c2a636fd8a0ca91911ebe48d1cd4287e0ffb91bac3113fae99e12fe8bfab2f86676b64ed6881ff4febbd7cc76c6367240bf02b88e453370b33ec900c0be581a83a3f932d7d7bd3a9afb34ca1b5477895d68d28fced0922f5be345986c4e0637ba3d256836989de187d4546a2f72431083816e0c5c7bf29dd5f95d14c74b138e3668a088d46acb060b59d27afb8219bd5c6a35f194ce0e01360c2ca52bac5985e75c86b5f6060f2a52336f776d510af555850a11ef3677d59941a1f0d5745bdcab275284b5058f886e3bc680b7e7351040a66fa49a5c9d7921233c16a774691f0c043b81bf5ad9820248adebdd2cb5ba4cc84fe34f42ad89e8aba98d6cdbdbcd1f66de981ae1d336fe12aeaf99c54bb6b3e1a9907ece942ddc083c80885cbd0b9948e4acbebb2fc2b3069428c10eae3906c1161db36d54d286cd2aa8990a7051e5e3f5140041e02f150df3bcb8492de39c92c498d4a4b6551d96d23bc30f7c09562a780db3aa1ceeba27aab825fd6949c6773ad7526cfa9d97b186c7fab028fdad98f6be96c4b20c749b39ae7009a7a19a5d5a211b66534f0add5a10989923d6a9ed8c0280b45d1ba2426eee5e1b9f9aaa9ae0f0236169f2252943e5cb5bb9e3265bbd797c22e73928bf8291ac26d458a6881527e45d736de66932b9debb1de2e97f421d3a22e3c221cfd1cf22ce9059c06c2f8297c4badd62d5f6d94b1bb21ff699203a092db91b384fd19c765cabcbc6ffe1be6d675eb56c5b7fa7d75ee8584eb31a932a6dbdbb5419fdbe1d22eec682f50c1d4d150efb84d14434f34624c8923b95a04b7edb67b9a3b079bef82f832095037bb840cc5c85903f76b25c96f921ca73ae808bbff7b1e10b335e2ebed86e3c0c9c2923fc9d4ea53274d38355649ff83e90e967cccfd6421d355cb684c7130ddf32a5e152e4c6b5b538db2394d14e1a777a4b76dba2fdca0a8a94902dd367fccafbcd16c9ba88f8f8486a0dbf93d16c3ba7a63ac5425c636c94f658670a5dcfe279031f5f48f9da6554a6c9f28edab6211bfcaa80930411341f90a5357dfe6bcbbe260292969b6ea5bcf4ee2851d5ab629dc33278a2877389debee266ebbfdd9de8b88814c17d238fb02025c58a732656f61ef1ce970e8644673a3c106f63be64c443916d78d080e604a244f5e6e25149a5ce3bbb407cfdf91dccae3c38959ed8d3a8b67c91728012d3dad0a7ccc28b88b538c0f6671b7c26628051f44a0b057a9c13fc149eeec1b22628a65c6c42a717167edd142a2237f186dac05b287efc8eb11842927f528601bd029a4603573a2c20220d922151afca81e5743feaf8ac297cb63b042be98d271c02fe8668f23624576fefde397f7c494a0d3bf490ec8bafd50dc0195e9c2d9453060998537c6aa575d75a604093af303d97e547e037e837021600f3aedb41bcfd0411681ffed3d017d6cfba74aa4e4ed27238dfc5992ef944c54d9aeee38d0f971acb2837920277d402cbee00022d381c219ccae18f2c5af228a43d34f69438a4bbcf8d25dcfba05569460d24f22f2f4f49c844a1a5d0b6c1f6c58a706026c9a155a11f40ad27aedb2d86ec8328c92c6fd032358c10e9c906140e6c2438e9279fbc1b50c8b436b66cd5986e29bf66b78acd240d634be42158b46dd3667985bcd51ccfe522f2decee6b1bc407d1bbcb938ed15934e9f0233e4d6f9b6af51cc48f98d81d87380dbb54b959a605fa122ae9d9c7cf1157b8acd2569f7f581b3c605dec1137149e34c85e2fd8946833a63bfa2762504a2ee767641a24f6f64f0a601705ee1f5b7f94871691bbd1db9591ab8e2e8ec1d7ea5735f340536de0badafdd342a44cc596a0276ea621dab3d311b484d8b1e4c820bac748c9820fac3966c21331e971c207c53a16fedc0419a35451955af1acdfde11397ea08de24ba8476b8799a179356d308e0390fe88092fd06ff9d75dca99fc7c4fc67f54cdfd49d968904dfd1cd16a43cabfb219a8ccaaf70bf4a3ddaa5c14f59c949791f1a556120baa4fdcd1a69128fadffef5dd4967dd9b471416626215fcc33b8ba2b579d843a36fbbb9866334005233ca4af4ceca573be48aecaf1fa8ae5bf90dd9d356d3a0e6be396e862ec4faed4acb3ee9a66b5c45520575ae230bc4864bc3466eed01351b25236137e7d92c25dffbead209058cf4e07151274aba874b7968eae310a998a0e5601b54e6fac3f3d82b46c358503ab7004dbcd23ebe8cbea11bb39c8c8ef0c5860775288bfa98d000142c6b274e258c04f59338feb9e7182c2cefda304e6e1b9de2084a2dcab4bc3cd5fc5afc2ee2581b89dca193c69bdc9fe5234cfdd07fef97873242b457df7d448f966ea1119d41dffbae1695024ab6c30391d5179766206dedf43016558b3dab47ec7fd4f16ce882b70c11e77f8987d7d2ed420da1851844ea2c7245b93cc0c92e32d3c5813fd46bf1a651bbfaa619484a7fd333f18f2245f956a34d73c44789f0aab711cd8f84d6ec074c7d634ed11eea5050210e0cf24e6bc70b1db0142d35563669bc92fa0cc291b29df413403d4f797ce7853b06cbb5365b0df421bd4f3d7ded3d97d66d11a7e56538dd47487e48dbe634ec9d77cad4b0d07e5623ab4091935c8cc3f497de667227d2aafcdc93f36220df9df85b9509837ec7d65e821d4655175f20c588b970e24e15e8bdfa626c7d2a85726dfb1591d7343e6005055da56f23c427ac03b24ba6081af405d1da63cb57cb2181f71a9d96edd1bb3766c5b110b3fbdf044555a616a94c9bc5b24e4ce4e97f9bb88b2b7a5c22b43f07068438d99bdbc13689f2a8f189c8b959f5fc3eda1c4e20245d9a6101d74e523356ca3bb9af73f73b07459993bfcce80357b7cbde9a0dc5f123a4e8c2e9ef07d1b915d9d1806d3abb6db256a8aac2fcb8abf1824dd23aab7daf780d33f166c7680fa19141aed3b7f29d7d506a5a6d6797b210a6144c2a6aee56ff2fdf7a0cb6f00ddfe0cc909557925fbb30ef2cf4e1dd16b909c49689f7265df435f915e1748c915f1ed8bd06b96e0f7020606f0a095791041b8827ba6d107a01ace8e46efba90e54da2043078e60fc391c68d925c84b0d2ced91c07e7562590970e0eff7c111ea4b0714c31ebf9cdbfabfd8b9e11a6468f42c65aadf14bfd90725077022422333c20a66708a9545e23d74ac2e08f1820b00b0a2a2a0692c56d88fa40ff2a3138792a6c89e9c58ecf353cc0e2b70b3bb0268bd571e70bfe92dfda4086abe7960f9ec5bb5b09ca493eeae9f13670c35de07d445b607a9480dbd4f9dbc2634500537649516e459462f682c6e38b4c2d1d178fb071fcffd3cb81440de96044dc5e9574f3cb9b55c07f189dddb70efbab0417b707c204660ef0197205136ed6f541b323d3400c3573eab9529db2db124f1af7ba3a29b3552ba3a961c039a5c0b4b3c0eef932aad9092ead0d7be66e6f8a53e3839effba5ab62645745d7562686972283c6d703087e4cee0c2e3ab2af7b78202b07c37682cfc37388ad4e28e43b8869f1c1efff7d9677c5ef79d42ec905066dde3ed67321bc1dee961037226023b58e1e24cb63372e151d68235c999d57551acaa2b0290d13f750e1ae6e8935ea45a4685d935bcf9947d3d6a77b615c771f05db7d1bc1949450ca0daf157bb798b5693dd3382e590c739608fbfb59673620189842e62243ec595fdda23b5db98ddd2887eb224bdb97860535293d20937c0c8d5cff0f3169530357cb8d0cfe8cc08c08a732bb2dc260b00172de37b5fe219e38be2acb124db269d6f8579da8e7cbe9ab06e77128ecbfd7636159b56f8825e1f0195f32248398e480f442a948caca8c826fe06564e6c5ef1594be7ab87a79ededa464b6994aa7e79bed6318da3c2bd73502d15849ec31969f4193b56ab17cec87501f7783f1b7aebe26bc6f5587e5f5348112b0fcf65c479a9e69fce4484b9a84e02ba915d39bf4c20f1ff2de5f0f043c0168703ad12b1b0dd8127224d577c8a4558d02c42e3f2742b6eb003c2120698d096d8e4097112d25c18d3421eb9dde0cdc170a49cff0da780a2f6b953e6a69299dc4af60e124b157ece2fa5c52e8264b56badd4e68c5aefbea17600ce1d55f01b5c259c3200b63cb2c17ec1c93ad2011aa892250a09cd0896e2dc1b4496855f1561bf3ad05a27cfc6e37a1250dbe88a230f140e4507503a4315af642182421a70416da9d25d1a80bd18dcd55da27ebd2e1db63662be1a26aa8dd824277df9a84daf333560769105c55163c1ad4dcdad6ef31582b276f01e73d34dd5bb7afd1a75de67a200074587d39507d695e76f5227cb9d7838fd8425b022adaac70240d8256ea57744ffa424692e7466fc5a3de90e9b168d9411e236885800d461144d7e676f2c7b9959ed39efc9c2b318db694229857177024d29cd2fb9be5b0cc02b95a550512db7a0d5fbad4a511dad0e253153312c3d784e655813a1cbe465bc931d68552e05481f4ef515056b0f2b226db8f1cebc2cdcf9e023a0a0d0c8da0b41b1d1b0031bbf1a49ec0e9fd759b0b4d89fc1d5c528fffd180b2c1a656ef684b4d4bff867ddf51d8aecee946494c0e403b13184cdb3572cb2cc067b9459b73cb37e4df4213be61be8c33da1be8cfdf9003c29f3336c6c3d656977f4076ca90a336602cc9d73b34fcb70aeadaf6f429f563e7514e63697e76877a1b5ec5f74a0a6aa0b63c8d39aaa20f699c63f0586333c1c0545a6a3cb487e8e777ba106880aa9d8aef2e998f5ff6a898c702a25c2b60673109542b1da140cc69733f4f3f69266b1467ef86182ab6dd09f16b5781898e453c0bc13d9dc21042b2eb0dc6db60f7fd641b8c89a18b9d8f81d14142341e90cc229228130d1856c059110dd520716b42dbda29c10550fc3b004a6f99e1d174c89e05ba56578a0960a5668b0ef64601570fd02e428eb84e828fdf2a614289ecb75f4a0320d479c68d069479cb69dd9d097565c8a6963baa743c1ebac11ae11dfdd85ed6d04c4b333eaf98e78df9c27470b9388496ffab771fb65b8bdc3ef78f4b39aa53c0bc33bdc71f182c18f6599c1dd20557b82c3d04bc2bc0ae4d71d91379da10139c3e5910ff9883f2872b1d32e7bd48ec49dbe9f1df5e594dc28d475bed7c469c4ed2a8690d7b44e307eda7c5ee0909ade485eb254fd19bfcfd17dd940afecad25975c24c8dc9327ff982c5a67c66c66bf855e522e1e1d1a0086171051d4ddbbbbfc97830a75ca8fae1b6ee33d33d1384fccfa394278cd005ffae86f35d37e295fb0535e991bddf580e9e70a292ed3dd7645f9abb09ef906ae1836080aa146382786cb54e243bfaaaf1f07e60d24c7712c186a0d3e8cd81a8b582efd36374b528706762460c408a713f66f1c2796f0a8b299aa11b91c1b33da898b741040d09675f8f98341519e01f7831382b248dff259da38ff7be35f6f8577e5aa8684759a1e9f071598eeb40198a3317d4daa99e4a29fbde8ca293b7a4edf714ab42dfb04e7e41f93db434537a582e6616a3749e3ab7549fa7c9059046c7b7e035af9ab638f992a8f3ca1ba5da9b9b3911849b649902366d922dbba18d8351fb95dfebf94ecee7cd8969fcf6e2c24c1e0831dbbc45a66b70f791b42ffbba31bc782f3b0adc73bd4c6227059bf3212554da4e938e96bb78e977e1d5d88b54a0ee1262c7d56c22369e1d3ca5c3b76078d8f43dbc210c03d6ea99626d8f59781a73772d191266719791d9c75e3646593ee7b1bb6854ab9c651ff41605dd01b6ed9b72a0714c7d3dc93164a2a8e217c5e680a85fbfed1cc5d0fa450287d2163499259bdbdcbec34def74c2a0a830ef3363b353776a5bf6fee31681e232867f2ce71d7812e67abd02332e35a4e553b155be075e9d345a199a357e6ba2f96f3b02e4e2ef01a3a4426d8a9e71b28637e35c18ef4149027ecfdb8c8f4e0012628fb484c4d1461da88d90be6e80304793b7cc3cae1ab63692716b8901c4bfa6fa429c4719a141558733b1a0c06119a83287aa774c09fa7b86ff0b58713f7a2442c459c2698fb2bb2d5cc2a83dd8955769644c085410749ec9d4b06d4af67d29806c208368189179f035d5ca09c1328a90116890fbe122e12b7171b20cea8d227c5c2eabbd369cbe70c74a2a6b824a33690bb0d70f7b46a690d31cb1e062a8bb7b876fc196a2a035134a5cd2064dfdc8661d54775e5728531c634a855ed487ce7a119f9a46cf1ef3088750e3ac0bd834ef706e11e89aa2961bce65283610f5614f57b9cc2312e0ba4d7dc171521e9609afb102650c330df93638da8823e20c4cde7823480d2805dd601dbff22493ee699aca55e9627157c90e10578d4aaa4b29be5efda503afc8ef0ae934ae9dfe800bbe9fe797c89cfb260630efea8e0eca7682402da6247d1fc419a7377e40a59a6ee7e865c4b5a0bda6d7da2b5e9af12e3f61c9455f82aee5c210586f262f9f5c0f101436575dbfb208085b2901d757a5301398c213e733e8733960850559703c25bc422f4db02ee8cd1579b3cdb508a9409b48f227213445c0b4502e7aafa5ad057ca42704e8f73fbbe2a943f3ef56d41214308032826aac19335b05695029584e95acc0259924254cf5c2eeb87866c822b05e41fc76fd790b220046ea17e5f09e2266b456ba10cd502ccb2901c6252023c566c81ff7913638cca5dd60a447c09ed1d28411def6faf83b64b38e8ec88f8773f9319a773ba247729f1bc6c8a21cb3460b3299dc3d833fc3b1e8b167a318bd7d272f32437c64f11f498eaf679f503b33cd112ff3a60355c5b221d63b1c6b1dd1abf70e10bcc967e72197a0250c151a094d6ee8002249e8da3fae723ae2be0914981b0b9f14fc09ea2c277e15b34c8b061bedbb0b4b0894ea6c8bfae3013275abc17cf85f35563fee7fba798796eefca3b9b7dfc833c9ff19fc2dde5bcdb5b14ab3c73af3018f42e06ff893a6f0ef808d73c39a445c63dba3de40bf4b4c883e0d31ddeeef89ee2f590bd18a90c9e2270aea983727c7dd4de48596311505fd4ebec19e94b35e57cb1e22656f522711a031a850d4698b2acdd611751b5582a3b4a0da1da9fd925957e4eed846a4b8fe9e63d802929281cab4303df528a9f376a621819003379c21a6051cbec0616b2a74aaa41070a27d6691e9abb726381e4771a90f8128d787e8c56438054ef1599f9deb08e71e505a5243124096c093dd55b9605fd27bc940d47a3854449265d4d0465bb620e6251edb459bc6b3c02dcbb6ab7a5700f7d42279cee30fa96ca6cb27bba0d969ddaf35007c2aaae02053a5deb00cd04c721764be05a7537541f44deb0623f84904774c9419a69858da1ad44e1940f76a3c9db936aa38bec4b1887a04312132d56f24d86b0418195a2d2e4e1187824bd823ca3049e7e8ec0e9192143f95e572782026ee5d1c3fac2421cf21fa99e166d9b91edfb499a2e487d8f066f669de9be245bf3adeffb12a9d5f84809c11d6fb717df209df9feba843dea66b5c8dc7097fadd65a6948c54f0d6a4d136ab04b2737bca19416adf0a56d6585e326fd4d355cf854c5f54229fcc31ba39da7b3bc5dbca24419553b712081fec9b0032d5f2aee4f09d801ceecc0213503f7564931cb9c882ab0eefba982dc3abf39fedfc605d07b9fc4a26b095a9e432d23e53797ba38037ff6be4f20f518ac9fbaad1e127de8aa8a6341a6920b50acc022fd6a91c335e9604db1626b6418e2b474c2ad2f12d18b438e47c45c140f84c1c589ab270a57ead418bb63a25b9477682974de25bbb3e041e1753bf05e5e61dfaf9fb7a9fd4304775e56349b8f02a8d7a9af1b8a18578dec057f609f2b5b738503e3ad603873fe94d7b1d5f65beaab4ac6c022c21ecd5034e7b822acdeae998620c08204cf3f138783bd38ce6cec784265ceed38299845665422acbd2414da3ac791079f511b182069d3f6bb986bba4c7b9632bd48846284d29e7b701d8a8b1c392efaf48b103111bf2fbc5508c9ae5fe0b82b5d79613d3ec757ac67eaed557383132c381f5772f28399fbc3ab35b4b4ac8ee5fc332b6a1f3836e09592c56c3513588265e0701bf4499fc501e2ec07c27993a02185f67de2fa2508ff1dd187250920cc926c1c3514cc563a8790f045b4b23d13b88603c2243f99b7af2f9336eef0a73b9a1f18a39d8c7030b8cff393047a93b6002572b289bad1ee7461831113b4357a475e1815195c1551ed1f1a0b162e728c7e0cd4cf2afb937f3f25be375335dc768b6d96e63bbce8ba075dc2278944487859441da84e01dcc9139021f52996d926931074b872bf5be452b1f11b6db0802d242617b700eb479ee2dde20fefc41b7e2e7e43b023f0a23c977cfd88a7e0177025c5ce824ebabe93aa8a3001de034ffb792dcf9b0ead7ce4be534f06b43eeed04f600b95f0864ad4c7a9dade4f5edb0b39d2fcacf683aaefec12d85b73dd8bd1dfb45be1c9cf024a4738305784fd2d92cc51a9cb73fe2d7589dea32e23ec6a44a1877cdcf5829558108c677d5b186d4b25777fd1f4879aa8c81d447e9a65407abdf6105390c0f035b847b65a864a864bb22f7b9158441386754c66ae68fd5ed16d7b3e3c9257bc7a813537c84063654520f3f614f8b19a433abf3edd89ac35683dd93cf75ce3177ffe3bc75f2d123836fca48e89c5cd7826ebb6abbc08378149007192efc85101074b94b29fb1c4db21287ddd4083fa7a66b8bc348e703c67f177987af2389bac7dfde974a18544573eb6e693b931a38327d8a055e36d3e182a6f0f3aff4d123967c01a23d205eb17092582c3d8f084f60ad2147fca96a221dd28a3e80cfb4018d9f959fc138d414da072df2dcbc4f4b3dc8e2bbb2c0636e8a33b3c2100c7a46e08dc2f7333b9126432f33ba9ad4a8e94b6e15813f813f04832b95be66fcf909350fdade938f556d292e9e9711b507e0c734a68c87b0f959633d87e044c036a2f07705a3719bc67654de850a8bca61927ee3355ec05e26d3c2923bb68188a0af2fa953d25bc87923a6f1ff678273c5772dc92706c993e35327a04d1e215726b66053154c905a4e0c2f4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
