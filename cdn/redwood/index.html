<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f73fc5395caa5524a3e07bf7e7a1320d89f263fde197bc5a73d2eddbe377a113710445b23d1a367afd1e168ad3466a55efa15ee834ab0150e1c3a61f0a19b83515d556db278e7f757d8ba2dd3b9fc00fa8583f8e47038040085adb24f63248495685ec5038a658b5c07405780599a0e18acec1585e2a189073db6639277c0f1191ee42d0dbc0bf93b4c9a9e07bc9529fe4d8f1c45b678e44c3adc614c46c05cdf671b8955f8aec14bed95cf5c8a074fdec0ba165ace81349bb5b1e69f051a2904c5117cc105f315702c1d3ade83b30cd1f3860757f21936c5d2cd2fe1c290a80dad1386304a387fb6a43eec1f4e544442b807e9dbc20fe1f11d30f7c69b0468cc66668dfe2df1086857da284cac539b78857814af04cc54edbfe2868cea5e2feaa8e90e870cbbb14d20515be27b263772589e0b85251403ff2d2452747bf8d88a5707e9aa9d99ddb3122536cfe9fc6879210920420f8eed87882f73f9824a4a2eb0b061da5f17a76323608be7720fd5fb95f8271d6212ea49316013cf2d7efb23bfa5c080cd1a06bd5852711ea8f7ee0af19a40d965aeedc9a69bfd59b030424e69dd1f91b7e055e6d3a6ffd5fb827b211d5aa9ee8505f67006735033f0c1f6ac8b5d53405c3a4db7fad4b3b644c797a531d2e7042e91bbf751235c5c8094404fc7b2f58244df9777d7d29c89c1f4d70b0f0364c5c8ee446332c39a2b9d1b51322be8ddaba0679d9a3796ed8066558cb28b7b062dfc9b45d280180c86a1d307779175acedb107984f7d419bb5d7f0a8c074b1eee2b981ab058a1377643fd67b5643d9a5eb0461f82749c1c81bdf2447bb22a0c5c8ae560badf2026bc12150fac33b732cefd6e7bcdb049b7111a9d46f28d9472eeb8a360b87253cdb456b4755e00b47a39680260f548ba8f0d07acfbaab83801f1576376c3d936d2bf35a0b84e91c515785e094e5079d7c39255be25e7ba1064df9baa384b1ea58cb158991a3525d1521c403d326bab222d28d47ba7049f13c61e91d7310fd69e8d95efde050795b9f70a843bee1c3224d6c57bbba09fa48e94fd860fd71485f8f7ddc16e9aa921c11c03bcaf4b892c51577d858a29f4d07dab304bc5171eb6a56124544840597a332afeace4bf30988e79af1500166920646c23c7230d2e5f80e190e366cf2b29b7d55dca3db90e719022e60b0a8663d88cafcce63399ce9780666808bb087fc84b2e52adb3579be58e6a600bb34656f43720b6e26b7cc8adb8b24dfc9ff2f6086b54da68ab21aa0a630fd9d434522d322949024288272cbe6df7178895711016611bfb4b6de73722a16bc013049e4e43df0eeba5ef49d002c684f6e06b071780f7af0e430e41599e48ed2b3953a394683540126ce092366b0f07b954e03d8be3f951f81ffbfa3380db000f2a865fa367b52c9d98d1ba9382612618fc617e0c302a82841d1b932319cc7bb8d929766208ed583b1b38d858726821072f1defc305070598f0570b366eb392210c6bef1e2d58f029acbe3a57b62cf5a7e5eff86c48ad1e06845088ef6f512dc91d91f8c47f089d9a58345e07e8fe9c2f6b068820d1378031a125afaf0a0eceed20aa0ecf3959cdb64010e5aef54e1aa091d064d6f7b36d801a774dc3cb118b36120059207c8e011359fe58edf7a518674e5e93f5fb68bbc80e25c431d3303c0474d971dd428d19f44808fdfaff0f873eccb9dfadbfcee090eb9b41bab40a64fc7186b0c6f65aa0cc95a49b93bd77b4c039c1a95f32a4879e55dc4551d44572edb256811ebec911617ef0436fc5c09d0a4b5423141e2ae2541115d68ebc6bb181226a79f25bb797ca820adfdedb214140ab8a46e2c2dee5b14082d197fa6a8fcb53970434c462636b6c15ef301702ead8aac48e8c6296bf5687a60b1d3f802c0d36303f34eb3a51fd8471c396d6417bfc2713422287920e2568adac59377209a1acaf8c87ffba4d222a61aca178567622fcc0b806c6bac4aa7e03e31b199df88b4182a60f7640709c83ccbb53f777eba2f465cba22d315cde668daaad2028919ab68f0b8056e3156aac725f156ddc30525e3a77d9eec9724aaeb02dc047f8d1875ab939b66030f52a7cb1ae10180228ece3731ab322686e8658ab785d914b8dc237564c5cb6136d2b40bf194454809311ca055a14a05784d50a600d36f67e2f4b6fec6bf5d52cf6143513a925508d43c977a77590e9b972f406d73f11d8ddf8f562751607f8549bc5c317f0f73561a750b10eeabe0eeef770e9d03105737adb47639192ad070d813d308db75e016e2a3175fb6a67daf7d17bee7a979f31d35611ae6aeb98ce53417f44716fd04bd32b66e95079937432f59ba14083fa288273899877d27aa9f533bd99a3c4b6a6c3d83dfdff007e26451b4e9fbfb126ec4138aadcb621949b6d73154cc5f87dcb6aebb9d6e6bdf606b840b319eded42c22bd2620e4f075368ed4355dcdea770e18f9215ded1df2f1060ac7351fd9b1f9123048d7ef44638d3a2b255d43808c7868ab195bdd0c413d27fe5015c43da7d8bdc339cdd3b3390cc19ac1bb6b9a8c8bb85b68ab60e9ad4ce2c8649270faa1f3899248d88cb9dc9b2bb19d31114724d0014c492066fe1b74bb09357f027a871ec3268f3a24d8736c22572382ba5bbc4e00095a9f3269a720e9ace27e734dbba7118d40b54c281ce0746c8d164f0b971a38e8740d16a71d9c5a9df8f4fa933894d1323cd1cc162bb5bd8a717bba7f1d9ad0c038493f39dbe60126b5465b89ff438f15e25f548074066c5a3b30f4edb7198542ca5d2bab230138b89414804d917a8e33a2f964caf41ed88688920b3b6a65bb5c00787848f9b71d95e36f2b17839195d2cf4c37879ec4fae1bcecaed097789a645e409075284d9b0d62282c1c4b3f15a354a73d3d33f890f60f07abe8f3ba5278d05032c4e59c8770692377e40603d133f416d107e81188695a977409cbae593a5157e82f01aef535faddfd9fe92275f0678d49584e86641188ccfb7a31aae0b6f6d203e79bdc25fd745869b85502930c2cd2ef733f0e485d143bb2434ed0378528c1ad77c6cc4c26e076a26e126f52a3fa17510bbce5c90809bb5e795aa6270b54a7c3aae036e694f7532baddfe5e89c6a4c2d50ab64f2dd33fbe2b4820582ff19f98ad3b2070e084ae0f594d568aae4de2adcd3b7a4fa3143021acbf9b48d12bce00aeb6b0c7198e1ad8b0d0487b943090dab5d74b02eaa768a629c68ca8814840e2f3f5fc2379562e457a7c6c34979f3f83e17f651429746bf8b39ce93c357309d109cc83bacbc129812dc439b865775df3ed0a893ff912b672e596e2902b06ae936f1891465959a9077485c3e77a76015080259df277b41c4d3d0e92d70eddd81e8190b5dac52a7ab8f11b0d9eb9d7ba74232b6557c25997b91fefd5e75bc83b8a909e83f4a352191c05c36fbe7a2171b2bab48c55dbba98345fc0a540e2400d07b8a651eb446ecd1761b8dac1595942162ca0da4a381d12846330aff394f95f8fcc9021fa3355e10c674f8ef8048e28dfbf445c3d0b013be3fac521efda56f9b1e722a5251fbf331ada58978e6c11f920cf3e115c50e6a5193db35b0108c08af60dba30dd429cfe11d117350105f76deb260ab6474d4c9965ca9086c1de38cea5d462f9b5aa96c1c12ab6da88ce433f9f2e46c195a59b2babe57fe276fa9c331b3684fd08ed1b5b03afc88aa93285a77350410830f6d46f35162665622ca26e8213cd5e8838df227bd908c15c4daf87a6c640e99fecdb4a3623bdbf9bc997be3e9ab0357b4de4f9f1fa3a512fcba03399adde918c2ad85a3fc230c33ab861bdc5618376664121472e71d4851fba2700de4268f90ff35f17278f6e9f221f8ecc973f24f4783097625bf0c94c71c8df92f7aad409dcaf0d4413ce2811d9d106647447909be9711a44f6415b6f66ae110f60e1576e5e0509a72286fb5244be1f81be382986f32f770dce016f38d0ab1facbb53c602d5ca64c4ef1ca2f94fabce346eaf19236877efd9422fd18ae46f5d1b2008b98ee04f741e0feef537ea8938c6a40621e71e2bc92d6e6e9ca9d39afa50a6cd5d484096b70face69749b237663867d5fa508ea65b06a91b33cff99e868bce274b7ee2317048b2e3db992c9a5f715b9a301b5d9350ce1a733a06b4f15cbc20b43c049328ff135e750d61bdd464b990b696c1de0dfe19b2cfddc3c52b165688249897e8f97ce0cde86835f6a0591bf87084b91028c24c5200264d0a74179e6bb3f8c0f0dc8505e9192d63ffd255e188e00feed54d4893d34986f4f5fd04ee8f5daec49601feec334282d982c64b448f3294dbceb65935cb9b50dfd9e0231b37d101c542adba6ad801c51651824648b38569af35a0f359b9e1f7f3a2133ad7c0efd7b62e6f937b301f0186e7abd4afcc29d38f10167994b0c287c98894116194824fdf618e7b98b8b66d1753529e962483c4faf395d8404acf4b109c8ee8400f0648b54bf932b5fb8b69173a752ebc28fbe7af4c52f9a14a3fecddd569dd9106c7ec370ffb54fc9812d34bd346e0803e1fa87dcb182d0ec976ce5f307675c15e2bb32c1a39d0a1b11511360aba97a2f1f325869b8e8472ef81a216077df822ef8f0cb21acd77a0f2a721b7026ca21b59734254c99b87cb3d63bc91f26d6cfc0cd4605c7cb92176bdf84751788c95f908b40d591d181c8915c6509384d09a9c0d689a9ca20042ac6dab2f4212d1299fecd64fb5339a8d661c132df5fda1b00edf31680071968471c2270bbb83734d75a680f4fe43408eff7c6a8392df79f49dc6eff6de0fc9f8ea6e377f89740e62a91a5ae09092c08405e2c83b90ccf3b272bb38aa6a38a0e4e988180ee8492b8da230e2ac28b7a6cbc918decc1e9c3c4eb2a6cab19aadfff158ba2faf049fed652f6cd93c85f59ccc8005f4331066be6e611c12bd68c10470fd3bfbc2233072e08ae6236762b3c70f2bdb0353c3e0ace9d8f9cac9f0e876e00725ae6ce9d3cb9db37cc5012bac339d06adeeac9deb302c23103c4dbff1ce3a1e59c9de62fe4843cc11947e005d77e646e019b8f6c4fd642949b79d41b7d75ea3bf938abb3ff2c633b72e0407fed1d2eaa8d49d8ac652b13c1245b5470ad73dbd12a2dccceca67d04870e8e65c352175db52aa8d1a0b84ffc579b73cce46b30fadbb706bbb0d04a9aee0ee39b2c6ff9e327988b332fa688cbdd95f9e294d8f89eaec8525fb8342308027961d0428987efdfa735ae032fb7430ec9d7ed27cef4af300cfcd164c6faa7e8c6639e3804fcf5d0d0efc7b08dfdabb5546bbc7852e60eed763a688d1d3473379d65a4276b47b8e091248b61229e72a13e778333ec2b1d318130ea018babb9d7f7ffea3cc5e30ef0c943b831000f9cbc696582b2ee6539d28d25a10bdaebc7650a818e0a748a08059ec8a399a3fdf4d3a484ef4746cb26aa6db66bb20d26048145298a660a23e053590b6cac2a98950f2918c957320697c67602a01310b2254fd8de208ef47ddc5634e326b3f6f83ecf81da6a1c40b7bf14d0828d0ba29b93bc99a4d62fa70597bfbd0fef22133f220f575497b91eef027799ec4aed03ed16f4790e7fab561618b083aac81cc0de9556394e4b57df9d39c7910a5d3d17059c5971c4ee41f7ff466462846d40d8912ca876c8f68333d36a4c9923ba7e8b5e0de77a7ac382591f1fa881f96129593a82d380e28302ea95df5404852b09d50f8b06a0e1faa570a8b79e425fc7f9f7fe94206ec7b7aaf5a1c6585ed763e4bcfe01fed2033b0e560f283d22f65dbaabb6179f5e58dfb321fa447c87a8a0c10074cf521c0f7dc5740776b199b4e569370e3eb1e011222e775181d73ebea754800f7bb9f7a896fb97547fba68e81a5cd41def3d9f30bf061fe18e0af4461a7af1bcfe10acdf4fa6491f57c8bbd10bacd29b98cd88b5bfd12940bc3329bb2d57e866288e7769a8ae6498baac0f89d7ff9779f9e77555150f5efca99cc45e872e241fd3e4b72d7ee2b00e423cbac663020a0645632228de5c5fed68a7c6b08226097305cdb7e8778196758e4f32121af519125d9237ec5183479eaf5d59b126074eeb4db47695e9e84d39829eb9da844818a841786da1d2e4edfa5abb5031095aac1f1a982eef9580a880cc4cf2d0ddc5b32702e6bf6bb8b9f48c96b3ab1750ca155fdd1ea366b544d49fd00fb2d58f5c14f2a88d507152a59b0eded3f4aedda4a21b26122b278c3ff3a17a605355ce31225556e59fe2d2701373755ede686d3423e3b26171eacda04000cfe2a4db6e5e807b92d453e5a6643bc84a56a8c9806baefb37ad9825ba945bba39a12e521803621ec6e7a693ff323595b2e1a24dc153bbae1bb555e45afa9823637d7fb0e1a6d23d307cfcf3e2ae0177f0fb0ade02ab587ee83a2c8fe0397736b2c6f470a66e391cd2b7446b98df2e1475c66935755773cf05f15c612cdd8351da944b06b31dd4f4f1c082231abfe83d92ce795cb98d53440572bf649b13e90cd210a40c159d91f443ec60827470f9461fcbc4bcacf654113243478d76930eb9c99755209ba984ae48ac17746ad28f8f3dac02bb45e0843f6a633a2770c4535847bce8aae411a366427af6c8b75dc8f2af0c8145183a451c837239b393903f191fa83a88851b3122d4fa5a5ebe0923fef774f865849b750b552bf32f205183e8e8655bc7743bdf50650f793807fb71c9b38ba26e20542525b712b4bfb6063124354ff591d9b24087fed90c86faa748271b748912fe1ba861d9e30dbed01084283c1e4b954aa3b0f8df031efb328ed3d8e20dbfd3c300bcb0476ab0f9fb1620ab66eebbfa5382e31c032cc240ec77626710c664c41ea254839c6f2ebc3e4cd28e25e5da369fd01cee600f9295621621c909d2a45314a191b49b7865bcabbe1111b7a314618317820deb5aae358143dd5fed6ec5eed77e366229b20f3da7967995ac7cd644343e5fd3505a61616007e1c6e42ce70bb01fa6a92edef861d23bec790ccffe18aa3b4f945b40d00a99f21b40c28c72f85f4f229f87336b7b041ce22568e144e668a98d66bd8174f803fa50e8f15d5cc162251c4a829fb63229d96771558c5026cf7f4c80389b34740ac13bf9f38a689bcd5b61ed713111d273950893eec4ac8742cd0ae6b1f787bacb8964bcaa83a0f04e5e86025005aa0b7a6c82bd98b84f29f78b71db482e23e5dbbf7fffcc02570ec954845574d8a5275f133b395cf46ee9202eaa9e029de65a3041f406e560097e707fd0caec8369614bdb520aca849baf1a3a182ad1a86a61985330ff9ff30ecfb8fd0945dfbfd9c672a4fd4e34aa5abe86cd96c9131b0449ca9bdc607abd30181271756b8ca54cd5c2daa8d656717e5a57f74dabe7635b064a6f23d8d6af6fb0023b967b7b55d06a3642315b7c10dd6ef30b6507aa62222533dd249fb0c0dfb03c280f12d7bd027465cabd158e01d40202b387d79fa0abab215c3bc1621d10a15078c05964d71e1546413266e45a703a2053d10508970f984bb473aae26df9beee29814a05af109a3cc5b03d394296c0e155068de79797249b496072e2e25c9d1a6ce2cad8dbbbfaf4f208efbfda2a189816491150753ffac6122e6e3baa1b55c754338ca8b1f67212ba9c8556194699882a24378734497603054579c0698e1d3dcb5c9a11d471712081ec38508c32a8e5ee4cd9c8a6d41fde30d13af6191bc29735a2260a6196039b93a563d0da814c075042dc4b85c019f2387aa6610e8547575a1c1e457c01c88c5947c51b634c14dbc321e6d17be646f3d7e52c125f06f7bbf6339c8b5d62940ea181059450f33891bb0036a65ec250f64fce8b3821c784b08a1c9c1d70b36f4080055f33c81a947ddaa1a0a135dd8b46d77ecf9db72196bf66af1ef325cf3d147a54d279e2fbb7cd486459419eb8bc61d14d9688ea0bd874f5e597ed5c53d07accff2d55838fcb848c95387fd586769943e08a223a21140abbc2b84aafd1a6486e47a5e28ffa98ecc15ef422b6dfcac4682dd7a703e1b0ffca29759d5a3fcdd7717243b0b29a0fa1a994f17aa8601492dacf7a582c1196e14650f6d53eaaadad339c46924a9d54a4cf0f20bc66991096ac000b0918a4554a6c3ed584986d298a18700fb1a1f1d241f38498e8b73462f61ce7be449925146350c3d3578a226f45fa30b876ebabc0c13ed7f805cf71c05a66069ae7ddfbc369655eaae7c007305fe69195d6401247a3449393ca2170e6e8df779d746da741159239aa25e539903f007b9d013b709a19e01e6e69840f476e59bdc100ff037a57e104c9e3afaba51363603f88d86b4e590cd7a54fbc45da57edf60a078613e0da36c862831e5a2d6db62ccdd6a9a0a195631fa88ea4f65dc8611d44d4dff09870d119113af6600dfb27f35ac406c527febcb9dd306af878416bc03af238f223e2e9b4b5e23e2722ff7b9a93b2c826db87eac698e86528d06d88788636e5187028b6e61966e875ff45375951d149374d44e1e4e0fc8f0f4585edd0baee4741c107d9f39b99c5e0a20e80d1dd2ffd77f1edf40654dc994727da3eef27db0dddd026123d2c3911af91879f82b6a295712c933fdb718a9f5946ebea381bf08569bc3b6a52e3f881e03a15258a07d9e5eedba8d4a9b7a9bb936c711482c49f14ddd57d1c9acf10312eb9c28efb0de98cc57bff8af26b108834365ed923f1a3211b6f727ec736244e9a1978a90deeb90c079b1dbcff6cc41532ce4102d4d4df6caca97dc383a3f306cd5094669e8e7bee91e52f121a0305adef78a68a7ae7c729f3e0d751c448f95cd16f4ce7274203cbe19f04c87e79d1c8f88f0a38d025670931576a7caae93ec4ed68a0159b293ec983a4b680d07727dd4d73265184d9bcd86df199b03d241b4d426341a3563db5dd8ed78b78ac9356c87b610904f13784acfd350ac04760c5152e4acbf8c366a05f01f87cdd2989f83e9a2ee8aa5c759aa5712e343849c30988577b37da4f8d33491cff400edde0b63e5c5b6ab5b0c50ce11c80a913e6333401ea441693e101bc9fffcb027ee41108517f813ae0f152c9475289ce338565ef7e0d8215dc277485f152ccb68c4f5a65f2800847d6d125814f1267212c5cdcd136801a542c89c9b6c43091a0851ec6bc4f54350322b6b8fb3f0fa7e443fd33c88e421fa4c16c2111d3381fe6a0c1538f19d76f9d0d6a02630cf3b72bc90ca0f37670eeaf41e0d76191e04f4dbfc066547ecadfc2e58199fb879a1b4c304f4b8b85fbab9c26aabab8c0323540451cecaff41bbd7218a9a04a4f3ef1b12db1722640897614a9b9eff74facaab4170cf791949fabd88bccd4a43e580802ed3de09e6bfdafe980092da4c97725c93a576ed00597067036783e603d3177d457b4779a08254980f1935f262e40b45bc096293d00b54c57436e3cc21edeca5cfd2eb4c82a7e1bb25ab46648c5b74459dcc090bf9c040ae1a092eb8ee3eae5d9da117b06027c0ef43b9592faec2675be1e252317d385990111ab1edea2c0913abd67c50e1e6cb6ba3cdfaa7b8d0b4d2f4c426cf532b74106fcdf1670e1d2c5c3568a0606586298542c724d07b2c7b676c81a47f26a830e5b495e993cb601b425c5b8cf9c3c16bb7facbe62a6729ea4bb9c2a81902af19c06e67ebe1839ff910e3074f7547dacdd1b1cbbb4271317f8c7a4c8a7b7846742d6f794543bb7d5b5f2f82442ce2a756e132de60840b85a38f1d3e4fb2e3fcd7c9bee3185d2f6040e908ccd891af630243f022a8f27dd2ab991f448924b609c45b471a909b7b7ecda783817a0fe03a835de4a1c58bfd059261757962ad0e9a7da8add5cc8a59d5b2451eb44350a06bb0be17df5dfb390955145f247f02bdd2db64fb08d2f44b71286f854318b582d1cfb3f9c8e346fd2c82b638568c82d7a472296950c168c5a948629f75a7d35117d9cbd630fd302eb870cd571b84a410caa5692df2196044f4893a5ab60f23db07f05f7181432a4d5290ab9c2c5afe978c9741a2fcb8ff34e5e0af21f90db6023a4a7fb402cbea037b98b31687c10fcc367df4746c38c076c926b04966454801087fb946d694945889f91f6027a855ed52ad13bd722e68279031a16f699049af59e7f45538b3b6e81c462aadded3c4900a905681ad8d7b69a9b468ed15d2c7ef2fd24547d7314c3b01c893000459cc1e932f9261a2c520aa6688ac2748854aeda436f853751861067d8fe4feddf3bbc1c5c95d62c4784d0fe4240928b748d31b533b6c7d93b3f21af0aeda0b06695eda9bf16e5fee7633c7d541280110a8d83900d8ed8726dc0bbdf05e19214e41aacd00812576ea49734d4c0d03c901e49319a30690ac177041b3d0c2e815767fecca02e46a7af1516871e38c3dab3d807e8ca7416c11f5f48de733f4cf8c12151233421da9570eb414343c29d4de48b5040ed122f1857c3b694d30eb9c6267a6bfd0fad5d7537165dfa14b7e8cb41fe88137f72c26fd99bde2738098031088cc783c6189f5dbdb14f1d09248faf68d2ef6bfa82d8663f71d9b9672d6da480ff4021513f4b2a4323847bf410ae1146835efe43f21e1caf55fba7a60ee43b5a4069cfa14b752390e8229048bda8d497b579d97cd4d97a88de625f5e84c417e6f4fb992c11c9e1438a705007942cbd8b046520ce1159693cb8e3558d5ad7f66ad10612c60ef7e49184eea8e379783c5e9c26c6197f9c196746f02e3c2290a188d09d095920188c7c278824215f4f455717d4798ce793fee1bdc936d2fda2698df16abb48b5862834f280b212f8657214a0b179f1a626c9b93156a2b4592923f335f98d677d8392e9e8500527e4db2c2e63fbef486e6d00bb6faaf62817fbe2453538028bae3673744299a20a1facb957eb4ef785ab4a1551da492697859ac5252fd196ab37f2126a87358a11890e4f304836c0d789351f4e75b7cace7293ebf5070508a3f17ee9c9876f5c5123fa9bd3dd243fea787e19e990faf26be5c194f9acad8c00fc8fb1925f749cda4a28b2a7033f122c4786895e624c3e21955b4d0f588174b8921975e9a85ffc88dcf78c5dce7c14497ce921beb65933928314e58500a418f4ce7952b397dac174b2a4ed44de67b9349a0a1a25b047959ae3670848291cfada3bd2592810724d1a2a4f76a245aef52b52c26e351ca98bc4aa57cb674a69a22faaed0b3763b21cf3ce16aedcce995c81264066a3c78a46124c9de292e42501f5b58b1a9ff63e862f03f2eeef8bde98bffb23c2c46e09076291b18950657800531d2b22501c4fdfc54d5399aae12b0ba5c764af9f7bd8789a7be2d72f21fe2db66e7ce7f3e2c7ecfc47d4e5b37412b5c7068b3c20cc6bbc946ea69057a5c0f7f2cce7475df1141a8f763e3740bfd6603088430e9183418597cfbd6e6fc97e5596d5a988c4ac1e6ef654718773be6dcf5ad07d6a07ad615a3d1bf461e392268db525f1390048f48173cf4a566d569e0e5c8a6ad308ecb11f6bd51ef226cbce585837717c84a15f41f545fd24b31e3e95f69016c230daa8b81a0de005d01401afd74060cd40a78a70e7e01fc02e7ef30254412cd3a71a32ea8b4398974238bafda267378a92d229e873d27ade16d3f909364e5a99580209c721e6a1fd3639d506deed8bae212ecec8f721cd678148a3465da0ca1e43f9f9a69896296decc9d3f9cbab9203a9bd035f5c7a9f7c27e90fb5d46609bd3d43b6d819b48c0c2c042d433388c8e2a770bb5cb166919320ba014c512fd0691c7186a559d920a234cbd32754877232c569481cc706fc70f02b9eb5635e61bb02e08c95b576ea8b856528f274052b5db5018e0462a143d546c56b22938dccd73dd84fe5eb1bcd8c0019a691e290edee539dbaa486693b41ddcc9a25daabef12f3b30acafae9051253cece932f5d836ab8bebd43c799e47f6d3bcac28e97e262a27361d31c089bcef05112bcde390823986ebbbfc6f34f364cb48019f0eac5d5cfa703f591a86bf151f2af52ea85332a0b0a7c8d40edd2a35c7028c9b688c6b2cc19458d195bab7eb8caccdc00c6f002257649a43bd471e3695c8f03a6b8be0291799339840aa707b8ca11a3aec28b09c7833bf0dc2f68fcc272423ea05821f60af5570acc612a2929f15c7bb7e4f1e23f9c0c1465a990dcaab3159f1975c699852e99a9e28d31948ad755279e5982048c43f143e3796a1112b46a1cac1ffe807a2996b9ff6296d49a2c57a803daca840d80c497c8e8e19ef00db5a3b0231a41b0270cface9a8217927c18ca36343660bdf3d4b0138af338bfcdbae52862636fcdbe7bfa6298594a59161974bc84b68ae37524d342ef88eee09802f40c5899a24f769899aff148a20d8aeaf76b3a23d85bf6ead7079368b2b2ab5636eb77091420bf8de3dd8b1506c286cf599c43d4dead6d5bca741befe6ca735f669a03c5e96cdf084004dc61e21d4d2ad3fb8477f8a712e804fbdf5f9a0e41165b3f88498b222e63c6a16bedafb3a1f62ae3f5b41e1a907fbc164be712c56e9480246e9626483577981bf37d62d5dbf34f9fbdb04739771445d92cbf83fcdbd04d20b8e8d6403bac72b2a7af26da8fcb45ef0a8bceddcd5395044c8c310187ebf30f4163d784846a4ceb6593500cab4c1601e71974aa573085808c3226f008b2e8087ac0366ddba9b30f56964e9c9dfa6748f64d92aede835a3d74cdce81bfe2a4a028cf21a3fabf2fa5e4ca314d2b183845702ade03562969ae8a1dee94670b4058e322be51bdd5383c30950f6cd9add8222cfa2bc81dac6be2597e9a00e25562e3e2b877e75d9116e5b165a4dd4888f595b967b991111282385ce8ea32e1d8e45323357f6c1cd55c530adf154721f14e6830ffe39b6609f95502b1750814ee6875568232e6dd969df75d3175ed56e125e742d95248be75928fb6571e421b8e8bdd90e46408656c7a09f5a2c4357fd5a20afec0ea4e8f0135b51740fb01e66e307e667502c5c61e171cc2c3abfa58dda62ea702766fa85fce223590cdba0f48343f692789d3bdb389c24d6b3fd0b8b144d53a73d04b2bf0b261be2ab8ea08d46067cf9c90291b3182df1e0f263d1a7a9a4e2eb5851cc6af0cf2af30431da043e1d48d6ffec0dec11c805bb2b1906336614e6870557f4bccc403ca2ca7201b866af2349fccb2d10f07fe5c1f0c4fa8dfd053eb13f35f7e55288fc3263ac88994819166ad9954dc2364215297dd4f41449365496afd46664934f5ffc728735f32b7e8459072a6b834c34303aa35db9e9355322793f36efd4ae48cca8ad221d56dbf701153e9a60471175215fc281dd45e5e1f5cef5a5d10aeb8f599b734382849c64e6817c984fb8ef82f93a3f8f74915a96ef8789a74bcc08d139fa80f0608b01d9da2c42a55636f7584cedb8a826e2c6731d551229c07c90c23991d04b55661f6def3cb30ff2af7c2b36ff016b6877abc76d3863e6e8c63354b648c5e686b70b05baff256b7d2f4c97479cb13d9b6c90ee97ac146e9d1b27a0fae9f466b911c4f42d6496f3d890e0dbd0195bd3f999ee2870a3909f0c6c931f8bb8eebc1fcb110fbab18c479a41c592013d8dfa528d48367f4bc3429b9c7bb06506a44d93eaed599975e0becf600b57e7f5f40ea8fbb3558baa788626ee04480ef3535c271167c24e0f24cf276f9994d1cf4081cbc0b56fe1fca696e77c23b84b396caa4766b881aa60989f71ca0124af26402c94698ab81cf2daf7917e44cc651d9d91056297772faf35016479c9a4adaf103a06455c9b8d8c8c04cf1759fd1801e9c369cb5048c9e1367c4f3254b97514ccacc1dbfbf41b0ac2e00b0fb993d94d97f4d3b0afdc90972580eae28273adc315e901cad2cba2b6dfccc406d708c526a8a54797dd7b7cd50ec911176d0f7b4ad882c957d7f688769f5faee7eba1987ab7baaebf9acadc2d4dff240d9462d9b423471aaece1af818eb3cde3b39c282f2c5e9efd927590efaafd75d23f7f90223907e0d951e125f3cc52ce339900fa436a920a02fd324c420387059dc73ce52eb7fa5b38d79822dff884af6361366c6fb3c21d3c69d1f66c53a593df7ae90d35ff1731600a4ac291e1d669c2bd466ee1fd91806a7d2f00ca681ecdb6513fe58039649b3693c3ac0ea332e381450c5778e87a8b752060c409b3d96f7a897be18785a8079d6b3508eecd854a445fe418f413bede0d86a02cd3e3d5740b44aaa29f29b0f3c80c6292cc05f4a9f6ad531d67fc4284460afe5813f972b21412d90802effaae750c89e52d5e90dabf3f05a96f07807939b56a6d335edca2d6ae2342ffa4a023b7a40b7acd1971da0b99e3e6d54294e8cf5cda3f68c01a56259884c8767fad11d1e86e90a39185d739ca27deea03f0e7a708ab1c92f862e4a015294275f185392dce38d9dbcb06bcb5b06e5c30101c7c50be21f1b58ef198cf20916a669c61f86f176929366a8a575d40279df326c5fdb1cadbffb214547c04f556f2f8dfd35cc6945a8d80eb29bf77c92bce2ef78df7816dde6b76f9ef53e1657b2effb3ea44cafe9a67698cc03474f6c407c9e3722c9ae2c8130f9cc138c1b72e0ee2ba62187c5115c177f37c5590b82c8beb001c685a9ac078d8e62d6a40bfdda88f2273a7845ac1d070385659254af61eaded40fe77a95298e7c26aa817b71adc56b35fb49541fc72a0f137000e93a31aa501d3d3aba1d0b29a50cb0a2a4e8c109ef7d98b52fcb968ebc80b055d766c1f1482b76bcd642281017cae8acb3621ee456896b7d239ce5a075e00abb5b051c7d408233a7374cfb9da3b5d0a935daf03ad92deca194cab46bd5b16204501a1f7766a4df2203ec1978662c882d64dab55e814cbe2d75ef7ca95b68c19229bee664fc9259e2c9081e68941afd87ebd5c3fffd5562b0d29e6c50824c58c0ef9b26d27e9427a3158a3cbc816b15ac144e3afeeb12668d7c1663c3f1bc61460b9b4c74c5c4d9eea1665251a5558cd83b0822e77d172586cb454062cd8092dae4ca90033e23366b071f4180daf80f73c362f19586c0ef353b69de7418b42ee21307482a7cf863427478a38740f4b9fbe9cd4aeb569bf04b8978ae79234334c215ab06af4dc1b1f46a9aa9db02ebaedf95e448a82134f59930ccff169eff48a31e9fbbd73017339f35f78ed1cb94d7f7feee354dbb556ff0b10d415f5510bc47bf0b56c662fd6c02344bed693713b17795af62aefdd480a5cfdd1365538f164e43e3e96ccadcfd5eac894c3cdbe805c4c1709f0d1de8b05d5e45cac0d8230252e93e3cabbd2d75a697fdc89688cf51abedef2d4c8ceabf5488edb15438de1cc358046940cb8022fde3ef389457a28970077b1204201df5cebe88958ef1c3aaac57d43ff838d3b4671542e57aec34c5b45ba36bc51cd87bd8d5b4da234515ccd1d4a4fe1a00318f13e8e51ba87ee5cc0b486ecb46e46456648e93cf0bb896645f04c3a12bfa257209afd24db5414efcfcde0f7377aad00ca4e57ffe2fd0ab60592da4984a05af9eed440b2c5cae9ed7cd5e22acf8028b853fcb092f641a570500665a05aa9e5e3aa8af339e6a6c5172242a1219d289130f8de3cb720e103039470111446319a2fc8a8e896dab588c5abfcdd2e8f8bf264b204fef5fdef4e341fa74eebb1366c5c83de01030de23ff560f2672a2870d3608350d75a6a34ce97f3532942df5c50b9b12dc624bdad52cc81d0b5f6bee70b65b45effd3b54649af8d1d11423e06937c80d2beac4016b28756a1d80462a865776554134d032cbf3ad44b37b39914e374c54f378dd1fbbd4ad6d2c618b945c7f12a235a455d512bf27dfe95fceab83a8d0664c1f244ed373c5c8994b5853db34ba397a90206425aeb86b929ced575f0dad7455958242abf0bb05beec7c5a3ac02a0e6708568e808952a121ee888552bf9870f6e553710d139c96c248de65a1ae7b7b5f7b41ea028ecde908835e705d46954a71a5efb88caf79466717b6fbc79309e311efb25366c215158ead960f4be43a558f8ad72797f60e35ef0bc78803946ff1e5c6b8edae4b4bed0daca0751f38b095434ff9d655cfabc5b9a25a10bf16ef5e20b182725cd2da09cce8952e509d3c6626ddc2127aeea5ba626a53d0f0c1fe8d043bc5b381e5e024857589d982fae089df718fd740aeb6d6807225cdf6b06380a0bb455f47a83a4bbc4ada1b6f646ef866d76c799451953429a5280250da6b877e76c44543bd95fdf7829791051c5ea3989d312513533c5239e918a545fba32c1b36f85a0b69ef81b52780a05a072d87c67a74fefb02019020420b852b7feb9912b4ac54c0c845d14328368d9d2a9c90529b7336c269d3dc4da047a8666dcab75461d9ac8ec7911a310806f0e1f1203262dc20c6106a135162efd4cc2e0e980de1ea0dbd046efe8cdec70a1141f73b7799d0d7d295c5151c7d3a605afbb471afd2d8f212f55bae6221d6d5a567d2ca4a4363914d029388fd776622bc243b5b4abb26eb1dbc8b6a4bfff5695efbb51e0f4cc78e7e4543effae896765747f03f3283cfb10e31314a915799d25edee52e37507e7a095e62949ed18f9f63209a1a56f85d6ad0bf16ed0429f61daac7f6b0e7265025f7159984ee5c3fc942926cc34ca3ddcc13977543b47479cde7dda6a4f7c9106eccc36339704897a95c679f98473c0b8ef5dd9e891ae16be8ead1464c5a463b5c7568799c778c345ef5737c8cdd68f0fbdb74694de3eeb12169393264794ab602eaca9d505302b62a4632d674c471d0c50e56edd2c7bebf28e7f7d430f236ceae630718c8efe37740cd4ef8a88b48d8a5c3998aa1d5c618357d3aee8d9a5b97c27570e242926f534e80e200e1d546dfbfe078431ae851c522a25e3ab23d086abdfbcf37b6c4b1a57defe136431f69271bd26e16f6358f6741c883c95f9f19aa88468e76097f2907704c7a79d31963b261cd6681cc4838b9266bf576019cbcbe6ae3ccaaf7d5ec818cb9686d7917e4b3b0108efd3c632b471bd221759d8b05ec1938eddc3af060ecfe73cc2196192c8870b27f2e9063d4d7fa5309f0cc67d08c505bc4b58800e8b39dd76ac8631012ede3bd516de59a3be17e9e08bc75006988d70a570584ded9c6035112e774e43994d4948d2b9f6ff3d5762d3f254b6debdacc91441e9518f056d6d6788e4d3f8758af0d21537dce0eeafe65165b98c92562d887dfd2dd36d0ea089ca9cc169674b71af11c3c717287dad6bcc0d4816e089dfff6ea9793dd3dd27c54afb90bdc5de6fb30a08e9af94caa85e6d3900e49bc1ecdde941f4a820ea7125b2443728bae063ee2f98b548df311853532eba98a76ca84d6849396753ec9c1764b161076c6a722dfc208aa9c2e541aec87703240d934c1bae7d946bbc0cae83b4c20d95a63b04fa089d4acf1b283ce05743f59e5476295c39a1026ab48ff0e58879fea422019e0596e5f5fbccd0c3178c893cfd59b196b9f8dca6f6ea9f367624d83d383cbc8eee0d4b0797d69c5bc530ef90bb7149cf82bddf1e3d09992b9156d51dd5f7f038e1686f14eaa13965d52f3fc3418b9c9d14f01d83a817996d7b58cc22f07a49fabb1d22a8e17866e3828ba68deeac8584ab78500ae981997b1ede9b5c307f205522cbd5365b3b10962198ca080f5ab7417bba3cd3ffe54c07a08c09a38615ac0dd7d62c6cb1f3e50dd1c0ac9d803364defbd530ad2326ab83b7cce27c3abec194d4d5491b5bfbe59a8fdde6eea7c39fd0b3fb308bb60ded3d23c7f66b2fecb44caa933d5ce504fefe7fec63c602823c54e3aab4160bafc1b12832ce837cffe6d4b967f7efc8ddb1313dac0e36524e49f843801e0e529c3eff1056aedb7e9940feb7451e588752e6514050e6103b42ea01591c30b3db62200c752a0982626227cb61b3738bf09e4a005fa15dd8ff1858569833539c9248809d1f5175feaa99a886906c863a6c2a6d961e790d1c7c25d58f1c7f3bd03d95212f55b091dc5ff295a7f9df0de5a541fed6ee8771f0d1b3efcc6bf6051c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
