<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb309e968a8e26dd481a545d99c21927b47a7ecfa3bd33682b1964e599a8676468f5c6b4bd6d0030de1f5758de28153546acf4a1f2e3899e45dd96434fcc42d302712bc7fe9a1328f574819d25ced2a8329b6d1f85473f94ce408cd3998e2a20c1f3d3dcfc6e42434e2781a545fd613215b3f6008c2ff2059928daa3edef5cccd985748556de7ee14664ad472132b9772cbeb86cc4a339f9816d3053a15db35b0c12a2b52092a5c542b54e865a39a83a191eae9272e4cd6df34debce364f6c1f5790f28ac6291d89517896b8c6f885b055b15efc6eca069e6ca1033341d6c91786680120853bca03455bf301da26269721926fb1380e58fb668a0d84e26e69fa93aa036bd06832a3133bba90613e24990664b49ea0684d1a367c64bc5be784facd35eef3d3424c65150228bd69447fcf62bc489462060c1e96c6cdc2087c5f604d4e751ebd3694919bd048f2da6d54c93a0672bcbe9fd70b3662d31cc2014f073970a3f43ffa7920d67aeec8e1268fd626ecf87590026a3beb7232d97fb6b00455eefd6f7c261538a7fc590b454dcc85c97e4d578c3c19b8e51b3258537bc0c208ad97369e04aba9ca2ca139c5812d386822f630c0d0722e36a3af9a74c1949d2573edda5a0c8069f5d6cd7b0fb8ca584ce5ea9e8957ddbd61c8e07c6026ef3711ed1af0fdbfc156dd97f301fc76c6776071d7aac85ef19b3f1b61bea014be823f999f533d5277cf6ab774ebccb34ce79e9e2d948f056b4ce05c1916d82496a09f7f1b8e8fb1014927233e38ecd1acc48a886577578b8ea738e1d09350784cbb6a7be338c46bc801570afab3f55ce7773c2150a20ac7a338a1d8550c0b16b5dfbc6f615e89506bea421988b937eaf52fb9570d25da06262dbc667b9c62553567be1b4221adb1862100e9341676ec750443d8c77f041e7e853fbb48d0f8cf495209e6dcae55c424e52a9c2d1848dd7b2e2c3fe5482223131116276f19e0bdfb963bd66ddf0d47365e8e86be462be7d0fb6540f999beeb2f7e1aa9c2c35790e93a88fefbedca4ba77f7a1a5cd6c8140e65031b51a8142f4fa7a81e94b857b4a5108534065321e2207c50f2dfde2c80da95a726c1f05e5a2703f8e6e1cc50de7fa3df2e7ac3b936a143ee5b37c861bbdb78bf50d22895013648f61f80f73bf65a28599157d17f26a12276427bc1ded9dd3daba5a5bbd2b00bf47a3c571fb6a998e45c688a76298a1ee96c355b3689e3ebcd996edaa99ca8e54502d7d862841013d7dba109e82edd34ea52d1f08a40f8be1ee58d9b6f9325b16fe4ce235ad7e0420c29d1ddb6c6488b6ce53cfced33b217d9c9b4afdbdb0f7ffa0a6f3bd29c12be8328069833ae159501177dfcb0cbf1f762aeca2a0ff13b0283e02766174ce5f13ddd3d50e15a127d6278e5bef6b182c361613d48c76addae1747fbe5ac3e8dcd0e77c055f1dae605057abaa390660fbae1f147888ac1cd98f2c05a027734af57c3dd97d210ffc64edf6dfb51c21ccb83d0de9023e87a4530f5f77b9e421d2a974f9d558584188e37c159e55335fbf3c1cf93143e2a68c78136c9775ac4bea33506895a5d5b99dbc1076a3f2a0bb6376286ce582ddb81628c954e6c7d3fcc7344a10da94830bb7c48d7a5bff947a01fc121b97c98f8682821518c6bb0a2dd2bcccc9642a7a63e1bbf1f6434f5a8f7458d17496c3c7ad0fcbb64d60a1279b983fe571341048e2a833d6707db856a75e673f4c067accb76331978676e03f07e58daa20ff12168164853a8c178be3a1df9bc71ac63a36b632147e6c5318cb07a3f22616ac21610a46b74fc72ab61b6118617e7c5d9b3216e352e3d14753d386d80867ccf49119a6713ec30b8c7e01fde562ab2af4d799d42afa3699e13924cd8da1b270adf663e40c39f83cd2d4f68f1146f56e1a55d98a59a95f0b1b94fe74e178492babf9277e9770ac50cde3f3e8c5e080c3e3192bf112baa15f34a30d89fb8fb7af27aaffc64b7c6ee7d3a2ece51cf27a7852cd5b0fd9842edd2bc503dca70f87c9f8b93a0f7b04f14044de010358f0a156d52a2e3829b370ecbe508e14ae61731178aac14b9e9385485caff3f0339cd73340045897ddbe2c396d1feab370473fe2eb859b3e14a8ddb1de0ef6b39fe793da69088ca8bc9b594d569cf619a04189ed8b0fb48a7eabae879b201098a828514f6c6c7b82008e596e88b84afb9494368b5aaf8b9e37b99268e6d3eef7723c9aa97e3fd234941ad6ddba131c2715eb355378c1d6f261deb12f47d25bfa07988f6dff95cc61dff5217e28cf9ea852dbab641b88f75d794156a79c274b16517cedbab6ecfa88a6115cce7b065e0a013163a12a454c5e891d97a953a60dce1d5033572350c8c0aeffd87c69887d3875ba8937d4bb1d0e42621111ba62f00b81ced0450295a7c9a1976789369bf9fd7b9850bf587ee0d513560ca5b388ed17abf9a63878d2806267d21a268910d6c489406f4659c982e7cbfacf3044d17ff965bb5c71fb980e0cf8078354e090f7a759be0e0ff395087673d0598e449da8fac35c2717dedeeab0c2b71979cec339e3363f0630d78b34e376c4695efaa73e3165d42a418f2645f5f4ebd92c9800e88734c47046754c6d12a7e44ca7a3289a20a80bc6cb774b2b86b8b0cbbde66892921122df2084c24e93d32c9dba0c9276dce4472847eaad7dec773684a19bfb09e6d8932f51986fbf972a851d1494e5033908ea4af21162219678818099cdfdf8fe2bfe32bc7d1aa9f1d08acb6a1d8670382d6ea35c8bcc8ccb537dac7f49f2d478b4e44dba623a4b3e57d06569b0f6a35d2148399b2bef982c5f9c030959afaaf978edc09680274b83a720ce52ce53622d5319ec57b7bbc7b54053a9bd86b04c44eb5169b81d7a13ba1ce50391d967b130845a991a49e3955f926d51af70a3009efbf18ff73bdb8f079708883f65e0ddbc11cc6df11cbb85e92d7c7ac999c8a990bf2e1ae48d52ffde1fad1be9299685cb28c61822fc664cb2ce42447fcbe1251cacfffd4126e410e7081254c2680f53db0313a936be1ab992c61f3b72640c3351d62a04304f59f53cc9e6a1710419d067a77ca2bb0916224fc7c328355ee1e71ad20a866ad8f610242b5f3c751148a1d1b36d72635ef118341b6ebca61645282803dbf0241932fc8efdbb615a7025cac1437a6cf40d501440ed1e328be068227902d2e159a34f6236334309e0ea4a2b87d623115febbc387bf09b71622f1707da6823c43c82dc1c70406109ba41bc6a942f68c0d69155bc42b56a62ea14189eb2dcd720142b954c5a3804cf3ce1f1b817a0d07ec12b9515409d73398ef047471ad5afb27a244a3487345a50b66528d165ed433ba50abe600de17882e23fa705b385e2f7e81ddd33f47f2450d0b1e575fe05874672d3921a5de6380dcd83d6a485bb1dc865c877c67940019fae72366fabbf097f03d9a2015909adc64ac5e4400ebb4ed96bc4ed0bf71598fd7d54119e9db6483337197a4f8834b2d29038ed6bd4ec731432194a0a6ad1943bbfcc0f05bfc5f71d4d572ce869761f7c2f80de9c12abb95abd565171d032b69c408010b6aff85a8fef55b74134798b344e4c01d1444f8a75e30dd2f10bfaea513c66df89f7e4bccf4114a6cdbc962af19dced4b732752a48880d15e08803d3b3e8c3d3873387639060e5af49325288bd41cfc4fbec0edf963d32810d17013ceba511424aebb5e7fae78f7ebf3402f93fdd8f1b04708dd1fffe0e7a0e4ce6068d80aa32c1362711e78e34c5c27a9baac1e0627358b9fe38028388f5f55c2ccbd63ac9f1644d2e1828d4a8936e1a7386d30c8fdc3a67b212de0226b3a53ce9932ba9be9237b52dd1c309cc773cd53db070c98268a7bb802193af839a17efaf47763d0e3c6aea0095dbe8f063c83a1a5b75a1c717faba2390ca3aaea6572f5efcba7316fb49dcc9374c035667b5249dc88ad3cb527c023d7bea8e2b2ae0cb9a570a08543df8c06017e7f2b4652a9b139016b9a97f650072ca3ab82872c5951467d10abbb6696518bdbca5a3240c38c3065ec083ac22f84bdd1eab27f3f6e3853ff1e9ee3eebfcb3ce36a7bd30df8acfbb2b0030a9402d238987303da59266530fe6ae564871a089a07e66dd5ab8aaa8fc4bfa236fc13d28a427d32aa3bfa7d27ec0c594159a062d40676d0db1a3e9e5bd25e950c89080e313b8dfe8747ea2b42fbe73ea2f27ac8a36e770e135a8e9fb5e2297e76c4212c95040ccb9a2134d053a246a1e9f521b86f0f40f0f2ab64f9558c4192fc8a53d354d5a958faaa7f3472face6e3586b216b128a68b746ec012cef53d93190f3c93daadadc711c2e386c952f80c7b6a38f424f5e87e48de639f64f5d5086bf255770c0708ce44f3ac9da0f371e6c6ed41bf618c646981b2ec47e4c9b77db1eac3debcf90d69c37c7d14bca19f3d0b022806dc1a180b225cd50e5af3928f95349e8e7993e21c1f94a699814e1dfcc9e273cb653a18782f41e7573529dd09cffb9742b39d3f2d1a242424ce98ddc71e6dcce653c3e15e797610e197a03b9d6583e1d1942ca323a9108abd06224b5a794aa1e92942d43776db9055a8bc1b7a7d62e481a24bb0b47f0384f18b81ff1908fe054c88a97a3e80777746887e8c991265e1c65848a279ba057005a981fac0458d690b1a7b5d30637192b5e3562f86e0b991390fd6a9bf2074510151d45ccd4a1254fccb334e785824088ea44bd9afeb3784c862f917548165c222d2a7a62d149dee58d80b82a5835a403146535bd90525086270c353fdfc6c52dfcad25d3a097f5a58db3234a8dfda60b9471e022f637c81f395723d24ca5a139ebdb117ecb029775dcf70d90585e77ec0059f81c7ee2dea2e0ddc33de5e927214f6ee82a671ec77e3f6ee1b58c696f6d67d0710482a6b17a4151b99dbc6a9b49bc0c759e5bf78d4d7f5a5ae615fe6e920864a9de74fca901f6fe9654513c6468d8a30da047d8401884b46f31f1bf54e09fcd9215289926473df13bb7948f78803bc018d5ce33c6bf29174a5bcef1f17bb822e928db51bfae66c4986374e5b000ea337f65c8e3e85b63a234d739dc64bae8691f9f7d5390487915a1d01dd60840dcf59eaa6ffc48645a0170b2caf5cc71dd64d1157e09bd68f114d041a0b0ef839afcf999c9955caada3e2415c9ef4f8346d7b9f7a8ea2e4725205efe4ebde6d71ef7a0f54746a475d4219d4e9d8e0879b0a5d034a85c1d03c72fd285dbd7efca317675c5c4b2ec0cd828d20e3f3aea39e4ee487f07e22f43929f656f5459490199cd310445c45487d8781d6f6548795756bb8963c6bf34ecd713dbd2513890862496ad26cd8d2da87579c26d63eac0065ffd4a24625cf93b1df578fab7af1034c95af1081d68fc00d869ddf904ca721f1c6e816e6f7938c50fe9439b1c8221254cd1acb0fd38bb75e1b4a910c589e0dd48b93e6f62c20490e11676b4d43e957fe3bf96faa85bc78b0ae410d163099d8241f840e0f6cb146395191e2f298556653a28dcb4238fafa5f8c45cf77572dd23ce054388dfd617bbdda5695f5259644db019fcf9116c7dfd97d7b17cb75f3328eff566d79da7485586ae34feda93efac9f07aa05d1c3e84ea81cd4e7fbf102998488cec5061ee297d0af3af2c4e9a9a65ef2db7c9af14f1fc42227d8f6eb2d4d97feac4a54e49c9a2be64ffe8546284bf071b4cf1dc126882ae450e7b1932a5f91ebde5bb8f664fda5ab025e3ec9c17cce7593a62aad9a6512b0bdd37dbc581241ca132bf0207794b1577c1b153e0aa032ff30d9025d8cfc3208bc38c12fdbc3f6dd8ee3085fb3082a803aa61e019bc904489d90a7ce40cc5cfb19232e622e5ad55d4274eed7e5cf36cded3db73e7e768f0dfd967ecebf825df2dbf3e83086844707cc67e6e7c1f02192a56d398791e03e1afa83447cc9a5bf4fa17ea07d2a902321aba3c9d8a2d0033c844a3d491c3ed976b02b0780612641ead1edc14eae0310e249c94761a27d639af74771c43845a53d961eb6d0c9dfd175f8e769c1cf4a25a5d51948e42431dfb259030403f495dbd199da6a4a0ed70b6e2340b9fdc0317233512bd45d2ad4e9a0d7599da9306d35b89a52760e340870eccc57ba1d92cb2c4f31f7ad099a3826f3e2ee4a96e4a334be01c37bb6a01d98c67be95171351d8eb72a65515c031e10902af4616f494f1917acee500a2c431e5fcf0c2728fa46870d684be9f71ca34526814dbaffb99c95707e54511e311400da6ef1b13db6d5bf763b835c3977936832b1cacc1cf37735001032c33ccebc2a13ea09aaf43ac7d30ca9849623510a4b3e12cf05cd39a7932065d034d604442781406b96f69ab3149c60bb3740e293adb291c640b3b47574e5e7f65a22accac85f5e4fac927586ee5748c74752ff56c5570dea21166e3809b80d175206a24dd90c93a266964e2864651ceaeb474d16abd3dc9486b9ff9928c2625d6c1383edc174023edf0403b341ce39b038b916fd0d2b439823698ce038a7c35ca62ca38f46c147a89de785247e5f1ccd1e8d97515f77f2a922946410b351e03e5060c51a2b829d8dca23253ad31a474bdb42c7f760612e89c408410cf7a69ad6e4424068ced1428adafd1ae3522a7344d351968b42daf1de719e41ae65ed9c69a53038078fc3ccfa23e47f05d4b5dcf30b4724bef03056f1b5faeb24d745c8da931178a070129e60eb15b9d79aa7f2dd05778a2388f8b334e3fac7814c7e64acfcdf65518625ce0378723b1ba051859a9afa1bea927b6cf87c60dcb60e34a24e09dfc59274ce26c3c4d9efaf38d19a863774e1fd88cc91752ad34f7af8b277326e7ce8b2318a77e0eec9730e30855af979201de67c345afb22e404b7268b33fb3bbed467a289f57a6ed3693b6be2b045d49d2183942c93442f322538b7cb91473b5e4dcca36e59cb38724ba826b078bb01fa09422d1c48dc1b97b3b6bd9306fb13b420e0a8bf588e33041423cb74abce0b203341361a55d8efdafb6c9042141365ed6699146dd02b6028b8842e79519d8ce37772f054b08ee22ad82a7a2509109404aa47cceb53bff36cdc07da0282d8ca22fd30d69ea3a5dc05d8503f67b6d5b0744e2a14a8de01da13a66993b7b6f0a98b83fcc444b08909b907430212dc688600868ccc083335e8ffcdca06513a3f9faedf373a620de1857c0f59263f7e137cd76f1ca40a9acfde0f08393330cba9a610a5b503800cbb309e8eaa5f5677a6f7992bcc117c152bb9be6a682188f39adfefa09fbc248a172f074fc703147026c488dd00bec84af444779ac0102536c37d68b8cfe24e7118c77cee6f6806770bb02d06ca24bb8eb3a456d147cfc31696484676346cd036355f0d164d77c0358f3a84c72bb8b29490ca40107ac23342e066e84e79081b427b772936de56f9fd42961a001a1ed6338dfa71c63f4d6197806a356a92a919b1c503cc4071242967e14bddeec74be549f34e45b7beac332190ef80cf926ef4fd82947d3e342b48598d6be2ba0dfba6a4715d511c1486a8ab31315b135899c9ed21acb2cdf2bb6c1f672511c6372d2f8bc400a32086d54ec3dc630ace74db7dc4f339f19af236ad6e966c964ff04c5e3b056e46b6abdc7d0cd23bc44c9a5537bea43ab34529bacb83f3e4b7a44ec92497ea05f70d0056c00cdbcd78de921235551757a1c4c2471eed1fa2435a0caa196d1ec737f9d7de9667b69906df385437e365cc8b8dfcd48aa75190166f83597d35ffa5fcc4006f101f230608b40ac9ab17326aa265122f0570074720151306934afa551ddd2b7b12b597d9714e7a352861d22cee573367b01eeae1781ae29e39500827351cbef09233c5a99683600195dc565175e12208731b0f6d36fc3ad5390af56b8bd0700873cfcb08a49e9fe13161eca4224aa926d18e65919af7337beb77c6d144b2fb9f590ad788ac6da22d82915d8142aa8d4fee224849deed494707729ad11c80c567a28dd68fde5f68174d0a5bf7cedc9839d2546859f91f9683c33ba3ac0360cddc03cd874fc00bd56a354d34f3ccbf01b5366a5546073e2595d0a031c6b69170345d492fac9ce71c8fa5e431f3ee47381f710edff89d52b051e34180ac3b0fa9a2ce42682e10a1f7c08c5cb5ce501c18c87b14a312ddc8aece04c7b755d31481f87bc2bcc4c7595dd0f8284a324d917e60f8c0317c3fa952a2158723fad07e6351b0932afad08b89e82ac5a4579998a1adf8653df266580027e9702210064f7a8caa3023e57a9e3b852c50b48872fdb532dd571057edd3763f5a790410d9f65a72e90fe5976fc612d40763322a5437583b7b6923f13e5408155c011419c848b902efab1fdee1f85ec9c9c25e2b070c187a02b48aa6266adee01e5d15a789fe6da4cab07008fe4896abbf884e5df6c518645853b7c1364165255b74b05fbc5d28ffd1e38bb2a6d94886c6c5fbf71555d5dcaa08d5d6b5d3c01b7810da53f29a51c151817d26533069be0c1747fb7e2a5d1f40f66762eabda021cec70b6fdde150a3d1e339e7a7a4b4d81cc5655dc6fd214115b44e47f1df28d4958fe7d153879b9467d2e72fe396bbf628d579cdb1c1b00f0c8a96af5640233997c92684ff618d83fb7fb6f961b197f45ad86ec2587774928644f922678ab8055b048923239a8f8252469cbfd286c22c0b4e2a449ba2990e6f85d664639f817d04e0e15193425172d41685043e84b532eb0f8ec5b45957eb194504ddd63105459bce921f10e04e06cd9868d26f5a794ce70a61e20135b881d6ccfd499951cd71ee321112caf0779117cea73374f70e2229fa825b7d92aba87554edb452f35446711883ddfe39dcdbeb8df4ec36b967d607c46a0e4ee1810e5acc107c69c6594e168275f3e85c426cdace3bb05baee83f06bbf7f5a7c1d50b99be4db3e2601d2de94010479fdeee5eac08ae075aec34aba9404c9faeb1ec959dc1282814b261d5ecd4a4b2bca64e02818663f3c3b72c72521055de9cd5ea52eaa23f5e7934d627f92e4683247965ad2648d243b1ad3f472fc9bf2e3e995aba7e6e8102df6f79839f3b7e3614707e578773ddfb4267a5ba12dd765f3cf85f31d2a94c374d4ed58d034b97980771f61355e7fb5642932927eb29515022377ec948df14583ee6624abeaddffab77fb022eb3a126b0818fc43487bf42bef82e4f6161253eab82eec5d605d4f85d769d4e8b6399db486ba78e395538af1af10f28660e0f08595ca854ce2ce5cc962a5bf563188b890bf09f055f8f7413e518ca85a9de9b03816d7fbbc2dda8698e6df6f8cf40544e78541921644ac2ea2eb69c8348056a02cda094191d6835699e8aae2dddfde2a7544cc5c6d2efd4441db9815de18be7a8a40f46bb0d06ef35dd4e183d0d39c9c5f406a04fbf214d123fa0537ffddcd754f5a3824e931b8d4449bad86d21919db0ff69347ca03548f9943ddc3cfb1cba97d3b03f934f90c50e90632bafe355ea4eb354e14d77e0b2a67f1f9c52b14a2d5b6e0930e5ba276025252314363d8f0111df5707098e951f421f65ca8861b1d27026a845760871e95d09c715ebaa2cd35c2e9957b4cede9b8906a3e00d62ac9057ad8f2004ac1ee216ad512fdea8366cc96f455defa03c743cb9a837ca4180380d6cf89bffb5229956dc27c5e74a591f1e0d5a96a3e6a76236c8cd2bddf756f7ed818b230338c354fbf5a5e2e43070a5eec7814c395836fd67c858be69a597af6b64e5595f7d1a515a4f4cc3ebf9116d968b3817787b3e1e3461220c37a62ec68ab92b9bb407f33d4a09074decc90ff0087a7ae2c409b91d392358f61ccfeb4ab4ad88394ab2206b5f2e7d834dd25c189af296b1ad90841eb780d7f4596d3934d6118d2b2e4bfb9ba0d32ada840d301d3117e424b5007287c610d33ae2c7befa7b51508f358c910db390737d56b5f14b15910709fceaccb2b7305ad709ef40ac0673019df7ab76a4c50bf3f54f05c1f1211a0fa735ecbfd6d831d758a12d3d762a39175ca8efa8fe65f027a8a10fbf9c731ed0128125aeb4f629b365e242c126d28433281db076963d7eb7ae91535229e15b8b8684086a054d6295606b6b4f9442a352a5f0b5b3928edb570ab7b1ec2c7551dcb205567e44652be46524cd7abbdd40d3cfb7151e2f930ef755b79e9d5b8824d60c1ea8318a2fe28de1ae161ef57f5d382dfcddc879ca5dd2138fe40d99f01010a6aea6f24498da46e67dcefc201af2acafacb919c8230ef8617a4d59c79ba5fbcf7b1d35b4a9e6133dbebd986ae07106aeaf9ad599410d221d2102335350edd8997150d43be06cc831a1f9164414209dc958b6f9bba2f6c67cdfce0c99fff1279ef4b7986daeb5f269b77d3f6770a807472e837f0f2a0c2324ab479edd65c8967b00b8a50355f5e48101a61a7c3460d89ae86ed97df4bc58f1678771c7a72dff8f4e134f79c6365c620d51eef137f4b0dc964f57473c97505c9133928ef8043f799164d809099f872587c7d87cf01dbe5075855445821e725abef25c9cea14ee04092e1e5d05ef84ad1160bba05a0e4723f3d9783e14d636256a24525961999bb6dacbe96e514b3b7d67a826b2e67685f6b75703645df5a016643cc0f3037b3267343f4b3d8c48397abdb8ef85253407f6b850c027780b7b4223c87257232f0433c17588e790ba3e0eb5e67b3bf9f39d0ec0941aa34771d8780f7fcf57034902eee288e24bb27f3d9f7a10e97dc62afaede5dd33121258e048d7f5299c48b803d6003261f4e4ac0704951b95a9d9ed4f89502f6ca6181f6048a6265f195db6c537378b5ebc62cada3b4f9f04fcb8fcccc5e6f77903f7c58698389284aa8d6662c52fbe904528984858c6b0a80e288d896a391477a9246201e5fedb9bb116435d7e8b01dda707183a64adcc6ed82a304027ca909ed53937aaaecbbc6a7971a6c07446ae29d5939180adbe9eaed3d7a110e35b33937b9359206558a6fd537f35cbc9ba0277a57fbc3e584ceb00998e69ddd743266d197b7cfb18a5e0299dcb43c35f367b1e1aec711136a4c91ee1f39df239be15373bf6b374aba1796f212fe13caf974e8d4aefd0f111278c1ea04a101143492da8c18d2f7ccb7c64784dc731933afef1e72d1e7c5da382840697c848ca57ffef471ce692a3672516ec0f2dcee8c2d74ad0d04f55cd451cb85f3a4f75334309b60afd2bbc8224c3712e58613b0af297622ea07a43b66297b6ac376e4f0494e5b24050ef102763a644a2230313b2391b747d1cfd7100d5ccf7330b0c41052e480ecb8656d2901ac27d8149714a3725cca17e2d5cea0c6c7c404f01cc2fc11c90ef340e7141b9ccf7482c6e48328f90ae7aeded4cbf61c7b772feb90a8747cc9116bf1a4d4194619e4570d3b335db93e16bee5e4d9b3e8f7040cfa2b775a385f19f8ac77453abd739af13f1b7cfa934bab57b150a4a7f6792807c14f9e202727ca7dbc1b81c83ce593f51d83e9f60994a51dc428f360107b1bff443bbaa82ff9f4ceaf983a492c0576cd3b59779beeddcefda79a20a61840196c52f795d6dd92c71aa419e57fda9d6db1cf10dfab5150e213eb8134facdc027b004cabf2050acae619baf210ae173f6d2b870b262aa78595ce6cb0de299f0cb05fdb4bee1cf426fe5c3fd88750682dbfe44531bbc62d7f29d85a93e7abfe6bc48ae7638fd3e338f6e0c2b22ca95e16ca7ee14ddb7254af933ff7924db6c5ea75fef8c2c9ef1807ffa34ffe2da4372bd7b880b2248645fbf2502302107340e8e49add07086078accd0bdb7da77be360c5d0f5957c2107f4abc2d33424e3989a124fe5537c2aa8acb562997a42ed86638e686c0cd5b772d13633316584493651082f323862ac35071317208684de4a390adf49ef13fec678c049308ffa656ad5033ebdcff328857d4ec944147cff1ea4d14be27901f3ff6d921389ebf5b4b7b30cd61879054f6e6c62bbb2a5463d8323b484ef883ade9afb3d1aaaeb0f995f5235966ddd1816732eec95c3ae48ffa5a1c3a57076cdfcd2ad5c72c6a8b70edffb28ccac625539ce9a8a26959adb05c917d11551b5512696131569c801e572ce58414d0d48f9b524df4dbb648ebdf4f58200414f8155b9536a46445a6f3b92c43494b4eb89322984dc99ace208bc4dbf28e95c48411a9e31e8b9f2d0376c0d3f6b8eb708c28f38b83120f37a7d972f57e7077f9118b743a807c67f94d2b5b20c65a093fe4f7358ecc02e0dd0f115563f850de24c5c9a1c6e946f80f6d5689526a144574316e863f239f181b2b933b12903c61b62d329652206a24138607b07192722d7a11335b27eb0ab1a12cd11350ed2902578b280f5fa5560252a4a1d1fd4b632d93c62cc00591dd37ede5081b825f4b224b5bf36eefec0006a50dbaa8dde0f15ff5d23f92412f393ad9088cb7655f172308d7d090e1641a4239c028b9c44a5c78e1bc7da3618cd8a2a746cbaa4cbf668f925714812df10a5d2bfb85fe9f9c60b1f322c373dd83db2b0849389d71227720cbff08670b68adf3facfff5333539e92d70e932320424c5be7f74d49ce8482e56e3dd68618628a5af4f5b03d017e3b5e4040536c7cb3ae2736aaf812fb38107706a8aa67f187278bf0623324419e75d1d6be7d3e277b95c57c8fbdf2f36cea8c8f89d965303c41cf988ea5a44cec35ab58f3967733fba233f893357df7270741fb9d6541505ec830b8a8c814eade09b1f64386b137e84b27b1f16355e0d1777faebbb71260b74ed84f559e9f7d1d6a589e0fa344ed93429a81fb3dacf760edd88d94ed99299d8e2e482d6ac2b2dcc523311249952b0576ba80cdca34d2c9df23598fe5afdfe085b2780fbc8f6dc1080dad7f2cd14683b1270fce40ebd069dbc3cd926cb97498062966251ff8fc8699e8a7fadfd4362de31d230ff5a42d4954a8a1d1d2a91419ca3888fd705e84d18d20faf39825871ee739bebcd91c582f48d41058e3125478a9fb8e1fc51a16025b6848ae8ce9e4a54f1c8f39162e47016ef5d5c05bf18ddef79c6126f1e8347f84d8b4149eadd2b821c4d2b6e1be1c9afe6826d7a6c6922056832656802261cbcad2563148254eebcda9c8f71f717a32a77d369927231bc4d9a29ce84ecaa16d74233ef3f093645b1daf74ae741c2a3668e44b5292a7dc7c1ba575aae9ab308658129c95b69eea2b2a206a042ba0c9734167608cc3cf1b9090d4556105d8bcb91e143035b056f7e69be8919c00cb16f658c46dc50b151603a56cdca94841179372b33f4ec064580a7a3d9aae7c83ba3b310aa8ff2a65afd9e2390ac14a9c41c0406e0e9554f2e92326d1b5017637151c38e3b686e96f688fadfcc8918e72408c72275be846858272c11f7dbe80cc69bcac9c983d6d45bc9566abfa759c18a00ff26a16f1baa3de47c20261238dc64f58795dfa77001cec065526d0ae35686c70504b29eea1062ec54f56a412f912bcb6ec6129e3caabd71d05143c4fa103934f865e15275fa76e58406e6b6ee9ac20aa43a8fe91b48c88133d50c36823a43d68e508a7f1a9e8de2c18dfe2942ccb05f4fd839850cfa5ee31fa2e8a5412f38187de777f6a33fa440d25cf62e4a3694c062e8ee0c5f4aec75d30eb9bcd6205c8d9e04a65bb2b985b9f8c03d004866a33ea8cf64b3f44ca4f9eef75a979fdad8c1fa716b21a0ea6bf3fb71b5d7b6cfa1cf81c5372ff562307bcf176fbeff3e90ee38e9de56487b9ddf1e129b2c32febd0e6e4808d525730355b3e7cdce96105e23f44655076a63267667b2e7b3e7217ce5c6660870de1a288026f1bd9eeb5a86dbb0389c7fae47088894aa35ca10201345790bf6373321ba83a5df036156f739c75b73d9a914ab3b60fc77ffc3a85f410279c51479379795bcb770c7225e678389fc462abd02fd07c9064b96141fcdb7594750c556d38b4ab9bf01a99c1d28becac58bb1611d25d5ab7c3b93e947eaefb3be3c8ff48a82e3efbff6081212a3d4a8de27d4444489241c615cdc9250eb82c5fcb9b65e45ec0436031f5e4e3dd368540b5e51fb8495445ac7031d87a837228c1b0465e9f6441a209fb99614a7d326b11f0ae94725560fdb4bb1a60c7b7096b242a340100f694fe9a56ae283d3693d6f9f670bc2fe2b054cd41c2b48ed1baad888f8a69413fb3c412cf2f1ac79e4549c9fbe113179c86e27ad411f17147e3a08b5477ae84f920bbc0cbe732829c1913ec903cce54fb184ccbb49ced0c7a5906adf9144a5c921652a578dd05d44b986a195b8cf99fc3054ce5bc8ab204d21c4d23f19bbfdb62f4b4c97d3b06ebf60512a3e670fa2de35408eb7a9d1cf83daf37e7ea3c3668ab8f6ddc623b81ba66223a8e8688f413e6cb87984405090dcb385d3a0afbcc8a52d414aa7a505f3e9ee08100885e5568a60a5f46c0c940111066c2954b7fd728689bbe831c1ea3473d8a28242cf473788ad7be6687070d28275863b401b88458bc49509fd8d817531034b87abef68d15cb4765266f5c6a385589a470c7e37940988d78dc531fa9232b20b0cb80fc777c87c16cd3fd9e1c9c41353ce8d603f7b40cd3ebcea0e851ef2e1200d43f84e96b807cde256a9697093f78bd5fdadae06a384b0d7047ae03aac67a583f3c81b7c649a3611c86c277b4fbd1817ad311a8735a4d0f6305832a492a6e981fad399d3c6dc5c15f761e1de6bf7f2f928c9d554a3ea10e9983da2942fdabf8143845bee3d5ad97c4f9aa8b1773991e3567ef53423e8f32619f133dfa190334f379fe32d4b77291af234ba14fd73efaf4b4cedbffd8b9c35188790d0e3c8d7a1fe8116ba6c5ceaceef291ca39401c2aa24d5ff422ea8be47889ebb9b27b7e828ae2ff47e6ad48d02f4844f74adf334bf9fb25b875776b8002892c2c3792ac2a313c1d8f6dfbb8681b02648519ecb3ad4d742755fba3a0891fafdf385f82e031740edc1daeba0ed5b1b885173be3e98ed728e3682952feb1bb1d01ca7cfe362e00d69fd851acf35339366c04dbf0751d6eb306067d7701d27a3ad1d69f4cfaa9d048df262f7f3caffad3fd50cd9987cf5426c097d8a1aecfcf856c308b99cd41e78ac4936d2aba87689b37177fb651aa6fe0a961f20707dd8c7401ca366ee4053c28242e222ce679f2430384f85328331dfda46b688b2ab02c346f508d201df8622a406d3704dec267dcfc099fa315e2b13921b9ac10f2dd1e5fb6131eb8558c25b5bdfc25e1b913b05d8ab8ebd6fae61a0ae3bf7ed92e2ef1cd4adefcba416ca9cfe2d097dc352b88ddc9c777375ea81d5629d5fc069111ea4728271752fe2d71364e09b6d557276d74e7741b8f74eef5c1817d64ee3b3fd2acb192d521de675f8872138b08327d1fc0af7d3172ad4303a7e038e546fa7af5e6f92aeab6c43faa6bb91860642d0b9eaf54e36d1554545034087abd315d13a9853bc8bece930537f685c61f2585a76453a63bed52bd3941d0e9909d99588e3dad39bac1dc41deec15c2d3132ccfd047f4171c4f473632fda1f45d834387a4384241b53ade789cae03bb01d24a77c0aed7bc3173e80d5bfbb2d4ec90a09ddb3f04ebe0035d89e1192a03a2e7503e49c384264b5abfe4eea7dd6a61204c743a5f1ebcfaf4981e6558d4936feaf1a9873bd4fdc02a0e586613ea3025e6b2fbfd5deafbc28eaa8a475a068810a26f4b7151d3b274e705e27cafb1ed9a695f4fee119b5cf58807f79802033509b5813105638095dfe7540d22a4aab1f569b7f9dbb2ca6b7ce652632eaed01da9ab73104050be192b1e214cc50a2d3e47aedc93a3dcb4216d6c465cead6c085eb8191ce472d67186ac23766781b504f4ad990101818435aea42f19c04ed2af4345af3064950a1b76ebb2f04384a69f421753266ca36ac622e2ea551c597751a91c8a2e9b296bdf3165eb9132a6077fc5769b2a92471a76a49915afebfaf1437afd48a9ddeea2a48e0483856304d44279a0703c0c5034c0248304d38f6a6d76b8f7a8e9144165779350dd77de5441cccbfea3259b707dff067c0ef597bf6acdaef1f4238583d3381cea3e7f331cd6f677324c3bfab608b35b1bf1f04c5a0237c8206c9a1addde8b39646fcc352d806d5d82453feabe25cbfd84d6bedd7b5e6e85a3a13a956839ef2da849310a549262e1eca3cfa2dc593e20d4d6159205d3895598bfbc2fdb078b46fc809e0890c348d885a51b506f007ea04147e479816e0abe8269f1b1eb56f9ae50152ebd027166cc5376c2b214050c25f5bdd0cb597e9817e43b0f5efada8b468e0882a15b790c3c6220fc36f0b1223e37df4732135c9f281d93650ce68ecc0a0ed44355182f06ed18c79defd2391a28d6d2330864badcffb35fa77dc0f967944fffe0b935ced4b08f299f3dc4138553d4654b985d7b183827e99d3632fe1dad0d157b613e244029ae7a1c59a72c58c3430fa54f7ffeac641e7a7c837c8db61593a443cdc3aa3c1c433217453eca691b7e62f611535d6580a555ee9f611b4c03dcbbb6a386ce71e33448723ae2979e5e17576764f0aa179ac516dc4d53e63edae28abb83fc8d3d4e9c37948812ead0662a732d8f928bd2078ee46b1a867f95cab8d62bb45037e337708165de5fc76e64d5901f7e76eaf296980678dbcee60ae204e5f502dd588dc6e40871fb0c6afe6946d2924e783fe8fa2da3ff0ae9564041e8ef4ce3570c0baa413c2d78411e7fe8fecab35329a363ff8492eeb02555b80a87dab8010422909c308386d6d2073b99d83d2249b2eaf89ab3264dce6aced199ca8b7c20b68c64fcf04062b6a29f566adb132b065a8e3079dcc31196a568bf1ef811eb17a4c20bf070900287649c3d02e44a9cd3548c29046235a0b2ae84f4e709243163476d32f576f0c1637c266d567cb0423724dbdcb1e11816b4c9fb9636974b6816ff75e7a7bc153847028a31faa79b5a73e0ca1b6046117c5a45f06c00d4a96c540e22f2f22901a5da090cede41fcf40a7aa753986b1ec575e9ca51a55ab59014d5ed31a8054f112b46599225b74f9a31b2ad611d51277aef6f56b6e6bc0f7d2b9d2542745d5f39860ddf9377a31dae26a18c4872a77044d76a9bb00bfd0c280cc71b0f2edd4df6dd895c53cfdbe2bd03d002ae3e09c30f4f539903273a73289641dbbb0b8af7d329ef2c28783166e85976dce562688f83a862889619aad7bff83b39df11d1036e3980e8de011cae97ef14adae4db78d450771441e6df106e089a5e49a23a7e3f2d98ddb302a8ea9931e9053b0e3568ffb0a84a9ae180246fdada56b4eed25d7853a0df573508b566acae92bcba6066e838981fae8d0859ed7ccc41a765130ec6ed85d3b3b8e95c10ead192300318b36be14f1070e3ed81a39aaf0bd9e9b27d23f39a32466ab731000e7972e0c6329c79a03832135a817fe743bde3d67c58a4a1d3c4b2f2a62f80a14af99790220f18816a73e9bd7bc6c597a143d2fb4f7518e98107696b408924aa9f826bf722ab17f2d11c208ccd915ff5c233cad735d2cd006e99b861e9b7461bd4bdf4a35bcca227673f7c46fd59e36e1723859c32dab894e73fc2bf331ecd988656162174bf63a0a1ee8bcf1c4af991888dd4264ce0778380652f49a54f4130bfb834921f329e65c5859fa3b325d1e2aa33fc207c09bbe1bbc9692639cc2e8571e2530bb472681973de9c8e42fec848ef53943a99b034facd91187fd3c05355e6006941620b011eda28bb3b5b97bdd7b5a8714b7e5933211d0a2483b187a2f5dcb913a4261e2a3c6b8ff81e320b131eecaaa8d88de89c12dcc3a05aed94b9202fe1c45e5de9567b65e46851d5abe984e92659f9358424024f3aa5fb1cb6ef4412d041fe601c2cd77a302be93b4c814f25f46cd10e586cff09001a8704e09bb2bcb893ad3910b38445f04937c1afa9ec67efea3f70420c4b4e99c6ab35ffc61a7f0c87ec15a6eb0d9958d8d1a075821fc57bc173e046a6eefadf64ffdb86e32b2e4c896da0708798bb08d3315ee9b9fbe22e91c578b7e0390b2dee494f28ea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
