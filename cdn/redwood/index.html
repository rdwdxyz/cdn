<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8f7a2a66ba061fedb4fee4511b2894b651b5445f682499eaab24dfb19eeafc9d9de42b744c91c7dbbea14d37e7e13a2aa447204522bba710b15beda1c2f89c3daa4748f77a7faabf72dd06073162ab854aff3b43f981ea84e940e447f73dc4bad481e35b5c6bda5b27b55a9a6f50c70bbe0a9f894c241cb64486cb1a2b96d8cdc3bb740dba789059ddb38eacfc76aca81d402eca9cc29529fc0fde8ae9d88381b7906ab7237eec0f01abe0a35cd2f28d1b5b95d17637736add17fb4662daceca125c5071f18cdc8c61981561682f936c75a2909ea0f2df058e59ce86aa5acedf3d6c29c7367522e2ea62d6f251c95b865772fe8b4c6bbd5a1b28ac44fc4ac40dbae6f023f7a7f0f7945a65b9478edfc0767d7a695e3acdf5e58a213de8cfd689716ae2cc8521bf135846583cf64477f2d49adb5e18ff5e74f3f785e1d025f4bf4a5756b0936931a60fad6be9ae8340885ddb395a99830d1c7191ca63121d35cfb51c443e00f2ba918cb5771448b7dbd9e8006b13389aa287e63930b92b8a02c35a0366c97b3be83c985b100f6a5eefddf11217d488ec163ea23d23e791a3282bd9dedf90cc2ee94a54c2a3c2670f7051e243478138bece9030f1dc15a0733f9c464e04d8b7cb0fb764ec7bcc1d62e1b1902825b8a2b13309865badb60b99332262e8c34ab16aa5e13d8bbb84d1d4c7948d674e02e9b1cb4a64b2329793dad644d4e577ac64c953435ea9b28e70929a902e1a54b3fedb79b0e96dccf1cf409e65ae0ca1274aef36923e536d371c560afcfd444cc9bcd4669918276af862ee1095ba5f4765ecae45d8f51ba078deb4a4094efcdc2a1fbdc44613279ddf12c6fe3f89133ae5089b71d3757d06fa0b3faaf346c6a66448b078f9c239cc0cf3b0a99b779890bd365f59db6fd6829d8d3251970cc25f176a7199bcc1d6ea3e991f840678cdcef22582e3df43f571511146952ac55d7037670aabc75598515d69fa91c9c6caeac2445d30196c7cd7f1c1985aa0c3fb6295b6e0591cb75412550d2274c5de5773641cba7bdbdac0a87bdcf046614fd06dcd27e30b7a269b0ba7a1c43637c9cdfc6427540cf45f5ccb97ddc69813e426678482d28c44a9a2fdda4d7774449ac404575871e2083a7a4138e3681ef2c8232f7a728f15eb2b76a770a199d7ea40c051d0e6845af8dd531d9b802a12b0b269b99f5d84333e6370756d38284b01ce9e6fa104788fd9d0be9d7cf44f87317fb0d3cc07ee3a457a6e7eea6f72c2f7f4154d88abf9fb1788d5a251b45ad27ab9a31125156d3e3c6b126e5f1857c974a25615578f412e3cb00a475ace3c71b994ece3d8fb4e8ebf445bbcb7d59d5723b8bdce75dbdebaf40fe59356ff796ce46fabb9a3ec2ee62fafeaf8368c0ba2bc7ada54f7795f0a2b7aa0f60ff070ad2a96aa4f4e846a831bd29cdee2bc6fd0a4d0513241f6e08b63d279d468d33a2f399eb0dbe94b206a5bbd12b574b52c1d0ae0aaa9cd3856f2de075d16f71914ce2260a574c33762ea39b218d90be36d14bb5d4c4ccdebbb89d9abe05bd768e8c0ec119350fd15a63600afc7e82855c59542c1154c5b3d7728619b5f249d2a16edf4925eaf1f38372f47ec75f7052b746e430c695d82b4cac6fb8fbcba52da7fec4b532c4c06b47cef8e9a471deb1ef035c264ecded4db8555774520833c167a1a3f95dd0d4911f8206ae9675d13113fb20809a15e26d1a89f3699f5173510da7b39ce8340f53eb14f5f432edd5e5ccd8681c453a7d13da00896ec45bba8eb267f22317d9d7203e9932166147c6d5e3b145afdfcc42cb99ea76e8f0a2e1b0842fe744dedcf03a22e520b77030d7018b2b9c94bc28aeac50fd380822486556407bbcb08120851caa176d80373cbe54e8503882d0912ebee9724f988ebe5e6541b9d9524080ecb5e1ea78e455c60951de0013380296f61e53ffc362e1818440cd909b78bc7dc7a5d5e843a9d6b7f16486da1aafae201f9de56f67469e18784d020277d76c11820f48396dfb232d2fc6e03e9bac600abe6ed8ae014cb9a868180b60adbf97772636c76a5e00edd48720a44b11abc31d9dfcb42e8752b286f5927d80a88b1e2107a589816a6c8ea45c8e44b171381c39e3e3942e042ac1eead70ca5182ca6207cf2149dff708572d8b00829d17397c8a92d1c97f8b55666be0ba9c71ff78057d9f759cb133ac5756dffb2b684ad89c385ff68d96d72d21db6d4cd55331a29ca2cb9331a0a1600d974a1cad8d71d6094322ee6ae05e10869d8fc7dfc2127b4e3d14158ca9c60c03916a6ca5e14ca440c3314ccae867f362da90e27e27fc07b1d3e9ee7635bab9130372d495234fabb0d7dba4e9a9f2c6cb8a7c17f2d7335b039ab21795f54151fb8cf4fba2e123409781e76ac213376930e3738fe3948bf10b69810b3d880c3699014049e33229e4aae1e9610142724e029ce884ef142c0b5c4162df69a8145558872fc5dfd5021ca179b757bb29e653b7513d110648ebd853b1332de1145e001f67d01209ce81db8a64a8d6eb5135e1df6ad890013a2ffca90a25e6cf20f323a2ba0093542e5ecd2bb8daa4b9509685f08781bb48a603490ebb5a2174706beb7e00319ef990ab35046565b931409c18888511d91cb231392c13aab269a2c2a2b94e38c527d65d496f2151534df45ade6021d53b4a08f926512f759e1b72162417e2267f30868ef0263e727edbd9e6a06c2c63bc6790e57359a56b4963a4df4411ea538f2eb9b8515a87fa5b1daddf982732c2f78bbfd050fd13170cf609bed7050c9145b954ebe592e998b6c7df7a185dec68565c5ca6b5cc8f4d97acd64ffc39dabf928db225df8c2e8990da649a1c1decae0bede15076b8b57d19a925388553bc521a518ef3f30ad115e181e77feedef2b698cab08fefb1871206e57d3a21c93fc80ecdcfd0d87a5e0ecf10199fd46a62af8c2d6da0a3ee66340114fa2dd1ddf1042ecd06c31ab74bde93e2aea90b8e8c68dae6dd0856360cfb2aff6b8b8a884429bdd3380dd4e1a38fef607c06a81b88eb581b19f8706da57d6daf7e397467d02385114dd206cebef032abfc52e4774944a356ac5c1383f31bb75ff9520eb941a387e962517671122013139b26c229f9196135cae4193e367899e6199655d2bc288e2c2390bf6b156727e16ce0555ff9c7b5434dd5d74ec774c7f34cc5844b8dce0451ff7f834d682674c54716ae6386d5b88ded31d5387307c0e89005015a5cb4b41a307606e160abef3935e77c9e501d344e1cb5bb8413e07aaf80ff3bbbb82497919512061e8d97f88b559e92342dce608f893df26ff040a2c1afb4c181e0bf9b9a90da315ee87f20f9c4070d2da89cfa14ea5025cd4fdd82dc7f2080df4457112a320f13277efb133ba94a44051b8cd81d70a169de0e821efeabacda616318c93c579adaafdfb29e9ea58fc2e8113c95eec9d77fa94d25b7c19f03a19835a3b65e8929e012beac21f25b1bb799c196e38edebd4f5ad0f6479ebd53ca07b349e147dab4052bca7c74aa9ffd1f3328bbf0c7d726a38b601f3532cb67193df1f1671d9ba7461a465183c81c82fa56f93a8d735fb65d994748e06ae53d227b5e87f6c61028b3fd5616a3181a17a5a3ae4c8f4155f1ff7bb2b0ec4c8c720bb26bcb30057ba2dfd1c2e9fe197f60e1acb780ebdfedccec3561b4c34eeea79156331cc1598fc273bd47f312489653a6995751b3b1b3a6ba42c3c197c2d0ab2a2753ffaf7d1710d5a75ac056655585176c01be09a91249607af7444ea7a7b48a9d2fca014288f5f91f28a4526088839f3ea9797cce3baf2b72a3ef72edf87418a2f8274ddd7823669847365b1ccbf126da02ef90bf52ee52abd2d08e121afaba2bfcfe0ccf5b05557009c2c33782b4c47d1be4b03b9d0872ecb2fe8661f07d1a6a20a4e46a3d52fbb690d47c96a22f6df4f3ac83eba470dd496f5d9613a08e8d99f7bd9e3c1bcfaa04ac715d4fa42a4c320f6f14d6a2f6924635b5945ea4a0bdcc0e8dbc51693044f7f70476fa5d270efdaed0cc99ff26a39142f7199fc07678af24ce6652780a9f0201d47dce6dd6424e6f8c0496f590c0c3aa55e4d13c046591dc84e907de570ccf50a2a55b7a7166d34364286eb86167d6434b94b32159507e554de281549567acb62d69e7cac61576627368ce845abe29ffd7e786813c357ee427af6413a3ff153f344b45acd79f49a8040c821201526ec8bed90e097fc0314f303d34a631aee07ae06162b6bd5058557ab594a33e57b9ea60f77ab424cad910e27d2caee7ae762fc54566567965fcf5ecd96d8d7429d81a38c3f3cd3464093d8e59a514c6cc2201e5170d75ad056447a70bdd2bc974710e718a172ffd568facc210b5d9ad5e39d1b85002ebc7794158793bf63216de23f928e4e4e747195658ac62bc844fe8e79d313a1b7a26f42919ad4dcaf6351ed8c99a60c67bd4be5d35a6ed0c318b4841f181723841004c39181056545844d16c7884332ee4b788a161d47e2b269c3872a66fa58823b9f1815061090147a81502c9e95d4098dca8375f98b72b9bcfb91760c52edce946c053a5c116bcea17e03322b79bad01ffe0f25d5ae23c73714152aa62ca355d3aafa4fdd4195ffbaed0cd378745643160881a3b047a78f186c48036af879e077c0cc8bacff0a983033b85352f9c3848db23c80727f218375bc702c019fcb73ff50e035872f9be4fe4a0ed29e61ba5f77210652509b155d9c40aa54ce8f70d589d501ee03a2490f30972c9a877354d6a24025799f22a1779834ff75fde1f970fe3fb032b787b261e34c4afb0757921efadead2a2b73ea6255ec13ad25eedf07e96247b5cc8c787417f483a9e9a46395819d20cbb7695149ffa0b027648d00637c379a022b2194ef4ea54b28d79f5e10275ea5293d9578ef201a7c5d71f013e45b25011ec11a723f5f14e80c2d16f259b320a7958f4ea666d6cc30989c60788edef876ec241470a1fe592825ff49cb1c445ce0af713eccb0661ce4320cf585856b435cfa1125299bc6ba00e966e039cc64216478e7c8cca6c368921fd24fa6aa3cc0ff23e2f72f25c76858392bdd70692b58f358634c49bc09fb01f821c8e0cdb71f2be19268f7106eb80312dddcaec6ff71d1c343cbd6bd46496a4fd9a6fae16e214260a02937ec663464afc7dc5e7e1c9cc4ac12b1f9d3ec60fd87f1f0edde27114a5d7d5eed7626e913b458c2d188cfa0f071a5fc20d0b4b7f829fb756d522abc08d1b400e95cef85b20b01aa56fb3369afd159538fa1a6b4f9c9140497a5671eba621fb44f3d498646aba3bad43f4b89c21a40da37a8c32b3b294fd3ba7ad0b90f7a4245947e07801899fadaa48f14e36b38f7889e683157a09fbf003c0e835ee69548fdbcdd0e8a77b531038ba0cc593fee369e1d5bb9f5dceedde710606a5bca835fbeec3c02b67c3bfddd8bbc7f480cc2b63dae583597f87ffa89198b39b02b77b6bdd5322c9fbc2ab2c8a697017fb9b6956134135fa3123f20888fee0505a178f4a92a2c20fc9559e77ca380356b98430e24274f342166d8fca3a5397b44ce9386fddb4e1ca2b7c0dc2c8a4256c3050fed4e084ef53c7114a7ec32b9b9916d633b9e30f882b5687fb562e4fb9c3829751335e3a4a0131e87c4f90ef96924fa8883b251497184051440e99338ab8be12ff1c29eff2fd2b20a33a3dac0301937b6aa67943b4d2916296607932738bb08b41bba80b40bd4f02c541d6ab082deecc95eb19aa9cebfd847515e58229d470bf14d58f9bcaf2000768e5b452ae012705d75b3c1cf5a3f527b4e443f28b7887c9fdd0b46b033fb35ddad1bdb46bc6cc583789761c69726d9dfc1d07d62469a4e15f4c25f9492dd9ddd6659cc52b3959e5fd615202754edec69e4b25762d0e7898cb733fc7506ef7c0f25137eb942e56db414a5c0ccbb965750716293cc3a8107afedefbbb08416b91bbf377077db8e2960f8c2e1a7e8ef31d89aac03dea1cfbeb3258fbd5634577740e2efd0285834591c13630acbebab626341712d7de02da9f9c0e1c87b3d26f72c485ad75f6ff4fd5045db1ed38aafd9edd7d5b55a98f0b775220e31ce93f49a0f3c56c9dd91b2e7d129afcc297b711f5429fa0be632cb1d086a5ae9a75ae896ef3136740cc74fa4863780cf0b31ff0ca7ff6ad1f7b1b29ac40867ab7e466c52a1429f9c7894b8b360a2bb24e294dff2b3d1fea88d50f502afb4087a0fead83d928eaf6f2ceb45d5cb46f1df77ebb1260a796327af2925fe7cc1b02e6967b1a46a7c9ceae1c12749accc6d00180ae10a183f1f66e0ad7c60f91b5e70f0ec78c25a7ec09207c030a4c06354e69f72f8829e219c5202be6d6436b701c05c83fc232692dda5ac4d3b2f2c6e5d371d3d6162a0221e2872af370ea45d1edc4bf526df4d59869a1f7d3375b7242848a1a8ae9a57ba228eba7949c7b1a96204f38ecc11299c6cffb2611c0355b7eade295c7ff5b771a1c4a9c72c24b861eaca8d4854e00b1b901dbfb0e2bb8cb338af1dd9500c16625da5e1e32c8bcceadbe8f19c565cf38131750d907d4b64d6d3904cc2e168ed71080933c2ffd906cdae0ea106383c79cb5209c6f03ed1f90ae3324f4bac7bfafb6a4fd1f94ec4cdd09e65a510cdb7bbf060a83fc73793569608f28a8baf3f4d169bcaf2a604b3a0055349cd4e5f869bf7c1e57a878f7a25d1d4e2af1386584dac964c2731a625671dc146807ef4245e2c1e6a847dc713b8a8e16460f5eea3fd6791715cbef7198bb2be29ef83c6855e30e5e680469a644a66f0fd602e622562933b1ba178f069b654bca52e8e873b1c39e60760852f6638e3f595904544f3eedbf21bd85e0bdcd504222546ae4dabbbed1d6b1daa95e6ee0a5f7169ed79ab9cf9e542534ab040b69e4cb8c850af96ad66465660f51edea94f84456c162aadfa8c7143933a266f3377ece5802f2b0cf3a7fe0e86168ab345ed22ebe0504dfce6e6122d0de48ccc92bf8303d82648d0c56e63a507b47c33da031a52699b6ea3e6911ad251f9446bdc9452b80fa6e2498b877b3236af42bb8a490114c877dfd819c6a924cb74f5be8cbcccee3c49bff207755c5f346ed85b07d0ec717a132fb5410ac7c342af3e103f462b5a0961aba0091d26600c220cc85bb8ae58bc7eda68b6e162e20085986d3035e54f71b8100171e1dd2de35532c36da2128f45920c64ccc67579cd509ae4042cf88c6c31426cd95da098cc61909f642265a227d93d1b9a86388507af45e74b2f9647ba1d2bce642b1b9c686364721f220a4df748c5e629a2ff420fe89e8d5b4ee1a46ca934fcfef9a9e40469a9f5a27d7e367f3e0987eb43b6fb6aa6d23588439f29f0f9403ef6079977706b9639150cda6c0ef7bb14c48b939f919ea3330531b5aeb9c9096d7c0dfd91a8adc305c062a07fd7d09cafc7fb3374c99876b582c799d910473aa37ed078f99298da875fe09d508dae594052d0fc6c495f7b01ee0c37f349b3db4484f8b02d20215524f2ccfdbd4e197c05124f3f01a385149a48d5fcc229de00441ac356e459ea1f0218101a62fa1987f604ca361d6c62b17439a19dac5ba1f555f6efff310b967cf3bd37e39d53d463ed6cc35e9a0c86d2d1f050e2a528d2c37bc371874c33ad55c584c96313d9c9e51f3b06d7aee48ada10c623bfd91a90df104da1d1033f8acdf3431c2fa763a605895b8eefdd56797b82db3ced1cb27917b794903e3a61faa0c3381cbba2f49acbaca34e9ec74ba6a92524e01e415c61ea6f14158f0bfaabbd8f7ae07dd1d048ca91dc984a58a3439bba560b0c1dc529a3783ea141cf6f8dee8902f51c41cf6453ad600fdd7e2fca158c28e8e02197caf26d9664081ee4b6754575a1e35f9e1ecfd518b6d5672c4cfda503d86e62a3e8884de52d57d5cd3933f61020b11e2cf66d83b783e4ebf9987f6fc749ac5884b553e5d4daf239ba04b83fff799bda3980a159df5db3811abd4651ed6f3adf5f65bd62317f3f585ee767746f58821a5aec5c5793837058cc253cf2a97abff71900ab6d019f3ff4df512be5f67037ba116b383ba9928841c0c66d426d5e7e9be3d0a0048059e7453cdd6dc88f2ac7e4bcfe71dedc1b141777e9a9eb5de839953cd6a270e45bdfcc32c7dca14067024baf02ac5cf1ad322ce7aa51dc6ccbf11ad8de185251331eb0bb8ca69473660f370eac6d3c9c07700c52061f353e29e38e0fe193430f321d35c4cd10319b505ec9b32c35f60487c72b4f57367c062493c6ddab2b800edbade05fd841937ced3ce0e9c41f2fc62285495d87b4930c5da124bc1f91e78a38f1d532dbdc9db26ca8ccffeb21ed669a275ecf292c7520a58ad4076f48c15f268f8bfccb82f892820c4622bf4958619529fc7dcf56a12e3c600bb46b53f123f933ac711da2805dee593b94d2cad082a13857eeed59efbb98d92919fd3e8c2ae3c9f71d155faff565e62fa8334a9e1266fff04dccd2713f1d070f2bea555bc3efb200f2a46ec5b9bf84e795f8ac29b5efcc96bd913e0647e4195ef840d9eb915e181838b970614c70969c4416b79e1f6ce54cb283f833be5871efbfaa3ba2d34cfa68d4f41f854fb077cd89fd3185ba4e758f5fe1aab3b5974b1e7635b35ead0fc5f4aa54133b9d1961c939afa45ce5e45bb3cee87e6896d53ae77a46bd8bd7732365f56e4a7b6e2e9412e4f4d5c863eb03bac7a7b145665ce129cb7be2a0dcb2ce3842cc83ef3365a14110079e6968b4c87ca9ec954b52ea33880adb72fc139d95400468b46fd1a843c6d7c8a6926bda447f64797767b3cda2bcc43f168a726b344fd3649b3f1330ad758445c5342077fdcc1568485716fb52336d2f424b460af78ccf6b0ec20e2ba8ef9db90e9bd6d2428c334f22cc0f84479a8c2229024279d9f3fcb9ea06e1f0efa730d5aee08d4baf35f77a343b3ca6ccc4efdef3961007cfc87bdce3a8befe2101092ab182a076f8386f6839ea9f4cd1534d9829763414fa3ffebda9bc080bdb86a9eb3fb706c95e04f59a930432b7efa816427d51c798cc0f18e693144c15b5492aaef94ff8fd93010baaa06ba2a355b63fdae4e5d8fd4576de9470090dfe46b44b14a0d00e84f05b33ef78f912e4e4fdf276a8fb2224a6ab7acb2586f0ca8e56e458635559c63e8675a6c9a7e350f7040bd826724f52df56b27cd2cf844ae303cd5b137012402110d3a93710ae6fc30cb92248cb1a740cda3a82d836b56f09840eb55c4fcb54506508c6bbc2740dd6e6da0dbc7d4a3d0d47299b17a42cfa066058912849ec859acbf90180fbfdf5faa61a3811cf808ff1fc5889192e7c346a85c2b42335fd102166d0d1300c2a6337ee93962082872e13f0f34f929a99ae15a3a3524215a0ff29618637122132ce71bbf9586f07cd7e2fbb8dd7e6c05eff2fd04bd22b45b006aa09de55db3a92dd0e6eb1f874b202a31ad897f32fe3a613464c24dac091186e59fcf2d5ecff0f42a15bc92064ea91b2e165ff6d557042a5351fc1d6365c9f652ece3f43d00c6c5e4c2c2c1ef6f0b4e3a6867fb0895de5220ddac18621114996c5d922ee6b884c6275da4aff66830042a94c40235a66d6a12a031a02945662bdb377959fc063a3ea3a6834c48c76f256983cdeffd43d39a35827feb659f162e2bcaa73bd37afae9930c79ec99f91ec4a1a1abb2589c1ed2d2502e1c851587dc7a2c45a705a98424a85cf76797537abeab99548da62ded914abbd015e652e4df74563e1b39cd550a0eec429d1ee11b44c830d28545ac37be5e0575aab667501dd045c33c5b801de473d84001d185aeb491eb188a30e231900c06ddf0f3dd8918ab48dc2fa7fe3775bca724dc58f5a9d088234774326fea5abd96c20342d2c00d87a744e921e852ce969c046949b081e31e497854a0ef8477230971723ac8de742be7ded20c8d6aa2cad03fd3a30e4f642448889086b444b7219c5730007c795ec3ffd9ce52346a31fde93eeaaf78cd2c3d6e55f990b90d2897d0ce7a23593b88b414e5fc0eadc2e91b67bf080566d00a9c9e10fc08ba17144690285efbb2f22906b2427fb220b66c8809f271631e5db17f67caf33cd179f48a7010f33daaff499d20839f7ab79a3113c00bd46deff65c4a2bca7cd696f43a3c157714b2dc28d7f0a1750b077298d3585017abfe2c5ea66f0b7c96870c84bd7134becfe7b27dada8ffb19fbefb27434ed236dd9bd430a3b18397bff752a9e7f93cb03f9ee13b45bcbd7d76c2e3be50e521e3e0353336ed57ed2e59dca4a7bdb3332fda5dea847f53adb119cacb469d1c5e2395f8084d6bae30939f32afa531ff68e5a860ce4b1f2606ac39916db1ba2b948714a6b84386ceb02ee0eec8b65cadc9997ec2c6b5ded62f75d6e39a6a718129928f74617c280d904e04b8c985fcf9987433a697e366669c7f826225fd2eccc98035adc0ac7605086c0a9a1402158430baae516763249724c983617c4b4a403f785676742857816d5792c1593bc02f53df021cef1fe68821c9b39ff0a85093dfa8ed012f6147b7f1220a400ee828c6d596e57854fc73e32e33d87e7a35e23cb48e35dbfccfdaee7e766ff55a3ab2b150a3279db46a8ef4e82e632bcadc0b3870a5cf881808482e2512d73bad6f177b3612a2b00d574e4a2cc1b3eab5ec6b72101f15efe5fb5bbbef6c88cdfa782a0a176ecb3feef351eea3516f0c928a8f5e47e9a6bd751761aac93785c99e8364aeb767e5c4a8ed18ca94e669a475ea9c187769572dbd56eaf8989cc14e76685523e2f41dca3fa0dc760093b36710ca6ba021aebf816b59baa2326e91568e0bd8ea8f031fceb4e0cb376d8b1e9137e570d8221b2246753d80d4749976a54600385d4cde08293333b9d796d385bc1ed4112efaa7089ead5d3aadc99f52b43add7c3a09f6582d893ae0e21607ef721074da7df21c661847594528e35c05db633994b6033337ea6926a9aa594a60ca310a7b9e7f6db6757bcf3e5922f7092c40f144a7ef6b58784d4a1fda987ad87fedb722f17c9abba5c30b01e086753d5f3015e87cb3d40db398c2aebfe07fdc1d80feeed15ef659f5d16bad245bfaa138ecbf2c1bc7e40ff0160513ac15f13f00fb99720ad67277383abb67fd8f1c8636389102823d152cb76c4a0f34ea61659f55a7307161a4b32228398d8c05b0eb0d434ab94c20f5e593bdb2c7078ba8b593f623044f6e192e664c79285947fc60e8f2a11ea42fdd88730a0fa1b84ccbcc08c3d8cb9ab4d5b02e8f008331d8592d65ae243c1500b4eabd5064b9f178ca5fd566dc41741b044617500a6335b0701faa194f2acb1c60f6522fe01428d1b63481b231440eec01d1b2eea4c0751ebd7aefaa247a185478289252a2b7c1eb3c189732495a84a554761ad3aa26914a05314e27902cdc1274837547dae2f0dc2926530ceed811e42ea1f7b1c1a651c0954cf88987a787df4edc30b21b5de890cfa29cf07defb9cfd606f0bbdaf1da741caefd780314aea0d7308c8b99942ddd18952ddf6f42a395bb271d5733621e6dc26f779a547384b2adb65d99e9c4975d547fd6cf8078b2da6a4eb261a17c46e44ebdf67d4eb37019637541fbf2cbe3d9bc4367ce3cbddb70a9d386eb36f36cd8e1e98a5964771a859654d40ba3b04ecb9c04e48b4997815560a00df10c5712d1241e5a96f5c19a01134a2d9a2d0505f0b113e4a16eee578103b0f89e5c266be776b44936af26ca2799e1a28b6c1b8cf489a4183e28997c383f6953c471779df88215b6aeb5624d164cec98c9f6264c2167770b55e783f133981628fee728762708583cdee3df6b30aa9b53275ec065ac4c407fdfe7f173afd75d2e9b16d8231ed30f4a06e618e9b0c6bb61179014eaf331e2628d729e6c366a902c6ef047f55529f966f94bf3511c3cd09f5fba102e58e4d69e4001a3dc2ffb6e92fa16dc15deddd4cbeb1ea25075ebb4b1a1e5140beb0e54ec85c0057e52eea31e4a5a7fce650fd9c03a62564f45f1edaf9e486ebb1ff6ee10b5a23e49dde9c16b36fb5e09c3047cf59647410c720e5a3c882c11ea0962d964f38a16dc558b57d56cbf62b2e61dbbe7f86e7e0412a4fb48d092d354e63dbdb527a1410547745932242eb0df7b126d938c9c929a63798fc98820448615d37a6ca9ac329cadda2de5cb3c18aa8374f5b294a70d0f6e6c4df15eab03e8e143eeaada55a79204ce7d2853280e9319cba622b7dd46986d7890723202e3b9e5fe72c68ab1fa393a1d42e8c7dec9ed0b06d420c81f47a758f77a277b8fc54d4e36087c0f7554afaab32a3163aa2dc2aca502a924ed46532159e20f51c32df4b9a87d681c2447581d61c34fe482a19c7af7a5e9827b373ab971a48ac6ecadce6a65fbe2342717279445c0bb4cea0d1e4acae4322e2d0422b652f88c5a8109e6e5646724152a8d914d1fd487018dea274691d414d9be5a90f23e5c5b08a884bfeb77dedf2ef7272cbb936fa22cd0b03e2f5845764183a11c67f153eaa1e8e7ed72ee205c030295746b301c26269c4f8463d2f525f2d5174c325bd87d28f96cdf5e1218968e062836c49fcb0695094d51af821564084548981eebe8c1b0ded89f7668d5f310fa004b6d27a25312b06bbcf8032e4817862a8f7e68cc28738b725944c3eec35b2b48871397425b4e0a3c5d03f82f6bdf24a6446540bbd26c78b406e5381ba25aba952653532dfe1f135ec9dd4b85aa0d5de8c89bf13c19b4cebef98d6406f661c3399c1016c09e959566099668ff305df907127925a3e28a97f5133f6da4a35b552ada1f92a2207096052d468a95f02cc6ba56cecca6d844e19158cbaae6bc56e0d1dd484384cc9bfc7921371fcaf1791aeddfef2e68254bdaf9cfe9e0136039703209418b6e2ea27a7a9932421186c04f53854f4cceeaa6c81bbc6e9b0489e45fdf32be89e3f33cb6fbce036d95ba37a3f79d92fa0f80f3b3855fee62d7160d7b941357adf32645720c10ad0af2323102acd26dfc4a2d1df27fea918d730364991e735e8248049a630f457ebcde8379508516fe285589f1c239dc0fb22543d5a3be7feace6ea143d528305b51b5e689623a2402e0da165b8cd47b20578219b52eb8badf872c121142448722317da8517c506cca7978d4ccda86addcd977553428c6a9dacda02eff041eb05de2b186e0c71d667689a3cd6e08187edfcb33be5291b28052126bf7dd71c4a98ed58d71942c5b94747f716bb69df7ac210d10f30d7d9c8d8c049c35fb5d4a644d9f36630e92973b92b4a1d5275bf2c0f7cbcc8ee33d13f972a758cbfb7f7e0a749e273d015479e5f296fca7397748faad88f716f8a5c0ffd0201dbeee1853baeb4703bcaa119af356ec95866b51669d0671c78aeded97792113ccb1ebee8591f83bd17450569f9db4fb0ab10ff5be2ce56d9580fc133c82415cacae01e6615d01cbe58f3a3532df7bd73773fc735982e0bbb842ec24c68d51caabe8d74c4a26569c44eb6a1d217b662b197a9c847c4d7a906f3f87ed98956e8381f86f768aec8e3616b8b48e26dd98711f6eed63a47b41a216122b970be5e2d108f68cf8d812f034d6c1c264516bf43f7c3c730a3d053bb87a8e5ff5e505c65778337f979a687031cfe0888902c7c7c3a15215583ff2b602a97f8dd4ab7e5175d07cdfb67ef10458451ddd60679eb716b4c072e1c61715b90465c787b72b97c1af209317d4dafe4340f33344368d0ff36450a4df992e5b98cb8bc252ee86a76f55b82ca01029b2fa32669f10d83a7d08950a0678b5026e501506c522d5368196c3c69f6c2d0bda9bee3ea486747023ebf10121ffca453710ef053aa59b639d67d605be7428475584f8d5735670284e4319d4009b6b922dc4e22071209cedb5c85f3f171a8be515bfb2a9ca09cbe650503e48cf0eb7bf9d9d75308008831ecb8171be8db6b3cdfb1a86e752fd27d0d86e79c0ff023b61cee261456d20678e4cfc45528f3c0f8637e7e2e4571b4ae7f073c38f0f79cc68676142e59043892390f18951dce3ba8a0b578dd4e1976aff7387d2542dd76f105357d6764903ee0edf3e68050bbaee9d446947a50cc1ee69d2598b42c7593dfcdf23a99acbd74515d1b4c514863a40617d27fecbc5bdc87534e0903fd5ae19cc1de8f4a169e410becc98a926efdd03850f17bbe99e9f709eb028297b543b31040c85f7ba03b3de2a4e144d4e7f89d728a9dea9a88115fbed84bbe1d9e45b3f63db2d89f394efb1324dd0fab0da4313490479432878ceb0ea08ff228c76a941a92aa54eba739399a70d00fd961192fe8b66523891fb23677cd922f65c94fd0a053e19407744503dba6697b35c8ec95b69a4785f023a229a788e2fff29cf95835decfefea1bf0c5e0abca94fd823c9e450cb5e8c12630e72c84de9a5fe2be0462452939dce265349f14c1842efb9b7697a3dd2d5422c5de8203f2315db91ed08977fb0879707510735031747437daef240eecc18e7990724121bb23b3a5a7be6a44778e2ed700b7feffe4e0ed9e6920e999da38c838262fe1ab4d9db236da1cf30753a3a07ca98dcd9acc1be64b15a63f924516b9cc81abee8e1fdfc65e17cc0653a7657dd8d5e8201ec6bfc5a63ab8bd38bd145d542255fb639ff4589a1e409649d7480090417cde0df71ca80b282be5f6dbcf952e5df7ea11d7a119e1679b48e8a35187960625ed5f1f02a7ead8845e741d6fc9f76d41122ea78e1d1d5785194b088e5184c50dd1c05d4ea072143058517849b531de88d60687652a4bc3eb1b8fc7a401cfa340e74ed1f74556b03aed58b615e42c8fb98beccab14a08a111f20aaa8798f7f877213f1c6c192fa1cbcb3793be7bb0c4fc53b76d5321bf4288e396697858daa9751ac68d9ddde01a82bb83f6e423491fa5a6d1ad142334a232d03c248ee8e071feae0f8e3608587a358679ceb9a94c5b925afbe26344b162680ec24ee5cc71b504763d91500eb4627beabb8122a0cff5232d498252d46f62680bb5b53baaa140fdec161f3b54625a1b5f56413eab7d2fdb6bf1bce887dbda02b55fbe1a3dbcc8c5f62dab2d35b6dd865c2c977f57dae4f3e0ee96ce0de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
