<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa817a799d2419c8fb74a8b67239e6b526dcc9b61eabb938017c7e6ad61bcc66a7c51e6ea3d8ae4a40e63e9308d9d5fea1347fb3aa83554d013295a30dff7e68fa0dc946a87ff3eb5e32f1d61518e6c9fed44126146e04de56b4c3b4b70ecb960ddef7781aadad2fa936f38e8d5c80cf1556c67216a2dd6ad75d4442f623936edea042aa115dc801e0d591cd9a125db1dd8fdccda2192e39fa493c38f2a53c024c39d37ba8a146d516bffbe27c19e87560f3910bae208f7a65e9636649e5cc4cf06f3074b5762b7c4a4f506b0ba7d269e55ee1fb94b2e5461e163f35761c8210469182a34e9f6a28aced9e39dd46ec3202359fcf8d97577495c0cd8bf9b7e00a244538bd9757aed8699cf0db1bb7f90a49670fcf6d27433a54ec4c977bc46080aeb7da778b92ecdec2b684e90d36e5b683b500a1d79c8daab668b2714bd5af9d046bc2f984186bd44fc21d7da31ce1c5463438feba81ea8d68cb44dd12d8264d389c53255acd9fe96d0e8a8a5aea548159e7a6f9b7d3b139f98b0438ee0c085929919b8d8128c00f56da0f2454fd68029a6d69f2e350090a5b0595d60875f0cb0c91e8195bc596751ba0c8cab845729ddf920aed0e6e68e50639c278a51141a7761a48754d46b91b6f934301588707d818aff7a6023f95741dbf57a65d7dcb1f2ec0ffff3626fa55ceb39240eb97d281ebe190c093be73f4aa4a05c3899e0e72eb83c4c5603350207056c4fe28b09ed5e7439038d491b2fedcc5cd7f082cdf9ee2c1047d749959f03448bd49be94f41e95bf5d8984e0353209e94344ab7379685ce2aa3d2603600a591ac316f4adbb6ec99debc32e30a8c18d0cb18ba287b444c13df1eac84b66e19f2336960b3c10d06c6c7774509dbb6e02272ad5b698ce078ce5d22f84d5a9563940b12facb32828cb14070050ee2ebd4be07d0598b8055c32419811e6f5c209f3c78bc944456a1a93a396960f30ca74f4f7673d4ebf3fa3201fb42d66af28ae0d498ee656d5bb98cf25aef09ca5b9658cac245f23f63e3dfeb6ec31c3abdebf8a57f2bd30f49ba59277bea9272e1582b8f7afbcdd09f159111e5640062e16fe202b3cd5b8d77d08a0a02ca4e27666f2c66335698aa1ce94d9253660acd494d5862b17d616a954ca7e655914d0464e1ce1b6bc8b0f5fb15bdf556db5e0fee16e8d0420538c566f9965b2f5993e07edf209bf50b3b31ed4b70b0adedb957543847c371ed86b4566a81519f7e694a0efab5d7b4d191181a09c5069d0751738e83cbd575a87b0f5b375d76645a94ad53b483982b9615d8cfe1d9a0ee638f8751d16fb05e6674f9fc0ba8885f191c90388f9a8e0af52935f209e324b7beeca1e0f9f83ea6545e9dafd40b8514fd3abc567cb3d3bd33bb95bf974d94478fa5857f7639f004bb10a07d0466eceef667f6904c4398e29fd522079d016079bb9bc65e3a3f43c1fa190a798862edfa3df493ff78b3053e18bd77812df6191e630ef33585aae48f7da2aa2ef7a7949086156147abee0305dcaf85389e1f922b29773efe569db86d9bd1b36fabf52f5c6b35317692bc4e15f01dda48455e364a9ee04d21d0f5063a829e4ec71c5afd83514903a7a37b56006818d6fc1349b9110cfa1d7b7d870941f679c380a77b48bf39a985d343ff1ef66fbfbd206ae1b8ab9298d5ff1728315363fa7a150f7211089395de7e847d7e2e7f19dec0fb79623f84ac348b6d1a31014da53ca8207ecff8c93ededab5e1e6a0805f04bf0a46687c316e7ff3db2725e900eb5b0ed049dcc4cd6cab190272e745cb06bebd5df571298f8eaf32f4637065f645f8cbf4b03be482af9aaa705beb04491e0a1f889f8b5be3c924f7cbdfc74ab53a46c9be04825619c0931b0e2b4f8a8290a5c1d5a248b61bb7335102399535582a8b75a106ddf660564179f6950cca64a47bf3ffd44e9f7e4a922025fb199f1ba54d15bd7abba00248f95715a80b829c5a5cbfd0eea7f738554cdf2ab4cd0245b9a51cf26c34d1ce8b395bf933ac31bf7a3110aad010aa81bf91567bf88fb3bc638c0fc6c9160a2202fa6263a01b70fa7a2d161fa9ee5b24721ec286045f2b67786c9c050e882d885540428581862bdfda468d04b2cfd60fa6a8d1b61b2ac3daa4cbc258a15d8871980004adddf410e41cbb39c5f50f643c50bbf38fcc62a4b9e11133390dca52f3d6a155a10a5125a2cf303661865a0ba16b37d089a9ac253673c0b80b5156ae0e5b5d4515eef41c33c9feabc8b20b5155a3ba3e55f8ebe862ee484d07e1213bee433efd62085e859a907387610894f9aef4b3cf15290d1ca11b73e65f693d3f919daff126d6de5823b324cb325bfab92f94743696fcefee3eabef65c94ff897e432fd61b10fe07ddfc13cbf595dc65bcd854a0c842601717978482477b356a99b64c1472220fe41ff37143e3ef32eb0705e10d69b1c99661741c2ec10abe0eb3223b64d4fc45af4f9fe4c861c38343fceef6d731c49bc3219a1bf3aa1e2e2dd97dfb0e91e520a59fdff431a18d4820cae210aef498d38220d6550a4e8244d65ff44a4e837b3cb6db10d7f27775021d67f26bf1a94efe32acddf9f688ea500d464bd5509375801c0ffc06a7fb417a32a862315bddbcb4004c3fb34e068c676d8735d3a94befe9b1d39088d364dc39b8eb4bb53be113f04373b7d3ab55ed1f5732376339bcab366e880e292e7393817c80e771bfeee425913d95e32baf46775def665695e8cbf6569f751e2dc963943e84ad9be11a8a476ff2606b07d7e2ee260489f25eeee511db08d87b681581da905c0ce117b65b60a02f18b9846e80c68909486ff4fce69021f7a263973cf82d56c98545b51fb87e10d4cb8e8a38ca09b507d538f678dfbf36b60295b93e03accb21121ac706fa669653a7dee2cb8c079179aa7732f8c9fe2e21702558bd09746d5dbaa8c1a4e8776e6d08bab16f04964350b2ab9741df6a716eb1edc244b815d9c5e1b3b63015c59c57f7465e76603357195e2dd1cdf97bc1bd9c4ac4f7a79d98f8b3a1d319b142cdf750c56bcb2f6ca28355fd2f4da5ab86a73a7c788b7e0939e679908580d5ad4abe0b7d562da9afca1ae7b9e19072aff64ded8ef0bbdb8d3030d7c6a15ad675196058bb0dde2a79559642da34a5a015a2370dc8391f09363e03d97fbb3361418f599cad4e0b8ad24a01283909a5a1f505a002d918d17fed8557415cf55ff2c348167c9a61304da35c4c15aa1a13143191f70432677c00c9c14f69f6f1f9a283b06d034a28af87814501bcc615b4ac329af631a7085d5b4239e6ee788b87e8877fabd5a20a7e5d6a655820012d6b32ae40daf47cae8e77b767c067b85eab32d0ba36c356c3bb09534849b7e11db9119155997abd121e025ccbb65acc3b7576176a4409bb3280de2068d64e8e648e23287d016d80ef42fc0c01877d2aa3d7973f970d98ffdc4868f23849d74157f847b1318763024aadb5588f3f49196fec3547a94fcaf517c83b1c388c5b6b6ae246bf0f0c4d21ccf2ba92b1d52daa7876a3b34b2cd92bf24c3c46635176b9ea2fb8fc7e97b196f5325b631853b0983379d4f476ae817078522cb2167a4e7d100db9a6aba4d15005377216fb4fe5c743056655f72765b2eb84040e3e617404ced85601b63d2864fcfee36aee39a5651ebfe0a719a1cab259e9d70166b1de1c2a3dd6a9d3b6387ffaa22af567c6ff9cb5ad05436e68e79ed36d02ccccc2b6aa5f84a5508f745bcd02790758ab6c1f6436bf5f38e8b87dc4e922d69578d34d495c7724e118c4631b26b10a6323fc1ec1f9ec0986a89a368c771618ffff2ee09bfb149fe1f4d16e5517656dad838224966befae37589be50db29c257a98b4b926b4042ac6139e40b11b7a05f5b2f9034e32bf2726bb785697082c87890dfcfbdb587ab8da62ce5666a5c8db02dc1d8299f5a9ba01818192f3ff8457778c9ee638c976bcbfec1d497851f450a7665a2e4d66ea06f61c86186c996e9350dd611b281145e2c7c166a7531dbc0189b7ad4f6843a1db615453397e31276e418c4bc357466ae963cbdb36d7774b46a778c67599850d56f2ffe07c3e9dfedf07b5f3ec8711e15d8eccb7e3a77643a421b39fff7ef5675af92b241c154f7ce4b06386ac8a96b3ca3662caf89648af5550f859b30770a23282c386fdc29d6a9c5131e53a9bbefa2b50cbe9a6faec9ce4acfe64b5781c887707c9381f817cd82757740f331b66fff2aaf1a93ee1431d8080cbef4d6ff72aa1ade3d0bea0cb73bb41c9dee7d437425d1f013846b0dd98e9f36602ba3aa3d915a9a04d371a67a28e55a628e0779c163286f8f7074b2f8cc3d94f93a80307c1f448b6e182d8452137624f400e4b8de27f661969a0bc11f6f66c30d871d1bfd7897c562cf5b5d18863e7a5f1d46454baec109b0895bd5e8eddc67ce265e77100904de6543c38577822fe51144823340b770a5011175f85615d4e0981eed3ad8db7231e3fbb721f845cb05cef408fda1d7f3de0e4f1c9d4f83bd9e1d0136227b60579423da230b6c15013b71f22f9bebb40a09fcb82ffdde8acf7a6e567230db0a2cf4f33d862caf9f99b59578f8066b9216907def3d5eac4b69defb6c4aa47d92c15b2da139618052f558ca9d3e618320d8c21405e1847875c03f2f7373595785169b04491dd3c55fe9f0aa30207682eb12eae5169ced47c0578b94f862dd3d22ade2f188999bfd6cdc2b57c9a589d1b67356a6800eb41a9102e01a069b8bd93e5a1c95309657db2b59f8d5981dd797dcdea8231d4eec9f7db352e8498e3b22d7d7f24a1b476c0ee5cd3945955b3b2e5b54f89a06e913dfd590f03b1ebe8f377efcb50d5af99a00241e65b5773a152c6200254bdbe323b82db2b44505f5e987c2fdaaf2c330cb2d507221e977b9a39f737c3dfc457f7ab6bced61d26345e8289c2fc4f5704baa9c9d90481f6971f41bc2922e91296d4533513757c6f1410a96c69606b569e5430a8d3d01db72b8350c49d14a6ae71917b61363d15b2104186afb7615c862b49b631459887c39723088a74118b828a1d5441cc0eaaeee08f1d2b23f5f6e88396fe2430899bb1161d015b10ec1e736bbc76756bb31d5cc3c9191e0ce5611c0581649ca872ae5c90613c2dc4ff7f44bb05caf8c7b85093b9f438d49bc9ba8c048df1d8d50e7ab511851086fb1a5e960f6ed5dbfdd347af6ef1950afcd996562376a714f27cd3e16e65be92b770ae99d790f6b7c1b2b49dff29bf9bc038047df53316138d4cf22d824620fc568419be0e1291da97964520179ada265360ae102a7beba071019d7ec48d7f624939de7794955bd2491af30489506f6545d19cebe48a4afe0f65505e38b92ea681cf3aac52b86944709fca42b3fcebdec453159862bfc03299f244d6c9f9934167d586438c1fe3177bfac0763c8d95b64359c01dfffc98bf9ed73555a7d69dd72df5ac21607c988469736579c44766517bbcd35488862732e6ac52dd9782b571e80a9932419bf092b47846b29e75f8e90e3a1b76dae352a7a8d2b445dcbb6a9415b06342d3bcb516b634cb42401611ca029db122d79bdac4bb4897d4bfa28f4b836c5cf544475383e919ba6d7bccf5c614510d8ba03d76bf8ccc861ea0ebc578c14d7e4d7dda511e5292d3d3455a780d9898c67c08eb147ce363b25282be748961cadeec42bf8b2eef44c0f0fa03cf07094929dc7d3ca508e1290a0cf53bc9a53a6094235932cb23b2e52bff8aad594f84efb241690db4c9a37732593565534e73fd57185d0682b49447c484c1ef0ac8601fb3f10959827f2e6d880c32166c232ce741172802fbce2f5cc7f112bd9cf0f5968ba32cad12c9982a99bb9b48e5446ab898d51319d3f16b9acffffa4b0fab748269d5f317848add3928adbfa96fe5282e42d1acd3ef1ab860ca236b9c311e9f0e71b9a73d3824acfdc921df808934003de6419546478146c3ee0f1d124a4839122778019077720b09ac9422d785586b0cd7ed2095936103a19e80d1c6214352a2f2de785f49649e17b6cc426882d03b251304002401b49e2456eafc4080ff695cbbeb37aa0f95e6548a7f2246f888ce00e50291c62afc4c065a0f95bbf0e7a35f96b52af4b79bc90dcb2df46f9188c31c55b1a5798b1557efd075de06efb39e80373bd463edc4bb4842ac76142bd175521430c986803f5cb8e904b337f9ca2476633b11ea7d82b49af71fc55a7c26a5869b913ce2af34419bd0bc53e3e8a251fd055d1e66ed68385e5684e86391c0fb38615c25b0245ee71127c3b9abba281f738e8b93c783a35b16d4562d15754f57c1a34d7e3da229594b396cdef9ab0769b495292e9566c62e09213a8a51f082b5158c94e496d7e0a3692321024a672405176694b097cdf9afcb02215ee2c1b48f0cb851b51f49296585c85479092d6cf55bf204585cb1ef940fcdbea06e33c0e60fe3e798efd8e4223c0a0ac46c589809439461ac34ca5a466ae708be1539d9e646a279b01e42b92586ca299499d5a2e7694b867ca90b011de266e7b5b097dc582a43f1635d9c3aae067b4a255aa337c6a7d6c9ed0cc138278699c792a9b1d1e1c8818d409123921a2dae327d206aee8df5edb96203049e1676baed328ba16d57be32f0a31d8dfc38a1f6697d46c66e9444ce47422e91204432d813777b81274c56b7c1ab8cf697abd46008a8505159131136076b92c7aac7bf00c1098d72435f1ca55178678241012b6b098b9d656f2ee9c415eadb8eac415694e0ce8618bf1a28b69ac204d7cc5ebdce034beebb93d1e47e6cbeb9fb46c69480fb6392822ae99cede9db5c84168e89ff62909ca6b4fd33369080b413b14135ef46c2ffa3e21f9c7696a9dafb2d4e188c09a2303dd74cd82bce446792a00b96e8b10f8b7ac510de5530940c0da10a0234006025dd9711ee8d5661260b4cdda70eade0f60c835856816240fc519a699bb692f2f6f1628f6c1bce83c9e554288f7882d623f7222d022211f585d0bfd225572c8b63ec791d851a311b9b2a76d7c12422cdc0802340f2a5c0ede79da9d43ba21d1cc932f30b76a88309ea9ac1b78bd13c8727b77269ed1f90d598c3d44d3edf0d00f28ae2c18cfb85a77c18d3510d3afdeba0eddaab9f35471a5661cfec2f837bfc33c724e3558971354b9ad8226ce0c190e12dd0a2c97b5d6abb5d0721a4ca587db1510153738c6be4008debfb3d3dcbaf0fc8f84ff178f35a22b645a305e4e4c7ac3683aab39ccf2f1ca057603e16ab6e4cb8a2d50d2a96316ae6ca635fe8a1ad6c1f761558ce557f4c8f106ff68820e5086626ea88a81ebbb517f2423222aa8ba291c2d20a43493a28ab56208320f3b6355c449f54dddc9b3aa70e0a4d18008e425810e2d369069e0babbc98bf80cc22b959912d4c0b9fef1d7e6a9a2a55255f42b590625107cbb6c94fe90ae0c0f06a00f4d28233bcf29b3177a07935917f3e6b484cafa808a995d764ff8f2d0bf3c7e7d274970d3f55e4e24427d236b1a565b67223a059d192e8c3110ae2fb95bcf69ecc9fd27f9a96d6f3bb5658fac5635cc612b4ac5c37ff5ef74a1a689ac68ad27443185e902f84dea714148f8467649351f7a390fef8ce0c03f8277cdfee9598d242054ac3d44642cfebee81d75ec4192f898b1793dba5450be51890d7d1d03670807d8c49c5b7b03e7f733f6267c6cfbd0efde6694672124b26ab430e233564ea7e0aa1d4181a4b9ba89885c0e117354fa0804e9ac30856d243780692feb2c62cf6ed96320c73bf37d5169698e669660358c2801a2d29fc9f4dc274a84dc4bb3c18d4a7e3ac1c27dfec716e93369110a1fa19b1f9e2cc88c85c16c39b28b3504e1883c7177a7ab48e08850f000bf7dc36034c650ddb6130cdf7cfc56ec605e49fb52ee989a12873cdb023184dc252e65a05eaed5fb4545f6bf71b796b016fd1448b268245170e955f0b3991ef201624a5cf13ebd4eceaecd452d07d3f07c31735d28182ddbf3d4a8ff45b56fcb477d73a396c9b69ea1e3821e4210c7b3ca50a9df3696f43e4c66cdbac87fd6b4da67ce8c53ac54a248c212d837f6f37b1bbb4a5bc287e75f6f2ff285c0c9724e48396acd114808c123c69a424ed85c171f23849ff63609fb6ab372ffd6dcf1966727ce76fdd2a80bd81d711a010d430feceb703e42239494a154d504a07deadcbf87beaf08cc1c38164ee231b0ca4d24d5fd01dd8fd2bfcd6ba6b739b1ee6005451f8e7ae63cee8ab03cefbd087f7f521e5b3957a9f501f46afa1676be1f74b02af17682b7f0db6c6f33ebc8debe06d411383b3e98a6377dedaaabf8f08b2e41e2ae6588b90bdec7d2196044e0b8376f9f4fc56d9a1b839705fe4a052c5c59dfb3eb46ecdc028a3a29a5e84861e51435bc8d81821298faf73e15f9c4cfa0d2f0f2dd86702b635136563a279baf8aff2eb900be49000a4ae940129151f2dac1c8cba2d6e1118f61741707bc216a6b0f1d6aa2dcedbbfc8a3c8cd18058c124de34015ef57a2ed9e391e926d58a3e75a8599c31cd2d38271360edccb7715fea13c2b6e0b072987db258df546da9c828afac3f6965d1dcbf088da368e40886a807ef268f5d85cae48c96d10eb089678db113ff7da7d528e35e99460a7856bf79371762abc81f9de3585ebace4b6a9fac4b9819d4e3457467f08eed449c92a15e4df859b5e4c44466fdbb7fe39531c66059ad201b9c76fa5ee4afd6aebc9043910cf398656e875d361dc63948447d1f4d3bb0e2f15ffa01b564c5adc494370a2e96b00c0d35be8d4cbc6275aea799a38366d2e8fb66c59e88967f1828387c2d8f8c442656050393d8ccc272c70b002770beec42cf5fa5eda4e1755a5914c486dffd7490d8617ddd2e850e0980b5f670172f791ec229d8e96b4ddef9fc9a5a628c3823bb8246954fecde21b55971e8f271ed64045f17f232f9dc6f68aaeb359614bc7d638325612ffcb6ecc52e3cd6daf9fde16aa14438fb32decc60c67735d0d4cb94f5261d710cf7dc353586eb03510421cd034e5b4771c49e2bb5f7d3e8db53c32d7acca133ca3cb2a0fb0e9da127cd650415e496ce96bf83ab6757aa686781c5c44551e8883a20c5f490ab6dce898ff97c43bd85602a8d89336f13daa35cffd707de565f8b726fe8c19ee78d72c899ba1e8be3b29b487688717d70e0146406560329f481f08e24f930d5962f1855ba306b9ac6bcbdf40974445d09903b5f4f9e656fa045f25a8fa8a21f42ff98b91f9ed870fc3eaee4797922619c3dd9f21a25f154b09f75fbc6b9f1903539f2ee10c487256689f09ae1c00d6376b8e4cdb0683c5649700891395b09211263508133e0370f195390d719f7c5f27d07103dc9daa8c11554b3f6ef0d800457821134d735b181b361a31163b5aa752f69fb2bdf10d6f706097bd92c4b2edc6a35c8c32f30535e40215b094728c7d915ff843c48e3e6a504194b3469604fe703837e0f49cd41a1e3511f329fc1789b2fd47c3a0cd8ed50228345601f3cb9b2a86c1b068b7f9d7f96cdbdd90926d1722b38eb80d7e67abfda89e6f8a459fd5ff4ef21510b51d4974c0beb5dc018c54b283ece9748f0da475dd8714bc76ac624fd34fc206fd4649d71a7b52d7fa30ac135dfb0c82b7da7c58a8935a48e49bd046744fbb13c796e89c483d3802ff409a277eca8a43a091fbf26adb89aead066fc3a0742a2d92fcc8e7e6f90b9c5c3710b8885838b0ccb6f065337040c109d7f1b1457bd4c8d50d0c876a75904969defa6a74d185ca35b46b7cc9451210d70b2b12042b26391c2a1cba674d1a9b66d0246b84f34e7ec10e1bff966ba68a1b682537e138045cdf1112a68e8abd78b43d4130dde357687deba898c8018a8f9f0fb7a482a064137b37b38af027f794867f27d2bc576065581e21b62aec8cfdf0094e92351d57319cbcb7c78687dd4c850e75b0e3f918ea48d24a032c88d4ed991ecbf90c9cb9fc928e94e4d343d9ca0785e3e255195ef8d6f9a42fdf5c227503ce66492c6c091c88216b6e6c38eb6931b0cb28c2f6608b757610a7cd2ed26425622a9f47b54b5c6f367cd3297cb05664225b4b265e1ef6246c0deba6c37a61dd0315564d6672647c9e595a3e7ed873c228a6ef476c2a6866bb420a77912002eb969219ed40c233b35e06379e0492b5ecef5f8bba3307105f0dc2873b977e823cfd4473173b6d77ac7b0fa677fcc4b2e2ba18c20492f14c6de85dd0f003c5ca0d25a33bbd32baccfaca311e63d7096ace0910a30519797811801a203950178772a77b4b50a05500cf0e582680199d944071d518bd5ec9a442fbca008f35153e2ae3f5eccc77c876c84517d8a94966697bf0f9719813144aa3a20efb029df9445ff673b54614a860311aee6fbdb89fc8bbdf9b93ac782aab236b0a834397d72093df45bf12b24d9cefa876f492f4dc61b938d9dbcd9aab1ad0a0dec1800aa8b66770e57b41cf467ff72e616a5614193ce2e46ce2053ae7eb8bd0898e1f8f5a71a387945f4feb133870d75adb4bcc186020929e0754a348616983e0effeb1dd1d465e94a02452ebe9fac5ae9fe29b514fa16905c6e8298035883d56de1ae03379b934df42f9a5b27d56109792d3650d4aed0e12a8e9a2218f3c9ccdb223370d2af7fdbbccfcd4cd18f1c291ed748d76359b3ff9e37f09332babde0c9a910baa94780ae9a31ccc014e23ab0040e0e2cfab3a22c69589780d2ac747ff2bdc99b13182c2d5be686a06774790bddb91a6f63161451f5d7033a4a83905f63a3005dace5716c62ba707be1ebc8eb06c42b346459b8ab50462585d9a8cb3e98b47874deeea9a87c8ea1750ce92b4ee38263b77e3c5b514d8701f15f7ad0f6c611158827ddd5a713ae3a1da6d1bd08dd5faf34241c27cc447e91574256d9c2a8526d4e6fa32da2c36782010831eb06341063caa90b3ac0d815a3d8285981f9b772321c7e5aaa06b4e53142702fdea3e6ce03f859eb8c90827411044425e72d8bae462d132be0e1ea4ebdf3d08f9127b7423ec2bc01a8372c97af34a20bb2c7323f7d266bbf3164f4ad7e32a3b3a974452b28914529e7feacc0aeeed522f675e39c4c5fb85735036097642f0fdaf0e6ba2c70c8f3e7b7f4f4d3a9c4e7af84ca510eb0a06b7ac132755600c48e32730bd3ac3189985f79e147eac9974ef2f631b28f89032b1fa71f603b413a05640d8d70c4332950ab11a58f2f134db1b633da9f0c0543e3a9961a4972d0b55b671760c501caaff6f6c3d951fab5c5aca66f968ab1a86fcbd04fb20cdbb77985040a883be2cb50306b10ae4d78670bea18721bf2e30c94c3d7b18d964d5a483f54e03903184b53454a59b982b8d14847962240b6940ebdc9a6c33eb9d0bd337050c06b1d9b998a1c1a305c1185b4a13dc536199253230f50962d371fdc46b1bdc2e330a63d661594bc8d8b880c1b9b7de405ea1b575c54a3944f51a63a9471d9b01acb47c16acd6da8db9d41c5d59fc144cf4569d1348951f49e012047e28e71943f204bdede0739ca4c6437ffb1e3b6abb76a918feaf34921acd9c4403b8bfd76572d0ac1393478630a2aab9657a795f386a0ccbf85b82b2e340da0ba62a854d08ac5775c79e6eaba2b6edad34b39a13079fc2017fcf0869b40f099ad24c58e7dacf3faca2e13c205b7a670fda2653b60fa0ea8049cf6c6329f76121ea1b7a735baf466259b70fcbd4dc70e1dfc887e51b776c3f9b14ffc853cc25fda3ad03973b12f4974aaa05915f15affb1fffa0eabe52e60826e05562c34bbee65133dd19fbe38f3f9e5eb4b7fc6f68cf9e53330918899cc4903e91e186c285de49d5dc1b609c24ed78d550fd8da7c5a5d5c155cd1b3acb67aa7053c90f853f000aed80695f2728ba8a3dc48f1c0b2175bc969bfab0cc12ba1aa41c8eef0a19ebec88fed6eca5f85e3b1023aeeae54ac9b431256e70f231b24312baffea933a0842357f75bacec1b1c950d105ad72868d67e47d68fe63e82345bfa7df1330ee664ec7ba1176f05959ee1da7f56fed5ab2cc6699cc20b98db3d0a4fdb1aef9f48a6cc186cb6dbe839ec43ad8af2d050b6a8e20fb8da3c8eac0198fc0fdbd3692279e6fb597e8b626c1b38cff41a72e8e7acdfe37f9bd551add33e0ce5c26ae3dadfe082129363fe48b5558bfdcb528fdec1db4f62dfdbac263692b8262239e012db61cfa1173146ff730eb70c3d64f9a114759f4af6c7c5d4094387e350e699eb85c498e892c81691feee4ed929273d8b584499b501642411797efbd2b105e63086f24bfd736c719ef7bd1c3c8d3d8cd132607e27a365f3d96148a74d4b91000ae85d9c3ce533f46686ca66b80654cfb44c6a522e57cf5ca8f98fb03de35352d28a88409bc59efb1eac1409bdf5ae1362822ddb9975608e79c34f6a60787f1ddf9514733820e9adbe1323d403e0be0cbefc7915a749212cb222ead9fa606d08de7dc1bca0e6414c6aa6d5ca314fcc2ab3a07564201ce543e069c76a64d311c9643c1f246507f6e89351611573129c4088360ce289b12f93bb4a9f6666eeb6bcbb299eb8e4e04789720d0d412aa72b5907268aaaf8a0b28764070f4310ec06d2c4e71290d31a65de363ab8d03be3d8b1f6c1182b36f38e569532b299b9f00de1c69594fe704fa428334ee28853055b9e5f35151a12c12822487fe090f51efa4c54b67f9e63d32930dc572867aafbf92476118445924c68ec554ba8d6e9550417f977f81ee29356f5048d6e2aecdd1a9e9896149d692d22a8d493ed0139e8cf5cdc92209448b7f854798c5961ce57b2dc05036133cceb75e4e025e59db54d05a25c1efe15b52d32c13ddea2bdc2fdcbe36de12bd2f9265906cc84ba840389d6cc7d098bfef289839ee928be57bd5a0ca8c12dee0ac29cc552d12f5b74dbfe0a5c2781c36f473f54961a5df3a21400459399cfa07c930b88171668d7c893039e0a7bdf668025ebe1ed9c428a3de5db0a56aefad1761aa9d310c63793fd3eda9836dda109e8d9262feef4cc66ecdf30a59a4a8b0cfbd6fc948c411e0436ebffd876aadae1301ee0c59112050ac188cc290d40e17d08d9971507072276a5f498ea66f913f9e65cae4573471d6f3af571f805299f764b002e3b73ce7487a3e2c65b88528507ab7c65469bc4f4f5ea6380dee5c2c9655b837f0cfc29bffcbebaca3f18859d472055797e3617934d6020e525062654ca15134a888c849ab98c07f3a2392568b61a3735b1f3ad44ed6f5982afd9859b028e6a744da7049c75785e376fdb1eb6d9681f0d9aae4ad086617b7705751ec7410f8309c7b7e899133c3f195c1098de1e19c20c2b385286ab3f190b33bf1093c60b58dcd364e6615c88fc99cbedd8f2bffed6b440e7d15eb96fe68a45bba16544ed0d5eb9a69b444e9a9f165033454d47dcfe2142196c97505393709817de0c5f62d10110e73afc84a9563c645f31e40fc57d17279921f23a7f560a713076f4c995179072932a3962d175b597af347317b920b29e29ed4dbf6614e5dc6ed585f3d2cec2dd4ba94feadae098c6d5f770127703804f0e98626798541ab10d6e9ac76cd81e3692f6174ce37744efc7860b4cfc40e6baed3fa817350dc3517b9b01388d0ad56c8bf6d353850e65e492fece8757b2769d0715e2f1b5ecd0f7621c2bfb081f201324fd069616682c6731b203daadbfa74a222569db4a0deae7508466232255f2b4df38b2a61ef3f2f173d736443ad17f18a8c19742839b1415476e8641f000cb59e8293a6e85c12a71669c2c79fd244e9197e92df12951cb5ae282b16c2ce8b7ee91c01b9f733a45f033203c91cd8682c4cebc3db599e0f3191ab395d66104c169335958fc38e0c56ae597fbdbb3e3acb63297127cb79acf88586a501bf85125d2375544571401dd0913cdaaa5080a277f702c419778d777337ad4e00af4d239c9f2efffa0213fb86c3659d06d6e6766a06166b35967308f9365cdee8c970db24321715445379871698dc8ce03214f1140a980ff900221e7dc9cc77fc45902f6d91eb85ae1ebc3f88170919d0b59f85cb3f169adfbf92ce604d3cffb2b873003ca370409a32c10e6b07aa35d8d9ac0c64fbe288f3afbd81dea0394965e6f1a3fb04dcb66f6d05cc92abd00d189a3ce6bf0c5781ccebe236b29dac37b112f54ef4b217ea6a4932b6eee245b623858f15aa3f759f3c32f69d9caddbb72521dda14779a0c18cf2a56fead15f78df12ac06f2814554ec82ca59007026f804c7322f7907aea475186f57fb8b8ec586aa51447bd5ff78b132323a7709b9b8aa14909a526738a36ff78261559d7563342f341479c9095a10e06b0e302315e199102e63250aae82aba27c775bdb6dd04c601eb1022009f82fe4ef81da3ab1f6d6beb9e185204c8ef823d0a4ce52c39d3afaea7db268f3ee4a7669f768e807f43edf35f3833fdebd9fbd7828f27383fa14766543c189191e109ae0df69bf68954f79e1e86e02ad60f69fb43b358e872db0a49509564056f367ba5b6da0dc8feab46c644059090e170ece7190977081469289be9601a9be8b8765410e203dcb2aacdf397a049d9dcbb1ac3480c6c92b9972311312c0f3b07b4795198e9200a7371ee980f7ab20dd2011728ef3dcc973ddec1db9fb8cd6dd02cadbe3ec10e217a0027262e62694cdba2fc0c4d3d675006d6923b5826d3aee1355ea3c3933e7f539772a3945ad10634d82db9328a7568941213b0a40fd4bc8e11fafbb4426810e823471b17ad659f2aa7e7b1947c36d5bc6f28bb601d53f7145ff05e6fc1c2f698e67f9f7f4e6efb9bb81d9160cafc9a423f15ddb2c304e2738e4cdc35a269512b8fc8a827fe7ed3a1b085c1168fdb09ae501df1de960881f1c9a840b9619e86e38dde9f94586f0ffa86c27aefafbe0ded50f52a212d133abf4b82caf464b8b085ff26c9c330f6d1f851777fd1706f06517357d38d5ae158504db52bd8f914447307f99446c84b91a40795fb18bad68660a54e26c30970fe089183e196f313a69541e0ca1040495f1b20d5a0b4b97d7628554ee9c73006a424d45580dd0aba22f22201ad016964e06f35c54492d01d8bf5a575c4e375b8534e284bebc995510a4edfaaa7f75df21016384c02a3e53d54f22db8855dd46f7d938c667ea059d05699912eae287e46f36571a8eadb594bba278899fe72d189336d95148e35222c18b0ebb49d18d961e332c80c32aba548a2d678b3c38cee1326c879677dac051a521f334c95c5b927f633b8a1afbd7614e1f3893ef184a66caf4aee6de35b93a1236b70eea48e0e3fc163af0bf6258b14ce5dd3011a864204d7ffdcc7c8b2d354d727391fd4e5659cb90967122bdb9a4e43204278f145fe0034a901096e36d1ea37db6c478ee6d5cd392fb9e3f9521f11882b3474db3db68a94f5b0744f479c5ad0ef32e6932dd7a148941f700d5b7e368a9ee7bcf4130a492297ec2b0217e93d9d211ec9eb31017f348cffd838acd08857f7db06330bfd51b15d2bc7b9d4ae301dd73571c13a964de33ecb3bc36c7ecbe635b8420d0467c73891f14c6b1cb79427db55d85584ab809ce8fb0ef064ddbd6121f32763a2487cfcd811521372c736a6660ea1f11099f7ff0daec5d405f44ac9529761853bedff3163b0454eb20d502c5c330a5bdfd063eb2653e0fe434695783e7a0f7b8e6c733bf4ea41bac1c25fd210f85cc81ea82655ffca78e05834bcc4adff338ff4a7e541c1a0a95801db279deb9c40750465791a1b05a9a52180d620b9d64bffadd6a8ad4559b8a20ef47a8098576a58ea8c368526ddeaa2edabb7d464f296bd3a940938f2473dd955634746c431cba23946435397dbe99300c905de48e2634bcc975352b494b3f936382a97d9afbd0a27f04f47f4b2408c0040ea460167134c18861d09594951588e6eb1d4c19c216f938c2eadffc3c0ae4014cfbe7535104b9a0106caa350135aa39538240175ad8dafc3661a2e9bf96ce6b258e2eb1b832a24f808c8df35c0a1a13803618b98a6b79c0cb4d141536db44600c079d2b03cea07db789c8fdeef169c0b98ed1781b825d3b95e34decdf6668983c233a4964244b54f6ed33f8784eee71b721cde2f87a047b9e0c18bb4ac610844c1c5c1ea22a74d06c5954fee76c7bd8577bd7c6fce5f4fe54cfdf2918874879229a78c8507d3b0edbe55c918c0fefa191301c20d6aa9978ff3eebddf3f5af146af8b376a61a88451d467323900c9c95e404bc36e2ff5d22414f8ae7b395c368777d16a6e5d49b95830e6ecd434735b6b3e41cee61881ec1dcfb09dbfa615f70085c8c5de42062d492015ac62be368f8ff04b7f591f2f13e3438fc14e679ceab7cfdae536dba5aee9496fd705929a7849c71e553280badc5d418cc710b4a9c7b39fa3f6daabf2b7213f0ae552c1a09414233910c0cb1028617c0210549da0a47ef9f84d71d3026030ebabbff28b220955602e654fc5ae601aaf3dd05fa14c8c0c7ebf79db815b5be2806b5d99d493f9f041e4b5c4db6274b7d9552b7b2c1fa7b27c428836038a00db108d7783eb553b3a4283b40bd983876d913bc4cb174b49fabae4e9466fabd89701fe9605eaa2f33a5b5fcc5ba52cae087750869129cd5cd716778ae5534e63b45bfea4b2bc31ffa56ee83673d75c0b54d805e955dc3f369835a9d11c2cd35772fcd06e18b1f0efcfba36bb0ee3c463c59559edfde60e5d2ba490f7faccbf88cadc2c9ed4bc197cfe75d31a4ce555b8333415d63d777de305330ccfd46888f305609827ed27db6b055396a6bf28625ccc263136b731d75635789c9a5b313407002511b9253f137991b3dea0611376c29ca451a0ce33293921991a7bd49eb4724674073a0a8d27ce8617e3155aeb215a524e9601d9000b9d2033fbee678b6f5189ad748ae1fd0e26d32881eb398f5636da962dfe877e8695200ef759f445000cfa470e1b0406b5adb7c6c0f23d5f6561ee66ba57a9362fd5f274b7c1eb6c61975517227c1a3f2f17f4cb87c9f0513447ae0cb2a2d866e85304ed66315d44e240c094a833dc49c2250a364e3262d51be99e5d1540ae2a9209fbed5bf3eedc802b1480bbfcd0007cd0c428cbf1f66f38e6b13a93f795b19fd1831b97cca00c6b6a16a6bc92344a52cfc378b75eae7f1176a71ede9bd1cb686f92644821ab4ace03b7cd2793ee7155727b91896bab3bbd62506976ace701206d937aa8948afe564a4da3b8fc145feb112d8b7396ae1b43d0a7fc5d67b06f40804f8aeba0d9ebca0b7f3a3c7878b6ef82a2a32dee90c75b36b080f82d18176bd6a792b9fc91e8faf4329e2578177864a983baf23ce168552bef67aa80ffe06012beaec5965206f083f1bf4a8028f03061d6b768121bf2b83af81410dadb930487f0260ca6b7e08c3dc9a6318ff4ba78974e442fd9c1feedeaae97227d39c8694e044bc98a140447ae81453d147e4b3d861eb38ee6368671b7d60aa857207e93a182d1ed76485467afe0342729592ed5ca928149e946bfbf74c1669345b07b1790ebe3365ac10a6c907b023c8679c27ab5eca458fd3754801e51148973fa05178e08fb01ab6c52d75953328ebc58c357daa00589dc006602531c56845d013a12d84c7175d0362b04d731bec18d55e68481567ef773ff9d1b6b593bf838fc9d47c784be473d3ceb3f44132d380d1c3832d4464b86def9f295817e07abc2844354dac3a07a523bacd38100a5ac13a6c28fdbec8fc4e53ffb7f4153fa179d01564310e0716d9aee2259a43d3f08a483259d8342f8d8312b136b5ef3440be32342eefdf2559c7efac83a039a92ae4cb61f73043477ca918a62d0722fe6971e93769541dd9751d091431b50735e36669c237f310ad0b4137413e1400b4a75e489a09fe0cd4c5eaaef409dd743d7bae79e4c06d932bf94d3451a7cbc2d101ef648a7726e94523397ed7fc6cff4363b41056131be070c8a82c5db458e084ca6d39469098862a928b5a8f00bc90e74f8b47b915d71459c5181fb45fbce83e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
