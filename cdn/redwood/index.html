<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e39a6aea1c6c066fe84e5e9e7afff51c7e1cc62d84f4c2d4f5d417d8142b0c0d85fc597fb8adfe35b7d0f5f02761041fec58b399ad7774bd6f8679886e33df661c519bedf40a2eb9b65d10ab9747db302350056ac926340320def6ac5511911ce0a2b244f8a8bf34badd656c18f509dd6381ae76f97afabff698b2161562fd40ad4dc352b3a3a36286f93340597046fe69acfac13559c5561ff14c3ce08f03cb9b57700c4e74e5391658cd2f9390189d2e05545a0097c2b44882e3f5f1058820f4d94563c8f60484f49fba1687cbb4d7a77e6136e3ed014811f7123b579206daf75e7e0a77f46e88ecb7ab72502f8e7a5076ceeef1525a785697bb4b02e26cdccc1d9420a13c0e0d1fd2744878465071c8a644c0cb79f72177d9778fb85c3538edc1e2b5811b0f14e6c36cfb09b030e089cf2c1d97864c27eca8181a2f9d6c0a3761a4098e0bc42cad3fd9c48acb068c7231c3b77cae52c8fa28d14c6ad080b1a4befe3185aad4b62158a9acdce17b1f930747e0e996a7f99aabcb7c1c0b666f9503fd4eebc7029c9bd946112dba587dd8fae103ad00e82862520d296f693783d8b74fbdf59ace08e29436293dc80081c212bbb48f712c7f09f170e945ebb9f1986a211395a982bb2e1c32356f96092e2531c5ee19668fcbae2429e20ab1b995eb079696833665a801357b8376f31daa89c429732642c38550ed1090c017f70abddf59744ffe42fc41676993655e66447f3a70dd414292dcc857a50adc0257b3940bc67f6f1cf99e317ae3f37b3e7330d9ee654af12b1e8688cfc94e4fe52c13a339a8f9c5d148eb6234246c319bf7f94229074a56c9a60840b8b144b9a15c4a728864dfc668fa674865a1f01c4fd98d0440a4909eb40cb380eb34985b0a992173410de4e48f95f06575f4787315f394290620591c7b541cf6d4f4b5f2831fd761f3853662c7383cfabc1888dab496b884a316583efaf4f4e4f8ee3e7d412c6cbcd5da56efe5a2da4c769b23276d20421156bb3db10032c543b95341b8ea42c3ac667a6816db858abf7341829c1fa7bac68ee94976a9a908dba226e035d53c54e0c8dc0068e08d38b17da2898cefb8476f56c51d56e33448872a7d12c2b8df904046874582d63582f05baa6d0f7d393056d3556bdb11d1d65dd20e836c1abfb195758c1c453b4c84859660f8275ca900600f6c87d3be0d4fddab0028fff2d55334dc3289cf9c4e421fbdca355e8316d751ec7acbfb33af74543f3c073812638324cb13b587355f031426d56043e9675348b65ca7049e8f7edf630e14e5867e222948585905c6a93af345ed025d2c7863d138e7fab50a117a1939fe60f1e49e279c1ab00504c1c8154ead520b7f3db983b107babc965e06ba806a60b7b1d32b505206e0c6426b4490a69a8396b7e27740b55058cc1e0aacccf600a3dac7a8596bb866942a89b1cedd445dc06f7415e87fbef45f4997028a8e9c174df55c3a269603d404f8b13483ad98c167b1c2c9ade68133dd6771292ac07552d5bdd320b4874d0e7c9efc3543a17d98e8180b6087164fac0c696161c739c165a36ef1bf953c4245597dbc104b9523f3343a70e29ef73c4d63718a124ed2b3ac3a7d4459434628ff4dbcb1f6538221a44b6b233efeaaede2b80d722cd41c1fe9fda017633967457a5b938bc210a2dfc7dcf76e734e2878990b7f9a1dcb7f2ee4bc9383093b5bb76d447d3d9c6d0697b71d6767117b2c49223e73f9f2ae4d416105c185a5c81e98b4529595b73cdbc8f05715212f40afee0dbf5ce665466dbaeb50aec33b7dc938385d0761b44a65604cdd2334a39a7b127997c999eed4c4ff8c8673a2cf7dd7ef2492f45d7fa8807d64dc31fb4315363cf8b53a35cd85eb33ddfd7c8f4cae5bf9cab57e08e28e035da03184f904c35e695ea1aba9dc0a150f39e92e2b6b6e0619de11efbd0001e394bc255a5af05090dbdd642700d03087ec1fecf990c27e3ae9c9f0c4745eedbdcec34a9561c1b2ee7fd554b53359d84645a0166119016989dbd282436ab28f7456861bc8ae63930f9410c7e82ad697832d3de17f1cd89aebf05db712e600393000b9781c9f025cd8f660430ca60db0bc035bd0c85e53ff5550628d97aa79569faae6ce461702e5e3e899d739ec6552c3123a9c495d77ba77684098f50e2f0b37d927b583f9f8dd6b5b53dacac35b7e4fb04dd44a100ec95dfb8532ec4f5f1510f85b5bef820a6bb5142d32ff602c481d659fbfe35580322835775ac24e3687c6a40b784ad934ca5a3c21c0e953cba5d691aa087dd7faf767e900a1b434994a2bcca992223783cc2784ecd50646b367632946f9a2e1f96a67870d8357acff2e34345dc9b9fc4f92d4b9504e69d397a6abeedcc720cd24f278de934ad661f26169e9eba6a2e62e13688c17d62e266f357e092a8049bab5366530b9c11cdf5e2c5a68d6dd9abee570c7016e8a368df78ba1e2e05b32391cd698e8c0f8a75827bbb911ac3219ef8502899ee731eb71c3c7715a16f36c360517466ddc97f2f203b9f7f35bfe56681fcd21aa5991109792ea09bbcd5b598feac5f5790a267d4fa74ca76967514bff3a38bee48366e20084dc6d58fefbd321d93d981322bf14a57cb546b4b98712a9065bbfe31c36b0c3d928f2bf5ed7b214cf413ddb43203d60c9ca696f2203f546c88d65dbb6df77a46a8fccec82d255c04d427456224d0aec636330dcbd355c49dfdb7746b64246c7dfe6fb9670508e1efcf6b4a4e8f2996b9fa47df920fb779db6c68363b26dac38af0b9fb64ee87dc8be6de127f42fafca80a6d71d957c7067939d1400e7fe813659f1f5a1b3093bdda0c92620703f85f23a7faea709536b1990468d9c744b50bc382cfb7c61c01348c96b8327022eea3bad524da6d7166b1fae5e3ceda70b5f392d654e0d1cfeb913f210e84b72bbf791754031132dcaa8368e392847589359e935c2a2d3493e3bf47fb6dd43330dbaa32046a03956c14d3fe68b53e25182944878d41272746523071c95b0bae3de60fc7abb7d6c9acd78fa61c65f6277e1b0331e04d5411831efa0fbf476c85d732500c005bdd423ead907a9a4d3034ba54ae385388642c5d2725098c0ff298b877f1ff717fe8f915e45fb1bfd72e16a05ffb0757f6ff3ee9367d919a8ae570996c95b36677c9ee5d36b891d97de5ba4b0ce357317a0fac58953f1eab5d524b8bd509e2ee69d5930d6a7024b11806a34fc20d48a3688cc62f20a7db8bb01e73ed183a7f586185f5065656b3009bf39d9a8cd73626e069be78313dd60d9a48e6cb92e374bd8284523bf4724c73bfb25251d257eefccbe62d4a2507b954ac287d0eff0b0278c7f8a01efdf1b9dca43f98522395b7f3a7512a7bb35df518b324b026abbe85c6734292d10fc775d7a6b3ecf6e1f2087fdfc9c716d622abba36747a8f760e005d0feb63cc41ba04d06ae3744b796d99d9ff6c034928672aebc9d40cbbeddc68cc2570d32d8677222808149a26e2df80fd265d074cc7b28444a64d92415e0bcb3a8c06fd71ba6d7b47ca5c97e4105b8f2af65c1b90f7f595c24c59c80f64938fb9d82cd0fc0bbae72c2a87e1be5c0f30a9c82ad8669f90f53e4eb3625b326beaa337cb45add6e721679c76f817c949f8452a6ee6f235d1af66ad9671a4fe3d3ae798475be5e8fc7e06be5d5b2be7d16ccfe1f05412ce86358992540531ce3e6b475283f6b03c6117b615549f1950b8ec6b239b67fdee498bb6c5d2153699b49268c34d3f3559769254efdf23f748a2570348e68ae176139b9606318718f9ccf0c96cee9086e8278033b23757a6ac8993dc438a44057e3b2eaec5e014ca49260367d001ee20594ec59a2220a2d7ae9bfaf7b4acda243faf0a5679937f62d0e252f66ca9ac13ad559a95ed4c477a63dab8ef96f53f6e2f127363852fe59483cbbb4e7a5d536ec48c1eef82e17a452a85ab9d5e47c6ffb6e1ca94e2c0c3b647a6f5bfc5a157bd446f5478e88946de4161ea3c2915b95f669cf87455c4198c912a9375d6bbed2a62ebbdfefb49cc02462bd2c6ec2306c3a4d9678845cb9675d642481ad9200caa53a7e033a13f3b6220252eeb4e30db2455931b1878c5228adac32fe72df2c172b483f494835964e279b1d4a0e7ddd7065e6f12c78a8f1545bc3b842a62fff061a08da0c9f37032be3309f0eebc336a4021f46392ed23e81209c9abd2041d1b416c9bb15714dd7a5fce2347d1463da815c5fe65841caabe3e59518a5b4f5cf7f6e2f10d83c26644725b957e9a5bb6dd0b92caf1fb445c688bbba2629388501e23362e54f33589f6458c270eb424bf26911e10d4c449d7f258c47ce4b56f59f97037b8888f39e65079390850022be2507e4ed065f42d8f5f48134e0ce6e0797f8b34c19a7345d1eda416494d8be005bdcb0dd6b7f1a3cc0c8952df60c03fb261e33fdf867a741bd76d4a10038d2b868b5231af7992146d7a763bd660e13ff069178127b6f20a68f48f9196aa181fe7e6ad603bf14e66a9e846b7f6b706fc0aebec3b433ea3581fe0030b30b600a3948323515a70237c346c810416d5cc2a51e08c01203589bea406dc24907e764cc8fab529a9dc8061057b03fd609825a683d5a4636a2b70770d7e011777376e46f1e3d808387c3d140a493ef96a81a8b705c59cdf45fec563e3ee2b020805d145e3fd82396a326d3a5847f294c66ac80ef5535733a28ad1bcd12adcd293a91c8f035a3b2e8021d32f36e4fcfaadaddafae181a19aaf7aea81e61d923e50e930e3da05d5b0f117ef3cb69b66b20e6cad8850c193323f0cd52775d163fa6df06efb251c5c239b06da19f342bdd1d8e20d5cd59436db6e8a07e8836ad0a605ee648a09db66378fdfadd58ffc857c01864af8f9b32472e81fea08f2ba21cae4cefc108c095d9fca2e91d8a1ef120e7fbfcdbf73fae8d7ddb1cb385949e98894675b23d8a1d3092665df11cae240fe5594354f05424b7aa8d163c97dcbfe8a31dde554f5871494804fcdcbc16fbb438c1df3a36e007782831a399755b883e458f0946870e3d7645d9e6d256bcf3bf96e5d332403c6a81fe0986e3ddb1692475884313304d9a1d510f461d9b52f30d463cb8a763c715c68261ddf566ac88fb4e6d74bb48996c53e6b7c5a6d4bbf1d36b064f7235952b02350d566900b85958b2fc9906c747c84d597bb0efb3bace1d8f75f7267fc1a752f6ee9ae836ba9ce5e8040a16501671933918735e7175a3dfb8e4d73fef89c1fed1f018c519301ce985570c203dfa70eac4946d7f43f098bd6c56e8fe272e1bec3816e7767c9e8c325502d7ec90ad4f0e03b80f4c8f95b498a01b3a3e35d77924d377ca9d5c80c3872c8537dfd7bb0ddf65b219aa3ee1fc3363b58339c88894772e2fc5ffdc5fba477815228fa7618ca6164792d870fb9ac6b939c245685971bf01048bd48e5bb616ecc3e9752333e78db41aca48b9071d622efa3f6626f557ab820925fe4e997e1de322e4f9042891566e2040b3a8d672206bff51a4317188f4ea148d515876f3652716fee30b5c744fe1fa3edf2412cef9810f39e61d688af358790b57ad77fe9f9a92f4255207478a73c63c83d6380a50987ba0608f2160ff16446d2c92b41aeac476745b0b3780fd4aaa1e002d70c239196ab3ae25bcda35027360a927222ef8febfae3b4943817ef38c2c18e380a245d42d8a847ea40ac23884a5aa372525193c459f65e914dcc5be3d93c367dc7c0f5cba4573e3859c1bdf05d162ce30a56308e3a6ed73fd35e0e432d5c95b3062a0becd2a124e5dc271a7a2d0194d7a34528c19b8172ac01803c3f23c42a50e8321a30f5176cf2276f4b5034a4bf0b875491b6ce97677dbfe657590834f17b76fcf466be64d874d581811c3002d1c33f8b2fc3a8b874e7f57398000f08638617d47f0baba7e14423ddfd0701aff64563b11f8f2a9abe7b1b368fcf81aa3139e8251e0c7ee1312f123cc098226bf5b285c25384f91c5edc965d59439d5261847c35e28069c7176ccd64198e008adbf63ae0fa9d985a133c0ca2d58f3ab9f27ef0c009698c463e96ccdde0623e63ccf8d63e0f42072433ec288aaf8e760408e44493e30a5f95022be192e87077c0f0812d5e43a8e6f926382f2894e7b6a92ccabdc2c5f645f2d491a09a85c98e5b843e5ab6cafad3715a1aabb08a03c58a258150098f8114912e1b11f1d5a7e7f489db6b19703fbaab46e85bb1c4d56a42dc65ab827b80f2a69d9266037a17c14fb6ec2dd6443520ab443ae0221f18f450a4ca4fd407fe1762cc0a4432904af95626c1a9e670c453c0ddbc364ea4ebeaf0f74c7634360b8afc1c7552594680f69f3dc92c475e3ac8a43915ffed99dc023bf630ff037ac93f288e26e04089aada99a75243f0beaa104fbbb4309af62b71a39d86a51e7ccd1c8328ea19e56d94e1b09407d633163d757db62b0b6ce2cd4b1c5adc45c17248b1efd1c5bc9732258c7327fdd893ad9691807de735a021df02fc2b770260d4c96726bbc65cd5b6a508e0b627a03fc99d7e08576d4b7962ad4802340f2153b36f99812965cb5d8342f857b1a0b958be1c3e27cc11cbe34248037c41a17944acfa40df32ff3468935e9109ef6dc01ec231a9d372dc0d31890257e47bb39a9950e08f1cfd3e71a49e3ee1d794d3712a7f7668777a2dea27a4a2ef15da60a35521da3e8d28332a11ef02f2ca33ecae7799136012c8f2f392d49a7f837c3b9dac80762dffc11462d0be97ab81c9474af02a5129264a2982cb04ec180bf9e844a7764590f8475bb6835de56aa3eeb027f379ead210e7a35ab974c87f12904036d8647a142016db28cf1560d3feda5008d32696557f21a3c150b54c0cdf50d480f75266da9e0c4dbbc8e006dc4a50cea00264eb8b5bfd2ff317576a1e45a04a729f8495991781f1ee09ddfae42f51eaf153722087856702e7901ca4d2fe1c046a6d2159905f655d3cee5eccb709ab38c69cb8d61d7b07fa360828e7c65a71e9ae142ecc4d01ecbe7b227f4f2a8bd5850e06d8c7892d9673cd214e9111b8b687a99f60e74fc9e3f8b22bfbe532ea178031d0af9e7ed961b40e5652217f88eff0f9fff3f9bfcb095b0a38d3b875de535126eb4d9870df884d62fed5e035eb612ac66448af38a5b0365cdba204293bb254ad5118f22c70ba4c2d571b9b6c13804ff0777255e2b7fe101cbfa82e959b35570692cf0dbf9bd3f3605f78079f62f7300547d3e70edd2a8c1549330a4c616feb923565b9fae8066be6076bcd8c8dc54bcd367a79f7399fa52c84c8c7cef2c009baf2f6618a40abe005e3356df831dcdacd71e286dedd993c7e02cc23d954b00997ff6aed17e78c26f0c917b4d0e4eb1ac71a194ab236f5e8d790de951c14c9b1d36db70ffcb0d344964d377c5e4a13f70a89537f9920f5ea1220ff13fab0a3094483e8273aaf4e746d4493453c25b4bf2ecc21bde277a8eb80e251342869a5922e7db73846484faecd3d7c8713102109fa383787f4ce08342f8c5b9fad3ad1eb0d9ae18b8abf4c70c1cba90470c00067ecb3d636981247ccbdaa2102b07987c172d649a4a311cb955512a79b8b5a9a58521a87ea55d768f2efdad20d7846bcef03f21f97e9fe42e634077ce2f2330cc9f05a13e58dff5c4b2eb9594437e7890a2db50ec0af6821f16044688295e60e65a66d2b6679702fed602d128ca0b25bb2402e7ba3e44f29c1760a1054ab09e086a230ab51826eeca31c59aba28d07eab3bc36b28c175f05629ea58a282f50c49fdb2770d018ee8662be86b3c4ceeef609cbcf0f15debe47d5d28eccfccf9dcb8ed519ea3b05357070c83f02661b27e90a7a95b6f4a47c509f5609155b226cb01173344911a74eeca754d610366e537352e31927681d5c8fbd680365abfeea458c45ff6a3beae7904787635fecbda6dd109e81ad05eb2fa771d4c04fb6ec5ba584f7ea06838800b11a00ad2c019fda583c038da2b5d76de4d52154b9db120bec11d66fe940675cb4d72c3274eb30a8f9d6b2360710c5b0fae872ed06750d661e4fbc06a162656b3bff41277e7e0d10ed2c39cb2c642ee3e23d87d137a2fe9d0082b8c7c37dd0fc6fee457c25af9f6f8dc7d0aaa00629473b796835fe2b5763c6312dfa21367abd96e84cbd8a70838e42e1d387c1162f0e0582047fedde384da76ee384f26e96e512ad9d302e8acad2c9d0468f6282e57a68c4b0b49c4e98c4ccba39e0eb32dd46d9a0068d7d58a1b8a1b0ab1010ad45f43320a588b1e40349a687f2bbb9a054c82343d72ce1de43f9641b80f23e3cccba557b0cd444312c30a242699e34de3be1de7bf9d4ef113de5e0e985f354baf8472959e667067eb818b6cf873bec925d7f30951bba89b8ba13965de07291c81897eb38614200cef9a14c138e9dc0f71e1ab0744a926c1d2d20f0cd59f085f2ec0ba74660df08f6af00d6408c9cccd383d492e45707c9c35258179c338e7d14fc753d8cc69d701ca34f495c6a93eaca6efcbf1421c68ac62c440a34b9188af47b45eb8e48c3dd5d3474a1c71e89dbc0adc5c9ebd0a98930fc5db72c9c253687da32b7a6bf2abe07901a72c0d389f64d6ecba9a5f8c572b575716e409b54742303b1055c8eb5fd6dc1b858c99726885a67831423ddf8ebcd8f8e373b658a0518ab952568eefbb9d74e36724b06d947412067ee9fba04250c91ab3d9b80904b1223f61ca5b5378e5d67093f55b787d1ed00873c25e3aceb081495774d7923d029ad75ec07526ed7d7a463b093db2629f89f365e303da769681ce450d2e7e55798fa103e6754e5d7a799a26d157b4a5d62f5cb1e989796adfc039ac1e63fa5a6b1a56cc6d07d6958d2aff99addc4cd808c3d3dd8e37a05e0393b62dbab85aec2d4952bc313ee2c61cce764b2acd681af9bfdb6f98cb32b5bc525c8b381b4afbd3dce844afa1cc5e1270b3da6e6fe4cbb2489054011d0ccfc54d84057a2fc88349bded0167494544f058b4d0150f357d707c878d96f5717436e9a0bde674d957d81e441b874ccda1e4b844a7a7f6beaa9320e86f8806bdd324b9fb53a459a49e22948d9d886b5535905ec86576e2f6f9f2be2533f4af0b3c180888411064930ee6b85501c18c1fa0a42a74ca075aa137f86efd723cc76bc79f16e1854139eef7d55e847af425e91c8f7bd48058d87fbd19db583506e87e26a412463bfb262074c50fa457b8ac6c80b65065a25590a0682f52878487bb04267fec4f05372e1be76700f39a2ac23d6c415281d7336572371734228a5bf852f9e2c33ec69a4c77cffaea64bb800003944bfb709e8fa8d7f2be6a083e6b8f170b24bef05d578eaf46bf50cc76b837aad50cabfc9848fd91269a452fd529bd0a81651c56856e6848e48bc3c2c15f45dd1b3cdf1c92974144b8e0530d9d80092332c719944819ef8f0832c9a616e167afde4bc8e0834b68973116f5d3ff9d58287d73fa0a987bfb85fc3a37697573f1f55bac18c6eee21446a50e3734de374d95fedebec1d086fa9375421524612cf54e2ef08c4e58e3a845e25fe221e1d56cffb0dfaf40791bd7c16e8988d564f718983b5d7217a543c335fedd7afd7c97ac756c3ed02ca8f94a506e239e57da31942dbce9c328287635b7ef3a967b8fd359b0c6be595ed39ddfde3d59dae79cf06c53706e269ca23ca6015e96b190e60cfd7214b50088a5fa1f16a4fe6a7268c0fb489dc61c10a720617ff341a8e7c298283d51bdbd572805059403679a5ee1e98c1b5ac2c3c2131399e7208dde1beb60ce33dc8fda908160f203dd0b68c78135e8379d6254f81b10599e5018a2c61b0f4825b1ccd73b4ab8d845391fd2c4c6916970264df5df1caf087ed611e7fe0bf367de67469018ac5a0741acdc4c68f7bbf4bf34789f7fb7862c8109b9d41519fb043ff037e940a5467d7a3fc4e4acc36bec30288d7731a9d18b286752a6a27f948bded7f2c55853abd594f7f4d157b660b9ee9a8853ea41eeb837a6edff1bdbe0f5a57ef9a15436fdc8e6c449c9afac926a478b39d2f7e9491a63ea570003244fda3634f5ea2ee9c76afa09cb7047a2a158c5f6c5e5a1eb67b9924245f128149c4e05121793baaa4bf1b1a0c60280874465ee2d61088148735baa7edca7fd2af6149b1b0313800dc529cdb47ed358615dd2a93f543197b113a31b58f8782b9dff1d2a5b1cc451165255fc4e11cc9baa01df85b84fc8e875279c3babd247cc5939e728a7d3a23e0f275ab82b73d2895940478623527ad06e2d7d0d59f928feac9e0ea67dfcac381a4b3a8bc1d9fdca591528acc315884eba7116afcf0c6d835770cf9efd52d1627e59fb9853e373a845aaee1f7735b4ecba7b70d314d86be1bb69cd6cf1a5c46104a0a4d54e54f7053d41c111bb19a3b7cdd1b797c52698679fc22692d8dfcbe522085350939c05fe3b7276a2166a0152df51bdb2318d091dffb20f0ccdb6bcb168b7daeb8748d906963b626c35f28b02e2be872a3775e1679bda71e3e89d22a3aed7a46d45c110866e6b530ab1d7717a7d0c868e19d500a0dfb1911b3fe258033771bfd6c6c7a55df9252c20048510a4f7c9ade49b66213ff3e9735c6909e3d2977e49550a48d1674934cab1aa58f3ff2e1e9c0dbb4e16cb2f1fe12d51801dbd3aecc98916db381617a5ec8114b5ca72dc971a4673ba3fcf1e53ad3160099c9380271eb9ad9639ef6b4befad0e1121aa7f5e35f472f74acc8aeba1a87eef34cf1a7ef82020d2f0729eba3f288cff715e2d762dd3f2f633e2c6178ed11739ab1be6fff38e4ec6853b0349dd1ed181ac8c1a3a328f647954107404263de11ee8ead71411fa3f19c7230d150646105d8e9f81704fbda61243a1eb32eef286ee708a3e9fdbdf4fde0c26a7272be50029ce01a4c8a4840876f768222aaf98a27f551575edef773cac3e6f6241b66f1b3582cc8e17c9bee62f5c56b4dbc92c7bc13911d1f79f7e556cfe42f78c7c7b204df8b34f53d7f944db2ddc7de392c2532cad3a79e4eda2374338b78db50f158867be1f1214ee7f16731775fd8e07f5d131ad75c60e19a11b462a583fb9c5a6464f3bcca160ec6f4eca0db89ee9ef036c5d94cae71dd8c51b2a3b97d59c14d74cd9f46dd9ade914de20a3d1866d4e7fe489579b1d1735b3c554ff9ed591abf87f7083a8a9e7acbd5d918ef2eb5be87a6954838ef14dd7627d5d74cae06801bbbfa9e3bbf156903c46b9f08be441ffeab8958af70bba642329bcc6a9f2866a4c856857d11e76587ad9f9c43ed1f4df7e0bb056d0a4927e8e2319746399018bd95d3ed50b664066af0cbb8e773be71113e4b71e8779d101f3940904e047c518c508e007caf9f1c0fe480ef9306d050b8ddcbe95d1aa038719cfd2160fb183b96a8049263a7405a869c6b68fd7631a8e1a33889915aa75847d2374ad70b2483f01696ae4dcb0f6bb101ec49038925f4e001369df25e042df6eaa3db7471db13451c260a46dbde61d160bc70f7206da396aa6c2191ec48c1acc0df39779dde5a2b467400bba16c0a6c8a702c6c1466185c8895b73b64e72fac5d94be68d77d264203962d9b3a9c113a9bacbcd3dddec4404517abe10f7f5a04011adb8b5c36096ee499513288d547118e06aa46fb15995c162ee6c3572045422c860edb4165eb45ca6f68a3db9aa9c15ed50eb527ffca80eb136cf881d9d1eb7d2d6f9918af6cffd848e03fa8956de0276003ebff7445b335172e48c8f324e1620353d28e6f0f309ccf6dc8a05041eb1f0eb7d9d3ecd6da890ff968d0b4551c689b86b701935ed3eb8af9b7ebd09c7dd250e904daed0a651324072ac93d67741a4d337ad3859e63b5f82c6ff68cc3743bc0c496bc3e266733ecf2b41707a96c31733d2109ca7e8d941539790b1a4ee41b7180bf3f57f93c6912554d258697245b7feeae100f064ff2945af13c33e4088314c0a047513a3dc9b73752e9e050ad26d6bb5d4817778210e2f17a4b3ff38a049d495cca01779fe30b66ab51629f1e4513adebc02cf53b224519bea4dcbbdc298a9977dc06fad4bc9dac687354dd2920b5a2dec0ef6b718c17ce6cb7827ebc2a8c8ae3b131a61c1d9befe48d55a18ee15a63ff0c01b4496603356a2a9fb3ad20a21b0b86966e1bd8161217a0e70e5b801e8da580cda59dc798b002eaf51fc38b6c0e2616e0e041066ae79f1b00d89a32789b842ceb5b24f6cf7072381493c0fb974eccc7bd6c1db944ab3c93e84924e7e0b68b3148184d911e58d1f65ecd6bb1a811208b298cfe7f95b15a35e4e83d4177684db1012b0adf6cca5c8839351ad886868068f237110078db32609e6bf963baa50276c9bec7ceaa0324605eb1773b35ab683d92b2c78e3a266f08d6163ea15e5b72219b994f3dc3dbf5268ac12e2170d537ec604d1811e2da6807307c578092ad44b888a13ac88629e8a8530ba3be92625469848c8f6b49cf2d2e7fde92d665608bb133f259a0f047d23cdcab957ffb0980fb9dbb813b0d714257ee2a41ee5acc38a31b11f1d6e6bb451e53476d037ba0781021dea5517910eca5e3585f5569ce79897410a864faff88208823c4b403a374d8da7d3f56a7617601bf7c069bb463ea6508360668f376d154e32a9f0063d6987245d33e2d125dfd293244c04e69efb392683204f5f9e221acf7ddee5c48a534fa2302d495f14e04d5f565ee6d6cfd89efffbbf39d2d5e3168b4ea66db0d0f9b677be805873b4081e9b76590dedbb26ccd1ad1fd59aa6bb082cf17d2f5879d906343df1038ad94d046c82e8d359cda87b10c34f04022820b430f376f1a06b1ce0440923e2b1dac8813cb35f18d5f11008a1704665b6000f49e77295e1d30e4fa99b6218528e620947dc6a93260b81d8f6267b193c155d2d59e360d4528cbf4bb68cda0f21179e7fe87bf47628735b1a5d0c27c07a64c00f720efca9e2c1bad7ff6591f851a5adcdcea93bf6272e5bb058936ced4e3373ba3a58d20d70de90fc705bb00d1aa8690d991f9b85f89a5e2505eb3e158067f90cf381471a18bd1de4c73cd62619e589fb89727908ace2890976de24df33c87c85a41b19e7623bb199e17e9a3700619c1dddc71c4de24192a66481f27ccfdd3e44bc9a83b77e40a35b982abc2f5fe8c3d3c99dae7f6ea926ea91428b9d4620e44fb019ab2b0b61e800a1d9164fb95417c4c49bb971ee34cc4829990f159159a074e7543e59eb2d3e7c6ff0c10ffd3934c47c62fc253693409756992cede6eef4f6941e5e14e6ce9a6d4f19880104db04fac57a944118a8b7e2bcc77312015a0b4d289ac2f0fc6eaced80c9b2f9cc6b3406656fcf7d5d7e9e79218cfa8e911821d1b6be9cd588b0775328b57ed4b8bf4f5e82faeff881b1a1f514173412ccacbea31c551766ad1245c7f20d6c744dc162145310b0e9f2d02bb231d4e4687689ca9fee5714bd8949c8f41ef774522afb48e8d32c0c8b8d8ada329d4188fb9cadfd9c884067544038a55b7bf43cb7f5265f9be593b7947ca16d92495cd1413ebf53eb945512d08566df8471dfd3a42ff367f4f1e688ae69e82f2078aa55c460299e3fd8313959e6f6ed94896d3eab01faefee9ca73c4f6b9055588d908b63e433538835556784f5585b234553781eeb428d35bb5eee3b8e99ef2f925f03e3a3a18ec6b779fcf4aa9b9ed8fe14247d8817e9160a46fb608d601b4a47e193cce1b574ee61fb15dafdebee998831bdaa885a395b4c531cfa840cd3bdb1e50cf84154ea0cbcd7907bf83e29328eabd2f17ae9edaa2859c3cbd6f7ec51f561a2fac1a70bbe7c9b021f204a9a269b0ad4fec0a21dba2bdb883be41137699449363af177896e2061d1d3a811c8704ce4c262bab6a885dfa0b7adc5843ffcfe638c1f30dd4ce5c1f5cebca2b3b21099ee406bd26832316ba1791870bf4131ca32d131d874a712afee4168a31f23bf440c839ccec4a6ba8c216de5394c40db6b017d391195d19e2f07243292c9c0e7932556faf79e46e6204730d98e8df8a5389c5dd882efac7c742b75cd8c39df8bd8fe4e7a3586c6749514191495125406413fef9823902e9b2931df07d092c50551d2755f8f190b74ebb069bf261032b31cbaa48df682cd9d05fbcbf3949d718dc33ac98a9107d561bcc59961a9f22a3f1c438e48877406f1f1424801c6948865cdf9ad3be8738e9c08f255884c5035b9127a4b100b2efeebb2a6a99e9ecb3b9bb80bc79acf16bb7e1043d8c37383247bf93848a4559d9fe5089402c89a4ac66b85a03435ee35b58ce7211fe8f442805cc9767f5a76d9defa6268d90338e06c6cef8b33c54214427ee1c7b5e945453cd2388c5bfe4017953dc60f4415996561e950ae0d614920a4bbb1b83d9d29555d9c2a87dd44decd2e761405270fc8357cd6e59ac29738beb8d203e5a0bb796c5b8da8519452aad98dd0fb0c30ece31881532ada2c73b3e0488161b699f91b87e68f97d64cacc7cbd45b06b9426c514e43106fcb9d4d511501033c9c7779a20d8357822043d94a09fa54762ee3bef5380f2ce2650edbbf3b20f09d01e954ba187b80cc4bee87cb2a839a605e87d53e835d18d18a122e608cc536678ad1a2bff10ed081d0f9446d90c6a9a22d8dc866425c270895e1f579e102dbf3d2f03f3a138954ecdbf9e6673060654d600144575ba8c5a786cbf89d2d637298d0a52cfe7ca94c3cb27c1fcc269271ffc0a55fa314f541b9f07ca222deb76528c5f56f9a84a0afa0e62596611322cec8d10c0f24d926d818d317b6faee10172fc1aaf39cfd7836942c1450466c8fb8d559146c358e9abadc965c2871adef08b066bdf3f087aa7759c22cd535f8dc127a6f722503d212e9ccd15b6699241fd533c08821e0fc8925dae741b47b487045bd6aa0c34bc08edeaa88b46dac40678278bd1c81347530204d9e4d4473d931d2da10fa8528f51ac7d674fbc0ddc61922a38b35ee2f73e5bc9191ab94a1471a4c948eae5fa2e9d4be1a9a3422307698d7898e7b0f2125d28a1f162e29670403352d96f6d6cab0eb8237e0fae8089b0342aad799a7a484766946122d2ff03624ea37e39ce7a44161d48609d66eda15aa0bb9adbfcd878f22056d1f8239cacd9ae2c464cd23891a8e20af43ed7eb693e491c8cc9e7f757a89e83df8201e49924fe824e0394c499535ee0d60ab0b5cd96cc6966f94b7ba3e4da3c44100cfb0df336c33f4e227badaf0365eb7c6f1b9170f018147edb6f2637be841da42d1947a7dffdeea9fe5fb23e0e43b53b9aa409415b019c096a5290e1d00bbf43fe8c86cf48744bd71ad0e0fd8c71328dc3e8a85a93f90d3d886021ac301a2759882cf2e20db232100e4438b2b9669d86aa21cee12267c1f0be0e09fcd1d658ff307020a6c80234b550711352347d79c646906ac3ea2c391271a1068fb8191264842b03e8d7aa9f9589b3849b73e68ca0d4a904801e8e39907626a177290b97b00fcc4dcb33ae378390128d499cd4937b611018bfe9ec90fa1a2a044c2e0e986f2aff2f12f3ab17fc0edde2599ed480a3e5955b08a403640890345585f0a7f9b8fd159f5861d690a3122500ceca856889662cc324acddd6d4ea70726ecf232a58f747f68102e86849c7bfcb34d29c0d454324624221a75cccd8143034b34b4187bc53da5139ef8d711c193bd7dd48dc3d8118b3597a1d261fd15edb915ab919348ed13e9cd084ab6121907c0b5f5078cc0599a64b39d4e7bd7e405a04ffd0b33a1abf2922619086f14d33dc372ab21d1fd2ab69396bbe56c967b4c221c47ac9e36919d3ddaec208b9bd1f424bd60935b9e34a49e0fb8b72cc61288c70d283ed796346d53262cf8dfcf31e310ec2f9636cfeff7012c488c6b626f95ab0417db219ae738abaf319fab200aa840a2a65b995ca9f069496a1b0d8d958514d9024860f50037472f11b0cc26c360b80db11a8bc5687686d11475a96273be3b28007a7079979a7eb018cfd46c2f49de043d009e630acb18a1d9f64dd58e4136230251e56f8e04b3a71f1dfc548eef7340731d113ed4879fd4758161ddda78d0157f08d421b0b19180c3b3075cbc21c10c73bd4320bcc320947d29b8d5dd4d5e633185b8f2b76ce1474be27cb9429d03bff4142f4d9bde4b24d4f1bc3c7709751f9e92489cf845a23dfc033d947f84d72eebe196504d974ab580f35183517626cd7d3b7093fe35df2ec7a5e23e40923954f37a6e365cdcc00dc823b8412576fd82b6233f42105fee4dfc8c801d08ee3f968d76fb4af556698e7d5835b9e39e1a7218727bea9a0e48b2c866f47e939f7a86580f23fe82e8dbea06d52f9f84fd8fc0ce16edee1e5f4cd28cfca5ac7153d0d3b7b257c5cd3d10a0bfe1b529a6925328f44eea342e98ba138677eae198d5401dbad49eecb602221d3a75ff7cb94270dbe8b3581027a7fc1f6a3381dd264a9b7b62956b209a989fd820adb7e0754f2c9d5762064990d514b6ea35b29e8ad5529dee3274734236018e4e54872b5f81b83b8a4da4b7ab942f04406022da1c454bd6fa8cf4c3e3ece3af61312e7aac12a65eeb62b7e14bb147bf18a603263936abae6983da79c4807501419564f127355d7ac5b86edb807b4a0225ccaf2be85ce589d996f5e45e2875d63a79634a3a37276287ef584f551bbf109aa4626c00ba2a1b1e99f55f4879dc22cec99867f1b9cd0eaed605c965ce9789734399f41d0dce6d9a3b9a57d02c55514b725d76da560474e6ff16a4b6464930d8f12a8c553199d1253d35aaa05029bedfce83431ffc20e3702e2575762ddc4fd50a7e927bc2bb384f181c8284a15af318d16dd76e156e817021349a0ed8fe94bee4233a6066913935086df3bdd2ec7c94a8edacecc749c3074b526059456821ba1900f723f9351a0ef8b5819ad01f7c2cbdf44028fa5b6767939f4d4d2808a2f38164d7a3ff25b8cd1358005a331c683bca95243e568bec17a076b5d6d889b001bd379d661a340109d34fb1260c1271fad7ee41d36dce45fa05853a4172b697db68279a98bc5b134210cb33dae4894f3d4a6440d42c9f0074e2921f0abf398aa3f8692438f3db6d345d819e3962b1ad898596e24b28d5a996b23b59b6666fd0cfa83bbca4f1448772270e6a97152fe94c4ceca196022a3616bc1dc87e1da8b0f405e552359cd62efe501f0dd52c5a2b7c62d58cc23b86a8c4491b2a8b12408b9c40e4efaed2d3510acfd06f6100adbbd164a0020a7d25d3550b71278b87073a3fb046ddbb2708331045accf6ce6080e78a9c2a1269b65b271be148b73f599d1dd60bfc2b091a0ec077380998a10fbab7226860b0e6bc080518f674599a206ba8cb64a69f13aada7f2e598493da2cba68d45fa8927bb5a5a8167d9751d7b4d87d13ba005211dbe40a70e0a7a20ce98f71888c06553fdbaa14989c33dfbcea3e05e5f1d397eea1e3026f3fe9df1bdc8657b8fec0f0e6992ac5a2400fe11f4443fb6aeee717334942539ce2e86fe0b5ec0c7624a3267b224ab5d85ba42bd5d7ba243c6f18e47b47abfd62abaa5bfb8afc9852b7513a74cded259aae1e5ec92a4166470e91eb0a99e5d2788f52bfa29884065fdf528cb732021e24176717f0430fb4b0186a254f661b56c6aa51dd67cbb024319d8c40beccc37999a3a6a663767ca055d88fb10d6f32a4343ecf3d1d53fea7f3d1294d311c9cf023ed3e5046e6b0bb5ac5247485610d8c996da9779ea7e534eb5048597ebe1ef551d57870884d2cada46b38aac6b5837e12cd75f19b6513bf749c6fc961bf841b4cf2a754fc94ae5af6fbbf1792e583ae19460df65f0073fa2508e7b2272e785bb306d24b303815d8855205ef09f76a8648e9e1c6cd262fba6fce86c8460cba3bfbee031e95d73ffca0cb46e986782a2449ca295fe3a5f15dd3e3a08343352fe1e8153647ac05569b6f65e289855abbef3261c438124a5f702995b6220b688b29cfb9ed7723df016db46e8d19d5b13fed72569e51dfa18850987d757e31e27a0567cd63206d0ba07b865701","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
