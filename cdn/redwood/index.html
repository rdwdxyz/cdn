<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aeb47c8f2ec1b906310d08ef0bcb505fbedcff0272143d1665f89ce36ec9f84fb7375f34a5ed625c291523d6a5e38e5d35dffb4a722d87a2f6aa899561adfd796be52fa8a084847aa45bbdb369285c8841b74399a55edef8ed5829c18ee062faa88b56b76762aba18eb93837fea2b937dd8678e2a876ecca56f4b5c09bec2ff9584a3dd4b4cbafeb527683810cabf32b3faf11990de487c1607d3278f1e16e88950b8a9d945f63bce0f9b275d28670a58491eecf04e077ce71d13aac0cde9ee5d4887c54eb53010f47cfbe9a13149c206bba292bb3d26f6b53d4f60d508fa9d9cdd631659bbf496e74989db2504ba21af3e663a47612f50975df86939bcb5b36b31ff424079de95c8b7cecaf1344309bf2b3ae55470f0ff74c010bc35206c8bc4750190c16181170b53fad0dec24e4e56d0553be4a5ba63aca1d69b70b540af8bec56c1cdb64fbb6209ee0d625ee27c41536866e930a6103cb71d085d2ad9a6184685f24f7ae13e165480bd80ff26eacf0259665a40007f1419b8fa6c92a79318a7ffe4023ef7f3b7e61f5ecc21b6f56f730019c9911ad29bd64c579da17fd687e7fc3c0aeb7e7db8065562d5156e121df4f7c27510c8fb3fa61287d3bf0aaa4121be5970ee4af978cad4f6a1fc38093ac1c935a4d322803b7372d0af3b65ca5601b26fc04627a2297478ed2c937553d4610400c6a066d56705dabd7b052bc286b4c06ba64e924ac2c5dde8dcf1ccb7a6963d53ce1d951b982dfd43bd7b57b7966670f36b5515b429eaeffbc62e84535cf6ff3eb7320e3344a75cc522ef3125c99d32686d15d1e9ae78d0418ba4f579190a3ac925bfd55728c20b82a9eba7b0474516bf6f13f9bcf6c33e94f97d9613895e27d6c22bcdf6551b429ec8f4c4e83dca64fd039f27e32945a5ca85082cfbf3a092a19d8f01a3826959c468f8185ae640479802e8d8f906e6e0239e2ab335ecc1474c35ba43f5f2462cde9fc134ce8cc523f4d04ec589dd90a327db01c6812ef6d9bee11edcbc9e74893157f97b9ff1ee6d42736f2c4ed64d57aee590ca3e464ccebebb192702a4bd5d3249ad4931a61a8f92a479a22cdfeaebe1f9bd71d9cb0b713a3ce51850eebcdad52d47f5a9badafe714ddde127e1732845917d719464a0e8fbfffcaa89827d2109bfa7ea7b5983aacf48492d00093ccd9dad3ab8dc7490aa46766c34689261cc75a129b815d4f74e640d9fe554402ba7c09134e5455f3d237cbcbfd8c972fc999a3aac74508c8d7da45bff0d08d834128c845047b4ad34886f7e6fc2b10f5ae5a71fafeab93a3ec7f1a17bed0f63b09a4d9ffd5d3a53cd80cbb5ae9e3135ec9ae174d859b3c083392a8153a320e045293a0611f0c11dcca1afac3737c88a600dc9a28926f53fe63b46596a45f37925bdc2399f8d3821052b479aff826e841aa3084b383d2e2c3a745bbe445ef67fad28f05a537756f153ea7fece9c9a32186b597821b340dc83ef7c85159042fcaa9d58e629d17c0ccfcfbf1ef4b0c7faff916c9de9b95101367c3a514cf45dd88b9de65cd112949a8d87a43a37ab8af888508c9d678a83751e1c403008eaf2a2f269e101c069d2116597ea0831a9582531fc3ea50acbd8fc900dab23fa7d2993a783e879e1b2909455483a293c2f60b384ec39eddad72f4f252dd287fa61820749d2272ae4ea8074006f2e19e2e93133bd2183c5194c4679aafc7c28994cce411013cf00c36855d354b7bfe34acf16d0f33d717c5bbbb611f1b1523fe7e045cefbdae7d8f5753a694452d3644e6f9c0145bbddc3f416ef47d8d5ad3392d33fae3bd87ef18719d0beecfd4031a965493f50b0dc5229cd401a1b9702f4a80f6ebe5503f164da6ef4f9f74787c7d53d013cd3e074a9dcfda0268f7b5551d68cee63e50acaa3834d6b5d35b4d9f1ec097fec977334d114b7adb7f4bbc5b942e26a0b343cbefc0361e580514775d0f4c7cb23dda3d3a262e62f503c01938dd5da0cc820ac8a17b8f1e436df35f07f5b2bf2b39a8fc92ec77e7a61eeb23bcb7d4c25dba11bdd7fbbdeae4162b0469d7ca33a3bcec11e0e064e27d6d922a2d79398895a25b694972052ac01f84cb20862b2c778d9983e5ad7d23e28f4f13a30b10981aed2f540b555d7650c43ddd509f96eb15e4a24b0aba412e274c7a8ca59a95935d8d13bb96d639e195f98332b95d19e8b4f6d508bd82f3145c346342e4235ccbd1c8e96fe708538d7f90c141e56014115a9a50427c45d7d4c98a1239d16fa36d7a0eea1e562fbe3537a10f27bedf051a603d1209d19fb1ed982adf8271ccf34af167c4fe2705126ea0b800c1220fd2929a1c2a9be5c1ece3bf0df80dda6bb72df22566e035ebf19bad952d022d5af9d3b6c5bf5fc10c6179faed1ede1644409e13561275d8464a3d4030c6fbdb83caaaab8924838fdf793b579c56c5c13edd7fc5d76ff28ac48c29e5904da9be0af02c4f1ad897f9fa419a9d82dd79159f432ffddb69bdc662a6820bd078d655e1e013ed704c42a5a34c1f33c79fb103341a40050d6840b099b6e7196e92ef90e1c7be358f795f12cf7a3de9955ea05254d8fb74701679cede5e1c4e6d401cc2c958643458e17208e2cf86730a7e96a06d4cdb4138561c9296bbb9ca33dc473b7f465fdd8fafb7e9a13c36436254e5ebb2f53ef079f5ffb0ea1b9979a559f9f46d257dbdede36b54ac8654d85a41b5f1b0c0f4e0e76470d3057e9720f240b1746578df6aa7496042d2a8ffc049f92f8cf6c6545c0607f75f7cf57d3181a2fdda2ca93162041402ce9af4cf61c526f8ef3b38285079e5b252802e0601a55727101d2f00f936877ca3106a1dff9e654049a560812655164fb3d85f23b153b8975c4c65390ca70745a870043cd639cc4f5c033aae958e884e66d97ba1eb58a02b4d732c4305af888ed299f9fd5990c381817cb8f4c4f88aebe59ecb07bd4a64aaf19abc3234da0e236fd19a47cb207edf2ca8e037c1c214c4bfa857e416751f537341e65aaa163d63fa4a09243b084a758b343b1e17d35b1f7d40495aa90c57c12564ccf959c7f4dde7aae5f0840a3ff008d74f05906577fd6999eb6943c016d424de5381e145615877b7b61e4495d4037a484ba0957d99e27fa582d60bf4e99c8ca47fe967641b7096dbf221ce0aba343309ec7c56affd9fc70de40dbb058d7daf866658b4bcdd6664565cc1eec2e11ec3f43a6d6d280e158b0526eed37cdfc42d1e58bf04ee513b215444cd472be1447f8196fa13ff1e28637f0c1118520e75953e8e3a87508c1a16d2ed28245148dd347e0e71a62c4f29105f1c723518881c67716f9598841b1985ad1f9ac67259df39fe9abb09e1f4bf551dc0e52f2d1dc8fe1a29778e795dbd1c0c291814a8aaa929296263ca4bc83b184adb1d0c272d55789f17ba57007c69d636e427aba99456cf6392b9c5d9d84b2aa18e852ba04fa0d2a203d41d678a8e7ae515bbb201e913a4c00730961957ad259c5c10b0f5aeafa5b6d5a692f22130c11878e853e6e00b8744132a93d1ea2b1653076e62e2f68107bb808b5bd2bf04432541f5d85459f70b3ebd75de7045d23df62a08e9826c001e84e3cf6d6caf7a9e8cbc605aa86e6646105cf1c4467bc99566492ae40b8ead70aacf6b7984db1107b0d3f6f0a6c26c7c48d36e010ffca25f8b5434cca3d87ad94280d306893a51e5a7b2bf40f9165ba1930f14fd756415bb21d998a419c48187d1b05acc5c5af39a247fb76b3b8fa561210d7405900486d52a7c7b81a596808ae1145171de5641c6b5c6fd94bb80bad35d1e6ce4b61cf832f7192ec6e9f7a5907def2bb3f65a2b6a1195c5fe23817df0b2c9c7dfa66953ff3c51983df36b60f9e61260fbe6e5b38f64347dbe48c9c1f4ca18e668ca18b325ed79631d180bbbb848fed3093eba0e114c067dae21188f99495620d89f32a3f848d7b670e0b8956dedb0e936ab12230892fd45678725db90381a73892f5f5ac31aee8e7a61358fb36ab23a03a83caa89608547cfa6dbe0e04e535319726635b1db4e511ea9226d634d65f79b68693de394825ffb3115f00438ed2f2a274903d36cd0c3ea4dc8218bf4faa8013d3803d9dcd8d08625668b9ab45d27123de60b099907562ba8edd2e35a7df44fc192a4293a50f6e0cf863d66e71d91d79ffc3af1374be4e4a801854852480c9c51cdf9d004400c0aa11821d911c9e0ce92922b65aacca3af97d3c95e2d3b17183d32373a29190e5f9053bda9f17eb7b9a6bf8320088a8a3c950dad47d29e5aa8a7406ec83c687151c9bc905155c342810a21a5513139acd82b1e44fe7ab89efe6ad0e253184aa5189bfdb224e5334f89b4ee6c5282da804c1af1dbc8ca09099913b69b6a4cc775f5d6ddbfafb6bc1e77fa234ae9d167e1fa48a4c08215a4a09f519c40eabdb90cc884ba206f83490999ccb6fc24902e2f93d1d0854a6fc66063050873089270c1d04004c9d1d28f47ad8ffd9940c1317ddf2224df8fb8d6a3e9f37681b10050554afd0ca181185d9b82763afa3866ead5d0aaa226f8b300ef097d673a01c61ff5153b344b39543f3b6a825b9fc3a40d3dbd2a969aeadb2811aef32257dc7869fff3f51a876e78f05536133d2a4d86731e3bfd864c8a475074a2dbd3ff0b0c587c9a2326aa40baa246b052335ac0584f0756b292a4c9226c2977d8ac09cd51a3e7af7bc66784efbf7022e48f45b291b429488b24987000014ba710ef3e37ee7bdd804fcd1eb7a46839dc291368ec76fa824a498698db2de98438605d45c140f006622694a34ea01d61e33caa4ab0d721f9cfbc5b5df561405812957166b38234c04d00b345606d4c59e9ee350a40c813e9dd4c78a88326677f6b14505c3ab392211ff34b60044654088dd85d10bd6ec357eda0d85a9cfc6d2da4db560092bd4fdb1f10edc896088f31c1cd28a616f97e3392636bcf035e62c4ae18ac4431b8b01b068645ad1b7b0159c27c2091e60bfc7f5f24f0df24a6dc3283940f8a7e3de971cd62d37aade6034cdff4af66b763c22bca2559a250cf73f1d8700e7f584dfea7bba8ad17e31b39405f1f2e3da3acc7a1c3a22dd04e3f793df6f1cace9b6fb80b31d63d6e0e13ece9b3a07d5d500edd0532c73f92d0520cc50a179367479725d298d36b035f54fbc8a14354544dfa6fbb7bc454628d0a520395459d48c182f1e10aee7a97d526fa3d2eabf1676a7706128122e9bd562f7c47d79aa0befc263844fd0b96b1785bb28e9012efccb305a454c5015ab5dce9d7bb12948203e21d5f245c0ad927f88dae7b54f565bc22047a5e112b984fc787dc518e6b62f25289567ba1fc6c6ade46ad2a49cf27165856bb7ffcbfe35dbb4a8789b5b712fbdfb9490a0c68e313197b133cf61cbaae6333b4395334b8ce81c15094bf9ed047ff13b343dcde6582faaf3768009c0c7b26b9b714e30f162ce5779e0878e48933718e2881ebc15e908491ce6cd2d01461553845ddc82d6ca0f90ac69390b9b768fb03d94d5bd07ab6a4d09f92bc0bc26124135a97222e3f8d4ec46117768627e9492f0e7e6298b775dfa6a576d60a7d305c99262f79434d7332ea0e8954ebae6882426d7c7268bb34d3c054c7c9191eaacf91b52365efdae2f5742c205f90127bcb580e4081947801ee9fcf8b42f1c686a41a1c65a9eb4797271c317a6f0d5f1cd4f91dca27314e5cd4633262057ab7d72d2ea9c31710ed99d182232d34e144393c5e4ba37fbd53112429e8b00acc23e58a8c0c46352ed49ad74c53994ad7869e53c63c82d0bc64fd3e0c7f3f14d4a31d34995f239ba3995b0ee2446f8457166b2264a56ffce860562763f05255446e0ab2afa4e3460f80f9b6a405d6fe3560b1f10e376201cfed0ff38c10962dbafb5c8530ff7fac84e988f3014a3127008f5e6ab7c637e82fe6ed021a9a362ae1c6ae57306f9fc02323b725c6dfa2989ef8023fba9c62625ef09b6bfbb0ea9008200c774cd73e65788edf998c94d1dbc59ec2937008f2df3c875a9e885f222af68e38dae52dd7edd34e49f09ba878f7cc3deab29e0aa3c6c3758e0604fea75c09990917d0dd458839fc8511f830d58ac0b1d454155cc78c1783107c58df7f7c6aab80170b3ecb6f8266dbbbce4175015d519df28b014b1004420a52ff2da17e7a1a8cf2ae3414565ff2956b853914307d6b9c1f4abe54bafbd9a05f822a8761ac242c59ef43e9cc4700e9db548e0026a3ba0046bd738dfd3dc08e44cadd3fcc241864fb459019b614137b5d838a21765bb100a5840aeb3041563df747bea8720c1d712f0674607152e09f02cf95418d1b7105a6f5b2bed78a76ac85556b8de9eba357f5767d6c9205022d77f8ca38f18d2dfd36470c8db7370585392df225ca7dec1d00475f4e029973b3d7c7039f56bf071666459265249ed4068ee50d2e087b396b2ab980dbf03f13d7df8e02a41b1303578fcd37704243f34ce08c6582e3eb598adedacb0e716c6aaa48c59f385d360479ff11dd7632096b135991765e8617af19880279ad0459875efad02f40c934a3f578a7c9a7568da0ec0d4908745c0e77a758c76a8b96ff7b25515e8520715b53bc395f2babb913b02fe6200d385a89dc5421c429e13f367111ddfbdd8662d9710ca3c2f9c1a75d8dd00dba8f44cd974adff640baa6167eab528da68c9176274b1be457053e76d3e1de71e4fd610fe3ec60136ca7c077efc9820718d8e58096bf36b1b8f25ac6b86bd754d82f137157662133afbaaa6d45b9d7e3890861f2f8155f60a4826f7a1c13777e57156119a3966804d337ff8577c5305c223400784e18a33a9e5d5676f846660f37be8b84e7b1f1b309e8737085113666846e1630b78a9c0674325d6d00828cb9fc735ad90f282cb623a263078f4e75d40cad67fa35acd84109e411d06c8f5a480f6d3c143082ac14b838a28bf9273c99a922da0d50c73faf182f44e814f387408cead1e79d1bf66781197675c3deb77ec794431b36c2aea2e75703ce8e1311d200925ccb01c1fe2ed07ebce91f3d378e9191cfcda6957a437ac6719aee1d60d5f65b384a6c338d1f7f79058beb4e89e5059301915b79fd4d363970959cfee02aa240b454d03ee7adb460d6e2d55ce2b856766ca2e553586124042345a88de0a37813da56cf5d858e582267ae07b862202ef7fab573a0f935ed58ea4a461f512e74542f6141af3015e1bf3b2fc6637692387338ed5641173e5290e8125fa61d4d3bf9998a5443cab7edfc3cf427dae3f9046fea7c60d15083cad677c7948fdfef904360f80b4002d917bd5d9a113ed1f9dd34083e2e00a253e6f6d290881972e9a7ab3bc4eeb4b93a57eb822383edd31afc1c8e7a776f95cc14210154903d89c4d30da87b06674e322b99a0ba4bc9474c1c1170f142af2f11326f67d2478acfdfd908e8235504df8bd13118b55d918ba20f6eead333e57b92ad0123e283c2134426712c154cd2c8e9e4caf2a7c602d580acaab2cc6d04c5e3af568e2a5aa4a33364ec33028f856c7dd7f9ac6c61a6d77aeaa61eb3d87f2048dfdd3c7e1143b92e0218c71c3f9742c8dfd84010e96b1571f90d8017102987b27d941dd037ea30c2231764920bf76d364875cf11fe1d5cb7483f35b1ad197c0f38a366e0f5c040df1849cbae3409629f428e72e8cbb5beeeeb4f43b5d22e8f95709164df9d40aa72ac729d662e5a781a5460f98a152c879b6d41f77d9772456ac8b3869d9d04a00beb902569205c187779f2357e1204d0577bc4f8454ccc81477d36f8061ead955a315dca7a764b58932bcd08560fa83644405a8191cb7c7eff2a85046ab59976829fe5442528a8c8a3a6f6ad2207e84676276ba7a676ec3add20b4fe5b070f409e2c8dad1066d88293ae7d4277e2694327866003ac70316dc488267bc2951fabedd646b2b15ea647e4f2e8a6e0d984abb88d89406956f8220fa90a5b8ac675dd558a8c5b4f810a6708cab55786cd63c95bec5fb7f47727c7d5bf1a9af6a106ae03f84d7f3f3521d535aa6461b31a297e84ed43023935550fbfa94d1e3fe0eed3e1d340963aa413bf29826080ceff2cfb02b632d210d7c9178f665f1ca7f4decf6be45ed89dece6a8615590e4f9a94ea7561f748c092342b823c69599e935b5e8d3051172b7f0f9937f41a53c7f3b60dfbd0e65bb307f2758f250ab526ace816c79006568e9cab14064ee293784e0853c8f1f568526476b6f0dbafdbd624f2152431bf5b4fe0e06670ca396f183d3ff8ef5be03ea5574aae5854ef621972e8635f8cdf576f5eeb3c606c579fc8c1012923172938e94217ba18c14807e80c23122b0a95a8cd7863e33ede5993866ff6a2fa038ab1da3dcb70da6fee7379ce06a384d06909b357ff1f9d8f28808393710fe7c506486378727798cd171472e1b9552068b410773dcf0a2b7bfbb8ef2031d8c883b04e7c4e74d415e1bf00ae9cf1d792612ad77b75ccad6639086923d747663181f94adca165624193758841cf6d67626be99266a0ff5eeb88981ee939f107d228a5d3a9c68b551f42a7526156ec0a14a881a5257a8d2c7717db46027bf219fd54ba2672704ef2917c7f7eb479b572b5bfa6086bb9e6174274a5f365c4766dc30c68c9bdbb458240462aae5518f8eeb056c4c83c7ab526cbd5a4da81889ea4568fd40a7dd8cfe83362c14b89dc78c64415affa5d7893dc5896228e0042cd9807e2f8162a129e9c5f7033ed406ee69bfb130c41b388014b49c9a74a52b8f2d14d95bbf043a6eae97e67a59b07a989f95134d6a68eb8197f9794252926008ee9cd28744afb5ee8744ff8e81cea78c548c4e49b4fdb2dd5e5f8d7a78369667987a2405478c42558565329c3ba00effdb16130b5f12dd4fb3c03f30346d1266b9b90aad341a926487523c2391114d8b2c240e5ab76327a07fbf540e29445f932e849dc438919f5820d26b4963a55e50fdf6b6ffa6e660af52b58d9432c1a35c8a1b207b70e8c35cd21a1c16e8c1c9bd66209ff50ee50528115546ec7f30b13a770d450cde806d5eb3720c2c4d67c82cd29893668422143a1bc3dcbbde19537d0ad0559695e02e1a9544929ff59e0cdbbc4791e64d3626f5405f775ac6bb8e04c8cec1746ca56d0707e1629bbf42087432c9173b59b7ed6608a762da2f32868ad19a084e4d479d3ba0882153f3af6d53a7a6430cc9ffd97a386c8fe3c61350d556c48995bb32cb25e50f17fbc544be0931421d7733654f3b220079c4840e666e3550c6a2c62a4e044df60052188d5ce64851a2ea3d4067cecbd429a10c7f9b0106b7ad0a350ee495405c28d2d58330ef13379782e32681114eb114a2e348971ff7ef9dd856b948d6c61d8b754a9cac7efceb42983016b4641e619a8c1dead6d3a9f8286d6536fd63de9155112ae273664d9801ff06724df3ef8ed1e537f43aed1abb7c5745467a826cc6a8a51302c9ad689420dc6104cee17140e85119e4d837f531671ff11b84314880e882b261c4a644706163ba07ef5f5c910a09f011403f709b0c3d0baeca93ae289a4f195c41138b7653da2d987bf3b07a53ec32b3c9dd2e5cb848a7e595812b8e46649a2f0ca4b1d7a9f4accba94ae6cf9c64feadc114f614a40b98c821b77c6b83d30ed35e7dd31550347cac535d1343a13a940a16251953a669db5b4c2926eb3d1f9394e5f75f51b34da9e4406ed39c786d3abe97e396f96c883e2abcaf6dfe374171656a5d4ee260c80bc9e5571d22fbd1090de7f2d378bfb071b44cf817cd0b1c86c4b481c4ae7383116be4e5bda330d003cc2291516160029098ace694ec39604b61634b2ca4f46d7b69e57fa9832422f3513a816ebcd438354563d0d8182b3c2510b0e55f3a1bf4731cfc4beb1157ff961b685de66445ca85f5a99af951bb9a177c5d236cdd6578369c6dd1165eb6cba1ab2487c67fb01b935d8e474d9891fec773839cc7d725a00bfe949e5a03be01ca2fdc6edcd21704660048df7ed90ec8b53a2d4f1046620e808bb9142b9c6d851560d9eb5f2403505716e6b80ceaedf3797dd5483e56fa58240c880677268dbd10c17a9ee0ba63fd8b001f4d252beede260df8c42def931b682df1471ce33208aa1bf853eb7250779ef5e715a44c81d5a547c22e2e759aee13045dc9f1423cc2690311818fa4fca0a66f5e880359f7e0c40099c21374ec63a47329b3cd4cc930244537de1b2dd01b72908a755c25dfec0bcbf440540fa1b2b16f8aae94e3bb1db50d6ec7730ee2b0672efb1ffdb5de154a68237634349daeed9dda7f8199037de40d57d66790d18e33ac375c394459a05db7036cc5e2c2be6b55b543aef6f3d203dfff589b78d830a86ab965ab979c256cf90b533c34a0a0e375e61e72a0fe511560f76de544f5f8d9971d246eb59ab848986a66c01abf588836360574782c4eb9513d83de3f59dce6b019be8b5449797882bb404aa3938acecebaf6153ec1662d042939e3a45d6761f100fd8f35d3342da1478be2a36f15b221f889e46180dc44cf5a57560ee4262c96d27ae3648b1ec376ac758efab3d6a977e9aced2b563b29a31278ced6fb275f22d2893e4b7ca3f85e443df0508df6c9b1b4ed22563198efc34f3ba3bb0899910e94eab476d6daeaafac056e32907eb88b23ee395f2926af288f0e8872ccebe1348a1a5f3c951b645082900c979c7950c102145a35e79e072255bfb41fdcc8a4dc66fcba95fcd97e5d4c9c189895e2b06cc0650b18d32c6eca6188df0e6c0f41b24b6e251b4fe1d6b9f65a9920262348607961ab166f7904ab56ddb7fb41fdd6f5267a18f33f2be454577b80962b4395a256324eb00c329f4759854cde6a3fe85acf3b00886923d6ab5c5af85250c0ecfdb39c26ff801bd02557cb79f8bf71b189c3f5215a93bb40232d2f1a003b1c1bcf5934c4a1ca828a48d6996300cb00375112d60d3cccf135a641613d9b8855bd2025328be261d2e243ceff86efce1724a01e3b5e84ad075244fef37f8992be35822f36368138b2acb81dfb3593aa7b88f99c80277ed0f186a54d7e593fb2d55eef5c5956758674e3f41ac32b91bfe5948e153ed8787ed193f3c1713437db8d6ccbdcff8f11d44261d9a16f82475371630211e986ab8b7470f5d55108bca8ec31b317735eae28ca406f5ad0678a001c1c0165a6dc303984025efe057678ea0da88dcf1e57449740020138f6fb3b234d2e347741dc8a6d2d18c6eb6e5e0a3d66ee342a004543eefb52f539d0f08aa6738a52dcd1c278abc1f78a5ffb4825f596b069ec91fe5987459d009ffce27dd7fe9ad67d010c2a12a4f6eb595a0d194c70c2174d077ee4db80deb5b091582f3c5627f47c831ca667068a37211f94585579210208c2d209299a99c7f5a35d41762d415e6f007187f6465b2f531e6528853c4f7384759d466860e8838d0fc5f320f7409806b8fec4fa55a846e61ff1e0e08b1980c5e2d8fa73f2bd0ee3c38fa388f11791758ec8771d0e29a383ecb60d39aa4f7488a00f0836c131f44b0502bdfdc3c769284c7dee9bef1566a16e1908b0e96ae80df7ecde1d93cd46ea2b0130abbd2e36d8a4d4e921aeeb58a91b244bde9c135468e44ae299f88dfd36ee1b22caf167b36d322c1406a3b25532a6e3b2eb3fc38aa7e8eb850b0b7487b5c3ba84505c4861fb1b0b275d9f7c62b531c4bd62bf45fb2f76ed5a127f448865d248e460cb9d4ded9c2942c48b266e7f3d378f2870dfa3e9dff05b809e7e7da737b4122121a2421393ef0edf973b3d81c3fb596161fb28d7a1019aa371e8a2edb34e735a690e5a59bcdbfe397199230fc533f988189c24d897377416fd66d52dfaf51558a85b0e0505e8d7affdbdcf0d8056723742b0aa189abb803bcaca04b83341640d32620b106c6de1f1d0884b80ff11f724d75de1b3bb59628288cefbea0443263054cf13f921c075eedc1bb993d43f72a48d99775381fb11fbb404b8e80d346d13fb5d786162ffddb17e0819171821d2a664b7ce3b4453c07f7b3a91e9aa239373e26a7b94c2e8b3b5e1e0989f84f45c51852c3c79fd4a3a1e2c212959185c68f6b195dbc3401e974e84f98629feb0c4c20effdac53784172f5223cfbb4ae341fa422d90c96fcf5d61af0b127ebfd4d506c29f3e9f9a3490b6694f5847fc918800a71915260f9fc9b2a87197f5f490d118da2c7fe5ff00c2ce7ffe52ff466ba21b6b4b874e8ba82de2c90e2ee7355f66be2d7c8231e450b75abfbc532196e4d6096541bb7a3c1a438593b93ff96e567006dde23997db8cc3b3dd5cd3dfeb6189b97d718d693f1836b6d2b96dc708e63a0394c35dad0827693a25163170a256494ed1f5a1af274c82e882692860d35a042b3c6c95b7d7ad71b643e19b048ba1f49aabff1bd24eb6338102f06466ab48ec86125f02ce874cb0f406ad74bf0d49162c6370133523ee5ef05d08b22e14d6e0ba6540ea3488e52b4fa4a2eba6668e9605fa3f6d0e008d667731f3aa876ab31f409b022c58f92a9f78b2e4f5c0fe4ea0b5032a580cf2cac1f903eb75fa2dec43e464b3f516f555cde0cefb06df0d45ee705363594cce61094e31f49c2a852e935b42c717640a25ef2530a90b964de6a3c66a083086c83399543910c88ff5c770f64195b4030e96370f3b6c5d05de8cebf77cbcbc95fff52c4d1540b95164c62054cb1eadeaf88ee09e516d38def1cc2de7be220755cbc956b96b5e87458efe521ba757f40c4221e5a56e4946b40880aa201fb4f9f55e931dc49943d5898ae192e64f7189f48231122f0945117c2f10811c4c62d1c338f0282448946c0e19f33a35390d4893470f9343f86757bc630ac35a2b2f4455f2575a76335de5217af96dda18879e2f96c460049cf0127a379c111e1de6b1373a2cd3a13699a2cd7611b1a51719f49a013d674d7cdbd5c4590f0d2cd493b401b76e0c57e007ff3b24785408f63d1bd0a1eedca80f1e947daf1b5510c028e39f99b1dde658a571383f705edf4ae20fed1091ce92345ec3ce9c2b01b07c231ab8570aad1ef765f581b11f587884b67b4a6f18eb8ee106bb7cab252377165c802f723af90250968e4e3f9626762dffc5d807a0e7284d89817dc21ab269e07b8e4ff9ca538d98558ab350bdb56e7160c757c21c3cfaa11d7da654af1c273710ac32455e23a264796f3cc67a5dc25be83e39d026029754e58c81affc661ff47852f096abddf8619c5a524a6cbfef2188316bc92a0956817411967c0a9be4c5654eccce41c4533f31400ff20df7ce89ff6dfa768292fcb8c51c675b59baf92e9580b46b860123f0ef9e8e9a2a072026202186547fd52bd61b53c9a3458fe387fb86b13706c8efd901364b73c7cc7384f3a441a1fb2538c58b073ef73c38bd4108d7a03d4cb8cf7e259b560853f181f0496c3c59589c5f334a840d8875dfeed87f2fc013099a612e9bb833de37e7504e5989d52f803642de145e0b5c578c8c01b86be02d4b5574bfc475d1ad14b4d241a502098667a64feb704d936cfb2946bb031a206f3d1a50a2bee50218254292c1d7fefadacfc5a86cf6209f53bb9ca62c6e476d24a9f0e66145546666c5069887c02cec15f82ca9f978fef0c3ae61bfb6aea425c1dd573395ee37a6a5e858a10121fc827d98fc82e269ddbf87b0d3ad63dbb03a064e92809f6c40a4ca21b2d9361306affc4cb3c8d5501e397bd935d1150740ec89b57ffeec71da4d9ce118fedb31773e02b630a2af9f1cf5ecb7537edbe096e1af6d5c6b128ffd85b48f7fae6690c0ebff0d24368acbd92819778253d0cf91c240f5fcba0c77ce781a06f436f3eedd955da40572fa9fbaf489c03e42aeceff4b457be22fedfa77297c0464fe30d94602d64d85dc6c183ad7ead1a5403ddcd52d35ab28535358130f1fa64982a6da5547c0c7e0f9c4208f82e7dd0c0ec345ff89e288e8c163cd8e20aa1bf2264f4ae50d8070bd8d0080eebc1399cbf1d0a722a2d3a5438be9f049277356ee28ab70627f3d64e2e1be3679001dd04e8f778828b1e08997481984dee5d7fc5b14df88d44e8e1167b2d55ab36f911cbf2ac4cd380ca74d643f366c15124506c80717eea4249616a4b427aabc1982fcbf2d6634e71b52d0f93f775513dc3d1654164bd2c633a5f790d0af93104256051cbc669f7c4bdbdaf5f3fa6cba776bbaa4b0b2e0fea70c81c07bef13c08ef9d6a9eb0beb86b2a5e019895240550b6adf0a9d1f63b9fd5228cda696ac454de195556f5ff39f576e74a1361ddf0394b320709ec692b5e7906af5295a22a82ff19f917301c8e5d05fc15c17e49ed389bab0d7a99c2b3ef2686088a7ddc453be0ddc887f8226c52cf206c65b5fa1da733db4b1c9244d40434ab1a10641101c3b1160193df065c23b77e1503bcb07ea75649f246f40db047356671b6742b8c0b742b84dbfc18d4f7d86318ded4fa14c8407490d68e642a02bf17c501ced2d88504c5de9631d59d1770acbe6423e410ac146b44a8fe0f706f01949012d7ca67ba7c6bb7f1d8e5c6c65f9f15dc796b1d21f10bf14ba7f4c3bfc34998abbe2d6c2ebad8d1e9a27a9daeeaa1c77cb1ed3f8017d20beef925502befe427054375ab84d7166d5444c2454c0e9fe2ccd927ac08cacc74dd3f6fa0e85afd690bbabc15dae637adb531312a4267238bb1e26a3fe5f4b7a839f9192f46729225a9c0fb05387c2a023296e93ff79c6447b9044a8c7181637fb29f31ff4e1c9d57e7342606b24c24a5512d16e33e73fdcaafd5996da4a139790f4db854543843d5114029c56a67655a7ce4c9ff1d59f146be51ff2a3a49ee5a22f34a1cb000dc4c3178ef8fd9a79588d840cf359ff5f5cd9257d4c1355860262114719f0e169842f4dfbb0a064565df31f4e0ce85b0128ab31acce12cbca52ae67c6d34c3f87b07defd7848a5f9c84d341bb67fc4a6dd060497fd34c7e4991de148fdb897d32ec7fab7c4f872647e86a0759bdc41d65ff9806d479690ee78f28cca4ebb32b02724115861f2a7db5054d0877eb4daccad9f88c2e44ae5bf45290b4468a602943cebb814994e80d0e52eb4d75196e859807b355c6745709d5faf153431181737a83b8aa417eb1e5f4861bc4329d5fe3f97acebc1dc34f6d19c601ea89eb1462c1dd0d9218af4a7cf1e6ffc3a488ab93fc67460bc80c6ec2a4fda75deca42f4fe914752e5d5c19e4aa690a219529a11cc8461d041c67dec1cedc403a0aab71af1141f4d352c87f297a36c8900540536e23802581ee09692f149641355993c2e3ddb40238fd49e026414846d057e67fa6d9a0cad5ecabce0ae639e0e49c3090e547e153464c81a3af2fe338274f6e62342af8d24404ee85fdb3a59783f5acd7e49bef1ea845a3b6c71f963720d720498ff34ef1f1cfd939c397161e135dcf94b46cc736bf3c5067f9ba9599edb9455c11bd78093a3c0b85ac81cde86bf3cc04240e6b75a22595c3ae7131a2d10fc57c31787a69b36ccc024d2522eb26229392e8b569eab4392b2aa85797a0dadc8e052ac3828caff8544ff1640817050f0b98d3e858f4d507cfa545919c8848cf3df88fa0b5334fd2f2450bed69472f9cabbfcce2d2672da45d6739b2b415f5ee0474a220551b97849dfd3b90a4b3285eb019c3150303f94f2865ab9c4cc844fd91fc49020fd3bb8472601fe9a6d45ca04cacb2c55949d5a96e989ce95dfb7365f481da7c4c92dc6b0783b12bc5415fa1d59ae0504f2cf9f6035e0f4bfb75bca6a916a51805d5042040199b3468428a5d1d5af576f4fde835fed96c3386a3ef8cf6c6987d4dfedf69373b230b55db005fa19070ec814a190c3ccd0817e1e373dd0c631fd350c0869d2d86b4845b876cb59070f71e1768bfc73c8a87d1d74bbfb36b98012b933cc95dbf1f1933bdfcece0cb8bd70ede2d108a18a9f9834f25e3be166cee410446118befbbd408cf5dcbfbf84633c3bb16160f38561e3dd01ffa102fd9e14f76ec806030973a6d34250f494f06516cb671c546b6f92ffcaf0e78b4ad8d1184f1c4c2bc3e8fb123f9bbf3f56e3d59457825d1e2935c1b8684c0d55df5a753fbb3595277ea2c4dee0287de7001ddaf7f30f43ed6fcb1cb6996f9654b6464be1f96295ea7392421ed431b9fe20810783d5fc601eddaca4bbfa65aec4a865dd6c54897eefca8c084afdbf35adf47c5b7881d0f68acac40abe120c7d1a60652c5b43ba3eaf439a68f1db3270ca0966f3d7c0829c6f96f1c2452115d6a0dcc9c8f10888d47b8a7bb7857e1a7d3fd3c37f58357468358c7858b40b553e48b0dbea166bad0d92514f57145222be1c1053c04751987956b8ebbab7e8b526439ab71bee2881b01c09ba96ebec95b2595d433f59f3bc1a2d12f47da5c60a04944eb8b9fb5d65895721d8f2507eaad7214ad649e8b72f18a5eab7af55d01b245a83685b862ccf861848cc2d27225b7c14420064d8a65a9a92ec924e14111c89340db4adb3a281016b40bfc5097003d08a308662e05952039a105500dd93671c777b8f3a422360d7e6d3b5044233be4f0e1d75d5d2fd6b3368ee58c396c2f0db78b6c1fe0b426b3138e8a3e018f9901dffb8382d7a63452a1010face8254d6d54f86b910a2fa59f9225447aa665bc56253e4519e06ea8d0b027e037d1eaa7a1b00ef9da7681c5697e52c970acaea616b562368c4da6de94dbca2b174fbbb2f5cba017460d220f6bfd030f6ef7b7c3a2245d43bfa3caf3786802fc7a2b12e16f0febaca10b8d2a0196e281e046c104c4339b0cd3cf81ac6336f31af39a1f2f652f78242e05f32906a8f091608bd90db4771b24f18dcb7367aff99710ea0b5d4d823671a875285a3ab29b8704aba54720d1fb85f4fd3b952b86bb1155aa59a1de04f290dca8a08a50f0b5b8eb410164dc85881ba806bad8629745fda54e292fae4490f346725dc0e4485a48a8a60a479958267e38d643d126c25eae13f89738bbe524e87b8ddc36babb5e8272277e5e233febca92d9521a2e089b87b6af2d85d2ff64a5bb93f4d82e32513998507533909eb56eed33e08e16a42c9a4b0d92e771ef9ccc8b7a2a476e5e8dd26a9b9d76447a30b393e75b97b1a1a78bb28007fbbda0c01a14e3f74241bbc9e2ddf79ad141e8af3a1f4c8f26ad02f7d28f7e0b6de7624ca9ccf7b7abfa9003fbe15965b0e8aa2df006502137eb468d64b731ee0057a149a14a24836092672ff28982351a78f6df55b0c0266a33148adfb578f9a682c501f200c72edd13ab25de33817899a87c4d6497e5cd0794995cbfaf44c2dee4a4cd0de16ee495531d8abc669902b1e472584fbc2f008256a433b209214a4abe7e5415d66d2d7c5059e440c0bb498a45faead0d68507aa90cb535a9c574ca1a997004c5104c95836294c15071dd370ee1b1366081c823c6a36e1063e545e2ba288fd747f8af3fe834a73e21eedc4d07e3c3121d7cec657819d91d58f11da49927c83b483f06c4a04e45c23efb3c29eb0c0353b8a520ddc0d0d7d10976d68497b1a5df0019ff7b22b9b5cd69107b7dcd0db0d0ff1c22c1f81cce47e6da27e5fe32cde96dd46912812a71451763a77717fe08e275642f801734cf00acbe861bed05ac5190714b4ff38f8b8f3c4aa754cb4a1e7ebad9223f1a4b717344b0c5cbce67e666fd1cd61cb009f4101509686f6f46fc247c3547211f0e034ea86101abc4615d869f20a9c2e1faf95692de5cb9a4e924dada7e6f85f6f09abf84e01be8179ad64487fb2c91703b30bb9e0d6471559f76419deab64131cb8ba4b34851a8c78e92d1c07bfc783f4fc4036f4df34e5e2e66de344640d2bc87018112f63bd318cad225a44ebe81ae5beed5c7db5f13eda917b3b70a6195111fe64931b690164677e0d363168b5e4cc4947fa6608a1703166594e78fc008b8d67bb7598da56b3a5065c60c78902afc3186256557b535498819aefc7f4b0a7ff6889b8caa51886cffddd06bf5e885a90b1493256833b1414e131b022ee61bb94c8b01065fcf2837f921c3bfebafa58858b58a81e8f8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
