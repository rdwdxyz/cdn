<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b918afbe726ced734da4a5e11bbd730356e908afaf9d8059127e796d7825964145aaf4d66637526f80b03f1410e8e1d8292ff23988ece0e0d82d0d4dbb0b2cb1b2ba4d6e3226cee252ca9ec2ef8fd9e29cd32208c1e0527350aa5b2ccb58b8f904806a2c57970a73fba22456757301cdadcb82aa92d24b6cadfcd204cdefba67ffa6b0413ef23de2baf6a6abd9a529c52d79404f19920deccf5ac42a3a95e55cb9c641a93ed610a9b755927722a8c35b756403fe632adb282ba51df102f6636433784eddcbf6b55cf99ab80dc172cc01b0bc107ad5c52734438bf7ca926b7843faa5a85547b0e672767263a1d15d44d68f4384032e976b59be92305ba5f641213cbc39c5a8e1824b2e5f00d91ddb623f25ad62f6e795a8fcdeac892dcd75736fccda737103dbc50e78e11606677f5949d9919332b1d7479a9cb3633282e87a944b310d8c94498f08155f866856fb705b632ed1aaccda1ebbb6471557345591913c5b6126c7a5f11a5537f75c0e543e9a71e7b5a97f9d333e0b23ba212f26ffa99ed7b20b6e3fa43d112a41d8d853b564c40821d60df104672accf06d3b1c6784dedd2986c0ae29f042b42ecc956100b01fcc98f2993487b24fe6b2d98f278fc89b5a6e04e09f3f563357549c93997b2690154ee53deb0aaa007e55f01ba51c28140ae1e482e8bf3089e02e61f314afbe20674a0fde8613d4438c6be29bc12178b904dedd785ea4d6bfe9d6b9c9bb1d80a599b5b35d5dca6f48bbf135b13b8f4dc66475ab672496b55afc21a71db8ee92ffdcb530483e4713570267d8f7cf0f7234b8f3d190edde821efc180467292b80e758a68356d6778d5daccafe3b0c858c26c247bc47acd1d9020e6118336e24a9bcbe29308e34e6dd2a68645f972e2fe85defcb53d5f479df20245614e31c7eb6429378894e9bb5ac6c7b1a7fbb252f830874268eed9754b6ed7f571c1766513e759837b65289f074a10576f7af9ef25193aebcff795620d605e5fc0fbcc5e16c2b335591a5b219f4e0c5475172c6dc98627e113eba347a0714dda43ef076622ec5e084f2e54aa484c39438be727ce9a7c417ef66a28510a077769f6efe70a53fbc0b18cf0a513f4b46decac2bea964bc937ae525ea8a6d03242d16e58285e3f8d65213a2c9f2fc7c801038c8f4af6ddad8a403084d9afd33e87887179f158d01319e057e52041dc408b2528498de5d8805f9ed57f9773192e44a2a801ecef9a83364cb99e6425cfdae52dc39d7dacf84d267961cc47d9bda403871cc51dfb1e05ee99e84d33542fd1121bd921da31deea5feaf8a99969162c9facaf790aaf5ce51ec326d454e50fbff13b72549085847603f1b0f2b4aba0168f7a8a1977929ac8d9e308e645a2131971c77f71bc904427267cc787c60c76a617ec43f191bc41113a8ddbbe840db9ae8544c1158295cc5fa4e7bdc5734d4b62fb3cc517363c960960231ea592f7619634d9bfb52c8b236f5f2f9e833c43da15b8894bcfb841a8e14a2b47bce028ae0d43b1f516b1c5dca39bc84a159c83d11b4518403b6009d9c6374ddd10fda592ad48cf88ad462040194deab27b3b257b00d35e088f2d1a54a82bc45c7eb3f7a79906ca7def1ceb5ea16399893f84f11d09342dc00e0de72614485f7904f5f3cee37d46840c5b18a17e685b1ea811f192ced7c258f782088c3ec88fa71eb6bd458d18594aa8bb35834ef526b793760e9a55075e95e43393bc4183992a91b284fa424881e4df72896d228b37fed9ffbf627808fd721d15b17891e6eeecf2351a61628ec47de925dc1ba8d051872283adea0cfb3dd22d96df36fcf347bf06314c08ff03c58063b591a6091b4cf9ac43c9ab495cf9b35d09edf023850e4b3058df77f90a78990c7ecf48f7a7917f816dd09cc1bb27e423d1733cfd888f3d78548384745c59735f82957ff5173e07027d0a3253b4b7d68e108bc0840b13dd30b7538b56b92b939dc203217b340b70115b85ed9619233ff175db2f39014be0ec5c14ace87cf17f70f9c326d12db15959502056a4778acb39bf38bc8cace4415210bea0abf69c42469f1ebdae2bccc912f7dc39ecb1e2ae84d7f065f7606ff7b7e76e2d738e60ba73d4ad0b361444ebb94aa61e34e4d8290f02c9d0407d12723709900a3bebb2eaad053c422b5840e5c37f785f47f0c55a54b6583ca2f7a2fcf0fb89b309a13a837cde2879eda429244d7542ed5e01a9d8bb45549c95610f7a6a42cac53e28e53b96e3932646e80a053c85e5a8ce75ae3d70a3b327287c8b03bab4f5b4e9b305e838b4b3fe48c4e34f298154883ef0b795298a4c75c0170373e4723bd5adfca7ad4abc060f8d0ef17d1a01e5f1eedcd95f598c424ee1607282041b5affef33094e326b5dd1a0a2726fecbf2d1475af6a69bc23a930a8bdc9f96d4724078304bdb43c741327ca0b34a2694584fbb38efa5aab14ed3cc184e2f23b1b4b8d170e0b1b7183bec7db7e1f6df6f0671ce13cc5c3463c203e106b63a55271a15eb3ea1f0367940f006f4e92f2ed40316747c828dea7cb83736139568afb306fe8801c418e8f11cce215f6a43d46325b883b98420ae510a9eeb43c1b4beadee41e531478f04e8b188e964cb332e429a604f4a41c54bcf97febf8c41de6bc0ab585fb8c28bb08c5bd27cc877f9159cb0b25e88f948ec2fa5bcedb48e8044ed2d0d50d549d43f6f25513910c89fb22341856fdeb69b093ab717a6a686f50c6fab9d924ca784fa9495a88fc624b976305612339d2a914e0cd9eb9317712860bc6d23c10bc46a6be3a20a317f73d5c7c02160d15223e1e92ba923cde6dff8d2b00df4dbdbdf5cb137a7ded07bac343b4cf870d73aa0b5c58de5e6b868c610c0a2e919e9fa93b000a7310263542cb127b06a51246e1305309cb6ec0644eef2a47023dca07a9d66f21b5cac785504fd879e8cb293d2014c479fcc9516f6c8e1ad16d7ae54e676de699f65a7483478549514d79fce5f7efd707483ebd4dc64ba40d7f9e0b1014c6e97af06e26fc12f5b770e1ab098dee271008c7eb0a3307b21f3dfb4ce9cc778a834da1020cb0a05d26db902e4842c0504d5fa4e243ab1395cd92ea32a3e193cd9cd668acf302742f36493860e748a6c4ba4963114937e0c8b3a761bb82b7a5a17f5fc6e93ea12980a68949300ff7a0c81782fca4dc816aee1769c809e081dccbd708002419d2c84dd6674a85ff30c8f618dbf94d0cddc378ee8dba29a3b45117ed7a61abd1cadf874c51ab2bc44e0b75faf575f0226f50da8fcfe9d8d508297f7c931800507f7ca33996455c18e0ece314fc5e05cf3c0b4622d085679eb809477d5d9a502523642af547d5bf224edc007ac2816b49bb98c6e9cd541c002b1a486edae45ab7135ff067d6f5fdbf68c897a8c19deffd3388f2d314064624897d1949a9aa85e1cbb8f8104cec39403902a97aaf4326c85e54ba4dbb1f35c987c669dd19c12e51372ea5c329395d5e16f97ac5e8df6ddadb8a111105e002d373fa7776c6a71aa60d2c67bb693126f031f14ab4eda89280f2ce6278cd433a3dde37e528d43bb7a7c0c9f93068f374e5ee5bc6b8a76b8b7ab4b40167b5a232b1f6b3233e9ce5c95b7a03668d1ae27c9bf36ea29f4c9f1ee3c255b7eb3ea66a5092bcdbd675b8048fa89aa0f4966884f2de926726e01c1afb697c1b201bb75fbe59182b326b4fc2881e8d95a887fbc13784c2e75d5a3b8766dfe40f333a3ee0974260e53f53955bd7026004aacaf1c17c47f7dc3286c8bc37a285fa86a52e8a20ee55fdb4fe5501d0de345f401efff9c254fd36f5c70e3b69c37071e458c84889ec443451d86015e093bfb7561e57786c29937847a0910a93f0317b91de97407874c0d8ab7c8b478241d3b9dc732e23900d491805c8d554efbc45934d9d3e42daa6ec1e1438158dc22d783ff9748c4c6803b1ffe4904bd358c7b5039dbc2436124d0744f508793f225bc875be12d30f22da404f7606e685624b62b322b31c3ce878fb7058efeb59f51780f12953975f868c9801793780f58cd065eac387dc503a57c45decea897345b08eefc0222b9d7b5a136fe6cc6d8926331a0e4b00d918d6999b3a54f4425ae19908c17e75b71dae48ab1af16d46456813f0f0db98c649473a2e380f9b58ff75edf72021cebba23478215dd3dbf3a8616931e202749e9af1edc3b2a6f7f3b7014fe4b8c6331be11b7a5a2e4eb95978e1010642dee59963cf5d999276eb3fff8601138c1e6593a89921b9407e0fb5b1effecba878c60d55d5661b5d8bdc2ca1a2607cda430f3f41c8d5c072e916d4d4069b6020c5214d292b48d11d37255768cb97d0fdaa0aa9d99e431b4af16773b1417d23277c689f8cde1ccc80024e76d95bb14e68f0f309e22142f945eee6172548f10b839ce2f15e9c36806c1956691c9568c2b9f1e2e3b050573414ea23f8c6c2c85a281101a051ce7904d5cb4a84ba8b920daab5bc47070e93b2646ddd17b254986a57e17c4d08e8b1ce4d7598e064d13e0ada6e85aca1f64ccaf8da0d8a6fbf48c3c01ea44564a19e16ed06532762bd2d3c123078d4fdf888e7a041e7b194617779036f1ab2dc7243075f4cf089d32674c2dae23e8fef40d99d213cf82df5d49b7572b826eee545d50eba0b9f56af3b86c12d1921b2fa8b917b7233751c8607c5378ce67e18240ceca465160f7fa4fbb57413700debcb7968654db3ec0384b147f95f1a5dfa328c7c1f8adabea4d74587031308a0c8bd109e46918195b7551f59af0e197cfc3fbf297975c10fa38ff152f52638d7643b557d0cafe658218d96523cf54711a4bb543de0b3ffaa6ee45a7e173861c4a902ec8e945fdb06d9f816dba4b6a817fccbbad9455e552eba6c2ba1a025dbe77c9cf679058d3cac3e2afe0435470eb3c2dd9606aefd8bc146bcb5731198c21df0ab0bde12a03b94f34e74f55838b13b8b60d08b276d0b228a3cb356d9e746f51d9f09f45296bb9ad3ede7407218b9e9ffee010dc69fbb6e7924fe9c6fc3d8982e6da1338fd60c56d5d6576f38566676b1b53d474b07c61129086771e8d5d525d4924e27066935f43206283f17b098c731583557612d5a5140a1b591190d3bed92c5fa2c8990bdfbcc0d677069a2ae2688c8983c76ef457578087de611dcceb176ab7a04501f6ce656484262b03884f0e4c23c9884ee32575033f99a05c40882e241ab94b6d150724a44837ce5d0e13f29b3a1f4c5acac9832a74d8fc1d76faee7fd9e20852779b069a7c12418a4dbfb2557dbd43313d7596ff8d53b68283ea83455c7053a0c65b91bcbb2985ee9120131ce5654af411263403c5e691a2d7eeb5a45ddf0dd439edab10417c646e681373c903983fd288b9c5ccaadfede3152cb262826f966d9c903c0479009d47777ce9c6ddb9f858e966ed06dbc4bd596b7283490e680606dcf95145c3c048e607c375bb73000432da3a8e04f79a13a3563b1f9aceca891efe6c90cfc1e9d4f85509ca7c706ec110bdaabdf23c194180bfd9b9479badeb11d7072258339299d986cfa47e2a5a3649bc4bd4fe8b9093aedc5804740a4470084483b9d3bc8349236ceb2b81bfdd10489b63d88897b2547923424be4e544daaea28c8a1af541af37b92bae31d556ecc83f2ad889bbbe60fd6968ede6471d8ccc3e6fd6fb86795bd45ac1f28fce78e41a17e81aa2f61f313406ca138ff8a73823284acfc548e61e30a1f4a18a2fcf4173c408e70d795e1e4232b3df83436e1a0385a986c30b5bfd162987473d2b06e5cb337bf4d648fd882783391f7167850d00d03779f0b22650b474439f0f6dcfb70d96d8c8615cdb01c4bbf4c1bf0b6c9ca06559540d3e01a368c97bc751649d23c4b045cb638b676ddeeabbd89612bb97f942d415e81ccb8585c0a8313c48e8343a7481643b4cc3b53a7cd47b8a4bccd8e53be54cd9b87756c3931a5de4a92780bebe98652edeeda684a890cf1f576ad06235e98135b8bc63f0546c4634c0eee97b7e705184a77d363302c9d99f3398079fc5cf85496278b00d25332accc21aa2551b08f81bdbd9f10f75970ddeef591213ab958df79e07973ecb4b04964547a27d81e7f03446b297d55ab4c9a6d60eebdedee9241181ad4c1f5b5d65dea793ff5c0ce17f5283f3510f86f0b92441499d50e68af18c073316a890abb31c76a782d4ead437247f5677e96cb8a0dda8da8cb0ecb0d70831da40a6580dad8608b4d73dc873f91f0f540a5183d6ebb7f41797430ee574916413469b617ae83d06958d2f5eb8b825f53507e6223a905bba56025069a11ca916786ab10da657bb9467b13fdcebe40bc1955432a15530015d994a8b4abf0c366c1924dbacb07a362856f0aafad4cf9ef7f14983eb2496467a1d61e7f1e7f46f6ec68dc2e27f71cb429f20e8ebd17fb43d16d8641c0deccb8e1c01c4ee113c63fd9541db49f191276a856d9d4fceef962bcbaf1c5eedcac444d77c38a2fff0beab3f4bef4738d28274e7e80d8e3d4858ba7e00fcc2900567edb4050e7b3022ac0800f114ce67674d83c148eb3bdb1bf9824b4e35f03f3e0e074292cae4ee74802022b4b94b4b9f5d262491afa6126112c02fcd279f7e7a46fca45b8a0b41f42f9f68747fa910c970d5468d3cf40c514160c10a4956328f4097765b58049c03df59f3918304570260295f7df3aa386a409fc950af6bfb12fbdbd7b406e892940b4f31688f3ce628e73dada8b380ae3952ae55d91268ff50ed4b344c50146af4a2126c6cffc79b0c47270a6c4062e25fd75bd5b472918b9f4b5e334fa54ca4ba5d2f9cdbc9b33866471f9004937034c3b04c47cf6d05f1f335bd79b6b4723cad1c39eabbb8fe160935b7f607c85b2cd1dd03c341bf5a27564a3399ef7a2329aff30b914910a685eecd8144aa4587fca9c6a50d106f65f4d1789ec9a7850b4a70d2bd24bae76bab1bf0094f62d9a7033b96a2cf17b452238d6ccd0d04756b49a5fb324f1d29120c750b9c8dc43f99c7a5fbaeff780cc807e235d5fba4631ebdde8173b4f34537addc13ba0b82283369d3d98b6b0b9a3928db8c851c3e2ee1572129205811c6758b279bfda2f1de406276ebb9d1413a67277f07701f73a1f600efbc229ad21656fec9d3383b8cd22284b259e6f507e9eb9153981bb2249938ee7bc143d92d9b9955f4c065c402bdce3333492042d795b45686eaaaf3547bd831c9ab9e2b1de75fac7796c8a148c3dc0ba3de28d4195a8e09f73aeef27493735144ee4e0dc479fe0821c2a43ed98a4d743cffce174f84543d1a18cb294cdd024ffc8caa6e32c491eb6211c5b6cfdaa8c7add947a6dfe96c727bf50a6454939b8c2cb2ba9357268b39d370639e1fc7b380a65c2aceee8db42314f36a325d6c237e03d071f6d6c2346f18c3ba845a55389378f96dbd85c5c2b898b0c81d89148ec521fd71c9e1094fbc238eb6d093d264ef89842f4f9a92cda5400818dea0c4a6290436ac053fd8daee841f5c394a17790555e6f89852d2954ab4a3ecdfb9702d74be5fe1620fba77a0528c9fc4d142b96505d53262446cf918b3ddc7d34b54d43fd1cbbf9167175a45665d403ad020a0be1a6a2e4948ec1269983211a4c4eeb9ac3dc3fe35bac9ee368dfb4da7bd658a8de1c2347e79dd021709b9eff0d1f7673de2a34152b3370c718545bec031ad34959a674280ec255131684cce5e9b1d848145b566f6610f955136214be6bc88c149d2c81c03500b0f42e1714284665a0f7f2b5a7a2d3be9f1981452130ece68141ca6e1e3063a82cff4d9bff6afc5be2016fd4ef6e1a273fea3f5bfbd3fb3664bbd9171a12ed0c0962d84dd23835c44b16114c25dcf1d132d0bbfd23e020ceb0f1d015c1fe7ec59dad0989062b9ad80e7c9d3e94426e073a1ae62a9ae478550ad6ade4c1e08a26ba6ba6311c4a5f3d64e519d32e48a9d83b474178c4a785f252be97c081fbb835c462ac0165b3e263bcc94b6aa3db1ba7d7a39478edea91f27cdd9d3aa70cf35b4b9ee3d7295ab0c7be95c3fcfafc3b7e70cd43fd63b15aa5d1c912874f6376c27d1c9c47b9bcb57cb95cf5953191146b8f0a435e7040a2b7de86f531579de7aa3e5bbbcd800061eaea219b37036102ae0e915756e0524c3b441b0ac1c5918955d6be9fae8184b730fede4ac9aafefe0911ad46406beca80549b131c88bbd72b6932d61cf4be8dd92198d03dff48c79277530a5e9af62a5728fe9b4a69dbe7abf6b70907c8ea70b1f7bcdfde55fb2ea2394f9f12b666d667357bff6769061b1a3cebb644192d691b178d69b2ebf259726cea03f32e171e048bb8ee1c2e9c09acc192c98ed9d2ec937244b5939e21839d1037db621b99627b8c62a8bf4e52f26b661185aeb6600f5892bcf5757cd1e0f93577a2251a2cbbfd3e5b15b9f746de633f29402aa9e6728ed96f84fb818ecdeda0c6b532333b78d19f71be49a4b32098e17061bddf802d03fa7f08eb8c002f4bdcc2fdda6c98659ca70183a5bb242ef9d22a0a4c067b689c2c3db04ddf68cbb394b375b5ffa0b614b56c368f45e152ec6720e4dd0919f9d53fe9590a59176ab44120a49a817be28617a2577975bd8d68764cee1c479cd96f9fce9056edebc2a6fd03c8eb5537ac234b5af97e0ed7406ad45d5ca3f2169dedebb5dbd77464e0bfa5c61f825bb2f99f6039f2cfbe7140892102ffed82b7afeb61845e699ffbde1e9fc841e6accaadb65ed205ea89dbbce04a2a286c09a0fd2b995fd73f5172015ff4b64787bced72bfb26f687a1525bc88be875d5896d0b35beb15e5ea50812545f06e34126287c4261afb5f46f43879e2f135a24c24afa35490e63f97b909a974557f3fd57e12f2f612125dda3e1f268d3a3f9808a2fc9077787be325a0c4e8369fbaca48993aa949ad0f863076f5339ea9b50c07892346e28c67e68bedaabba9eaf042651662cd3f56b546038a09aa09a45138815967088533d9e8817de1cd3a34c829cf80ba778da1cf29c78445470b08e43d55e83cb815425c22e0d5327d6bd78b9f54bf9eefe5f289e920b887f9be4919b4ee39b47ced957e53a2df33cbf3e2acf9c78b4e0a65f2ad0b4233319e6ee623ce2289355ac18218f658f0ea3e9601402c52c18d4a672e8119f1326e288118f3d44cbbdd8bc1734675fd29cf0e66d504d1a3c799213a06cb75e468714ba1083053a80637d91b61d41a70f432b9faefb7cadc4e62d3c611a51870e7e61eaa18c77ece61becc64a8b2e77ae209e12e5163a175fbba72affea22b5b7c4f2d06a65ec4053afab7aa4f83645747f66eaab7de75d8ce3c79f8a1ec6cf45b23ee0dadb14ae4a0684c9fb2ee58707dd31e19b92091d882f4bd999e1d16116ae6ae78134bc0b276a7fb43f4991cef0c370b7faa7a77baae96e1636b7a48d0e1d60443c8dabaa2bd451558707940219e18c9f3957f8c9d2d8ce9f9377ccb16693d6b43118ea94710337228ead214cb2d5bf3a2be3c4190cbcb390bf7ca9b0afda26a73064a57b0628694df827b96e1cb35e1ec9c9d3cb8aad105718487a1e7696fe5d18441d711348b17fabbcb46710854757e768c5ba7c1c504accf027c74e362c1ec44f6e258f82a438b820b152783759c7465792762ce3efe4e1b4aaaebf17a7691fa8841421c3c1585807644b2c2ff85f275b99c62a1009c49df7f88b1325242db7492dc117ddae71dbf83a755ff1e4f40f69fb2fa38a50c4413511371957b93efc746f2885e47744aea4626e62865664d92e2644280f5dd6bdfadc954944b5b0fbd43e9b8a1b31937333ec6ab84a0d56696d9ee827f99dfa37164bc4b461a7a6dedba194e47e194574e33bdae91f7135e3881fb3672d7ea7e5fc7d573b269d799d08eaf0813521f5d924154a4ff4639521b4e9e3e1067be85b6b33cb6da8046e2b17d951cac977c9f72684044ebea37ff68c37b7ccd1cef272f8baf61e0baec9477824d4ff23b6b079b5c5c0e52423596eb50e19da34686ad6ebba5e03131963cc1c9f36df19768391dcee8a7ff82371ec2965fd229efe24454a51ad11dd62a7fad0139947d2125b5f40d7a42efe03e84961264bf8ccc5ce71cec5f83fd94c8c3a1645f4ecba2992e21cf730b14bb7a2efb9e225f01bca0097751a4026e480563f9f18bcfd443477a15f0ee1ba18be30be037987bb2e89df3a2230af1a3e1cb01383519c0fd1bdc3d254df8d574027130b660aa7236f5d3e58002397ea93c7d91b2e93ef6b4f3ab5d98e2365c3614d645cd4d7b608992f6aee9e1bc2ab267de0fa269f730e8419dda93cb77274aa36aedc4e72ef2a037d9aae656d21704026a09b5db7a5ad37e93dd68b1b004203dfc9fced9abcc48a9a08128b571248b9cc887cbd0cbb76da4fda2aaecf35de92610330c616b57da2cb03db2888327502b6b300ad5adee03b934cee670ec4d28911ba095c8d4bf7d1b3bf66dd00c9c9676961e87dbd36925ca990d4648ac904bed572311ebcc93f32fd6e3d0711fc3a4f95b8245133096c47da7ce645e3aeb1b299daeb99b6162babec2d5f52ecf39a69a1841b6ed73cd61c6bca6dd787ed972fffed1d8a82d9573c149c3704c03d6c695cc478abe1f74bbf37427df8669e8c8902a92ddc2a1b974b2218bdb25a0772130c9b34deb36f020d502ec7fd1657a7206f2513b6ec8bf8e84689c01a631bcf62c176ea9b65a8ec9856103b8ac9470d0baf4049238e95f35bb2598919ff0826c6e2aa4be5dbaab3315512d8b8c87beab509e0744d7f64801cf2411338e4fc07ff652bf160f9968ec9a9b61cd10df97857df69d6f9dd5b5c24509db446d22cf57eecd9f4f8b6cb7a3e4f67091ec8e58a5ad9cc66ccce07a17596ab38a14a31f667073aced0ab5712963d6935a0b70a0e0a415578c02e4d2f9288e3412d4d1bcccffc2cc2a22bc9754fe4eef19d2859044af33d8a5d982715285ed4d68389cfdf170eb242f7705be1d38e02f72c301deea0244971e19f36eb496dcfe0b72ae11289a832a4656b45f0905081f66420eee78dedc170823a148c4f0c9b5c1660f44b0b8dd5e7d43fff0a3e930683f132fcdf5e8ad6ff9660c15f4ce241c73553479472a020f115857434ab46faa1bd7747bce2e3858d5b124cd0c0cf6357feebee33d9d3bb8313655073943687a98cc02c38ecb4c612d282d2e32b19d3102d115d959fb56722bc10c71d4c41bb17e7dc0d42e0e98b7ba95829a1c14da28e85fb82b8612daca9798ab4b7af424881f8ecc6c4729c7f03eb5f677c92a3bfc98530b60a4eb621b4e6668a7b1c7ecad60e53745c028cb0845cb24f6e75da84361692cdf8d2a2747c2eed955f3fb9a9921b5b108401c65288b9a5ee0b5d35a6471235227262aceb2d8f16d71b4f32e4e3907c2631059971ae99fd98f492034190513543b817cec241c31112da7a88ee78c5b09c5c0d58abcd8a22a415617bf8c2f00678bc1c1bb8f413367688e33969563af73f84693dc07754d2e24eed7ab458f1874ff182cda511a1cf6df298b257509fdf02436fddfca7a14c0756b33ad66be15355fd476a79f212fea8aeabe2428932e120a0f71a04fe0c68072d29bd19299a0d1df21ea5d2200e326e20c143dc37908097a4cb86fe9f137565625bc55870ff7cba2fdde90700b4f1d4c7bf7c18a8a61d58fd540fc20cbabaf44e197ac6a3deda1a7d2cd7d6b72a1b068119bb8e80698aa484ede0d84d45513c61aee9f5d76fc0feff2c52bb5ad779f975c52b40fd6469497afba8bc8869c48ebd4cce2394816f7326984b73323aeb20672d2f9c7a650afbfcb2c88fb697504206bacf820c121beb9c1a50138165ad40fdffbbc8d9a2d9a0095a0e6a4bf75f118ea10021ebbd9cd82dc831e8c89bcb5692c02c679177baaf9ae96685b1d370e3ccc51a1b128f73ec08b83e9fe0a0a5bd1c8b49c3bfc0309f55fa69379049025120d6e322bf05bd450f8b5b9c1f2b00b04b2049e67b6a5be45ec5ddf75d1f9df10fe992e936e1ceef8614e9d488dcc386a6f444f6e46d5965b121cae6a81e750dc3e9fdca76c96aab0e78354dfc563f3af963d05834871ccaade807e344519bd850a08809fc1f8a5070cf0f28dd8609d77b6e61441f3e7ecedd4a45929b92b4c0675b30ac83c2344bbf16aca805d77ccc83503a56e11c10f86fc4ffe3a95c0c15c41364ef507883fb9504038e8a783d52e22d725e4ebd4201cd5de412d473e3af6b8ce1c78ff5cb09830670f8fad898d98b2a782ff5e3cccc697641ca5ad9432e1639f5d9f4a5e8b8a613b8a7306667742eea2aeae21f6bdf356e793c93db14080005431db3d4b2886b2864d1990a98dab05bf7cb9416a730c97dae98ef5fc69b8f8d10f426e9e567476c50d2cf620affe214d36f8a4b5f960684ff1eaa2076492c17210e7d836cd85d2f2eb7b3c67ebcead8e66b8cb4cdf0f5e9b797bd4fa00df3d19c98d4ba12aaf20508e2ea38269e79254bc5b875abd8710b866d9bbc0695451fe0c06cfecdcb3c9d000e50a46992f5cdba718b6b8291428b73d24ab5900762d23a15fb6d438a26162519503a874913a10490fc8463da0aaab978f46a586bcff33adef239ba4918496dfed472aeed7a13a25270fa14a8657a7d8a98766f176fd32b9296587f99acd06caaa4550e92fc3a9c70433950f80ce55beaae07a5b64c74834144e877b0580933defc93ad5b3bf96fbd4bce4ae37570cecd7a0b2c3a75086014e002431ed1e50335af09b5028406201a68ad4ae94d7bbead0f6ef6d7c9b38af54504e2328fe9e54fc0aa1b8a8c992f33fbea6aed82deb2565585eb07676c7d4b2908bc5a6c67e0ce707f8173531108b63e0e7854a2e9dd5933565e0a6090b61ee1549247b9fcf408572e71a71224dafe54e2b1b3250f64ca08a8b79fe70546d17bd67225cfd50b56019efd3b92d5e970701b11feca36feb760b27c51cf6704af67f6dba0a8ea20bce0a8de0c0ad90a98fb97280026f66cdfac475f4eb74ee6f7906b8c027633246a6330d3c7f7f9f577387ee95ebf443edf51a9fe7932dc3ace999f6b38868ba05aad7a7f725f57af210d73a35a9e9ba15f5e6182a0e5fd3b154763af9cbe0f791760dd3eb25dc1b57aa7c5f0027671a2d18c51e0a482cf1c6d2b1c146d83a969266418a0c6e306346817e2a40aa8667e9dfeae5bb247c39f28854f5548c4668a0d215ceb7871488dd23f15684f83a15d41cb9267cec4e4186419466b9ad741644ae5d0543fc28574807c08962a26962d9e8e1d3958bc59acb359ccdb1905b395df4e19e426abb112e63fa116bf36ad2f0f37875f05acc9b5680476a657ed9127d32513235061c11ea3ed2fea262c445604a2ae208663fead4bfc459b46738d0c7ce1ddb50e04b01c248119cb6e7b9513c23dda4d6bbc820699375f1df3fc15e99fc3f3686bb2d90b5770068457f0a6f9885342f24588fb96d972dad7fba525065e58028e679d7aecae62cccd2d44b5d0db222e9f716ec76e0c2df903a9fffc6245825ed8f6f217558ecdb236f393ec8a3fee2d6cb5394ff3b59c6f2d2b38ad5147362418ed335a5820e4e3a0ac7d7dd47de797b1a2d22c4627345972257d646de5332477ac6dce03f38333d0379c7b2aa0c46bb44e5dfa482d632e58b0ef953cd009cbc5b946bd562e376ee6e73ceee034ab480f6b313d0bcedbecfd59f47664787db3a11525a1e4c6ad4710a6df2bd3e291561e2b1f58d3ab53f9bc556b6b30c51e18a84c8185ddb2284d1b50d91329e990b255574503d66c3f6de3c9d5037482dad2eb1557fa4f101a79920b0790789858c316598edf63df253a454e7b19d254ae171696f19d8f9d8c956a8ba6290d2fef3608c7c534ecc93ac26d295b485ec6c56a5af723eaef1b6672727b471bf1be104b5507eace69daf99188a284e175af18fd34088f57469ec2d92c577896e2619de15f1ed346dbd9e44fefd17bfaa6643a9a45326f451bd90a0734c24a1ab4bce2ec4e9723a9ffbfd0c0fbe2e10f6305208c161316d2e9d5fbe5032cc37fe2eb1970fafe3923536ff7e529fd64c7a8e9490aa1741447574e4a7bf759146dd6ef91d8b82a0cf7d7099a657fbe8c3208462be2accc7a3b27420c59f7b4e92c9403026b23ce85d48b4163c06715b44f923bd15c231289465ff010d49ff9087caec187d01fef59f9f4b491a0d4b561e7b44fc87aef228695e2e6efa4e8704198f1fc9e2d45136d465c9c4070828611b7259b3300a0ec8f9bb267311c38e6b00ee29b0cec3928612bef41255b4a789804bcc4f8b76d708e7ef9b89a5d851e766705dd6bafe881846983cb477cce0d705cbec3ac0edb841f1bb92cb624c067e858bb2fc710fe254053a6cd91f97735bc38705888629cc78265297b04f03e274ee5ffa2a22393d75d5271fe4de2363037070bf5beacca4d7c79eb9b042383dce7bf70cb39632327da7aecb1234a9cc880d1fd149a5abc08ea81f8130499a6976c32f55b84017a7ee6aba4d9a48a58a802588f46cfbccc22df3973c5faccf2551ed12b142d939bc8f36c8ce1af7ad6603e93c5642b84faab71733c815f493d290f709f904511f0ccc8fe6a308a4273316d097676d70855e1a4c095b3436e1afe8596321496286e4194ad545779bfb5c66edd0d1587b79b6f5f6846cd639d195646d1500f1dfacf95357f99eab78d5c0ce8e0fb8e8967ed0bc9ecbb649bc1ae1970170b2a71edab5b516cbf0523e2931402118b3a25bd9f38689c93f1e1aeaf637b6bfdfdecd304005c26585167059157de86578125807aca626be368bea1c6774dd503688c9c59fc58168973c7a2051d876ceb780f0767d9832c63e16d6cbd35d8ad814946e37a3210b4039d1a3a1d64512d5c90bb58956abd5ff6f36f2aad26037b7c8365f424c8a76edce604b30ff3869e3213ba66d4c8558bd2cc5e7b98d6b9d4aa41203bd0db614e3db2f9857d6f1a1d43a7a1c359b2e5bdf036ff51ee79a318d4e485ad43c2575f6e01be77a589e44c1032271857ed8a7525e7e84bd4a8735429928e0392dfc3fd15634261b3ea046899158c70f8bb4082c1dd80c777b2e0fd8faafb8ecfe47823099f24aa52bf7afdb4bbceb06776e008982a7ec6b8933a60d90314679814419b24e60a4eb5d3e44486681d39f9547df952da84c4b4842d4406f94c143ce648ec67d5031388afa991a1faa4d4b4b81555e76bf686925da9d43fe9fd55d664b64b14922564fa7e27091924c921e49e102071a94cd9dbda029657e486fa283f31509245930f8daf697cf882d2996679c806e103678c72c04f210197ddab085cd50957c11bcb35690bbf76173829f492c83f64c01c22487b4ced06fb53751480ad9e46a70602c2afd60319adbcfae6b0a67a65b5791266de09558e239cd5e6a01e4d6cb2c85985d822da2b5eb549c5bcfcd8519f1f21ebb3a24eaba5e0ffd24ae0f9d86a5f8d098890111669aeb0c9e3272db6dd6ba8dbefd41cdb146756bb7b852e4bb65b704937b2fdb42cd1ca0062c545321f23943c976da38d2c2876f4dbe52470a29eee5496be31dc094c937935fba7ee08adb511d85b60c23bf72a42bf811e34269160bca95d0b2fba057d91589b1534a5efd5a7573f4ffc9500d9a5674b9e1f3a75c0c6cf845c5129648191eeb97a33fe59f8b982afbd2fb0471c1d7c6b611cf04afbc1350d865aacff2b41796d76cf8d5191c145d80f3de2735a69a417c355dc143546a845910917c78b8e5fd4fd727473a28ddb8b98fa662e1fd08bab02f74b7654683f8c21efc563b951e563d31b876364eb224ff245a567a91db6ebaca91abbb2f41db55c2b67cab40cc3e90dd799d34ee21989dba8ae36efa04d065b52f000c48817a540ed488a8cebc983ed8a17fb9e4d8dd401dba379b9f3c3c73621a6e4b2bf39b4a14805cc6658ce39fc0b578d792da0a8154628cba24f4e4e8f7f31f2d1081b264a23f32744d2213aa0a55c56ce82370d6c9cec852de0d608a111b6014edd7bdde37f1bd5fca6041992dd7745a71cb9fb2878819380fee8255bbd6eae91c776aaca6285a6731c6a71688f29a4611eee30868fd70e170d0185de65460fb1e6862597fedb12ef637d9e5ab04018bcdbe708edf2f26d3e2eeec876bcde6ddea8a3b64d8c0c2556ce30c5d0c3fd8d48d31f28a7896fe662e96e3999050fd0d83f4e27ba064541c80b9497834f8085b889f70ff5b8dbfd7dac45962c48929fae2343a88c1eecd1353420974cd4e89c6fa646f665c022d03d4160c4f27e78fabc0f1b04a9e23416bd516c7dcb8ba6d26f4ae29970ba516f6209bdbce80949ad2ffe1e0339b2324e08b9dc3eb3d60426767f4af6573d3008c1037d6a0210b267df6e7b1e998c3f8d01d7e7f938128896f25e88542702bc30cd5cac60bac670ac0a9470a92e42446f7f68725676fe4d4482f3ddddb4a37aca5afec658949107a8559fee31dd0bee6a234a3500e1bfa430d235c1643faafeb808c8151fcb44939478c68ddb03848b55718e4f395ecb201ca089feddd067193862dc568d5aa285b5ffcee6937fa6e1401a7395669027476d4c545c492674b5243e19226cfb5f8438bd7834be5103714e3017bd63be4cdf35f32ec4028f5c8416c98467ef66d58845e1cd81656ebb10325a3635b5133fccf750e7b57c109fb8ab2d2fb3b5f37d96fb6ceae7fb600b422f391aec060c0beb5ef87ca11184024d16c5f96619791bad2b8d8d4cbbd267373e9e22891d6f080918f9deb58b23e7a697ac665a3224d3311325b3ec42ff85d11ac891c8fac417886f1eeb42fc32b7523cc4e73fea26a4db49b6c234d44528e3cff8dc45ebda71a8bb1c3f98019620dba629d3019dbe3ab864d04fbe24cc45de65c787ea59aa4bdfd66aea76d6b4a293001ae331630f71aa6dd1bc544201a910abd5a5c4f189614ac4392e2bf084928a7605ca944997be780734ee5a93ead97f197f4ade9b15ebd1be5fdd63664696f72027bd3b3df889831d13ab72568591f368fa3fe9756f841292b505f3f85a185b7247d0e4cad962b4d9a8697a43909cf504efe99ad54262d47a29e3659963ad16f5f07e15f008fab9269f8c2b6f784857921a3d9741185797140db0b3f6515df4e23bec2d4d617e8643766ea228edd786401f0bcf5c72214706c8dffa79897e33c2c622490fd6a2df550c7d00a0679c4c6bf7885141e99c2b5c7f2bc4a8fad2dfa4b0c08903f6973891ab95161d953f9919885efa6dd93161ead4758e7423b5438f06f2231dbca7a9315acbb1f12e476bbb36115c165de5c02d23dd1b7d89fdd75edfbb31f9e476653fde68fb826b6cb7389c7fe33eeeadb714e55c3f1ee1b1faf82afe76655db7ca728b0ae2915085422331b18d11ffe250f353c83b643adcec7f6c5874190b26f87086f0810c6d0aaaa1c8d7c0c2ad20268fd5c7098d9bd32bbf63cb0828099327a52833d8f82c9b3df165647fdc91ce42681996d2eacc08f7a94875b70578a375e930f609371ff1993683ad7d03362ab89ceae6e661f19973d00d66abea8c3f7261e2e20c394bf04e7b06c4f9df730bd568445f63dd47ba1b26abe450d9f8fb35246c230cf893f78b1b356d06064c889352b68a4498c2f6c6280994d14c94b726f18500c6dbbd27b2b7285f562f4349526922965d0cf35658ff71cb719ad24b7f063ef584f88231d2f691aabc084ace28ed15848e051097fae6e810df473047013e233f570fb3572624af5e7ac3224d49012b5cdac76627d221bd00d24c7bb2f2673392f26233d642377f53107eafc86fcf123456bc24171012cdbeecaacbbbde34d4657cf4f635258e1b3824d8e54143265fddec4b248264478c8dd075f477ee6b98f6f185a45d8020e75e0ec01f320e1a1f18b0fa8c14507ff5bc40c3d06cea666f689f112dfd22b1b8c3c775eff3c55a1ee45fa3a615740e4e76b8b75598e48de811bd20d359b4a80e363ac62240993d4b7a0167707634a543d7f3d5d6da0fe3dbc59d14bd9ceafbf90ea254efae1d9cdd6905abd7c0ac3228e98d445d42197f6967e76e082c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
