<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0558cae16ef71adbc28d3f9b94ef757d69ce94d937f0e8ff574eaed5ecf1fb1d90731647ce1de856006b6963ce3412d72a6ee044c6d39304a701a1f24085b4079d7b0cdf3c1f1518821dcf70e287a01c4bef36dee6fb5af39f1ddec7e0c8e1811dec88d604f0922e631f136c2730b908f77ec2f9cf6209734b7fb8a23f19c02a99b85afe05f50bddb7aec7595fb6cb96d99acf840285d29025fa2780c1aac5fa04adb76a53daf564c778f18c6c44857a9dfc95d7521df90d57dc4eca6658f0ca6e8be44fb64d5a24756978126f02a75194ed9225353b5287e3080be28070d5c694fdbb87a75f71d2dada4433eb80354389757e02b0e540ec38a166cfe9c07463093b2dde1a626f8a8b68c72eb509480889e6112ea27e84ac039daa8a1a1125ce7a18980d6bcfac4d5765f8d7f1561792c33031c5f603cf3a4305a74750724171430b81a1c62be8db8be6a4e9e3c989c81d264c31b177afff1242839124d02b61cf2e07c8227bbd2eec99aa9458b9191eb028a8b088fa6c9799f68b5903d3fefec0d53271136a5a480a9854f55b4ffbb5a73748bb1cbf9a6dea3869e7c0f231208f048495b56c015cc3c0b88ffd31db8a8c1b98789447bb118cf741d9ba069a2de5002a7cbc23bdef2359bb7c3107fb07dbf4f4a02a512d16a11952093505f0422f08f915ce6b3f733b63d1e6bcd641e706de40e33612556baf8dc961e34e534c1fe46b9259b413001ddfc10691af9a7d03a345c2b789d8334eba42caafbe44b23ba225d86b8d9ac2e0d1a0eab9792ec7e5d323ccad1e279f02d0989fa43bd153c5e1c87d4e32632cee3eaab279e647a597cecfe7aa003408db0a82e2eefc29de00bed0735800b2af1d256675643ba9e97117a419907e6be616156cc2ca968ece02a56f424669d4c2cfb7feed06baf089491af1d22ad10cdf043426f72ee4416ef2478f36d2a160b061766dcf215244abd4333dff71620b2e6d5586bd103a24cae40ac75d63ac7fee551f382e450bb4fdfaa552e572b7a960f363740550675133b0c0c2ddc6662454e50e180e7242fef9120f7952f84b3cc56c61202b629f755aa42a3f267ff3870f0d5873433003f00d1197cec6ce445bea5647b83cc4cc265de757625da45b1984b3baa2ba6d6af3acbd75953f780aed9fcf9f7fa2de934bac4828ce477d01296985faeafe026d3968157fd97b286e7263815e2ccaa2ffc8fa67347a1b053e9d1493d0ae7d7af1ca0cd4c8822bf7384b10f8d7be25b96c5b4c7c6a2d625b49de3f8df16a05b1303afc44a312f585f0754299700bbf5bdebd4f8257af8d537c1e028349b952b88cfe13d0f8c1b852f5fdd9bdb3ad69476743a3b0deb4af8079a59a118bb1f5df974ff76a508ad7fe6327c93aac86d752592d619ec8a5c9918adc37981dab7acab530864e2d08900ac3c58f4f2986c0276239de6fd986c1eacf387d69bdbc00262804ac39c77e0df718afba7c16455b277ece3f0e075327bf27018cf5cba26d256dae5bba93e1960f627e8d6d4cb2c8daef981b64f9e08fa9470b0762e79d28e1781d0ac720a67d242bc6a95b9b5b071bf719416930f6aca0577ee0a35e237fe90f14cd07239afae30ad5acca058559fddbade719dec57558664524ac92836b567a906e0fc36deec408abeab3cafcacb026e78d426a0971e3518c6b68c51a93e01bc208dd003865ba172b26fc14880d2995bdc487ff69c3b2bc183b6c924b6b68d51621fb93eebc37779d155a21883bb73f69c7fc08e757ade6b8f26d9c192ff32ec3357788bc3deacfafb581c5945b5bd76a5a2af3c09bdcb67400bb762d48fb7d4000bea0394b7b27dc00f2276fc1f8c81802e98cb3a5c5ad22c39ecfed73457822a4936d6116b6b1687ab3e9420517d1a50a9761e7cfabc968f03550a25068520feecbb4b78ad22c86d5bc364d41c77223f132b776c6be3843f57711b22d40a66d8206d750e162ed5c2619dddcff255454b5581e5bc4cb88770c4660ee4ba29f299c78dddd934c6ad264032bc8285fe966b5f23d7459b490cca2e734445c48d13381ecb6e311cf4df1725eec44859bb5a16de982a6c5b0199aae4efe8e236ed59dce83ee806c13710e4f8c81701de603dcdb716b61033b2c51a6b39ad60c975fffcc3c84de55cb25458c47de33092838074f7d5b068e9985ec812f7f3d3a53af2be16ad018a15c0589d62ec16efa281f04ff495963748ae4fb22b6c905b9ff9cedff5334b888f574942f63d4294c8a1d8c723c46877a774702f0a24b924eb98dafb7c8ef0504494aca0fb42534f12626a54f1d3b73c4fd393ac9d33a32be8d9994cab6474a1de8fbe3ee48909c42c2b969faefcade96d32a4942ac8426db63780535259eb3bb492e6480738b425fc9552869cfa8daa7a5fd11486ad406c0008bd184812722d4c9d8d66999215303c63b44b243efc6ca60fb6a095d8a2d452338a3fbddb522bf744f7330c5d39b8b0d6bb45e9dd18ef8bbc798f682dd5fa35d2f627b638d9c499c984e8a554f8de33fa50c8e4c675548959a7da8c61d996b9177f3b50a4f7132058e04cefcd852ab320d81f23cfbbae2350c738c7dae6cb16498b656480952d987b6c3a308ae8a19f060a6c7217e4c34abbb057fe46ec674e9fe4bed809c3d2e565af203466a5ffb819efcc78ca322b23e15dcb2dbf6ccffbf38e671675c93d46bf1496666ed8489b78cdf531fb9f5e08ff1baf87d7c7db6968c1b2021cc12ad87ad970a990bd33394bddc4aa6282bf7a171fe270b6ffd5e84207db8843e6d57cb05be5d8fd9e8b9cec8fc4847076da9a98aa352b15e79bd361ab59a5149b39709d60a169526463d0feefc8e24bdbf78dd6968fb10eee68d593ab496997f6704eb0bd87b5944ea30fcad7ddbd6cd3342a61fb0881a74690d86f47928dfaeab73ad75171d8818464911700055077e96e013593bea33a353ea968f22a78aa4a3fa6e9bece6b0e409b95a7472cf00cc810d7d10ec91a9d608c1e141bb9d88ed9d683ec80cb4ec2666ac891f21124fdbbff2a1fc0ca2c758527d35e78fb8a78c1e56ae85619f7cea1d64d59ae7b85b4de98acd9677b2ab06c765e2c37655894161b1f4b6981fe9bbb7b58cca67f38feb85b07a948ea2ec2d6cc08c8e1a1c54762d6178221d19e9a5542ecdabf1acf04dcdea127d32557aa8f942270031a82aa85f458fc46774eeddb3744bc5662af0ba4ef4eb7fa75c56cefd10142fad5a2584e3ae604d4dc9e6c1854eb110904db733adac9548eeea7565998cafdf6f40f73195dec9d6c13e738fdc2d9b1db6c070c50391ae33a6dfa2f6b84964304d1f2502b5a60140bd080c9ca2b9fc426e9412aab54ed2719abfcc2b64067f8081a6f019f1fd50594223fe004f81f3cb9654d857366cd87e8f5752ab51ea24718d20d37a68b3f054cde86bc13862f7de45ca8d8951e40591b20619c6ee8e84f3c04107fc3ce24ce377c67458dd7f19b4dfe0a77c39670242b0a7f9ad7770b7f727c63e3fe6abd1217c8d6b6aea531de3de07f4129a9fdf2166a93444a49008720277c96d4fc9807c9e1042a495df953473dc29b78acc3b3d7945cc7d3a760f2e179e8cbcfbfafd73b6963aa427fd3c98d6e988a045eb39ebf21f8ef37090a589541edc130a3ff9ea19d8f3e52be623d9f1bac9f73d2c7e207f7a21d03292664b896eaf3da393cf2a920b9b28f49108d3dfe8362eb040228a9975eed10d89729fdea4baaae714081e708420924baeacab395960a12894583ca512e9fff5c253d8077dbb0640be2ca16290318adfec4d944c27ced846f17c8c7ae5ca17c7d8341cc20adeaf573d493dfdc5520851ab7e7534da501e88ea6e325c569a8dca3e76c8226bc9ba794f1690d7b0da93b6e42be9454c942871ecd31c91836e8586c9566d8cf0ed13322713ee462c8ef6517d06da828f04204bcfa7976fe9da1af742448b5a4b2fbcfc6d87d09397c56dba8592ebe5a887aa64391ea59eee2d810bbfc74833d141870d864b2d0286be0f9a5d75f129f842ce0c5c3c1485c7df32e2d8bcbe92aa91a28cc187be42fcd077406fe6582d59c9d474b9fd701cf3e4e778c46fca3b8ed3ff7caeff02f44b0554db462921361c20e8f0f2746c895454b883e32ceda8f889f84fd03956f40211172b6f58ceec6bf65553a24b53a0fe3bd194cea4803b26175fd65a9b9448eabbf76a551145348790b92b0608c190a21ea1cf53eab13329c40924f5d6ebbf10ae65bd88af12c18f355b55fbdaaa38e92f4ff045a7f61462349c7863d438531c3bb037fd3645e3c412322d12870678f5f1c6f1a6a26a98d69fbd1045c2a9a9c687c0d226c5039a091203a6597692476d5c4cac7e01d5cc93b0e4b551dbdd04ab95187fe9bea3590e00179ac9267d995565614cb87d3fdb3a5d596e2e45a4be9fc986d36d5f107dde3367993f40891a1f6d0988439f9946e9f0894ea3254060897ef0e245440e21cb6c69f01b6b314741e2af5c70fc336c570cae8ff59d5e58e855d5c6a5f33d5fe1dd54b53e886218ef53a5fac0526c53d9f78b8d9dc5297559f83807617552968769d73efb1e93a346e04affe10522d5d9e7c187674541234502452dcf7a9127f5e5eedd2e81bc226911254e3056650cf0a806132eef0ceaaf7d31b6b8f42375a437fbd3b58415bbb268f5ba9bd070b7a369859fac47172e39d23ff55e753f7e8576bf1de78acbf697db55ca89a50fed61c98bba5e403b12fe5013a8d041890f5bc467297e569e0d431d4e5e2b0d70134b1e10d90515403a3495b346c8fd04f4a907ac813c2573ecb50a805ab3e5abebfc5f4514c2d50297913d3bd2a3b341232a1790878d613efe49c2956d2f9d0e62903808de9ea385dd1c2a2cd9044abcd8c50d7900b6a46a846da44c5ab05e4c50ef07d73d24a30feb4478c9bc76b2f7905d339e75b3dfa8e5d8635fb99104b518f696a5bef6d579a01a8df87db3cfeda17bebac375b787fc0790cd92bff7bf9cc0bae1b8a83336c30a932024f2f280e3716adcdd60509625a10863cf4f6cd7514d661b5035ac88de766820f554d6bb9fe4192ef83eeeb5b4cfff1662744ed2c99ad455ebf9f7d396451bc9d6c9f8f44ef1bc31bb9cd340f7fc06bdeb77d6bc4b5750e1e1096e1b933e95a96dbf7bd16430ba5162f621a517e9c4e1d2bf3964aa1159c8899612c38f7196e828cc9b9f1300429c19045a4611591a42502826f3878aa592dcff5fb84c4f1170441347210548d7bbe156f878cefae8e7fa70a86c03465c2ef5e3f8310daaa4d64418f83bbddb135db86b75d597ca4441ac9609d8461fe33e9a7daaef160e5e03a5a55f67af57fd7eb60b61e8dd262190aab7f926bc1e79c327514397dc2b8cd46d82a398a6139dba203e962d2c61327fb45c5d15bd77440ac2f1f507dc3dd4ecbe3a6131bcfed725192f05446d285f8e6415648bf25365024735f200350b512cec15b6c8926172c67d8e4362cba8218d17de34655f9c4c4e59d26de800d46cd0cffddcd2f30d58204e3c12673a4f473e95b30407c80b2b0e5126d720a7fb7f270e2d32d9bfc3a1e412160222b6d86a020eb0fd51b56dacfec889d5784eeaf6d1cf88def626952adb5f7f9ec97cb08a2b01eb6cbccb02e2932e19a64a0233ac91b082774d48281955f78a16b85d02129870a78787b2583eac79c8bd9909777173399d4e59cb987a0da38c50f3a8917644680333adebc97b21c7347069903945e0808d8ead4bef899df3e57cd1f7be6f6c2618bcd3863784d901e524f2bfd73af969d5a41b02d7287eaa4cfedce58d53a6cfd6963564d964dad6da225642d368b7cb8ae45df6baa5ec0fabaec48ccc0025a2385c7a83fa39f394144acdf87c2e1c998f8b43bc2264d4f9bcd1d6cf83d37fb507a7c034754d2a8fe420afcb80d4534187d9dab76931248ba2c0da13c195eaee712468b6dec977706d7cc0fabc37dae60a3c095b8ee64c046c4ec3af0f79b66d3703a8177cfe584fe89e9609643cbd2d35ce26622a336c15a098ec4880f7082edeba63a30e67216a3747f196e1a4913aa8cc032d75ffdb7b69854d04371994fa96157bffe746f466a3f70588cd3211457d1686f4de0660c5cfad82c7a230babd24a99dc3868ffa1473c24a497cdcb9d186a7ce9b4e68452810f1ae2cf48aad60063bfc95ed02046b9996594fe5b30e01a1ff07daadab8b55ec5e26c75829c422883c72588342bb4f8fe9a9ccaa272dcd76beb79d747fd5fd67c6c963ef598e7da5dc61797af11d75f26ac1e33ebec69e0f8a5fe48e7500c0598c96e4cf24e8857f5c1dcafb3f0a22067556022c23a2366e69c3fadd289e8289c7ae003a5c8dd7e6c001c48eebc1aefaac3ecc9d5a91db65bac1c039dfb825c8d61b8ec14660f538526181989c0de1c076539561e7983170257889390ae613d2eda4ac57cf4f737a67accc237d57067222f63707a3c5771a8d68a19f06f554ed5348c7959c83917bf8729cbd272ba1cfda605deb81375e68e5c1ed213a71dd01095a79734ff618a0aa3dc9d59daa52e29c5ed44820b182238ccb1b014cd8e2c717d4200346f4773f1cca3a2136d4301c30e6c36b162bf32bd1f6de350cf1d368eed9c1108c6c497bcb6e02f7d92b07b6f236c55cc21a93db89da6d725b37fd05ac03dca91b5c499ed731243d47a9534c8897dd836798b042133ba391469d8d140d2104ffa7358b6d30f540ef2d865d6e06eca750e4e20d29b00a52aa7a36ffeffd7d6d66b5f45dd509f72307cacba41e017648a2b6df646e12571a21a6a441bb3811964af55e407d8e6547e5d482e2d792dd3bf38d1598619e3a8a6a37df48436d1ccf93c70678028fa23ba0dff7d71a08e1ccfd9063acdb6d151876f35da9bbf7daecd6750ee45fb65260c7d406575245832b4c4064bdae2671a4e5e4939255c340a92978f111ee30bcbffec579adbae2710e19203af7462e3e2c07aee7245503c3519260f69796b0991a386a293fbf8162f11a6dd2303d592a0de9a0439d922851b9d8871fd184f141d97a8dabb563dd42ecd8f705163a75c859ec9b35c3017b928734e779197857138c042871f6d0da95af2c39ca79003dc11e35bde7143cc0638619f1141c7631686879759b04e69b9ca9038a98f680b5f363a111f97622a218c97ed477c67b7507c000a8f9fe9f9c8cdb185032ccb0c29357489d2f10f3f118d292ed6e26e74ad57352f869267176affef648814a66f8e65ab9819de6416719bf54dea553028e0b0772aef6f04b61617ed8753fc009857db07e5e5f0b8e5be7b27cf6e20bdcf75b98b6d81edd63cccd57db6b42b40a874c87088951b71d80e9a3bc26c08ac377a12ab0c0e912e532e3dcb407a8fabe965e85476ec285847eef4ed71726fa0ee3634277dc9767880b6db1173097c33b59e33e8cf4b301405c18e213f21e407cc9ccc5169a84686560dc4e3d00282a0066ba9793e646ce1a1d622577aa0f470f4e0290f9b5dd9c23036f7945037a9253dc3eeb4870289a65c1141889c4b75cfa962d281b8c44ba87cec4bf3c79e3fd10456fe770432a23c2a7e419384065172453eb7e96f9aa607e26b2d4b28be0b356cd9ba4168ddc36be86bb31a20fbcd177116768d38a276f2386628ee12132ab7b99b6417be5d9e5718e866ac359a9a89b8c9c881b32afda0d5c8d18910fec43414c5d03ea14e51170cc7df830b8c6d07d670e07c5060adb595c5ab935fdcc834dde8605bfe7718253a6445b1b0a18b31b987590fb353f2fe8ad2a730bd7e7c6d575a006cadadc0390e53070d8c4808f342936db9343279f58d62a412f15f7da7f82f650ecefdb6830cdaa5aaf10aee7aa7c5babdaffec69926baa873cc949ee84a9c6471fc60afd1d19ed8d6a5de3e9b2b7166bc6407d6cf05d4ece92d2eff3c1b8e60cdac7f64840f2293222309b6b12bc101e03d871d6621843dec29f588dcfe67bd0bd1431f31efe0cd513335b52cc7e8346de0baf496b002482600bcc14fd10bb370a946b95aa81fc8d294c86ff4e33303e5f69f4f8c895f573fe114f2ce5d04607ccbf263bb569854e469c40865fcb9cc7353a09da7f41e17fe8d4f6d6605269840baee65d60dd442ebcec44a6babe93e476ce29956c607c93560dd6525cb0af8743ae2e25af40c8eda4376d80309fa7d0e63d9245ff6390cd567d5e963c9ecb4a929b9c0757e41cd17d031ad51b7dea9b22912b1730b98478bf4533a7f6284a75c94023cf734059ea75913030d9cd010d8edbf2a7ef002ad0bd695fa272170e0733512d87845e1080b2169c6b7f1c86a8a1340360c34af0997ed7059694628e25a3c6a5847190dcb2cc3cea6fc983fd164b2d052f8108d85d43a94f44839c9006ab3b0785034da5da358ede957b71fcf8d75dab842bc23e1ac29a653529c049fdc29324434ec3f536cb01147be230b740b2c22bfa95f6e883ef0ed64d50b4586c2b28574cba0b62fd617c54a6a577be700759930d445dea65b80bb2dda1b1ad23c37ed313a2f367b9d7feae3cfd9058c8c5c0303a4af6eadfa48722770bad7fad832073143d832dd5ae04495daecb7268fd1c1264818c512b5bbb924f0bfe28d04612193dfb71bb555d43974295279a3bdecbee9e7746ef70dddfa75f73a4e29522c75bfaa75e35581b6ef3d419fd211c78b1d18a4237506ccf97f52c55afbc86cdb55c6d184f4e3bce0d797a3508a878fdde4dea8648ba750da55e1d14293049abcc7ce67c0865e96bd7d712afc64d130030ffe7108c9db250f59aedd431424092b60385beed4cf337781631107b905930ae3880092e0a988ec94f2496e551d5a37d51d95bd073d8bf64a1b42fa05db83de2fae084ee870dcb88186c6dd2b14062925f8e820ac97f460c85ed4fad12b18b4fa20ffc9873321417c2f8c99f954138b9fb663b6f7cd0175c230327d8ac3388dd90044bd6b67e1288be70b87278463e29cfa2634ea7b252a81406d05726ae52d43a65ca57b83e4980db9fc6db9deb04c705eea91eab3609fde42587ba2fce6732ddf80d775d07a56f4d537fb207facfbdb9c933ae796ab508522cd5f7414a1199deb27c6a52e249c2d1891ea309243f5eaa45eca78b647e8a24c5e6e929ad879cf8ccb3d496f6aa14904735c80f5e9eb2e299e335c1e0a4357890a3a7e493f1898770cddb48d376aa526357b87323ba2a06f7f68829eca5a5a6be606597ed8ec749a42a93614c9a17516a3344e7c1ef388d091261e7e569b8d9813c826869b42568304f6048128c3a2204b70424c16cda5e1559f09b74bea5aae18e75c6f7771da0848d09f2e321c4d275ab39a49b90df4af3251a6a3ecbd7c3ded84d3a3e13eb6da4f2c7b1fae19d143d15baecc68e44a91e60c0a28478d26dd73cd1789021c7def21a050553b7c4b2b8f9c71f0b235450224f880395b76fe64244e588ffcfe40ef221f2825f8cbf16c1e15c8ff92046a71ecd4ab0636746584df639d453f10611474f16fb4a8bfc3149d6b3dbef6683261fb7e2c292a9afa4b83aefec64932d1e0156e4b191934534c1007fda5e08f41e09e5709301dd08725d0a3fb6480b5df160b1e831d257009d4c9997afcb5c59d0d65364192e716a2ab9132aabc7d6a07395c7c3500eb3a5079b6418eb7d56e6bf2143bf73bc5355c8d6bcc5f85dd0788aca00b00645083bdd10ad33eb9878daa9d353c5b1438808d6e1f5b9185d43d7cf0fac59f1a0d40be3b1fcfd8af8c60beb53e59b001f486b0e8a1198e8a067d83e0c8bf750c4d48418b2ada259abfbc951cd503b2451be7145242d60d1c898a6d27a1780f9cdd4ced8499c7cc586d0f6c9439ef5396f2c7fcda88f2518c9a7376bff9e86e23dfe68321b446c08e2d419459ae58fc2f4c906d9892916112a28674c88b772737670279b99a9dbdc044e3b551f115bc667eb6df9f3ab68f5cc8e6fa3490effbbbbec90e868fb7e328b6ee4129dae6dbae09936e6826a06abd413166497bf0f15708fa489dd816bb4a3c2bb4f2c655b4141ece5b9268127cbb97907af90f43ca3955aba68586ef428f7105810d63f3b4684c3121bb88713d9dc70bedea93f7d7c586ce3f670de59e6edab0c6ceb17cf4c49eb5d17f4b34841e56fc01d354b6677c601eeaa5c5f4c1c12c18b092d00be0a1aadc802d0a1ddc7cdf3718cafb084d2c1a275160b12ef04fd385fa83c3f3c9ce423c294dd6ef60945bb25708a381b3f8b501d0bdc6bbd8b1414eb9b6c3fc80ed4bec33deb37e8abcd0f67c7e85866a71e7c18c8a88b7ecee5e43f95d2b60cba67f84ed83fb5bb441ce3735ec26e7880f0284efcca6a64a5d362bf6ca668ca0853d47878eb1e8017895812221f6ec0f0cfb20a01aea604254975e4561f543d26774c92c8e80424dd7723c8a1c27d99384971a6a24a6d1b06167412321be1e7d331228f66e82a3da3d26fb96f210fc5c5ae5a8c38b9fe6eec27eac8ea339aa9f4a02b7e8e2d738be0d97e16eea3908662878d28cc40ba38302a5ac039b31c1774d8ef4d5b59f5719eda4626d178b53941dc6c81ed20b421d8bda52b57d647d87675d567f80b92692c3cc11ec33a3f667d0e341141c8d3dfe8881a6952393bd50d04405b758d9953614105d549c1ba660118feed41aad84b90379eccbe4d827b0f50463f1511cb339ba1838eef5191f869bdc42aed2d72264942f6cde321764f7e76802d84059bd0432834afc6f1ad7878355540dea1582c8dcf4d33bd285d59bcfad43a0717175778b813d8bc4cbeb4cb3cf40a0df9f64806ec0836d899083a5fdbb05c8dd9736017c93c7af85e48493e4a6cd0922225fbde28b8e5d25893488063fdc0de8c043016976b4bb9d92901dd90e35becb8559739e2bd31eb12d005b8531b383f6fa040a648b03a51cb6cfd79900bd3245e077c5d7ed9da0bd6ae8b8487d91bf00416d00f09e353d06c6f02b84b0c618c373f725f90652e19aa20a5412c0ce7ec45bdf94b8d145b30438424b27160e80c8530b454411a82e30ce7ad06428d01cf52b1e3f121095a2147536a135feaf796a1f2ccfb2e9ad028960734d9536d33482829814075295d45fce8db88389f841e7e9036f5e0c4cbc1ce6568dad4fc65a9e84d443a2d568feb8f8fd575154fe6dd4fddccc2668dd355b6b3a0eb70dcd67c86d5d263eaf479e7d35108d0e533b09a89aaf7da176e087c98579aa181e820e17fdb281889fad1cf7179b115d2d4a96fd2e811652a60a3ec685380735559699e49b3beb4fa799be9058f97ee8ca13f855ea478bfa989d9aaf29c55a9a663f8298d888b2577f8cd52dfcd93f1fa7df344d461101980405c35342ca815192016ad454d016a37ad551fc9f23616e2030d407453a6ba8fecd2c83cc21daa0593c8dc831a105b72633931569a0c9160094e7b0ffc596b4e39975f73e78ecb8483ebcfda574dcf3572d3d9fff340224eb3d86c6ed6b1d9b4938c44609708206d729217aa56b2d4b636acf193d83b75dd77348f216c3b0465d9f5e40c97fa1d020c732156906dfd65edda0a50f71f817a92f57a661453bfc12c4dea1251cb6556b5a8e2939d94c0a7831117c7bb76d84b278683b02b6fc6bc428408f26950bd7182ffa3a54b07bdcb23a7b1c0bea4c552bd3c32b34285273b99f7dee1af6a24cf688e39f6b43827aac2609c74b5c4cca365b9e016ffb21d276f1ad145f3e1d4f6db13294915145742ce71855ae91f4c3dec19f29964fe50c800ec6ca7c7aabd0dcccf491617c2baaf6edb6449b9f78b8dd3b335d45278a3bcfcac66b6dd9f18cd530fe391907fd5bd89e65ff82e484c4a6807bbca53225bac87207431f7cdb6f33bdc224db353a9cea03fac86418c5b6f29ce124b81d4a7915a32e405d8f673f99bbe4b6ecb50320ff43219c5140bf8b56f44441c90014b9d61551d247af401a97f5199ce6dc336f8d99219eb12c49fca2873fdc616d4d765f4eb14b7ad04fef3366edc55bf8a6f569081729976bfd7dab9b65875347e7fae71e7aa9aba0959d654cbeaaac3b638d305ba50475b24be8cd1ab25816abc25b1f403d96a87a197403e407aec8c72af16dff5534fb9962bd754197b09ed49d3ed55a08088424594c0765521f033bca486a4304e86658c05c7cff0cdaf3b00987278a49f9122ef755354467b7d812caca678d35de22fbd1d6b05ec2bc724f4dc5de2e2cd291ac213245d1a7c9bce7deaa352b4c6f5e0a92f3502e81a928569d65f39dc32273121fba09cc618d0517849d2f2370c7ffd1921d7bce4fedd9f24f175c9bff319427190d91073623fe458161fd0e7449bdaee012808c80c000ed8a76cc3676d93ea20e98bdba97679f40976676aaf676498f3a8baa106cae070ad4ac71748bc8873fa1b6362dfaec8561fa8a9370db4ad1df246f2051c5abafbe548d719483ad6069d378d12cd31f330eec4664e813f482338aa8d0bc79b9f28ea5b7507d565175ea6890322f41af75aad347a8cb34cd2ec6b8f0089d9353eaa990cd494300fa9951df1d39c54a0b62b66ab56d7cdc7dbb40bb3baf8976828cb10cd1778ebdba901c1b82845c133949aa1668926db711d45217f14da292befe48191f5cf2e22fa823f325434e6919ac04207c6ba8b1ddbc1f919dbef72f7c22ded1cfac54b9fb1065c7b008356fe136866862dc04a31b16d56c2ab39a590da28f269f57a7144823a2fa2ca951d73edf44f99ff27df88af2e710cd2f7b2441db30a64302e6a60dc0bab2341909f25677650afc9e31f9291c4ceeb604f9b024cf80b42193dd150fb08f62a830f1d254586b54ebb86a0b2c2e899a0526a120128ceef4cd4869bc12351d43970562384e37771f57ed4ebaf288e846b108b838d1881c1f8ac06b61b02c239c216c986e7e0c989013344e6d52337bce2bb7208643568caa63d941414c26bf36313e690768ed8ad9f266291f111b223f2f069a7d6abcac492d041b1b4ffa3c63fbcd2d03482a086b1f4cbee1d5808660e1a8f529702f4876ebb4468eebb638dc2597ff9e0f7a3a19ba86f6bc646b80ae79296972945eb2f9ea1939f31f2294bfe2bbe33d14868da658d32b2fc1acac888f536a56b5ff10b6feab785dadb00e80a7171dd4743f995ce7376a8974964f62d8b1cde61cf518d39dfdd6a05b2d7bd3f63f8e8f0d84c4f8dd36fd13a4cfbe214c348fb6437fd67318002086c103a190c58be5837a3e4f35245f8f778fca4c5e717146ecbacc94ed6d18cdf65823023ca0ad3f2c47f9059dc41aa051daa32a106116176c3beb1bc04bdf0a0615d6b43a9a22ec92fb6e60fec38061f7eedd0efdbeaa481597c3abad87b7122f64eaf1b86b26c341f81771e379f86fb8db5ed38c6e558a27fcd779b25d4ec02a342eddbff6ab9b8b734a231c2dac890f1490a38a25668496d0c8315c3546f9d1d0d3c2e86cf652680b646cd8d2a34141825382bbafc8b6718ed27208dc56a413c981ac2f04b44508b0a4f97b86d501a4aaeb41626431aef5d3188e6906418cb31e51ac6865d7c6a761818788f690c117fe4118d63b4904263a4c18676e8d06e7c8512c9b13c346a50a3e97a05385872bd4969e2c6cf8fdc12244241a990b25d4bf061aa92cb40d72308c3e9d3efaa8d5d92efdb1aef9d772184c8600ee0b1bdec4e421ef7365dd7e04debd78ecf2a3c0ecc256769854d040e7a5d33054845fb328703fe452c31528c5e4cb32c8b9ea9a2af6535502e1b2672fc3c7b6d59776a7cc07ba0f443595119c77e292f879e72fafd1822d6bea1accfd5af85e5469dbea383775b2f2c3caec823ad30453f2211a2f0612f6bc667b2306ccf1bd19f5a54faa8be657bac940caa94c2b264d27550530b5daf8fc87bb1b45d8f8fc36275279af15580941061ee67a07c013b37d6ee01f0f654679878b3fa8bdcecc08e2b22796b97aaa68d1e591b8ddcf3a410414f3d5940268982cab1f37c4f677b6bd0eaabbf35a2ab4206d52b54d7f9c32b6bb472288b090c1ba246acdc0df301a107494e2372b3c9fc0d2ea48ef43640177bc81768267fe1e62f5a9e60cadbbcc32e3b591bdb7771c8790e253661a669ac1afbea10b3b3d85228fba1b29be0010096e9af3f4a2b0a57b1650365fdccac061e21a39364706b1046cd105f8621a41a327df293060bdbdc56b3a5423bb2e0369bf61a642a8bd2493b45b9c27ae625505eb98675e97e8fb0bb894f1dd2ed445f39e274e27e8f601d39e60c9c6db59ec7b10822560f561b9fb21d504ecef5a01f3ebb2f3e1dbd3cc9b347fdf5f0f4e1ce710d372357bca6958b5ddf34d90c509f63301859c6d0f01d0d50e46c83d6d9f53f522cd6a8f2cd04354b2db71ffac4d253079f44c23a037e05f2dad963f5e91d5c49a1acb25cbfb3bd99511ab7a2b520efb93495196e4e2492acf1db30046a1db7cd9181814784a8bd18e10788694b57e079359097313609831883d92a529949d82e500a6d729018f83cc7178f567472099381b0242946b406e9b6cdffe2d76bb7f0ead0acf75856986a0d10b69a6f64605dde5cdd16126e023742d7539cc298c12bda09334e2c95bf061baf35eae18fe38a5a9459e307f5a62aec9faf1be8e3a98bfd2d9e358c0f4b58969f268ae70a7d7173aa7e6448cdc585fef495ddb76e6d86c95abd894e3985849b1e57f29dccd6945e67d8bf669903ab598ed522bafd335c1e107ad7ad6c67a7051f2d0266972a0d3f3ab1ce6bbe87da2b8b3e211312f71d820cf00b3894b22a3196396b48d6e0956e296d475ee5ca567ef48e52cac06e485801947bfb4c3b6733c6fec73fc6f76967e9288cfcddf3e5015ea101db9a56471533855c3d6ea50b855896a78741856c7687cc5b675c1dc5b770de67a8a2e8526e124bb4f5979f2536f4a52d5477868556de6d18cabea6162c382fd2efafd945ee9332515e556a8a3e2d0f153e33cd10372e7d9c863790d818304b146d040b7fcfe86e23f5fddaf538a3b78fafd132f22feb6bb866ce14b42f386bd30ed32098e2270a4e0169d46bcf0e98d0db83d4ee3201d014143fd9f7d86d94305c7bd272e5cee5fb9f3d13d65f9261ba2948811ebb6ab20786c2c09ff2a733406db6a9e7c8c96beffdf4ba3a15d1e81db6dc21de8edd70d839f1aae91488203405a6b2eb7bd6e76c92ff0addf6de706b2c1be7115c6df2eecaeb2ede9c8cf8ef2e2f03a63bef864a9d6fec7071c51be99ce77d96dfba4b8800438d2d2c5641ef06eaeca0f73a63b2e54ee02614f74fe9791f34a935fdf4f2ff012e2cb5879c701bbf9f4dfef6c32b39287de38be833039aeb5db2fe42c9413a7d5d14f4a42a2fd77a1c9c9893cb02a0b509aed14609521718edeec8ca91f3f19ff65a54348e3e6c27c1a3b5a97d8d822094d02835b5a86871da297a634e9cf52b6490366cf80586f599f55728fc68cac6149efe8c260240e82fa5988aa01d297e255741d30eabba897aaeed69351b27156d3e072d63064eaaa8ac9ffcecc4506cc7d81b4d1e83fa2ce796ed2e59641105fc7ebd9bffba71d64e1a0ad9348604be6926f4575fa05b810bfc02479a78414a88e853767009209eb216192b0eee029648a4171bc5fc2922de0cd9eed7424ada9d8a021c64dfe2fdf6553d847f7e835428434293b7687ed971c9fd7e25e32b570b37fa46a561fac0886f8b8c997a9a4e276014df0aec3fbf93159e57be68fc125ea3b5fe836b34a1a34fc4f79a30820e9e17208a9049f9cbc99f2c895d06e94bbf30d3ea4e33b473880ba2da0a79b3459852ca3583d6861ae7c6ed00ad6808ca7ce4397787dd2e69a8a0a7be1e0abb64b5231a27fa0350b2d3287b3ca789f3afb965f0bd35db5bb3718f08d7b8cb5fc279e46462f89e083d7d2e5d72ec8e5579a8286da8fecc69aa6b4ba88dc8dbf2c13ed381e3e3accfe5e61702b1edffb3ffd69895afbb497972567c1a6b025b1f779e6fd7c57536215b373bc82da8277fc7d99ec5b0e6062587a91a1f6ce6d7de5e0be0d35cafa9420883401ecccf067df97680cb14156a265528cbdae37a7a153f49327184986d89f3560f0e0ec0999bac601bd97c097f2214bea96d4c7f6e9d49355a0c924f121a521d530f663d99c7c6c56b4f6157f0177040ad914e6cba26964dc0cfb33e23bc86e448b1327b8f02f56d9097acb78476b57f61f86a71b3d9f7f845f10cec260a18d502731230221ffb776660f5a4b71002b60729e8a79ee1243034810ab190ccd9ff5ee58115bd08b37da20991ff52ec3722f1c689742dc164fb8ed608702fb82d8996d2852beb614df1dd5bb3cdccb9aa500ca513cf0c1e8c22a218a91097e2558b6b8a449e5aef7a3c07bd36f4380a2709442f8fa7d36d91ed788eb531689218c42ab731e574a23afaab7f36d0c1d7173a1b7f3e18472082eeffae11a93e84527015ba764b7e6aaf04687012eefd3046fb13ba616a40832bed81c518811139ea2d02ee05b011be2bb5186f21740ac0cebbab40b7bc2e5fd1c24c0d8052e5d65bff486991590e2bd0d7bffa8c5c858d05edba9ec50eb532b67e549018789bef70bb476e6980154fe0a48dd344f9286a8c359c81172a0d12ffbc5658ddb02b20e67339e2cf8047d945a8dd941bda63e6dfdd87c0672e4b4ce8066d462786c90274219700f366375d70f2fd41c7aa27f915c3bd89b7d823cb36828c0837bf1fb45eb6371e52bc42b09b0762f0c6f4e5ab30702330d651def44843a96991f3dcef7a31937054f4a6da81ece6a99399d8ec41aba48b9d1b457f44558333b3db6b9a3ce893952e55825c4f303d818e088502531df5f84dbdb5c672d36b57a7d5e263265ab2bcf5e8e035b96fbc19a15ccd99acc1aa97af6856fc274ff1099a5dc753e2de9b9dfb364221759b16525afeb15b51e4b3a55db45d6ce51f42b66f1f0e8a636aa23661519ab65824271d00264d9691716295432b40e65164bb077714fd32e5661a74b19af8b38606e24d2e071e98cd28895381edde23401078599b353c305cad54df4f1451b33d7c12f7e3bb65d8abeff553707955db2af00ff0427c1afe71878e0ad52e125dba4fe4236923af92bbc47723408f504bad8d92292721df2222525bed868d21eb59674e329e30d10a665bc955ee00fb451decb6dcd4874881ff7f18a20d0c004e3a5ef00679124a863e86076df6e30f92b0c2da29786d42771d7b9aef8213ad0ce9e8a73ce7757505fa3bb103fcf193689af796db579bd9bb25f40299616c926ec4e92bf5d78deb58fb89f07d2ba82b78bb92fc33535aa3ca78b98e6ec727057030c6471c981899b51cc868bc1e51ee5aab03e430ce1d1c525318f7c86ebf8a98e6015cec784b4dcedd5b76383ce00042b0c3b54e03789390117a4f18046d9eea23ab6305054a62d15c7c5edd636d4812ab458322bfb54efed6b7dbf2afb46b46b3a0e624e2e54f28682efe5f31522579d051086bde657b2d05614713e57b0d96426e725e6400c25602a5b2da49d78d91a46c46c6ea28569892b3982447fd14061891f8030976fb9cfdccbc415b2eefe2732b68942c565d730e749f313254d3fa578c52c7c9f15fc579a00fadbe08c33beb14fa68e892d6c5dcb8803557528151d5ee4f802f5759ab620d9753106d33567b6881783d1b4c6f3cceae644ee59a0bdb4c49d3593dca27d3d6c64f95b23c1509946700a5cc1473c32cd8419bca7441a0a7ef9b0372b130e072b3a938ba7ba61383e2b7907d4fa7e80ef6a01a25c24cb95b5e1f406bc3d15894c8e2200d1e773fac9d413a10347acde5eeb9b451ad5e9fd713cdc0c89d3ba1d5091a85deee2d3f528ecd1d3efffcd25988f83679791b7b4ba25d75cc3bbf949e2cbf9faf27c8130560e466d451b28a5abc592092b46e9aa222ce9eea0fab109bae7cd3684953966f833ba0d17cbebb77445aacf3575653702cb49fc2d7bf51c9d152f5f13af19393447db3579f37ea31b57f50d44d162f0be96bbcacfe8aab568651c4e8e9e82365ef6eb2501b0e6607b95d41105947b2ea3471ca4dc2e6f218b7c0950f53fcbe1b97c32f37930bcb5aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
