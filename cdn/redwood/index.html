<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2eb5f8894a40628125386187fd79059b327138abdf7b3cdfa63ac69317ffb9e53e63b952bbb375715e639a0e7b0efa77a83639ce6f672cd229879047bbfee35ec0d38b60b59027d234ee64503fe87586d33792a13e38086100d13a24cc7e3ebd06347c517790f6c133856c2eddc95842cc8e71f1dd43a0669828df252cace1d605103b37689c65316e5202e1bcaeb565a006857fa296ad58d11c293a518dff441782a5aafde7889c9a7e698ef4565eef2b67ece1887957c15cfa3a056d64cc079c9e925d4f281c3edee108ad674c7f52aaf522f81d3780d10be730cffdbe8f68cad7c78c66655cf60dcda68a90aec1073e51a6136f76e17208ae7bc7a6a7297fba60a536cf706b3e0eba42577a3076296ed42bb38a25c2bcd7987a47346b3e4a6a0a3faa52a872df4b380298d6e65189146d6674e6466ae57554055655e2219f383bf151340943417adaee002b1b8d2ed3b2e028ae7cb908a6613e589beeffa93e5132f08484eea690780aef0e841b83d727e8f81344b8567072c5a10213ac999f04b936b988c056aa08d676cc57bd45f4996c415ac38ab7fcfd5e879e1f6120d19d0d1b43e7ea84979ef67d9bc873049ad50c2f46334681d1017b4164ed29f9d753261bbab450ee11d7f514f7add3da32464e9e8bbaf83640753c20774c6927f2106e652b96e812ab20b66289f2f833bb54d445ac5a97936af86c6c03460e30c39cdd63ff87074e8f83ade201f3fa14140a58706ce100bfc3f159c2be71d0038b4e4303e075712176d53d71eb9f7e2262aa3fc8ff16339299e5391a30bfdf74fd2a9b31b9ba9afa9fdf0a5883c5166305a7b38d28b108880db42d8c62c26ad0c10a0892b94b04e3da76f31c7ac9cbeaded31b02ca88c42caddb70357394b878850ec4266b47b77cfef952b8b6ed4b3ba1df896afacd08a3dba9d3eae7261003ba02cba9583caef2d9712bc7ae4244d5b3fdf28dbf026c96c04719a1c9e2b56db52edbdc7033ae189bb712866b8e7f91178c1c26a6e821457d2a29a0d81933f70a96709b0d9a18ad09eae9557728085fb63c483c7815d2289d2a57617e7c30d535405fb906e263926d079ba8f2cd6b9f9330fa206e97e349b8b5cea607619018a43ee533513653426491f373adb41394516db6a444fded1cde7e2ef3bc9aeae650f8d398d7b4454a4389e4850e13de0e79110c52259e809040157c15f2c7ee9d8442ef0633b27420486b258a9de244d7752ae6cad0e3e460072d36d79608aab996bae2750a7d17df0e631d01da7080391696003f8d340a7084bb02ae5d0822ee1331856fbc603ac97f7f5c0e6b006794dfc04b72362ea60e82e69b4c8b2abc9b164f29932e83cd2b37631f68d8671822567bbbff42afac3c0445e5d05b36868241e9ec2542252dc1f713245f77ebda2125507181b0c1c3909d3edaec0e036aaffa5a512e6ed421ba7e339d8888396b30d74279342eb2d166563574e30da5ac177d6079ea5116ee8ae279caf984f9441ad377d7b8d1b11f7cfa241fb3b4589235ac8a8560f13d12489b2994c21c90ee2a16a5840566bf4a72611a26fe3131c15d2fcdfdfeebedcd4c3251942bb014047dfd296538f7d71fd8e4f6d6e38c7168c61cbf67eb0b5dbe4136478f318fdd96715ea258b10469b8c7fcb078338268004665ff4f7bc3a733b6adc537f4ef4de513c559c01547b2ae56d4b0c7d187080c02b969c9ba2f945bc707e3a66cb4da1618fbedf172d3be0cbe3b6d93f337cdc76242de3f4b869fa1e021b4d8e411e25073967db93ea276bce6a4553e8b6857b9a629b5a2226027a85b22b250e5348d89326446708c053e2824a5b68ecbc7aae92db02f82c5da3c94eaca08f9e73a249bde9fa5c38645d4908f39fc8d0e66b80f35da3c9fa51bae79fdc09326c43e35ddd588b5d27cc65dbfbfe34f8e2b26f83f6ec1d4f9fbb2aee664830d7a0a6be1bff39377ba23be8c5736e1e1b3d8bc0f5524e022b2b1f3a2598b02cd26d48989823705fe30ec2fbc3922ad2fac09dd70257919ba464d1a9ef0fe354375c737ee09b070a834889bf23ca45cdfc8a6144c59d921eebfcd1c1051ab0dfb53bf6341150a55dfd61a5153c9f23451cfbfa3f12b9f4bba37ee0b1dc66f02618743ec4fe376ec9c256d5d61c5214e58e6dcb562e7191c0f07f0337f2641e233e6dcb58e6ff16ca4ed30b419c23bcb790452434f5bd5dc0c628f481ea31940a6d47e85871fa3b2b773965ad2eb27a88322f1a5223d0ec406534b84930e4c8574d99b8b0b355efb58682517b71c2708734f395ef83e6b1a3ee2370b9a512e4180e4efe9f6803d49b5edfde97097d622088e784efe43a39c7375d3ed02484f2a7e2a7b818c4ff96816f6681e3286dec8f28f1a6644e000a4e69ae3d939e081068acab94cd0dba1be2d35a60db0191d6ca7f53eab0724457ace8f866f586b57cb4bd8fffb1834f5813904374aa99c42d9cf506bce40dbdd12091290268be08ce5dd26fb3b8760fccd9205fd122aa2e3c88fe6565e70267cc09b1ba81c05f300c7774b334686af7e1df41ee413adc27ecfff0f207d25de8900cd00bd227796448b862c2e8823942891ac3188534ab5fce21fb081a45a74e5e1b3314ad24145deda829fc1f13b5a8e8c9694fab6ff0d6d897d9ef5f8cb44edd751bbf5d9b8579bd4b6b30c776571e2e1e07545147e1ffa508530a24b3c02f240f361a7698f98cc9b0faf995479c40ac9a0ed8372bf43caa4e4622590cc2cd3a8ab0f4537c185c1969346b81233f6171677b407bbe2b9b12732b01641b05a94f122ba1ec063baa63c8d93f6537e3960e8d83e4650a2e5f83754f23b489afe219f90671baf6f382263dc48050963c75ca802fad89cc95269dfb7944f5b70296406e9e02bab781d7860c60f9c6766cfa1da25b4fbafdd5c51f5013722aed81f196a698a2dd67cfc3b30113c68cccaf0c0978d1ae6c046636f302921dd862a64d21859ba79e7ad776f11f6e827073469f5a5d6e621f8a68fcae83f59e7104cd059fc78928c6666323a86dc0783b22204aaddee06c5e5e3139cfbfc8406ed00ba46025f59682719367feb569edffbf5b9d21b91343df61bfc2e5362b35134d5df5557b12c2ca4e54426752e5e46ddbd1c3801906fcdf88323b56e91db1b9ecb195e2cc08f3c50a72e1a0f70f8d34dab1115ebc8988bb4d4eab6abdbb9219b98aca03d014db99a83364eea9d2050486b1982721e13d4a81d0c95dd051c4ff1cb8b8a0fba1fe99ce312b07657c583fb263c3921af7ea515013b8898b30263a7ee956abe5566f7a5a206d0963e22d3b978e9bd880c788e39cbcde2f2eab96b377af35c0d3cc5f601a86565bdca93ed029e802e5a11263780d79fb03631e3197e62ed4a0da8dbd7b94d0334df403597ca3b37f3b451263e83e67c7cd3802fa51745ade3a522e2b7534bf5408f60523d46fea0a7fcd89b2d388703f2279252d2a349f09510703c3c02f2994fd7bbd2c6d56b9b6cb572a03e087276a703857ca30ba04dda2993a78948fe1b9be72a2ad6d3fd94938f06bd0fb8d965764d31feda4136331b3dd0a17b3ab8362a5785467b5dca1bdbadd115c371e4623f7983a01f86c71b9777367ca7b3913696a3899900d58b30bcf4dd5bc4bdd804e466a546bbd0bab91ccaf862217cbe3de5c0d52968612997cf49afd349daa49706243eec7090749172c7404c7f6b07e1686867d946dbe49f9ee4d94d3edd918949c53616c89562b327e54882bbc5a402a349fcbfd5f14f400eb5dc5c1b458ff7caeb9c0f21768cc65238c4e058fb8db968a78cbc6509fc57464ffdd79a4bd1a8e078b459ba418caa1a3d99c073136661a2aaf5ad50d17639b175858d9a6e0c14eb5629ff67c0c0ede3771d1a7fd3ddc2b260163cde13da17d4058a4403acde75160dd4f7800b5c01f3bcbd2d89527c7e150e02730df385237a30a6515bf3af34467eef34d364e13f96ba7852b84f87d01db71dc72b14910ae880df14ff18df2285418089aba6a982d2272918c1591ea69d9d747a176d5e5a5c36f275a0ab73bf823229d3d622496733e2dd7d63a1d993fbcf34854876ea9661f7a680a8d628a803db8880d4388e1ae62411cde3e18cb452c9c5657b57801e3c57ccae9d437d4d015913be8e72e7a97f62e7b49563da3d669801937374a7b8d79eb34dccd2cb7e43e6db7beffe9286efad8117a41b73c202425a5e3e2bb0ef6b707009f3780cc28a8e0225353daefe47646944d115227e20b7d6942b99db4cca086cd73d5a3e6cc8081f97ae72820a9419cad3cfdd6b21332260744c8bc25aa3e51a9f0a084d0761285e8dd7dbb965efe9780086a26a59390f80491ac49adc00cd709079c07ee4fdcf311aa918bf22fd8e8a9f6aa69562b0eba153326fd50f7858942c1bf827981e0c729a5fb6f496efa725978ed365b21c9f7666735bc1403432753cc6074553d7b57f9bbca81ec52d5d25335c4adc567440d1b298bf10a1713fea7a1a1f2661d4e867b81a17e0a3aeab189ae70da48a6187bf1431ae4ced68149e2224de545b6a23e2f62c71fa4c2d9d0c914fda6e59ddea20de2fef0cc7fc9d7ccf4b012566c514810f39a3049871421baab0be27503145cd3c44f307f5ffc76985e6e38ea5096373d74091913ae8edb7f5b42fc21c5752ea44e9098924eca790a93d9b07ed519892e88d9b53b71e8f7aea7739ca689771cecbef348848c43d8924d849d6c6eb44fe880a15e3e211ecb56d4723d1d4b2289c5970ccec3d5a42a8d6f8a1b88c805fbf04457be9f8184debc45094ed64fcf966afd2199caa03475f7c9e51340a3e03e799c2e251caae9433f39030d1f7753cf92d810f14a2edb200150e2818285c9a87a40e493832e99bba67f1f71ab961087c64d30dfbb0707855aefa32d6b742874db59aaa1678830877306948f6cb6db9c39393572c8baab2119fc82d0d708ed5ca3437c561f5e6a004b539151f1785b8ef5117547bf962a3936ddfc48c0220962a17a0ce3182208efc1996a4cfa89683a1c94cc1f6aee105f5baf10b1db57e0c639ee97e74ca3fbb1636a8908216f6b58f9345357ae5bfe61b75fb88c131b099d3ed02eac36ccb7065968ac128b457003ca2ae34a59975ace798c29a067dd44b8512001852325f913ce7850ced1a1516880b510b7201f6bd8168f418382d0435cf4da9d5d0afac8dbb92f1402ba8a9acb474471dd055d70fb41f65fc1c07b6b319a2c6a9ece45ea36c51b848306adc2eddc455823c353b0c26517ea0b07d198c291cd75d4c0a2add31215193edd155162259bfa5f4084ce0abfbcd0e7597951f4e79fbba86d1a280f051ded3c77a9a34bd3d0a470843645e9f4dbacfa39d4293fd047bea5a53fac0923e6c204955c9f9d168520f8ac06e6e04bd9409c9143a5627e0c92a1b41dccd76a296b816a00103ab205b643a4bc2dad16b164c813478344e9ac1985bc3c5c289a3c4badb175e9d69e361d72dd3f35d1338688b2ade013e894c6779f3bb3a0e7ca52a66523f6b244fb78f8ad678943bc1eeea34e4c409b46916e46f8ab7986f285abd5e10ce27dfec150d2783fa25835f395e734b065d6076c386aa2149a6e04b8d5be690c61927a5defa2d3085fd13b6a20e4163224155959c463eaf050855287cffc60426d22eaab53ad5fbfbf06e86a82e3f3f8e59b01fbe55198c68f4089e935682d5790c6d488e652fc5805609ff0f2ca46f29c6889661c69438369fe80e1f6cb4da46ae58e1a944e8566b4a371230c95bfa64206b787c84c8debb2cdc7604a4a612487da6ed22a6998a1cbfab3f111de86ead6e571f143042151c6f3f0bae1eb56b04653b349ee753c90caa4cf40ef7142e83006d8a2fca4ec122e3b2a1a9a5aad5d73b00da8b136b1aaced23e449b4cb651f4ce421b7207e61a3e07c5a73749c98e8d2b2389afd66f4016a2cebab7a37e861bc6e598c14f9120c0e10aa1e921b3c0660fa17844c80f7ca807a8f7ac3ec0c10f47acde254ebf1621c84894426bdd6ef2447941954d85b92e4231ef33901d2c52a1ac04b4f982da9e3c403ef647483afbe1bc614077dc59f45a21361d7451c5615c0592b5e33aa593a194f305f86e932ed72a6c6d479691b908023c867093642488ca769fc81b9f4156aab376bb708139db5fd23ad066df19a3d4822135740cdddef9fde85591259d1d96fa49917b47238252d33d1ca241cad2e3629a09907d27852a5ceb607f4acc20edb8c453332d9ba25cf367e2bb7c67a33e165e0cbc73565ebeff97edbff9e74d6c75c780add999771053800c40901e0d8940ae423761593349d2140d00bcb144db518e1c699e8f1528060b5ee47e4b2bf8aca2a16eac579f00ef0415b9599977deb20eba1fc2d924a60f48b4302e1010c3d23a9ea3fceca93d3e0f1cc0b31768499389b86dc460c0136766416f5892145a7f97633720fb3f15b0316ed7d3890f4ccc88a33d8aa31dc1270b5c642743ba3305151384ea9bf241599e502527d51368f19cff8b1a0915dcc0a851bfb4c1ff29707cf6a399e20ed3fb5adba3fde909dc1ee4efbd5fb8ffc99e333817d73c476855f246ca58a6f905076cc71a0bc4f8dee57ece8e91d7813cfac0ea8e327d46dc69d66f063584af8024a76cfd26295a3bdde3eeff5075decbc22d2b5d900b4ad2b5b245cc33a6d02ac7f9dbdabba399c05a7c950e5f93af5ad85c0977e48400abc20908970512e563b50fdecf18ab63ff26c46696e9665c0ebdc79c110d4cdcf4d56e3e67739fd22a596241dba15fd0321d4730226b29597f098b472adcbfa654ffc9e3152c64aa166f268c8167fc42a01858bdfb44852b7b6c6628d8e4e64ab126263bb0c0465b66be92cb2e8b67565e61f6270ca0eff5ac613eef264376b1d978d64ea0a95c1296f06559a9b1391b552d9da624e798baadb3f7a1723febd64ea46473f3bf7f4d9c515f292e2b2b5a63a062d7277d3c68b3fef38f8ec50ca2f2a6e6c9d13aba03a49c868a87c3378f0927ccb2e674031bd57525c0b571af5b21832f7f3034e36a5393deee5711be40185b50a78b71ed22eb0cf5eec7c836e1099b63522920df555721068cbd4e334e98dda73eb6b69d02a27217900a79c78e28d05c4b113e72371bde736455292f0a73d0791c54738572008df84c89cc787c9ea3728d58fbbc91495a487d54149f7cf28ca9de81ac6334c8d6d26ff2357de035f4c894e4322fcec8799f43bf2c983a8d4deb4df9ede378d97e3a6ce09bf1c75f3f7677bea26c17a53f4083fd46ec330dbfb6d23412e308a48ef3f7cff5ed4e5eb6aab5963af390c23de365a6932b20ffebe28ee6060f0e4fbcf10fa8c5301aff75855d1df49948394ddb4c214e1c68d8c033ff20a168fc89a121b7e8076a1aedd2484b624feb043168a09b06153d0ac01361101d5050ce1c84da897e205c11f717f8ebcd8346da0fab0dd5a731be12527b60b3d7b892fe5191984844f3fe696b41920e52dc592d79f0a5f2709294f31d22e07b7974bf483ff7855dc2766e698bd68f1d9466050b7cb84dc98db7345bc85c2842d70ae58c654972d5cbfd94f8ed86bd211cd89dc0bdedf0a8354284d2d83930b9c4059b7fa9cda46c5951e876bb75d9de87725acface1203ca20f45895f7f16f28715857511b9ce77f854c4f839dc06303d6f940cd13b004a861b70436995aa7c67061208750dfe64e5e1843bbaac25e9de84caaf3b98c196997aedd9c6a51f9009744123fe86b94af865e242b758fbc3af24ea57a51960fa1c05b8c3fb3d953cf779514445b4758188f7e265fb58af8c1d3bc20cdfc3e7928e082361169dada72b928e7903f24f179b6ceb016eaaa70dcd08a2fe4139aadda6d6dc1fa14b408f06d8eae3c3bd8e039fea30fd97d8014196601671567f045ed7426129d0f7dc7e5010b15e33f1f1b15a31d9f460fe7cad20b40052ca45cd330884ae8f42942cb09440010d7e08d0b31cfd3dc6c396f978e77a49a9900b08431e93870f0415430ed3fedf9db54b1196e2160f871ac055ce17a312f83a6c1b9c299a8a9ab36c3ebbc221e97f7acb5582ee050722a367116336470e16de1f9d503b158aa340bc3190a6f9fd7e0c0e0c18a21c4567be0f68e7b33f9f7e0dc3d370c8d843d90109340c5ff4f9ce118d58c149c548edd767c246ce64816f0e7b8516c86cc9453accb5c192ac41fa044d121a0b8299c91c3ed542bfb61fc25ac274555af7657e58a903397157966952a862057404195218314e370228a8966ea84763d4e23fc2e8ebd9c1b2efc1748c14fc79da24a20944ee758a97b2cdd0223971aa131ce39d2592692828c5142c6f158f2d058003bb464744081ebc463f29b533d3844b25f8a23d818606b9645db3233f9ed19310a47944063ba17d382cb188db5cd624034ccbc5a09f6a53c2b5b0333cec11b91dae7863386e4ad0c52c281af87128c445e90c0b96b3c69f9c6fc1537310b9460268e6fef5d17e8c3173c95e85e7913eed5c946ea64d940d286683d6c9fc7ebdb4652cb10a5cf2a921e721aa23d26b2de281f96d9aa034e05e8795e4ccf695bb7b94bcccd5cccee073f36afc77eaaf9c533167dd1f1d4136b65ee38517e5afe722bff578a7b8e1c8acdf1a95bac087c4ae20bc0c5c80853795298ec5bd11ddc385176c7a70b729f3678195e32a35f16dce66a48cfe5ae2fd0900365bfe33a5acf3a0ac29f9d029714bf12e055077a61f72f2f442084aad000a331e9a9c414cde9bfce7b1fe550fa0edaee75a662f7767e67eff0aa074cf09e1d83ba66f03cca0678d743d84b6af49aa8bf241375bd2a16789c859de7ef238019364c92986207d4ca08df03acc71170d30e390873e1ac664e30416032d15bb8664aafb354fb513a28fbe2790b02b4dd666f2ae22bda7d3efe6ca725c3f60d1ba35f2b9c6bf9e50362efa9019e4a4587ef53b739f564449d87f2fee1083ae32001fe9492995ce143c45f89ed67c3f41772e3328c47eb93012c2e360b2f0f4806dffc3354a2b9e0b13bd66de17984ae6075332ecf66314707af126dc9b7ba09bd41f2efe23e1bf20197e737ebd5368d4368d20b4c0d1da94ead5b73ef8654e453664915881f1fd25fe1d07cb21c21674d9bb40d2a816f86c3760a5a533117ed563be25e62641f146157eb4dbba5078583f43abf436c4c97de9acc0c88376b02acf85e711c97e102989ef3500fab3a78225a8b2d6613343046f1b2e36c437f89bda77fa4bd5245095876048e346b9d229d35fe515a295a5a4af03e174ba9c4a4c7eb12ae41dbb25d9186cb6619b80b64957052f0c8cf6c381459ab134ce5c69e31933f5154cd6c01c47c5a82cc62e74e24e03d29acfc34def8a15146ff97793c71371570da15e6cf55524c184fb330a8fb69af48dbbe4218662d87b2217c495eeffeee45649018b5fa148585fa0dedd863761cb052f49b7250452e96fda1f2cc66f34632e2e294318c061e8bb008e31586ca93052c5856fe685f7e58499a7830c3254bbc255e5d9ad8841893b8e52ae05823b6d6e54e1f000f945aaa332f48adc63c526362d628a4389a1b7f24bd0f7e920722f897bf78a66e6fb9d85e795df45eb217ca699ce61ac15becae0e2eb9b159fdc06bb2e714e855b2a1efb7db2e03680353172de9225e25a74e75026272f70bd248e16d50f9e61ad98ed5a44e2551c1eb6f7743990325eae80d839a04ed33f3e4ac0a8487c337f5fc04f61e3c81edac95a1bddc09802edd712bfd0383ca880e913810c12326b65f2a230f638dd5fa5e7dcf5c8f670f701242366f7e38f1048591ffc37d87bc93c01cd8f1f56a26c8f72e6eed10894b8d1e7ea47595ec93fb1a8181bfe37e7f34ab87ee14d95deec3e7b8da83f6377affe384cf5ca3e075d11913bdabc9b4021678a6dc1e7b7fb9e80f79b5e958f21c5bdbedb5fab35c9df8b634448da47252838c535016d7c47867557106cbbf831210cdfac58ed5b6d8331d162051e22d730ee9eacc30d3240af047b5d320380f86d56ac5b6352bcd46fb2120e15f6350ad38c2d45853a3c4607752308c597190fee5d168e0cc85663733726e66aa379214d1bd76d8b889172a53b06234b6e30429249abf248751764bf730252d42e62030b5ac4e526b1487deb4e7022f934117fe67c1f277f5d311e01ca58df85fe0251472c194c8b043ae159148c8d7f31d774821cebaf2b5267c3b84b817e8507ebfbc07ad310c4e8be94fb0b79e0670f040f8175d06ed8d37f8bb0724d6bdbe85311f3fad7dfe8c4a658fe8778bae4e27afa3070bee37ec36c7e352857bfdbc5598874359645a70460f7529913a4d9cbec6256843d6b19f26016b576c4586c0a27cc2f551d4865dca09723ac0832fc52d6a092b80229f35534e4b45276504abee8e90d65875b0692e2f1c84b6bd871728c60138f05105f7ac5a086ea2dcdb75dc73d761e5ccec40cbd5a78819eac8b441b4674a088b82ac5b629a680991c818f726f01ce4b3496dfc9a5159933d8215bc8b9f7900c2741e5745d5e7ea034d3ea8f883e8c1c0606cf927835c259d1a8d2a45c8063d7d69ab40bdb2caaf740b20b54f3835ab7df0cf1389abb4f9d5a17db0f81b3e45affd0824d33a629714e092bab2a532deb99f5ec8736bff0abbb4687622766fc3ba106c6e7ceafba7424d86f949049bb0d6ebcb8dd92a29443cca6abf8d914be6c366e6047616ec3b0ed78c4a95f7121a51a4d2719a7af6225d9c7b89ca91974775da31e3d310a23f5a4b7b111f6eca434a6a8625c15ee1c4e03a330ae35dc33903f906d80b3ac851385b3399fbe8d5e6228966022135abdfe223731ce330c695b769c8ee83d4c41309448bdec921b18575b6c5fdfb2f69e3aef7864b8cbad708522ac77ab1eb424ff9c7dba3b11bb58d698d5da4701218cfb43957016ee8b5f7678f4affcc32ae17ad97347888b91343c3d44242dfca295217fb1b89d948e42a4a6ed05e6a7cfb405ecaf6e843bd49f6dabd8039cb76152f5f92c8ddd1b5db95927b97424c352a6e50914e7015b40debb5cfddf82a6adad0b898ce55934b43f5b3735948ac0cffbce43613f4c1d964ca4ab13db71bc2d4b4a65ab5827b8fbd6fa68e85def7dcb0bc1c5a0b11ce59338d85dbccce1a85e6f343e86ab42e5f922dcb011b07bf608c4d65d845e1d7a27511246107ec07559e710e05db63af648941d1e396abdcb7efc7f48cec6d060a7cc170b82a23ca93d9e51a4029fd8a3a3a32083b5903f6671b1ef790b881ae7008c4f5875eeba4d900bb65a08c83079e5c6ea2f35e4adf3308e41034944d7636f8526fdb114da29a2059ff1020903caa91169b8f31ca13faa4665ee2e07476549d12bedf17cb44c7a4ade7bc251328c159e29274a43f303d996915cb0a704e49325d9c9fc38d8173ddc27c2e626df553286565380c67e414e7045c6d9ef76c5e0dbfeca7abd6c523259da7e12d518c52b276ab8dc06ed0ee4510e87315114331c146bde5ccc93f5ecdd3c22ab30b2f964a06a0ee26227e3f6c4aa6619dd335a2ee7f856715cd4ae7f54041e7ae3a911ca3b9cb7005dc3729ec49443448307c2ef760e64fe90c15f1ed9a2ea5ac18bc63a8f80bc3095d42d71829f5faed723b3c5587e523a0d80526117e51cc114f5e719027f47cd1878f0a770f875d63b40fd22a69c36cfcb34eec714d67638275d8886d8bcd1e1f57293fe85fe875ea707b4e3f55c5c57cfa2932c302aedd11653355d55601ba5656c257c7060a4d1e40953c94e072c6646ecff6e417099f2972f8bf20a68bc1132a9359510a0fc75054012f331b7b01fb7b20fbda1807f95c5ec6823a2d248075a287993e82d0ab54b65c794f5b814469f455362cf8a28313d5a66e267dba2afbeccb0f0c133eda39d3a34d3831b90a2aba77d3c7c2b83a9f565363818a5d9abd896f6219f3358d3be898b08fb535cebd0c023698a73ab37cea44759c75aa7446a1fa7b15cff49ab32d49bd0db9c374e89de22ce72f7ed497a9acf8d9dcc3309cc2cdbe14152fd8756175fbd8402f111f89ef5f51ab83e051a72a142d4fcee0c75e0718744954efaeebd7f6bb1c5729b214f60141b4c30810f632aa0886c6faef16a514c70d1e83dd821b8e1a40fb33d09c59b7277bd91dcfa7798bfa4f982efaa6893f4e5ce0a2900369678ccc8fc1b9f87e7768a0e75a41a571225bf2855da0abed8f3a4654e6c7015d8f4f7ead4ab9fe588cde0acd5c63694e96c0bce7be103c46eb50423e19ac492bdcf0f4ef8c2fe86ecb4961e98d8822a9e4b016b8de088274ceea1de70c2bbddae1fe3fd6ccea86ee56f3405e6c651b45d5014d8372fee52ccc9105d2d914ec40ca45af8f213225c853e778aca8e09fba0acbecb9ea8f694b8cc4f0a1fe5d8494583f5b1c50449f1d1c045f19f3e8b45612b59cbb1ce0d16523ce8bd754430e2f908f0ea2eeb594ab4b633e59d3450442723eb070a2c929ea71612d64d92f5b05973568389ac5cc0c6d600e4761fa16c6c032765801cdf92987bca09216b370e34ecc5561c3fad9a98e80112df96c44a5541e41777523f0dae1b15918dc641c0624d907e740a6ff100859e1a76f6a6ae4020d46331b84b87c365591a4a0989c3d6cd9ac270954ff8a8d448cdf5622c377ca59513c1fb19bff8066f5b04c77b0f08e0f7e1663acf4f86765a2bb95c2a301e34a61ab4046fa3553fa0298a45e491fb3613b05d174b1ea670d9d6c3f6b744a7bed6e596f17c041b747b5ce64a59197cbb09f981d8bd40ce6ad1b36b0058f3048eb811135956420dd98ce72664c16553870063f723fa4c408fc062945863bb87d73e43230b2a60bcbddc31a53235f8c5f73a662e4566910e570723c8244723659f1eb46fc11a795fd95cf1ef63b3e6dab43d69c81b440822f5cbaa42c3b2b536a974abfa20a04c53d54f6b067a50461b1869ca110b8e79ec5d53c88a7bff57219d47bd8aa933bff3f08aeeeb0ccde66cb0a50764f799f6df5f864c31b3fa50e0b6197db7a6766c08fbaa61a6a08cfba4605d9d6ebe47afa871550728b5a17221ede85fc999268c7889f716ac36e57716bbe78cafb054ee91e01b2cbadc90e2691a5aeba1ebd38e722236eab7a8e98ec65769ad827c815eaad0dd1f6f2c6f7178adb8391181718e9bab294eed5f5f6361d992daf3d436d2ab36329142af56a010dd4151549b3a3c54ebca312ca96b80d8666fc04fa36027b666c1ea7b38cb838361744489b0c7f601d232eb38ef5e1d48886ce82dd24cef0044be45c6c43c5c6f8c4c057b2c37f2d1f0f98e816fa205547038196e9bc2f15281f0e3f50d2de9113050303773c5ee7e49bcd8dff2644a00b81a1e593c5b627fef277c227ac93e317d2e44b5bf6b0d93f2bc0ac15648c007903d2d4ccc0d80fcb0d8f4246eabcda8db7b590ca3f82d2cbf6a0469b44543897db656bc38fe7e9d43bac36c65cd4847f167371d265e4119c77bb0d84f3c9197bc359a24a4fa1a44be660eebd3b38e2d77fa2d8130fbb4efdac90f0e1460f5b4f198fb4649ff4f7da29ae7a7be1388c966d7b9874487cc8e7ffd2da61c9b3c8616970307c9ab319090128e0a38c4a5f1eabeaba4baf19e9a5e6e75ebe1dd467f27ec2dde8c6a2363705c684cec87a46746d289d560934e4a0d6d53d697a87d67d3b3ef14435c48eb2919e0a62417ef54543fcbef29954938254d01a61e4b2c51784169e2b1916bba380527561431cce233ae0b04c6da3f9a5a1308145e5d36e355db7c401def43beb53c2d00b3fee9634e6b63a94f4953358573b314edffe28ce1c6645bae8bb771831c242a1bca82ca91b32ffea22d05ef1b0e426647979eef81b73d04ff3f1aab41644a5c1e4919bd44767475322c417c19b0d82b9001a7f694ac454d28d06913ed3ad16d5d4a677228837db8c735601db452b321595967f2560de0eaf2c4c6f98b29d1565602e022d0bb19906d4596136641e89b99ad681cd1f851740c3ce75a0d9bf07e2a8e012b7d3299651548eee3123d326044bb20f79057b05994f9c22dac89ac6e890c6662b8fb59aab20e8afe1542929bbcf1f11dd517f050a86542470b128f038b1ce6282702438a2dfd5433d6571b97ad7030a323a008535b8af8bbd5981a3006698074bd5c52f47f3e9fd99f14958439254038424af985d1131b595e895107f7a34f885bf737d9c9727da865c40b8c81882c9cede727e39f7257bc245e01b128a22241e842ebcdd2be94783113782ab26a5176034cd7c7d445b0b8af276fa4047d3f8088fe3010b3516ef5f0eb39213e56f5015f6187129e36e0806054c37aab9360a37def466ae4f12d6b6e84ffcd222c2b873989685bd5217282369c43a73d51c3776364eb9d54f62ba87a8d4333acfc3c1fc1b35802d7e3ea9a4d726b9e79af308b8ca13054e5415eb09b0b49b93c9a91317da86e4319e11f6d65a07c53925f2558daf946b1ae86b72d54c9ea4528310ea85fb9e1cfc4c8d8e9683795f2ef2eb5cf3031f0476e7484b297b1d3edf1fb8b29aa6741d6c8595e9c3432ced92a39feeb919f1bc4a1b90706331b0b0d8333107bca6e3375c8a9bf1a5a892fdda3c845d6b7fd016b9f668a16078c3b54a666c7f93b09fd36846d8a0092aef9e84bba0ac244ac766e09c9ecef3262d68655afb6827344c0d7dfd64a55912c5932c67dc3cd70521d17e219be56a20bbc75793f2434437c7977e31e1446b35ff2d4444abfbb6baf2b9c1c7c97495b59f4bf94417f4730d0f727bbeacdc09d656f0ed887f66d627b5f4b71b395db3c3e198e74cfb791f374b5eaff9b1b1c8593ee9023777c5658d181df889a575bb59948ad7e305776dc9f7d46e7efcf8ee816d9f343ee39665b4b84ef90bf4cc5cdcd5f45dcea0c40b0cff224d1506eb3107c5f642bf45996c784ddcd9576878140fd3608aa15d3f35d136c036230056693ead15994bf7e6ed90e37b9b79278a7cb286ab7a422d0b2d058feff557f55d8abee48c6ba4760e83d6327aa87bf9e15e2c53afc63e1d5be0c76e70021ec36da15aef942887c4f916d2fe72d492098fecb2b3fdbcdc5294a380d89c105443a0dadd754babaf2ef9eab56c0861116aa0f3c1cd0b3c1b8b8ced025725aa2c4fd2ed918a10eb85644dd66efa22a43b46326f9725241c57c7a780d31e956d31e7c1240bee2084deedb2865f4fe3497aab0a2c572a783ac7fb48915a255585ec0c07af3676450230069430958c187f42f3c53281b31be8be46dfd33314aeed9f344d520d9889d6307b804b0e2e2e2ab3071ccd2df0b40e7b9165ca5fb40f3eeae6d5fc2fb883a9bd7b4f3c8073588b934051357deeb51c7d99128b4f79f50787219724fda1b858cfbed12a46bf1c302ef5b58af3f602651f852007e5f8178b11aa22b1f9b41d6f8bda59326f4067f027cf03b92a09614ae68b9cb0ca7a28cf6d5f3ed951c44c61dfdd7bcd48f7dbf3699579f48a32dc14a91e6834ae0a1caf990f7f8957eea58f8081487e541405b95b3a73f07a0eba48c4acb82ce6eae96a26217ea893b362d944be1fa0828a2b0665823b49f002b99bdee6dd3a46d71aeec78b9b81ad86e2a046ec37095c1d46861aab61aea56c296182bff8abbc2958ef692373e3a906244b3fb9ff6855e8fa24713f6a4904c0e4ee3b9c66d6a2fd01c2e787370c876f58b7317510cc9eebddde102cbf6c303529ad997ef114f69b4e59f6cde8c5dc15033a36f7131b4bf6ef9ad8d1ff5ccb606fee00c8e51ce5826f27d465e2c7dcb1cb8aacd753ff4b10f6e2355dedd94c6ceaa396038f355de853b2feb03659b50eda95fa61e386ff091dd84baf1d7d63428e76357ea76c83f813bdc82036650b2c17e8fcebc1241ef2462490ca405d8b9e80a9e493277cb0e92d882550038ea460f006274578d1cfbd90fbbf4554006190784579334b6528600ad8ba510eb2a67cbe0e50209ec3f7e60fbb09208539374c0a9be95c8392d3de3b890b0aa944ae81f8d64772dab0b8911161f035609a79ea7d22dbe6683be5e0082b8c7ecb257242d6a23008a335984407dbc788584eb248fa915e39eb146cad02d4f45795796d4a5f6d4bb755892cc91c1edbb2d460a5853141425bd095ab61c9eb3736b1fa873e5550177ed989cb44c10e1ee3c81a401f45fc1169812520c7bd71f5df11d9de90672ee98f9e7c42408f6433f4977bae5372824554cd8d7a8155a40e50294ef263f79366c8850b6e6b021cc71541e47bd6d677e57a65303bbdee320228095ad5a2bf5aba9d36f54687e8f037736d792e0c62bda85685a8fadbf637a25db9f2de31d490f244ab9a4febaa87f518c2651e195afad341b81614fe1d38f4a31b8e0afc1dcd97258da5abf4e56627c40e0424fd9a86af953866a4e2e7dd42db7c146d417f19deb778e668aefddcb71623c7507c434ea6004fda793d110e9d1a306f42d1ca19ac07ed1c4bbb1d80b06b9fb5693e624db0bc20e13c7dd260fc81133e0c26af5b1727d155d0cb797f007420e13ea82877c66429d629eedaa1cd04a72ee83837c789404762b98b4c58fec008362f47e9a93130cd72e37fb4b87c420850bc4153b03d8f024cbb31bdd313462dbd1a56875ac933ab13d635354edfb20b7125323f642d6416801d195b4f45832d3941fc9b74e7fd73776de47fcc3a0b08db4160cca6ecf039b020b7eb7f025626d4b053305c1d79df65298e31e9025e568a6d602bd4c7739b63099b34d5ab40924d5771792aabb13005d353a6ff0ccb31bf042f95f63889a5d69b132819f558886f42fc2668f8c06b954349d2c836437461c748a647917219250a8149dbf735044352d3279e1769fa063f2f6519c07a31c62827a272312b006da2cf0fbf7690a72216a42245e1a1c52b79aaff14563d9e84a3c4569edbf6ac4d376903ba8d1538010c255df522875f762b41be77595df7383af3e0bd32863978f4c8b3072cc8dc021677b9a25eed7169f181259496ef259fc9568fed921cfd463ba97f3b7fa46b3fecf026048ddecc1f9ca93432ccfb86e8d20858617567081078ab036cd9478326c7aafe7c9c446debfc5d4772d531e0e50644d1409f8259e50808220b15cc16a87edbe74f65cc9d4f69eb4f504c6acc8eeb10708f7ca3249141620f00cb74a4021dea6ac371e556255e67ef615db6cf54b831f6ddbe691045c7b205fb0ad24ee18e4b0babd6d9b5f4e5ae11843927039e93f4022645fc9160ca519dee513b15ecbe08c7e82ac1012af0f74ec198afae76b6d1f83a0efec8cfa16e84d16e7c55c53bac099be4e74a493bbeebf9700b9b47f00fdce1f356100b49444deb70c841e937b948209674abeffe5de5209356cbd23744419276ebd079799af6a7345fa0aa273d19a6554a8c0af37458d158db62be9653434934a8282eaf250c2ee9814a09aea7c1add67b0658ad5350ad21339a85e3f5acc3a61564b640c0cf6153c0b1a206987e9e7b4334f158b6966e7ae4adeaacd67d5a58fba288c63f2afd0fabd5b480a7a4d66ee953f7ce87bb777a6a8e9b5fcdb37846f3e9e5741b36980ac7aa05d7ca8c3927f639f19bf690a941936b6ad72ebda5ed4f36b408172851855ad07d4e8f81345e5cec2b802d21241becafe586725bcc0c8d445ab6d4efba51f001dc94898f3fabe8b22c215aed4162744ffcf71464a079093bda5295dc6ee787cbc8f6633d2529ecef22414573dab50cd85f23da34c429017a51bc2b7498c2e397ba61377cbd6560bb82cf841a548ed8e8c5705ec711c5381ef917a8b92667fd748928da9d0554d9cab6d548874b031741c2f6848743dcbf4f7a15006c73871f8b877c2e426f15c28bcefa2f60ca42df315780c91962f1f7338541dc23150f33f9de8066ae4292d3ad32eb083e6e5d1b762906a69146def7be3a91438da76bba9157f6bfe9199de5dfa7fc60430666d6b7a5bffef6e6ad117b3fab93cb33eae1738917e5d4a5a7a7505d4f5e32a6dfd304fa728cbd2b8a08c358226f4bbedc35fb3ac37501bcbb4203c99d0a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
