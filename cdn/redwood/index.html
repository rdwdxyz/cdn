<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da8c732dae757b1dfea47df6cba03aad49d24a3b0498ea353ddd96ac691d028391095f314af4ec9ff3e74a65c88dff9552e9313b1b83a832ea06f32379cd4e9e157366f509f5e65798bdc5c322d0dcdfde038a4b68aa320c4a1ca2e186493982b9f6b9a48faa1809bf6c24d54444d7e40a8ea8b7704c12be6bc376c883105f92d802ceab2726bcd203ceaa7bf0ec8100839bcb79e28ca7f73c54d0e739b47400b96b3e19b2af248bff0f88e3359345b89485381dc04499eb93e9825876fdbd41ecebc9f778714bc208a5c346abdf7897d585b3987b869c6d3619a7eac18651408d609e9fd22e6d98c11f082bb5f8de0fed17c8036bd2dcc19020f4090649b6c430e1e997b7a3e81b5af444bd882c21c78afd2e6db286aa7f5fdc1744af8236a5b4407b6637a2c770ecec296b9c46e4721892bfb8fc183f73ffda61950c8c14ee70ab71c8a40c51983aa56daa47eaec586993a6ba9c698f47babe556137cd71a594030202909416d5d8083ae51db8b9f114126638a16450ec23feeb255e49d1582e72be086370cf16ddf3c04abbd0374578998c3155839d54f6e6b251b1f88b71a639112051cb8891f761d343ab6c9d6f676dd910f2735a0cbb4737c72d164be473b316bc223af0b018f474800bffab107824d9b46ca16df2e843c7df81e12d0c9e34a7fe1f347130dc96b080d09f33a18fcdaa06d04a3709176f76be7344245116b5b428abc0192ffb01b2de9f0cee027bd91c87eaf39ff0bd907c49cffc888a589049f4b2cee223b05d58ddcf434ad9e844f16938434be850d1388554e3ff943710df18526018c820c91cb255e6b8ceab260ae4c4851cd88aa0e4143a1ecb9bd2557ae9f3a5859379426ad06ada062fd5380485bf861fbeb049934a1d9d3f89311ec6c5be3ee703a4455c131abaeabbc42e68c1f784288582a122bd1d1110b4938585dc6fa5b9d0b7353ac5ecbdf2b3458a45ca053e6b50ca950d104bac0ef0b622a99de8b4f622cb8d277eaedc2972d50170d7ac85c7e7075a8a62e5ee52cc345eeffde70de26bc0ec8b2449faf3260847751de86c3bcbb471dede6bf7daf5613275dc07d24586aad13c4f2f857a26abaebd7dcf752a23e1de5b15627ff3391eb25445d5fc0c6bf7932ab6711f7687d428a91773944c90572acbd283e7620a5ecff6fd0f9cecd839b43dd440969805d4483b1602a937a938a1326202a4638b39ca511a6828b52f7a3562308536a6e78972f1465cdbfe37170d31269df42c217fd8cbab94d5ecf35138de850fa8db382091f4045fff8cdc3d529b0f3993cf9401dd2483a739cb7351848be8349c1794440d7ebbedb78195aea758b3657a1fe461556127d6d73551b4cf0b6bbbff8a9ce1c691f45e3e3335381afaae6801130d0bc1393f93eadc969c5589a25ede9cf47bef822974cf8b322c7128a625bc2d8a5635dd3b33aff92663c3a73837f658086e7df7a3c50c2474dae3400ac6565d141a71e0cd059ffa7056960c6fc64f3259e2f2616962d9116bb8105646a50d8f6b7c858e6419fc61afbde674d2c9788ae61bc0f2d0289e32817331703c8870a6c558261420c7f38874e577ebdbc11a5165bcf121dc190bba977e414fc840a8517d6b17b999b7863ba6370efe17ddee8bc1013b566531e2cdbeb941a9c68a7fb4fdf20f8620d84edcb2610db7e86fbde6705f92d8ceeda5bb35d915d470c9de1ee277e32bed26c558f2746a8cd8c276810a8ecf656df8da7100784dcb11ff2b0357ca1efb91adfc9a0a6a40a1014c325bb0f60697bf631751425c1d76e2f5b26a6820d32ce0ca756f42e7dae5b8e105465053c02d01a74a7c8a3b7dba899ad3fdb85d34c2b1a38b0fd33ce54296d9cb04cef4960a011668608722781f188c9205b44d5c941dc7f401611cac2365a3390c3d020da250722fec8099d5cab903553ab4a01a0e3594698d9fa8a17e3ddaef0388c10ad6afb658231ffa1f97bc952b51381cfa7dd209e081640bafe700389ea802b0d6e21d601457dd72d71d2253fbcb3dfc933c852cebe7195e34b161b4818ae1c63cba883b45acb98da88db90e0fdf40bc768cc1d07c39525f3984c879ea2d9df0e1ef348e7088f19fc84ac9a435767528a2095f4f7e794434d77435644b32182e2cfa7eeb2206c320c7cc7fd6dc5e089954961a84e0ebb1af1e1131553916c98ea8c02da7436a389acc867eb5dd66e31bd40d60b8f0688e600a7c0a25ccf9e10b1830e0f980239a94e2a87e0e3607c507073ad366c5ba695bb0f9e9c106e2b0e975470e4f1532ec04ddda8782facb2b2f03be78a073cdd136bcf66f2a9c2f9e05e8f6201ecb88c2a9aa98ca50c5177a89d71ff2ec7da369d444c7eee6f1686ca4cc4fa49b785cd4af910bbceb17e878831e9126690cedd4dcd6f3ca426277b18e8e3591d7821671e0b1236190736014d0ea954cf62f37dbbd4ac843e539b678c067ee10a370023f38ab2b37b0ef31971bd7bdc67eba097ccb07ac835201a0dfc64f8ffbca58d1d6e5bdcdb03ffc45a5db2fe841065cd575933e215baa179198a05642dbe13e07b51216453e7de3df98624f2ab42a6f7521052be2e6ee20f9328292831bd535ab61866d8a33b52234edce0b22ea943389774f61b287f4b723e88644b28329d78e20964bcabf36e216913df1bd95b0a85b89fc983b52e6515aaf683babbde8465f1cb207c6636f46ef4991221583ac33fd74a0f104041defb1e8ecf0d24d7818d33494556833016084656142b505ad3ade844e5a0c8cc2ac2c31a5da2c40ac7634ff94bfc5ab2ec7182573dcf909f7a572d1c52f5b873a5627d65fc3caa3f15d2b3ceee375db80dc0995164e1325b77c6f3178c8556c1c954e3ad27918815cb38604043dc30588e8f8b6d3c265faac1fcb49c143480f13e3f012e4639030a3f260ea34add8edf2c21b26dcee6719d398841aae068dfc198db58349893b555a40728370907208f71692df886565442be0b3fa7fea9b0207adfc31c0c1e3061a77ac86221f275d99e7b6f206e77c038febd8d6aa7836464d33f1883d092b27863c962a91033229ddb69f7296c6b9d6500e58b26e41fc9581dae4b54643708c7cef040382e7d54e9e2e2ca1e392c84533759a8fd124ee284e9526f8117aba54b6df446d097fca71e2da38603e139713f07d4143e9b76abf94155bf2801badb29fc95bdcbffb1fe71d1110ce68662952a7db806b3ba788c7c6df06edf68720c24fd56f90a7a357f02089cf06da6e6e82f90bce76fd74e73b4f5f07279c933dde38acbb99c5673ccd0d4263ed82967575c50a9b5a8990efbbc13d82c60db78cb2c7385604d4a58c1a8f36daa2192bf3340a178bb3ed490ff7c1c7c31013c8cd824cf6471cf92cb80f35ebe68f93f2d89d3cde356163db20533ee7654c391d873eb30af9c77babef8ba0fc34d546453f4f73f6ca28253ebcbd4dd079443ab051823652d81412f39272b9eb973e06a41af489682eeabbf16337b362590f6afd7fd4ca08c5f150744403510cfd386633d58a8de6e7d801bddc359dcbbb477a8b15de634b82811f06c5475e0d41e8fe976f7770b728c6c3a05547f97bd32c4a505db9bdcdb6c61160d79cb7bc03767272d5731a701a4e9589f17f2c4385f4fc4cb1b43c8134a795a331f26c91d54181cbfb9c10b11d9127d65525cc168ee3a059bf48e78ae85885d6f00b5a1cd5daf7c1d43a7f8ef0a9d605bb0fccac249788971906a2b9a5d0dca514f1d567bfbd9125dab699092b2b6c93d47e26a084e513615007376b26b0ef3eb14d60ab1a729260f4a6fba6dad8dca2da8cebc023825b41ffed5426bb0ca3df8833b426cd787115ee09fa5080fa226dcfc04091dda712b28cda72768c61d5340b8551f6e5b2766cd111f7063baac94aa579172eb498ab85e508fdf8644cf4ef89e1bd8e8e4b8929dd714ae6c4acb1320b41fa72c9b4179a465da9cd2334fb267d466478fb03abdf8b5fe6955c3564a7fbfbff194dc5aafd129d6cda051016badbbafb937651d74edfc3188bf466a6534e0846d8272e676424babb11479a4916c04162c91852194a53654146314e1cb3c204ba503b37d28600aa9f6b907ed4bf077cc596c96c4ff0cbfd4f42d3dbca59c35953c96ee896966106f72e34a7dcbfbaf3df06e231eb01e5c34cc286a5ac26b4638241b1443a8ec0ced4978b541b4b95428d4fdf5e9a5138f99a14f166b8234f476080f529781f0e185d87a0b5d1777367328a57806cab0648ba589223b2f7d217e3e8d7a146ea3bd84146570a0e17a7f32900b4d91daa6db034c7da9666553a284f7d3abaa434cba25d9d5462d62e5f01465ddee8d428a33fecf224f5f34d27f4306e2de3325386d96bb1a841ce5911670eb8ff7611042b7c08a60dbd4acdac2625dbe4325260ae0f37c35249c1fdbfda258bee00741fd5131722f25558e97e3546375ae6bf60492630c29d173c38e0d4d8093825de1c8f9db490b24ee66fc866f4b71ca255a443427c2eb5f9082c7703bcef4c6ec54b30f0e61708e8175fd4d9c4239a475a365e91a7de0e46d73f8bfab2c2813adbc1cb91a4b0256edbb2667cd99fe22ac2898554480aae2c8b93e729e3121a4249bbe90b707ba855df5c4a8ce1b47a7e3b86d18c75ec9d7682e3d396c7f64e894c57ceb7654b0201bbc1f74bf592f01283c5bfefb67b7ef549e9a544cfc76baa8c7cfe8c191711b6c9627f47ec9e0d9d00fb25052a658abb334604a846d6e6d68936689019bcc2b00432a72d0ed96b51f6ea9fbbe8dae7ea7e98d3c5d31d443229649026423a25ef09b65aa026b2352dba1c441f36d6689193171812205162749aa8c975161fc68f4c5f6d615654148f2635ea29a8f5f0766d5ea844df1b963390650739ba2972e3b3726c2f301b301e1d9d40725f62407533120c9e7ab1ed514dbc2f45ce9b5432dac306c9ef9a065db4c8981c3bcafdf1d58a26741dd662a59c42e5eff6d6bb77c39fcb310e6f91cbad47de5b64807897ba3deebf2c623a690feeee0838562be59ba5e6297f67cd9302e769d38939ac0e5f6271961a4abb9ee6b64c9bc3b060f3046a4d1d9c5c79e2cbb3517eef6ab1891000a39a292a0de4cb40dbd8928e922b017aaddd706fd9c29009d59945f4b0555388d9b85463316dfa467043775e861b34e4b4ae38f6c8e1b7fa04f588860c81bbfd6b5e51df32d24a563ecedd97b5fb89b893c371affb255157ad937a03b61052bea15f479a9b36369d78ad7065debf8b50e207f4bf12513df065fac2263ee59bec819133b55b6e1bd01165a6c7194479bf1cb8ab712401cbe80fc549360b7bf21e2142375645e6863d9e3ce53d2861b6bcce100fd9d1818f7746662f9ad604d88a10013c04bb646814609b1df118c2dec1ac70712a307077c5ac677a2b8ffe4d7fe167fab9c26657292f30ecfdb26e37cf36b49406b37bd26bdc2d5b43592e62fab2b435a7a907449c1b700e2d5ded9e1c1523e371decfa063c85c413418f84f2ef7825e90b46d18b3e36a08218e8f3640611780582962671609f4e66678a62b0ded5a66cf6a728910158501382a4edcb64c74d65bd8f66538b69f434236a3d906168655de1f12c6df2571225152939d340f0e3a0e69aabffdd2e4d9c77e39823dd1f6ec7c18607417cecaf75e75cf8428faa098f6bc6a2f842ee1e3d4831ac63d7d1db4c6d8ea4b739e49dd05b861e383e2bd4a439bfe778f22f3e1494507789d0373366ba98d84ec92bff72d21abc6d8fe6bb50e4e71972eaea9c92b32f6d8cba43202b3706dfc6bd5bfd8175dbf3769022561381f7e89f42df1ef80911502e4173664fdf86d746efcc5f67fe8556f08a6dc3f70811f13046df2a8b364fc372873134fd77860c276d1c879a1065f05af46378b6a00a70d324d257bf439a44897036df90ca8a4ec1534b2229be68012dc23d328addd0569c9a04160187551f82f6c77c5bdc0df00cb26116611796b9273b3c52100a8c9ec2ffd5bb8b00cabac5dd4fe3f4b286fb226aa93b03e85f4c669ef886b907c7cba7c143fcbcc07487e6074038de6651b8254dec43ad298fafd3caaedb68716e80e84471b1df4b8f84031ed900fbd0dc0356f10de874ab244da239ae0cf115e3a3d08bafb816e8b1ad7f18a2b3943526b71a969ebf8a9a7e7e9352d5372ee2b4c5d6ee87672461576dedcd6e2829ab1b4cbae7fe2559299d1c889832c73018fbef92c1b013c53d71f55324b63b3d89c9348f2cb0f368262a912ed4d98c5b3dde384a99dde04b5e016d067e2200aabf751fe5626a3d3183600d5d3980353ab8473a74aeac2fc2589486d078a80897bb9ffdb4fc61329c8ad9923622458c6b6fcbed86cd5b22340d8fa8b7e2c30949f38e227be823762cdcc195af85be172155582a632ce8015f348b74241215b7dd15730fe4aa9812662581e6053238ff20cf3ea4f0f0096b1325477d77e0310c29fbaf5a36bf6523ed69ec5fd67b589ecffc19d88181cae97ca5c1ac152262c61ce6c2d394b1c97faea186e88a2b7b35c77d79b40137667b8f16838e40544a45b3450f70dffa234702631b86e5c5fc289c89d5d48976abb05fabdbc6af647656063e1f6b2a352c6b42d8af1d1bbd3ed492d89128b72179d031a969be73704e97f38a282cb21177fb700e045826cb34c277425435e1cb973d1b8a827f55d228dc70a60069f4a452ded12073004eb624e07edbebcfed4d075ebcd8f8e0d1b42939ec832ded9aeb0fd136000978974cf2a08e26f4a547044779fcb1835a0005de9b0d9ce6c3292c62dce9c3d9b1543d6e1b88c1d257ab514de792e882241cb4c399cd9a2a4124f3f3d1918af6c38ada7732359dca8ea4d2e249eb0f3f291d14e3289296745f4b06e0ec08ce29bb8e19aa69a9c00e5b5dc68ac3eaa9ab626c571be67b47af699a805249e874519309dbcdbaaa41f4e31dff8563cd385a558ef71425a33ff28b60dc18ec27baf15891286f534710b0240c2e6ec8e281e316746c2e835e943ca2c3098aa3c2f1bb59c07558adf6453c155f44069181bc431961e720c57ee4e6ab25acea77dc9e9e7253c40dfcdd26165cca65bd9c3803a0a38c8cc2d0941168fb001555247a472bab76c5b85176aa7479d5dd907efd86e6518704e22abae3311718a4411f869538692c8cd86ca2e52ce63ca839313742b9151dd2f6d30b82b1ad0651e9183c72f119f2d9b72bdc342e2dc5a5555b9e3155b920493e60a0e70b9519ab216a3b08ccbe75afa2f132dcf04491fd9ea1d28de15377062612ebe3eb5b522ac1c9f4d5ec3bcb761367866ee9264cbdef1afef2ebfbf9f73824bd0913ac6df2fab7e63ed2c998d9ca7f3f5228dd57873835487fa29c0a6cfbe6cee74968c48ed8803776db0878f04283da8f9abe602f325ea20a31cd38dd6ce6316949a5b5f6b8d8f673e82474013d18eac7e0154c43781730f4a1fac764fb01fdff8bf4e95afd715f3e7c1145eda64d3445cd098d738b6ece823f52d4e02cae26d75dd876f65e22a6001bb93457763f8cde6b83bbdfeaaebbc6582260bb132c325294969d65ec3704e244717e4edd8c8bab577c46e31c989da2d49fd352489364a8e98d97514ba136a82bfe21de53eef238c2451aed0429813d7335eb8a1ae68acd1627d6728ba3786a8e84a77b88a5a554b9703a507a86cc78b6028fdca477dd47bce31ef971c6df1fb607c045036b1cf499e3cc77f2da7832c96e928857aae0a7db7bf3ba1710faa6d92b0705de537e4eaa34149906d09ffdfdc1036a38cb382bcc45fd122aa5599686f971f9a4944c4193376bc6d17ca525a8e46ec940eb481a6f33b1346fc342cd3fba3a9a15793920f2400ec65fc26f3bb6454311756d5006a730cfba79f478a1d27fdbed22ebbdab8d7cc05bcb13b5ab697bd62534287eac3d12448aad6224c40e6a7535c35bfdd2f2b2bdf1c55c51d89f43575af05143ab279d0bcd3bd133f4f035c86691700ced74be846a6716ba87a22d780921ac1b2a452523ec6fd0c48fc390841581f0c94d5cf5c1e7ad8a8ce8ad5347b8715683026a6cf4ac86a8c91c4b7cf523009a180b76962d923fa93b3ef97aa9e25ddb8255c078239e66861f5e137d034da7e5c127c820232cceb852838556101562575254a9cf3eb134466fdce990e0d3f884e0a920eb81611e1f192fb93bdfee3822189b28f878d01841983d12b7e5cab6adb442ffed6979749f723ee7328cfcb3f028b34c5c81ba4d18118954ac232f54b8a3aae440b9d626a3fa1a85d366b6504da759e550111b27fe4a63428a16b88588d9bdf6a4fc8578045ff269cb633bc4ca7a4e7c8b6c53d2ec0f18600ec9ce58950159e4de860e4a2214b68d52c7877da33b0009cc70c868e926a45d246c075db6101b45b20f2ecd89e5828362b0d51fd8b8deedf1233f4ac40503ddfe348d86bafd5c5a596582fc2bb7a8bf4b50cca902b0dd4df7326070c74c1f806f78f5fa258826547df6194707cc757d71ee892b99845e643fb0fc9b1da9ee0d1a5ef90388599d701f182dde9ce1a3c9bb7c1b00780f2a20945dd148fa023b2662278c790f300c1bbccaba83c66f84bad5ee90c1c04376964042115b6a4ac91dc964b66d229a64ef9929ccadb894bc5e4da5c22f73fb90d8d837103dc4d9e7e005cfeabb70ee6779e172c71baeacfe2d3efecb95887c860ff09669782dcaffddadb41fca6eea079751cf5cbea46f7622e9ecbf842e54cb1f39fb8d3ce9fbe72ae5a451a0ed9897b2234b1cbd10d04692719b8cb4c530c2e6fc022082a6f374b89d4fabf45e0a144735167d78c770113662e4b0393460612fb6f7ede6e812d87a11b73b7865ae250376a805566f3cd9de9c857e245474605815f7a69c0be458bd75894db3a718fac83536b7bdca22ced3a0ae478d7e1ae9dfdd17bf5b034461cb4f067f7185ce7816d592cc99a0ea72a39dbc317a5529505f2f105250f4d8d8452d13378687f8124c8b6b47ba9c7daac484073f7e40cd18e96a7f62121e371996000dd5dbac5d280de36163e3b82f9ee520e86fed7d77a24632ee4050ec4c31422220313f327495dc3bdc55526968f5ed183baa9bfa258d28af33430ba9658adf67bca4072f28990021554ce241495a1353a3ca6819d6a4b38b2fff0adb076707ccf4d32356cf8962d763a6743ae16e1224b5aa8b29fc09bee3a548f91dcfc7323c5180e1375c1fbfe00601e343aa5bb96231fbeb832624553e9a20d016790427df3e26b8ea66b1fd1d86fb42ba030861755ed290535e25c8e0d383cf7b1e376723d4bbc27299eefbd4f3c9c6104fcf599e3251cfd172a931e3c90a985a322c21dada3df660a4e6bbeae2734972873a43de85c7e42326f512debdf6c423d8fb9a49b71dbeb18aba59dc1541fa527b77c7315d5870638516d239ab2319f0cc711162c67b111a331bde41f6a08ef74ea81ff2ab41f7bdf27f9f465bbe7adb144d1c6062a239094a706c9372c037029931309c4e5f84f819358fa4ca206d83acf51bc941775eab6c4ccf774590ffb6157c8bf517cbdbf6ba2d5ea48e9a3a7c60bb415df15fa3266ce2a4bb35f6e2a454e7de0cb95a050734778b843555dd25f3527ef26eed315ba79cc2e32ba792b4940dc1fb2b6aafaee352271361d73dcb0166a7a4686f1e1c46dcc1a9b5ed262d53dfb44b11e289b5ebf28037152653985fd9e74e38b4f61d65376efd6eb4136c81177473646faf80eeb3c4d7303507485a138f21443564a5d3551a9630f506f14fac47df83649f5821c92aaaa90bf0ab5470d079bf9ec146ae06933d8537d188694293658c2f684abe0ae511bca82e24806b741057181ecd47831494bc5569563a0e693ad0f79466ea6586996bb06ba598f764664f982db37488f71cee92baae930d934c1183755c4c544032b881df41a01a1e6b373cfc9a377a2b1021ce264ac1072e6c5b74cffe96e65888e603c61c161b3b389a3be0de8315642585aa73cc7ccf7a53952030ceddc7ac3f0460f779668b245c1772dd374913e51e319649819e85e4d758695ba6fcd8f87e6d2c120134c0cec6a1892b459bc9668fb693ae122cd36b0d32f6540b1ced2bf7b14e09a8a0007c44e8312b98cf3c71cb94bc38f4ca198717ac4037555c1bc93c706585a7e491d0415fa2b4b65ccb29448e46230232e2c5a81af6bf97f2c1e2a48cbe732b3fe76148af877923279da6b4bd4d630d9f53a7dc74e4b4713d1de2421736993915c689de9831ab7e241184bd3c69ee19504298389d232df2db4a96f4ca795fa5da0f186c3d6862a0b7404606da13dfa5bac0184e85d9520b14451b4326c2c6efbba63858d0890e0965558f2955f7c81b33345ed71cd1bb7b6c3de860c79edfff94af13543ebf57f76bd14c162fd19dafac163bd7954f19c08902d70194492a4e13b3c5f8464c0bc85fbc552bcd998551d4b3e21c33562113bae9787458500dd4075e6e3f3abf31e9d0886d0424f97da5688836f246673716250aa572cfc136f450b10e8dbca797605ef48c18febbc610d200abe4e31bb32739500e77e551e84dd84c984882d330f79f564bee5aa05f503ae0aae5838df398db7ecbe2d2f94e1e122daf3264ffa9225be80f2289b2de3e847389f12cdff8e9bd46a1e65d16ea9c720ab856376b16d716be7f0360b3e52a2a44cb29f0d60a9be158965333b375fad732be6f7c53b7c37b5c29fc5eafcb071a818984ae6a4d861d31c5ae48b2c0e083f014b3aaf12cdaf69b343bf54d8bfd8c6cf15f4a39f59a912c29c59d2302689ce51c5c458335ab9d931d6b156887130c74ae11210c362b27dc748dbf52ad25d12e2f06ae806c7855879dd3ae22157fe765f28f4885e74e88be188ecb2fd048fc35a6f8c0b4038fcd4ff1ad6627364c57aead6dee9e86c1be10e3753bd7acde7a82100ca89231f99528dda82820ecd8310fa4eb01d9b3d99f54deed7fa573741caa3672fbfe5ac81e3f32cc8ac63ac432d88837bbbace589d6550ec9ab9d2db91694560f9c0677c3d1b819924a68cf975b233d3a67e159c52b7223c9f549fea4e700e5ad0431d7c4e3d34729d0c042e21817cec2fbc9b722f7edb3ad5bcd7143004b288384630f05d264db45ad0201412c850adca50c920fb0b2c32701d0a0dc01d21900186d5e111531dde7ee98d9855fdee26602193fa739d822eb85cf9d1fb399525995de359b774aff10cb1b1fdb28b6a39ff523b0060a4104b4a3e671dae0f445bf2f107c4c8da93e619b3a983208bc2bd58adb7b2737bf03981c5832103ad22d8f9a4c88525c033d808fad911ae667406bab1776e30eacc0c13dc3a321cdc4ff3a5c31f694df31ddcadc5cbef5baec902b4eb327f160fa69f3f6523206a7c29c71cfc622f1318dc365e5b07bbaffacf0a578a57b4d8707922181f2d9d24a605316c8c1209d3fe3a6f6389c5a44108a2c1e659e747760d2ccb7839113a16e0cf8c34110f8bc05eef97845eef935714e5dfeb858b69fef5255bf72bd4988d99ad1700cade26b199ff0cd4fbf51a0058782528d464bdc784d9dc134a2b9b7840f491040496b2ca9c31848b89c652986ce9b099afea45866467cba7c06d1ddf55f6cc3e3fa6dd6812ccd2944fcacda25ebede43baf1bd9c154d3343013f75ccc21398a81d16471249331fce511510f26b16373cb7855c8a3d2b4de146d5657a36384c602ef1c4a0bad84e8c4ccf0afbd1a3707ec226748b34aee7933668a728c48aee07af08a6016b32b980032784b2c3e2bf9e9c25c4c8c767ffd334bcb7ece776ffebe105ae025a90830f9e3b918b12689247959d9297da946aed4c833f96bcf90a89671cb8ae540695bfa646e9fa0305256ca210dacad8a85fd00232faee362708378651fe53e9aa59a1f3ee1b5c802e20ff6212423b47e26f6d90e972cbe82886c908b3441f8c14631a6ba0d868d94ffc1e003e6059b7a489ab9a71d93184611ae34a977f93ca5c462ac8ccea5bda16c05bf7e306692d365b12f0dba2308f0443d4236f1f2f05f6f692f65429b9f98580b589f0c5849f3e36e3453c58607b59bff386a5817c03298a5eb73bdcbc9e133f776742ed8a3accd4fea4465a21c39e88ae14de177f88fbe50542367a96c7978c8c13a89c1060379bf2f506971542074575538ce4166b83d249e8c6b99df6ca27620e35377945fffe3bc0387df4f97b6a423106ece6885b50983a4471101b67612ff217458b357b702c4e9061fe40c1c86278a21a6dfa39b1d68395117ffccc97ced72a77a2cdbaac2b7dc350a861bdc7e0726c4887cbb11f326efe729c7a1eacee10a3882a929f07f78fb8c8576d34f5c83fda9f0bca1df1cd5c1a8de9de63d5866cd98630d1ee22d3e0584eb426dbe39c69e1f9ed7bbe91ba13498ca9725d3dd203b3d6f07dc17b458aa23236083a836e28bb187c9d388379f1e6b90c5fefa164f1b879836c897fbfbd4d63f85c277572f429d6c3f2628fd97b562ada856853ec436643d39b677d4b7f7d2154b0b1fd1a56796f23e350eb628c989c9e13b2dc85791da092aa60fe9ca7a7bb4a131d38360e2ace4b1f7331ddf0118afe917ce3fb640d0ba78b9be2e109791b945b3c85b18dd0eb17828ef37726c9a6b45da9ad7b148071e0eac5b7a84f2aa9bac72eea1ebe0082d3e2a2bb0af9fb71426e2fffa6b6bd9e6148ee96c5f54e9b4ef63ead746a3b39d04b8018d96004daea1f2f2cb601868303cdf4cab3866aafa6b22e686557f605afc589d40cbd5fdad7b12780d110ffe5966e24cfda72c97650e8cfae0118c1d0e2229700de118f3860fcc1268ae774d00144f238290f00751981da6cd38075cecb8387eb69d7091f3aa0b778ce27da910aba0dfb4de05d38570c82f4632afa6eb9853360c67f19ec35c49ac74a928c7d7ca6d24c8c52073b3afa12de408d5f88c99a23853c16c9c06062bd83689540834b62277eefb1c0214d1bb9388b08779dcdd3f440f2da5833a860d3edcd5d14371d5c08c675eae45d465dc7da58f910b5644e196adb8c54a9d104f05eec48f1f14283371b8d19a8cdb8c67b8f3ccfe5643479050582b1d5bde7b03ad7cf11998dc5e6f84d343907d9d232f2b58d63ace69fce9ea0dced71cbad6198f8234d31d7c65ca232f6785a7e2587a8ceb38af580a40cafcd32e11d6ed8dfd8775a04af054d308b5e8b96dc90f12891c21268b3f4155eb9c7c924bcdc619a5828617ae95e9942f6477a8b79e4d20bebfab7e57ed1a14963d2f03850173e841b27ba08c5b03181e7b0e3a768829aaef094512a19c8698746b9ac0c0ebbc9986c04eee7cc6e3a8c3d8128d25ead08a7a67ce239eaed34f49f6058c0a87a54f42133013315a35172c7a92f73506e80a9a898d488394af19ea794af3831ff81fdd05449b5954556e31c869be5d2e5d358d03f7d47174fa9e7c1311d4f116157eb265f3e3801eaab68e85a10652ffa24c1dcc1db1bc5d7eb2524464bf346ca379529ebf222a6d3e52a394d698e6c5b67b040ae43d1cd66cc562208c945b2cabadffc55832e34ebe70db4647bb67901c40bf416ca3bf8e215729c597bb0ae1ddef30fa7b04c9d8b61670181d874c38af7d44cb09998e79638878a99a058416d54f82a2edcb02f1b1a1e87332a760ec5b155af10452264f0c0fc69d70127a845a6d90fa9026a68e7571544081700e10f6a35d3f3e3bfd5648d6fd2cd491262950339be2b07ab0b3bd9ea6ffb73790e39486a236d22e8b36a570aeff569560037f3eb6d2ac3a86d6036174c2185f5d4bd83056d10ba5f87edaa33d69e4dbae4c2c91cf70205587f277125096587fc298bdff43c27392e4edddab3bce6a7fd36028a3846547b672420d65666f3ec5c51b75db0d3906a970d6af1c07fe62290d6812865cb2be80de67829ebe7afed17cba5c6f9319497570d89267f1fa1308e812a057529452ff259f53b45852fbf82aadff15a734731727171d536a2c36c68d043d5a2d4b1e4fbfbdb78e7525dd1fcd8f1a70105c0c7dc36b33e05ec41f7ea1582f4ba72e0046c2e906edaedb93d374070cbbcbad9760ae9d80936454964c5dfd0dc127a38e8c0c70c2924cec4c42f102d956e87d32ac9e36cd201a8e3b1e01a2e80de44316abcf7cc479de51347c0386281f81d2b80929a73e74f1f03e2a60250e25435cbb893c92c4a48be23e331aca01de349ddba5498d353c40f0f1b313f6b828e078b2e78ded99b86533bd289f4018d350f651ac7320e9a96fd3d6014629059cfde5ce65480a0b39c546c4d73d36f3c3a0b83a9289e8831c40192c88aee98be77e933a05e2351208f296493813924ca7b29f8ebda98a71c55fa54053674c189dfcb29d93eec9190554a96595b38cc2880a4898323c08c4bd9957d7b0f2fdf53da3d9672986fd339c0e016417933c3906a852cf7a8e95b45f072f4a0edb440f3960cbef9efbcf7060550290e37f0a412953835c47d9a5cde5f8cbf27a3024c759d8f65b25aa89fa62389dc4e24bc3d35e9199ef1cba031fafe40353ff00e0944bc4b881fa3dbcfcc88ec4f3553cc20b167dd1a7465832b074c3fbb619866785dd1126e5fb586bbd9b2777fdac1a4875e95f1534efeff622d44076ff239c495aa01b6f1ff97a654e1ddb35f284804d2251a0d3a5430466a022e80e2143080879687a0f8cdd1adc49815ffaf1a2bc91d675b0feea2fb60df7c9cb0b7ef26b6bae665590c26b4dc17574a3ebf8a90de2c6afcf029c87bacd957c366f98f202ffd65302417f1cf415a4ce2df2d70969d2d25ccd58ef9f32b86de4798cbf6e1ed9a950b99cbaf5935f966d955431fc80b512ac89ddad65a1abf2dc8ca69ee3673c1e1a0383e0b32b1eeffccccb81eea74882b218e209fc3891031898a0d2920849f7633549e022c7f77059bde5c2efd259e0c78612faaaefd0f5a569f3ecbe098b9612f391aef5211e8c0cc47507838955adee4e543bed67eb27e84f97dac78c197d8a631ea60e82462e426677f4edaaed2a51492c7e9ed286de956680347ff95bb79322957c8ed9b2262a05b8669c57330b9db946d53eaff2ab37792578cfbf2dd1b6f8d57e44ad0ae85c347ef51088738ff89ce6077d8819b95cfc88280b8c6ab9924135bd873d52e9282b9c6b521155c42890d5e73bb33204b752cf0f2c0f6649c31a1e6dd819bffbe86e7171b57c7c94c7ed324ff8338f730413ba3b3624c2f2cd14d43fba0c65856cb7e0c0663607221fad4749d44295c1c3416f5517618431c5c138b860ad02a2ccfbfe407c5b01c90f63437122f1b0ec8d1ce5909fceafd9ad32598d55521c84d7f790e30c92315200b86fbd3ce20ae46296b9e3c549d4611bfd9f66e674b08e3ae52c010b08bcf2469a7fa182ec864557960da52e6d6ad76331c48c949ff4da2d0798fe03f49ab76832af8e960340803ebd07e11f4e1392d143141e4bd84eeacf24702a6155f393f02547a3e0e65e6410a1ed26d3136f225e51ee2975032ecee3a8413db794ac42bd9a5975090e38edc9daaf18b43da9a194f09a3a45703374631117e2fb413ef1671c7da6b865cde222157e34649d5e499564829b376a26e87c1906f0a5452266114a62e391b573456ee53fe91d86402135987885bc95e3aecbd16643865546a50a17e4d017298b4bc7a27c3b8d582420b0ff674a889e992f8b804086f3d5691866c8ca54a20b697e312f8a2bb6e6cc78d07441f41f1b89b6d099ac61031ca2f1479aafa786e4328cfc2f559d22defe3344142e4d83b3f9a4a1727463010ffd8fa58919b3eca844b058ea95a48eccf78fa327437a2210d9a589b20cbbd852fac7fa5f797c2b9d859762a7367d89a75107327377585d4c359fbaa2795f75040b4edb799c536597f32539322d2bf098d84508439355b5e38a126fab0dc41fd769501b56bd6f3ac59c951b436f3ff17e1686cc41c82653a871f89610336d542ed4ed56fb3417c3d105ff224c1f17fc47bfae893c0845911feb928dd43fa07dfa8b340896afa52eae50362143c8b08d72a5a93983d2518969c781b66af3a12cee711f5435ae2d4d01483339bd977e7554ac8c761484bc1c92e479022e877ca0764d8ecff17f14d46ec97ffc6bbd22355f13f13bbf407826ca965659ba587bb261c3f96af736bbd9b33641f4c107846e6e8eeb0980b83605dd74738cd848939345e4877b581f31f36b0eaab3d73af477b9e6bedf939d8090e4b27ff818c5c89e5fa9a3d7389bbc5374502fbd724f86805e98e33d8d4039474dd2fbecdfda55915022a227a7354b312e1aeb67ede8608fba1eb3e5c4f75bcd3c95d9c697198a68f67862976f2655c996f040d426a199b46f46f764960a45bd730ba917aa489de9cf9ce0996c5a15c80009a203358f71b6fe71d61df0380eefd463f3d3a01ff554ec87b92ff7623ca06882ba69e49ae4193c4254531e1a9396da2c1d8e2c96d4ee96f76f8eff95ac9bd3181b1bdb23c307e91cad07dcb077cc8818d76b1451ca4bef1c5228aa92ff43c7874d861886113040099375a76abab920365b99c13c1431b958c6c2f8c95084b4782cedc18737d241aa1d9973481a5deea906723ac42acc806e5d28ec4283c1ed0865e1efaa43788b1c42e054f2020dabd0393bc229d5a3d7e925c21f96955cd429a78e0e23f68fbfa7853792fc9157d1dd8fff529ad2c87dea59109bd77abb06f92620394750d46dc8d03c9492819acf9c8c32a6f876a7698a0de56f8115ee1c637afef09238c025c46b3b336b091fddc683ec62d42cf1824e763f993509eb751d5be0049c1e5de898eb27fe324474943287d3e4304dc978a48084ee885bcda874ac2dde022ecbc7e2a7e78cd0523dca5220d113272035a4eb1b0fb06a28641c7fa4473c9dce1b3cf41c945195e78d6d63916686609cbbc37342936ec373ee251c8085401f0802e6ffd6db71c81ad4cd46e95bb3a112cf9c7a9e2114e6c036405a0a575a706d8302de3843b48732f5387ea7c0df7c88b85c1850b59f742f842fbd124f46701f134701b2a9388ac531cb018d2972ba7f5ec19b69b70c72f4cd1bf7d20f5bfb6acda3aec9d1228fbc8f9706b43d954764787c1f744f70d290759719306dba4b0017499e982ab607d76bf5b7c360a7161692adbeb6aea8d0a6781b39319be4bfcbf36257570dc8afb27b469ac5e60cb63498530218d8ca6850a7bd544d82b97a42ed743019a7c473f00cfd7a3acd43da22c7e5328b4dd12122e04293eaffca873f39945d2555b503e512c804ac5995fe64f22764f0151792735245bcf2a781349f8426551bbb40fb2a635a101e4b204192fc7c228a042da93fae5a6ab4dcf4cc77313e2e96d9add49c2779b6ef384d237a84c3318a3bb4cc7bcb773234aac69514c2b8467116bebd1e94a0e909a53342758cc377c5f959ff237e786d96daf6ab038e6da0f0d2ea55f7ac8064e828e8a40c93df19b3d9d812de1f5c390430a54a4ac9e9fb2ac9080b2568d9aafb8bd8034235191e01cb9410dc00b3d6c31c3d6000423446e3ba80cc50142b79b2214f282a30b886af3eacbe3a92497f7c1b78587f23c1993985f10e7df91f07f222a7d4797b51667bffa59c04d99ed1f4549660650d2d9766b1c35685cdb42663b351b8d6caa47eb90aad1378c41d050163baa93b62c6fb8ccd0c7f829e1a451f3895ef8be0e3d16a0f152f4bbad2462c09b94cd73b9dd33c2d84e48fb4d3707fe57b4724a88a532950decb5f450e33a2dce4996b74bd4b1242705ad4fd62be02fbf2b30f75750fc7534cdcb11dad76f92450528254990a4c2dac1a7ab4284b38e1c72827128a80d31e66ea7ad372190c00cdde2fd8c5c12292df943eedab3857a89f4f1489ee5ea6140341aa0f41685246da4aa0b21fee8167b6d8cc282053126024633205b5849d7cdb70d296f7ce33867b6c40ba8a857ecd043d110fe127693d2a78d6e7df1906a6bff1f54832d8b6b704e0b9074c34239a8c9cb530bce3dc3cddb92ac47dad69f58ec14c726214408671842a8841e90b139b4a0f062278661d1329","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
