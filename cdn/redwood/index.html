<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82bbb98e4349c84eb0aed9933f530f9e3ec18578628e477a7d0c7b0a0ee28e7e73212a87c831539b0f698042dc0352bc3b3ea1a8a39fd9691e288bbd720395cc23efda27a2f9bd2fd0ee67e65d02b469957d55df120ae99377ffb120b63478f0460aafc7e456aca2f74acf791720a070ae1472d71f4a5ee36971c4244d176658436d2b2363c35ce8a92afd51c307957f05a3dddf15be19068962cbcffa2a44819d9530044a125ef6bc388f18c40aa4c1e49166c50ad41658237610bff1ad6060dfd11da3147544b47a80665d7b95820a5b75237cff489193b552bbbc0bfc721e8e53186babb324913f012012638bf3c79a577cb81900e53085c74f4571cee79359dfe30e8ca05a1b9a20a5e2d675f6b227d15252a5ef77372b6c8425ca4ba23856cc0bd6e4bbc5d0647c989b6fe42dca2646629ffdd4509f031c81d697b4f1cbbd42a4f298c960c25e8cf6b518bedb7726248987ff7747f20cb40d1629a33196541470046b31497473944578827ef20f32711257cf5ae484c89d064c9e560d2ced14d45cd93098287fb42d0ff6b83859d208f2a0144b3ee4a9e6b48525c904b04924fb8d010b974cb3bbe78f5c2de0c70ab190551831ddd078715b1e1ccf019525d1e5fab70fbe9c4166741b3bb05c6553a80d33a8691ec14dcdae6364ae650354bda9d9477270c376debb73d48644d0ccf313099fcd6e4beb8446aeaf2e6a26320b3e91000acbb2ac2aad9d90171eec45c43d94df24dfb2ae57009a5be2e045c68155b58673d333245cb47af58183d21b24552f02c823d3537270b793e88c5b37b3e51fe5422db44da905b2972e4d6fb7ff96d9a7fda81a30f3bcc83864c10c50b96b345313225cae5c41e026bbd5df8dd098049e3dc4c9018a3ffd5853fc25bd56a843a0e965efa81970d394ba5b8af7a87eca4b5c242bcad55a63c66e37a3f7a6f98281d4172a0bce8e7a87104bbce392811f99c5cf2603c5be03c35c2d0a44b0e6b9e5f58fe1182881cce1b6ac34a802da08e8ee0dc0080c3b4daf2584dd5283721493b3f7ceea351970a5d9b1ef04267fe28608035c5968990111b5047de36774eacc461b7204916b0398823659c843d065b64f2bca5bd4157499e332d11e36a548e0fdd48af6a6931e1957b6c9ce127486fef14f4844d367b16e4ed727a6018db77c4f976f74720086ee3e4d893f9a177539de8476c1df6c0ef8e166b8c6b3204c5e2c7a3bc1670f3fa27e9faa1d4149dfdb0392ef0ce08d13c35db4a3acd5e3a7eb6902d1f0223f2e3150644f483d835e6336971352008635ef1af494d775ab13ea316320a34f8beb49e357d1f9d605f416611ccf33bda9e637c18894f1f9a08730384eaa572fc76c9da15cb253f951ed2f35507bab23dc5025b2794085d89fddc0583a5681f70f1f1770c18145d42e0cd0dc39a5d6b7f1128f590a254fb312d5537d448b47b4b1572e65dad64ccc3657d1ffad27db3e46ca4cf29b0964765b62a54a112ea185df1b393956be1d60b605f9754634967d33a6873665e00360be298bc36fecc0fbdc1da2b2878dbe6e2aed4982a7e0bbd85378229181a772c4bf1310d42f469b30286c14f65bad3c2a19c23885391a3ec57722dd686325bed6d97b36703f6e25be91559790b2049be7f9e219f062844d0d3e972e497d1faebb24c6d1d0b41d735bf06dd5dc271c0d8685a09c8db8b37d6340db4a6967dfc17118f497e3a5800a01cbf6a9f60e101c7bdbd45c99ded4bd00f338b1796dbd3239e72255248bc5002efee7110678d380cc97b9f812e69766d937128d53953904e2e74854b0581cdd1457adce75955a5e3c18a45f271f57de3eb185ce73760db40949a215fbaaa13fcf99a929f814ac95734fbb670e76326c852b15fd9cd7a4597ce810992e85b355b6e974ed7c8ae2f21f6984b203af329e5123b90a5470432154926ecffe7c9260e4ebb61fc3a9c113d6a40709c2ea57b335e506fdac733e01f66ff784c12170af1e14abbda128aab86fd4a28040af15a52d89d69a8c8341ee174d06f87c7f65a69281003c83786ce544c5566c62766d3fd1f736c79a9c0e8aadcab29e36516ecc6e0dd5fa7dff9b52810372546c2ec00f436b86501f8b6e258ee7642329d7632d8ca31ecc67a0b3c975a7d221e87d5af049b65e1e5595e23cbc2cd4896ed2fa5ba8f9f6c213a33213a84220ae541abbac64074341beb9486100467f3954b042c789bd11b647793b62654d6f5b34d66529d53c3dfa9507dfb3e202a51818f7ec53c97cd2e45fe680078da4c00280f18ea912231b8b1e52f274dcd790f766dcf913ee9db5692e5eb6dd84851e910531d3add638870e72fed94a3aab72e122cda14a20234b4b19f566a174684b330fc6b426d05fc9bda003e87199c64cb0ff2cf929ceb41ad2917ccd2925bb10878f43823ff751d48edc94aa9f48e61bacfb63b7d903de1a9f791fb176f1ea87e4023325cb76d7fdf4c2bae583410c0364ba99899ac662d3f71f19d2afbd2a3a81a5d66191c4824c5cba00571c1cbf3e777a1d47384d3a5dc0337988fc4a3bc8d77e86711b8ebb8be55969df84c3eb6acf98f7065e4ac595ea0f0ce887bd5a5c712c4f7c917a34a3897e465634c68d8f09e2586b7c61a2fcbc9b9962e2d8521115f5e44f6e75fd3454fafba527d7528f1f95c747467c830b03ca8f5e863d6a0a1624404a98da76810c9656a773b072f26bfe8cc4ed15d2b1a17e0c28008a632cfb1e19b491488b1927528a16a4cbb955a063df5c68f77415c2937ed7a4d5bd278219c76c16739a1a8fa599e26ba83a7ad594949b2f0385a0fd42b7b7702df52da35a3beed7e0cee1065bf7133cef1311256470ffb332420ab34b9e4c1e63985fe3bb2809f964032fa17e342c9c4363a79f03718d8fd76b600524ba94b3106a4c305c8d6b33607187506512ac87378787b38ff7f83fa1b2d8bc397bd1bddb517844254db628e7bcb7e2d3a3c0d11cfc33f9bda35d2a1a9338e8fba094fbed523705e101a32f7601af4b93612411313fbca3a1895f0e96bc6f7a5c10b13328d4ce8946e0e5f7314afc0c5d18c535400712d14b8758b8d3d6c03b4222819b13fbf0db03bd962a430c179353327f20ac2ceefa5a693fa78f400e5bd1a2c6aaaafab8fb256fb2f49c85537fa1076bc68676a9fe2ed783791268707ee0c23278cefa2639814fd5d37b4aec2b6f910b5005378a2a178410dae01fb0e6750fdda31bb25b6ab44defd4430be08f9ce0b1c2091ad2d6f7ccd07604748658ac2240147a6230225afde9d0d5e70dfa1f19a6dfd043ea2607375eda6edb2e231379421826e7aaa8a5df75cd98e25af4aebe1e4ac9bf4e7a697252ae70049fad20b31be78f95f593b950f9b7e2be7f87fe6483caaf0522ae87521881e24f7ea058755861d8a64188dd65dcc458f400ad29c59aae22d3013db4a998e186ce364f179136d231e89ca0890257b65c8d9ed1ec6448ce0527e11736ae61157fdd2a1fa136c5c1b7b011b77ab22993762ecd741b3c2bb9ae0b23e519768bb6b651a0fd37ebd0d7d70fc71f90b5182bfca066b92226e6c05b65f7e06304a4ef725292f3c57841b1eb8efef1089839bf9a13c4159b83e54a85635b1e436f2f80c304190bf47aa9fb7fcdd55a6cfd076cdc1920d0ee66babb6b1a7681ff8a1cf41ff6021d5bdf4d895f4864f942f36e43bb5bfaaf6c6ee4980fb75ec12c3ae6e99c1ad44e48aa432cee506a3b1e8ad69c869e02deca4d26eaefc706695248d24f90068c7b18164dab9c25672c3eb24a6c470ee4d76a5c093a95fa98f3a72fd992981f7ca84521f5c870a93ce5ac461acd2db96185a7564148320a4232bac0d2983d2bcaf8957490a89520abf7bd3a1bd4c780aec050235e14f9c2a1da609fd1dd299723c25278ecea902290e60ab421b46519fbe87094dc7616fafdb7d1ff15cbeacb0e0005aafd6e53f1272e27ee3792be52e70d17871271110310067a187bbddc1d01a5c62b6530725741a882850c357bba138a99835ba354855f6db006fbea512d606471d3d7abce4511c64edeae222298eecbcd01c4cb6e9671451d5e48a949b6d555a420d3c5e639391b3d8ec225823bd53bdf85aff5985156d5eb28a54ce363b5aa624f6ce839c3ad143761addee2ab50791c0dd2c9ea5e0072f79f39032dea97f2625dfeba512a0a4f899c366b731ab54c09630f26feef6dbd1bfda125b68b2069be3d515b3a42bd2444b4d758f83c3f2a52e423c34c95532f6d0fcc7c5918b60a0b7652d0d44ff1c40fff8be228da8cac6348d3a5d9342f91e7db6f9db60d3b9a8deb41bf8e35c7b3f308d2b288e42943ebde696ad1b4ff2c751b96574d5bcd9399366e9af9b30fa870e92e1b710891f0ff2d7c77993725c3ce33a8e86616b6d2113d67e9629472b62ac5620985b008cef22789b2452359d2463de1c0bc617ad3e1b673554ecf81a4703d3c214ca49d10042db666a16f409fde5746bc4e79210ede76aa5004e058a7c9c9e7729f4e063e67813ae2b15e107a70919524164f5267adcc350b21900009d41f4d1b2faa7f422e13e7155e0074f05a7a7c7759a6b6e72e4b8b15ea076faa0508c953cbbf87a0879cdfd0af9575804a39cc4dc89de3dfc2f2ec5f5f6dce921a01c792d31117e18aee683a8bcc0abef5625ee3e1be2f00d14513585119e5c0de9bfb8e460efe7b2f6ad5bc85d953c7bdf4ee2a27d9d0925c5ffc83eab8d81190ff5e5fceab3d4dc704f2f6320eec1e1cee8f0575a236aa0cb8ecd779b88a270d9bd861087d5ea136868a390aaa88fa8104212ad26bb7ec41626217ce529c1061254f5882613f45a46cedd09dfc404189b55b32abc95d8f259f337cf21923b0efe07af9d881459e0a235d5a4f5493fc76da0649c7bfbfdc3f395c8b836a47946cb179fc6b9f8c37dd9c787ffd2d0d90fc2953564bc484641b571d3de953911fb37105ed0f650aa5d3a0f34fa51088daad261d00a4cceaaa84ab81384586258cc19984aa303984af05f01be0af8c20ab3f0fe2bb05302a4381a2912351188239c95124b5c94972148f97900c2901cbb9dd6b94ab689e452468cf7beef3fe1bf67d714936ee40262f2b4fdd9618937e48bab40fb786b61b2fa00e844e7d98e71eb5fc7bbea00a76948314fc5a005be069023ad0ee455014197ee4645756b1f4be6c7a198897ea4023cf69ba00581ba67d5f01a44a32da82508f7c1ba3240cce24c8ca94cd09b23fd5cb7ed35f5e384ffcbbfc3c1680b60527d31342f5375ec1d17ac46e31520dcb4d216a4c73c913a92d61e01e8b720252c4143d57fc2e3746e0fad1cad281607c4915a86229250fcc86dcc5942b6960f556bd2c958ad53ff273b97cd60346f6c7b0bf80601462c1e53c9c9e77fc7dc254f0879f0bc6c5026335f0ebd177031548773f59360b54c2612e76b1e77134ab3b27220464ef602df007ef730cad00e1522747073eb655b90143f122ea0575f7bb3b2d7530bcd244d0b37ebbf4b6797fb858571e9fd19c8880c8300189d187a5395fce34a88bd3c5ca0d69dd13d272f32313c150c142f3a1ec2175ee044907a01eb204c0d282115a5e37e38864bfc2e51193ea6c42a307ea86b00a22c5b368ee7dc7cce7ce2987dfaff79fe74051869d2c532efd67ebffa281b760a13207834ee4e5b1c4ddb80b99f85fae8700d499b019379aede42aedeef4bf11c49b7067f2c42317c781343f83b7551ca04779b377df892234e7bb661f97b18d0b94fe2bacd4ac4ae2a5f54d5a2e2a0b6c019e8c1520da8db30f41f6c4face126fefbb1583669498edf1698e1126f9ac6e646a240edf7908df3f55c4b005ecc6e63f1232a540696c7affb87da3ba2248488c47f832da7ab730966fdb23a659dd4e60ab2d24cf2de999e79c1a71f03ad71cf485976f3d2b5078094909035c70eeec0e8ab94735c0e0d837525f033c831a548c5e7e7318db9cfb114e5be6575fc792235dc004e44e25ff415ed7adce6244e62521644cca9178a0fa3fa8c334e32b6c47fcb3027a150a879245837d8d4be1e6aacb4b212552bcd51ad7cd79336219f781932d74e64d28ad80acf28bed4da74aa4d326fe336c9d2ffd24210bb9c9cbb0e9c4504c59325def9bc39b2900798680a1a6862639e47bf81a75be6a7fd486caf2959b44466ca599a1f8d69bd203555a2e5716c60c959ea09202971ccbbce006a69895dd1f1f0ea23558cc9e9c654e6590acb0def35c17e68e30fe4011481070b815dfab401ce7ec4d355ac6487338e1737068b05fda48906b167b6c2df20023877e4e0d93ec3b4ed1dfc4c755dc5554cd3a4087a81056a273c6166641e147fcc14e1aaaeca4bdd21c7a50445a48730030a79902c1a017085fe21194c631d9dac336fb5b86f155a1778ba50b4411cd303d53121736c3ff666aca96994fb95954bdc706442373eb51f0c6f663781b1f388c6f843af38a8467384d77dd4303d19fde6ddebae24b36e10b281e5b90f5f07cf0dc77b1376166bac9714a837c0c13018e161f1b798fa160288acdc9bf5741080d1a5774bb9545e547adec4263e0e4185511beb42bb2a46342fcd9fd67ac96b3b5706edbb15e1fa07e052098690737df71166053b39a08e4441891c74c9f1e0b16828e0dde860616aea85c978cbd15978c53c784bdf6c4a38d5b40cb2de3b4aab66bd0397df3bcab93e0b7afd139f7fb9787f2533de8366c6a36081a559c60dddaf7faac0f6a0c192a4fc75a219f3e00094278f2b85de874d6a22bc090b9cfa6f60554462eb322f2731819da8e6c68efc82daa5171398c2585ed1c233f65ac52f93d4356bef5a9498be616b76222e2993b689fdad6f59643cff48ce2c60d629768387de5529b5ec683b456365e8e836766b8a67b78b379e42a4464e0a45a8d1a96fa7cb05ac4f6482663dc3ca24eb04e559f27969d90f729e873099c85f6e59c095c08227a067326ac86b4f8d84c88d32260851d2c83b3ae51da2ab1bdbbccb56882e76f0e3477ef1da14ff24ccf7d7008464b73af1e63aae8b284e7bb3b6a487a7a849abf0e0ffaa899fd763234f20dc90499ad49aceaac169a8da4aba1ff8ece8ab6ba4066cc5cc3bd56481bf6c2a5b494567f79725b07a870f1896b845515848be229de3289ba1af8444a5de08e4403ae1efb6c02d8edfab75feedd1375f3aadf15bde9ca35faf7e87e06f8b0049121fb20b1ec813344cd48bab48fac64cea96db56fd612f8dac472a5f2d752ba15175cdebc7e3adb6366a251fd21e7115a9b12a80138af22649de70652b17456910546e8c9903e73d8bd5afef0fdca1c5b23b72f6a1efdfc1f960eb102b5f365857894fc93fb143ff9257899e6da8d604858c6854c05f3e168dbb3bd2728840b1dad555c206bba682edf94042f1b997029675eaf290a46600fdb4160e73285fb5494cfbb55c67f60d760c68a66a7f8546a855aab1bd37913736bf2e2e3494abbbf57f42fbd347e65f200db5de9e657862e2e7ab365dd920df28a15d953f1fb9e31be71924e9cf635ea01f358c47bb74b207b38a850be793ce2625c1666d0cb5a8b0e67ca91318626623ae1129102f911f2afd21faade6aa9262d307d33565e069e5d23f120da4f5e933bae30353ee82fd47e6dc2e9696203a41a54fd5f81fcdb54ebbfc5b81fd3331cbddf491450cb155a4ac4d5b561e27f85f99356fcb3fdaf60cc952ae89dfc197c60724d0f38f3d4b852613845679cbb278371a96e796460d7157d69a35dcf40d43c22d4de49edd28ceb7f99bc2cd6037156653a678e9e682670d45335ff7a06159de3ea6ff729ac28eb643a8c50e8b0f74e02a8c9e84ad695ee5237802bb1041fa013de6d1013f43fbd953c2d7b95b708fa9bb248f4dfa31c2487ccb463fdc7e0adfb2921242c771d61358ea4d258b9d6d5c0fd9a1c3d1f1999637fbbb8a75dadcf6bb9d9d85ffa15bd9f44a6e29ab69b2498b67b41f43f48a9a5bb574634e82bca5c098a9f0f620f69a251509419b19c9229317ff213dd0524e5a7d50cd0654053d08a6c8ac5d667b8c2dc0073e128fd454fb910a96c741338c7889be4fdf93b0c1298926721929551437a9bea59fda81ad3665946444df7cede0018a7bb5bddcb12ff95fd441a748e892f6d1a93e4f7478f90a1e6c39f16638e9706d8b1edf909babf4375d035051ba569682015629a94d02863c0a6a682877c8bc8c1f01b8e0c11df0526e6ee5f402af2cea0b1db19bd06993e65b4d9aeb316b12bcb2ed55d3ae71e1044d24f99183478017e4389ab9f2be6d511db835692bed6a3aafde1390f8b6dda4dd3e5e265d6f5a0a6a57257f4b4fd9ec69abc1f44ffb6d41c7e4496aa1c445f0212870d41b55ee9f0075e2ef62a7e8f2f4dc125cbf144ef998be6734844641d8b12bdedd8f2692b76690bac99dd1e22e6222f0401d435e60f812320ad45fcf9745047566ded3cbff1734c5c69f2671ced4973c9987c43efa21136e5c143d6d2e923c2daca83266c7c13308d09bb349f9d8349344b0a1aa00aa50d24cc16506a44118a636b9ec5fad846195ab4fa9b324056507894a5cb603b0975198d9deee6674ba019b19e77d70b38119cb75beea31b1a33e35d5161305aa36566e61f38f92e4f3c6b15c18c3eb8cbb92a91aa8277174828a684d77596026b817d9b23d1bb5129174b8393acbd10e07ad3b85e6000e3dbe7416d3edddf2ad7295756b3cd23f684aa24cc6befa8c34564114a9e91661c100963b60747996a82a86b953dc1e6b454280c682177f9535587d6625d720e9a5484a70c48e78cdc59bd932e287d2ffc1551c3b27f07627848517b7a1ee7ff6d9aaa2a4079192724cacd625c4d1c958ecd37001fa108db038f717c99d54230b4bed1e62a5d320cb41363d586618ec83845e8a728c63200f7801dcc407af2e0b3b095e455b8cabfee5fc85220822ff82b65b21914a7cb22f5129c6cf324c9cdaa1ca206e0643bbb411a85c080580101d0f2ba1fdfcf404ef835ae1579842fff6646af1e7a6572b47d1799c044c21e17e93009c7a42ffbd771b4326cedb1b507a13fcb032cd1e8d899276e2f4e49d681c159c26d6e255ab5b20d69d8914ef496074a7fe3175bec58c2e9265b0545e4ba4254a527996b5937be3d4659c2fc771c62cb24f4726de5f350137f3c3d019c93ecee124fa4fe5672001265b678958efaa47ed75fb28ff55ce84de3401afca8c2fc4a5dcfc2f352fbf11dcd08fdc41d8a1cafeebbf9c5e54f524e04776c59ee96a9cdb89c263affe27b687de315752ec8fae2899dfd90b0a3910a311ddec6269dcc7b2617ce936ad8a9fc92447d7fd6867105f02644519140d3c5d9ad28b7243bbae970c7b2b67abcd164a41a2bb04e28df112324ca9d14e253d4722f20135396bcc0a4239615ba2984d34b828c87e4d2ef4c80ddd59469e8fe47d56f0a71e485879b72263f4f3bcdef2b9695752f2aaec06170f58bc77760e60ccf2df6f4c550d824bfbbb516eec841ed4c8102d3167901dd028a851c21a04fbbae15a1b5d5044aab657aff6d7c84d74ea36b709a379c051e2ec1691c7a3b2a70b0336aa0e813c5aac1f41fbb9a85ea4327e347aab853874421b35880beb8d3bafbf1180b05ae6702ccd207f0c80ee48fd7d05c4f7837b97930ce0ff91d7235642b5b4ad4bd76809b795ff749ea5391e0032dafe9af8bfea89ebbe2b7c0e7497c9e43d7272c95bcefd5698c9335abb59c14c6143ea449884d68e4ac1eeec0ab82a6deab8487c2ea51cfdd12580f325a008212c4339bcf00168f4ef00c443cb6386438679cb194851ca7b04ea7db76e6eb680daf3be9a25ec549fe6fe4d823a06d20d541cf1329acf1bbbb9323bdc9c566ee04d1bcb5773240e824b92e7b381af33362ba0966c50002fef58d781c4f8fc8769dbbb83c12826911dfcf75af283b8765bdd95976685ba27c3a8daea8beadd20d48c1856cee6ca51cad62363a34f1f1638a7da235401c87d6c427b7d27679eff40adfd13c3d972c353bb0d1c8a8e3b5fca4a85b1aedd28fb5a644cd7d025a93cee9eac9942946e12e11423059031807035f312f82ca0f3348b41fd3c90ccf67070375e14bd27384cbaac69400e0435f6d1cf95ff10ebea50fa171c0207a5b7d8ba8bda19531fe895406d629ce71750bc561abc3b9a3530f808d5ec3ac7f493f04976c7730a6ead792a18a49513ac3944f196aed7d90a25d38ef40daea6a25ff975d2db1f170c7b2e089e1c48d433d52adbdb4d6499e887363bf4cac14d322f1ac9166b1cf31781fb31687d4a8a302584764be8031a980a039867be28a0612809c5a58f16b231820355182335b00b0536b5a6709cec7023be81d02cd78e0ce696a1bf16673ea491e291e9acc7ca768336fa983f2b29eb4749af0fc8f85349f348fb968410d5024c1b30acd7e5f76a2587ec265522b930f49dd417b46ce0fefcffcacccc8bbb11bddfce38e28fd480c6b870951a2d18ed11af952fbfea073d2800f43194462fdfc408122d62b7f395507795c1b10b53295317a1923232d9472051ca78df46ef0104bb37d204ebf4ed44dc1c3da2fad1b4a8e02bed9bab08a16b84d252168c3df8bab24374dad162e43d2556951af51ca876990f3dac2f454f7291b30adf40c9fc167c85f997b187ad7049b8555ece51b89fc7c6171254f71077750829599167204df2ff0e33392a51fe0b966cb90b8e36caf874692148dd7d99e3fb80df199dc5856d0e6f7b7213b708aa23121d1a1a52eb904e3479cf8bf9b1e4e4d20783719772c22a1e93972edb52a00dbc7cb02837f7a65d410a1fb12b960c469622905ac156648fe0593d22b2f53442fb4044e7c1df3fe46d4fca8bacd34e2f74b3f96717be075f0e841fa3435c21a3fddb9b8ff28b75cdaf1fc731a70736b8906e364e450a383f7069e5601eeb3a896643889aead1bb5a3024a10687ecc53247f787914ccd2c11d38ab52d7338fc50b0eaf0b4851ade92bf190055b9050fd332c073b72a9a0b04ade2a99c4743766a71ea709b75f10da0e914d7cd90e14253854d368c148ffb9779e29388ed0c1750a2bee6fc03f08f6d65c131fee887fe585e05053f07ee0967fd36e8be14cc2b2c710cc4dc39d06d63a2d42c9ab1bf1cf0375863233f3ddf198244ee0284454c30da661379bfd7d231ddd9ab8371b9eb7b994881bcb5ab7c8bafc34468c744c5dc2e6a0a8577463ff74d78d985d3c9387caec3bfc2de4c878e6dadfe0c17eeb43efc1200ac4e44be3cb88b22622599ca5786d5701e56b0b5714c6315d9b508c8200bdd14ba4b21599931694574a89ca9ac225a40fcbf8496a98ce29665b706d1deb876a2186e97442bcbbe3cd6a222f458b73ca7308fde94b991ce25b1b5054e5a33cf8fdb447124367008b9dd5bb570c62fa5a88f5c319327eeb263534dd9f8784e421428fe5ade586e511edaf79d8ba1177fabf17e0de78f3210d8cecf210da3a4940085a83e2bec3f36fd41b0cba2b23fa805d11b0c73c958972daf762bc990c4f8773e490e356eb281dc316d3190556e2435a294b2114e6504184ae6fe5b8499527bb8f78803e57d78ea341f662eb1b2e66e5b4d0310f38093a549306ef99a4592d6330f9da4fef94535571f0608f2a5701c06b0e149e9c304115958acfa87fcd05d03feab8fe657df2e39ef7e095090ecf7f7387454fd0bc7bb60d99e8b635475660a01e2ff8dd233c107632339c3e96ee26e1bcf20dcefdfda9426ee3d66d0f78dd04e72870b030cf59d4739c287bb1113a2279ec0974b17f3b9ed95c188ef360772b61482d9ef4a61007b15b265e55916a16f9f2616ad93996adb5f2ef12e11ead0bcc3828a0613ee323a25f1ebe3b2e1d596f1ebe4ed8c6e1d12e65763fb5533a84e0542b0a9093cb0c0be76624e3a9b1e22b63b5b6768242f666ae70ac0d3cc08cefb6019d774b308040ee8822a009a69a1bd0ca5f894b865abca770805f59f08574eeed0c4bd6bbb72266ed49f7a3a52a0a70a995aae131b8927ea0718c0762b1f806c527f59045d07bebbd9eaded756f1c7648c421b9ce2ee03bd6d1c636080ff8f56927896016500f56d91124a5ccb9009a17956a0c3a1834c438de4b844a276dc31083297004ad47ae3f16d28744f619843233d937052671a4ab892266f2cc46251d2a73e6a3be46ec37b9abffe66a72ccadf128582eb3c8081b06466290d5a7bbb57e88c8e5a98df7e1ac961d01b3fa53e5735cb7c06c315333ee7534be4316b4e260ac308f7f469cead743b4daa1ce586841f1fe1a8abfbdc8a6ec8ce3138d9e78b5e79d3cc597241563087d2669f4decfb491a459679d0a1213d44700c80004e81d4c10f612873595c5c242773e224d1d605f46c418c24f9e15dc99f5eb5cc15c9269c6932134d03d3b6aa6c2a226839ad181fd6c94fee38b0a62a878f161099a6c1984776513dc50caff38975b8842200b524ee5b0d6214d58d41107d64e6164670f4d573fdf7e0c5b2a76ac62ca86f9fce80ffe3879b11170e65e7ee29ebeff1cc1672fed4eb5e17ab380d0f6ec7aad498af6e0fd5e5e97611d2dfec0d3a1d1a65f8f36c033a423b03ac148092c94e495e949ddf746dfc73517a1ecc49ca26b51a31d7a1c70af93bc2f000c0d05a0ac6e004db5814843bc6194a4731a29440e7f8cc96b3cb9b13be65f7a1e6069a7438aa386064fcbda64569d7967fd3a1f41cf3430b5eaf282af7665e42638f6ac01fbecb55c1a18910b9e82c46ea13cfb5feed8c7a475a5a1b0ccab91f971a799dda41b605013b2f5dbc2b315d243d5531ae0760219d26723d2ce5c70e34f568843c2c9ecf886b8801bc1701e34bfdf2254014cc79b778714fb576aa2fc982562f040e88896e52f52c752e0ba90ade63d9728b89063497263d992b4dceee4ce19534fd0620ee91ffe7168330732a56ba909034f4a724833d7b94fb305627ba6e185440bf1049c4c229974b0125c47dd7aa2b15e9b8f6d8be41b336fb4a5b16b934b1c90a8af040b5673f6428b3e7a34953bc840f3b76a3be9ab373617796d5abac9d77ca760b5c3e262d51ccd81720499f6e96badf714b70794ebfcc33f65908987a7dad3a4774f23c9b390853647e7dd1b9a29b1374fccc18b49bdae32eade4604341d7eed88cdb53c0185c929f3fb7a402336060219362ca5fd60128cebf97de50b0ee596b0b038586066c37cdf6b3d7d8e488e702bc7535dbdd8b20e1fe3b496429f0dbe1e6ce3f9452a071110179cdcb5814dfd020bc2d751a125080cf8ff13fddd25a2c16e151360f7f0662f573b28b7dc86c495a288f2f1d90bfcb7bdcba9e441569e78f977f6ff1ebb7f2861ef23df8943c5b37b39ddf1dbc0223f6780c8c130365a98f99df0b2171a9d35c136ed44e2bfeb3b6e803bb6a8a3dc9a96cd772455b2a00f48b7e2743ac026cb74f6b8cc872ff77069b030cbbc932f3eea3ab28501cf760798f145c1de46143e821b1dc9b662774793be3b61a6219f0d969a4c9fa097a113c2562ff82ec78834944c6be4fcc497f70ba0f57aa93dbd7178ab44f92b378a9696c4c47d790982fabc5c803cc661b18f4f4a43261d6979a9e4bf1a6336dcf94a3a6e25543ae65d2f78f08d4924edb497eb43a8291b1d99ad6e293e71e13ae748f4cd799b33d00ca75a1499b51075c7d187a3241e751975efb05ef5fdc4cbbd8c8b8217f8750f4137670463ae9b88382898bb1e4129b23aed1c6968d27106091ed9d80fc4923161cbe04f11ea96d757e8ab14b9a9d9826c593708b994884378b956b271009d86d4488640fbe77e6badf3f6ef3cfc7cb91c7660f83196a3da475b318668a59920335fdc42f582ec5e3e19499787640b2c0b5f523539805c818ee1ff35fecacaab3aaeb04ddf6a110c597ccefb1568d2971d2465aab269109fa690ec61e8d7dcf312a9d573eb58b92cae3d1f8444a145a9ebf80416a6120c9c40758a0fa2e437311924af4c401580958e52656b31f30720cd7f81c9fb032903378cbc56f16f4b701b84619e65ad038cb86f68716917caec73b17b157e2f4b8062c07c1120595f55f4cdc0d459ce9c41a4d85078db71e2dae178aad93dc066ed137b1ea08545e40dd7b5eb278a036c76cf3dfef612e99a4a39bc00902038878234e242e6ce5d8926ba9f7568f9d103eefa63042d0350ba5cdf0ef68a9c2007776fa83464cb258bd080c47c07b509d471e94dd1238e59d8b12b2f2e88fc1a2b7ab17a1910d5a9383a3a43c07f23be121678e4b37d9762f8a800a20fb1b0c6c4c02c8ad402fd55415e5625b854f56e739faf09974ecd974b82143f01689c02dde27b8d4ca163aab4239ede2649ad4935ac2a046815092fc49d00e5af0b3dde5108573c7af7d0c33d9b37ab68d25ab236d4f47f9d71f6961663ecffd6faf83f087f34c5c3b338172635a98848a2f8f40d2cf5c27e66f77c03c5c381b04c062d9eb6074eb60cf64d5b02abe32a74fcedd6bc53b5c3e3ccb266891a0dbf16c7acfab5fd9fbe9d4dfdd2ea201b080f207e108720aaba7d5f83d4b0ea9a5946b626823003c278f041736ab915e67e0395ad70ba6658be728de818dcf9655a1efdf88eebac41c22fa122e19e0794b13630a706c612c3b16ac644a8b008f91adcc5fc48110b609b79b9f373c8d4564ab3c92143284faae4b1b0b8205da985e139c2e5adeb33961ec0953b16e746d2dd8871dcf79e19aa1066cd7384ed778608dd412e9f35dcab5ad4a4e0a6240a4ac91ba48be0a2f07c6742790a032bec0dad441f43eb8f9f7b41df9333466bc06e58b1fd9d4651ae9439b85a5c37884ed772f31fce62b966e1985f2e9901a4d42705c54dbb56a49a0ec4be2daa5759b4a25a72f1c9b85b5a72ecbfdf700df393087a5f34d2924aa438fe9aacf1166e47cc71c8a1b51b67abe9a5ed642800d974a33ed720e6ec4dfc6a010b1c19d57be66514793c8e2cc82dc623adafd6048bde72dcf4a0daebd05dc006dc5a0c09ac3dd801d5ce0d33668ac67e86ecc210a44b30a0044b89898abdb42e74c495ad1d034c6024f8c6623ff99fb5e0d7be3e306967bce3d1c8df72163f4795bb802f9df4cf21036721dd09ad3c88d995684d03d5833409e62d67e6f5042d5b8a67c6999bf1c9b5cc94a1c8acb671bc30389b25c633354d2cb372b599da414af85ae583d1b79fafa71126ebb777dd772c9a26ee43150da2ae92edde914b2e782a79442c63265c14f8a57beee7cf9ec0a078f73ba38d674e65edc5ac75747f458897c39fddaebfab00485a6b43c14040aeafa3d9977a5511afb307f9ee1685fa83f0261464e6d98247276baba8b143eb1e87c04b330d0e86f37b27111c6aee34e8f247962aeb32b1b876b66136d5f67e572e3641e5b83c6d8f5dc555764d622208c8afd66793d6cc2a4aff1942021caf598154f4f461809a31970e53a888299cafdfc343dc1d5d92db6bedbbb5b1f153873e034a17a403886f6d7d94490643142e87c038341adf8c6c0fe738b52c8e5f5bfa173bc7218eab458f7403b4d8a3314864e0a4611e21cca6df48db9295994776f243db86942019bdebea5f0ae23ed3f6ef807306af9c50d8ec838f04137aa2460658f93e648842eb64c2d3ad90b5a8e5c11d2476cfa259293b822d82d8ee7fa5c57f25d2330288005d99ff08ae7eb45614c5743853a66ce242cb7503cc3f46a8c27db9e7d8283548d9953101a9824c484113fce547c1df5708a6d3d81ccca8e5bff08baca3a01c7c584764cae182a60920c3ff958a832f8bc6b110dd2a1affc0cbd45fb23cfc60f0030ba3fe41982cc819a26f4e770887f1baa906f1a1a514f1916b027e203097a42574220411cc8a397b1530a437377963a545486d0ece1e67c9a9249d1859ef53e3dbbee54d9dd735bd0986acc3b25908b11ecd4070af3e207c4cda24d3bd36e6763060f9119b8ddcfdd45bdd7e191a55f4628df304584ee5951cee30313ad69845615bd06e2e0e75d02a617fa59c2b115c2d94f16df6d81a9c795aa3457d74eaaa878605e57f220efaba6ca0e57ab60a175bcb5b780497cd5a55fe1a64c36c21b720d2ce9b2677fbb3b031d5137db1d33bb4820eaec4e8efc308d4116302f5f9bca8810dca743095a21993531913369ebfa24bd298e502f0d7803b9dd2665ad00e51f30f2c10fa68742b78aff9a713d392875c9e429fc2e4bd612fac77a4459d97cd301db51ffe3438f596b7b524c2f17e32bccf13390f14950d0e80c477f2cfe606251eda5521fa3a0e108931e309abad7ce57b1925bcc7f44bec9bb036822e79b66a237c181f5ed56745238579bcff1d415a8d251bff68fae8f572f9b39c00bbf2fcc8d44fe3d653522ec68f133d4207b6fe92ba2900ada8b55d53b86cdfe8210aa206d1d9a62aef7daa0c34aedb1aef8950a733ee71a4a3621b4964ebe78d393be349a5781b197f042497e6e1951ea345d5dcc8722c73e098e824a31a159a6ad6ddc626bd49dac50c75d3023b2f652623900d160a320b52f8d274fb95893f0bf3bfcb802ddd23bba4af29af119add17c9e8dccfe5a29634afb766e5952f0e6a2c7d919f2002ed3b9fb6c4f5085f8bb9632028550c5be28db68b10463814072295afbf0e3e13312f7e31d39fa98be77772d24e5459d8c7e73facda10d4d5a3f627e68508f95f99c661f115e619e28b5586e3fdeac578c31fce3de0a9d8c29c7b598deaecf93906ba8242692b7514156367ccd2285302ed9ec9f7d96d05ba1dabe9d8ebbbdaa9bbfedc33edc6faa1650cb03bc94c9f395755ab7c6efe1997eabe5a54519521d85e345c04a2560a597619f1c79d6e002e9c201a1ecc206571411ffdf4e9676277fca0112da777c98f21e72c9d7b789ddde167fc06d37cad89dc1406be7aff2d341c07a3a6f4066a7f79005fce74d01ec7595ff973d85c1275fd9427aaa17c96ad0ae058d7f595a5d7b856ba290f13d788e394abe5797b9ecbc1bbd8ce70cd37866b41eaa0143724fb75d2fdd19d86635281ef2c7d0a98572bcfd0a234f2582c47ba741475ac0e183ffebfffa39b47fff267b7626deb6f9e4a7dbbdb46ad0b7a1fd7f3e52642c2ac553376e0652b61c6c9d594c86cae900881a59437adb5a511fa2b032737cee4394d3794748b8b4b51b438d9aafb4f8156e1e835ca6226ad825ad4bd9b9a6f42e9cd1f1a5fbd026659f5958d99b754a70879b0c2c773f31cf60dfd6fab54371337ea705bc81675aee45f1ba694ee92191f967f8b83c99f3912ceb901ff413b91da264f69c3be5a0474937f316e468220959757b491b37c4311f638a2e1406285ee52aadf38551fc27d08dbc3c4d3c9c6d6e0054654b1e9fd06527179edeeda61f8b79c7611a58ccb869301336f36464674902bdbe6a3fe01faeee11b36e8ef122fc67fed94a306c11014bc56c5dbe2407277bd979233a1e8dc301bc6992b3c55afcd39fe8f9d16c1d43f7e2b64726180b1fa08b57c97b57796257179868fff1fe70c4ed39ebac136e7be44b1acefa58000b80820491efefc7709fc6bdc43e242d02fd46eef4e65afa3f1ff8868fbf1abb3944a8b3f13561bf5cc5309a841505d57062673c29597f837348d1e31138ac101822bd011b3f73367bea1aa6a35dfb0ff4f7d94ee693775def77508e3453fab9cb0623aeee93eacde16c78b1c807c4baa0c5589b0fd0914a1c6d6f64f03cbb55b170dc75281ae3a9ab022c5c87d0c68dca3095b656f325c988df925ea178842a5215cf54220f927a6961dec0babce9b08bfc8904b9b05e04cf04de756b7847611e1c978fe8102df2b7275954b87f99a4196879c9d7cfd3f88b03e507f9299bbf8d8a1be2b9217bde20354b42ffd864bcbd0fe0800a1cbfd9b1705842dce1259c4bf9b9ba6bcf971293a401132f5c00657a7b6436720f55c49c20c48d9e4dc8e12484e039cfc9799e78af3723ada3ec8359f878cff4d16abfd8e109e071747691e47b8001466f62f3db89add8fc3366a30bc827fb436f51faf7a9fbd554c1cc8ea4b037f4434ec4f66157f69b4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
