<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2773736250d32fac860a820e34835d8810fcd839f6fc2e5114029da81d7fa5487312f3bd2c26555354e32f6698efad681393b1ed5ea3a8decc158f94eea63c3b5168dad450d91ffaa37c4cb7969fd9583ce274efa7b21d5e09e3da7a87b35b3683fcad6136f57f2fcf0626b651ed6d851ae8d6d28ff68cf7e5c4bdef1691b4e9648f61cc2dc6827aa45d6930464408ad6c8530383f537f4b3107402dad5b9aa0983dc8bcd979f1c8f4d6a284ba52d81170d209530d45a1bea5ae7993b20ce3bb5b83c56272eef284d7a0563f483db8d23e443cbd0fb8584b891b664fb75683fa330f9a0e486168618bcd65b9d72227392ac29583e0c0becfe7c8426fd563d3d918d67a32e8604a893b25a18986ecd901fd8bd2e54b4cc47f34d11e134e8856d24749d80571559b4b2be8f3d8aab01f7ca7fbbf0653b5c24aa5b7a7e0e74b387278ff7b8620510033468f3cd3b14a77d0b033cabe92ab6f3c836fd8eec302fba0afe8e66d3e211aa88386664bc26333b162e5d25a6b17cd497f5a8773cf1431d5fbeb1234e410cdddf61139b3228dfb28cc6d9d134239b0e47449b62da071c4b3ff9128b48139d95e0698cd88365b4d8fe120e5a9b7ddb7a5cc49fcee64e4616f501e5bd8311c697add2b908c50cf8d321cddb895345598b0aa906f38ac6479b3de1263a23ad222aa07657463b5d4cd524c45c2f968f87fc0c3d84184abf9094a860358cd8160dd823fde8727faef01f0b0ba00c7f9abdd6c59c5f50b7fba70b8c768a7f8617b7579687abb2a0b8073d5c635b15b59dfe3197c5fda996045b05e5a162d05a9b544f5fd8ef5a3ff322d0def012dfac42be33f39436780ba480efc3b736c3c8cd33b2bf74c3f763cdf01579487859e9daef7dc1e3f456d86fb2f907e07739e2dec66a61818805cea7e5de34d2098c81c0d507efb166e0218923584bb8d8639d979ad5dcfc2246daf6c106669504c96aa78bb316103334ffa8a2909601a3f424a7c7c1fb73d02e6c81673f1cc2b1d0a04dcf10f5f9941e89443b9773af51bf027c5366929586ced0b90c529d66f65b4c2e4d97343dff8cf1c8eff0fa46f151ed58da8b0b62b0898be4ef55268be15c4034061ce936e35c00b0e98d970d24d9cd79458a5b48bb6feaee6f09daeb8b8205428f184f916f0a39a61e92fcb2a3dc12dc09b5c21dc6a5fde5aaa889109871c1fd7f55456089beddce64287240722cffd67decb31803f976a555ea6582e4085b800ce695d1f943bd63e72fbf265fe72036e76e62da5e6090a7eaf91ddc5e0b0a967b2836958712ba44b79950562fa2e8bdb41228e817d8a3fae5562ed193a98429fa786759ab5258f510f2aef18d3c1d109bfaaf8dc4e2fa42d7fd40c5ec9514708ece7222204ec34694fc60f952f34c66c087b7be946000af67e0839c49332e61e447b79494e227b8d53560eb85721f5df0bda5fd92172cf50d5e2017fe2a27d620847a4b8f1f2ed22c1103a4f5528c6d31a21f2eca728c984c0b269aa6d2dbf5a674b3c53a85c326c66a12541693cd16750ee91cdcecae1f8df98bf4b5ebcc7fb9ab3b72652e93d34d9c4e89add86fbda20f4755de177c570ff933ab05d727147b5b497a3d2e6f4a5f00a53eceb56d381740622f9aefdad2786050361e764101c640f094b7f1f69570bae1a3b4a4b939f857790788d8e88e7f9d925b6d9a65d81c628710c237c7ee4af7e7e04894305be598514d0bb2cc523ff56269718d079e2338927110eaee8b95eb0ef6118e04b9002df7f8494801b11c6802644f2d66327cd37a97994ff6274324edc89db56e73f2db80117ef7bcdd5da768712cf969b35d7a27f1f28765f0033fb7ff0104fe3f5203cbc3113035ab352e37c5ff306590f3b59e165e866f0443d0d79130938ed99e7c1c327885593a0765937db423b52d8acda8ca0716b8f04c6c9520488e2a4bb7267bffa4f78ec996449495c8d40284b779bec2bc0f66b254fb89daadce5d03ec8eabf0986453748f0822c5445968fec500a4c2c87f35bbef083bbb2b4cb19712a7cd19467a55770f24a094c87dcd5e21cd28c54d63bfc5eb598fb9c41a07b429ac64c4ad736cd7aff112c1253a68e68ea02bd6a1dbfa6ca31bb6ba455e74a259599b1316997a7a2a34deaea47c3eaab9dd5bb123fba28c6ee55e60009fec5f0d9737b1685776fb1c7fbca8d2e64f93ca3e076d18819b254d6ae0732eec823e7cd20608545fca8338a2f34ede17ef67d49f4773d14652297756b7a8457ee2e06669f25b1c301e9a636df006abe7726ecbfd34bdda17a0246a91a00982d62c03cddb185865c2113ad94526b23aa2dd4ab9b81077982bd8c1cc42703e824af45d3343629615ea215c6b8c4a57e0233a441ae257763d1993dc43f9e2e5722de6b347f21b9fb6983eabf9689ea2cc861c7770c402e45afefb03ad8e848bc656ac755ea64138410870008e6c7ce2846f5624101ea5bde257fdc9091c773dcfcfe84c9f5f7b3264326f8814de6d4ddfa2e0ce6578aec0c32cff323e8fb0db0937044c6278ca21199bb00b6958e857a08c448f87217cbecc8ebc61ac2a49600dd669b9462a3c794de394e51974a5adee9757bb0c9b34a9e7e270b979dc7c29c283151e03619360ab2beaec6b8991b59877a99b90c03e77fc1f28306c5bce30dac8ab69bf230d1278eb2a4e8e56350515966478178b74f3c5d4f2eddeb22d2cf0c3fe3bc6a2f332c278d16f863f0d25000220f7c1b36ade699dca3725f00cd727d730676768632bd91d72ed92b525e0d2d797d746d29d664e586a9b997d58680c77fe58d5ed089b5189ed8712cc8c1153ffaffe1ef4fda956b1ae80eeb67f37ecdf75e9ddf1078c93015d944d9342baf8ac379dd4dbe5d2c600bcadefa4a528db90e4cdedcb102118ada884ad43d78f0b0609c3ebf94a29a720a6b6dfd85f6232b212268bf2a096ade88d5a509f7a56014fa996c04597eddadfec1449a09f210590ba43766608ad788ff8d1d7eb7fb18160b681bfc5b9776d62792b936fa74b11a58bb0cf3b44772c12ad2e9fa017cb187848686e3c4237acdd67aeacd7d52a81891e91e60988fdd8c1ba6f63b717e9b1264d47ad751385d933d372ba207d041596d761255738985791cd702099557e561135c9a04f8ac0cc2d560a9bf1768ef976f7345a958deaffc9a31c9f465e719654d07877af6f81a38db1dd340cc31642a0a6696c5ebfad7c77e0d144be70fa2ed340bf2963cb37383cea3658597e3933999b63d92637da2c83f745534b7b1848461cafc6737df82d3f3123e938132128597584b3008edde7e21ab0c5d1c32a90dd12c7d796a3a5caf65fe3923de14be89f4b76636f6cf9ad628c288177659fdbcdef8e26a38d13299fbd568072ff4a2ecac9e61cf69e93cdb135af72f96f47e568d3e150e5d123ac2e4ea13a11a241e83c5c1fd8f4e592b4e98f9fb584b6e88e8bb3f43124b88425fbbfd94dbd576731aba789bad049cfade0985651f3360c3b020e783d673004b9b2a6d037fe9e505fc4ca6a3946259a01383c5009fe6a19068c1ddd3d0e8bdc84caefee70cb8e498fcbfedcae07a02cabd7e76a3032388da488ac5bb96639a3e63f281d3fd3bbc3e1b2f34166019e85856ebdc31e3109defbdf28e9d788f0d09ad108356d9caf660d77316ed2a8ec187af0f908ed71f4cb85ca94b7b5afc514d86e1c57ecd926e32e18750c05a745b7c5e80f684bf40810c47541343e1ee91f6dd46b4ea86836fc079a8b7f63d3504fb17520c2ffc68e7ee7a50bde71348f0fd707051d62c2825c7c88e19c92da354b5f63cdecb940f5c70c4c3c7f544ad228e589c2ed27edc7b65e88cefb025c035fa2ef0d6e6d1daad5b027dcb352a642f22911b967732833129268dc71fd1585d5a11b4a0ed3c683ab043d91c30519c402fde11d8ef39f805e07e2d2fd34a1f7f26e613c7284310f91a0dc07351d7c36ff25d641aad3ea59e064e974f578635b4f97a9b388a641d11928afcd35404c45b7157e0c62378ee36153afd4c0fc90b8572072aa9b5be191f440b96a62850e84428d70dabc70aec501653fd2c1d7a13ed840101e21c7f11f68e861baccc662557e7b513b51f8501c8153a356d2a452c7efb7f432904ba771c86f30b306fba867abb648d30a632ae936f43245b8ea98f1dc246550f781d5a9b589cb3571d3579f373955297389650b98a6517fee56bbbc7d1111d92917d8a717446a32cbca3a3aaa5e1ccd6d86f04df8a1c1c2b955026fe13b33ed69f30c2a823c9f612721347b5c09a30fe73197495d393ed6a992567ed6ed6b37830e7c61ae9fd021eb776692974866df57e3209834c4a5a9d7e58b7d51b4dd2681351b5be463346e307770ddaa26f380ea9ed1a0e329ee7e62a1a89c819693c32c2732339cab6047e854a1950a630444326b7fd8c8cdbf03aa1993ba6651c67ad943156c2773f8d899040a7a825b525c17a06d66481946a8deeb4822330b74460b4af199b8d0c391e2a2fcb20411bca420ba5e33da8767ea0f590528d6feda3fc681bb6c536d4a9ff2282023df37929fd041de5f3f6baafbeebd120e14ea27a11c166184bdce1dfb72f6f75921b25bbc6dbc6e05bf2a94e254969a2f16def90a89c6a3bc9c36210f837fa10a995877d68da02bfd25f8dc6568c3c96f430894b4893cb61f41900e53c3603ea0fd4d7423a0b53fb2958ed316a8904ca81fd8cba64e734bc1d4abe53c70f0dd69fb5cfb9b931ac024e685e0ff4f37aca51bc69490b3db4ed56aa8c050e779599ac3e8d92045d3b253cebaa311d64b57a99ebd4a8b6745c8c7144dc20891a599bc163cf823b39c6e732b49b381ac3ecb9a80fd51bd283f5174635149fb39013a602fed6fdf74ee7df410117fac41249e69119790a8b3fa8304aaf711529b0295580af7190a1020d25376ea4337c3d4ff2956b66f783f275398ea11662d6ae3476c9069e5418f3d35e22e60d30ce7222bfa100571bce9de32729a648ae8b523d521f6c3a0ce0d678f981c2549e145518fab02c3b8be2104a9beda54cdb9461e301f3083f6cdad6ed94ab60cb39430c17bb7ecb2b488a7c8a8e5972681e9bfe52a685cdc20f6caf1c95c1a0b338e8400460c7e6eb5dca14b99c7776b5b594fcbb0839426da2c394db59f0fb351e5d8bfaecc901e8f1fbae746307ba6b8bff1867314c18e1b104b422b5df6a4d90684ddf606ad213dad20625dde6bfaa08d1d22d3330db2b7e396eeabb569c2d874c773f9db51e766b89a80187355c57e5a687098861f2c92adf8efca54a0d0f13ebd2857fa298f1903872bac257db5f7565d8be5a3bd5d9fcca1a6b7cbbdae3feb0dc0eb98ac50a1d5425bc253b60fde6e359cc6f1824f79ee70834cb09f12a3ebf26949d391ea7543ab8da0d94acb39504e1b01fe0f4363e94ca49c0e8b6acf31bb1711d52fb37886369796b50e900b076beb0fffced8bbf69afb702c762a6ffab7c15fe0b0f21d1b547d5d9c52df1045d3b77441bf6d0b4b0a705bcb8c59dc72f64b7d7e98e5037ec6b1f265c4052b70133c37f42844a8328a5417f6b950be5e1b272a8d89f5cdcf89428b54ff0a923a8d9bbf9fc21aa5a03b07a71d186706864b87d24956c1e4c2a4b3f3ad9b399a715fd23338ff22d539b8ede5bfac295fcaea6b5c8f06b998718d84a3077280b1b3465979dcb6961c3c820a29df7da6b5da0e48715cab39555f6d87ec17358cc2ed80e6ae4dea2da922f8cafe3b2655cd2b38a4b81fc8ca73317ed91719188655013f19b3a046a5f65bbe7ec5f8a8ca6c88b41d58e5e1f6d851562150aa96bd3044f2b8cf743508578c7719dc964254735a36bc6f5550137cf75fdf51c2a222017453acef95a89d32704b8e94bc391ad4292ef302d708b16c592f3b1ad70994480c9f20cb1c6684dec92a54589c0d62c7065e469fddc5d2d42e342c06f338d0e839e9ef2f6df3fc3f2bb8b87ba1c51501db4850efeaf421999f08877a12b94ff65d82f1728d0942a8d4e5cdeb3ffa7c2a4647bf4e5c5f2ac766732c9ec73cd09c0e58e6ca9e229e87cbfa93fd1fbbbf9ab25f9254bedb5f956bf45ba924d5bfb91d265efccea0d4a76ac083fcddb9c4ba8a92ed493af84805a5dfdf5a4e3dc779c40574e38bbc59e6dc43b2654b4880230850f2b95050af267f57ea8eefb192619e2a5e75495981daf03d805efd04500f6d8f920dc409330ea6af7ad09cb08a9b1010d47c8c4eace08cb9fa524f90f440138fe905bc737a192b9d358c36cd718ed3baa109d113f778c7e801bfb15da3ff594708501876269d1cd4da5acbedbb857d9ea682589e5da055779a0bf96059b499dcdf6e075a4e15e18e91ab82b8536a3fe6da0d13c209fa8f2fee8a5fcacd8a2191589587f27f64442ceba142a8b851068fe0305cac0c10332933c1ae6712bbe7c8b89bad3357068f2db95667d014a698039923dc428992257370f35067a9f04efb491f76171e99012cbd47cbf7fae64290348f820d0ed311661c410b5b92cf551c2bdac9a08d6946599310c606c20daebd17bc51b6f366518436efc73ee75520d11c08d9e544b14380bc541e36f299e932fa9f44c24c7ef4222f9ccf0261d5d0bde3bab1803d729d31c9cbbadbb4c8a5fbc32934acd4dd85505683c6b8d57ab51c271347cc84852df6736cf7e2a10921f36159c89cfe2c53b09b880472f2085a37a9f2b11ed6498cec0b2939e2ae0ca85abb6391fb4e63d8d995d0c108334e4ff4ff56c68e9189e1f98939776222e10920349d664f09d1f28657bf1ca7f4b43d44d78945965e5f4c358d69d1c15f98a8e3cd84e1395c03a3c90d6cdfacc3953ce0d5457a6c7e7d5c15b6b848011c6b4362c0486177f0704749482582a7fe0505c1b405ddad399c3902344dc27221256a065f8c2b86655492415b123caab08cffe96d462d510947ea56998b2c54389a4e44c8c920d432a08b375df420c2ef9d5a7e8b9326e58f31e78c48709eb97ba8c52683e361988d3938d9977598baf77e3f65f25300ee1a42119f2d3436217134f6fb9b17fd553f960ad597bc455ec0920fc39c899190657b8c383ef523893baf96d698458da1efa09836c7f643aab5ebcb56c336c7938596bac7ea2f3169881a083746d950c59f1589c0769fa0dd40991f66e9769bd13bd640743e7d598f3cc1444395d4ba0501d12ce1ba55fb51bc675e6f4e93fc936f885e93a65a378449ce30e6e7994c0adf28fe2021857e70ca59b2a8f1398db5f101b6ce596afe415d72ae364c70dabd5ebd6f944c338ca8c5343c537a16a2be8e266dafff47681e39baf7b44f4a4d3b543dedcdd3611030c29db484b7a1a8179b1aa66e362d3bd7a16c8c29d134030e8160bfbe3cb82c8fc948546f9cc0794909e2034b856e2c86c08ad19354cb86093634d4de274beca1979e4180c6394292004d0f514140a2deb52f87152d1aa1e87d4e01dce0051d52222c10ea3575f0e36c6ccd7d42e819eb38538f55cc876eefbccf9ecb384d784e457bb82afd57b05bb4992e062d8e1b912a8fe35d1c20ef236d0f0dcc9f060a0bf26874508a2c8f0f3117c1f44d16eb3bc78bd1bb4346debeb8b566d36ac05150d77ae9ba79e5b1676f60b2985d4b8347841a7679143e7a8abfcd71a7bb44a16fccce48cfbab03da224cef6470d423b1970a35fe8527af2e64cfc2377ab09f9c61fe60398da5b4317268fccf5e548ba054d170b60e78d1b5530d9e9c7d4e2f551b365af17995c1bf07a77251f6e28cfa256553e246b6d044414addded9ab4b75ed688812e622ba31bdca295591db55d045f9cd805fc58c62cc50052772f7ee1fd0d9857182b3ab6e8299d6a01b168d8cd440d7d388203669ee384ef9f44881af4d23e669bea7528dc482856245df0d8b9d89d1319740b0587c35101268c62bdbf133d9282341bbe43b282d978bf5a926a91a97f0589ac3f0e6f47ce73821ba6520d7176cf0b13448381af0935c7df4e907db222abe0008e297a2754e14edf57167dbdcc4e4db8e4b9078c07058bc4c72a6c51bbb8dc53baa30e7d56878be97182ccf5c0c1ad48e29deaf36d1b0dc56ae58911273e48ecac3fc6bf654a24f2c8d990253c2b97ce563f5ecfdda196f3a7e7c212784a6dc39733fa99166eca8eb21f739879dd111f1e390757861c03bcf33b9566be81cc21512c239b8b14ded372f616fb94c041f5774655318c71cbc71e72b855ff0978cf289daa849ff78a32415c7b237763076b6de000744f06165fa985043bc72a74e8b1ac25de1a9129050b970b11c3b01284624b5daeb95ffa62dc960f382fd60589f9423ea8e3b387d65811a261aa6494617254aff0235ed35300127549029fadfd0d34f3f915933cd8922a4788427b9f23eed330ca195e1c12cec7d4b21a3112ce2e8f18b0ca5fb96a53f1c71e14c26e910400aaa24dc2764a20641b5e0683d0a3f41d6de98e1a0369cd97e1fa29df776f6b135ac702a0af82114914f446923b1d659cfe803457519210936fafa8e39943c758355e4dcf1db8823e647c03e2aa4126a935e1543c4627a478fe0a05fdeb055a2e6fdab1e9fc098b2e1e705fd057b6cc02c7757c6c51070ccf63765300581e8a8a2a85b97b387ea1a62352bf103547d53916a4c2efa0e98a05883b4d4481e4049b9d3f2c7ec48ab5c3c210c20bd2114b11b663bcc6927afdcd3c07444610a6350dea3de51417154ac9b10bbe2fa3d39e5313214b06a485d36d31edc9850975d3da93806d816cc16350d0e0ee5c684e55d6494325e36b1353a0aeb3408a83ad8fd33e1a85f89b60496e72a68dea624a580b3a6a7b13cb62f9d0029805c74f9c36dfec8d739bf62cbe8410b9d1e25386721a53fe97b5e1495548f014271852628d336b7ce1addbfe1c401dc189c819870e745ecc1e9476fddc9c8a5e044609ccac0121ab69c273d9c0ac06ec6756e4a9970609b5fc780d2e759e02362fdbabf6e7ae7b704d27f534c371385d90683995c54169ad19c52f27e7deddd70fa78dc38672e1a806b0594baf89a0bfa7698e3e98aea5b386bfa577f1e1022fc1e3ad1bdf7ea8ffe3c4d2a7c9e353dc52a31dc2639b6104f35a1ba57a78dd0609365d1ffc42a55635075b9bc6cd40eeb9a94fe2c426658bb6d5ce7e273a17f38d1838faf86086133210d60e94fa2e7f1df2bb172fc1e87661e90d5f022efdc85a3864ae98cdfbb3afdc545a1a406a8945b640e7b03712b19869f5bcded979bd5ab6bcdfb93aa1829356cdb3766cb84033e4935c8aaa7bf490a170ee8de8fd0e425f78831f758c78d71a7f567714db31fbb4030d814691b0c94059aaaaa68a8dddba1173412eeb30b179b7c05555655e3ed9654c80277c5c6729fe937671bf53e024f499370f55d566717019f9877c1cb040b4337c36c5915fb010c5a248c04b18e073e4adbfe88f5c3099dfa3029019b6e2d6ff1852bebcbd05cdcd60a6bc863f14c6fc5f2e74ebfd4e6ec8c8537f730a901d20954ad8fbf6edcd30ac0038c8d7da5b022df9911ecbc7714760269116a9ab7af8803769879ca2cb62aecc6e34702e99ef9cc73ad30283fc38a294c8571405fb2ad86ed84807cae7e8123a11cceae6112c62572833ac3a0a466561e91735fd898f2f054f603757a89a0c54389dc0cb22e3ebe0bf57eec4db57394673e52c6fd6448743ce8cab25faac579d048e6121b35f253ae5404f75b72c508ba71f816471e1b08127d4097c2a5d30f7dfeaab47be900938d391123fab8a50715378486ed17e86366e2d71fa7d65d3b159784fde57fd4160d2a785a6d5ffd69499dfe2f13d9716fb41ba236a57b54aff12a51050a708c8868e095d46b04fa00830b26301d5730660ffbc4c054c56964b655f4c1191dbb49bb92cb46b7fc698be40ad46c2a590d0b6e05b76551263a6f218848096a60e28eba6ca1f383af022d0a546bb9c3b347daf19a934d5b34f683cc4e10d3751aafbd6207ec9a0552a8f202359b846251cde6a7f929086347b845e54da4c544393de3b521388eb3fdaef63561c016c4ef64b1ade51345829743d367b8a7fe879fd7b24dff6c0708f2bd2c1931f3e8e83e1fa39fdbab9b62d4ab62f5d37e42f73b839b6bfffd250c50a6f4df8e995d5cdba7c84419267980f496c59574ec1abfcac099466aece667ce4bc39d397b6d1f5daa9c38c566e2c3ae74c0f68b662a27b315f5ad67afaae5afa8a972e0ec62719e05666b1d3440db37fa20e560181c509e1c2bf64bdcac7c97df8e55cc9faf4e16c674db4a57988225c246f8d71e52d1723595c94f150bff3e1d7b8452b8dc057a9d0871892ce8c0f27c78b067b7d3c81c6d69332b50c4dc85cdb3e9bcf800cda702be9ee61de3378ed7da850ff2bb676ceaa5b83d89f16960e834fb87b13445fbf2d207685850a0852e657b6cb43ae3d2435b9f909a241d9afe2666e7077738a1d36693864cf0bb598709fdcfb37ca57fe34cc396f6c14f45f18b872ee492648801903b0cef0b8358a7c0014e7724722c298e16e793414138c947bb68994e39832f3e55a57a43d79bea451d86412d45dd22fb4cdfca0f0b2125918cc9b6b1fbf0468b435523d7bfce545955c0456478a29675baf836523b213ddac20851164b75584ca1e2e65718ec7b62a51c28db99e1c5402f4f53a9a1e7e4377e021d2b2772d831ad2cac6c5e00747f04f3088e082ea5e64ba043226e5a9cd09855081c5d761bf68bbbf52c213e6ced40f85e0dba5ebe0b1dd1fad9a6d1c2fddb158b5e7cc40e2e0c028e3cdd9f78c5aa45f0d90a2cd7bb6230f3ab09a997d418705f97c6cd30ac791424755d2c5fb08ffb2a903e9c15fea904acb219f9005cc36985be4ec2f753b99037406196556c3f0b6007f91d9b78c60246465becd6ef2184fa9496f6f8eb016aa836dfeb26b974db63e14b15b161b46a17ee1e502bf8edbda485be37ea28103876426a37c142fab9f5377afcdcdc4ac42b989c26f5e01cf0bf343b13d999fa32324747801dfbea262840e1b161a70dad7d9617b0f2dc4d11dcd993c69d185694fee288ce908e72cb0c838620c09a5e687c84e0afc3eaa8af50c1fd755a3a94f5d0156457ca297462f1c31d0d3c3f2a14fe6162cdade12d57fc3a9ce8396cb1be850b460bba3b58f1727a32963bb805e97646849f19f068d1f19d6c87522ed623d833ebf7c988c6820bf756331bb8f6f37b68932b42624b756455fc16744e28cfbe01c5bcefad523cec237f0389cc458b077f7a20974a63843ffac346cad4a747bdb438ccbeb81371c314d401321fb981197d1c94bf8fe7e714ce784313a5f9156627c42232cc5835e8541b423ecdfae063b1f89cffdd42693fc58b25d87d8ffde9eaf38fddffc53be8126872d876614c4810d600a5175dbcdaeb5a168ed34f078573db252097a4adb6d832ed9dfa096e521c92e337b0350f63ae0f7701ae51cc13de2e8194526701d346535496fd2f75f14d367ad822a70bb68990d313e8a07957b5400d084ea18747dc0c45552d1ee82d5be04eacf5cd9824d730c03b1d5e1645340e05b6ac190294c6c9a5decdfd95f31c56851b2d61be245e3d00486657482dd821a3d23b3b64695d6fdf7350c227477786480ee21b60a7b51c4b2852dd3a2887e61ea589deab1798317a8bcb5126f8c0d23f02e3d54ae50c475c03fe9deaa7d0f16e7c19b90361593d0467e1842dc1626582df0611c0cc6707b00b7bea4a1056817759cea79d518cc49e886796f7dbfcd066847de09d8a35196ea4a32bfea2cd8935361987278cf70fd6f7e8795f1d87d4adec366d5abda946a427f2500f28130ff9bbd60cdb304f8f23f0fff18eac48f96a7464798cac67ef0d3d7fd182906f4b6a9142ed1d1a14dd21c2b5232584d209310e6363d0daf4a207834f33a8189ca155c72a4f100ad4f189e67ebd66ce7f7a668e10e619c2f52e89507e174300ea540a342549f78941e4ca9950bfd892bb25570b13d3abccee1225de8cff942baf11355376806cdd63487d185a5332d22db576056f451f978b606498c0fe07db03e9044f1523a666ffa0d14f5047fc45f12bb41022162a7117fbdeeed5189bddf2283f0a34fc053e95a950e38abab05c16f8331b5015495d20a25fee1bd3ee7443517f6a4ececb30b727bf8f563161e7dfac9eaf613b4d566b54cb493c4a352c7212260c3831e011517db897667b09915126065002ceab25a88a8f0f1c642c39c437c3b111b07cdb24d219373fe16b1b1fb4a4b71f2db0196e60d37ab65a1c1124cd9c2415372c87d522015472a687392af8a55d0a6b202f6a20536192761e07f1bfaa2f3fecfcf8e99a3905a06f206afbb8fce1685c18656b88642a0222908c1013968bcc8d1943f4983b5483b2109e66f06a92b95c4cc07047a1734a56f9f8d7b6ea0575f54e99c1fd1f15603c93c701af413ee8735a0ce3827b208de56566d326c2b9267d63e4d7ad7a25079efaa6c3c24a5126337571efd5cc4636383a3eff3c997f4573e9385aeb11c20c471e7ae5044bc69584afb8097b45a31d895f022991fba914157d33baf576fb66cd5ee9472b2ebfc6e1b90ed8ca671442e4b14aeacad97a12fd8167bc60c95c06ebc68c7f8b2fee3eb6447dcd412bfec6509a4c5eb1dc4c69b5b899228053cdee05ed81d313ad370a0d69f8c4a5069563368fab74fb001461140e499b9915f4e1a61063eee55052ed88122bd68cc66a8aa3fd68098dcd5e8d1a28bf271600560dace830e068451a3faf45c4b9575cea003ae51d1d21e55b12186ec40f533f62f25a11dd7a056182b45cda5406fee8065e7de356836c807c0ef1ebd0ea2ef8a02a2ae8db03ba1474b7f452720288c5a7446efb3d7a58ed7a41e0db571877e7c81a9c02d501be28a22ef06fc847cefc5e501da66c1ade3a6432f919af944fdb76b2b8d65bca61a4df6babb25e6f6177c5a256ea929503d06577a812d57c31d889657dd44a635976fe7ead9e2c7cfe5e097e5a6ce8f321694ef2a082b8e1c1d10b27f0b5707c2128b702d3ba0277ad15929def619613da955a2b18dc15e0c98b5c3788931de90498a14e4fed124912ee3ba0f12a8696841d8d2624b6fca9e264dd634449bd20466dc70e61364d836a1304f599656424f49c9c6226dfe42f2beeba5661a649d1ad9b461f0d42e245b71deb781372295fb3cdca69456ba7efeaebd514c3af3ee6a9b0882af19cc9e8e25d13232b8d4e4aa8f260098d69ce8fb6fcf45a6f92f3b76d9c7969e4f54704cbdc119c97df688a888ec9f23cfa4c41a23efa1d97b25281d9667ffc10c6fc1bae13e9fe98ad058cf280759588c46c2d0967e281817b5d8b8f186527bb40ddc3bf57012b2bf4fed42fc7238c13a19563ce3e0fd0cf84aa473168520e2db786e8064786789357c4831ce24340aab29aeb5b715a46828c2b19c39c41caf9cd9fd69c7d38fff785bf2cc1f3bd510d913b74b797b24240b46aae8979b0229430b40f230077415b9b36f9418ef284a1c49302b262a3786c88e6e075a48f901fdf2f1cc70f104d8a313b6c9e9876964b4adbfbfa65874347dd23395599103f77c0c2ac2060bac93c8af33cb12c894f25b83cc8e335c1c4e28a19e8af2ad1b87eaa7f37c22c6d65fc1ce5e55d5f9297632a88806f57b4983393bf290fc0ebfe7e3aa7b2e346e97da2889ed2773ec3164d268f7fe0e5107bdf04c1d74a495d1e0798731f978275ccc243ed300fc5ca88e0fbe94dc7aa7841571672bf3405e2fa120d46d664a0b2ac216bd9c09b9d2546a77eb7d902be8079f7355b4ec8f1661910314fb2568d910d935c7abcf774671bc5175ab6c71267f63acb8411e8dddc78580a3fb78b726ef98d0b8add2a21d241e31c6d9cd6229ed6982a697e431c438076c96c7821c569e75a5a1f7446c62f89a74c839c6740138a2217f99e8ea2c736063ec759831ba0171ad407c0cc4a6a16c321d010ae4657b67fbac424ab9eccd599f28699a551d7aee2c937696e5ab8b2556c17f7fcbf2adce19b25e9eb50aff613b305bf3fff35eb4a8efa73e37d52df2140495d736497fed6e478a86bb1fc3dd69ac1707a07accf0ac6c574ddf5c4f7efb4854609e4787476dc6c6c7c2e14b3f7154c1ddc0eb8db472ca2e7b4bab7b742fc5e716cbd55f6efd1bb24fb6b4bf02f6db7743017982070f89df735fb18cf9877d76239f2360474c49f88855a39150aacb90b61553beceb9ff4727a0070b575e6ac49e9315a77e679863521676b97e1b1b80c09d0585dad63489b19f90f6945e4e5cd53910343799982f2c99ae8433197e999db40ebd6afe32b0d9abb11d56c1b12da7e370d25876360fd3f0cfa39b4526fa653cce220981ed633b6dd23d3841bfde0539b704d480bb1c9196cd6877c0ab83322e8c014671643269b5bd1b8adcd129f3b84e70546168a58bd547d98543be27f8bf6d95f1fda06c528345751a0e0599b5d082f90ccfc98fa1e2f6d2bfc28638c6550bf28793bfc135ac24a17a67f62423450851e91814c843e6c58d323634053026817e90f103c63d4a9bf50258693e3223c052839d77147fe0329b97bcae15f7441ed3b44ff4ccf917101f51d22c62eace20656e21ee1b3a6b0c5bb137b79462a1d5ba9322cae8f73a7436f7799be5112481074fcc35594bfc0dc3ff636237ca4d62ff632433f544b63350eeb35597446ba32e8ced068713829a3bc3e96d774f3de5e466213c20a99adbbda74bbd1e431373d1d598066f67a4735f0be08a105289809ae453f99cb1d1a47338a1a4269edf951c883083693c9541ed71cb1a1378af6f96bec077a934e06de62119a528f2a034aad6f4852bac585dda368454f5eac5aa04c20d25f9ea1b028607b041b9893ffa0ce981c6204d8bb910705a54b9e7adbcb0ed777139ce1b9427f435dc6d420e77d53a055dd831565977d362c065ee6e732fde6eff5d2f5496dd9eb1c3c95995475f004b5edf26cb5e0fcff054853e357ba5aa5751a200125a7575135192934aafa99522110e9c43509a9f2f0c66d705797b8146ba05f5897ba71b476720160c2e5c076d41c4faa7ef307f6cad150fc862055504b48e0cbf7c4380e9833ac7c2528b70753b6f83d9bd236589e4097ec9b27df5e15ceba3367ad83fcbbb6ee7108a2e9310392ec738a057be3165f20db4d3b86b49e53845fc814d3afa6eb0b947684e2e8282474792750d7b43fffdd095df4c6267499ac154992ecb75e196b9777951cff625bdfa8144f9f25d5317913b63742f8d689125ed39d4e849441ce5c3456de0e0a9139064beade8462bfb3ae3b3daf3c44cf25e298c99fbffe488d85935a076e62395353c19a27156b9a3a3c3d1be95cb44e4a8655e322c803025997e946d31498cf6e93db94ee369a3a762873e72fe3e2670b20054809711016853e176d5d53851a43eb0b850dfe1476555284bcb53fa39ddd06092882e19d758e1ba1b882acdb36858a3682094f84143ae363c79243d7bea71537dc6ed2e73905b5d4ef6e78a319c096ef7b6564ea3bcfbeaf36edc17ef2a3e0efcfe7867d6a34b14ca928ca419ba15c6562f41de177605bb4f5a14d763734ab9256619b2ad4267427289ad53ea556dd7250669f923877987b8681eab95696be800bb326080d87b1a63b0fb2d691b9699d7dc121fda8b087a1108e3dbf346c49ecd28fc0c207bddae3d7270748476bec5574a3830dc54ac4889eb77374f54d3fe5f7e03da7eb9ecdcb033cf17d78b6ef4e30413b7f5800f323f00806eb243cbcfe0fade45352a9e997f9fc451037a7c21b6ef7e90792f4a69d48608eae66b7053baec48fa00a48cfab3e713d02a3014fb0d67ca748e5673be293b5f8405107ff207edeeb172deb5ae855689bdb518b1777fc48b20d36811f409c5383036826af491c16ff70c239bae87db17cd8afb45199b2382bc1f302b3ee5aa032e0be2773bf0fcceb5a273ffedbba5ef490fc539da432ec51c1785ee4525e4c000c42bcaf624cd0fbf2de582246fc541f5eb119169766e19ebf57f0957e3a97feac6f10898ddeff1aaaeb19b65fc3988dbaa4502d35a421746dca5f504d58dd5a01c147d1b0a80147488ed591a4885778b9baabbec32ea81c2ce25a259f23638690944dc36801e077fb9eae80ed9f8c0ed8022c4063d4d36669d70b3932b43048cd73c60b3cc69291e5d39c9a6b2a5796bb9b26e9e82d99bce1fd9f0bc192d46a049c61b4b0e8c8d2bf2e6da4dba6e76d6867ca9d6150b52a7e4347669203189ca661a1acb83dd69aad725aaf02ffff798f98677be4d59f714ac27c0d12c8f122fcdf68feb77a33c697ec765e3c985c33c9b4f4a82ca7c8df28f170c91e1113eaf676811f64186b977b81250cd8d1fb3774de3d356ab62ae6577cb37e089453a111e3ea3d297ef0168c639ae4a737a5c65c6739e1ebae789eff374c0011cb6b7c92908b9a8c93ffc9809554fe9e2dc7d69692e5642f6374fe3c5da456a3e2e306c9a45296cb62b3f0aa9f60fce6bd3aaa49aed2c08a0a12848889f96cab254180f3daf487e50bd19d7c1f90b2c3417244195447feadf87d566bfb29903def5af9b4119135a60aefeaf9d64c7538af32907821ece3e8d77f5810006cf5f845b2fc3361ac4655b40e52d98755296f42661b2967ff9961feac219f8905eb1b261bca44596e44c3534432de4531077b942f3af32c33778f917034dd025cdae3e7d22bf69c59b8214ac51543292ed416db0a43c8feb0bfa120a44d27026e39a5568d2d23c19c82287199054a2eb3102a0bcc8895ee38c7b5185e499ed701425203467dcbe207d4622ba4e3b856c979700f48f3b98857966b2b6b93e257ff4fee5247f12749dddaa17e04f49a501fcf847d6849ce40b2afc65ef33593fc413f5b671ae8fb1557b4ade226a4f6062549ef5ef4e18ad2a33d96b2b82ce7540c1b1adf3dc4d61b08d89309a03bf5962d3be0e59d4f487fc535bf8b3fb862057e48f6f5643a42d84c8d623f67b4914cd2bc0998d77f9463eb3b8a9e99b1446652adb34706fa958857d52ee706a30d160c2f2823981e9fdf5e238e8e7425a3581974f7c1f691b1dd68e2dee99e8c28b2b64079c5e34a5b3d6a616d3c3f51b08a0c292b0ac782dd37ad85f6012c7ce36064b3cce99d128fc5ca73ef31b7bb94a8e589bb6e5f07946edd724e4e22d522f7547f58b5eb81d668733c541f4503c3bbf26248954df4b816eaa5e10e0de6ea4b7f15ddb3ca8b4c506224bd7b9145f64c6dcc4be3cf65c686035b2c69cbc21f096716cd256abe5e45ea229b323042e44d1a0f99a3077c6fd6f4de3234eaf7a8a52d8b789098eb9a434fc736f5a7d805b9c085ba3605680349e9586eec0769e946c4c0c3a6d9eff18007dfee1517d44ed0f686caba55015152a282a30b769d9ced3869513869ed74b5b3010c8a9a3019ac5ea3a108fb87ba54ddb3610076b3c22c079cf7eae32609747c2cb1aa9d641a81647487461073a39386f997b770f84ebe265d7c608606fac214ed1104ce1e0a73c0560b8eba37c03f319b5861bf376532b87e30f7dcece299344fcfdcfc2f64665bbac87467f54a82cf5bd5e2f7d68f50b8639b356c4ac53db36c680586d5f1c4937c486c48542566738f046b2d74b40886f9767c3e323d7deb4a580dd15ef098c8974b46f56e72ffc8266142686084a54866a35456f1a8e1f4bf9f1b80e2e00f53c9ecb321940d71a2932948787bc9b402319443daf4c18416df7dd2b6eb76a17e8f54f1cc6ef0ff867f2952043c14f36aa5ebf8621d66e5d4b0a60965e4ced6ffa0caf758cd393c7a9e336a5d52ba3c7718a314c4cd7f93236b3da17d1d6d4bb23c909e649327d666b1d2e407922847124ee68d4ebcf96e2350f01019f1ee0975dfea3f9f5560d57231caf1d6040a486221ddf2cadc243cc1088243da3ae8bb1749d67eb79bb89909ef8b3b852acc5da0e0d5193aa1f3233e9f331a1e8da21f3bfff3ae6735a2a583e6da14b79ecc1219f3365206055b341f3b87f1b2b9b633d69a6a113063a62fa354531","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
