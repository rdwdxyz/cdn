<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c6187a4d9f7812a37dc6cd45f2e73b200099bfc82a1ac593e14fbe8c47db9c0014e96efa81ed4b13c1a3675f3eb73e8eb2ed02d1e1359309aff855a2d808294144d002736e7eca81570fed10da8900acd36776022986d2fc4f2a0eb2de72fb1fb26ea36fd4145bf208ee83195a137cd54c6b54ad55dfb3c34d818d54648ce36bf8f9d32d67ad02db1de829579c7c6489ac895e94358a4c9acf1cd320dd5469c614a70a7e28e55380789f28b3edc1643efefa0791fe62b1bb908f750fe54e741461d11fb508b09789f44d1c2aed11275d7fc42e8e54b0051250b3de9cd0536e20ef761480d56fa004cdbf3054d5a512311809842eca4ecc1134b2cb494d538bdbde92402d45af6407b22e80a1ea9345af22c2ad5f69fcce63dcfe4cb7b3acaf341a7557f3544e8878b80e7f6bd9752ea2698b442e0965b48985231bd1cda2ed68db69ebdd36f930aab1cec4beabdd3434742ad31e0544bce40a39e59902ba12463c2c80eb4f102f2bfcf8c4e006e68d437e7549dc88a1145334cd4b81c59730c802676a104862b78db9bddfbf989eb562438db570741de8d089875dd275f6938795643a4f2130ec879108df61dd9a928c57f3c05a3061af129e4513d5774c2005ed2d6a4e9ee3dc1995262d914b40910dc3e013cfc68e998ef4a4ac785c459cbfce6a64d6e6cef6e0742940b7dd8c9efa1db7922c209133f49cf00b3300c9ad0ac6987757b0615a2d116794bd7259dba28d18b4722a9855b286662ff9c9277a35b635b543e4ac51e0a4de3e871ffb7fb1f2189c53b630228e5291075c756e9aba8df73547ad403b58c9f5c1f743b7ccf5c4669f858a25e7a48573ef30640d5ecf53e7abd1b7492de1de0c93fb64af17ab88ed9b7b334e807ff638ab1c94aec24139215e13819fc7db7da7f22c4689d279457bc1d2187d707cd60bcc5cebb0134628cdb5a4c071cab4f3e721f85cce1588a7a05d329b3981070f09f609e9195f06b10456579a2abf7a74e0acb73f302a51e3bdd74c07b1269a7c39be5456237989e2eafa2f02545ef5612f6537067a21f55ecb57d888e8648a945c302f5262498713e969a2daa0d39cde47a38fb884bfa552e6c62de80c883dd553f0ea5952cbd60dca533582942c19aa6de410e6417348ceff90f9dde50e947ddfdd8e591b29d6587d3c992119dab8df5e555f9e51b86162bc059e021dd82b413af12cb61eda8c9c6a0b52b39d508a1b11525ac8fc85899a96ca467717bebee760bbea8acefef296e62b08ad8a0d45b2de1227155b2ab031d6ea0306f5e95c136e3404db44f13ffddc30b1b879204fcbb58dfe280bf884382b30d54e3d92c4c1523c0a513b27897cda58cf703c4e0b84400d892b26f48155ddaeb4fe9ad5e337ff4b6b76a05458786e5e2299894da935fdffb5320c4f69c76849e1d88a519fe41e59c0c0602387795617ed85064276968ec106c2c5055d92f9566405d6d39a65efd506b97c1dccb0d4c7e29dd755821351aff26555472799db0dcc8bc6c3936cf63e67593509605a2ec2428ee621d1c3212659c2ffafdc4648fa0c1ff23e1017e053c0c0e9b77cca9102ba0abeef7d2e8f8aae3ac6255747294bfcb74b1560a5f878d7fd67c82412427cee22cfb0538b73a362283ffed2eac45e1ec017f765572f31291852f07694a67bbd470498b8f8a4e622e7fd43157448597e13a8f7447ab5e0302ea1d83d036f52da40a012435792490b380f6670fbe24d0ed553324c0e2dbd605dcda38b9361c3b4f0045d4f9f57e99529c2f5e1db48d094a23e2814bb5c97bbd3b293fabffa9c0a1c8421e5b7a09a21cfcb711661a09605fd1f1eb71a93c2e7c50e77eb83658e8710f825f3300f61afbb67332c943f34311423fc8a18b1cb898a4fbd6c234dad1584dce8167a86bbf0061a459cfc7dce3720cf991a154ef8b208a4237ee163d4275d12aa5f85c006b9994318d7e3c02bf5a8f8f658614be8a853e8828792d3fee3ca8eb0f4696ee5c40933853f3ccba84f54a29c20ee616e5a8d3038b6c9b32f920c88093fb66d2a24d9495c7c902e5afd1ddeb829acd2ce76c388c57d72c158dd88ac25f3c378644808e4aa09d682b89b569666d6f4a4b1bcaa35bb014329e698cb91615f93a196335e700002262fc391bc1752522f7011b7fddd5c2cbf326215d426d3599168e3955d90cf27e7fc4c27cb346ba6df3500c5ec3ac1894ee9362870175ad5e7c5d628cf4b951f74b5bd9752303ad5a42c9159b3a8c7dacad0ec2ef3f69faf3993892dac46de18b17c57828760f715798bb01914e57538f7eed5329b508c4c8eba1873065e1792aea63543ded7503e11c8ede8b6acffed539a9e2fdfce536a3cff0e9c5eb0f2fbe239cff2f4cd5fef63db4af7384563eee24be90f563e2121e732cfbc1d7d5b45b8d95d697c01c3cbd3c79476753152e4b80ceccda96c14448deec08b897d11db2409e6ead65acc8d9b489b9d4e55ed591fa787cd303f22d40b43e61ecc2dae92669a37aab249ea22beefc1b53a9c6c4b1c62c73e3f9973cee273a6610aebd2c4a2847ccc00bba34d3fe5491df93e9bd4f9c4da9728ea2f3aa0afca774912b47e2e7f3e6fddb749d8520de82c4c6eb25ac9bd2db38e1b73b6638734cd998476c435e9934be6e48153ff55f419df867c2a414ef056285a1bf2efcfdfff2a5c50c9c195efdbbde931931f58ef5001d017f755b69994b1caeaebeb5e6b3682570213807f30c1496499a0fc1b5a3806a3186f670bb31e5ac07ad75499ebbdaa3e5e8cf7bab51ba1e0eb3329cd8af88a5668255d5aed09dafc70b3bcb14f01e2b96c4b704a2282dc60949881f17465bd7c1208ec009ddc0c2f55a74d2ca27283b15bd1ad31613ee6ddfbb94e74c82922c9f7696ea6f28fb2b210299d589760b65017d62541cc9667b4407dffce96a5ba7880b5736a8e2d6ba20d9bf7be4fb29bca9959c0c2bf3b74d041151cddc6e963647def97a211593e33df84ba96a606454ed0d8f318552075330603d8fe6730d5b7e59b2d2f9deb2ea3f862df1989fe42e08f79fdbe3e4fada383e78a02ffba81c41acf8f8672141ecc812a8289f7cff9c551def927fb540318c6248763b6a173724244ece6322176e2693aad9d64757c112aa5449855697c34f1896afdd7bf3cd30e3c4a8dbcf93d1d0434c4a2f959fc24fba45ac538b3b81ac3a7ddc6e13776e1f20e9e589fdca4b916670a6d1a8db83e7dc3f77df28c7667d36c27d5e9ef44c2d31d08c096ee1d4e6e89257ec013b8b235f3c3ec12ea264b3ba0b6e6bdeed7ba4b46253b396d2cc7b670cf700e4b5c08ab0be48689d37779d2b2e046770b6f0b9a776776231da2c54098e9378ca42ad1b4fd1df8383a9b74df0cd5d863edb43b1d30241e19d7b618e99fe24fbabec38ef752b2745e40387d978773ea7346854b91563d327be1e9696b8d6ec8fc1925fe4f16a08e4b41c69008e04881d26d25402353d042076bf91b7435273b2273c25006aee5f2da1d6545e71bbcda1f763af4fc8a5cbec213c5782d119554cf1ce2a4ddb4cda7537217ee9dacefc3ab04a31af34b7b7bb07f7b85b16edbd904f9f251be60bb2edf1dbb37bd77a81e76c671c52333014e6561083902192beaa0edf205aabc382635baccd53a2f8419f157eaaf700c2ff147cb0bbb6c7909bb9ca7868f2299c8de226317836b030bbd71ba4cf7e348cd5091b527cc15ce6ba0c150f90e6468b6943d3eeb3a23d0cbc68585c5bc9381f618f09134a3abc18a4af639be30b1ca8d36c389393ac6ce02bc4e86cb8b5ccd5e46db4837310e702c3c7c39a3247c75af7658dc24d1765b628dfcd50ac7eb582f444495b259bbbdf6aa9812e5072bf23edca7dae1013030bf123a39c727674caf6e1ed8bde07f8ebc4df0cf9bdf40bc432a123b828f61959400ed6527382afcc4980b65cd9a3690b48e2ce089a59214516f435b722adcc141f87d0525a861cae31099c071312385c10a2f536fb4b076977d34827722e3d15e7bed15113c57ca6eb69d5050d8c748e1aa0edcfd63afeef6ce67e99dcacb58a092b41ace8adcea24fb7c08e8905f2347209984f3a5aabb651beaac48f4847037bd8f873603ae39af044711583716b81509a5c051a6e3c6194b2942e155704cd7c0db88151655043a53d5dae4c9a11fadd2309fbfb92aab4c759654c3929d8e2fa84c8425ef9f7b86dca58497b64c5bbd18d697eb1cffe158a0324f6f08655454786e479be5b1cbefc5c08136b4fda18cfe54c4670fdc2f63a71a42723617fb2f28db5d048a160e5ba9d701f1a02d188ca2b82ec07a3a6cd82de1c05320c09cc801b69e2351729224614378453c118ce4ed4fca2091d6d19c87d80c3018903945f6891d04545df7f1d03c23e1bee4c777a76032bea1d67a40a3c6900856d4a80d7a37969ba29d71dbe81a94507bac6a569701afce5db8863130e88e881eb2d4c63d320d404c63e95b06cdeaf6f6950dac7414c6ae53c3f19c32631d79163130ff4eb7bb3cb35818c5dac21d8603ba70062b6df55b7a466e7edfc67637d12d9087089185e55b298a6d1ea91ec2845ed4c9fc6118f32ad8e14b390bae07aefb2eacd98b152e60ff9e8ffbd93affe4a0616ec930d4a0cc0e1727bce78ec986aca4e64ac91ce181ce6b66020dfcaac8000bbc91bb48a3361fdf2b7781de59adde495bf06b6e168c297c7289ede797e81540de5407f385f8a745ca2a7f8c5817f90d4229c75907bc0ed58ccafc05cbd9c2bd20498102239505fe3daabe8776e3aba6f9ff97f59376002ec64dff4ecdb4afdf50d5e51d8de4fa704c91548bf17dcff67d5c53e86c7c1a7c0e5d42a6b78389017b7d9771a88793e8b4f225c27f2b8946cdc7da62d97dfe92b72e97228c1577d605d041593deaba75094c06796bf3ef0d2fd6e35f3457ffc0d50f2f2bfe61a3739efbdffb49c82173245c1e28c7292ba37f8a5d071a47318a64ce8492cf286ffef170bb60913e3d379aadd8f9c2dda85d572512154867ff29417595c28b805fa7e0432241016279a2422dbfad8246d0ed458cf099975b41b2f627c7b9d9b059381673e0b42859143c15ced5dd5ad22c935b3482408f5c2fff8724792d69a293e190c0aeb2bc26b8b65ff1d09896dc59958c7f3aeff229e086d94453e9db9a1b332aaa4863719fdafc09e52263868c59b354621368816c2b88ab9eebf4361768130b0ff79d93c3baebd7f8b632219b2931c4f4707351f36166faee1746b9705d8a721a687353d1af6ea7d250a0b1bb0717558379c714926f520690d1a97e9a7a88e1023c204c305e8fe5abf766db4e6cd733f66a50708ec06a176ceb7c9ee302398144daba80a257bb90a45b9c35852a453750a60e17eacaf29a9fceee006bd02acee2f09f6c8dbb90fa50333917955a310a8af6ea8e8c4e0f96e0cc2178318e4283abd7ce43cdb43ad27e965906f7dc207d6b57fbad6127cde8d8662f207b182554f48db77e808148ba8362a8d4521a814bcf2ab1d29bbb0d921952baf50abf67aaf3258e5e3ed3579a63f9a93e2b36f8fc6157b33833a5c3e56d4070fde7c617ebe63730b52f6d59adb754ff3249f9986039f4cd06050f6ab53f77af091bffe08f0496157ee058b0c2b86d143c2f5fa5fa0c9e5cef2a32fa59724795d8be5b6d957d21b1e74cec92bb6457edaedf29e6d0047c6a8f89fbdf583ed3b9c4fda1ca22bc42cd0147ea983e723da0075023189953d157793b8a46b42e355abf27981b9d6d6aa58b2b9a204a12f3f264e06918a16b86de41619a1287d9937acadea2fcea2a3dac982693200d409617f45825384de11b582d96ab9cb135eb45b37cc247e9bdc8668f0481ec57f9185ef4ef0f7acc960cbc951efbfaf9b60305608a9e4059b1bb6b9f956ea9af1631bc49c8363336fa7f0a727ecfde23671047d527ab72ab30502a9833efe908374cd1d5cda30e57d5a066ec9e20d1b0a362d9af4910a4627182b0f876bb04c061b4dc49ba9abccfbd5d0e80fa643fbcb6b5e7ef31e42e9739e3c7d9eefacf1320615510848ee5e23f19fbd61aabbc61b9499035ce7b8178de233609415f62839c114781d98b41922c2a8f77e3656961c55eb26be1c822ad5016983566f88aa13a619bbf220f4f761d352e59950387d7fe118565320a688418ab6dcfe5bde11588967338ee0904664a7f59de8f40cf2d77853d45896162df3423b1f68ca7065d714d63649e887498bca3681c089dcde6a3ae24995782f96e1f51715a263ad0db2b65ab75dc21e72c9db4c98bacb85c19b5f8150a85450974505fa9a2fb4c636bd3e91676bc56a16548d61f630b709746617204dbb765fa9826feeb1706ddb8f3b9d15b9bc78967ca2df4d4eff39a9bf2d87bb112a40941e10e07da5cca528f0ddbd55fe03342c4427781880ff89c6231838b514845370c983917cfab914fbe036a9cd16cbafb6e5377ec1f6d7b2e7547d926adf353ebdbbbecaaaa509babd1b415796782d1f5a0460273ccea730f1c236d9c35d40b8926282b4ec9e2298e18ce9d5ebb0e3b0e115953b2a71e57dd2b8df57bf21f10cea6f8a274bc3eb36422ffc1f6a677163a978c03ca704f75810194524f91eccb9fe0902d89a314076b4f2b27890a61689ddfd22c42184fd10d286bdc2722905b23d6cf44506da0839b3d80c9c4e1917fb584cf7c1dcc0b3ae99b28b246d145462d671baecc1b9d2108236d2ea98db995c83b86c4df0b2e996c31da30c59bf5e530866d180b9c5534be4f738c524cbd7af141a1723489d9c9d9f29683dfc71c16938a17bb182da825f1b334bd724d033f6c55312eeffb236143c1ee3916324044b345fdc0e9b0aa5116714dede5a73143d075cf548b4c47d3aac5ee1a114c8d29258bbfc8f246a1fa0212c7c5888444a08b3103213988c9a6eab51d029dc74e223fd311111f040529fea85fe7587ae7c5f29e341aa30ffb0302487953dde5f823e82df1bce9623ccd4b6c3ad8b8904d22cb37b8ddce80d7bf2a15de8eb431a5ce63711fe8b02133940ce5c1b802ed7bbfbbb792f5fd7a1267c0ed1817126aed083d31628629a20cb3adf625eceb202b41627021254e27d099feef60f7514cf6f999da0e8bba03ab101e238fcb358a45b9ce122726ca99c62471301cd0f5d5d681689a2e511fb8bb07d141cd3ebc5e2d00e1a986825156d5a8b8bf525d09a5bec517a1a9ce38d2f6e78cccbb18a35ac11d39a33c7505888bcda455b3587124e6114e78137ac7d1d5669b89c1a3b4967c6d32e9d31ec8100e924e047afeb2bb45bfd955cc36d11a2c50effa08dcda65fd6e40bd545f6de4c2a741584a5fab26d475eb249b2696a775f69a5ea5f1c6027f36d642772f79aef3afbe40d457398c72add968161879160c188eed20cabfcd7b23cc9948ad288222f591b1752e21bd0127b932a7190a468ee914021e2286b5d294a678c635890b4dcfc2bd769e69942910566649b38e71b865eea3de9304164e74dd51ebb77783a58393fbc3180e65335f1dd6d63e1a350a6c70d05798bf3135c7e3c9066c273c42f65a3c53635f42a0886748b9daf5786b8f3f9074bfc552532a3f90aa96fec19e897228c4ac2d4d48379608c7e95dbc1e4891e749ac5b461a857b77ae6be9a3a6c32a9c3d990a1e42874e1707c968640a1c9f2d00c913b2d5e960604807c4303157a833f981205a778a26c03f67764d756a0edc6abc96ffe41796a430e77d8caeeccc3cee3d898894e28f5842d8ee6dfe8a2f49ec5e62007595fc447e459021350a533042567488dade8164f3fe24ff3f6b2fa5a1f9a88ba211477c4bf77fe8ee016bdfefb14538f8cb4a1a3ceb89ae83629a80c03f973966cd9f2c978b7c37f2d95d4b521b39a45e60777628d973ce506140b9b30cb07fa605e3664ac62b6752f3b1a95bbe3a351ee74ec60cacdbec1a6ae92a95cdfb519a750aa82a6a808d2b7275d8031bc239d3bdd681458cc746160998d6d96240160d40e97b43608194774a40e651355c2cb50433408774c66d2808b38da13ff0b411eb2ace2d8c87415ccca0766647e87c1a16c2a53222fc909ad594f748b47a0207e5256117efabf78a9008b7b45db0ecb35f3d8b57c0c680a614fa42f3a655506ba5a0a60281e08ffcc56d820fa6965e3ced3953d7d1613e1f52119c25271177e63e07356c89b6105244ded96e95d29c1daaf753c53f8fd58fe3552bfdcd4f1921b42a4e35406332fc0fba48ad4339a43d4732483733c41c26c062e4bd393550374e9cd548f589a70244a795f3269bfb7c75d224abf0cc0f3403c3bad4a1b07770f9f56af2a34a6eaa3b700f7d2b015beeb0fb51f9732485c5effb642b3259f0f8edd578db472b4edc7e47319d8c75bf13e8c4e660c6e039bbadb07115fd4e1d94cbab2266541779fb8548284fd351c956a67e4bf62e251d0baf85fd1fcb4a6f0c43e348d655036ca695dce2d834275d7f8a6144caac1ae7611ebf7ead91f1881cd618103521a07ad874ef8839be7dfef0dfa44ab505dc250a8659b2002db7075ade24cab977cb99622c04856b4e26597950124218f003f44dca0d1ab410fa5660d492957145aa3a4c9de12a800bd3e6f1a61aa3cce3b50c12929237cce6f2014ac67fa658fc72a2014e9873be96d70cb2534c334cfd7f0f2bb834df9c668525e071f7f300f80082353d8b0a5692095dcd4b8fe6b0a1b2f0a2c44dc45ef4706cca0ed76cefb2960e6e53990a796c92e0c65e90f6ec972a1a8a9bba76fe4cf77f1ab6c4c432665f52318570b829009d0398fb08aba76388b71d311e5d930b4f2185c518b38623c08c745458d8c4ba8b76e3b8cb7d8817314c5d4b913d63f2da8bd38a0097cf6432b6ac2e28bbd74f0b7e892e09931ba449b6d89e14d55f6f1c70a79855fc46a73542bd2447360559c6011e43b9e9915424949d5e49110c3c31f3a389971f87e698150ee2490144523eaa94dd41da9ae8b7895287383530c23eabc47bdeb103b7a42549c15e82bd4f8502331864b326fc4799970588677325f812dd832f175cac993b3929c93e7b1120c37f0b10fc40ed3bd587f1c8c24b42aeda66d553c06322ce4d1f994d48e773565094a14d989b98fedcdffc8ca7d6558a214fedb3dc2f56cba0eee47b8bbf5ca1c2dadf63c21cbe1f8e99f1c4f7ae4089361aba97684df9e410bd47a9486ca3a30507456057161e314992527a5828165497503db6f95695292e68ea2845102ac57f6501858fec8bd6ba1915e3206e6aa05a2983a06d30b22242ef6d23c1683e06c43d0da16742e91fb04847e6b869a8f01547987b80612279753f605e745d5243876f2c162610e22ee5b85a39655a364adda759721ddfd6c6872f37f5c3bacee032fad6d241dbf9b1157b158b7ed26b341982473b0e5d61ecd4e3cb142a543e887dde89545a4b9ae8e7eb39731e7d0a6cc61195444653eba76cbd4067c3fb516197575d2eb80becc60b96e9f496a788012241e016cf8c885d3fa100e10d4703f057fb875cb68d6614df14f4e40e9f9b6bbc6338870046091ef2b02b89090ed4536c3ab25fa4191e288c2096475298aeac8fabeb3970cc408d40ee198b4aafe854cd5967713cc9d03f2daa60b1faf10cc50595356e442d52f66f43ecd3dda1f1d26060dedd1d09d14d938d3b0992831daa133c4f9d5902c2472ef6bd0de3452554383251cb0ba69e4866ee88043f54d7ce96a007473a6a3d41f72c9d9929618000f4b6baadef1c4c918dd6dff316fbfb7cad27e8904c51b83df76434847ec6ad27dc2752df94f063da1675d2aec0a595355edc7351cc92e8a33e06fbee2a7df3233e4cc592fe8b3784842a420f3704ead6ebf7328baa704228831e419b0f2eb980adde6653545d22273b5bcaed938b07c07b81c43d82fe91f051adaf0e37ee7bcda1d6a599c81b4199587dcf0478046a5d11847ac8f83defd8b8ae5bc271b90b03f49ed4833fc143ffa869ed1e21024af3efd4b6db1fd37b53dd3f190b727ff093c91be4a6ec4495fa6c49d5601b26c719173eb43cd34314c95679229b2afd288f93cf5df53e135763bc4d0d75c2964f8566bba55bc06a64f58504093fd4686d8ecaa0d446e07c60b5d3b59221b98a0f47d88f551654fb6c2fbc3a655a61f58401edc5654f34e3c4b6110938cea34dae3d62197748df5754d3a45d23fa39908efa8097b36c949594898bde9744e63be7fcee5912a3cbbefb3b364bb597723a2815fbabc88e57c5162c5e30b1de70c6ac89461c12b0ff175d32553e9869d7293e1ea9036bc15470939d3dfea33c18de6486a10898ddc4b2b95d9f51f6f1db355a12a351c05d4d96106d952d9757d083cf84e5a039a8d09ae257f4f2221912e0643eefee5ef7c80d064213c8fc7c04d747b42985c43c11eeb183d3c0a2b2ac4cae68516c17b4da6f30f4c40b33103808d1f05c5d1c7c35a00009a8702dfc72692f631d1f2fbe2a750deb71c90db08637227164e7fb32e24e1c2697bf1c7e443369fe6488240e9b336fd45c53edeaf57a184c60a1c6c08e057c4a99b1523f74fa2be02f0c1ef58205079f333ec4731fd361fa30670ff83ddd732dd8cd8c29d58a7cfb69f63c3b4f662037efc1ddaca6d555a0f45631ee19a7d4556db160fb0ff69fed7a79b21df28e202d607ce535c7825a37829e2bef0ac086ccf17955277b050322011cf4a2e17a4384db23ae235695e4f28d4174dce0b2fef00a194c0219f9c203ea244a7fc6d021b42a54d261a08ca9c24d5799e164015a9ee7e07c245e28edc09f3c4c52e5d88db2e6fab2b2bc587f840adb99b233c63e7619fb322ac9c95e23bec5a6b7da91f50b0c01d6196131c83d1b719a0cb484df33fd82d3fa0873c949b31010d31b41c746f65780618838b2994d0b116f8e3cd63f7096cac5206daf0dfbc23e73cc3b6afc7f348447f62e611ce6e2f88e7dc679f03f14ea5470b4b325576f2cb52ad63447faa2fee9a332e50b0bc9b4c7dacc98842d6cf4a4ea4122b63c6c808512ad55495e14e154bd561d7e78d1abd505d2865bcc8229f15b7fcab1d8ae40517520acdc0c005eefcc6e7c547bccc29df7733220a23810ae237a1f9a1408ce0f5c975432bd83c7d728b5984c4f5f62169ae66a970a305566890da3ab32fd129d10722233b97facc89592711624b74a0340b2b0ea21656340ee67d2c10a9c5757301ffdc8c1963d2d26e7ab239c575afae25695f32af816c4b3551a84c847db4cf99ab2628b7f19c2b94361338023fd347e62709c20fc979a490b15cb4693e0859d3084ee546e05117f2fc1b3034361c4278235b958a0f2759f5ed014f3ce72fcc1bc3067cddb228a7f471b57935076ccffd4359f8018caa404dfc13216909dc9028b845ada4a8fa67f962fb4289d1b028243d04ba12db5fd1c834741ef05d09385334664245b34bee5a1da11951c1b4e5a9a0b780da15472596ece44f44e4b7ed704fb265ceeb61bd5cc416fd029d2a5bc46a0b8b0fccbd22369b5929b6529c73b3aebb12998b111d964d5a86e5d864081bf915fc9d664deae9d239b04dfb0c40d25b54c8c1af6e46be58533a8f4833743b75a06b54c8aefac173fe494af70a22360d089d542fa0845ab9b38d075e1c447720fc3ac96c388fa17a49b1bff842b71ef0d30b40b4016bacf2b0c39c174e915908d733bb13fd761e1693da5bdb4eb791ff07405a952a8febc701b4e6b418f459f217c827afe2cffe16e42e6adc245c2fa30dfbbcf0de315cc6be461d12b8ed1f42df7dac64cf0407b2002be1b2292d2c92c737fb94603c2be2aaf41a5aa53ed27c6d27db6f471f34f704ebbc2bf1b94f3a74e936b929f7ed7065b4901c75c7e6338486aefe7e6fb6b387d92226189fbe28887388fde542a7366933eb2e33c4ed0d3aec03a366efda7b53d4aab3b579e40c6d47b42fa3bcf226691d248b39aaab3ae32e6020a05ca6041288462d17bd91e6c7d6241002abc9b51a61bc22c483e67ab172cc3396a4fc753137924c3623c4fedab4310b7cdcf3069ccbbe7e8c254085e5b5d93f2b2e3f1b82ed8165ae01f3d9a0237298fd58fbb1e42ff27c678915739318bf6d0a7b4dd475a44e8fd1a7a11ee4f4a92f8c7542dbd5374e889b1f3cba30d699d413a1ed101e00a666bf77e609ff0312c57bc8b3e8425de72871a9ff2e39ec36ee6e50b346f701b2c59a6fd66e8c54c6360e19568292d12ed8c92b1111a47441d7702910a2b5d1aa5bb516020d358325d5f4f440c641a2191027dd316c410c8ed94ef6907d40ddcd080f65caa9aec4cd6561b0a38c9d609da12a880605116fc350933ac03ea8f20b978921373ccb67df54b22b83079d5df6274446cf19a68d0a21a014ce45e9758ab4c7ed89aaa9c8c62767b4b6cf90b9acddda7b8d1eebdd0d2487791a864e6077ccd5e3a03c5a2910bf48e6af94c7b81c6221b6b9cbdad675eb1ad8139beb5c75943b68ba50647b5400115302ba7ff59a647addddb568ec5b8d6d163699c6b609fcf5c3db7d166939fa53bb0bc3098e694f6527cfcc3987902b28e476ce7af96c9c2d00173d532c17ce7d8281eb5d65ef46889a930bd435e32538be7a7b08c437af7959bc80e863a079d8d4a0a77e915524a13daa1311a12d9a46cf36df4b32d595e54c95f09cddc372f68a25df66a169f9da5850dad669c5f7c15180515a12ad9d185415852d8650732930d2929500bd22cfb7b0103a8ee9a9923b926b3530f5b985dcfe2484c5c08bc2771605c344fda20039f4aa64933f6bd5921e1642b33aebf6d5b58023cdefcc2b96b5cccd21f39087e180115fa8d3b51cd56d36c37a0232b9bba626dfc1784f18e543fae39cd4b3f029b458d159f6dc21d1e41b6cdf11e722b9304d442869caaf01693f69a7950c1b1a7a66bc8d9a94561a93ad2dc6fca6e8d0a949f21378d1cc74bf70cc5a2c0d0ef9d36efb0880e85381c2d88534b76b7ed196cf8d11a81592f1f7acdfd338da00b081700cb0bd5de027c847be94a414ff8ba16e90a03f3b7fd8c0ff990e59987def116a746c2477cb776d0b0fcc70f8edd4f2727933796347913a1d1994e738ad3f97610c8d5a97fd2f3f364b48f04a75d2261468858abcca6ce4760bd7e1b05f7c05fce8a85f4fdf311ed4a8bfb1c223f970ba526d68641171d6229e70de195156af97387c991338dc8e5db345823c721ba4a8bc2fede580870e32f5f67f872a6eebe6f5b2329155f04e3a42dca15134cb5914593d557392cc95f4bb3cab8095769d870aa2e1030cba321f35eddbedb3bfd9d7413fb321116787e8d419c8024287511610a4e13de96a094f52efebc8f29943cc50697e2f80ec9a416760808f11e93dffa2c5784f104c2a7ecc69d9bd59cf5b8795d73eee8f906602876d3e7cc99e7aa2f6b87d48c37d7f37004c627c31c27f032650f07ed148c36648d01b5d2356c1969e41fbb0ba7a85ff6c24d706a078e5f9bac8a38b1f95af37711e442301aa406532ca15a924860cc8d770948551718d416c83ba6e19831b87245f136c6a47dd3e771ebd3fccad61de2e6821ae08ccbb3c6e0ca827eed3796eccf0013e945c13b1305a541ffc6272a0fcccf5d4ddd506b47e90f1f511e963cea41447a41704390f59f93d201d05e419a6a244bcd5e11704a8e257c25c947bab15f445c832046b620365c78775b8b7bb5c067e46b852e15dae0a8e08d68b4ff98053007901516ab7e4cd5249ddcdbe8c084c9bc8ed3b8d7864e2c7d841187e9bd8e1a4b8100dc22f4131a2ee77d50310d77634bf6cdd71f791ff4a063ebf229365bf48fe45d90170143ec301d0a2fc644bcfe95994d21e4c3bbf0b50f2ebee606646d98bfc74029113834fca84f06f9d46965b84e2d327c29777c11970b04bc36a089a1beb0970a09991baa481928a46a8e65248472329cbc4d7d8bc6d69f801be9ec2c25d106c2d0afb5b6b5e1e4a12a7ce4566268abe9af4c9187ae759609ab4ae4d5838406f85539a14291a85ff3e62f5a5de2dfb8fd56d479c17fb2aaaadd4ed7c648aaf7b8b960e27d6ed42c5e92d4b5b0028d650d2faac770d24eb7cb1a96a41eb8662dc0dadf732aef8272d7302d7f077d1e7a77cfc2b32417dee57c7c8b6df0e4164d92f0256bb4513af9783333f11a76d9d269c86a2bf2aa5f722dc78c9a88cc8488190065c9e2930a3aac78f0fa06fc9fe2946a04c327e8f99d482e951b19d3a1944490348a17aa83695781f163fd608111d2dd481ac20bbe4945e6665a59d14947399511ae36830be39b5d84185f388d0353b88766bb2eccf6c330e6cd3d9029f13498d5ae45883832b4cb6e6d2ac41aea26fa51c2a164a8022a2f03f3563f41133887b706722c769675f9911aaa2051efc1b61902650f3b2bcae70571ec81010b13a9ef149a9d0eda80615655c41aba8b4ce42c219ee6f063e2a621474c69d3aecc9f77d46255098e7fddc813304a3cf5bd49e7f55e0ab4062a2ec3b1611f9bdb4fdc7d6f623374236a75e79ff0f955429578cc2cd47daf3baeb9ff761108689499d0c2b64e18b248e11f79f7a9a6e01ea66f039d2f37956d761095b630ba7decddefcb622862011ce13a65e8be7a359a3782d98f9d90e2b342af618abeaac5e6b9c662d492432e61ed7b93ea06eec750dda7d123882f661f8196a99c975142a49ed19654a0b6d6e11da18adc07a013741e1f09f5710fe569b7adc32baa0b4665a5905387a77e567afc2d4420c8e98e6a7b1856b60f3ea9a5b0356f2a964fabc8656bd5a212befa4d95c7089126e1dbd6bd379ed3ff8e7a24217f717f4ee5bb212ceedbf2bf19c934c4ca081cf560e93767077979f964920b2dbe53fe3672f4617965eeff154dfba3f04f11f61011643e4557a4d77cf3b7f4bf9565d348448a86850796ef5b52f50fc7bbddea1ea8d3ea72b801657691cfbca7beefd2c0bb8b65f7d8258dd230244f3ff13e1518ef27c03a7c0a6a5002ea68c723d64556b6fb2d52a9bdb79e094f4a929452f05b59059cb5b880e09dbfd2daa33e397df5a5453cab6e986ae00786495c4d7f1dfcea843455487d816c7db6809d5c30eb4c28580e719d633de0c80c6bfa1d7f4e7d1de8af06bf6c748be69e66c77cfb488d6cddc159a71d04125f6b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
