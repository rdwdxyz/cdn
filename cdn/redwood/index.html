<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86761eb7077733da3a4110d2d40b04245e6a5154b5b91a8a02ed545bd0bda78ea124f9dc1c9af80a8cd187ab018bc8a475b48a85ef7e8e006efd45989d696d5cbf820b823026f2a27e1707450341bd6758d885a0450ecc0005a842da689709cb9402c3d27cb4796069f2ebebccb4f08ef6f27d81abd52a39fb43bad189e458acec8373ef9e5efc83040c8538a0333e2249af6ea16387aa995a9587ce44f2e7dc5d7eb4503749a2cb29368883acb69e1905f0cc9f732a19563f93f0b034800c5a85e2dad715dbc33c8bc419fe75f3d262f4466352352fb96c9512e06cfada69b09db6f25cdc12da9db7f91b829c9538178fe4c273ee138c35e348996393da42655112bbb6fd12fed88209afb76499292c3c8a10c787300296ec70282da764cc6f661294e1a198a85ed957ad6dc2eb93a4ba290b3b2b572919e95a7c9b9ae5dc62e3c5d37249873a4c156974d5ec7fb2530ad1cd321078572cc84910037f2864ee076e372b23cbe777826e24fae19a181e896b738e0f9de562b478f22b491a7d55342cd748deae7e59d40c804f2dcaa00a2d381676f0ee0bf42000fbec4118a9f40b25bca830a25079940a8831b190e4afb03e22912dd2f83abd05788641df926e6a0fdbbd985adaea56019e061381b68849c87e30acd89d8df2a1ee4eb40f72e98afbcfa68a2b28f84c34819f277e5d5522074ce31185807170ab7a94b6034ec3c9dd2c4e7f39d4b606589e0aa003a74ceece1a658ccc48257a5e275522d21628441152e45b24acc0fd49f810f54db229a637f0948a27fb270edab1b337726e9e37250a927b4f485bd6ab5c967b5f12477d96319a865e19073bf106c75a25cf3544e93d55e4700386b6d693c1798fdb2af77287924fa13ddb570587dda7a578915bed8b92c3e7ef613b6e6fa1bbfb2555370dc587af2f6b3023fec7fb5291a9a229bbb34b013f947154eacc71b199e738aa014655d9ee609f05d4335f73021b2922cf586a11f02f5b04a7602234b0b0a544474004eb4030f7e73aaa3dbbcaeecdb54c9d88f29bcd01c1dd0320039494e2798309ebc9be6331d8ede08749d361bf24be27919b98f9b393f020cfde6e37c926bad5f4d47bd677ec6d2af454e33172e5bbb4ded94baafb1550e14706c03164d50f9a8060f6a7e8ff66537d4f08e7da94bcb1f570329b15623e83594399e72049454ca8f7d7a9238f0c764077e392f5921d9248ed9973e76f5f10630733c66814afd38550c41071f2e146c6644ce9d07a0d9bd4ff13a0a27990d9c871345dfa56d0581d6dcf898bdc006d7d42139ee0c07ede8e44ec22973604371b01164b91c775ff4553208c3d6f0ee63c76e361766395666e6afcf16875d1cbcb638f3c8d4359e27c9f32cae1f19cbaae895d5f7518b9d1ac724cc34fb8cd38ef82bf236f75abe11a2819bc5b78aaf5132c20bab8183c8d8a956e3dee59d359d42ea26ca4893b895ab2f1f570fe9f068ee78abaf1d8430472af473004bf796639529ef0f78ddf0324ecf70627d9c39553a1b85e893be36a9e4352e4885bf6e787bd22c4ea81eacc48ee9ab2068d19e3de57c182fd9e61157dd190e3bcd306da3fb344423618b8e024480aa5e73324021dccba4e1754fd28285aefe79750df2b046a5e4cc788caa6065c1b43615062127f120a42d0eb484f95cc1fbfefb5b8096367649c6edef48d360600ba5776381d4f2608c9fc322e04ec157a3514872eee632cb450167a83f8443ffc5873597d72fd60383e967b603e4d7b8c3007bf6f057e199dda9fed88ce0b6728bfccf2910bf77dc716c414c94cdb5c18f8c5196411bd23110f7073580ca580973b4a2e0312682094cb9620d5ebe0b7ec15be44e4114044c1fa6697e2c5c5abf3d9068a7266d57c22d266daa1663fc3ce068aefc96da0a8553c899b1beff260ed53fdae1e993c5f71098275dc7ed52c1e03529df74a431f7763b3111e4a0767b97a00968b5c8a5b4b7db8f26fd7e60694884f0c3298fdb652544ad3b61dab5721cccaf1e25db5a0db4ca573528b517a1f0363119c39b1fbc493ef1c63061f52daed67856a4727e0347c792c59cc081cbb9bd792560237437871c15558fc5c0ab82623ad717d98f9121086f9bde0b56f8d163a5100dbdb482513c23e62bee92ac7f05cba9761771a897e582f53684651cdf3d298eedd479b0c535c5b90b5c3cbcda00bce19815b841493577839877ce2f970ceeb0ec5d9494698a09f5c05eb8bd391f1e790f316abb09b025ebcfdc41bc107db595456295a268769f086a0db49f29a8f5ef25ab86f33071d42f5731e0259e58cc139d5930714a6f50ae5b881dbe57ebf0951c55996a85c60737635d3970e48c93ca975ebffb30ed989556e545654caeb5b9909f4ba56a58aec99a5faf4786242c95fa326a7f347cc9fc2349ffc619e789326f7022a1a74ca55f2c10198b5b8c626ccddae3099ae42a0947f201a73d923dde15fe8fb21f06f13043287becdbd319704de987811388ef451f046575b8de540455b2a77de80986ce71f9a3b5a09841c0f7c876f3adcca522f712eab60bc8112fb6ae12e002dcd85d9fa5bf74349e09e4a6ec37db39a79306ebe2c4dea97fe2ba7ea6fba6b38c9b418222340e75072a8a14b9c06fde15f8618cb2367198b15107d742494a02c93088e7ca06de5a76b7ca0347664f9c8f47de042833f9d246c7b759fb4552337c94cd0c8cdc3994fae0cb520889531f8df8abacfba9b470629429930fd880a401b31a6baac0a38173a46b9350a120011d30ad2b77d7161e2f8e5b2940e91bc9a92b5e7800e057bb4d1e0857ecdf35cad73eaa7ea15ba901d620a8f1ffb6e76ebf3ab056d8e183fcb6d03aba87adaba603481c0f803c98bb2adafc9eb40e49aafcb4716c1bd0f9d26c6a11ed86838b0bad5a4c7590cf806ab65e4ebdeb3275098a5b3445189aa6931f8435be14dc938c28116f82e1a581914c0abc15fa0e2246459ecf17b9601836290ee86b573064bebd572a3826051239e1944e1d6706921aac8c8e40929630f255811593cac8b76d54e42be6cb0bd171ee66fe65dfe057aba0eee1bda8819ce6536227de93e15e11077402cb700138088f33398c7eca0bdaf796dee7f81e143c6d5fd7ce00fab87e431dc1d43a67fc48ba3b7f0736ec9662e2d93af2c0cdbdc95971d4a29066f78d044f380d544b5cce1289ca6b3f1a5b90c7aafd3fb64e03c3ffde825e3f0bf611ac476aa749ad38c9ed6ce8d85eea332f392cb4d0d1a9a8d577567cb18b6247afe0129b95b61c7c9290fbaddf8f1392149c67da7f3abf013542ac8519b8dade50aa204f553fef671140ee828645f495b599e5e73747da717e75c2586bdc1ded9adbbc8e9905ee6bd7004eb2d73ccbd17a77f945b0b37b7b3c347d7f9f152651edc11828f150bf0e4ddf39ac712897f37d626e70847d4910c9b950a5723e88334dd40a53273b6b640fcfcb3e2da349d12272871f95c87c873f1631a7d13d8fb78330cfdc2227930cccf00e4d12b517e1e91b22a9f70ac6a2f937f1aabb124b54e8a8e2bc72b0ae545df406793ca0e441b20dcb637f66c97f6fa02dd21377fe6432cb9608c5a484a0248697cd5a90af3c870b70b513c3f50bfaecba6f728d07173316a6f8c738a3ce540abfae6849ec51b5e3765773a9af501a872196f138d785023368026b6c3c514dc1c4fa75e9eedb06a2df3c61827387d046ab14049e0b61287cfbd4b0edd3e6816fd1179bdd6f2b9a19d1f165c003dddd3225c0b2dd952cd3e519eb55300c3aa786f1ea13dad2014a2f65b5529ec6473569fe88fb23a8a3e927b4f6914384a21c90a6d01a978630b3f34e5af26e20160039ded216f3b5508dc0d98a06827d45649024b7a42ab2976e6ecde466dbe0b06a273861798e7df1f594c6be4236d9120a63e01ae321ad18a843bebaccbec053333093fef0426f1193e2db32fa6895e7da4b87fd7584bd7a98324f319e1e0c1f20e4fb567be99ca6d5b5c3bb31144b9970838bf7199c6387eb18a0486ca6edbecc519a4057254f507222629f1c55639ddbe49da5f944679e5859844f866f2d19b49fa1abc25d71ba5ad96f2b7346cd4c759d67ff4cefe298a9036a2bb44d6a1bd9323caccecddefe6a5b86f5dc0746262a30e8ef4c38845a1342bc017fd5a58eab77713818d33cdc8c20c3fb6328e4ad15ef913929be1b38aae335faa156918bc419f64930e9832c2ce3cd30424b587c369253dbfc236f58f3290f060d10154cf86deaae794764af08641bcfe3542f36fd02fc572f63bb41c50d316642334f1a083b4648ff895dbc569ed6c635fcaa59f0218782ebde22cea2213e35aaffc8a94c77741502bb382f54468fe38ffd5a8e80ebaacec78fdea52a3728fe4924c3673b827882cd45ff31e9a238aa46e53997f684ca8638e82111566701a77e64268e911a27698bbcb83620661b8550d31520e1b4caf44758d053d63c3f2761c1f9bc3e74080483095b6e302371af78bca6dbb12301c31dabe3073535f94e59996d8eb97aad2f2dc13dcb1d05221131842c7f51e4d0c387a639bc3d8e193402c629e3e23d7808122847762ed1ac7b2c765dee4e92a320c2d5f59faf71c3b9fff5a40fe895378c7e32327135395bcd8535f4099dd01a0399c1f770f84e85ac37d182b9c548e6e7b32a077dcf800ca24015daf66ebb0f448e7f24299cd55a09a4db552bbf088c211e16f13bad1821097b8f22aff062ea4539cdea8aa8f2ab2febf677b18319b05adba897424d455021c4d891bfe5a3c3ec4fc17a3048227461f57b5633fe07ab1de74a448b3818f720617ae940dfa81dd59d272d77d2f9ae777ad0a714de24e8fb10824f85b2168ec8aba6fb86289d380899a1ca6f87e8517d752eae193a7005f8a95cb23877681cc682c863c890a1a475978fc3928bf02bc42bb1b564883516960d54714af313ed172b6aaec830b0c2f26385f0ddfec3002f5b6bd6c622bab03168d545a34aeb0145d87109bb44e8c75397c881dc2187f07e35e2a0ef8aeb167492603b6ef3c41a898f5300efc9dbc9db8701426d0d7a1204e5975a7f2dfc5577d0f87b946fcabfa953236da3edb949658064304af2cdba1dc445856fcff1dbb7acf728731b7b804d7dba9c5dccd1cfc787c8f8eca204af007e60de5705d480569def0718e0ed64ed0901b592c0575513b69574e0d0e8801f9557cbf8431da27811da38684a81181b5e8f8ecc4fbeb6f4a7f63db9e55dfe7db69c45dfad2c06db569ab95896ec6b61644ee2b960935568e057025bdbea4ba7bf8c5aec459500b74a4f59350a3cab7bcc47b86f69e6f871b4aa8d25482b9d8f584318a4fd25647782214939f47a14926175a295e592e818675b47d559882e260da72427c5d2b801d35fe66f72efed314edb1569e9a0e0167fe36636e934b63bed8ca734ff37ca5af181434ad167c683014e6db183eed460845d00691d698a4245e616b8283004b9b20332c051a5b78370947aa798bd70f4c390b2aa4f101658863a5a6537976e5dad1b408c903e943e93f8ce0c221816b89c36a5c6a1b63d293cdce516dac38e294d3fee2b14ade0dce2c6481cc5ba8e674238959f4b118f3d7b097331e0913062d0ba018058d157ea25bbd65117ccc6b39dcd795590beddc9d6c9f3ee81b162c3616b73bc06fd630b125218969708bc992b0d2ae160fe32710ec3d442a0f1307be5791afab513236d0532c0ea0086d92edcb31fc4437c067719f7997fc55771c503b04a299844048ce8f420c0e14c8b1770c83287a600d2480d2eb2d2b18f7d976e6bbad4f46f5f400bf5e21f958a8ba2866ae86e047e575ca065ca409f420a89135eba2cc33af6cbdd66af37d46ae4d07933358df1f52aa8c91ac6c41923497d13f22d1f16c0825eedde493baaf10d66932ac9de0b0a74344f875858ec84d9a57b520d89ea0c3dbdbb6c69f1e6089e0b3d999d0f5eb7a2a0047cc1298824c15715f1036455389c24db00641f10478a3b028be7ff56477007109069e104ec7d46188375d769454168bf1c5bb3c030f7ed5e9ce2945dba859f3e77032c60ff4ce1c470308563232a8206f74e5ed154942d06e6256d484c6b34a3f771cd175c3dcb27e763226c636274002ac540c2a6216fcf3b6d5a565c72bbbd7090f6d817ced36bc2901337cd1ac3b8b3c0f6decb70b53235ef749238e3917831958e52048288f28ef06c0b66e878ced595ba453bdc9712e87f6c888cc858cca13e3ae65acfee1a27ea7453df92a3be65426e957f209042aeb2fdbd58a51c03fece5236d844907acb883225c29da8a0a287d3b59bf43cf8d44565475a6f40b68c192b666d83fec8446710a3d0fb89388d21cd54560ee7ac80f5d8ba104fc5e3e4803de91a8083d3492c5413b708cedf351d8c40a5faa9b902a16d8a9edff6581a7fc5130e7c3b9e539516f77a4499f1033fedd7db609be4cf3a412cc1c635e564c3da016e54c7157cd42e082802a2db31a282be8a5c2fded29171af66aa024665669cf9fa1d7bc21ad3a339d472548680e0fd5cd7454b5237025029d08f149bef3b5c48740ad0d6a9ba0fc8ea7909fff5aa6f7f1b654fadff707113b9c7d902fd158f8cc45eb9ad700f4a15736374f0704862677dc64bad4a44bd513d49829e90cf8877487ac02b7a6a336b8270c9e0fae77d18a30baf9cffe793cf25c57863342287019ba6118e2305cdc00410d17be2b2061aef2891343e72fca788e5e57db5e577c0c9453b0e6e6bcee065bcffc02327da5dfe591c49c9e34c4c7a01594abc2b4cff9b01281de9001cb181944aa45db314242dedcfe815759f5db1e0ad34ae03bc01f379359877a27aa35c6c006d278dbee5752fc9a0f65f4c848b404cb6aa8dc1a6a20540c67ba2ae0838cf713732bba1d4fa8baa62bb61c94a396168f74438b934583ee58d8fc7281a142441dd2ff3cccf2b8916bc5be9bb79d2afd429263d24d894b861647f54c41f84d2e26872d729e5c173463113237b8686ad5cee1487a7245aab332f115088bf3e4144796a96d85353d6e98724a288b70100691f1714f98c08463833d97420b005db3574eba0d419ba374bbbeef515d338678ccad584c0889e95224b1c7acf68a64f96a6ebb8ce595407dd83f59c6e65fb9d1fb99f8a565079f47fd59e68c3092ae3fd6ec77d37ac24478aac104ab679c51eca95997dcdd170a93b2386ad876c7158298f8a0d52acea7aa356997514a456ac18aa7d993c698f825be86c3289146ae8093fae963033c425a4890aef44bf182cf26dfd7469b0d62e9968c66e0c53473746dd32c14963e0bf0ca3283861874f8e0aeabfb0b4604ea8b6fa6e056681509d5b37b51d4cad39da1674fd5e944db8be507261712ddeb2dc17dcaa9039eb89428e21ff0d7dba9082bc62f09f8fb524a60bd98bc9b34205bb0e82754eb41b2b283b53328a62355ef8730c841fea8c10ec7ec69309611cc0853970aa200a61dbe2c5995f9b1c136b2e49d65a7c41ea84cf007c1533dd1245014a1bb0c894d4dc88d257baf143d9f067e27bff22385fcbd70305b5e1a4eaba18f453d2f008419d2899ce59244fefe433b136ec3be5cac7bcefc9adc837bb234163629010fd8eab6d69d1c2546f9f787ab1ea31d2f67e77276f01e92d9ef0d333550fb43f4206c2aba75f582741083db90f2f2c78fa0b2c1db0ee62a3a2a264b1104468b92a022d8ab3399a551c04cff4b01fc4b3d66f883ce85eccfb18fa871cde2cd84cc036a1082280e7c82a411216ca09675a7d98fa750dc1a00e72d52a6b815556451f2f2a53aaa86eb467f5354ef1130bbb71548dde648ef12a9019a734c1c2a5e9242a03cca077457d7cc21ff4ada609778ed7247aeb3660b4e47cabc36d174735b56a85eb6294f7b1184ffc751632143a74e5e797fba02e7adc3b21d9322ca2ac64e773bdbd55e5cd62e8187073a978a5021b5a1665b7c8d53aadfa83a54d28886f9c4cf3fa091b39021f063e8ee44effe42fda404477e74dffd3db27fe4f65c237b0ea90d9a2f4793571203df4ffadde93255e2e26cd95a606a33645bc533eda8499810f469319bf2e41ec060ec9c1b4767b91378b7c0ecf4780b319540c94ef4022c45c318375fe7b49cf083aa1a51b23e2bb1739a9c2a44d29c4fcfcd4bb2d8dfea2cb8d6b7449c1a06dea342d93b89cd9459bb5b08cb6a4e54738821994a5835017b26cda0fc11ec43cc0e40ca259d295d7de012e8da8defcd0cec8d4e89685a78f948170e5a5224ddf6ad71a2bc6845d7f964ba8fdb48c39d476d7a3cf62ba9513de4db1b8f729c23a4f75d3863f82feea703d671f8242dcc8549111719f3f3e99a70d72d9f0fd51784919df80642e779a00b468507f9b2cbb02c539a5a387df9b107e9db252e2b976e67b8f8b973813d937428639e61d74ba08a0a99a87954bd38dcb1b88fa5d73d8a4a431875f3f3a1482e601bcb40804f5b6ccf6d0790f523e338bbeebe2be33c43fa74a8736857c70db1d4ba547fffb6856358d44e5c79e56573a576715a57f1e24aa10fc1800fe0c08d3217bfcb9b43b79e19ed893fa8b6e95039a0070b3ac1b18705c879e5a843f4059a8738b583914e0b18660d90cf181a0f956a94a65167786b0ee2778f8c44098b7efd4751beeb5110fabc39cc6568ffea35caa5a9a1310124538ae64cbe1f377ccb5146f83241fc6fbf2308f085551115286b5616617f1d6d4ea2a93f90110e61f63c614ccf4121670d9a6b56b83beff4f013a8d2c6f071c6d7eb69c6f8f208663041718f7cd0715ba382cb6f13f70841fee5b4acbe11ce4b46f31a27daa95ddeac3d61aea53b8553f3d1bcd9c09288a63f794ea3fccc9a732de7056002715203b5acc969e5922a4690e17b4a15107554fd2f487a49842bf7f310763205a54317d931b121673cb7114df015bd7dd6a2823cc01b79ef9b59f29ad7f5676448dc31f789d03ff12158fa11e8fa00a4565493e87fb40ef57c17e6ad47cc56b8dc83ea596f500c34f95cda40fc9118a39b1901b9935bac5147b6af4a9c1fb8dc923080c3f096c098de5c10efee0bd53365937ab59ca13fb732d41949bd220456abe31c34cee0f87b9dea832b7397564469e1aacc83af3199936305280030b3bcfefcdc74d9f5808d4265c368020f5aec899ff5fbf39865d350e12268dfeac883436b72b94f95915747b89a69aafc0ad26243cb833f1d82b224bd0f82ca9b459207bc880b0742d03e0fd2d5e7858e0554309a7562ef94a7f58d09008bfa0477ee8ae46599f4bcb6d38680b02815509e329fcd1ed04422b4165f5050dcfe0549b315584a09372bdbaba9952599194b9d3633ea3bb8029c79cbe3cac61df192b9d58aa694a402dc2af763f1e36ea1d480d400bd92c3d30121692fe55adfdba35920d315c549509588b7ab48bbe1afebfa7614299138d0bd98dbeca6f91eb8c8c485657cffffedd1bbe127620de4c70c7717da4d03eb26a9d61c9441b554cb1177e1e7cc3a81d333be26e6ef004c8e212dfe0dbf85c2c07b2d57ad3411d897ee781f400255ee5dd90f1dda3a4953dd36b86c5f5089b7a0d859cdeae42ec12476af38b3e1fab4250aa0e3ce8cbd7c1c18c5da530876656f7bc2431ee4da9fdd8e9b5c34bc6c4e6cd9f4b7a05277e4315f51928ce33d248128afdcce6a3a877bfc722f6bde771ff1bf78de54ac1bffb1cbb66c5b8f01a08d4e4d31baf9ee0d183bb9a0794127167d2aead0ebc72e4fa822cecd6e7e62f092d1e93720a75f91dc55d2e58e843998c7087e6bdaf8b8b054933b3af48c5814e917dd0037494313628644b0fec482e4cf7c2b7bb6f6478b1c1f9c7e0b2b78a1d43285510461b7ee805ed7f971113582ab90f7f7b722efdc5e152869c9c0426d85484164d8a5b21bf16db7ea4506be1c30bd8575630358ddbb026d85b31484de9a1b229df665d0a348c6c5313eb540476d4e3c5f6c78322853f5d66aab86368390b2286f7bc8b2be156913ffb67fa7ed7cf4ba609c41835c877b9ad66f13b4e6020a8e8ee7af539480103b882202ce77f4e3c59b5680cb8037b7ab7e859cfaea312993bb83ef2afda4e8e09dbfefdca99df96e9b0c97ee2f415c8cfa7fd054c74a61710258fd5b7c61351a35c8f70a0b4f98b81ee4fac1107b453f8cefc7579721a576ce0aafc2f0f5e65fd0dcf11977642b0c2debc9d7fb7204f3fb1c4258b54df71169baef29f1e4fe7f1c73f0ed0453dd65c62c8532e45c821610f3e44623dd9bbe5bc58c720678534a7c1e2c45fa85d1fce517cde42c697a665926d95db8cc7c38802c58570af18247ad746c85d19e3300c8002b09092ad724a6da0042debccbcc336a2a67d83e95f1149139533a2145a454ff33d53435f5c554212290bf4f20c9ca7079fb1598f259c94008f69936db37e3af36c28215ff9d1881cba9f050eb401c71697cab29ee6e7b6ecd130c7caa89e905ab14cf1bbe39719edef926ce8884672c3886c296112018de754ec88c57e31a4c772cb6bea21a6bc75bcf90caba2af9f71569b648bfe5321b86e5dafdae9818ca4f49eec5f945f07351ecad43a83b154badb32f20a546bc80b8b5e5767dbde3628fdfb059603df3261affa906179c8f69966e0a3dffab9eecdbf6dd8dfb2e43ef485cbf4a11e8c7e42c3753b22f046005d01be7577357382d8d213f27d81f7812c8145598f4626629b271ccfbbe52119970965fe89cac015584f442ef344e08fa6703d570f0585605fa25dd0eba69e62b1a43202e9fea4d2bb707becae13a3c89c1a7876126a03b8befc95fa817a6d286a44b7bcf25c322574e8b6f1d00c8e915ff492a995486f16fba8aef77ee4258f3d70f9411a3700029192ca0f92f247d218e25fceb8cfb01d9821c37b047716e7f581b0e358c877bdc57288900f2933d1d4aa4f8382f34ac142c027cb61236827489067fab2940d70a277c2dd95b8573e58baa855c1ce88f81ecf17232045e5192c440e4e21504ccaedd02c75c6844520c0a654e85efbf4986c2b969a98897cb712505079b2cad357451b5800f63bf640de34a170430934ad984cc5c213285b35eaa8031201aa6a60717de481e7631d9206b04702bfe43e74ea883937fde5fbced787da79fe85b113d984831e263bcf9dc170ac3a3e92a7907b5b2fa87dbdc8541076870e544939b72c55658e5f6c6c94343db2c61f5e711b1e85c70e95adc9f8481e205e590d5b9610e876986348cddb3b6b9dc32847da3d57a63cfc2c9f83f8675fbe97560de29b6e5f16e2800328e611d3085f65a212a31896370305c7b7d289b570923ec529f8e061199b195260272b82ad15af705eeb513ca5ae1a9b102396b7b24fce08958740516a09fd716d9bece2eb9ca83dd904c0576eefeb60488ee7ada387c7e33d3daff3d3914214482f3f347a6e96c72f0c51d0c821b7e28f10e8c7800daca80cee4200eda67617c466e9534ad5c0744da803b86c6f581e7bd7e2956f6f5880e517e65d4e21bece103705665f4a8b1385112b2815656cf4a9edfc333210ab8acd788e327fa936c09f02957e455ffa798cdd73ca4b2ce4ea32d79a0df00d2e6d0b0adf4a218439d90fbbdd5de9036cbc99765242134c059f04ddcb98ff2d492193aabf3afcd723fb42e975aba0e46cc8c610e1bffe97ca64707ef3c1bd96f72d8143ae73468c035c8856c29478ef42b3762868c98700116c04cc4897ce54bab31250b748bafc7573b439d0e53d53ee12dd0d07b744fa924f3b01371b39400a6c196b5ad2fffc8bea166f4f717b87b8eea825df24ae27f7d740477938a7cf911beef0a2fbcef4202086421953c48b0313316f49ffb2c46aed62b85877bbfa19e6ee93c39fa4a274bd42f174347f9d860753fe0bb6b98cb7f10b32278c656da08df5f13727203b47207625f9e990348e7be19cc40dff755c6902b9f81c57d41ede59de46396148e0f8389ac24fb9733975f9a0c94f5c13b46c5b39b3aec6910b4d218c0e5f6cdc9393273ba4d1f802c978385184db3bb0bf0fe153dff16d850110324ea62748f619791d9b5de781c8609122b8c37a0341a5c4799bdade3c350d08ce9ea68f12a05baecf375c18e3a1110234db583b6514756a4bd8ff043bae9d6b229884cbc276a7427b0d1aff33a466cd234f434cb04dc732d26f839201372a3d4e875e5850cb8dba420061082ef3ea6943d2e518abb5ed43e41cce9f687c42d751a4a688b4b59ff8c2805f62dc7bcf0c5e8963a13c56b7e876959d5487dfd2d6168f05c627061b204328ec6f5aceb8f56e8da4ef0fb7db0e3d6cedbe656ac0f28be4ca3c2d0196239db274f00311f1cf160458d7375c83a8ad7320b7237578c805a3843dfe09066ece8318908d26a90e510772366783e9a287998dc4d5b04289b622bc39cce5483bb2bc9c1d5ac73edd264e5d97a03633e0f600326ef49e7df2f932528e1dd786f3098d85425e4e2db921415782d4e879844f89fb2552a10026296ea346ad4db3af28a76e207ce4f5669cf82cca7b314df5293ac3c6d17352d17e6a2de055c30e599b4fe9615bee8aadced354de1ff817b854c9b0e66c80464e7ed3a477a6000a8917a44cc0979f22d7a0e524cb180d0239d4dcb69b3b3cf783c89081dc7f06a8ff184c32d4ac315ee75d0a38e484ab8275792cf790f5c1cfe2375e4bfc044c0bf0c363760b4ac103f58d0d117c5e852bd0fe4dd55c4fc527fbc2553ecc5980dbd1ca80a241f893cd1aa9b2cb67b03521e9e3f9033a41ef8335a74f1dd4005222b9e9851efe97310feb5edef680ddbb20742b51505fe85915669e665a1e27fc32f2df0c985be83afba3a0a5e184dd5559bd4bb0983451a88f6d5164ed78561adc330e0f27806f339ff9875e7d3bd24013a55cfb00fa2cd0a185d59868092efff5d480e54b934f3df6571a26a08269e3f98d50e19fcf72e17e8655937d5c9204baa1e2c0498efaec8ade8b87c34fed58761684ac98fd2c8f37b0db2161c31f819a5a4115baf14d40c0e7e255b88ed08d255742960b45165607427215cd9b493903914ce1d4f3ca6cd9e0a34bacf7d8efecdb23db1cb32acd3b2353f2e6c3dd3e574ac730798b227b74bac9bb43fe80969f81a21b6c419bd6d586c4fb5d7bd67fbd7daed5c5df8084a6b31e508f0091e8723ee7dc45b506cf6403516c36ea2f67d26daa0b5e3de679f9433b712d8d9cb117a8307c8cfef922f5a606ba040b2e59d821a8d8cbd5c6ca2020d26b88ef542e5d3d1f8e475af9b963fe3d600b51c02c1872d62714a3e43496e9ef36718860ba32962b53def46d9e7f1af507b6477f8b309e33aadf208744f42428f2d85f17bd7204aaec3804dd93892145032b82d731abb8b419c5cd7b7412952a7fc2485520630cef995e4aa4012cc93dd6a55f4743168834a0f34b7ac3f1ef7b880613e450448af1e4a9b7f7db0a08ec4f5ed65467ac6d325f4f092faaa6d6a7a74f26a8a5f06b7ad03d10286c6a0799c20d4fad88e464df701357aee1f6416c6744652d10311360431c61ca48dfd67da3dd07fff26c3dfeef5afe7a147037da7f4b3a619e7c6fa17618ca16864c8e622f407b51f8943415c90677b5b317146d819d1608c4b761f3ddf04923abb79e345a172e9f55e9cfe001e6413adda6efe50cb1d05cf5c4edff081c020c84d8b64fc659b39f820937994e56386962e766a62f40b0c0aff6659cd97c2d3fa8f3c01fa2d899180db34a9af488a760ef455ea670ab0c7b6816a53f63afebcdd517a31d83637b53094d248bbfe4b29d2aeb5603d0b5e3ea4fa48789ad68fa695d01712a0fde44d74746021cf03af62e8c714b57c783821f5eba616b32802ef0491b844a7a3e736b80fa65fe6f64356bcc48d07832e59b14461d32643e88047e6c0b44958df67fa1daeccee2d661ed264b038e2d349058a59448f3a012d2737c1acc71e952210222173e3e6428903debbc3258f38db9bde2c062123743509f73b29882690a3d5c47d8fdea61ec273ef5a1212fe14ebc8ce1414377d9c51123171c8cbe832fc476784057aa990442b1cfd48df3ba1a9e38a1f17b144b6868713946b021b29a3e9f5f6163175a69db211560682a535492b1ca655fcf64242739cbcc73f522c4963a21bb1e8aa4570940564e309ad6eb238fc22ba802b36bbed24629ec512115cfdec8fac0a3a4ef1b8c0ab95d7cfd1c097b3d53371203c077178de8ebe57c1379f74914ecff37c25e9d0b2232e2c1bc61453578454b1e6fd51567aec263a83e94099c4b4c770d53113083086c33de6a5f3ea021506b1504b4ccbfc2eddc711dec7232c4ba034d64328ff0360bdce15628997e5602e6b8631187fc5afd8fdb25c33a8b5ee1cd755da70820556b03a9e40c6535854d66e38b5b98514a86116887454040736fcd8e80448828a6758ff1fe9e7a6e7c1ae602c2ad1e16e3d2df900a69f3211d1847dabc34e614c306e434d7ea968f07a1a6002ccaac7364cbc627bdac4ac6a2ae791fad399e361caf15f111dfa4ae61327fba37f99fc886c217d53f1c92b2f3fc2050a0478c060b77223a35c942ce2f365367f9e46cc77f7bfaa595ae02be384fbcbb1fde2080f598525af351056391cd8b600d03e425a0db3e6a367029d9cea79629e61daf6ca9862458562f6db9b8b662b616aadf1becbf6f8c48aef5ac1c2ee0d87a64ee2fbbbdf697093f7b68bfe0307d36d8e9c7097505ab18c7ee305b8d475b2cb0da6bed8ff6887d0617dae51f93cae4c37ed06c1d50f6238185b5dacdf7ffa6af8242ae0b18d50c948758881ff643a4473e0256f2857cb3a09c6caa09bad92241aa73aa8ee14d63c63e0e163608cd0da49365badf9cd29990223e55fbf2b3394c8fd839a48c81bf38579e4cefb5a7d72b02fe9c1fa99118502af39e5d829db31be42766a8c6e73149b003b483f63948a9124114c203fb1ca08d418b7456372434888823efb0be719afab2e1b75d26d7ea0b61840e5f7fbfd86e117a2f616c0621fe7ed8d9e4cff8f187260f9fbba72a15de590dabb51dc30957db7f5770a1f13fee189806769742b7bb26eb009156d5d4a0e5285cf6fc5b7251eb98e6f7a6df2adc668c4e6fef0bc33c8ed193b9494c717c0c78db71a02baa5f73240e2a4827da91bd9dd9003010e061dc8e3057992d62bc4843ef8e15f6486c2a52ed25910a0bbf3b6be3e45db8bfac5d3f93ea3baaa4d4e6a589b4754eb39a5e276fd8e75dd0e7f1cfd107c644cceee62062d645a2509e86be15fde60629dc862facef0e40746e9303add06845a988dea27b1e277c4cafc158fd69e7d207c3fb3c4e36805dac43320dec77f3eef7b2430c183185acc552dfaf5786d1a0820a197b233b4014ae07af8be67ae9f86b84f6834cf5396b21b02cbe11fd97b343d7813524f66f26fe47406a9d4406def4f084086c269f2f44edfffa12d62d66e9e99018635e6f32add40b8c41108207959afb84e8aa245e42b8b2b46dd672dc58d2c90e20a1299ce74687f4df7c13710cba5ec75416ec3dc180b8d847514e05ac0ce7aa7ab0cff5dd5f8c59b42be8e84d0db4758bcda7b8a163cc3003b9f0337033faf9057274616722175b37886bb99e4419f9ccc23390fdb9cd1defce6eaba2c716b0b17459e0ee2b7e4b137dabc0c18528aaa650d501fabbcfbebe05d27734b74c6075bd3d42001f312917fbeeee8b653c226899258f452c3079b5639a3fa5e7fc549a1dccc92a0369f06678b2b494f3c5e7c7e596b02ba723dbc1cf3d96ef563c706437a9fa651f10d442deff188d225fe7e80add160c89557b2e23fb634ef9c982898294283e2824fd7a26b45964c79a1267d346c654dd9fdc5ae46ad2a7abe58cd03ef68c8a87a46019c6ffeecef6c8989c3221f5d127a5408f6657f33df01c815a9ec08ba54bd89919736f37052658dab8c193184e164c4105c790e97e90b2c901e3eb217569dade6c12e9393ccdd31c0e3cd0f53452e942c3bfdecae23173605fdabccbe82c901edb86af0e8229551c4b18b349c374ec6415dd04b8fdc2928ea74caaa06b1839b5d9c1a544a5d8026c006550512d60ae480494f57a4aaabbb7eaf6c951c1a8a6380f342c5efdf3d463ed08a680af06e8e31c7cedb94ad236201eeae91c232f9813a3dca393ba7847e56d0059cb920f3e92f9670f88b4027350b4059ba64ef5c404ad36bd724db18f8d46c2b28cc653cfde5487e19cc5553ea8f202ff75bdab6c7f4918efe6f3d95ed44b4b6dcadfbd5c2e3934764aefe3b3fdb14f084b6fb777b2f203e250e7f0cdbac4ee067a6a4380187f6e827c7e1736bf73e5a25623b1c6bae31bd2baf7e5e010ff1d3a6e8e15b6ba24ae87752a18bc7d6cd403633148193f1f9d6d3c20de4e1de0116c341bfa8c34ef46edec048c3e85b4706224502785edf191490af85a1897f8495d971900d4d275ca0d9e81359efbab455f426bb1c4d8f467f57b9a1af5e85d8aabe871fcac945b8da4857b15675c5dd510b7863dec17e932232fdf3457bbe435bb332b3a21d6d3564ea655989df3d652ae2dfb6e6eb019e9c250023a2b6dccf581ad275cb26a356dc2653ea6a603b5cb1d22d50f346d3a4a6d8f34a0c832c19f6129a56f504e7b7d083650c78ca0464118dac356d6b107deea15c17cdf537e83da24f5eec23167b431913b792075c4822104040f51d72e842e14473c9e245f3879ae91adc5eee5d8d9e087e2f64d45960c58c39b7ed2182d1a9f90f654efbfebebc0c45f94fdb6b94ef86e1ac3f278faf294823ac53427c500dc23033d533e9605d5fd5c7beb43ab5881570c783bfac3aa6b6c716f3a48c6b5796f1367a546a80603d34997d7ced6f5db5e9e6ab7ba83f66ead8ba712597a6009f737d5512b28fbba62dc21d998dc29d5f68f6bc41d47828a8e480f05f3fb8528810c27225073488b966ded9894650108cb4a871a6991f74b3c704b2ae7598644301213342232474f466bac3fcfa869a6af242b3910bb19bdf4c9fa60996e4172586983b7484f753b87778dfb4b4ea248975c03dcef0888f6ffe66d5f9811e2a6cb7aef89e28bfc6a807ebe7617e1d6c9ce97b8c570a705a7772b9546ae50c4a4bb64381a18a533e9685577ef4de6ebc5921d14ea3a44bb43dc109ec9abff2e83711754f738d02e98aea6ed1c79b4acc33f54a2f0207da342ac6168d3e0d781d0fd2aa749c11e9586a1f2fb0bc84f647f4c7759d161868c6cfabe2574bc3724713fe6759e8bc9b5c4d86a9ccc6e79dd0e1859b0f7149e9993706ba7b2e60196405e45d26c8c7ecaf8b38ebf0f8f227e62fbf8ef1edcf8fd1987a3fcb39914c9af5193f05d3a73c0e02c20351282ef63825155b3d11d80c9ad7e3b06009d4130286673ed297a79d3702c65bddb6dc568f4d36b66ab440354f7bad3035ef19ca7c712d4dde3bd74df167cdbbdf76be9f981cb2a9bf264efa5dce87d149f883ea346506be7151b80bf73826a58d5b0c1c9c1c397512edd72f8f8b21baa5f061f29db0c90cee80df1a42bf36e327306881f297fb6855f040ec97aff222a808674d0689b52781f9eb4d5063cdc45b05a98ecfe2f161880f694f6367316795f35e3a7f230c11713d1ef9e481adb52f5e2898b215cfcda6f35f50cf10b3d202bf34f2b682fd041b5fe7fbdabcd7528c549dc897ca6d60175dc0966817712d43f50ad6c2ddf30e4f26a04d31342b7d6ea5ba4f36a93ae069aa6287b34e3da08727d5caedc4d481a976471b24f76b3e4bbc002a89950240ade111e32b61b752a98c69257c06bd24d7536963c7ac98b98f0056b5a028863dd56f34d1bfe4eb2145106620b4f8055144027717851a2a9eb480cd958af872fe6ad4098889a0e5f159d4e665e4b76022183a1f152352e0dc9f0528186b774a920531708edeaf7e5bf56ed1b0d0bc413794e2ae011820e6d550f0df297544a3e35d315c570ddebe1941eed113a0434847715a22e6a10c4937d6a7289d7e9674bba28c5779e0aa256704183eb25329089544d4e58a5f74fb2b05eac764931773","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
