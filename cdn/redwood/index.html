<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6cf5f32ae2de00822b286a5afac1cfa8dcdde48f5c6dbdbd4b5e8e5843ca7ea30a133b10f896f6c45154bbeaf517a2ae393614b1e93c07eb0c5b6df9123e472619539595ce6dba99c3ce043da667de49e77eb56e1402f9ee596c66ca93687b4537d2db6d1cf38fa4b7939c159cc78bdf9dbc79551c46b642a0fa3755bbd3535458ef7451184219afb82a7c2b102f9cfc5e5935f8cd7df1b5bcccc7f19c326d44e07cb3158507a75a6c0e585efdd6083b01913462a3ec1039948c54f6ca67bab1578752b73038c17ed71b070108c46d89af8f3980633b9d989d6b313ccd313add9084a02001dce6c27d1471c029b7b6c2a681b7c1b01caefb97ef298260783fa180fc7b632d162c5061541efe6abc840571c47798be17745ddb4586b51fb1970695eea34d8f68df542ce6b34f9934ca4c8b58dd2a81564316326b10c9c8292860504a97be4206c675ea499c3b23c11db7bc89120735dc4294f723de7fcb5211e878ed1b5252056817c416dc2a7e66695e5ce9569385fc20aa69dfb9b9efffe6f3e7ccafcde130edfcd174b57d7413ec31336a8aace048515f01df1f6e3bd8d6e7c75052d421f0af75aa484178e73294e89bfddd58d0f0d1291a348ba51b7cff6084df704bbfba4184b6ea4550aeefb1c5dbd8b4cd014ffa4d88232489726a23166944fdbd452411de6ab721552787263baf71d94b9424402c4817f062b7ed25155e56c00fbac04c1a6aff133565f00ffc00112a19dec2ecbebc91dd34ab9ba9737ff1b9c182fe8a179cda9ac3303451544a7d5134d76f829a4c3eb3bbbc0a2e5fa63702d32a3c9c9fc2fed248fabab9dcc3297a83e4363450aa73e3c646491d43fddc187436364ac30925786fdeadfb77ed803dc14e5c8e4a52e85a2ef740dd66d7a44608d444e16ce9721a42df46348ff1da565b5e4018d3feb5ddaad6c3e813aff41e225e3ad49805ed8112bbb2b4c0864a06650d48f6a5b5c1d8b134da92045815f0662b2f05a9ce168247d4207b5940e25c2fa5af84f2c864267d0a2d9116f09679874689b594351c8c76d3daff45e9d16809f27de109608cfd096546f563663b6a305c72945bccacdf82af2007767214e1556511ce5206e4b0f938759692c47d50884888a0acb77a9411180124256b87ba5dba306006f55eebcb2b60aa1451c8b704fa71aed0ae937129f05db6da2d2014e8fbbc6f4caedec799dce1113d569cca987e5c430339119a2f8f7e0cdb91e8ff9a01dec53adc770bdf4ad3faca5fba2febd4c102074215f9b304ccb0a5aa19b4cec2dccb831ccf95bafc0320c84f3690198a9f7df59d97d45d7cf716ef7905f51721276f35a51ed14b5692a80c531cab32da5c1c4006fc18782c01ebe2dbff5720190d5ba11a03d64b1bf71d1dbeb70133594759c88966a634468b9d14982f6560b0ed9bf18bdb13d7c3edd08ce6033ff09ac5609dc93deddae0ebac35e848955d6bb3157cf5818be9060bbc5522d00c720a7517ef091847d5eacf0ffc626b257ea6231507e0284ac14bc5d59ff75b0a8c9361fa457c1dc8585b5de39d9dd46569d9b474f914a8b92d76e961141a54edfbf5a207166f9051b249fb913c9c8f9d33908f6d3c082bc32bdebde211a87f5d2cb2feaa592495aca78d172834939588123a4265a982c5fc555a7e624dc610c2e8328112dd6cb0794d378e7dd8a894247b45b317eecb0efc8a3be76a8d4a3f9b8ff9fa3a7f5c68a37d67e807c40cd5293e9e6d166cf8c3d27c1ef476b05bdad437523b03908437a25f60058f729ba7635bfd49c096df0cc6037a1591b782cb6eaa3e43f29749ee895695c98b4eb1d30801e3d5997d11f5edf82b466bed83368337ec119bb0ebeaa1db98ce6aa5eda1d6225d129b1a3139b5c9e721edeee1f5e62e0d261abb9706f42dc210110be496fddb9bf9f5bb8480cd7085e07200e97c18e3ef8f54db820d7cc9426a46947cedd9336c4b4c7b7d6d88e5d1381a5d1cc94f2a856d391652c67523186d5b8fb50a9361ec298cf6b2a171d091c0bdf02542948b896a3b572781869346254a16734653a20dee76a6ba88ff08a791a730215a702288634a1a1dcf4c419ef47ffb5706d6b2f26bc075219fcdb994021622dc70f58eae9244e9530d207c547b5f6654fd9ae8a0fffe2af2416fc29572c8a5d9cf8a9a6848e5d83a2b7c099c1fc2efae475620a4167d3992af64933513631b80a5626ad4f6f9a6299cf34e021b1809b58596daa39c00ca218e9eb241f2b05e3033ca88e6d4a6cf993b01c68c6810a80169aacb8dc787fd9209d09bf20221fe05e470659ad5fc2d725d9959f6eba18f285f2fdcd6ea83744b9224864f0658a04587679f679da9af4f2dc67d15f67381ac9cc25324d51fbe2108a54f0dc0fcdfb4ce5018fba9b657df8c9ced7f2f205b2838ea3f5c39b4b1d640c3faae76f8946fee6a495a05b9e79a4eec5232adbee6a95bcc63ee97d75902879eba43d73f5112fcc43c719fdfa578c4dd67e166403e9281b83da6d43452a7e2eec8d4c13e63bf53c3f1b1947610b65da79119c95db0fe9ea9831b747813351fe89a983aa93ed268957d56785850353153a820ae31a478bae54c0190ea0e19cd0378412aa8d182d0db8861ba3a0c72975567b8ee40b178d5e75f52c9e0508b9749106c7eea0c48258d7d8bd8322a0099d8db0e3d80d64feeab086c7e4c1d156d48db9ae1c22cf5509895665f44dc38dcf38d41bdc94facf932c4b8d66062308d6c99f22e5c255ea2e0244b611fc360273269a893a86a67ddf13300a8d6e0f84bef271c02af4f1b9d99d051b5524e5a69cfaa9bb6412d56cfbcc0432ac3c41d22b538e7ef1fb321fd05a1891172f9f0058bcbfeb921356e653624ccb0d94b5725164b50471e825ce135420cb6e19d89b6040d33ffc727d291dd99328ca6cda36e496585802d24a463ac3f62c86ab8a857deb693b2cf7d57d7c703ecb5082a2c63cd6050ac3b50e6a80933a93e201fb4b1537381ff3cf48c8f951ca1ae7a2b2a4bf0a503d6b6e619d96d3e31ae6541ecefdf93e066952fa8a03ea34ec5f7d639ebfdfbf3f2bfbd0999ad9a97b80c0136cfca8adf9008ea180137322f2a609b3fc1c26cc12913b4be8f6b7a8593c40c7721f6d8a87a73c0b4c10c0c33e8578e3fc43ebbb9cfc301508611ede390a700b5b3daf9372c248b8de66a3b6ee14e77adb9c1975901267e07eefecbe50482510366327e230a83e6872d99827eb83d685c2791a4e6fe29e93430c01fc907fbf6525b1bc4945065f7e88a1bb70883f6f589c8a67659e755d4818e4ec53b49d0392c9891b7cf4aed9250c955c1039c1ffacc94f7ca0b9d8e84fcbb43454ae05414075b4f53695f024e9b1acb79069ce84161c67d42b87f23115f1c2d92467a273ff8f25f5c8fb29f810ca46707452cc01ea53d2db576c93e93d66b59340cee205a8296fe88ef451a475fa741d41d967bf86a6eb045f36d73e17fadf5298678cf3796d77a60ae3766c090a29891723aae1e376136faa44d50297e8681f6b71a8c3fb19098eb5c55a397e2377e1409ad67bded849a2719a49851317b96c695d55bcf2931ab20b25b88dd4a9895f0872a70db28360a6367b15362f707d67a53fb2c4d82ceb1885a9c2bf7a7fedb240e895f8c389c1cb05176809ff92081df4e74b4c801b27122b9e2fe830e3c201b3a9d9ecd7e8bb889ce56a6077f44e5690eff68e48c2d2ed05e36fb23ed09db62f25d64b6c965354c009e7a6b7c7ed962aa098ecac6d3d20ea969219ea9654fcf4c95bae32b8e21f6691557bbaa29bcb159aa057436ad426b3eb5bd087e5a539e892200d2ac740b8bcf3d97dfbc90f782901cdfc0c4ed0c3ea1f1f1e7f2d531279a8fbbe7b40a0f4939778286e1740e7b88231093ebb2d0464fae1134df14a16a1eb15fe950690c899ca81e7fe45e08d365a5d73421ee8823998e4c53c2e7fc688ab51094335dc1e1b960b51a0325773074eef31045ac3e0099fda4d1687a7d068513a09c42de159ea69a767be13db4b444fe56b14fd04d5918a51adc3bd428d4ed194b4d6c7c6e3a01d2922bf9115696ca8d47ae6a59ef7a13e4185a4651b1792a80361a3cffb386c8f15e20b9891ae39f2265d90454a03af149c2dc92dc545d729f83da181a84db7fe8e929b6b266c610045128807f588865068a1bd48c4c5ddd4fd67c86ded4847ad17b7726dabae6acbe60520c6298a93d3caaf6e778d70e7cad9d090d860df91e6410667c20a81a9809c7ff94b07768e2264f26cacca566da9bcc781a55458f900372353ff340a67750e891b6f2a4b7d9f23a93295f6d1c2ee862781ef55d13babfeb72721606fdd9fae339d66861952514d89dfaef4baad7479f189b5f467d5c9547f6c0aea6f1b5473c23b80767e198b6d2dd15040a0f8f1b74a0c2a98a6c89c95a555843d50eda001302014e318a1a4af9ee88d2328183dafe90035118f67a1c333bb0db25614ea5abf9d4ca11537dd6c3abceabcf58d57d5caa715e223a3e350872ba4476acbc7da7ecd720466a82cf004bcf482f19af4ef0b2145fa10ba0ba1c9a2c07ebca623e933ef0547658d49321a51f3982a63f95b753d68139f3f5de0f3ea342742d696358db5915db713958695ea906528bb375014b02ad01a6f12655adfb43486c2a62cea2c3b6f7d725009b48e53b376da20552838267fe0eb10006b580810c386b9a8f70b03eb46ad1d064dedaa25b68596932beee22321251075523b1caffb04fd42b9f41520234ff1870f17e4f9183c08fd16c9dd8e8b104c0ac6b24a83397acc33096697c86a735cbd806770addc0dab76a895e3c1bcfe1d2b2275b311799b56a76d5d93da8b15cea2cf6ddcf83e532ba3d6e9bf5e00fb3259ec8fd0b8ba379466dfda053a7815eddcdd8633bd382a4bb00c6d0ce6ec0a4e1760265223bcd235d89d83f25a39b368a6ff759d5e752a0a7d817c08b2eb2c1c3ee537d67c1e3afdba4c83b9f56fafcf3e749518c0e54c4afe66753873f011ba5e9b0f9a28ef28b8fb518687a03b3efe1a31a17b7900a2122caf99f73308696251142573f1d8e6290f81fd101ffa72ae3e2ca8b743f0011579e794aa65492b11cf373b2357fd8191f3a75a38e2a182da82c26ed62fa4f5aaf6fec08e2881322f9d9b9d96ec314ffbca9ee597eb5fd37e43cc4cb60c3482a9475ee95d84d9d0ec6f50e151cba3b7fe55de5074fdec4c218127cf775b473ddde2e3d221386e0dbabca64931dcb3c36a69ab1f891690096fe4518f91bd867361c02eb00cc054e10b9a78fed1a19291e76f078dcb5b94ccc731c3ea179237462ca62d262673579496a4dbba19ae33572745e3f1f6608f3bebf2a53eccf05cc2d7b443bf7be88313402ec956a11954da0db371b4f7517478ad4e65915d0764a50e6317af36155e3712142e3f2cfac8eeea74f797fb697d2e9967179a0b0c7ce55a0a3e71d013a2a03045a13c81f677a273591db10a72f8d50269d77f029d9ba598585752fa72cd484faa2e508c70e50d232e85ab4d88b9e230d89f6fed16f500e246bd48ed1ea3ea0fde06eaca458f7228ed153abdb3466569073c4cb0898aafdd89810a626a96d4abed8e887538fb353bbf87510a99a59fce3eb2251112e52bfd5ab0911a97333e5e7dc4abdb41d3344105d5875e0811de19b709e88728cb3707d43f15d92fa206a36f33782514e9eed4d6d401250f9a7bd4f0eed78a5750c2ea2fd6c7ec5c810b96d11170b7d7cf53c861ebf6b10c4a7b711c7630698b617b2026741330eb13286ae42f6d464f528841c901e15d2193816c0347ef34bd00a11b0d8cac04f2602435f254be7f127046fa27ee8b2e7cc49f3d2315c4b1c101127d9773d8b1dfb820ccce210ffdb389a4cf8a58b7d857c844c3f4303c75c00b84461246a99324bb07c1d6a363913e4c0925e8cc0afb4fc73dd815623dfd06b5207212808ab3acc8442353b42e7d2fd35b9b6bace99c2b58dcab1ae2483c15a8565bdb6841bbcbe3c6ce3e924c4f85ad0711d5742c10253ce494ecacd56a7bb075b5ecf99ad8a2cc9f1435cd51b06b1f37f60c5145612ea4519e59c4302b33f1583f78269ccf016b4de15a49762af6081d777631697152206494cd73a3e666fe69f71be10201b6a18c7dc5f38e9d562f45cfe78dec0d09d390d444f1fc85a265938cba5c9555fc9af8bc84f7a8d0e14aab114d6667ba2209bfa3f4290735bbb5dada48971aa373e04a60f8516d8f60f54587921ea1bce9f7f3c10ee333954794a0a4f747621b30898c235c2196fe54680c70fa23bce5fac97c3ab37a8e27e0a228057c6bf4abef68415edab0f0750a1f2d05c2b6add4f920791bbed7b8105025628e4629574165136078f1e9d45c99a4246d45323e8aad48eef59c0fb704578f438e9f8818eee051442c8355f0a6082534774f98ca88a5563c1776da48f2d931b5c40c7c5147924b1c523a60c4a93fd80adb01cfe2a540b792be2bbb2365c8ecb1abeb4b8f8b6254aa222830c2ac3019f903f005ded9e8f91da7cd25bad34b4e0c5cc319ca07c60538ff9cf88c2d2307818997655fa0d98afc782f2f707798f0cb8b5b9dea0811dbe1e737afdd305769166b7ad462eace5ea9578bcea89bab20a4f148b3c2261e7694fc1f798bb7c376a441f85098532694c8fcebaa40707cb605b49d2cc07a65f4ba361f13eaf428c84e12e4239a9dc65956d96e2ae4b449a8d105bdc97821558b1930aea09dc172bba12f6893117501be285e2f4b58867a67ea409787bd3dd208da690a21648cb53771a332f40a3572ca17f1f2ae368707ec4ea4cedddaad54aa4a624791aedb3c71c96ada94e627c36631e3d720df8536eb33c92ed432798d66b32e6722ad3c448e62e299dc00e92e5d32621099daa083e32f7622b242987680f7b90e301a784aac3ef2829b2b00b495a68432c1395b42aa55eaf02f46b2d3d427bb2a3ecb28241920862c122c20cad3601964d8fed65e2983cbec2f32c29fa48bb724820052f07409bc9ad7133c6ee273d9bb6088671f30f23c8873ce27ae761fe54b0d6ecb196d597de771419f923f2c541ba06f59c6e183ebb413a803d80fd007e4bf6044c79537149f913dbf0fa01bd891746915d74016cf7ce23fbcc7d8e223b1a9db0fca6aa274385694c1384496b87563d82168a526f40b95a9d57ead3203202ab6c9ea7859c6b1d33cdf1b26eef166621b3b148b634aabaffde51fbd58f4f87f462602a2514756395cc412449be38eae1e627a7ce667268cab3886090447a7bf96e2ab1c331d37dc0c7081458955f241846d34b0b56e50f9717ab9d6a8b74fe6c6d9580326243c0f4975d1ddbf3192ec7ad275b59ee3f7ff47c46db8297c3493fbf08d2e6d84c3b53baf7de8ad9f89824f4440f78204c6f013de6f61e4f371a4a21b5a1346c4de72b8aff41608692271dc68edbdcc99a097b0e16e0a09df9eeeb9af3907fcb99e6f81481e6d6a8d55dcae43b9716d36cc8dfed739087f4f95782b725bf0f23a420381fea625d63d4ad69371b705e79876a451abae5b168c5283bb1c5edaa76f4455878c15741d97bf9cc1fbdacb841c3b0eaaba392872e0eb3cbe32aa9f319a0ae5d11caf66eb61ad3a96faa4d1a32795bd47f6aead68fdb2f21d1145eb9ecf80223216d1495b61aed2c9515cab4b78c6414b033c09b5ff69b63d274d25eaeb55fdb559d50b19cc459b5437928bf05fb0865e021317bc222b7b22ec9544ffb3a5d7204c6ac36223452d66578fd3d8dfe8a63a205146692a7ba581fd5ff6483a13dffeb80836dc8bf6238bc3750b1859254a5319a39f9b322fdb57cb8cd7c13864d534b33222e0224d1f549ef3436eb2d17997c9404e376132243fa6c3c72feaa1620da6807784a1b33aac4a5d671b70595a4b6bd59473d4e31dfb3a40f4470ef4d55ada7cced2e86f1ebbb9a6a3f4d818b589d93eddef9cf8429dcdfa608f8ea05b9b617e8856843c0d04bf12e11fb05e216f56359ec0c76cd7025e3f368f268f9a3996d9757558e7e12ab39c19cd5719de75ddc030edb9a1ba15626fc419c936259cd860c543ed1696b4a4d333e086471a489d866365f2c26670880b216c72756fa364b2c5e1cbdd42d187ddec180be2f5b76ef21cb15eb5647bbf4f4a7d2116646362d074f3f865710ea4e2f34706adf2bdd76d3e26dd186a284a97f1876e7e1fa616ddec98a5c0535bc9d9ab2d4544b693ac3c2a8a907d7c322f14f37af8a145d581d2f65f99683dcac98ec162a6ce91c84c9c80caf2d8a87bcdd7147fe33c7b1cfa3cedfcf20c115ee6f28423ebe59628b11c2bcaad0577e2ad6646d7cf1c94646063f6bbd66100caa3164afdde3f45bfd35a504917e25d73aa0f64810d236f8ca87cc0847300fa8c1dc481ff412b6254446adbf5891944e9e2a254da1d7a72848586fee0936b8164b60decfe8f78406cbecdd9ea6e06ca96b67a06d3354bfa4390dcda49d35fb4a3b36ff59b5409c28f515957283e5a73fd1181b223c758e677aab70722f35c78e8180ab84c1fe03177ce7c4f977ec3c685cb1d2be907fda2ff350e54a60e3c3c9dd56dedf15207fafd533452640a52e709c50ec802b3a831693fe3b28ff976c4a6d0c16e72a3f3f7b5da361dd6c423893cca3f58624cea703c9189194771d07e6a0d658c88e39ff1b3402ac77cd926cde0943d37e2e99d34686d953330891b66f5101094eb19435b4085e73bd471ff4228b0d8d7a4b3e8b920b55be140f75529d53da454719d5f1038c68d8f76b2ffa7e326a73d334cf75d8c51b396cfc4a50a90429a09ceddb1e295a7ba64faf1c8f1b9d350c5e110aac8226acefe9abd72d65a1d4712ecf050e0d76c5a296e19205f1de3c08276ffd333fda2d3fc6ee4a0538d9582040dc096a8bd05f20c9a8d3317bcb2fe4d4ceb0898996c3e05f9534434cbab90bd110281bfe8994c47f47f49a22ded40e2f45e95ab1d45e827b51ddc72fe603d3893703b14f266fd4c6eba4973a0440149d196144e872ac9278e93f293c5035f1c8765dd44df976b99a3ea80110f4ae749c731b4147d7d8f7ed8c611b0ccc1001f1285f9752b03153f14ec48eee013fdb239b1d9ca55b85f1bde3387e40cc1ce8ced190c7d70750dfcb0cc5bbdd3814a737f66359acaa13eb68a3b249760e4c1e1c45d41b9a05f59fa0ed82ccb459b9983a1c916893c003f8a63581075a8fbdebed00202985f68a8ff5b49c0d9d822c1e639d3cccb98d22850da8e04e73ee6232bbc2ac7b42f60a58d30f47f634744d5b8b7de63345495b1d22610347f364acadd2dbb0af4094c9bc9a5fba88b82b43ad1bf84c3e6ba455a264dfc2609305dc53eb6c02c7da2199fcbd600478466cdf8bfbdd6a470a3f26b8b24d0b7328bd903914f00919a693d6d2b2166c2c3fd6551755deccfc1fab584c4798e627d4167c9dec16d8a338f36d2143854fd56f03e0a8524f55cf85552df41c1046df711031dd34c25f973e31ab290a90e9890a112c4877ab50ce0c0f95ef099100b4c4498aac53d78eb2b433867bb1bc04caf7e1f08c9b9c6b17a81e77973a3071c410a0bf07cf2c32950ed76aa956c551dc4f82c9351aeb0443839761b46f842fffdd84bed50939c8103daba5e1fd3bf7d977bd19b33a8b435eb285c96a6897cce09f332914ad5e0169e91acad5168b1b700344de3a298feb63256dba68f6143cba449b80dfed369cbe16c968dd078d9895d25459fb9b6aa7bde563f7832eb913f9e2945cbba405552f7aa25589ab6fabf4a1c30da8da3ffc40fa1abdcfc5ee0a52abbed3c3f9e494175533db01849fea700f5cd65ed28fabe6e6a4721f217979675812a7ed1af7368412833a7fd51441192670f035408ffdb84b182c47c14d371544c6a5217fa895b62934d3cf9332439091414193bd745a835b077ad7b8bfb5837886e0889424dd2e8098c1bf4fbe2347bb3380357515db419971a84e793346323213dc282fcb4e1326a0e348e823f917274af2cbe31369af633381872a411deca127834b50390459803250b357ae3b047f72628dc952326e23942145f055fa4e1187c6d61593961d957d3b698a3cc64c18290e92c414aca65d11d2438347761ea79c0d9894a849da0837867790f7be6f311eaeac5202eaaec741f2f78fb795574f17bb564fd2842c01989a81ffc91e64941eaadc14248993dd2c27047cf6e7864b3506758a0901bfde128a4ba4bc9e2c9aec0a31d42934efe4550bee56dbe97bc85b5bfc4de19ffaae072851787446f4a3722976e7b35d6fdb30e3ba0f807eebf50356431b58ff65f5d06d32788e893c57c881ea4b74f1e9d57eecf3699b0abe4e7dc15fd7ed19fe1e91a3827044b4312f857079aa9d82a5180b13743a1f59529dfa011c11f4dac9d5419d90cbbe30c0724bcd6353c61bcb3030794c565d16643ce2d58247f1b52f3c584e9bd08aca98349eba0f2bf7118f32bf214f91275d0f81b1e5263c81ba17c65357a797f07fe56943d522c7d2f9d0b36d92b7b2e1c733bc64a47c3f0c8be49535b21967a91c647f1976cc183943bbe893e0b22549f74114a81b79e901037825cf695009247d1c07bf800c56c543daec603fe0ad667e09edc5baf9fc62fde57f08e8c3441f9785b29de0378a9a0bd44871b958616fc5c03bf427d3038e7d8f8a4f42abef598a7fec300d9ebf40c4b93ecda44d667813cd6da3178d8b88ef1d87823cd268b187a66d182907336788191c7dd98dfacbb15eaf2f4e3d0cb828f7aaee4a60a59dc2abb637055b6a2c463404b7e8a68ecb110516815793cb88d7dc9d184ad6dd3d1413a64e0c7bb0cabde0c50c973c9b38bb5cd597f7f931a63b5d1f8ad74130184d8faa6cab94b1e804835c4c681f7f306dc3c5c5befa799cfd117080b8e8bb8919e3ec7ead67eb8a887412cd4cee5a96ec8b7414cc729442bfdd7df9660946ffbcc807f36b437cd5e07d5877b6c755f9f6628b238721abb49eceb7f0d43db00a5fb63eff29bc63efe1944c7584ef093c61640054c4fb56befca25eee467dbd584d47368c9f86f2fdb04ff58bfa146c91bbc055c8f0e788f8c5fd15bb54de74044f407c9b8431f961d7dae8d2ca38f1df0450185281c2adf21d6eaf062eaf294c13da6560eadc558e141aa93a2e15fc67843854951cde29684e12b95419ccbf776342e4c02d4b4edf6fdcb70778c8cd5d0a4799e9fa581c603fff10d51487d9ae0c3a97cf5ee531189267eb167b17faebd01b7b71c7af414b19cdf0a198f07094b1b158b8dbbc7c682beb21f385b3ab912e5c8439d2e62f4b65fd3ce08a44430714ec80d584acad5fcdf0586e8a2b3d96c0cbf25e55d39beffd439b668130b73c6f24f438173528edcc667f1f25e6292a5c702534c199a41221c8350ba154900ae33ac321a4235f79f43fe119572cdf1a7220fccf09d74c618feaf6eff04e4ea574c11cfb1d1058484c221c9db7425522a6fc2461b2bbdcd7d56da3e560aab450ed4682828168859c621ea47d58332c5fd53fe7152ae2025d31ed2e49e645fab2cef99cc1cd01d044613b2b621b13c1d674821131679694f96a8579b34243d125962c3fe74063a6870dffece69feeec7e0b5e8a651aacc6b7b336849ea72c6b4d7f6aff5bf83364239c8c66a0bbfda644db7fd1c3dc86e4735f6bd651159b692d8ab4246aaddc267b1367c899071d3e351948163b4d73d1ab030242199e2038ed7ad463507b145a785cd9a04a5d79fb73d6510e6a7f7676c43cf142ea0f199b25aeb22e72cb6a169a32b6c2cf51305a05555707b4c2852c9d2573d06acfa09027c67d3df0496880f308cf735aac56271a89bf9293280c2d75ec49241c615f4349a7dbdc96eef9e3843b67f7d523d8e708c4664e89aea9397682861fd01ba440ca67f7bf82d5a4d1fa35520fe57bc87db9069aa44f724d33249880cbb6e1e175a8b5d1827caf9e1936c33dae3b5286f3e44c2543004f8125fd919d14aa2bccbd1795ae6f97e455464434979aa63f427d6f684c50fc046f47243bfbd6191b9f6def7217db5ea67cf2a241a9a2ace66356f3d345c9b15556caefea84056ccda568c6bae7d348cbd095b5f69ee33ed5d0b7aba2a16edbd7e1759ae39af6d565626f64ae6c0ccd54486bc71888920be3702ffe58050c756cd1b032da460df20ad54ac18597171171ed92fd488218b42e2e52ca51fd76688eeef0abd9cb53bb929fe2a1aaa21124d344f24e07897675e7c82c406f5fb9b4ddb7c4fa3536b576699ad17e77550c18589e246fb971cde586c7558260813022d915ca0a5e43e4b5db23c980144a538370544e912f298d014eda1c9d541b1101cd3e3aafe441f6fd14afedfe9b380d0e70c231edd34cbd29aa33b61a9fca1f28bfc5402cfda0447f0836448689e6d8cdcb1df8c06e7486351262266d6c34a2813b5c78863d2096d4ebcc4d2ef631f23d370d11c2d3e752aa42d086748b840ef0c6d0b0f26cf3399da01ad374e44cf63909dc72cd4951b36a623e44bd7236ed8bb157e4099f85ec89d1b1c1f820b52e299e411288e9b485aab394f0e88af1797545aa8b2eb03bd98727fb0747111f73b660d33a48c6ce15f80a70cbbe6563a83ce98d199a4095bb19b9832db93b33a73597a7d9c4e30eeed44c631d77ac2b6f89e96eb1a48ea0195b7e61fba435f94c069102b6e2c5c5aa7706f5b62a0df582102027b2080eee7ef4f60cfafd4cdc8504a90b05d30fb99ae2e2b7b566f09fc25fa3e51d6b49946faa51ff2bbe7f0d557bf8a63c7b343f732a30bdc9e9ad7cb91c33309399e8c51d2e584f807fe64f3aef91a8954205cd284a3b07b9d06264c9fbd3bbdab9956855d073979ecc4b0d5972da2284f6ee4ba72345c748e4d7ea2e0a3d679f8106e3ceb4e2ecf4267dcaec4f0fd5336d2b57e73038399acd4d9cd3a6280dd08d6bd849044d51552524055b8de10b28be7106b26eecc1550e41f278f9b93611b6725e745d8882f9d277f4c92b11336009514857637bf0a46901e35c766722522ed1a6e8fa5d0e41a99a2d0461b98d8500b596a3809901894d9eed6f0e1c27c470b50f2bb5e9d8ba55b0ab9da7ef80d79382e520105732955ded09c76ead93f21296954666c812743f23432fdcb78850a4af1997a9ed1b2f0b4465d34ba9be0de093723488026dd1580788600aee675cfc88da2ad83fd11bd853df30bffd77f4613bda084531ed000dae57773831ccf300aaddedb4b5e91c38b446673bc842c99b35102549f8c55b5a7109f42db6d8f2e24aea9ce921fbfbb856b113631f2a27e3d853303f3e980aa48b0666e24c251058925d853cee174847a0a365ed730f1ee511ec96400674d08859f3fee78914ebb9427291ac5dac855b25d64ed0ba75fbd4b8ba322d9ef425fed1808c7caf78143d30f6701ce869165dd25656a306675514d8b21b7c6461fd2c6e92253474df94c21a8ad9facd08935047a4a01e404f486ec33631e3b48c34d33ce5b43529441ac1b28d41955a56c81e45432148ba8f7925f015af881e0179392f087d512de7d671fa35986508025fa9bf37408cb6694d7ae902c5dbf395346273d25b638597753f8f8ba77c7b0dd727d3f8fbff15c6bc853568df840a70b1d4af108df6d2da6545f20294c5687b3418139da1912cc91daf8c469b652909ca072d5a879d7ad98e00594a78f980e0827c46067f5bb915bb30f335fd0f586159b3f1207a0e0f798048fb4dedd53da2a4b08808cebea2f9c2cf6bcd5d4f6d7803c167e75beaf6b501bdd37e0dd192534fe5b8879901a2c0e4e78f64e9fc42aea125d6627c024194323128fca523c0a1d0634da61300780b46949eef6428c11c0e0ca4bcd4455486ce147f8ba89f5ee9d09aff1dfc60466232df360f222171afd9b3f93f6a2fd6f09d57d3c2e2c493a5cec539980193a6022f3a7aafbb6093cbc5897feb1ae70164d9f22300ae7958a7172b88a42155cfabbd4cb41d7a52d67fee255afa2fabf89b003bd6a501d7757fe37de3a1ad27867854987b5e0cdd3f65ddf068878c382318291baba816594b49ea9aa8284605e48d1a4d4b60312136cbc05de47591ef33816497e946eabb80fd3745752b3bed577f8a32802b587b65d611f2d5c821375edf3a649069121dd32a5dfaa17d56d32c187560f28b805e23686e384d05a5f66fb8042814e0ea280f1c1484e0f9fab665c80d7b8db6c1d6ca90a98964407657690220d4b80501be6f8c3aa5dfa7f4fd1f95cc24b1072c6c6e3abfa488cbb256a9c63ce517c246504b6cea0f0828c14ba6576ccb2a2a14cbf2cc5a49ee4f75c52119d4d301082a567c3dbd6670fafb4a341b89c1751511ed953f86d928ed11530192ae84ed9c931161c47b44346a42db0e1e364160b9fb20172d25933b4db174594eb08ed861b7b58710fafdf190c283b7b06bc475ff6b89e8c00e976f36e5c2301c7e97e481f77e3cbfc65946980ed76654c236464d0e6d8fd0ac9254ab98b364e27cda9e05d667e73fd59656e3e76c5acf229cc3a3c9828e5cae7d147615ad9d24812f23d30f3d63579dfb02c79c74068e39a765b81951f28f0995a831bd0e8328d48fe9a8ffa4ab787595f85726f3aa7d5fe8eef5291262fcc984d1cf882857982ad9d77b78a747a2ec033ff19494dc104f228d9ddd5c6f9879cdd6d4bc7cc60ad1d2888785d27c876772da6ec7fed0cc5b342610ea1151604348bdd6a84e89be59ef174f23c056b156c9b756b5c7d2360e435536c03ef3d903de70cfac06a5628280b4e3483fa2242656a27fccee7fe929fae53a5fcd35b38dfce836d53c9dcc0d1f1dbb6b66aea20f79ae26de3a3b15e861c3a4c71249d7866cfef2938cbf159be2df180a1180738fc3ac8458ca4f1ee9ab9342b98ac7fb18a93b4ed526904c96a1d8f598117dd61b1741d6a54dab482e2c26a2e8f70d7d3c2badb975c4ec372ae00b824dc456a64198244387dbbd179640c947a94f0c4c7708d438f27bbc757a95bcdcf7e73140414b720187fe3c1078cf8b96858c8212f884e1581e75366f4862ace0fb5b01b034608626cdfc6d706f8682ed80d60b994c92af10afb98f9acf3036081ea00dee9387c533d7d55a830fa8b3aaced47f8336063890aa7078752b7d27a923067a3fd1b3479c218b209cd3813c10d31e9a62ae7f1a1e5c2d5269afd354f0944ff1f7a6f3818b336e5eca34b8acb72d86b3a8bfabcd2e187bbba0581c5a6f71f1882b44c6887a2a925417b91baf17f84a6f4bbe3f832846971434118e6d55e4cd4e3067a7c3f26d1d355efef6c84e2f9996c90be3ccb3286b99cdb2ff6e53c5c0eda702da19531db47f236d964f726d52c948c2160ee992985396923216a42b949a03062404217e77f0543d141223a861d5bec896dd7fb7040a159ebf2fbd62ced481095d849fc1ae3538617588b3ff9f93dadb618cfbebd8bda9c2a8a82f012b6ea839a04597db8a74c08506797b99d48d65a61756a3cc122f195fc73453b250ee76a0004a0f38470ff10dc60090698d5d22201ace96e28ef187d637b8cf75207e0b580560e01ccc1ee31a118bf3035fd24fc506d1dc05cf4c5d6fcf215546ffcee53abe6457ccf0e164a5a3ec127a4377dedefc29b625540d70a66e6be27eda3b1ec42658a8d0031d380b88dcaa066f1be2bd47c2df14eb661cce6f7258e6f6b7bcae794e24fa281c68fd6e72f46d2b15e8bc3100f773bc701d7ca73c4ed4f30dc8cc88bc51f625df965d4fff3ab8eb0e4509acfc718d6a44eda1a05c09eddff35b835060bff50a250417c3547308ed2d1e83ae7829410a15c28f4a8639d952b5bda71332400d2149ea8b9f04ae0c14a44c690fb45cc94a144b12c5e20a5704661e24498ad3725c828bbe8b273d7594a388d91093fa2d3b3dc3191c62f1115969297b9563d1c70b428499f2e5e51d2cb0409ecdec9cb6daacb6fd7641e0be0761b93b0d15ca247746c8a08c81974c442c311927f83446c59deb3058776740d77b7911423a3ec86933d75a77a647c530092c356901cb8f586c75a1fc09ca2d8da20c0b2450f0e7db869ddda4929151a8a73332c863d44cbdb4df06e031a50b6a4d8f4653a4ae6ac75e35b789397b9956e498f87edc78ee325e3047c4034b0f747f96d058562e6ab349d80cb4100b708584983621a59d1fd01d8b2c0158a83557e220c5dfbdef1f5a4216b1bb3ff6b5a8c28ee5bea1eff8e10dcf026314eaf98444de56ae9da4e68d1cd3f985183020956fdcdf1dd8d83a38f8ebd4c002947cd3804ff3da95030c055e997f9e5f0f332c9139f7e0e7c4aa791286fd5e1770321045a0db126d1ac8a34fac186f373b711770f4aebc6c57c65ab7063ed2c273e3536ae93318b08653f36babe6a6dcc833b092d2268690fa5b05c8d85d9c3b1a95e87c036d30647037e0fb3e1d3a8e5965f5207e138b5d1fd82c7e17297057280baebfb6c57cdb89257109c3b06c2d0e55c75c3b6ae23612f0157fa8fd56e3a0593d381d692e71376e26e0230c9331ea906e83e95c255833b50feefac8ac156fc33690d8188169a321cc513de3f0fa4f61edcc8ff4b63262067be927e432faec030b9ca28244154ba4f87bbc7c8192f61dae819419f47e373fee633b1066c5d7ee9c5e91f4273dedf6ffc429534dc21e51e3ca03aa31f1744193b905c549543838c923114c105a2a4653c50d8309b9cb0da11239dd007d2d28b69bcd9e4463f5d160c09aac0bfa16eef984d871d89e1236579781e9033a337c04a4754355912bb0d34198c5ed48a9eedabc527f10f23966618dd1f5193911b63ef30b4c8a84143db709adc327000c4366cce7914d1cc87b1474e582be09b9f4b4c7c88e1d3d2eb7b07d5747c0f7f23ff5ccc558d2ff7801a2845a94316fd7a09ad275bed331ac54e7cc185c4a8a4a6e74ef2d2c2442b498c03498e3f401e9e3a4ed3bc4693f1ce93b676a7428375cec3d294e8bd94cd2346ecaa9d00e229c87ce9770408fa8f7d55eb7e0de6c15a5f84ec79f204b0200fd90857dd58d7beda8b64fed475fd71e57fc2092ac92e74860998662ad6bd749c4a4f330dc86f13e23e3ac840dc96923e38c83e38e8d141394f6494a50c845ed476a92d65c4a9e9212f77ec2a7a7f4c5cfc2fc062226ee5d87c2d795a8691b33aa2721535be896b6ed816710b6e29a3930649431f753a5f2c02319cd9c13dbe3b087fef93146b148506559daf9705659ea29ab9838a64bb76da70e9b4d97976d0c854a9c6bf8752773a61041119383b16039f65089631e0240110fe18e2c10d26b5ed4b64fd055f19f2795df43d66d312a698f22519dbe27e201bb9e875bcbfeb8de382b95345f9ed096633f98fea7d3b33461bd7a453a68068bb7d919b7141d71c457305c2cbd64ed0538b0103ae90609bf06ac303f2e329a8ebd24313178f776a6a4132445016c95ac0247e92b0d402236b594dc50f54091bdd9f1fc9a87c25c1213c15074de8b0b1369d1294a0d248691ef717123bc5cdbe92d9cb382eeac7d18ccec82fe9e962e6650b6fe6b713909c271bba343b8d1c183929ff0d6b2c43d0f66c6da962e2fa825f5a936871de90cbdf4241961b3a0ae0ab96d4222656bf98b0f3cdd2d94acbb5ad9c834972199105c9339d8ef505856cc71d97f17dee4213b788942fee7db0dabaa3a06bbfc148df19929c9e5e8cf6c91708a56952753c39e215bef94cb455b20580dd2a5905783c4e6d4d57a65e56bea925f5792ead29a3ea14652b9d75348cc11024e795c445699238691dac9665841320bd0db11d4e5cdd2ae57e8056dece144317a4204ebe4025efa6d8984b0a6412407e3bc0dca615d40ea9bf680ac1f612520cb243f37cdb22c135a63e788ef106a2c2e00b6138dbc79aef0034b50d3aabef36864a581f90a80c06a64a69bb37d71e4de1f660a03d215cd559aa460b7b68b09a818e342534c7f41bb6f4ee63f0c606e4998f87d30994bf72ea19bde07e52444559e897d71e32cd397f196725effc04fab55949bfed9ce5bc962351e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
