<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02bd22701d8f871796ec09b7c55e4697bdca01b6651b3eb14e67c1ba56a48426204414acbcecb0e648d97fafaf2390a579bb5d071986e46f92b1b4f2761dde8990e5680c4e62632343320b35960414cc9e749888329f9fcf21348b16acc282c4d00f7bf1ae24dbaae0ae3582023b1b9e64b1751acb5f4f611da30234742cce7ef3485f504dcc90cc91942d2e63f980e2c4a04f78efe82194be77ac6e5666b182bbbbce2399e7af095b140f15e5d9c3c247a15b59bf1225a4c065fca0097e8842167d1cb1177460376d5f4aed855dba2754c850d528464a17d13b5e49d5dfaaeebd2c1fb692cb9d66de385a2fc0e5f1866508daaa28c147cf831d1a0350927a2bb977eaf5724dfc804b6618138b85a4c2154bf219b4facc383d72ecf3eaba9fb658fe8ab9f61cb0222c2cb673be9647fd92dda13057191a7cf861d75bf0646ccf0d2f408a5d3ae6caf0d4426a7a8e395c7cab74b8bad1769b6b6d6f97124e2eaf22352604b4ce4699744f1b6f3752737d982d66c9e488f0334de10ce8faa1bd6960f8811666c973ea19cae54d9c72e6505deb8c326e4ece0eec330ec46e1b7519f8b884d23e2ff2ced5bf2ed152181e50c08c13c7e2146cb328063af338baa8b120e0ce1679d7253f0d7143ddbff0b1ea3797126567200a48c54e173e22fa06e0761b9e7807683b7eb394e14d144452d352840a67ca8fa64181817e392078af38955807d5d9417b9bb7a2ad026c53b262d39a4c3bd57446cb6efec9c8d5eaa13a2c001559da953060c87aec3a1c29635ec429dbaf8d3f952774d582deae46d2fc69ca3fd7d38cb5648290a2a4408ccb63cd8e19395c9dbb538f1424f6cfc361b22fc1665a6326f7e607dc18c69e9058e0b0745d8ffc6695b0c122b816ab75baba07a986474a5d4c9f1f21f5d5c34f758def8c6e9a43c75c9d9a639e84d790181c4e0cee96967be546adc6a1922aae544ea8a02e37da61b16c07e993d6520feecc372213e106be4c705669d2dcda2fb3587e5a718374d58cd6a27eb5a910e8e87f0ea5995c7de8837d5ffecbc06f138bbf168cf50c22f14796855cc51f418f07e4808e1c169b9d5e02c322558870defd202759cb8b5426a53842989884f09a2b74951ea6cadb101da48afe9147eba5eda4a61fd49b21d0984eb1c78602738d8a75cf24bc0acfbdf59f2340e4f997a313c076e7fb55e96f7f0a6ed5765de67d3c3a03cd42660d5ead6fb3a0e141b4c46675136beff3b8d66dd6e4252383053b26321737105f76be8edfde0f18fbe6b1a27bcf92c210589ad77e2c6360e4d81ae641864a0f4a29d1f3d4b6fc5743c67601d05bc40650004fab73b2a0c5df648432bc4f05f5b3979bb7e2407d7445ad1bcd47c49918e42642d73dfbc0270cb9dad1fed7e04628aececc4a8936b3ca240952d1aef70ddc6039aadece46861bc78717250da9f503f59d0b0a8afdd7d02e681ebc6b37f66ca5c8dfdd7462063b0823824215255a445f29566a75fbae1158e38089f7beb2735cedcee518e06ac8fdf4536f6478f5e840dffd3dbbd9973df1d32d458b99fd8511238ff8d0125f12f94ec010890576c81fc6ec836fa0332a6c8627bf9601d1afabde93b82d029d930a6e0807269012e59e4fb85cd19dc937ab59ab4212589d008e32dce2ddd2ccbef89909abaa69fc5cc39d737df9ff4fb5b4a92c0e1ff47bbd6f1fd8627f8d4810526fa46e44446f64233df11ba07904e50f97be836d9fa529d91aea62a4af6cdb5f22a1baf1486a2db7faa0bcdf3475fbd758cb1cb1234b1c441e1d36576c45dc50b4ae0b7da67c66056d4cf0fcaf939a9ababa3d8b291b53d961fb654597361e18c8660baeccddeb49532eff7503bb4e6dff08121b78b8858490541e433140788d1873b16254d4cea48d39351b907a5bf382171e782ac550b2400f2e1cfe8892c08d2b5c9551dcd0f8e282d52fb6016fcc5c70ca77673cb365006cbaad330d39d341db4806a35db87e5d329b1a71a2a7eb8716faa94834d6428d91fad12ce3589def48855a21622f272ed690d9d2e6e0f0e26e365ccc5454bb350aa4b33cb1c4ed26da33f6fbe6d50818fe25d48b692cc6d69cdae6e44a1843745efc2d601ef5070081a5a7ce8e7dfb412a91ebbe7d119c7caedf9994f0a7a7f76be0e467859e91288c545c21cbb38144bf66252f887c17d4a6a1f96c95d798f6e2576f6cdaefa2f4996e0da044cfafda10171aa096c3e304d819b4548ebee87832d8b22df779e7d59ff3d2c32d3424808eef503e1f35eed90c30d9b6c208331017156755f0d28f72b2e61fe7f362a673df9280dc3edc2167dab2783e236ec143d74b35ab0234a8ad3f2b676c81d7a856326215dd642990e1c3ed8219d2b45b0172b7ec2332ca347c9ac4e2ab176f04ae536bb61da73bd42b4e9f2aba8f4f3beee3e16499bd5dc172ed9568fd86193f52f8589a2b1b3eee8c0b5a2b91cf6d9d999315dbc258d88861856662ee4b90a65570e48a97e66b46c74e12abc8098d50ae115926e62044cb9227127e93475b97fc30fcba62ba984b5eff4445a5da31900d7a34c42835bf3a632f9ef59fd029494d1913bc4bb1770753b0bd55d862bf8529c298b9ffc052741fc5958d9c4a0fb9d30386b72e327af26c7bf11b8634369ab95fdd4a87335347e711cacb2ca0ac8a7d7522f048e1f5f33ed8506e87109c00389332a7ac943b2595d0312df4fefa066c4c25cfbacd6aad7d87591c7cdf93f793b76296ac6e71b4bc9b11c3008c62634e301e70fb421d5bc426f8154068426e229f8b5f0f67693e8f81d26ef7a9efef520c3c04c242b9417fc12a0e27675f7fb078adc8f66c77ab2d5a5bf4e78c317e1f5c8526597e5fbaa57ff5f8ddb915edb40cc5188af039a6521f6cc0012aa83df9b3874603a087031d5d47e8c8eae3ba6d2b4283aab5c765ed093c604da999eda389f5b214c03852f9b614b6a9a89cda9c0de2b1a1d5375c0d30e527060fed267608068cbbb6969c06a0284e370dac1c9ccb2cd8cb921fa2cbf67cf902164b775b5acb9b70a260d6c88e7e4966f5fe8d82f3aafbe4be1dc6c5b44f477ba7d0a29ccc5960461e5470ed37165dbc8ff9bce245223f13b5187b94718c5f24b3f8f8eea87ff2ac0a68baa9508aa37c42689a9f9a052b642da2f038fbed88ee6deb93e9ec518a1ddda2fac2f7e866a47c1c5d1ef285cbaa28fae329f5e289d20f6ab09b9cc91dfe87a0795108089d8b95fed72b64c2338149bd3e8c6464b0deedd5872ec5c1b19879dbb871339f74072c18dcc1e79f87bfbe3fcfc8f5c76220111b900e448349da9f0ce82009e6353eec68ca38d53b3dfbc293d5d8c5f6feb7457073f6ea72a34b0196baca76e4d770d4fbf6e53df68212612c26dd3efa364fc11146a92b4adab22ea670d0c10fa665890edb2809587a5cc34c3544f95a8b9b69a105db5d99639226bdc3ef485f93cd3642baed5d3e29144af4eedcde2ad25fc6bc7fdb498f954f0e2d60f9ce81e1f29ea2b7660b039ef156f6f5fd91bbbd5265994107f7dfbccfd67d18612f9e806c8f0f957c449f427a86743eb3833ff64c7b079210638f23fc456153b7617a236990ed057e9b2f9313f5c4e443892be2bdddf75e1005a77fe38e8bd03a4860db268783a71384e181f8ef82b5d2c511c54b7ff75c8eecd26db197d3d0fbd02096bb05b792048d9c422226281dcebdd7d63536220283467796fd6eae9980e8ada6e1144315ea91d74094f48c3e43fc1f973ad9d9a2624943a2b18a2704c1aec793696b01a670a181c63bcad107b8bc8d58a9778a268c5ed8554e459bf57a7743c7452c2c4a9765d7e3c8b0ae3fe5717d32504940c9fe559b5ef36daf0e2a6d386433036d4b8a00ad6181508bf1778952475e94231927dea1eb9276be8b3d9fab3f6e9f4081b5767694434d9b2b6ed50dfcdc5924e1ee132a8019909d5000bb923aea99640a24e183788e81abeb5a4c985ef8ea4ff4d0c12bf5f76345f8320f555667c4d3ce45481c108ebe6a8fdfaac185ad73e2e561846ea39e626bdf7eb04a629f02d09c86a09565730251082daaa69f2ad1e9376cbdda804ac925e3d1eb6d9abb403a9468a754f9a6cac624d0b1ce8c7143f3aac34ccef64e9ca89be112b1535a48a7893058b6b5eb27564e6a2701c6d92bdc2e4a583f95d7771f0af9560138e754a50748d5c6f41a6409bd64f5c53cc778755baa483e9b56a002c7f7f3af7220e8898d9381de4f2d559fc701ea5f66cba95a44152ec3a10221d99ba877a1a7a15ce4a7bca39f9705b0fb16a3ca806dd4d630b20ed0a914d239a0f064e71b0f2267142b7702a3f3be26fef61ebfd58af9f34e016d2627dea7438def3fed2dec9b0d00ce60775a0669fc6b360312c07c2105bdb48137579b8cb5c2321515d2a51a9fdd4c00bc4594e7c3acd8d98305b1049af0c926a53ea0a89fe1deb70511ab178e04d9514b991a38a0bd7bfac970e6d55489f99d26739e36f40d76bd8d714cafd2891d6d63eb309d97763abf378fb0e6068ded6fda0fa3e11477315c8cc6ae2756d3a9c4d9e80976b42624dd7359bf4b93a221b5585f804277cb75b70d18f3459cdc6991d7ffe5280229d709bc1045d9f0e3092eeca03de474f8ce9214326d80494c7a46764a026394ae42dd7eb3bd1b0124a1fd65e68ba2cd685ac97813c5bd691dd0967585a14fccb134a1e33bda5502107f3d90bc1de21bf96aa8185eec2f0c31ed4ea19aab22c2d2a6deb6c0c3e302564a7d1ca6b380e60f163aa874186038231e96bec59e151f339f723a512948407240e8b105afecf8254498e34b937f77c2adf89e9e0515a55cc32ad568556a4036c9427fbea7808337cbf2834210bf246269976bd2f33feaed42676f5a8f888e302ac78a3a5a2010cfc554aa917e4c7077363cd1a9e8d042d6a35b2298b3d48c2202baa97007e3440ccd0c1bdb7cfc29efefb9ab7b8e6d575c110ba79d832b92515352b4db2b3a44a585288480abd8d901f09daee093bdc1251a3224ca626965dab4ebd8626d7b27d1491bdc5b068ac4e995b80c43f96b359e1ebd9224f2fd82425933ccb4e395cc2e57314afe264c89fce59dd8cb30ecc54432a2631761dd75169d6886c652eddfc339298f9b5bbbec430068778ced75c6e3e8b9e1b90b3927374b6d59834c2a6894136e592323949090556a8e5e5b0333bc9d87f1dd4bfbc7e66a9613c02b0c46edc853b41c64f930a90cdcc7eaabeb14ad67b2ccfa5b73413831ee47b877802ccba71f5e0103fc074149a676eaf8f381890270af9e393c083c621d32ea5fec83b2506cd65e123c347ffe3747db7682d881f3834ca675630f2d56d7b2c4e671d3e0d9aedfd391faf337cbbc4c8c3c0a3e9e224341e413bc36710b9c16742495ba9791aa68e0b7132b3f08bd2a3f529b6d02aaff05da32c3298bf788981695c2763d9f1d6545ff8314f9b5b41630ce253cd89c31d2c5a006d0fd4791401eb4a29ef6880521fc186f9a3a6a29843651357ca1868585d2f4c21c39de94fbd46c1f4a36dd70420716e3636c05c3fe90eb31b5db389341918b518868c55b9a3a15a91b23a26fd711672af01227991b8d483230f25d64c3bbd35329e9f2fc53863b4ffd1e17136f0f29d972280d3598f51ccd821c9d22d8a525be120f8ad9300e3e2fcb557ba682066f24f0022928b05a89200c557fad91e7dd30886159eacd5edb3b93fc83e6197a7571910c91bc5f1cb4c1272ee48398c0e45632cd7ae3ecd497077ef4672942b571822b90dc886413aa74809d80c21d0d3c27e513c7b3e9535e301697decb800ed89b24d6c85d1b152eb7d9709c21a2e0849f7e04a33d33f0136c63976bdb264170a433377d4f712aafefd76cc93dfa6b9cbef75b8a8dd573617e37335c607baa68a5fa1931ff549a58a9c6e74828fde519a1a9130fb01c2ce44959602b9f3ebf7dcd264a17a248324f70b65a71b36bf9a614713d2b123bfd602547a172cf7e1022022b8379847dcbaed32ed8a80d30864495a8d130ef04add6389711541eeb6e72ca927dd2878355133a91085a33cf8a1bd54726366c62c7c0a6c0b82b46030cd948f185fc7038ebda9168af3dcb0aae00fd0148d083eb942031995b4a2a766911d9cd71b3774e44f00eff90de05ea518d9789f77a4dd35917f4b9a6108cccf004214d163bc0543b30c39eee636731cb5b282431e827aca083dff74c3cc54f4e6e2367539cf1a19c72e805789920abf75879202d8e9a9886e65c106dd359f61c5126af662de20902069a2d8949dfc7d939f3b7f73f754e8875a0ee35979aa9ca93c236c070acf61b1f741e4acfa3548ca2ea62823443c84a9b7e37ff7bed544c399a12df9fc0e2bd67fe46b76a1003225af243c9ea3230232f019ecfae5424093b35d3d5eaac30c0b21bf1e71a6b826e062a1b646812b54fc9bdc7287039d1b632e347637e0918e316cf3c8af68e6032963525c3116bb0b58294ad5f8328517d5d6c59446ec74a994661c3172f235c0b5c4cc80af1d5b643da978ecb0c35e433130d80d3c289b83782c794d484d3caeab8e24169d1f09bb8a7476fa15470f44ae0017165cf59964a426377e6128a79b5106d8ccde979ae4d77b6a63e4f9d920665dbe44a0a60db86a7d277a59f5c603073f0933cf455fc42ca292617a84eb9352fb7601f9431b8dab9b6ee7f0e5b8e749035b567210cdf2b09e916d6644f984db16c39426b4612fb39af2fe6d0a2f86d9771bd4d98d73e4ada8d7c77a3152e74f4194bde0634292b3fe0524d6057d7adf8810b25c8fcea4963ea06ad52a12938abef9555eb933317ad8b9f39435d4120ae94913b019ab5f554adae1937f065a8699b99cf0f131be55ed3a5d80fef4dcc7d8f917ce567c75f4e336178df7379a7de2df03e11add100c1b51d778d275d2595058c80820c24aa2258e0d316aa5791cfea426adfd393827ae33fa559141c5e8af9a9b459141ec838dbbfd123ed8069205e4c87711d646ffefda249c8c82980da2c7132d35bb54af3301689537e216829f95162516e1686423aac7ff8783078e807afe890219c608097c05ad36fe79c38dcf7843f637db6fa5304050ba001533504bffeb64ceb43cdc5bf59d71a1009c67fa43d1db989792c2ac34a938f600a492758063a854a2f510a65aaffff6c99d6a89bd206579739b4ce809521aa73df9018a0a4ac2e0e1968d0b4aa62fa0e41c6a13c1377a6efe2a5968b33e031d8d22370e31351d6dc7c55c1565908758cf54b687e482a168b077d1a72bffb8ec01d87c7a996a5a0ecff4ec1125ebb68d9cfc5265a86103a490aa51f878d5339c08bd16ff7a3b9bc862a77c8e6ecea0cd9f06b89181b4c2a41f6ce8331810852d4ea4320069b5cc22d1789e8f17ff0bce41bf02afffe74ec5599235753664522e5b5e2392ba3ac3264aed3f66666448e296c5f2af71d9163cb1d190098a05724792f34f3563db536ad640feac7e1e1380cc1378dc3147a977910b8b11bf88256a9710e79ab9ac6662ee6f305c3e1ff98af5ec93f6c48b0c28cb4f6d0e00a755dfad99e88871dd5bcc0f04c9c320c215d88446bf8943774f8eaf9f2090f72d3e234e8b6ec7a868773e32477a60bdd61219ae796f1d23704f1143004096c6414ea668c8a75ea8029345ce8226fa1d360703b07f21956a2343c8cf5f72f9196e1ba1f30af525928950ab8a68019a733bd7017d04f11cba8c271f6682ed9de8bb06c9db07628eb29fbc2200e2f305048e9b7f290836d80d76bccc7eacd6b4f5f27c86b40a7dc7238cd00dab9095d42395407713939c9080861b45aef034fee8208663325e8df411765e690faefc659c700c02442b914e70edda9e931128ffbfb536748c04d7db117498a73eea226ec744a5fac5ebf0e1ea2d61b8004ccc2c4a232af6c657348e61ffd52d9e0587d4844eb6d42d3fde638020721b5c78641d50fc7deed451ba8a8f19e6b22a7fc32f2eea7899eea91bda7d4681d9f2f3839b663fa94a9dde359046bc81879ecf7ae0ea2ea19eb5ca0c37278abab941c2d0dca5baaa0cf38a09fbe9851825ad04a1d31d91a7308e946085fd5ebf828f74e492393c10f6b5aefcbcffb245b38a49babed2d9165ad07bd9b4da77e713095d96a97d1252a23cf3f29fbc895783d1d3e720bd0021405fdd9def0d229a64019b3125ab7ebce0764cb16ff743928435c177f81955e682243c2ba71784c2ea1858ad09c20555984237e6e02b3c9cf4bd7ec4ed8dfd9a6d79ee60e26a8662028cf8760b69154996df3614972e5b3e0bb504e0c14459c2c0ec4b27e5edb9b3856a61b1c92f3c8913f75434bb968ae437c518e35f1ccafd75832a6b4f9c2188e390ea96488e4fc091a94bbe16fc20c6599260e11be69e8cf316c535485c1800166114b5b78ef6b3fc50b81dd966bcd6dc7672b9a38d13e4a8c3f5e79c3d06e254eca60871a966d28b7223b494bab0a96b475ab76c0ebaf4d70b0658ffc821f2ef50a7bc1b384e751f4b7de3b80d2106e472c1f6f5359a3e3f24a53973bab30eaa0f5bfcc7249178adce67ebafb1bd99e718f663ed4e2e7bb40bd1b596641d0cbc697ea65bcecb3914947bbd8d17d116d538150f8590d64336b7c4eb474c2558b677222e438bdb1b67e9dc610a58daa463c6548d3d8d241da4d217dd9c921fed4c90df590007bcdb9b373bac4e902791d7b1e7317a03d1b3be8231bf066dd51b66d45241a032493fb0a08deb239254b9d61b95b96a8ee3c5e1bf4e4e049545a5634a67462198c9e8055589fb10325d75fba3ca166b35f013916752fb1fd792a724c9b55d98d7df6b05738470388090977ded10361a5a52be699fea7155865467dbfc9b393c866204ec69ac942e04e3470a06cec91f3276c9d02ccefead40305376711691c63c8347409eba135ce600b3a2774bf4d47e38c3c48d359c5a498e3f468a473abff7ba70f093368364d86390c9cc684f6ddd1a35998152f0da758c91623a42a987e07d9248ccb52f2febd059bffb634131a68e9434b90b0d15cd904d6f367c31b8e3a7cb3824504379dbcc63e0d9477cb369207ad911e5f3b890ff3c28ca8794399337f60846722f3465f735d5b32da4217aaecb4640984185a3d3e24d20d244d0e4cd2717f741597fbab98d5cf94282bdccf29e935e14e4525ca6ec151a81daf0a3c44ebbb44ec97dd9d89d7a7de5ff0d7e9876f78bb17396171b196a4f42503b5b4258a0eeab99fe950df6dd26febc88faaa31cbe723bb6c264de7c530e72b405c74cd5750a909ff0a9c0e4b11719484dc7f98563a42638ce303984b78139174479117460e34ee795b6dddf968931a111b86f43042c870318678404382bba206ab57afc5eca4903ac4180a2c9ec0019d950ebd553505060d72665fb2cc1173f84069cbdb34c5b22f86f532b5935bc290c67d4c050f8cb6930d79db63c80977c162ff6a690d76761f9ca9df0dc4da87aae5e0f6146c6770a29e71ba75d196678fe27cffc21a991df6a8f70cf6aade9d3a726d7f82ae3268c0d39698d10286946cb458f9f329c91c0ca01dc07994c3e363993c614302206500c5f215e0a74f8a54ea3254c910f20e239ae14fb8901f3cab43225a87085a62adba28e83489f71423a57756aa54fefd24106f2088aa30950b0eb0ff45a6d4d3c926ee8b25631eae3820e3ff779b44c7d18677cb3efa9d8745d7d5d496f0827a1024748a722104fd914adb0fcdcde0ac7e01030b10986c8d4cfca9a79c8e652c08f045b70d173947949ce7d74ce7d7461bdfdd1c2c8f677e8d7b3bc5b0473602ba74bcb9dd6dd7c25fb193ef788593eb8d7f18b262bef959ef03fe3ad90d7aa08a566b99aa4bdb268e32d43fa463ead05bb3404c7e303598d1e5b083c76df1fee8e737c27cc7da138587802d848644fcb43d56a4b9b3c85de8d4a566c9e9138bb1ea925518d86c638a85876bd58b1eada66ab9440e10da8ab2bc5e465e9641a0d7055a580791a3520bab678e2f0c76cce10b5cb3c4c3a8eca0dc1952015acfbd09b7b7159918f23efe0a1ced7ced2a4696c912d8a73cb6adb853347f3273ddb0b78bc5c738b84333cc4ac5b978a5a6537048585fdf6615cb1f89299a985e5b89c1d593671c8f34b358d6721ee8e04b672214a477403dfea4fb79734c0b8f09aceadc3b6bed3d1693aef592b012d491c4b394de34a1e18848e59f3ff827c9a7cbff504113d86561ecabdcbdcfac7474c8ec08f223204433f3f8f260ef543abf2c07fd40330614c7bf3fdb3d331b78dfb7f94b288a6738860329d8e503ae2f8080054d528a6d1878acbde17b98af948b4c24bd47d0357956f750e6bfc6df0e650eeab257c2e86a1ff793e18eeae00d3bac6c0fe5c12665afc39967240685170fe0450d9d191ec34e5110459984ae746b5061faafd35f627e8892d5dd5944e439ddac6607982d2fb9c56e0887b147234a461758232bf02e573da879d6eb33d761199b6fa5099cb23dbbebf27a827d2833130e513a5aed2b9347f58b8e1f20afdab1ac3be1ea4dd7e72df458ed91bb7d4e857be8f50607eb218d6aa8ce44201d01fb51430858073579c3b4b79f03c2cdeca8a266598b8ae9d53a6e9a427e5007b9794d6915b34da15ee84b791bdfca4207ebd112d5dc152c6d28e819b4b8ae499a4a5f8ebd4aa59cf59cf7e6f17c3e0da3ec7fe9152f9f84ab315681973b3688ea44b7430b2ba360c4700cfb186c2b39cbd823ecd299b5c23c5310c0563ce3c5cea3c654db643f0a2c7080e159336bab942dcf1fba3c29ff3a86ebb51dac2ff577bc385a31ed77bd55d43ba4e8da3f07a93de43afe803e4df2d309a13a94e1e506eb3b2d744cee47ed2a148241a54dc5c2f88d04f2cd58e8730ca9491b52f4a01b1d167ae0ad824f3ad0d6be6ea7c215f22343d9dca75efcfb2191e7a51dba3af3f32f74ff9ff6694655d3c16d7e6ba7a0873fc9506057d1429eff4788de804b485620f2607770e621f4f1c36680f35cfed8c940019ecd1cff3f06ad1e3db80d730a3127c48a57679adb0c515ef6292e43246cf25fb7edd295a01764d0c413ea513557d16160ec0c3ea77dda5ab1122d30a6203d7ecd94afc2b09ec5f4b6fc88df8ceb44ec2461d0ab34aa80f8922cfe0b13d6d34b4aa5e5d406a904fabc3cb119fbfd40aeda874ed003906270cd751aa709c8edce7ee4d00e7084c0d34b11e7ba03fc260cebc77749f3a427e8e5cf025be0e56704e4fcdfea7bb9e4b1b0a20fdf5dd2d5b26ea09b73e8bf48ae9cf9e162794393a1e164458c762b48aac837844c0d08590daf4e6d677e53de7bca8aed437164240853555f24d845c3c7d39168fcfdd94828e6add19c014c2fb70fcf1f38263e9bfd94db5e0df38db247507f138f6eb0c7ea7b60d83728d0e58832c22981d0097058b5df6fd83510cdcbe2f832870bf30698a2b256fe8164d47835254090799d2d4caed3eab9c81d075f4e7e9ccc6ac13c91b4bd99c796df6765d7036a5b6d7245c389c8c218628e4077eec276f1339ebe273299c6e430cbdd360aa687e7b66d5363671392418d0b5298d8b98faa097796d55483612a54ad964c1376ab36cb496d8d0de254fa61609cf695669626a4841432c4ad1563bfbee49bd0604c92517032f0e6d345f4e6108c5d40a27775fb5980830190cea02a808974e9fa02fb6a4e7f959d66d186669ef9cd469fb9fe86dd115b9b6782b05f32612c2489a3c3f13720907b8952f709ac082b04aca5f11f0ebf9cca8dbd356709bff1d601c38136d8a0af2d657f35ecc771b687de3a412a8890f4ba86004ffe14a7fc498dce2c1acfbe3234a2e725a797262af123fb69103947bfaab615e2ccfaccf675465e023dafc1ce7fd8100827f61b9060c4dc3930de6eec18791e35a0272e36965e858eb00c55c1cf82173ef6bd96b385dc55433f6ebb72398b27467a6723cf533f09c06b0e2add013e3486f1146edcc2467d7f088a7e2dcb81190c2917c3252bbbd5f4804ad1c18efe6541353ca423a312074404288e049d5734913f7b46a9ae3a3981418a90a746c38920bd37dd1df829613780b7c3f856b88acd9227302baa276fa6dc79ca00b2bb9cae19464e383bbaae3d048cd2e9edc433a8073a1b388265116b5f660f8684ca58368de060f8a0029ac5c8f2072ca34bde67f47bbad999201980e17339e10762f1f1239f4a8167b5b2dbf42996b6ef8f153242da65c40817ebd5c7bc7b6ae450df969a63a6d9277a09536b069fa7bdb505bc2c40d80f3bc31470441c5fdbaeba45f3e6f411e70fe60a468ea38f3b1863747e74da8e21c468965157a2b44990a771402e372d8d06928d9d74aec70205c35210e671ce65ac28e041ca94fdbb7bb211f14fdd0890d620d36476c6a87a93470196ca88f89a240eeced03fde1c3dc744115bd8520f7b79920dea0fc5268b1e203b953eedfc5c4b695abb5c8d63eaf004409a228394ca3deb543e6c0c3a513e8cd193811600a5a69d0f650c6ce15e7e7cc681cdce8cd2143439be0da3035a5871d3cbf63e6bc5fc3c06fcdc911024474d54ce22bfa403fc1a8e29ef5d552c3977dc84be9494bf61b9cb7ddd24df82ea2a358e59ce284c7551157935c919ac6bf7de74f923792f39b7867fe8e9605f8e8dff8555f3584ee66d214349694d91785c999a074b4d3d7ad0f44d1760da9853018f143cb26b7cc02c5950d5f8da814ba9f40beaebd02f0d144a84091451bbcb70d69ec292934122a016409d8aa35dfa565199ee00326d6a43045728a6bbd8dae577d1f122e275e038d05450b65afc748d45b4ca8f98709184e1e0e12a7b1b3be03d8134e35b5f0234adc05331cd141cfe6409149d16fe4a8eeefc1d2e87b8cc510377e7990a813067cd136de89ba1f7b0ec64242bd3313ecb7579e8f3c3ec4d0021a2c866e21805cf59938a3035d163718318193bf7b1e00fd7c5e1ca381c43d4dd8b2a6d9d5b3cf3c7aa3dfd2dac484daf78e5c9c77e48a41d327a769223de08269eabca8c94be071f50c8b1a35774d0182b53c48040268ee4f5398f17df92ce800b2e431596a69e7a57d6cd70034cb13502d8424a6b6d7e77d7e0109aea417c8d5e916f585d911115e6862cbb6a11bc49dcfe199c459835630feb3f6497c3a4f764381e5ed3f3e27020ab2dda02e779f2b9a47a380dd3c09598f92d5a9ae79ddd162f97f23eb03a396907300032403e85d1db573bf7776a8bf26d55f357f251fb8880a72f458b42f71c2bd543c11ed6d2be5c90a370bd32f7e69b00abc6f22f3fc8146e1037ec463a2191d9915e2cb1773c820b72f85502a182fe2d5548defd435a2f0d5748d2f71df7278cad4b288797cce147fbc6982413f876f67eeba4686c59f25d8cca7ffdb70a7bb30916557f52de2b79261036b041fd3d10169c02c1264fc23e371ec2089b423981475eaea98041bbe266ab633a02f4b48dafe9a2c895075c4760b7b9c5811221f809e7df72d4eaae991851a7b80e1cb491e473f836518bed073fdf0a95b3fc15f82d7a43c7b31bb851a8dc77c9a595add2645eeb24f98ab74efcd395f4eee21c5f857a3cd55ce84b5e4469f689b6acd857035294161266f7970f14ddde39379200ac568963ae4a315ef919f0f401556c4cbe5a654306622c811d01aecdf2677c5e3fbf14c9ddb4f67b761db9a3c66b638d9ba60ab1ab038e03d8005714709778d3756c81b0c35673c2e80d49b722479c0ccef1b29b7d61a7720d077055dc0a78c5a8b249f271f772bb2b79cb5b9398426abe3cf8e9a980747c1238755a3b6fc3d0367b8aa31d0677d160be082323315b8f93bbe79c0cc7a07f97ee1efc515748123cce5e497414552f39014ea4467f1cc6ec11b54db8ea4ec50948cb6446f706ebc7c85cc28b3d85e95fdce1de0b1d7bf85097e1e481740da8b6f2523c87c7739a013e7172f22e38a3b19b29316835a530de17108661f2637f813a6b11e40129136a803e2adb0ba4a2f319e5398e207e1433752b0c598bd0d062a3ef1d2bbf46039747724660818a1bd90e67820a08db8fbf06be14b80c35a7ac7280d7dff00bf92c3cf8201120160d45136134a0ef37df5fabf6f760f4ae72bfa80ec9788c1b8cf3c769aa6a23b728cc0d25a4045ffbda104437e0ee969c132b231bcdc3c3ebbb47a77e518a29868aa461e0b8470d25b8f22a4899dacbc391dda469dd0fe83cdbafc7d84ff73b44217985666de0cc0eafc16c32f5dbf2e50b40d0c935358b864669e61cc0870951c40e9d0e1dfafb6bfa210cdc791aacdb0b9ab06dd6f9a11be0f506a8feb5b93a2aca604e2bcdedf8bad19527cd74944b79a9fef19ce91449b0338d19839fc48a32863021c7615478186093d3d11dc6b1c86d633f3e30f0cb67517d405fe040c147c246804c0aedfc301bc579609d68c3907cad495dda366fd7f2e541317ad106a7f5c7d447d0eb8a8f4be64d10b6a22e9852d778e5627133c7e9597d32f69dc68815f523a6c84ce254bb97b150bc1a9c434b2bf368de6ec2e0514711b55d06d4eeb4d380f8dddccb9c720f1e4729e0aefc139043067b52c16f0a729ba92d2bbb410fd05108230b9540e7e786d9fffd4aebc870483b3f1c9866d78f343749e3f6c608bde996885ce07756828df9d6c50c9e05a49b24f2560982367d65af0942fe43f273dd0fa39bdfa7d38e24dfabb5ba95b0ac841882d1dc7fc165f00ec6af8f75d3a1120cf80f3b4bcded3040b5977b8491be48f1c4aff97ddcb9a231aab3a83c62ddf79f7718fb8e4c4e372e73354de8c5762bfacdf18590d5810dd0265a47c76b421f59aeec113f314f40c701422d77c93643aca2782da759bb7f15387a949d7184bad2925d8914c46322dc908f2bbb1c8f36b93aca331616d6a20573af2d5c4444865ed34bf70057a9c1b040db55e918b41b4f48fc21d2cd930c0d4730d05afe504b80c82c422bf6fe8578edcab029a2f20a3f345e12a0c2d6799c438748bb7fafa13ed609ce38e938fb0b4d9e49d26db2edfad149743fcffa8e21f904bfe59929fc42cc6c92d61cfa9b827a3490934ef2bf41a10aae49df77e5b971ca18b8b5cd93fc75e6028ae36ddc7487eb960e455edb190a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
