<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9734890ffd16e2e96089e73cffe58a63cb1547902e71bf7f500bdbd93e11b4e91a7b66799186fc50f36e0d5d9c83358d0eec76c99baf90f360b297852435e2d4aeb6e46904b991b9d6d51b4afc0c056153cda549dbfd0d3177e0fddf8c45e4441967a676f78fc1c04cad52578e2b2d6e22c422c5ae08cd21b51acc22d93147508e73869254795cde43e6ff8953186d0219294bfa35b6e7ded677454d450ae81577e91c16af84f80145091ce83b940cebbe652f820b6d14ce6e1e8239501c538496c4e133d1a4ddb98f472bb248ec82e98ad4010d24083ceea11a85d08f196d2b4a8b32307814bcbef1bf8c4dfa2e05ba6d9d2af55e064f09d14f6a313b059e51d681c69f9f51d71aa333e970effec3275339ac86f73d6ccfdddd5b674f3eb4b844fba31a0ac8946f3c28771e3c77a8d7930603fc3a62453b73522db0ab9a25093c58d62d1b25813fa57979469a1909ccb0a390575337e8cd17903f00b58e95c0514e92985bd497c738b75c0718af224e751553eaee7f3608a03dfa363d5c400f4137ae1822d33929412ecd63c2f53ead432eb7c63c9dab40020773d290a8c6f21a7d0d4592d54d2231aade1cb2e126ddebf1ede0c25f7f4212da81a59ce6a58f2389f5247370de9e79e837c6f34a69584474e3067780805d3e772e1686a4b559daa6b05afd9f1d6db50822ef5f6aeb142e72555dcdf9862bef2bd9f74c4c89a3584eee911368dc49d2db9473a5573e29ec5ec49cef9c32944b2995dad30fc0d79c389d9b863855a6492a473679d05964bc7eb2ac5185157b88fcfcb5448bc2db30189de087f9740ac462b31cf81ff3e2f4989c22723cebd24648f32e15d89f3b4f1bed55cd3503160a69af55537cc0204d8fab311e73920b769f92163e515cdd62b81921b8ff739d553e91e1cf372426a475a0ac7f58b11fef0297348d6ab827153660bab51f589edb55fcd10604770929dc5bc103342ceb847252a14982ab7f3a69b3cafa1b77572679e7a79b9f1bb04b8b09d6233c319ad5f21f3d53298edd177dd87d726c5baab50ae4d71586a13d22f67696371c54fa8b2273b3cc535803192097a3e448850079997a2054e18da89b07cf4824ec1a76ca14e9008c7d510b15e819f1a55aa88b083bb96fb55f9da56aa9ef1be11b1bad7722eb946ac7b9400196994f091dc03a788e78e186da0e8b39fa61f0a6b1aee20e0c336bd1bdd61552b84aa47ac7ae84245e65a4d06788434f37e238d3c39301a6dff739463bb312d23fda6317cd9d26a157c34cef0c143caf0315714ca8a7476f1820645d03bed5e686e3e101b580758c08fdfc0a8b1d1465a424a547233f3f52158ae2812599e0d6f16683a2b250f39797f333add279a0cf64691914b3007e6334bce0d9c39db9aaf0f963969dfed4ad3fd6230870c12f52198b3d987a711df4296d6609fa5ff456ffd5de6f46aac8ff6596ef9e7ad2ca5d740ce1df284160b8612bf931284d0fc8f87bf5b3a5e6177ebcb34afa2d5565a768d46175d6e3bc8a9e94f0cc03841d5a38d0c7d6f662f69d4545a0836c92e61d65b4ca96f2188c69ff3e26f45e08e72a0324594235fc8b7de5e7767189c18f8b1e3655eb14e13620e34c018f9a47dd9d1caae3a7b6fe7b6329e71600ac7e8712aeaca75db90fe47a8ae62c4e79efb1cf741a534ed2e6702130477bb328b2aea2fdf65f762b434558e1d46aed6b3e62eda6a173c04551032aa7086a86524a8de5cec2bfac8a2cf4bcdee1f2c719921abd1a06f239878d0dea5e728293072590324f84fd9197019375f1da85481faccd5a8cfa64d8afe530821d30227b084acd31b5e602b938189c5bbc9a63f3a5d61925121c3dc626aa053d14e3f4f62cf474a42c0088d9d72ac4e74a405663f23641f2cda1c4e488f6144c0e5ca11a2775c0398e8853f807121b1fc5d9f48bac24ac04040baccabcf241fc2b507bb8aae93fcd48e97632ba2fe71ccc67fbfc899e9f55c8885f7a2a580079c5ae98e4c1b4b733a651d2bf8697edfcca917fc67705525ca09872b413594289677287b04e040908367e7d2d87c76f1ab9d84086f7720b62a5f8072d3eb6193bec3bfd0b42e80225bb46b691bd86b02e48af6eb6777239f0cafff96511b2be52a79d528be501c2c4d29a78959f9bc4381ff32509d73c04f0324597034edc19d297d5ab37ce1d995295c5c0d6078d7c4cddebe4db4301e7af7aab27c1c894d173d7857e30503d135824a82910ab01f2c54e7ce713a998009087d2d2bd6f47621ebbfc172e99f7b8347c424a837ca7d0951cced47eb1edd05540db7de1df6827856b0dec09ef62d7c47132a68463077da00a682868c988285888b6705590bbf190d1e06e047a820c87894af1a0278fb15098387c7428de9342759b306e52b775a11e2a7179ed845f3fd59a0157a3ad0b4fbf911f8ccec8562e239725c69a94cc2e7b03279d805ac84ca6a19586c971d3e970ab49ddc0ad4fc3bb4e4b5a701a98d2f34fe9f99e82315c0605ebf6256a75a0ad86293f5c9570723c35de3364f819ea21fb6bb8cacdc05efcce6cfe2b9c99d465c988f49b39d4ff23c2a595c7d6b409d5f32a51b000c32bb76353b6bdff86befc0c411d1538621ee3cce29eb14309c52d343b72e9cd2c3e12ace17af860725a7d17eacbf61cea684ca14e98cfb03796602470b0c2afa3ce8d70820ef94c06045017d242d7c88095a5c78cb7c498c7c33b124587dee9e742a1ddc678aaa809b4a26cb9bfe835ee7ee9fef63758dd961dda4bb7029dd6562a898719022baaedf631c11c14f501660610bcb9d397b717895093597c02d4f4153db938f331acc848d79a4ba648f85e049e5b4829ae5190c17205cf51c8e08da502f64d244ba99124f3c805d3abe7cddec17b066337cb0906dad3f39da91e01fe1a0dfd23950f29a9b98218ec58840035f4b78661d95d3a472073e291bbe38cdb4a644a69ac14d1b674241dc235628bfb6ae5f2769bc27c530d89d9028205031504f8d9aadda1f6a1a821a4897f9cf6bde053b75ebedd1be59e05fab9b52652cce47c48a7ab03ae7db962f75215eee691d2c542f2d11c5739212606f30dea33071bb071bb2c7d8a35827077790f6635b3136516e86769f9aa5f37fdc332912aa96353ea1e6085aae96e3a19b272686014fc841165e26080a7ee87f474c717cdc837ee0a9d15820aa5e0ef9c84f608777cf191ede5cd428b97fd193f7d4eda7a9fa050f9b578dfe9334e57fd14f92b91a0183805d23d9157cc7d9edeb584c72407d2b44336b7b7be32d904f8b4a3ad626a984a82c0859d02d2ee42cbb22e11cac2568c90aaceb5adf592fb6d593a94d797512e3246614028bd9654c72319c39b242f0d5da51984f8d6bedbc4e0082eaeef06640d0ca69e8ffe993ca508459444cab46df6b5e32e54842b5f7af7f470caae49eba042743cdee9c4cbcf30e1ff1492a99d81596bf83e1e9498b30ab4cd438eaf12cfde56a3a3c7bda7e4096c6e1a14df45dea7309a9998f8f389c40e0a56e35e7548bb0ee8c0192812fb2489649ca5b6326586632143446cfd53ba0730a2f33d80d5d94dc51653f2389e7925d954f38f25ea1d3e63d26fe736c638c2c7351e1ea0cc517c0daf983835bec2934b6d77bfd858a042792ad57d6a40165889034bc5f683d49cf25b1d28c6a20a05af28eed50552a0e30242d4f44f1db9fa90224eb3826a078cf4cfa65038cb24efec5f42c2cd5c6a9e2f58bda9c777beac1f33c9260add0d3e5ddd9e11a91d3e6a0f3db4ca76071086548c98eb8f5dea18c1efea8c4511cd2964d524e8e0b0d652e43b1a795dac9ceac7d131abe126209ce6117d5778cb5206e76b17d3e3f8b182d2095ebf9285b85f90d9ba021239c617abb377dfe8d039ea5bb4ce52f901b6f60354bfffd4a8f0483248797d0d2fc5788898323a11960dff35baaa88c4348b47598e9887d943485bff5e2044eab14423b9a247543a311e2246b32e8b037ddda0d18c0ae554686f246b3791f1391db80409e348b4ae9c7e0c5ab8ff8e921d232dc22558a213becb9e3271fd642384ec0251cf84bec6bf77efbf5c33ffa784ac82b2a74689a43f0413d7a7461b363a20d11266ccdfa0bc96d9339acfd7bec93859bb18a58cf6cba7cc984431f67248927adc815d807d60df6ac0a699e32973022bce8e87e62a4f9692e94d42692575214b0332801c2db91811df217bb3458ec81d19d8bd9d31fe3d8efff951434c49cfab50cbfe752a69ee7d0d8fe9884d302494d48ac70a0bba967b94de7b5ef5bd7b36c15b83da07b92f87f50e2271577fe33a03194e6bf1a8f98f8007394d9141bd9db7c24a90955bcffd7842ed7c9e69edf3c9ab399a2f37308ce2624f4660e64f0c3c1842ab6a7f5141a5a7cfc910c10a487d1def065f5fe0e4e4be4ceb79c5e26f68959a0f1108dda5036dc8f8a36e4c4f9681f4994e6446eb3035cf1a50d8f8b3ca4cad3b28d9110d0327b16eadde42f9ee4854c2a4a3ed130563d22e7b3817944eb779ca83ce0c9cc7fae9cfc7f7941a833fb8da42012e5d580eec7a7c96b4435ee0383c32e522195cf568eae56160d1302e3f2ffdcf6ce4084867aa261711e69a2988e9260a489c722ba74bb10a0bc2e6fcdc493e1d55ce24a2c44bfc2dcbeca2cdc7882b8ca55cdad9d4716b2e1e88ade1dee05b8be3a96c891cf1acea0442c21e808155ff78326b81b0ad56c59c957e004c9788230147a9834566530ad343c5829db6333979fbb4c7fb0bd746ac8e476b3413b1cb6ffbd623f0eb18b2a64d4f557018714bbe359192a0fd0f69dbdb6cc5d608e6d70bddd095f777de6b26521fe7a8f4b994dff477eaa9938a072e7c30f050cc24090607a6d3c89cef6dc298142ef1e386ac2b87ca7eae2265cdf3a74bcaf4557e61c13f4aae62c851ebb112443c8b15bc00c5742fbc81f172a59effd75a78259e74a59d0a65c33a3e7302bbf6d5009a54046da2fbd6c093c2e9743099a5c6e4ff7452cfdc438e989ee2be978dc31a1e4ff6031baef11e46f3de6b99f509f1a763d33f9b7257213ba55a3f0f6a5aabffbad36ce8feea93501ea6aba3e2d79e863f65f851ad5a95b01ea61eb19794431a5be873e5a1056f34238a56d6b174318676c7a9f9a37c17ae9ff6b5cf0049b29d4cb54152acbbad1791a84ce54286d0bc1124001357572cedc182a2e1028a9be32c3fb9db4f2ceefc81d815db167e73003d9e3015562c3d5ce718508e0f7c284e1e616f068fb32944cd9a7b373abd2dbec582457ef2d69353f8c6ad4b735964ccb2bf381682e8fd6f717f9c73da6351966f9f943550b320b46f34c837f312efcd7f4f5e2306e4c2fa28ff61ba00b88ba04b416efd3343a5910622c1481016368681f223f234efb5919fd4de6d26b46189ec8cfc4e8aa9478019a9b468cc7474bf715c7d463673beeb1f5ccf081c4b43c0355a90d10844471efc4485df9cc81b609dbc4d21952ba0966a857882caa877bd542e83c1b0fbe8b098932d33de85a60cb5e6e74dba39c1132e66caa07e3d4abf9afe47cba544c55473595477056897e366ddc1064846f90b59921f5d495eada6aafc6c4c0a12ef41655a2ecb396caf5cc1fc9827348b31e249b87b33474a5d56fb76abb6cd584cb6fa90d339f0d59c14df702ed637b4180853e69f1d550ce3f8c93eb6d2b9605eca5433bc5924f19e508c361207f9b018fa3dc4bd5d60f5bff59508889bd5fd236100bd8a70dcd20f31495bbc9b9adf5117d4a33949e1de638ba9bbb33e87b652e781c09b66acbb3b2fc24b573b4ea0cfa07b352803bae561cece640b80688862a3cff1d0c26c2a03bb55acc730596b630631b3e3ae5502337fc0c5729fe02be75a6a7a6e30038c148f93f771c6d1f29238ec1ec429212eca4b030834eab0bce71423305acb6251b50c0ee5e24c1b3e0a298fb5cfb600dcb66d4764fe432e4e2c7add201778bd6b9f9b308c97fccfae7d824eca7781958feff6c2652d087512fa35adb9ab9a1422d5c3371724c16ab433e24574de84eea51203caa430e494c80cc43de9a1864f0a1674ee43abf5a86c193b1515d772416ea334d65533842005eab064344c6d5879f24ce8910561ca3b13638add80ad384cf58259f1a61bc35d71bf43966f9c1690cffbeb838985426d64bc0f675dcc8e8567b31c63800eda897b00bde4befb7b863632525a05751495a20f4d6ecab43b3897ec79ce9066935a24731724f26c4372a8eefae865124a06b71c50dc2be7e1d253946e8eafbb69b4faeddf106d8727113fb5ec2848db0b58b6545ff730cfe2921586a687f849a3745044ea5186110f27027979ed6a9ea90ea9c55aa4f80c7e7ccd73792600554a89d2e91e5ea6029625495261a5736c3a89d605379f88de7e69f72881fdb6067d760363f6c104f5a5e0218692e150ad9cbb715fff36bdebc2fbc91426afa935d1884d4a8e8a1993606d17bd3ec3c18657c184a42ea36ff85c4a75ad37910e1bea3f25125cb26ba66493afc068f0ff6b5979025d3f1e082a23136ebcb1edfe37e8ea0398fec5d5ed6a2675d6b6064bcabede12a7a3a7cb163d6baf7a48b5cba1ebf9fe2e77837bfcacde2711450171accbe4f28bae8f28d9e20f489774235fe738c2cc64de4f486339a4a8ddfe9cf6bf1bbfaf676793e345b3623fc073eb7e1ddd45d9e56bb94729d9ffd0f15c7b560b510bb4a238cedc40cf5f405cef71f6f8eb901b1adee4ff8fdb6fc35399affb7c8bd0ca20f183cd74281f4782c17c9e24222ae0487b8c7502beff2fa556388511f5136d31c158990605ed80c8663e6ef841dbbab7e796b4b49ec1751b7a6e8daeb5d5889482095782db19efdac74bc41adaceb59ee50a36efd01282fa6f6d46c05bac2416ee8cb5f060f3fcfa1cf1c3c4786569066a6c935cb24d955de3acbc901ca7dd54a85dba16e0a306e0ec0bd9d2bcfcc7b912f6057a8cdfea42ace3de7880e5293403cced5f53b49bafda3d58de8b04c9d98c5bb2935ac08f8e698bf0bec32c8098e2da28620c88e1c8950c5ea1a39854bf4ec79e981c2dab6686f2437ffd5820fe1ff9f78324b8ee8a8b67d3cf6233034db581bd11a3467ba829852337d3090e9913289f97d2d23c27a60773f4fe08ff9fd57dc2fe7d7d8ea3accc3568dea13df9ce9e087598862541357c12d4c02115cf3c813c72a32116277c9136a9475c874bed37b49811f6185966139d8bb612189c59ceb277b48dc602815256602eb745bb84b17d3226c727d018018608353f928c4deebb8de6932a37d694c81ed7dcbd10f8a18c82cb6bc3ca98d80c7683d0ac431424f731d4e2042d17b00f12c1c130303232f1db5ed659ff2bba042b60fd069aeb29c0a89440d3f758b28187de11f2c0b0f8a9df1941859161c6638a7a286637f291acb5a4d87727de9d82ae3a464845d1d131574b5b1aa98eca56556975ae455e20acb2513d6092d7fb2bfe6beac04c462cb5802e3dce32cd673171dfe23e1d817b123ab41dc738be680f66db951d3af8d079327c6096f10e0b2155da708a0b9ee1eb8a6862e62eab66911fa01e3ed506e486243490ca7d76d728445f904e7d261b66afff3996f5d46cea86c27586fce1854b491beac16867f356f5b2f449e1950b3cfc961272e585a88fe708ef25d8cc9487848791c58ecf0cca87bf5d9ffb1223ee9b2b77cbddd62f3647b477836ad53928fcfe85cb15aff8947b640472521652bc59f6b962f0363adf266121e63e014bb503029e09a9ca33aa144921a1a07630e0a1e2155f339d999c522f6a8e32aa31247b443a65cca022233c0413005c7db5c785465ede917e97d00af5ba0a9b7105ad476a66c8a6dfab59d2292feb69984db69ef78d4250b4e026f01724e1c6138aeb26e9a51028266bdd9d7044399a88312cfcad4834d12eb9244a3c1b9c72b95e8cd1f8bed12d867fb2f13ede3cbddd6691930d31d375eade8242961bdb457b727fc10ac919c6d5f0c7f7866073de6c3c4bee40f06661b3bb2263904d0128d77392049a8d7da6f052b919d8ecdcbeca5bac6fd5c1f98e32cab8a321b8e2d916466b75876862e215ac8e70878f769de9842d3f0a28e4f53e875889ce07c92aba0c0dfc99be8553b0cd3107078be2077e81bba38161c77205bbe6023f1ade4d622318d3ce2a23cc13fb6f3eb6c7691735eb5041ad62e3746b0d44ff7fd5da82f67df4cb2472b5917f200a51deedb318331f81ab3d4ea46b518813ce36621b7a22ecde9cfef8751783b89a39b406a9c421e6981e3d83ca653cb6875afc88b6b2253ed12603143768b6571356418bd960844a2f84ccb24157969315b5c9f0a61315712311564159a6ba7be217ce92b6b6da183e6e5db56c046c31030c8af46806d2ee91cb15a7058fd7bf6aeadc869787262d8d210c036aefd23b9650e14d62c2255abc72a1d94ceb0a86094115c7b7255ace98d21b5c7b7a8a1b1f7dfd7ff3808dde778a0eb91fc62c27c29834b7533deb9d55501c468be1348bbd7e4cb930d01ccf9a36eba9413c9ae2000f7b7959047e09ae5e9ff1cc6eaf4ab82c29a4108c3afca43c2e8011b11481cdec0b595d0bedf4d12726e1e2568a711b838bf4bac460310612bd75254f53bc5871909d6ec87eac8e49aabcd50c3f389e749c6fc5e5e0c50375c58bc329b8b12cc98e8c7329dcbea9439ba81e26431e99870ba91830b3315bcf39d426221b64952637d123289b608c7405454efb24487acdb5b14e34a87e61a948286283c238d55b0f0a95dfd73cfb1019340dfc503a73ad1be58c07c6be458c412cd662efc0f056d6dacfbf6944184a1b66032b2ac6e256d391cd3e283a551a7591135568d6f6621b879933dd9cc10480c4d6f0a39d1737eb7336a492b01f27e540d32cf4714dcda93960c63ee9cd8f16da0b017facc9e9e8068b0afc8ade91c398c68df7b2681bdcc34a135c498ad02f23f789d167f1e09f1fa762b034a04d193a504a9102e0720b44b03cfaf4aea65d0ca50d2f8458d86f78b6c0329b5d280189af5ff18697d9989fbea9bcb3dd1f9991158bc874395e2c92d69229e15115dce96babe93e6a54365e89282e2e2b73d7b8398e1906f7b5c22cfbb862e797a575147d545366369549ace8bcdda48dce4ac6c5db6dfbdecfa615347c7a701a8974da3e4140be5df115998225542f4155c293b203041754a36e34bdaea452e244980b154697640757c958336bbb941f7e159e1d1e55b0a1d0aaed2990ecd6013e1cac891d687f695bdaf745e4f0c36a0477d3793b9347219921942f4ff6da5aa525258c7d56d5c7dbf8b3d22b9f5458e18f8dd1810221fa55072f42bed3bfa2a0e16cb3b1603d7569e3224abebf1ab4d373c448eb71593ed5317bec9d415eb590ae9c255f829916806cefcfa17a0f580d461a1d2d3a46fe6a896915ba5b26df39e46fdf9583ee09127850792283132976c01dceb7bb0cb6ba1e4ac6de4695199ec9a42693311586b2b85f2b5cf8da478407df656febc6374d33102e11874e91a98e51a7915f4cb32b3897d8f6cbc916fd34e247576b628c4f6ae75fe522a3c5efb1d91fb9e57d27ef69600b1d49b2af6b2435728e6ab31395191abdce585cac34145d55be7d1d4df37dbb71263445f2576ea941bf9af95ce33d1e43523cd1ce2e9e6c44797fce983804c9b45273baa376cd4513e1b98d51d83843b8f33b09668aa2aa6e8dc0e6f66bf993fdfa79114d16edeae6501823b60cc246d2510867bcb5268d076c0e0dec2557383200c4466f888036852e8db61a962d5151c59722ccaedd7321562f0d87e00631c4894e45a0917337908e6698dd39880a85d8ff4a18178dd07f06c8be321b95aab38570aac9ce66aa733e012633de91bed4818e79a9de8bd0eb1ee645345d7f996fc83f2f691f84af11e49a4338b0fc3f70217e5a08feb527f96f91a2977326408fb4a402c761e07eee317403f12da16e5660d88b11d1117c8e88463c74aa4ad3d3537531330756f5b2d1cad0edecb642117af19797208bb65043e9d32dc93c6d472faf7946fddf17bd6d26b906473ee0ca3673af61150da179ead07167209a00257ae6ca1977a282e8c1a3ca8fb1afc5177b759882e518fd7e78c4eb60a57dd9253645c3e9662328de9d5aabfa991f44f3aab594813eb0d9423f14969f11c02034bb053512e8d2e38d68e191e8fbc65924b348ce31ed64c0c5a73cf8e1581dfa1b9903e7f694d9fc92910c007411759456fa53de8253518ee2684b3e70749402cd24f3cdcffbe98f56159d35c325ab16899b5a6fd787fd19caf7b27dccc17f34f6febb1c1c32cc4eb0fd82830ec3a871bddd88b922bc5fcd70c76f6e8f55f3202c2b48250af733858c8071f999109fd2d1f6db9d55132b120c28ea63e6f3f5eb6e98e3249721472faea63e9182f6f810d70b7e4f1936abce7c490d8bd081af4c0ab72cd7d8b203f5d72d5fc7062ca48bd4110eac81431815b981e73a2f2298a208bce527a751d9009d5c7fff2de41f677bdf32928ed06cd0d62c62c9b01af0caa3d9ce8af72967e0a4a5e4a93e94e4df4e576df95299092a484292aa4d9f3aaab483bf872b914879ad94fa88b32afd771b177888db721aa18ff5439e36bb108fea2e8d6165259929ae4c466879dc5535bb4d1de0ce81fa3d5ce6cab636cec7a29bab47eb3a42ccb16ec60fd7dadec5446cfbbe28c62cfeb88da3b69bf1baa05ce3f5d73a3d3d2d33cef12e70c1d0767e7b3bc61b6ada648888494170ef74f3cee9a31ea82a8ca89a1d26fc88bbaf213afa5dadbc3c911193cf82103114dac5a78e8bd014e1c7e5e28d5fc9be5c21715778d393c4985d8ba78884b5aead0b7a35a59673db4bd56f52d77b74e9b86f8bd4d4a168d2495e007d0ba0df5c3a49940d8fd73cbb92bf39f8a0be09b5235aa3e40343ce72c52896481d6abfcbb9d1df7cd2a637a5f1d4fbcef1828e07d2775d9aac8cdc1997c385ad04c955b9e278ced9ec8143631842f17281c59e5c0bf4eb85141f877ab440c80bf240470c607e0097c72f9f70dfb245cded0c8700442b50247a3854552ac42579cd934b5bf395966852bc61ff4b44338257f992520d8446ef9126a1fe4b39bbba8f6cfff2e27dcc3230ac7fcbbd119aaca227b6190c60b18e8ff1228fff2e3de30d2306163ccaff822a7546f4e9be1b7408612bc9a33cb64d48a297c9a62252075cc572deb676b3d501e5c319843d966f0bbf2333664ae66e944091602ee87aacac3a50732a184e4ca50511624784a0f4bb33bc6683b0010b67fe104a93bbd13a9cd07222ffd65a3d7acff55b4f34ee681cb3f3c579c7a88ed2f30b031d71056cd4249e7d7370a15da1d2efd66f0f197c97d31fec0036d7f780dedeca26873d1506604efc050a4e4d36a4f03cf081915b58c326317463547f357d3c93ba984166175c28e08ac90e6ff1c54ce90e829c250313abf62c31d3b7f132d4ffb9a816d6dc831ef23766bb85006bc9ae63d8f73c6e9206825337aa5853c29cf2bb03f9a28583ff57c0a850d9dc6a17ec6ba984e69654c08ad08b8a67f9b0dfa34baae35535f8fbc445514af9b3b40c8717185bd045725c62e947548f0f6e013d4243cb74d4e494bb5416a850862c7b2fdacafb6e826156e35413823b91aed476f071b9f92cf448f51e4572d25e133677680dc70c1d19993b63e7912609471c9cb0cdc6b9b9b4fd525d1d7e1509f16b50a400aa43f7da380f38a7219862c9292faaad090c670c0d88673778f0694ed35101c5f1bc546630f317accff31bea5d49d124af17faa2795ee6a38cbbfc7dd53c896a59201edc37084c014cc31e7b2bb6e0f4d62598605b41562949495d58de5fc098d218a017bb830fe746c7542ceaedb1d8e80e014c1308921a10e77cdafd9dce2fe807f9a728036a48921ec845c486fdb9b53eacd2914f9ddb2067f5011610077727e8f4e3544a207f27218a3c2570ad56f7d0774e960e31fc14a6327cd96aeb4d9f1cfd8c47eb50fe9632b95e2f84adf98181ca343bdd0fe687bfdc06986225b75329999c9d0d7c0fdf3d2f661ff19a8f45e68357c35800668394ab02500f07ab898312634bb19204dd0822e73d87febe2961ce23f51198a90eb409197191a77d0baff33af57d90a1b27192dacc42f8211b2744396a8ec852fbc8d85bc4916b52486f2b13a99fb80e4469609de6a0408113bcf72519728ca20a68c7b8d06cdb700838c825ff1df19d30406c580758d3dc6c746df89912d1236ee2cd50c5c6c19d54ffbd219e8c3555eb08b7cd3ee4da080fdd42acda58541ae71cefd281bbcba824bee6ad442320d32be2a06361cb13912faeb4084f56edebc1097ff17ba8b083480f9f6fbabc9442e97e58bc67e10f12a60b3cf7fedcacc22329857342cbbffdb70ebfacfb9a078c337d35577e0fcaa07ac665f7150f42e2822b390723618f6232fe62c06530744efc9b1337987e7b2b3f6523e7535d5bd02bb6db1aa4533e46a199541c9b6c50aaac9618a77e43700da9a7436e3dbc3453d813ba92f867df1fb911afea80b0258a3aa392246f7dfd15f10b0d6d74870dd2bca7c0592c7efcfb64a35bad85e78ec8a80d78d00d6f0b10956b95e9a18a7b469faa5be04e6b4e9ad5f3a2a4a17fc2aac31bcc25ad86885ed1c0fd2cf0ebe4d593b75bdfbed4a0ceea1735ca9e65f46de5f757420792bb5c846cfb2b54c0212c1ebb66460f7a06480a7298199b4991e77fb2d5eb95b2aec4abd36dcdc27426dc79cf3dd2886602d5027eb6c08f026a44a2ba09a326aa7223c1f1f8b22a5dcfcca11546f952d11edde07b88041f41ea341e29d8f2f4d210766e0756cccd38fd31702f9b3d7942f05de945c1276b09b9a92720c0ad1b13bd35e44d32ccb15746036086acb107edab257546a070229e92a1c0696f4b6d38c3b7dc4723b5fc30ac2151c1940a6558a3598fbdb9f5779f77742a99310b77cbe5b309b2e61185411647f7b15daa5517da6119cd98551471bd4210339ce955ef7129a9d21ac868dc086c567fdfa2ff08fbda4a084cb3dde803fa21c024153bfd275763e4ba6bbbb86c01040a162e4f6c86b64d749b713c5665adfcf3e23f038c9c90090bd55e6d967cef0f75f3bd0fda972a68b99162b08a6c8aa7c0a27b700e97f3296a6b027ae3fbc56177628d1199fef8400bbd84b573a850285bd13fff67a82d586538af14a86529c03aa4bc71798b6e37f5ca0cdc93cc781a0dc26f86dc85f917cac532aea5c08c9aead4249818def2a7d2a94b56991532ccb2f7667bfa1e72c16490c0be2eaafd070b05d815369f7fa4a4f84657d189a6022b536df7143249dc26f74464b9a19d9ca604c6d0941e9af329f6b1e79e94d12cd4ff20e90f4bfdea3d785f8249b6f3bd0653d4f1ea84727103a39c1388db3e7cf8b9a08788b27f9b8dacb21fd06d52d2a4d1de062667d9eec797032a4d19ecc4a39d710ac1e6033cddc76f87a87df017910f59b1ae463eda20e985b9fa7616aef3faa7427812e9ecced482a3cf20640a4624fd640aa004711ba31e458b51b70f2d7a70d232f581c2f4574d2dda3307f031ad9dd6b597f6879fe72fab1667a6d94a4f9eb615c438204e616bfdddd82b146f5bd760c0683cb75917d1e5c8d28ef584a9b3c9e0bd237655682319de4622930ecdc0618c15385d4d5ec433f065017e0dc6e9a82f3128e969c91ab7946770e72f4527775e1acd35307c5b51eb60d2c4f1150974d36a7bcb5167c18a71330630aa58daba367770ddb0ed403049ae85948eafb3aa306cc53b6cb8dbce2ed5727fb85169f726dceb8acc2c9c489905291e868e4612161c7d8ce7747f5b57b48b048721b0adbd854c2b44bb9934eb6240cb7f2f1a936dcd0e84c98fe57c29eb14a5a933e15b69a0e19641415e4bc7aa02a60dd5407b303e44bfb23ef06cbc335d5bde9b6fd772d0f5936a5b322d1a0764965054382ef51652086d219f134bf482963f1599e447ffad67d292888de4b51eb8aa8e4c25ed2721ec6c7fb58b942a6e3dcf3021474cc682f1f1d3a4f20549e2b12a46b9bc670f56f8298df7354997bad2b9d098221137fd1d54870ed564d05e0676800f8760c6079693d3ee6f7d3bcc261085d21fa95ede2ab051480819337b73db67324803fe0c35f09da1489114a0d2c0528707fafa6b400c8e1ed36338c48a6b3adf0ac517c9ec6cf83b4996f5ca3ad5ad0a9282b5f83241435449f547695f69ab27c6061645a9f972a9f97d2c8e15c18ae732783166b445122a9d0da300c1e37d67eebe46b91ff42da9032c50356a555b958b7007f81178bcfc45ada7da456be3b0745c9af971414bff40eb058a56121d5ac5f483da58d2dff08bcc5add9ce88a97386ce573bff35ec637772530860c5295cdf5cb048b280218c912d8d576bf5c35d12cd2db8e0f6df13923e2645fccbd52b152a8d0a9d9b226f2d6035d6aefd611bf463fc8b60b0a96ff22cc4777e2c86174d68b99f91f13c5a2e431ceb0b676d9118f51f84ec1568f7db1773f6e7fbb14130344f4e75ae549eab872362c1461dcdc31b8cdc63175b7ee643cfd5462f82e686de6c411d428141880d99fe9f3fd39c7832e6d8ff1c178318cf959455d7445c1f0fad21d9ba5acf99bc57884b940ec524e1e292e736fe02928d964d22d23510c8758054c598ffd2127557627de431409d4b4db6bfd3ca14267af8b122ab05d642c35a330bc8cfb9ce596a2b65b42adf31e60c392072d956fbd127a51417455703cd6a2bbfc29017fe76b7bfca3a5074cb4ab0bee13072b02e4867284b0aa20894f9bf82fed3382f9bd48487bb07d5dfc0b744327271dd8094c1a71f879d0a038ecd2cae34350e0cbfd4a39a12bf12a1e2493379944cfface48f8fbd4d1731d908d70336670e1124250edeb92f306b67a1ed0fc638b643dd8bf591baf176e6d49500a76fc3c3b3c535d256d4af5233f168748b7b0ba8832f466ad0c84608e081d79e41564f4ea699456819710caca350f12d3e9c845c40a3806ac24f4713568ba512527d6c3db36f1885e4b2d99d10e7cdbaa1fbcd326978bf312b6363ca2cee014f51090590c0b23b0681fcd627058a87dc82044e197a5c49101bf67db8cc736960fedb5f2ffeea0e3119fd36a46420413d32eab07df72d559443b6718ec61dde4fcfe615a6d0dfb94faed40805ba3b4ee95c2f8f8e08f31cafcff33caa91be531fcb045b70a8323c7f0080e4f133abb4fe24b45c185660342a96694b69cc6fa381bea48bfe00bc977745bbd83606fd1fcae72810008f9f8f958e796a0bd02e254957376f0503fa3eb5c8a971cb35dad880e34042d5b65e261c05f240f46ef6fd0515a917909a966f1725073cec56dbf9d6da13dce47e3545d6391a284911f9757396467c9a9c4be610dfbf9965c51a6d98ff47a845820fa9e487cf14275ec041fcaf63cd0d9f9290ced6592d6516f25405f3c1e6842c03ca26381e0e52ea4d734e955f7bd9f634c6164288e3016c057965a1f53124e9b0104aa024a04a8cccc1bd6f999d5100242fb9d686924574e908ffeb5384a1d6cb15c657455f3cd9b8e93bb753b1031ada8fa40180a2d0a7db52fa952b02c816a3657cb959a6219cfeeedcf31287d320e6e99d5b987ddb15f15842c023072626a4725889d6b6f3823657884aca9fd509097112be68828249e5197c5d69815f20d609ae16ca970cc0c4b9cd74b74bd523a694bea764a550f13027bd41ffc61dd60fcc3f296b1ccffac5c023ca0275bf4f5554a5706105ae6c92bab837b2b13551d193d3170c979d9c93642825e8ab225f17b83a3e54e142be41e71e50e6ae3242dd6cd5638e0191c9fa74f8ee98288d578f83acda1951286f4634e6e6d106cdbeda64d8553ab095d14502469b17fa00e17cf6a644e28ce11233fc9130d066b5ad2e13012e6504778d1ed26081c7809c4d81b30446f22689ae42356652e44ad3fc74bc31a478ce62109a5af2d1047d76f8598cf1c59637b846179465db386b5b51d89b6f593408c01fae4d2916211b0462a7d1d9b658beaea18bffafc6b429bf42078bdf874fb442b114e2492c88a7c2c343f0a5fd850a9a34e5b52f9d1e230b134b24f24c050a636bbf9c8ee95e15c373b198469ffd26790ccc1e280590b4881ac4e6bb832dfee1469259d38315ed5602728d4d59bb148b6a48ab37decffd93b13245a7ae947bf8e1b4304aafac952d5be891df3fc4e603899365faabcd65f47fda3d23d60583a59273d217f1e1c0beb638117d4f830a331271e8efc9f4bd023d1887920b63e8877386cc4d9c22bf326fe49e9bbc7ce5ad8e9e817913b4d4f63b92ec35339d2060b7c75744284e9cf1b35ec812f727403fec27e3ff6570153644fdc1d7cde5966a325d2e196d91bb68612ef5c6c274140722173c1b234e2c81eff53ef8fa5e0fc2bdef4a4d6636a0a64fa89870859cab45278a1a0b7163f861b2b1430f47499d939f74ea9fc7dadfe586ad39a9de7504e62970650b1cf0e29a55006e5127e57b2dac0b85dc28fe0c3228ecb1aa712086136efc573e173a718dd3ceaa7a59e95a37adb11999719cceddf894ed5963334daec90324908a48df264599f9caf0dd44af6a2b0a8f79f2ce0ee005c487d5d520b794859e69e34e38a341d47e0a940be8e102ae1e5ad8f3ca4b8628e00d36ef75e4be235c657def13bbd2a062ca370d8c65f3377321a17a16104b8c3d98874b1084f991ae8494dba9e3c0ed21fdc87280238ddbc4ce975593edefd9863786db50a7e42569f35627748748efebf712f2160f38ef2a200c430fd76da72cb3b724e7a1db1f2c182f4316efb3adddbcfd98f5b23533d4df8ebdf7f39159dc08bd6ad7e835954c3ee24e5dfbbe3568a210c6fd4c944b739b0447b91febebf8b81aa4ad6d63b3a55657712b45c34cd166ee34676dcfeeea3a14af16787ee9b58751b0c18defdbad6a727034e3df0da7835411f5f2150bde8a7e2e2bfc5a98f62cfe7f487fb9ee228c28e8e7d938ea7030394454e51fe392981c51b0367f84fb0cece6ad63615bb29641b03015a3de5fd039119c833da61e210b776d4837bf36ae431081f908b6972a806f1ac3925f895e92ecb8ee43e9d3fbfbbc70b09efb15d410b1d8245b50fd5788d751c20d9ae36dcef244ac3d2b4b5ea2909fa7de49c250b9ab9fbca2a5514a2a39d9f5b291cab14d027e7a0b7964b15c447a710ca225a0889468d40cb6417d1f08247c3530ef5be3ca444c6fd7cbdce323f4d62ba879ba21c8a597c9c4de25a0a9bf454cd7a7fbfbce013927d32ca62839791c5a68ef3d15c9021c9988a0f9425ab6dc16c322b58306bfca948fccf25fc5858377950b5eb1790940b88117de66b414b5c3bebb2d367f996e58b9355925c2617d5245d905d3fd32a8e5fc809f0cc51fb7468cfa7ca4cebf02dfaed08a6f32c3906b0ca629c7a98e4c2d86da8ea3f896e8c8fa047bc855660d783f91404afe11fafdfb355838efe7e29690710d2489feed4407f6dbdecc354d985daa5383f906d8c35807f5c7f8202bced6b1def6dd514ca8e9bfa6d703d2d95ef9f73a42e91bf6960095f012a4a8dbed6607624fa609592d7618fc04032d58f9e73f6cbe7f7d5f090075c95dc8fba43e2639fa48e077e0fa3ccbc2d5bfda5ec21e9243552115e9d93fa36169c4c3cf7d4333df0170c6efc36e22b556a3ee4cb48d274edb596bcd7091731ebe19490e082b1970bda25c0a077d62e69a02f23f4462ca34cb4bd749d3b25f6aeb3f8d929647e03ab2d2ee530f322b44489965df2652505c8a6791029b3dc57ba6df38bd203846d1cb090aaab9832efffce30994ef4d1658f34d838b708307ba2eec293cac7fbc64e17511f6e58df5b93c59ebf0ba9aefc804492ed430393bb2de45df2915064dca64ecc2165000cdfd8592f08fbfecb38b7a28748dff0fff51a191b6c7db0e33956d75c460f3dfa19e727343f654cbcbdede7403f4f54d65e32469a84a1608596405aa7e5e5c3713125b55cc2a6db8ff50c39ee1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
