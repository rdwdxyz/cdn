<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cdd259ef05a8b3e25a233b54b2dc4369f7f5c6024fd5de18d40558a631b8e9ccb51969ad3abf21cad7e2579808d4a2d9d5e310bc702347b61741059581363020f5852082050aa5fb3421ca174303af8879c549e08c11a87378356eb2dc4fe7751efbf4f29ca296b9ff06a90d418a93d70ba104898b5aed23859f098ecc40c5ef33354c03425362216304da82e5b469e74ce11e74bf919a2b3098e35b78bab3d30a2e9639bba05954b8715ecea3bb604c61335e5a3abb5eea2072d8039d908122e7e09264b68ba19a273cde6aab23d99ef3ed19f102390e195e50edbfe56980f407dc578ad48885e04028dcf0ee601cd32ac8f7040fa91cbbcf194534969ba76a81d3f95ad431f28cf5ddb8d5d4b05742e9fe419c7aaef8f126406e239f915a0582d6d1551d113ae73061e6a2dec2e297b94305174ee13c98e6d36769b31aa11d2d9ef08b40781d103760cf0e8f0f4f6510fdf78ed3f6df6a7a1a02a2965dee61c05aa378866f16ca0b98f9ec143f00f4ccdfd5a6cd81c3239f66772aa511e0d7be146e853955328c9d68125523f5f18b738a522b4a600f9b3781fae620bb1c4db6fd0f695548cfc5e5aae1dd3dcbbd8117150e773e57acdc898a0809f50295c28a48d7a35785125923c1c5930fc850bbe35cecaafcd35174803f2ed15636ca6c183d8b419cd18aa2a3f2dfc21d7815bc19ad98f8b5ad3fcbdb16927101831a8581d72f77ed0d64d914d32ca082590dd88e321bf9a479987110d82243b42ddc864c0634285c16a5cc657488d6931e027839646158451c988121069fffa54b40f144632890bb3a2085db1b2ec00cf891c271700012904fbb95031208888f44abb9550bc2ee5ca723cda858e29757c7c441b6254dc7af6bdc2f18cb825c39186bbfbdf92b68621df1d369c7a58f4ca98fe8ba9590118d08d3ec2c71b46216c3dfa742a2ccccc9c1c6dfb33c17b1566368af9d2a2215becac2f3df42431e99504ef3fcf922702b02afee12645421a1f8c13ee6692cf691430b27850e2030ceb9a40d18702d654e688058f9a50b9050910067dbf68164f07fcc193fad4c06822dd34d315ace2bef3108523f2cff4295a6843824add3c5e0ed46600eb338fbdfe3a84a937f97eedd376699a522edbce1f64ca13e9bbe7fd8dc36fc8c7264a02e036f3627c46f2a3e284b196d1f7adbd9463b95ff3bf29147203eb260028416dacb73fd737962d496539e755e2e67d56fad9c452e11ea43063db7ecfe15f0af90df5b341398d90cae7cbdd7560cfed1e20dd175c11f16d1401ce5ec05040c0e8f507723116ca9d2982a166bb84758c4f5e1669dbdc50e33163f9f2de667148ea1f21deeb4df16ad0fd682246fb6fdbd5fd308e167844e164b7478c5fee2ee21cdfc76fc9af9ec23161f169e0618e8a683afed8a6979189ccfc56724dff03f6cbfbd4d16ff5e2eed46861171238a9f65718a209b4588ab67c4851764f61fb449a4acbfecadd110dee01fb4526d893e73a5f02f293840f2c0753300035d4347774f7fe89bcc46dfe388e84e5da1f92f6c722afb6dd9fa27c7f7134cde77029ee5c6501c7ddc0cf00383b0b185b7a0eb25c6e500151b53b22304f0e1880baf05c06d835af276a34e9563371e221abb6541ed712d49acae3091a5e0093473793a5ec3b60ef0632738ff535406c6e917b903ea0de9ce07cbf895415f4e196552286e72a1892a6604200dc57c2a977a2235241ae374c8b1eacddd88388ea6477cf98bf47e17a496a9fa2eb8d8454aa4cb4f330563ffa03df0bba852023239314655d0912e84422d1fef6ffad3fc51d158a2bf725a6b76d8841aa48cf3b15e21b90494a363619bff822e231e1e8cac287c2202f2a6e574411cde5842a49ee038ba5808210272883accb57a194cfcb2f7c84e2a0ddddeae822580adca5bef2f5adbfaa6d62b8096c699422e2838ff7b4f07946113b1f3115d63a5c7b8d2eb59375e74db218a96db9b51893acabe68d8931364a7978a89b8320dbc166122f133e711bfe720e09e99ec78abb734fbadfc7ef43ddf06331f610b51b802ccc2f3ced63e97fa34ff50ed4b7ce884585769da7695e8130b9fcc11cfd34decded6ff3d738bc8eae967a92de49fb9624ea57e71e60a352a881b28d0e369134aa1d22cf1b88a6c59bfc6f5d5b235a9e43ea5b0db9fe2f70a6df1172ba855139baebfc49a4eb2ef016c63db7359614382efbc3a8fec8f702346884f2859808e764902df87297e572ca471d98822dfe90995e06f2e733c36e6bfe0446a287335b57a80a845fc1f4d859c805c2be1e093f19c535cab3c4d9a07991161353c58c0101cec8f45d2f57cffbd3c9104aea0dcbf4b13aadb456cee3580058a7e907caddd6c654e4cb1ab49d0a8cace35ebd23d07070402db6bb5b03bcb8c0427e122cfdc8de225ef19983031b7297a133ba9943fea31a56e5a163dd732547a0a62f3e011ac321d21cd0ff069b7c7c77f23f4cceb3dfb34dd56dc83b1d41d48bada4aaa9b99a5850bc55fcfad7a15d4924229aeff21082a24474f918de8163db6562bb1cedd8c26aa8fa626eab027cf6d5455bfea790c9c79d96b45a84ff547ec08c2e1b6860ab76265e448944e575222582e0d8f6583ca72e8adf82885a46342c8dcef0abaec500455078ddfcc9f9cf44c099cf013f732e682becdda3db3077cfdd9e7368f23340bdc7c5c3a3305761e25f972644d893591487fff1d30c8e31db8a91ccc593164a062a14905fe37d51d960ac01aec13c67c89e6968244c76806c82fd6cce83acb323cd8f7207c0054082c8e59c69c9f61b1b3e849140d8143e44f734e476cc6c615ad44c7c637151d31a7720e5b866fdbd3ba7c880701ce69f731b571f7662ed31581e5f11ef629d9301060975c3a8bb1d0fd20013155d1f7f18f7af81a367110466edfa6443eb5e478f264389dfad44e12aa04b3606c16ec2b10eb9437964c6bcad14be3e03d926e3c0fc405b45b0e109243d6309fdab10e9592ef67715786e1aac5720dfb10447bf5a69ad84c140cf41f4e1b957939febec887c0ceed888e058cc64fab8d72b27349c59595c39a7b8a887731c7a87a1a33d53bee5cb2d8c1072bc2335b905e1c2495a31042c40448b629e94a97ef03b9bfe7f47b730f650203fc737a65ece5a3a7f26e7999a1eb2c25e2c4732500e6da774927ee541eecd952d64defecec528a7ce3e046aa1945bc63d86ad392e69eb7f6d1e4c64f0f544a99629b772fd70cc49f5a7cfa1eda16d701e1928eeffffcf420065d4fc58e04a0ed3b355381cce383a8499cf8c5462a00a4eb8d26d75fdb63508a991454a1a6a45e5148e9e65a0a0c2e52bd95f4f112d342f0a573a8375640789e40855ae697650414f9565ad08b8979a8d74e6856b131153cd22073390485f2389bff0989723f8880056a5f4450153e420e05543a88e3d98e4804af8d02843670652b1c524887179ef2bb21974724757efa414656e79562e784b7b906c7d7112066bf77c928dccb6e870fcbae90b844107c02fc88fabf3f3d0220e4f0b3d2cacbe22e2f8a7a73537a15156d18e467a2da56fe13b9f57288e48314788b77d1628e987c29cb1ad2a54c8e331286fc412f910f1385f6c005dac37513f6e7ac2a3b44a06f0da9f21bb053841ee30b11eb69096e8cba2ea56830a0ed287aeae7c5bebb5a43b1c0abf1975bda08bae9c10cd0a82d5303d51d587e4d0b6d1f3dfb6b22ff86a19c11a87edd989a8ec700fc0a8d65c352dd7a2e96c031601e284effcb88f582949d8e366192112608c3073b3f088e6b8b39d22e829c2da67f57ed5150c14634183a9ea9f52cc5301669367fdee60eef163b7c83560b3bc786acbcd2ea5b7d4fb20a3f1860e90241579ae025ca4d50948a7c60f0f0c0e46f80941540a1e1ded1976e9e1263e9dbfbfb57ab112bae41335a2ff463f3a67367729eb00a097c1dd3a205f567b03fe38f9f6abd1fac15c8588a75b171f7f052b3eb61c352b856bec9b5a35f38d58fbed27b4def2856c9f1e714c43356d9863c2b5a5065e7fdd7ed2b0b69fcadb902c0bd83854babee7648eeee6ceb60b25486f65b39e622e99344ad4a47612a72c103ac0b58b9c538a49fb34ab42399d89c40ca4135800d6cb87fb7dad5af2ae4b1ff2ae43642c94580326574275d52ad9d04211e036e7a7565313ee6ebb5458d852c0455a8bc312b5fd996e67da671f98a1903c7a0cbf58c57857f4f31e5a3bf6689bb414c1ce54d60e902771ec910b1c554ff44952620863ab975a3d940d675d0dc0296c575c016569564604db019211f5f2be9c93139b0350ba6c8721e26b667294cca9e9aec42c679ed38759d624912a22a77704caaded74fdc07670062721eb6fee4b41170cc1dbb0b037db20cd1e533a4f6ca015515173f9b70a6cf4fd9f90faffe101dc23bbea70c53f8d4d539520fb1130ea5e99a8fb0ce6628162bb4576f50189f6c8475808f8ba891c07220f2161a0a4c883be1c265b5f55182bee1ad5bebde8cf0c68e1755cb43bf0c2733145838f85c607461f9bf0fd2207d8a3a8d1e58b3ad7682be8ce4b9ea281dbb1b96fb0ab568988545ee1382e79ef3d7e0af450c69eb72e6065634d872c7860672933502ee6683dda575b3afc33fe2a712e125229fa6021dacbfabff6caa11f1105ef59187b6e9e96f8092b76d9f7971f5343d6e2ce7eb0b4b399611b5081fee5b3f92e17d5061b7b34859d2e987cb653105792a110cf9f0ad01d4545071d0927527743ce77fb39fec8dd28af6879c5d7eaf32514b883e4421bea7bed853103d2a74ff46b67c11eb92445ca206b790eadbabb9d0b9074dfcd22f49337983c51aed1cd192ab80cf40d0aed8a00de08c41e87cdcd4d1322eec8fb889c4a9169ff45718c44b4316b50358167e95122fba0775705912801963243a8d32f69640cb8a2af2c7e71a76985b7fa819aa0962b551157f4db486a4f26f526c2e80c35d79c9b6b42bdd069cb0af21d056adedbe4baf04e0882bc4aa1575efc127b933bca948acf8976dba562d29d364354df8f68afdc6efd969bcb1479287b5d0051e65bc3aaa8f089d478442918fb6045a673c949c9eed716620192db1e760dc40dce6504665871752a9ceaef2da590ae2a687e709010aa73404b34655e50b333db726ac15f9feb8956c3919bae3ade7737fea2a7e084c3c44240e9ad48847de410d9a0b98aabeaedd92322ea950084ed307ddafcf2764cfa7a0153e72312637266504a3dcf3828ae1c4b9a9c28a2e9be23e4a1451c1fc1d3621d318f9183351bd5650969b709b6c9316b802c63ff1d019c211eb77f6c52d73ac90e1c3cc18addfa9438874e165f00bb450af8fb86a3417d7a3a16f73d59fb9273498dd2a63e967bb9221a066075a2d40cf82091a239282573c37b2707fcd97a0f1efa48ea1abf596ec4f23ff7216f4525a058eec440096d1c586fa3d5a8a0b9154af3b42434082081d4f318c4ee4b48ab11c623e00cef292bf19dbc3fb86a0bcdc4e3202c31fc7927c83ec161993468884728d9df30456c7b3383a0e2da1aa7e6386caaa4260cbe33c2b8fadfe511cf52e19335ea5fbdc6bf5ad5aab52512312fef73d5fb94ef4632503789ab2cdc29346b28001f1911d8c3373ad2bded30937d34029b34b85b5fa7526d5d97053ce7da631d1921c560c757691d0468fc3bc0df9f081b3492f280f4ece6fc4ac72f8cdd8e739423de166f23b9266af2fd69c2bf11fde55272b30e097f445ac1c641426cf4a859d34276c41d6f532c1007e5754526fde3db3fd8abf7a14346bf6ffd3469f41c84ad69730ef32f4eec1e511fc56ae79d23355609ed9d42ac8bbd6937b240813ced15d626bb6863b24c05b456b013aac9c92c54fa7163eda05179160869408d7addc2be1fed614aa01d099c11bd73ab2763133b13ef2d4625358f13b66587614e8e0fde5110e8ee817dfe443b6e4e1d588a5e87df822191e2d8e3eee2475d9ca587b9f2427803f593555f6683c0e6b76ecb320801181da6b7ff2fb7696006bf417fe064f6fba749e67847ec1efdb70044cc0eee252edd899621e2199284b1b8a231facff3726e44c182eb3f18ee1ead8dd239345d46b845534528e16ca99f590c1d8d3945fd543bd02a1cc0e4599f5f2b68fe434e4f1880dd4ca48fb30405c0c8e392a641fe67e7e969e5fe86a68aece26cb8f8d7a26aa8f5eb174b0612fcf25320c4d64d2e62b943eabf82321c4745973436d80389a5a9074f482634f7a8867a86e8358ad284d201da9785408bdd1ccb31d24f38da26a1a33dd19a20e10d0299477bdfbbfd37626a77b54e251781d3d6b7f25a8cca886179ef0ee00958db0c9c986c696d8aa99337ebd6f4cf437a591fa8e8e30fcf658126e33bc785b8b198387a169a9539e8dd890e1d3821b5523d112ef6ea7daef3c76aa5f4cc2765d183158c35fc071665d8af7d2cea8408fb45cd8777b4d8f0be23b075a94bc0ccd2e2039631f41e2a94a00ac9510ae33cb7b41febb1c99dbde1bc0a92ebfad945833250aafc97ca6a199074afcd32b49e0f083e5b87d1d46a9c91a01064d624e0a4cdfd4980a8f47e8a392d8416a003cc0406b449d542878cdc57902b62807a1c66226634a115f8cfc6b63b4f0c5efe6460bbb69ffa142437566dcea01ec651eec513fe87a06986d154521bdf8713e1aa025175c65099f09ea8e37ffcd5e4a9a447a514c89b9a65b4081c793d2a3a3c43d394dd22ac229a8ecee66f565e1cc63f3b633af7bc8833103fb5c55219cec49faf75a2c0fa3812e61e3115c8b371fb5352edf37e61a977dbc623bc23d13196631ab8f1b9ae86bedb0e13b891c6f3c75019fde7cd0fe38bb89167631e648574205fd18acd43193cc88bfd2d98fdada53b5573c5c7cf26aca46cbe2eea78c37866d3b8b46c828894ad469d0db6e58f7e38f5e19afbfc0f95d38daa42fa5c2b3adb0a1866d10983ffaaffaee91583a69e95304e432c0b8d65a5e3a546c14e2e91b42dc143dd9b3ffa28e540f4b87fff88e0bc564606920f6a4092d82fc46b2c6e529df225b56e68c915b9844be3ef17e792237bb7cbe2e652793a22bf3a93acd9727b28288b7bf1e48b5886ac63a74b43898f0ab17893c4910fbe841703c42b9c1550ff1eb3b029425b179b23720ffbd5b9dce51ccc2c5af8005b05066d56f9ea0a5bd38a527fdc76a09086c2b9b29d5913273a3eb097c92972d6206773d0a78192d786a0b8f7459e7b549f3141f1199faf73faca121fa9bc2e9e151d232a06b5632321a3ae8421f5913f1a0772b1dbefdbcc0f8a86fd7fde85065f4b2f1cff3cbf077c8b6982712f2b81537b20f45b55aa68a2471d516072665f56d41f8d556a2c4a37c194fcde75ba44c9758faf74482f45c62bf4dc79720af5b057b30ac3c737a4b8c1641a82759ddfa704f1a243c65e0d39ea9263331d637bb04bf7545080767cb7b194acb7cbe4481595c1d552ea3bb78d2905a0d8b1c0ce93fd157d82cd8323959673aa3ef1a4ee6d44b9dc9c624f74c1ae9ae70ec30159950481d96b9e028d1d20ae3b64a9c22734a0352efaae3907c5b928c4524da7f188d25d52ae3a9ecdce13dc29875bfbac171595b44090587ffd168645b074e7e28d2ecf5fa2bfd00dde5280c115a02bf3668713a96195cb659ca843c9661a5a7e51740ae077a9f89b1e3cc3e288e5642f4404597e27f3c65e9273fe8a9527c6245f4c42224fcc4ab36abd08500cf611866c55112c22eb62f8e8683cfd4eeaf68169b25722d7f9ceffcd994e9f2ee598252195b67f98c0afbf5b59ed71e933d26e9da756db47ed886d89f8abfc220ea888678debec9e4094121c5f783955e202b9e2a0c26e59f0466528a80f1094abd521b5ff108d39684287f08429ad27c4b769b83ac8a8db8c2cd41f2269e947b7b01fc8a0238eebfb50d74dc0e88b22a3e7118b27184386ede9a88ca165e2bcc6b79046d34e71ceab69d84c9ded1f8a4441f7983a2d6119cba164e905a5a4da9a359d784d994717f2262465d98dbaca4b62599c5d29b190aac88054ef526012d0a5f7608f7ebd510f285a2bb26e63d425efc1b0f25b09d04cb5895b2e035dc84c7f289b5a325759241e14078f643d38a55eb32b0aa8243edc1477fce63dfcf7418628f736866100ed4f9aa127ba6798b83ffceb429065546463de4e4240a3cd5dad3a4721628a83feba2b7eff4d81891acd7ef60bfcf4949345ec8c4cf09941a1422f2eac5e66f7e26f9c2c1fa51b5726058e84142a50598d762524f29dd772b84ec13c0af6e0eabdc23a2af7a8e426a6c48a38c71a01125f3a2cdfc8f2aa8d8402e427c957ce7841afc515f92244efcc759e9b9773a0ab84ba07e94725cf512df147448ddf46c6517a6004b0e88f69c10524c31114a6af8c2c7bd309b7f6cd80ef4d76ef6623712a08c75bd0c66a1b60e20ae8a262bc6f50ead3ffbbdd1070cccb4aff4e161a8f8711c5786083948af2a156cbfc38108ca9dc104c3a6e5f323e87280bbe09a9ade3e7572fd15f8339a372f6a438d1659cf5d7317f3db1c3a4841f84744eedec43be81635d99a764dbd6d5c4bb859c389fca50e6bbb6138c18d13db3a2bfcc010382d93f8322de55c078bbe83d9d816a93a5ff132ebcfbe9e3e42beaf587c5542aaf79a736ae02c7ec908c54225bae8e0d50e7184db2219b59cf9ad2dfc5fa3b6a1511b9e14b20b273627543f49ac935e4c19d538187956c0459071fc58f2e0647ee32e864b702c28e9ad859ba9311d7feca6cd05570d8cd4d647935df84517c5182a93d257a43365600c3a54236c2eb44aec35bc6e73595473438db8f4f217d6a3f92bddb6b0b35774843d9260b957eff60cf69f107353a9b66b00e87c3e35580619f48364d39e62a3a564ca5daa9a81e09f357c5f8725a97589647466568767113b8d9b742c7450d241d30821070a709fded1399402ca89bf33f8543e5629f7db82cb824a3238c76a14002b0396b4c1291f2bdb9e8d054d0eafc76f964d48742c2eae348b694fbf0b603d1405ff63126f4f08b5dc8783b40733763578abb1a4972df0bd98f94867ba24060d04ca38f798ef9e1cbd91624fcde697d6012326da559f26525e77ea0f1baff96e61d27a8f074414e77d60e15837bd47963f7363312cf65b51ade4d8b56d0eccec67aced9d4e0d05bc7ffb7b80a867c4277ee16db460384de8add8015756210a7e83c43f1e75fbd641a22f6f8355aaac9a477ba05270ef2b7a93aa69a3c87afa8dddf383660d805a62e8d378993f38ce3722ee691a87aa8a860bf73b0eb1dc89ca817dc3b85c79549905d79b62339fec0554f2c3d28835e42e0944beadc93b09e3f0c9e07206fe1c8d7061b91afa49d1518b96418d6ab0f6b1419bc1e2f1f5d5961e60d05e35002962533d060ec34c998ab53b6c292b5eb4724fda5cd17215b3c91b9da87ca71b6e03324895cde7fc5dca2cd86f5b2691755eb576f7f37cd5ef39b3753bbf0391483a9f8066d6a80b7f6938f79e26d1e565a16dab2f8ad5cb7387e9784b62633d803f3b8bcc93a176dbcb12dc9b13e1288a339a992acce7e1d47d3013c5a503de51a26e2122b970b7b1141db25e4261730ee823f64095bc1d149594ae9429760532088e7aebde8ae69a4f74b3bee75d25687852f91fc6476a73d388cdfb662364789c8b191dbf063cbfbabe682a1c4dbb2ca36a678db20f8547a31ed5dbc7c93c9fc055bc513a4c1fe0fbecdede0e523f7b892b17252c556bb786b99ba6ae5592dca8d8a6c960a90aa6471c67f971d01e33524f5be96086a608d0e8981a762a3ea3e59eea9bebe53270763e8114fceede0d0e1ee68d3043275456d84ce79775c44de122764e2ffb3701f26e5500b73f61ebcdb733731be5ffcce7c70a8802ca9ea6c3a9212a729f12832581718d681641fc70b9bc2920accb0320f4aed08c45d2291dd5aec1abc481ea3998c8ec8e42162d17591d8f296cff99c68a5cda5082978cb3b7c39b05f512dfcba53462a0d8f9cf00e14b71e05a9e41a4dd2c13f40fbe704af6295049e97db54a7d38c6af14acc2727e4505ca186f102012197aa841b7112d334ac0bebb64dd6450d38e0c5fd7dbd6cf43b084f32e81f71ba4b8f601929885ac8ac5f3ffea122176aa19cc85d0e70e694c46e42cd1201b000742e67f1315ed70b2628eed8f5f0c0366bb7003cc62f172bc55775bfe999fe8d808bf66d0fbc3cd114066405e8dbb73cf5d78146d0a3f9725b35454b8e8d4b55b08d565d961bed75da02e0e72ee07594a442afce366cf4d73dc95a7704bbbcdbb21509d3b5756ebb499e6f521abe5298c08dc9b11b07c16c61a60a2969be2e24ba1c28ae93bd4dc94a1c483226fbc62345c43cf1aa9e0dae0778576d25bb567821c389a431d3159a2990d12bc8af349c60823bc0ad46a8ffe666b9e8a874558f0eecbc2c4724d8297e8da3d628913655efb4e7ee87094cc1cc33a63e4a939aa2fbfee7c3bab825c45b86e667ff8c502878fce916591cf36dc02a8030e0f03609dfb7c1911a1c80b7de2529933300f45faa3d7e1f4a92a58c2d3c110df9c22e3cd30efa1e394d5d8a13fdf30b9ff6a99bd93be27addea1d665429dff03adf10be52f129e49bc8a064a720ec5e67bf847664d2a845a809c7139d3fb5711b5ddc9e38a9334f9ad6b5a9fd5c0ee21556a4ca7069b965a99ab7a05aaff92f0ab3b85e39dd8cbb16191ac0594bd30f2c8ba57e7f27e1910bd869ae512241fca34faac00910340d1750c8afeaf5523b76fcfe92f15dd0ddaa1414ceeaacc2a397ac73fbf8136c8eb9db19fcef04e934b756cfccba64b994935433a36a0064ea6cebcf2664a44547932ae118e276d8f5bc6ef13a39c37535932d663cacde80d2b9e7012141d5dce19243517ecd33563ba50fb9b346bc6b484e4d3ce6314601f69e1ee6d5c2e01b78e679fce363855c47429178d16f83201fcba8658c4c90d857f50a083ebe860fc125b4f82075c8c65d66b49fadd33e6caebe2c678d73542bdc394028eb23b4a3ab8fd760fb53b11673f4b90cf72bc2a99b22228d5d938bf5f36f9b4a6c088b8a7c88640c8c06e528b0957e4f860ed24b54d4859552ee83f1ef88543a4e80b8204bc7f7a06f2239c1403abbe0ec18ec354cd5bd17aec7f97a0e207cc18c18d2232afe0080c98ed7401a40d644235bc4e675cd46dabb3808c55f2a0bd832ae1deb1de2c2acca1b01e52984233c4b8333cae5f7b1f73c37d0caeb77aa46aff68cbf0e17183b87183ef5eae58ab3b86ccad7e964f40a94d297fb1f5249260fda8616c4fe241942b3647eb1d3c1fb68e0bd71fc8acd1125c9fb855ce99949fdfe6c7c1919d199b9f6c185cedb4b7b2f396d6faceb4dafd555ba271b2ff2d550e3b4c7733b8fd8fd618bcc1ae30d74c9b62793016d37952ba1b4051288897d56a28a74ed8ebc887d46715a3e7a5519782ad5aa388b9a2fb9f430bd81e0da5b7c7de19e00663515c4b12e3da7427ae0c28a3d06b39c41b146de245245bbe2ee04797388f0ab5ab3d42900e1a2cf1769dd44ade341b70c9da7f5655f6aac604bc8f70589ff3fa0a79d5906604cf74fd6cad18b2d114e22e6c8e3a52f139c1947e839da7d7c29330cbfc5e9b62936b8106b7c91589c6e6c25c1d62cbe1f17947b2af35a3e5b91612f6da699d0f6ba2d69912d5d79dd8729805cb425dcb4198ab69a68742e02fa7f90e6f3a591018d1152129e17af3fd3c4b0f76231aa1b79dad31da90b7c586fe30cc484c4814f0f75c2cc552643a048be4dd47a3de1f3976ee3983717200c99fbc8754c8625c21369a2aea8364221daa598e189fdecfcb2a1c1245d9fa7e44cc7623011d820ccc7e4534976704d83f108b71f1a397a49a2b0afcde65d28a2307ccd0f756523a5af9cf976d49f67ff4dccd285d7766456f7ce10480df9821b0974d570795fd6914f99e303ecc6701334749a6bd44fefa654c9723441c070981f2f42a5e4e2bfe942d8f785f52b8fa2b368090287202fa239440811a326ef1453893c2390287aa3757d34a7efb27a69b393deb5d6b7cc827e1865dded76f44bdfb81a59472573f33a364dc925912cf3e619caf756bebd0008d45500a24b742f388a300fc48ba5df3bd939e68defd04db652ef34509c499318330555dee32e8ae19199a6a3bc0871385ad51e6212335021a8a7b9a5c29ed6a21ed337a92e6ec510af501163820f4277783061dee7bbdd7130a6dfb833d9aea5cc32ba9b3df601abdc536229de72bc993938caad7f1e2b76044d574f9a36f7a6947bd4a6d5489ab005485c910c905d0d7f1619d46b50b8be512c720133fea3096f3cf5e901f489ed2beb9a191bd2d53f84aec7aafb515cb02874579911089e058ed06abe2aa0e97dd878e4305f2b3762b109881322bd20a75535c335894c24ac4a5155e3ed88baa6a005fbdcbd4370c8d820e8fe9af88746c42bbe719a61af005b77c1cfa597c7307e416a65f1d5c4268f49801c577ca64d1818462c1f016d2f7b2c9dd54b1ab66777548d530b8647fc68fa88b63422dad8ca97fd9dda1fc17100598a1319805ab658c30415933f72f749aa94802db760f57c5dc3c9abdedcfe540f6ac615361b6a3ee8f1223f4adbd7d5d65ca5ed5e1f614dab911ff283d1bc1c7617795f88e9d9aff0007de4bae3d5c34b4d024dcf8b01afc2b6dc914fdceeca147521267599295dc6005d57a7aba3a56204a454fcb55c88bbd85d4a23e478dbf5ab5437285ba962bdb0ccd4cdb1b3eadb2c4bad98c351a5943d3865917f7ba028cd2b42e54568017450fc15d78a29f453965c71709c0bddc1c71d9bb702a686e167d169b03735a9b6929ae78989cfdc8e7c5cbab28220b5bdbb350e8b2a4b35dfc79df0d7033bbbdbd5e4cfd7e02c383a9c1449891f283eb289532d1e2144adc0b7a3555051bbb3f16253b5cdea487cf52f8849777d7545fd5580510a965c7e6f7c4d5eb9c1d03e55dbe76fbbfc4e77ec4ee63fdfd0f41fb7b7e46620d606f653415cd0dcd73a4cfb9220e5c39f986a286b11f022059e3d27d9f6ef4e6eedb9568e575654e06d78324a882ee8c9e3570e29b9490e830705f6c1c806fdb5e6901cfe248011e04109150feef7e67a5b9272a7530b1710adb7b6cc9b8d85345b9a13dcf8b3e62e716d674ee27aa4a5f5906726e7215f4c09ca2c30ae2bff248fa5a8f40f30165a80c1bdc4ec989932be7d124d8a5b65abc5f7fe8b7f70d1cac2b9df8099f4b4a8ff064f0e5a2acc250b7ec2b53e584af371241800460d4b9b323b722b10bf58bcc3e991995fc858d1396c3049af015f68d5c919e2fec8888ed735e8cc0e03c01d9dc9500edfcaf577d1c52c9c5a56b632eea001034155a70440ad626eedbcf891f7fb653ab3c6d071db97c849c9943f504ad95f1fb0e05fd4f68aed1ba5752e15f59eb8cba947ebd7e3ecec871d140eec47df234e736c99e9d0a9ab1dfd2267468732555702382145e870844cd7e3d25dee9c78dc5529374ec77791acbf7c0eb24a3f1d831db34e2aaa13e98d6d4ff7f430e82da207639cd7e79e7ff7782392263459dda309977e2cb40ceb7e73a21da63b460d592ed17528624abd879d065aa16281bf93f45c2e73b49616c75c606efbf1d7c404ae1588f9c352660b67fc5729143d47e63de642f3310add96a99ba7ab6a09214da897e28c3be6ddb12b7d99bde36a697e75546b33902c0edcff526a53244774db937fbf1063174be53420b5a9e17664ca6cf1395a0c7977a4c820771808c950952fc5aff941b954a95eebe1a796d698c37f43386d1e6eaee4aa022d93434b1540856df2583dbff8c50c69357df7b58a70dc8f6a763a4740840762a0ca354070a44358f05d05138ee5235d3b8b3973aa26c2fb8484c9a99cc5d21b859832861fdb80bca16a2345c2aa29a89842a73d91a163cd3b7cc717b9a8e0c5b467169c2dad4d182774f897a8e60f5e6a93a9d466d199a5f345e7eff6c3b58643aa278095a62594527bd4b91fbf2a31f378fa0121cc5b092bd007b4c689cbc66188b620a5ccce5b11a77a7ecb9c752c0c0ac5d6279c63d94ec125ff21251c84d8b0d796bb06fabc126c83871101dab4aa1106f4d80ff4990186b4d29816ee2947144c149f6f17ceb783fe435ae3cd61094492376729cfe99b75e98b9ba61c37f2853655aa542d6069331ee6dcb46b2832bcf6e2a65e6bebed63f5d264ada4792ae3a709502e4741f722a90ef5012933c52a127c9cbac337e4e00b27cb65c50aafb35ae66c482f88ec1a822b7b3f9b211007f3bf70c2b480307b2661607d993034fa61cb1f8e6fc62aa68ed2ae424205449ca45ac857414b2a7082c0a0d2f7389fe142099f85be4cfcfb99e3231202b8d8d8f8b4c023e2cfb97378c15424f336691fd9983d4a7760c2ee27a568beeb7c0c28d9e0b060d84c0946ea7c3e34bdade24b9c302f8f19efca488f093c20dd59dfa0e0c6f82a4e5ef0583419d40f16e6a823adfb98ce01bc3bb7a34051f3f064363348b299e05f3bd3d3fbfb74b46a0ed2c9f15cb47abd527295f45c03bba05b2f029006e8df47701e3aa96b69e9297fbea866bf0da282e8cfd90a36fb0b75ae713b5738858acfd3835159a4a27b459e5a40f4fc7e31475a613b5456a0dfad5fbc13c4e58be3eae30d101aa8c51ccfd97d71d9652e1f830664e03ccf99cdd75f647788a3b6ab29d4ea73daf26e931bb7ee4399711d891de18730955fb079c15e6139d7fcb800e45ff7a93785ce1ffca8511c8a7978638f3c95ae0bba41502b7e1c58aeb9aa44c63daf16deb7a8879d145512df6f2697414f9533c0be9ff7757a283a290ace0e4d0cec68380ed39c21cf0c93542acbbf0bcb96ac705e9cab918c954b7452110250579696bdbc814027267a6e38d84020aa55a8a131dbe1711f590fe2e9fbc2f48dd6d6a7052ebfa71ea27453d69dced6429787b062fbd728cb481d03a91ebf40f6f5fe4a53e2e3b698571c7282f7a1c079c74a4a77ca74a28de6c2ba88a36269be03c95ec265e559ea81b2f6499244b4d9180ed5f2968848cf49577c310acd9335b7e992dd0424268fbad7413071b59812ef657","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
