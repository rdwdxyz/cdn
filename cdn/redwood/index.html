<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"046d7064ee82b05963812a3c4170e22592f4fef4ae22e5483aede72be36e200b2c4eef0fb5ec8284c5818045df0d3fd3db2aca6537af00b47e3cc919e6081c7cfc80ac72897317ec7f30b4a9c99972d291cac8ad18499bfed9d45b579f3d519d05521695d62fc46b619d917a11a7129d70f8b6b36782a469944df540920af4cc6816a1eb06511edd2e44f794aba38647a294566baabdd04c17e488a7b85b191a7ce67c883a324ee0a7462a953ebc8166f25daabfeff0c6d5f3498c80ab358deddf29aba5635d274e634f06189b0bc0c78946205737a92b33bc0a89d45b4331b24d8f37e33f5938fb752401d2a66c81b257b954e17c0eb1593e36dcdbae1badecb6ecf84f788ec022d4e5d1853b23e5cdd72b8e759fb00fa1bc2accb1ca3e526d73d631059c56963722a3cf7441726f567e051edad62b84a03f0c8df7f88f5dc42dc5509b353414692aee055584cc81c34c07a539dcc90c3f991a02b203af4b864098219525f4180ef7aa5a439d7d99aea3f6ad8bd672ebeb6b04f79a05925d8a041a7758f2d66983d37a4f4000a203956cf2e1d70a45ce2b21c7ad3072a6efa2c27e5e23fe33d4608d26d8283c343999437f8538f431bf2e415379950f48a91b956380dc4530fe3cb5891d269b5b1fc1fcf33c37d67e76acdf2ead3ae630238594c2397cbcaa282e0f1f1b4847b9743453856ae2df27d6fe1fa42097ebe4562ab47e29d8e31a555bf8039c1b313002f3d08f6c203eecf64943818c58172e9ccb0086c3908df5d06b66b4ccb47f20245923d8829536fb3c2deeebff05f99cc8aaddf53100456b081e72461ade83d2587e959736f84573420a691e9ff1fa377ada60844295f10e986a6ace4875502e22a57dc6e988ff1142ad30e2d0406b35333dc5f4b23ce8041ecfc4e02257d1cf0b25e7d83ec2cc3e01ae67b35fca9e1ebcaf13ae656889cbf364bdd99a927bcd91b5a3a87555d73cf3cb59a48e11be0aa4ec9f36084886d9ef37d740ceacd073761a7c50aa6d90fdd84c7dac720ef70dc5f91fdd6a2d48da43289f668331c6746c1f01821ce11b3a8be101e8d8f0d3d5b55809a16df1ff7df747413bcbed5b2e6e6121028af47128dc5a1fd2964a80242762265ed2080b75ca6a222cf588fba945adf05f307e8e895d862e8d9e681a93cbdf97c516cda0184d8319f1b95bc5d57ad5fdd0bb3defa90ec179ddf2593f3b377f37ca91c7fbc820f6ff9d81b5f67e7826d2b996904db0a327c12cd0f492829bd548ef66640bcc17ab653d429b66ac342390392b0837bb5d2ea81f7192037205eb203e0d3cd85251a07ae7d581b201704eff4eb66f184a099a75c8f4b41900b8cda7053f4a559cc6d537f378e65ab1722a5c794aae756595ca4714a84eb627731731bc2a6bffab5acced1e0aa4d590df317603290da7b933a20b3846d6517223793ee93906f53aaa6bef9c528e32982a19ba8637b86ae52ecfaf15139173f37ab7dbdd3d76a4e4eef1c9ac2297958b09e0245bc57e501ecf207d47ba4b4a4f1c782102ffe3786e83a4b2ec37dcf96acb1371b9a6988364ee9d9bc90918da498e3b6dfc489578ee9dd658d848a4c96afd1cccd7e0f5c9ce0c08da1efe0752a2cb969b7112ceac3a6d7e0a4e3abc4472a59eaefe17cfdea7d5af48b7829f681f40f010963f77bf9d1020868fd40441d5b0e2b5ba77b82988841057d43edea1e7dc8607263f21a1a115bdc211ddf5431b56aedd6be84b5b98872bf661ae668a01397b46536900902fb8391970837772c890413614472be8541f175422c1790905bec0b88d7a66c738f9bc25204e829499dd357661228562beb6ca4defabbe37512523ed25ee1f138ee2335ceede1ea56b09673adc6ccbaa83d7f01887477a3803e2c38e2ca735fbb4877cdb9c2df0649cd26b2e231bae8317f6b278a25a1705ae57e9a9262a4bb5adab273d45d6ab7dd2962001a952dbbc8fb8c282705a82efb8a6fbc64505d2e34a641d4694796e13729dbe5a82c211b12f83bb1bbe793766f4fd9313464ce005b098b27f6d2a99204099dda9c82c93c3914585d9c660211b5494fc1a25524adc109887e8cb6831b5a8e39220d54a7f2bc89dd691d43b8733bc0d686d4cf95662d70a842df5182a0871181a935257cf9f57bc2479acd5ce9bdc5441e212950814085b759d2f51816ad8ba6f3b6fe1dd4d2b699cec40622eac260ad7d798c26df81d88d843d0c8720ebb060ee7e184097e0373a5692ae94346563225a6503e576a7540472dac578b21a2babfa9d2baf0a088366b2e64245563030a5e70e25f62464f64da238c48444b3becff311561bf33b7dc8c3331ccca06d26fdf9edc00c95eac12d65c812fea0925dadd82af92e964182d62b039293489e5ac56e8fe982ba7bb93e9d43259254a011c84847c49388ce320ba03a10df89ddfbfa53e4ac9b40c5329c90b6770be5badfc92d25ed76e5e932b83732e848547af5e9b3634ddf8bd15a1ec1b3337a361e02e60f07921d9e01ec8a961372dad6e086795070045e8ed79037abf2e57f4998a79141f1685f9830c3da189bd6e9ff10e03b1ef12b326a5fde24d1fcdc92aa04cd84c41db7880bc7e451de047cd2aa9360d2972855710b9574d6f48a652123b92eb8faebf2ec77f673e5cb100db23d6ad7ef1f4c0dd50748147bc42ef6388b1f297120b3415569b7f8b76379c53e59624be268ed4fea3674a5eb7d9dea0a9025452ea94392946e94fd614cb4945fb0d0acbdaefc038bb1f942415b7c5ef327be4b91406f6da8b8e47414198fb5397e33866cdf238d3052e86f79e54bcd46a921f9df520cddbda2d7b0bf3af0295da6ca5014f47b5e4f18c217bea7b81a66845c8437709093f6424088c5a06a81edd4ec6e6add0aac8a8c8a483eca3408167aa15b6bfbeff021cfe7168d6da40766856d1253afa909c3eda381faf882187b501b9c901e9ec15e5ca7483ede04d110e56c918c02884e46b4d247f00c847d44d05ddfb725bfc144823d7159c9b702bb3053514f5985a999fdae1800f182d35134a22d34cf0e9a1d1be3f58124d0c1ad22a4d0e30278a6b6840d580268b0af98ef40ba4605c79dd85c316f94209281a5e1f494aee34c7ee330a79e9ffb89869c2bc0f6703f91a8ea97bd58fd7ef654f6cfce269976e75b17e8ad6186c0a229276f6f55ac721462d30e5a16d97263ebbda8402e5a8792b0ee00b7a360c08dbbaf82637d4eafe23846fbc95c5cdab7c0d69ddacbd3e4a9081eae6d1007aa1fee0a41f126e50c5084c91e85d9a4c2873821b8183f7dafd38f12d4775d73c1eb7b2a30e84c0719bbbe050e8ef595d54c48a5b5e797fa133b5023082877ac25a1da3a9bcb3ed537128e97195ff824d872f63d980fc93e7d35387872b770dd7895b71d327ab1f0c0c79e6f4db16039d301e7b30d0a1d4c13f1a0e80c5e7fe564c35fe1b142df0748618aeb4c23237458ea656a7091c7a5379a400f7add6fdc08c30e2415ce570bd0f6ac01e20fef999b820c0bd86ee4c8eeab05528990fd0cadcbaa70d61a68f4c479a57599a50c144ae5f6de76a5753f22065a31edb989605c30d84c013524128cfff8778827d83170e82f8f0893a5879360a5dd658b0ff9f18ac27806d8c954b18d75dd9bf8d6a49b1cbbf0f2e8b3ed7e972187fc40a46826b82cb7fe32d6a346edf8d3f2a2cf32476ee63fb5691e825d442f306ea63f7e18ca79ed41778c61016e3a31449a50c42a8e24f3d7218c7a7c9e0933b77e0e2d63675fa6066216b0a179239c738b50c113f8fab3e205a117e0dc9f45a501db9dd56988b08a5efdfe78f6ff9792e3b7a94c5df782a711948c3d241f117b5760a17680bba20b74b92b015f7225fb253c24d212b33bcaa48e29ef58c062c2341994daa72ebec7a049dc06a4de0929bf24fcd48456cfc130c239c2de04b5c06b9ef14b27c9e2bfafdfb9d8fa5ed07d275c5ef07004343c107247e72f0752c1281a8f43ee6109ea27beabb9144988e3aac95a13f7a132e8562a71de1107b793cea7d12bd7cd3df51fce924514b157ce4eb9cdc60bac2746199a168a22d8f1c50f2e45c8a01f16d961eba4ac3fa204dde3094a698d4db1d21898f064305595f2571b0116299627ed037908ec4f1c30b5e0d097e711722499899ab71d8b176b8afe759e866007f2e27f0d67fa1107923183208945b35411670c22554c4754c80f8a60637749303b857197de5a72c852687e6341d8f619bf68c60cb6a2bf0b87463cecc2ff6d6e59e98b387dc4616e1bf4a0930175b0e83bee891f8dd634f928f32ce18cc404e87470bbc17b08cc675f2fac5938fe68d4b476fb506879a3ba221ba1db0f29a4867e8a135f50612af85628462c828cb246d4b6e7c839151b4289103ea95773330edcbd7e0d23a452ad86ab10792e85285fc6ecd3a2abcb544df0623bf8f36a8d8166a6aff33b45f3175e75c7eea9da10b29a2b021cdd9022d3168cf03bd62aee44f3d4d5274df0b47ba3c2ec16e3dc609c06056d4efde61432034bcbfc8eeadcdf99043add4d35a2968940ebbc5cdb46b3296492ed5f1ea08cccfeaada3d4bae17d8e3e767bc919ffe70763b24de282588aa3bc20e5722ca938c0291a0245a2fb447ff25e7dd79e0e0491dd27fa89d226d1a0ff410dd70d64e31bd901c4792de3a1d85c64b9da74027fc82dde1190bddc46fe3848fc0a02512ddbac3ce01bb7644777ef37509bad0604057f5b66a25a3ec5d324d33b9bc1a0a2ac57157ee14ab9eb924a690cde38316dcb18a37c58fdc38864799597ae9a9ade6a9f6d6a31437b8e7a8f3711ec5dc8b5d57012a2d00e49ea6b0ab3c08e832f24cd0f371255f902d5e00307792a06f5ebc82a17fd4fea87481a85401fe2c5f6dad60fbc82eea977e835ac7f688e45fab41333f8bb1306319043c57690ebd91bc052c3066ecffb5ad4c7805be9be68cd54fe0cbb33acb816bcb6e807e4eb9a79588e1f3ff78bcdcd0a9bf0620ea36a22493cf14f23bd1a9a56b59969e90233af11395a244e69269fe69caac1ecfd910baef83706eb8f1ae76c31a01a92e8b301db87954ebf785cbbee3888c4dd5b1cb6fd5e6f3e9e226d45b1803612f6dc5061c0e792dd190449b82dd950db1c329c253885636dc42889d12d3003d0dbc280769da700385b7384ae75e47f5c30fe36bba668ab97ee3007753285a1905f9c9700670733b7cb2303fda6ac7855e54e074b2be4b621190a728da850735ab0d41afb7a3610b0a8f42b138c9f59909fe3fd3d85ed70a596a9ecdad283a4a721d697c319f62b9d18062e3e52a0acf25dde85a04ceddabe4474e88cf5fd3d15f1ef7224bca2575dc9812545c38b346aa5284dcca0d61242749a3720b8cef30b440cf5446016e195f66be82108498a57d0fc5928f9b49e334146183a5c3b13bb5cc97c95dbadae3f9e4775aa241c71422c19ebe285e3803ac2503a366c65a532abfa9d9bb6bea907c25c63dc9b1a70362c2115e4537be481af166d1e1e1535a6156287061f7e15269d881b98784fe8390a461aef0a1e7c15dd568397c8e0889c110655570172e84a4faa93ac63c078cde7df1b16517f73d7c3f82eaade7ce46a5d748ba5a9337c8a2b061e7d12a12da94e6d0748ce384f222aa7933ed5d6a6976ac3d8bfc8bb3acfd4a72886a2179b020efe958029cddc1f73adc66e0732389ec39194955ffc9cd6d23ca561f2cfaeb29c312628c5825e4ed90ed85920e5e8de26467aa317d0b9fa2a289620bd85eed965459a6d5064a4d9b71e1dc3551d68d0cb242fe180bc87c9b66ee835fbcc7b63772138a306b60c232ab72fa21871d6ddb225ea6b3917a9183083a1ccac36e0c61539d2f8464c67455ce3354307bfdae9bd80aaa34a41cebfdf67bccf4e13dcdebe216d96b3ee4d9301e7462e3d233d954f493545f3bc9fe54fd047318deb2b8121d653d04c0adf9f0ffd53a2e44c10315b02ab5261aa90a8215c40f751b8ef84684d48e70e1815cd87e086046d1e5f34c5e94c9a3d6f75608cc058d4b854bd9fab40433b6ee53189b287abff2341adc559d399cb469351f33b5a6589799ed9a8c66672ffd7e7183cc25f7d092a0f5c7f8d3b846f2a4ac8a208ccb6a0df0b2a0c1adbd4226ffd529bc380dd12069bb60d14d6342eceb3e5e3b4aa12b5513a3ed8accaa86de44d0b844fe1e0849f773279204cf8205de825c4f041bfa99d801b9c781f9477c8d2c5a802430d79e4eefb5547897e112ff49cba0d271f50ca4a6b51b55c946ad0c6b6fe053ef9d8183c03de5ed3a80c3e5d891b0cd18cff6cd86356beb48aa7b7e4fb34a5fb859af9f067d91866d4e1299769d5f5c40f6e0bd47f4b9116f391c19beaf9da0afbfdc2f70fb82989e5b578efe58c45cd044fd31ec7022572a73c59981a82512e2efd0afeb43e942eb116571b4aa241b157f3b4db6fa07d0561064bfaa4f95c22e3c3d18146a31187f7c0e3bfcf10818435940171b9101fb4d4463f0e7b66d354dfad484ed27d500f8509d0034286dbf99cfefc06ed2628492e3acd45cbdd547b45e4225ec60bf604a17f0bc8f5a83f53aed66877fc0c86b927961d3059fea803667699421bddadd756a9dc13f1d58995dc4ed7fd787c79e39a165d660896fe258600c172b4a9c332a6b1306bcef4169b80cf416a5389cc112d008d6c777162053784133e2b657a957275224525731067380ccba365d8188ddde63db7f4ff847eeec7b6526a70ec2b1daa48be886c663b855b02bec3965ad73af562f77ca48de53d0ffc447a44bccda5f70093eebe4382b7bfb859c446e5825862131faa720bb047e85217178f132c7a351425e3170a0b0aacf6c4960949275c7459a8bb93d504b7c2874398c1f7223c41e52a2ec76bde191e7961e20e6e78200dede4bbba43e4f555011119e6a9af8fd1b7070a425587c0394f20798e48c2e00aacc03ab43775d82aac413f69a8020373574902656c96991c332a66ce10cb767194d435ab305f2e7b7ae2d87fef75a52eacdc1160139bdf9084248e0fc37af1edc4741b861d2a3f87021506d6a1707ce93842e4c5580cb169c86acdb085983838bf5295fced520744ca8af24e155e4c0bd8ed75b2f08359dbb0397de755228ab8d5067b804ad91bf1a7b5ae433bd9108d2c41e6dcbe7c3295640f53721d7904c370c54b18ac7e440c2b22ba8659605f9fc69179d2df2c1a0cbbe8f53180e61addd39c234ddf2e68fc9023139d0c8e344da4d732cce192d3b4101a257b46bec80723aa2eb31dd3a1d1ea760f91eeb6c35a7acf4893fe1ff372ad8e46b6a24ea423ffb963e74b29173f08e6004bdb33b3dae3f67375f4614eda6a07069a4b3d7c75dc7a028c3b7b838441fcfcfe73d4506dadd4820cefb4c96b9595ea181cd3e107cf5dd255f59ce84c91e9c3c9f6979c0055f72a7207aeac7e57ba05fa75c87f8300c6cadb0740492bc09c5254075806746bbaccbfff4f719b4c1662aba0c87c3d1f5cf83c92631ac8347b84e39f4aa544bbe2f28d13110e4ab370f0e4f61deaf5fd30201fe9122dd42d75f68caabbd0da3b575b0d7154f72a941c600d2513b4dc3ed6f3d0961e1b4494128aaaae37ab2db7719bd851bc51f5c92b484714a0470e4378ccb2a92bb4bc7f82e1ef0a811cc5ba888974b2e1a959f86b0cc4cabcf4869e1660bd736589d7d6eac4c00396f0b2d265044aaf77c590adc0113170dca9f503c6ace11149cc3fe978d1556421f61b455ef051f81f2f78ff5163333f264c99645e1ecee5efdba3a2f3f7ad17c9b582a8975171b94afe582da7a65212000be67f6513fcaa364e690028c9392f8739ba5bc792b250bb34f73250297847e84f3e05f3380163bedb7dff8611016edf7493787e09cf5195a27faedf3c457ddd432c0e1c39db45b9ec6fa1c52cbdd4a22bbe33f92993bc01d32c5ef00cf43c6d21077fc170230c23c7e049c0caaebe224acf3f2b73e84d8057cf1a2d2411325a89a6e04323ef63ca9b7b7b66e63b780b0d57c1d33e0a544d4b4f63f157c35ee1883a1402bbfe4cc75bc4addd33d182e2d5314d2e6f11b6249a0e343fca2cfabc804c202c0af2561f1dc62f18a863c4d1e80b71cd2a81138ab4a2657b4c7e19102da22ddbd85100a24f726b3c40c9c6f61ce52d855213647ce7c07aeb48b952ce842e2899f5bfed36286c9a2f9f0c4330fb94869d3cbc068bfeaa46d74ccb5d7f957e5d66df0321311f865d644d8941c5ede9eeb217821b6ed20e5189f576ecb32c7acdaeb3ac89773842a90b69c06768da549126c796da4833986248c07a1c10722570c767694e70e158dc453acf4f972257ca3e6aad3178234ad1ab1c91eb588a13d23b739cfc939d551a3d69e6f5690722f08a59774a3ced031611796b7497d9f742c25ba48bf14f65720b7a71f282a89cbe96f0f9b48d5d5adec1f4238c4113637fc9037ab0a2d1be25e76de22937646f8a7dcd2180ad26231f2840f143356b70f2cf39e8626337282ad903f7e30697c65c63bf084b1d8dd353a712460747e238e2384680227a1e6c2255f3a7be2e5026f657afbafb8977df2604da011100d059ea0da8c9408d445ad3de17513a3124bda0b1193351d1491b89222134a829cf0466ca399abd78919565dbb0126810007d5e9cff780bc09cb8452434d892681e8e3b6f6ca184cbf51f23b9cecbcdfd80b4b8e40aa86023ec3ffab30ec2b2ff7e9a21af67502136b9713ee632c300ef1833adff7b12858e9db2313e3db55249efd812481a24ea92397ca6fd730658680b83ca2478c618c0e857c070be335f629bef9355d269add0d8f12f2750efdba5dc9ea112c4d9a127cd0ce0428bc171b64ccfb8551e25b5c69ba310e0ff57744476bb8af095584493cf3bda84aeeb8569b6e5a2a0549021db6f6f47d266102b633d8e338a060984a4acfd68f24506bdb18b391e20124018898a7bd6aa648f005a899ce93572b9aa3c13d80eb52176e3eff91d36cb335e797f7c35e460dcd0f53c3fc4b1c4b3b371ee606c84b4e56db8e7554a75fa5c075d2d1d454295cc8de541547c363c5db392f5c31f6f2da59a72e9dadeb6d3b6723dea650d9faa9728165a1e91c7417c3889191ebe613111ac066c9a68d0cd1b1b50398bb24b2195e44eb6c17e379596bda65c646dc191eb7977e87f01fbfeb1778326b854979bf78d01e728136ff083be4a496c1798d7116c4faf5614596ca0bd39e05ccbcb6105ea081cd12a00bdd169b435e1767c9414b3ee20b2d2c7dbd9c71c299848842edad1f30dcdd119f6e4fd39724c6118e222f17b67f04cba79e91b14546bc6d97f91e48a1b13174ac6ae4e8f3d243068dffdc717a3d9cf34e4236b7b72ce689457a23b1d7b1b730187868d362fe94396c15531f4c4d48182b17093147dc52e2f32d2527ece15b3ee44a29e7ebeff4a3d927a338d71cafb42bf4d6e7f8ff0c008cad9b5ba502436a207071f064506fba19bfe118e3f8602c763f1fce9f0e92aec61e17e13df5d582ddf0a0b337a8fe1c6b6aee55bb43e39621a5f39ebd98c2c832da1139c5bd041f559de9deb6a908dc8648b82baecbf1d134897b9625a603b005b7a27146ff9a1cbb35e2f807413083b7ff295e699907dd8e9c36d833ce5265dcfe976c47488df575b503f57bde20cbb363766ec1760338b87aefe3c26f91df98d998db92c47575f11c1aa8800b87cbf681534ea753560a224668d88a12c7a50979f3fb388fbda08ea849064d89042edde209a27998db8e73512c43f0c3791ae9f258e4e86a5f536768f2910b203bbd1b72aa936231ebfbc6ba690e0608909630c05884d3b63447dd4df4da38ec856665453b2111835a3caa516fa822b10fba2336e60388da44dd0968f565466bca3c8e68baa3e8cab6f96e9dbf1e5fe9307dcfebdd0c9da75388a835264141d842151d1c12ad4f04574c324c60f1572eabc6921d3bcde0c2e44ea134d750a3786586fed9152e711f72cdc0946285ca5d705727b20fe9a8d7dc6e02916386b3d9ba6ab1a192bb89a9aad619b9ec46e4f724e4f6b02ff8812ff207d0a075af2a72a5b052732a0e5e262b78152741c390963351a34628217fe217a3e16d3f39402da0f2d74767948e048905ed4096f0dca0d22574f3543c28ccac025bb196508ac48dab636af4ce5f99c0ea442393c1da684eaa6c694722c0b2dc497fc69af4c3b011fd410246c443d37efdfd99b3f07936f8b1895056dd881c74e7875e390bc04f7a51ea12dfb3130f49d4f9f4bca6bee397a1ab6f23fbfb9bb71a747158417e7da3c1226afcb3f8c90f39d46145fe23897e067eae8c6c589023ef8ce61d93e8081d44199faef64604b9fc85bc5d5f15827d7c667bf5fd8cc9736dba00f1e0cd29d0cf7973f1e72cf6bb8f8cd4c0bff37fcc28df910e6ace2745ef0ab50e5dd1ec8e901aca690fdfa96dabf6e449637247ea23db3bf17960558026e8db1a9c42b95e96af90bb0aa6b15c7342fc4d4b0739b72c2700dab420f8c6e4104ebeaecfb126131375a102106c7bda480f5a2e556bb6beefdf7b4699bf0ff13f04d6d40656bb38a34601e1b1c204bc0c9ff02b406ff64f9e7c67ad9b33fae2283797200ca96ad19eb36c4c5b16f8c0c0d6f8bb68554627d3f66abe9fcab8d3050ce23111783bde9dcc005e661a69010ebfc3afe95aa150cedb95721d9b5f14c1d67a827b31a6ae4a3723f591637226292da3e02b2c188c2d356e0f109214fcf5c6b59c86baa2ff0c61d826fedd5c453404bf709cf615531e6d09f2852f79465e5648643f8bc60a100fbf86e4d0eeced9c8a5165957b2d2904715575a3c3eaa4da6fafeeb174dc7b83208f7bbce042f4a9842a572bb4a61b121427c4821139c3c77d1f77503fa2b81c6ac28566111a53008a16831eac140c2a05652865d2948f88a2c2d4ec32bd9629a7a4fecf4f7d698d82b720db4ecdcb96cb03fbe790ed15c59eff39b05aea1462ad5c0b4d7f39f77f080c5a6c9f33d1606f04c2cfb95a618cec6b6c64d22688bdc2d657a86bdeb30494cc311ba71f2654da3b8738a23d6f4dfee48a5b92ad40cc2e54e9ec0d84da51d2021767ddc189e95f4c0d4cffc87d54565d3c827ea226711c8ad5071ccdf7b36a48d7e2c0eb37ca22cc5c0cbb973d79e477399ed19f4d21f1203138e09b28758eb83bf6539b16f79e6c1a194b801e02208355728d2e2074ff360a60c9d966f4bb70ecad4bc0d8ecb415ba7a808442392f9dd4cd7581e61d77c345d8ca835852e380479871ea87eab6e0aacbac4d332a5a8e017759ef6a2b1a5d9839dc4af24e23db2a458783659747ee275c99bcb30f3b2fe8538c69621cc5823553f560dfc8e5465c1e552ae3d18836001a940557364a5878efe3c0815da30bace4449334319ce8667320655b71b7dc9478fd669d03855c3b97bd9e03efcc09c58f1f73e15924e4224234dd607ae976eff5b5bc167a4bf0c594988cee23f195c588bcd1fc9edac73f1ecf54c2e85aea0993e6fe8cdb6d3d0908914365baddd4bf4095b5c90607c94f8cb271599e20d363252bbdacc0ac7fc13ef638289222f1885ac4633e0b87c1d2260b5ed57d21d9251d49df3f1a1b81acc7f2b01fb231e90e42d405daebcdc2fd9742472bf20bc145cebc701a8b2056f81cefae7b2a6a89f94c8e3a4e9ca9ed527395ab7c3de5c2f3a7f3d3fdf7102c76a209ee1c91eab1f65c6ac3d73574a3f6ebd6d2414926ee356ee31c681296fd5fa558ed607873448eba9debf6ae4fcbb4cc69ebe6a3c96392a544001a5b2dd37927d2736f2831d281fde5d6ffdfa902607ebc2f75f3e19be27a3a374a921737a576ef8ea5fa2a47f760f3cc5c33f223ae1bf70db1fa0f6ead2561cc9bedc2984e320edf3059afac5c757ad36237bbca67d317f8bdbcba9fa14d90bfe8c69397e71e0daf251e07a3f0cf3f45510af93df38880887ff6ef054969f21de031cad23e4b88e7cdfa7f4b3c36d4c0456ca4694c63d1b469345e0f0a7aaa560a1be016d979c7745f90ef53f9d624a954c07155b787aa42fc18a74d933aae3e3e6076739bed22046539ac9c9a94e490875a3019bf5ee2125d2524955c148e34e99b77e66591c67176b3cd8229305a0a4cb5bfc54ac786f8cd7d7c3e955a7b093a3e5cb3b9cd655609461f74e9c0adc04fe13350e153913d54aad4080b537aa5701f45a714c982f1b7321f68b3222981cf4026647d238fd66bc619a7afa63fe25fc02094d23664ac94dc4fc0e0d36bbc3b5da195c9bfa824bcd354a5b85a4578a3238683db6640e25538c86c0217ab83f9ddf0007d8da4c59a1ed2033f9e458d016592896a1fedb4596f90bbe859746230b9fcb4461c1ee97f8335d6da253713a1008a0c6b597b9a4e6e3ec34a13c76ca0f92912925533e6295647abbf93372dcf9ee42e8021fbd8608114b676a1960ed2baad6b9d71f9b838d669024c54f88caf3ee0656c448c3424cb085ff2526f4c788585aa57f97d2abf1bc53ba246eb6831e85d8ceef5b42083304bc9b41d0b7ed49b5c06bf038dc793440a3b632ef0dad94673ccbaab17a69076896444cf3f783bb5e8637240efbdd9f8ab3d3c4c105a4038a00506343abe5ff90bb33dfe846517b80c5d24b65dbc314fcc0efd76eaa01161e300df2ef96edf3b9a7ef98cf344169676b19c57057fca4c940683b885d49ea67467e62aafb89362fa50f12e21047459352c47ba482a57e97fcd2cdf36edb7cbf58f1303ba9c369ed4d041bffb2a74b9d8a0dc5a38ef24e57eca02ba85e317b11875a6417532001afdf3f89f353c759a191218465845095eb85170a84bc3ccbdaf40c654057f18efee96817f55bb5db3ffd8b8c526804367967da396afb5cf928e81facbb11c006f24ffe761dfa2f0c502e37de6e100860335803c678ecd4607eade4a4cd6d73e02f670092fe688ee6baf48efeb10605b52c0ed21550b0a23f5a530c1d8d35034f25210040d94633e7bac7c6e58c30aed6aacf49ba8d13f9ae866a7058261ec34651e0a5c4c977c72435acf61b31b2d398c8a99b8d08c553506b698236e1ce06b90f68631debd5d832ba78591de9da5e434bc5d1bbeda3bb6b362bc9a94fba9fdb1910e97ad0f2d5131d127b4f99548324daf2c1c4dd7ab596e3b89689e4eca28640fdb6a1263fce81f23865220578cf8d74df99c12e6753a1139c6813ef47b0e7d82a1b4ee6558eb32cd9b229f77f428a164557488d5d24331b32e51ded1812e33e02b8b3d93e387dcb949ee6a96360a32fb8b3356da3e61e292dea832f15df51ac3b67039cd5265532d910ff001d95553b4ff05bae856aac2d8f8b5c36dd17610b9970fe86f9426da501c7a4d4a5204fcf15067f325028b54af589be4c1a725039bd2797f29e6122743b638a362dc7b1a776564baecb3762133f140b0fb6ba4da59800c8723d0437b1c4146800d6c83d84ab6bca8ceb7fcc31b8df23f659e425ceb4d47f93705d89bf458a4ac8b7696581527f59b6bad4795667be2915dd814f640abb5b6434f344abe87cdd31eed3dfc1bc1779f54636baea1231ff7933d89e7e41246489ecb948aec27e2270b8415051fc8303a7394f64175b2e8ee65758f82ed915bd666b874f9bf265d437057bef8d2e01d72df54a4eaa855317f59b7201db5da639e36c7b2ab3150ca693c6198050a4b469627f42fc2c30fbba103423631f990fbba927bf673c41eb96391b684d596c832314dc5d9eee7f93959be6ae9d535bf9bd4b02bda83ff4ed23cb22c8e095caee33fd91e82ae812c7eee841fb41af2890990714d909c06133a61f57c69ef5d131decdc204fb28722c121e5f9b29c6cc0b81f3838f80203a997fc12db28ea234dba8018c46c8c99a10127461fa259d523a13b50c45f7027be3a88798fbc096bf4de68c74d45fc1be2a87199c8fe5aec98f71a25f5a3b42a2764a58e0475df5e6b425a9b72b16f34859bc8209c7ed3894f77fe0cdc8cee9fcbd498c1c14aac3d3548cefc021118cedab820c89e174370c941b42a58b080da7ec11b48e58fd769a54a792fdb3af857ddceacb9310488fb0bec7462e880027bd1fbb0a000013e5e9ffeb837c8e3342be6db326594667dbbc23eeb87c172b802b7d54abc5cf1697a726f084b5833b4e30635299dfae0d59783e97b230133d3f2e1cb25ed1c44f81c0fd306a6addff9bfddff04552044ab0928488b8b4a6a9c30b399852ca955ab3c9ed3b0939898f2fc86fb25cd63506d9a6a72347605f04ad1199939ecb59e3301059c8091b97db7526c928eabd561819f2134332b3f7babab3ea57c864d71c185aaa4253e7c1552b71f8a30a2211f68f6a5d4d0a342d730e6accf62abed5d059faeaca63c3a062c7581fac071eec618db8886fa337a5b6a835b995dabf912eaae7af8d753b8ba272a1ef34bdcf710720fd152c289ead9e61079fec2a773fa252817654666b62838869c8d596bf482b6432f90ef4f4c5973cbc69888661f8dd9825480f2f99213ef9857fb37994b8a5ce614d439218b7ca0b946c49536eaafc87ab9a08e9d032d7e4ed7ae99c86461d3e4eb146564526283aa62ac0df3f2a9ce22b17824e7ba82144e5dc2813fa389264a67368a07c34ed69e05a4d644d7ba87e3d47bb4a45e626384dbdf0ba5035b9e522b53dc151b14be8daaf01a507317f0c6fb3f4011610029107e6c1f702d06ee3fbeeddf404c551fa53489a056aede2922a327d828e5f23a3e6170035fa949bdbba60eb69fb2035aeed4be3c87f2876465c8c03eae5a01732582be1b87f4dcd04d3c2c36b74b9f05aefd332367fad832988c86b13fb45427dc8721a69f05f179fd6ee5d5e3ddb56bf6070a422851ed125ed20a92e059c07371c43bd26f183187f65c9ceb3cf242eda65b9bd09dfbf1a5ba881e42817f5a4bb9bc2f6e4529c41c70f15f8083559663e4669b9627c6ead45508a5e533977f6b554f07a960be036ee5658cd7916d4a7b52eb2a46263137b7b19dfedd253563f06d26fd7a566088c71eacf1a97d7a73fb8ddc1cedbfe41a94827ff7a3f2aa01b834a49e7234133f7c6717f35f863b2f14f60f669ca80a3a4c34434c88fe2e3efc038d686c21a7c62149988fe41e471daad0534e0d51a5c6049ddfb40abd294106040934485d31d79e43332a028895ffb315707724a94664214445b5f488561a7771b29274dc2bfdf4c52d773ce385de898afb4606f05da23fa5fb28ad768ddc27483ff00460ad2a5e8c2f1305e7d3dc8046b66ddc8baf595ae42250f486c9e89de1e12a67522f364d77176ee5ff714d0f0d8ade6b913c7508e992f758fafd38a0e544bfe034953c157d09e51656542e8c751e112696d3827c6718e51d5344f638247fe75a045fa020bf4de133eeaff5ffefe4111d64238cd9fdea3d5def79daef930fa913c6b20735db7bac476315f97e836679f066a6c91c5f89f924b8078cd0a70c9ede8dce0b58f056d7ffd63e505ef0637fffebea8388109c97d073af9df0ca582867d6592b80e3b5c58bba1935a450de00b89d93f45affe0510b9e2b3d8aa44b48d2daf09a42fd1859357279d329dfda2d18e24267d5d34551f90fd877367fedb5fda475e325e44ea6a7e3578b6210dd37625c5d66a21fb17f1566d32ca08d74abb2ac31dfb8bb4fe851f0f1f2cf45d68682254f7cd78f51e256c492b42171d514854028b3036d371dec2619574a55596c499d9d7ad9cc1be993abd34bd368de7978d98cf24905f4c1a02f1cb89383237428b8cbe2472cead6515a4949634f10317319fd4856ea898380d22a98d8812e906e5fbb57fa671c4e0a36c9285ac7b66fcb4ee64be34eb7ca11730a18d53a94bb0c1a08490f36b08a646d2487ba242b05f1a8d95a07927f17534aa1cbd69108b0449b2f36cdcfb9e14b52b6bd4e064420d34da820cbde86d010e1f00dd786e40556cc03924f8a9a427734186b0f55bc0103ed9563d4041afca72a8a7c6663f0a24ab1c06027b7a5ef75a9e7f25a572840750e455cefefc771c4ff08d03dbaaed3257ec0b74bb03e4c665c2baa59b0ea9ac43ff6d4385a22e3ec085a2f53a827ce2a589e8b6524bfac96d762aa81559c9425d97f0479ccdeee60d3378499a7531e13abc0318e6e70c990cd7c145aae76df71cfbdda0b4dc809763334879e6943ea5963a2005e341e360f228fe8f744c082b9e253b73a9138f32155acc7edad1e8d3940dd6234f8a071140b0f1eca34a4a20e96f2df43ae4d9e5eeaacbde344aa731ca5d3eec3829ac9fb5801142d9cad1d93f24458126e1aee969fe9005d4aa42514a159af33029a38c5ba26746d80322c29917a8349bb312aaef7aa78cfe4bdb342c710c9d7c854112414394b59d1151dd2caddfe3868f0da1cdd424b195821837574eb3fabeec8b0ed7142f1195b64fbbbf72e9d47247ddcea6c2cb12b9620149c8cbdfc4b29358998823dcd65ec4a41c092f82196482f3793c6c470c84d165d77980c5d98fbd04a1511159ed7ed01617d1c6da25c8db1b4fe34fedd8bc55916675fa733e4b56a6f5c3fc46dc5fb978057374c97d46bed899c91f1c94e53ea81bb4297cc3042b0f84203c391bfb1edded54174be3c8449b407acff26c0b412f235fd045a7c8bb29616b2e273aa95323a855427d4f9ff52ff94c9b86fc72431496241e3a07ed149f2815146284251066d122c6df98c1b605152d46ea2a93bcced5278e1f9c4105cff86ef867430a49fd0ea05009ad79f0255e8f78c00b5481433bb0d9e24da2039b382f424f989c0c432aaf14721e6e2e9cfc8f2434404234d5db5b35ad5554601e3c9f1be99682b529fede0120f3eea1b1a12f84c6c3d8fa163e3477b687cd146da9f2b0985856a4016e463b11f8cf5fe76f5170b1f3776ab3cf965fa4c0fbfb443df84de09cb8ee5f7dd10d08d003febac7efca3b04ba5684ebb37a885eae362143bfd06aa5ceafd0ec6ad9cdfbc7fc998bf53b9dd0913f18834c6abae87cae0ef9577912b28cef6f8eebff1afef98f22d090757d17b9577b01702327b4ae095f19cbd8e62444ef5366ceff34161893afb1e69505e9feb0d7ef353d284d2cf8bd562a9d51da57cc8545f9681b2b4f47b0e05a5250e2eb36dd7e6c951acd76a2478281b1dffed3e96db112d7dca3ec5e2a1dcad5b420c83896daa3f3298470b840c0aae0a787c596290ea3a29267ab4c8f624f3e9fd8c988a7fccbfe82b87060a71d52ac85e5bc4ca958ff61efbf5c2446c0a1abcb76c89039f25812038260a0d84328ca3db7769b7301a163604b54647e7c97c776b3d0064e5c436018e118bfc2090f5756f9ccaea9da64d468a437f702afa4adef6b96d17b8a7050b370456ba4ea34c185310bbad15d007086a1a3b7830229d06d335ea0dbeb858c4cc3efc813d6e8efa3379253defd808ba7de38c42a4dcb4b641a93c5eb1294a8b23af19c4806eadb0ec0c67c52c7cfdf2c21fbc664bbea9047852d9b57f2e7cb700c76c844b2a2cb6aad039982bed6085dca3dcee3226d4b09fc2093ffa57e08e3fd3b9a38b1eaae17c538d56246016391075917042d17b492cc0df03362fe3003d70ff561b798bdeb08c1abca94008420497692702a7090ec895dd8d92df4ffd7bad40e438f715e36516512692efc549373b12e2491382fee32672f27919de804204b8b8df17b71ce11c5c0e4380f3675a1eebb75c2c7672858afafaaabd4a8349016d420ee3ccbcb0c28e723854396522b9e6ec4057bb5806df529b37840818aa15b5518a68fefe20b0015d68694a2fd81a70e32063e5cfd9d6020ceabec2ccd6fdb3e204f373378b35ce41436b87d65b30818ae11cb2de956ecedfb0832f72719b003f49127549710e879c542fa13c885c1800f2d5ebc5aab80d90009804de859bcf1f2be612d30d368a0c5bf1e02e0f21c77ffc91ed38f035ca165f0903ce87264e5e652e929d2fde1a4b0e76c05a7824b5b0aa1c3b653253b03f53698f4208119c0841a3cd6e09585e2ba9156ffeca03a58ab00ae28c43df9248104139809a698d117e42","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
