<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63e9bb7e1fe1bba0254f48ca89379c1b49d3e27cbca75ec68346621ec0f4eda87ae748a973550b1556d59bfaee09e2118a767c66f5423e3e3bd46fd2dcdaa9a7e3b8e9aa692be6c06c41df530bf311b76d348f50d5f610841524606ae0df61cdf0b90ef9f93aee845452f4a896608cd2b4268e857c8db6b10b125382559f50ea2a944fb50919414844ff653e33c3bdf763c80b002711d6314504abc1a7a18c8b0bb2cbf2293b62ed83143217e392f267d112a10fdfb45540089860f54a90488ff7587578db89cca14960f658713ad6e40320abe6507b2d292470f79428b006bf57d1fdfbcbf387dbf6e3ae932ebc841608250809336dda03f5c5a8923bf3973a4bd656c0ee4884485fbb93a7080628a495fe5862307e8f40a5bc082fd3469da26299f203ab747f36dbdd930c0c5abc5637dae26d8c507935db589e0b24a6d877b8ca8feb09b2cabf3c2813f124bcf8b8a4ea36772783c7a5fafe4e3c0018307e359108b1b47b44121835bab30e60ec54a00d25c5bc433acd1fdfb9aa85cc9b9a59c198015305302b2281efe4c39fc89405b7e2426e4f88e9240caaf9cf19ae57f34f588c9bf06060974f7888ee11d9411465130c62e20bdb61c5c37de54f3623ded10bbb6f3a9c3efebdc26a06aab82643949dd00d81a2d96585c2696930194d12a75e7da11e9d3da3463cde4eb97e61ea9d624509283ab53a3a88d596ff409b1fc4ab61cbbdbb467719d10a2cb82bfd104b50437b1e2900c9951e526b0d8aa733a858e0602d0f211b90c0a14e99c1d6ae405fc60c316e6ec9f03d52921494b438251b0b92cb42f95986a4b979287ab8e105210a261a126ab3f5c2d0f26370e622c70eb4c13d5314412ba03edfc726a08bda07819227a0dd2341e20a0e333c04e63a2eb3d73ab1bf1e9f4c37a9603b9b373e6f527ca2bb339df501dba27cf2550b7c0ec74875b7440004187623c8c572d08b2e1ff776a65f45356d4beea39903b54c27c663da936e9320b2b9793d21e7f8bc1e6cce53df13171fe7a7ebdf23a746f4f384fc4f8089534ecf4ee61560fb1b3edb6dc6129d724d71a471a881ec1e9527202524316baf528cca4c8f305b8dbb80dbb146194f4cdf4d62d6916bfa41aad6334997158de5c71960c0d02ebe6f4746acae2e1b69b2c1ba5b8e78d731b756136bdcf2e4a2e5fb901824a6230351f1e5f333c56d743c11bf6a2aa8789251dda0fed1d205e9c6fc37f1165f664d10696d90e45d0eb07e081696c076718857fb4a72de22d893bfefeda0113249712763a42cdd6d3acadeca50d547106fa3f0ecf25f95934ab5ecd9e5e0acdea2f33742733d2c8f9aae8066670baf700f023607f1c71cd6475cd784295a034f4eefae0b29b59677b2c7cab0038c4f820b84070ebb9c3ae12c7b19228c3a5b2ce6bdbe3c6add536200c3065180ea9a4ba3000cd2dd05c09c93beeefd1b65763be3ba7cf4351ec9b28983131793c64a39e20ceab7f3720043bc50557d7bfd102c2e9962444c1c881a012cb15be96b68b0af70b13030a7e599fccb62a7bcd7dd39eeb45574d99b3b8f9ab0f4aae02456ffc234e0e419dd975a3fd48a6d0dd08903fd90bf678a1b23757d90fbbba67b6ac3f9c3f35bef0166642ef4a3db0dd6a2cd90fbc348874c57c4f98679e9f4c1b70768da59f0839dfee061a7cb1d07d3946b54591c2d4ed0956ec20cff3d99a201f3d5928a3d5122ff32db949424e39a0b91ca008de5ffa5b4f154abb000ae92f56060bb5fc2c7ee594fe2969ce57443374ca782fbe0634eac8afc59c2b9d528520870e18ea5be58944c1a021f30cd73ca1d5f8c813cd3fcd201d192ad75072c8b7e387aebc8d5228fbaf5004e886ffe3f251fe03ef0e4afe0b6b4a78d8df1f4326fcfda04c053809a9d0dd4122d708abc42247ea27b1b42b9b00987ed415a2e1e45b81b0e0c61480ad7390b42957ed8c116afedbc7ecc472ba2d1dc6f65a562c1d3ff2bc164785cfb1679d231f9969696f2f779b8e281deab21c2340536ac91af7707313a7efcc4f8c575882886b52fed3bd3dd6631464e23652aa5e94ac07c405c05f91d02575ce051e820b11c6c92871d80348d46264d348fb505578c4821266628d0aaad8ff01be0924f4a67053b71017b300415b0d0a1f8bd24d63766c79e7d560f6b7770eb6eec1ec6b499e297a7f4139378148f909b6e985ae0fcda0b8fb262f2c38f15c1f7c71f92bcfa15f52ef5ca1540e3d13485a067369c5ee24a810ef2b83494d010c9149f721e0c9218b3fb8d140e0ae6dce383786656b27e5bda83514e724f664162a0540699fdcfcfafa6a9b055ee6aa4985940ff4b637b0a995946f97302bd4ce451d0323c00628486c116600de1d16daf65a24517cba11e83a54443f73a7eef1b4f346d622e495d3744992a10be0e805e862dcabac8bb292618af75982bf5e7c1336a76f3fab4998ef90bc258ab39f12cfe40b5c25ccc81d1fee7a8c45d69ec3a292645cf8320698f3e864023069b2c77a8194e64015ee70dcc5b42db3f5316233022873da9857e6c8f797f6ee19ef92f1c8ec19a5be2958d072b985c529b781179fd577f858db616b07c6ca17856d3beac1596d50b8ca486b79c516a1c2d09139945e8d967b9c7e664cbe74d107d8e0c7d7f6e0b1e573afbf0174bf08efe77bf1a73cdc96d1df6366334ac6c5189f2cf3eb89ee9164583e695658b03f78ac08b9495eb0dfc55db239be7a019a78ed1191f28466d2ae9edd295dc0e4485eadfdd3c40727dcf970b8c16a08f2832d6dd53ccc371b3a4346c3433bfb6d9d805ccfedbb9e6ad0e2eaae1b368d427313cfad098d5930c0401728fcac7a9e1f5ffa026b241ea01c81dede691f16cdd6b30ea1e1dfbd5796eff7f944afc76cbd4c8065218719a4082ff1af5962bd0dc595ceca254899652bddda4c844bfe8436b9406e93a5f42baedd910bf6c790085e2625b1435f3c9ba4319a3849644569006cff86fe6f81c71bbf6a4c72fd10423e78158d8935e3ffafdd2b25b03610292780f9a82f9e9ca4dd830796df23fe44879829451e1f5b463a416ffdc070786b6117260321b872c613d669311b3f1751c52248ec28eeff3b44108c23e2aa476df0e3423e99e7590660ad5ebdfca5e6d4a2c172f9a42c1a1e3fa5c2da3072f0a0f10ba4ff3dfa9715a91128768d364058cf8acdc1130da797b218963acd94fe549d2df37009491826377b950d1eccf76df92f8a380512700c9925a20cff3361c85fb833d2e3d9e904aa401ab0547c74f80316cd2068141ecd25f00c9e05c37c5ce72a28f03f22167c52ec1089a76807e0c698eaab0caf7c6ab79142d9e664413beea3de55be7b285157994494fdc9e35b2e168559101ce59a80486f0f35d32f9cdf697759b683bb786285e039411403b1abb78ade2f445107a93fa887609151e5b796a12fc578d75d019399b123f78dfd3f56f644661e71ad7709a3d1cecc25e84e2e390e887ff54f8ed9933303bd1393b05cb1845f637bf2e76278f5627933a4b852b4f9667a3c6a57486c776a12981756143fab87a9a3be2479107dfda5353b84299983356e85e37187e2d1029a4e8f6afa033bc06d7a87967f23465bd07163b9a6c26b128ccdbad1ea475220b0a701e22457f7e647b4b8ea58698df2bed51a4048c1200504e45e77755f890cdf70f18b304ac73d9b37e3c73e69764d480af9ae7a4ddff16a99eb695b27d25182f6ad3eb838dbdc86764f934a604996481ed2fb9ce65b1598a6790f3b051ce07c9be5d96194cd3ef4f4a8f1b0d6ce6a5793ad397d45d067acc05a4a5a4439932dfce427282ea88013ccd09d6e01426834334b301c694f40242835c0fdbd9862505319d9e94e96519fe438453be0b7f660230b02c2ab564c537deccd8b2754ef687f7d6f252cac1e56858f14fc2eaf31b1e350800fdb1248b14e84476d7b69f1c0085a96bf90337139443eea30b0baea6b93ca5a10eb2283f9ea68d8358ae3e78988e7f206e0badd47e8e146b66e9421de40c35fd8dc8f4b857d0e500f833004f2e841e8ddb94133c8b38f66779044557ce6efbc443941edc1f24339b6025146fcebd656975e57c2bcae6b54fb0b1b35114c7ac25e07fe5c08e2e23df462734c4d549a647b49c8a46e6633a937c24c603555444daddf56a969a5417c79b5fc0e62892e49ad89ef6aea12194b4874c72409d74b1a838dd80140cfc429c3c5e51666a09c651161a9c3aba4a46e447e39e0179b5fa2c10e0c4cf238a7ac69882f402ba929740b7631d09e05f7afffc94461aafb19b59a82fb8abfddec61ba1fca4de304e625850f74cc73e15297c6a2249516aa98fe2cad0a9b67c5049276b95503b4d5f60c6f1a7264874174450b523857ecd429a9238bcea9df7b9677e6fdfff10dfaf8b4ff1a4e2a16072e52fcd2b876a98b6f34ae4db27812ad847a9b24365cbf23eb80b1634d3ee1ecb47bd05e1fc8207c58eaf92bc0a61b08023164a2494e54b6d5ccc09ad41d3790c6d7b5facfde6c5e83bdeaccb9c7f8f2045a224d94b2f23321d6f728ec94f9ac07c33e9b40bd1213d7030a560861e9ae34c69a67376ac556fec88533c2678795ea55842cfbcb718840430c3b396a4578b00126308fe883b81f802b8d15393a6827fddaff33d37b0f4d84730d75f224f032791a42e93742195db524d0f3c7574fa78f9515aeca42add239188aba7f69ed38fa8dcc45044cc5212ac58590fb462d0c2ad8237a17b8ba0dd73a882f8a02edeb0d5fd993aef5a075e2da126991394343360b9205aa372c6f32b875a664eb37da5949e73a75fe7c6c8d80aada77757bca234b02ed08d2f56a55d7e071866841a6b75e7b331b7f3da691c0fa27191b4dfde61ca24cf6be4b7dc82872e9c1f1c891892a915b736ecf1573bb4e4b34d73671e25485581b762cd41efa1d25621607b8532a26a6b33edebe437c88dfaa3813dccbc68eb2608d96c6b79426f1315c9c2b39f545a85dfbe88b1a0ddb1f262bd30b8504de4191ef845c5de15dc91f809577e8d134d3936ca85e79597716de34b6246c77a41640704f810708f30e5b9249fe910f628f26abeac0361597638ef29bbe004b8083e15d2cddaf6a52eb8bf29f89a31120baa73721a4cd142868c8b920a9aad903f2e85fedb4f41b9179a0a3e813d18a0cd90522cf15d0a9677d3ecc818b8d4e001a0ab2c0fd88935b2df84a091a1116dae33fbb0aac8b701198a345dab28c929e9bca92a14f0ed6a8336177ce518ca49eae42b74cbabe27ecefe0e220bdffdf6a01d708290a7efae5835cd19663b9432cb013ac0f461904757a92d3922fca14d8aa9aa9d5778f81c2a95a5ad7ba52c2bc1e032bb790f35b9a2c6b44dcb1103b6d292ca43e39a914539e086a879709f7e4a31b9fe9566bef8adeffe0884180172822cedf1c09891c3892420da330591ab6a359293a04848b523913a372ea78f2a4847e3f0e2d2967d3931596421313c41a47ee654b315add354c0de09c16ee73be59701ac29f973af009ffbd71e8b559859d519303fb420df7d429ad65720d033ef3328aac8b13069046c74306d66d70c554022921dfee2219d8befeee44585d8e792c770a90eae89e81cf7eb556d4a5337aa3bac6451053353e0982f21b8e4b959ec79715068958cae4b78f754247bf40fd40b18af8d53d1c0eb318c02cccb28eb67e63ebc533e843bb65347e5e9e5761b106c5aeeb2bc0f0b179231d16e2ea4f4b8483088895041056ed03d7a4e57522ea01acfc77a1a974fba2614920a85cca6daa6339e7c9c225a3904811139d19307a7f47710b644b7eb308d24bdce5f8bfcea8f11356d3ceaad824fab9984b5f60f27aca781c76535d0a8f1d9339d65b57625e94fa4caa406fc5e51fe3ef27c01f361a3a12bf85e06098b15037d5000c32032f17d6157173d0f7ec9fe057e39305b787b0ac61ed7102ddf9c597c0adb5c0014b41e7c6f66edaddb57dbdca528c59c0354b96b73a61db4568769fa2e2cef504db33490771aa0ade588ecfc537aad68007b850270ead3d27563662fd2e1db40458bf9af03906d94e03806e17dae16c7117b02865249e871282f4cf196adb893fb2f22d0c03ff45c6c598b31c480ca346fe687280a434c3d9fade0ea480d90b8c0fc790fd43b1f7b2bff6efb3502231ac48b5fd42e36553957dc1e9b444529c49f20cfb65f97670662282bdbcaf358514b0e609c6b9dd0e126e1341eced48ab6b59c9f7028cb6d96f5a24fb3158229f933928d5d1a5810cb9269b1ec5e064eaac656aced5393c25cd0641b68ec5eaadb3f7becd306339d3f5b7467e18002e54f501f96d672e14cfc5a28e54c1ee057682a05424e42782e491d246accb7919447d20009414444b64bf4233ca07dd1a2e63bea6c43a9aafccf7f2715665eef36a6158ef215d06d45980428dec9ba82d24c006ac8494a8916cff307b8e68e6de6d7f943a2c398f8620a66d5d01ab75bbd20957adda503dcfa5da0bf113b50cd053619e8d9432744c6649712ca6295517eff1f1529f3ba6da2afcebc503acb835dbbb574a8e2cdebe1205d210c7964dffb36f0f0ff076dd1ea01aab03c03b613f4c50d8c8e7b560e0ac5aa7f4659d8e891540479731928019ca8ca1b8ad9ece756f198b03e954edf38428b2a3ec769be19727241cb487d9bd541ab03a11ebebeba2ef79beb6d43896e79de62662ace14aea274d8cf68f0c4e6d92d6e95f8715a5574656bee812cc867ccabac446a9d867ab57593a5be73434749b97182fc34d2da5fb6e5213efa6ea264584cb7738a0e36384ef70bcf5cda117f7bd2f3bc4200916938a0a98edeb5ba1597558eae0d4b9c4c050002848c2cdbd0a5b441ed49736303bdb682150180615998635b33e0a96c2c94315cace8487c016a08c80e65e63163e124816fc6eecedc22cfdadd338532f84ea34173a9542b68d7813650685bef4f617503466ff075157e87301ce9653ec224d455aead37799b4bae1657d993c1ded74ed109293adbf93f04f854d58df1a3a673a3d0cc595127dc89dc1bfccbbc2edbf2089e43e4e67b51f6d80b5ffc50bdb1e6a18a94416b8fa02ab48a4be87adaa81a1454c9a2ab86c7ff14235a0d735964523a18a8f2b2c3dd693e543a45873320db105aceca2a9fe096daa0d436611809fcc524c40a90fdb99c7f44145f2a7d152d9aab2a4d80c1ec448f07d8f65ca9f98e4521ede91f05a4d7f1281fe44c4a0f7dc6aa8ac17b3a5895123294cd5c735241a2e7c9bc762da81a101d33e1557b5158bb5d185e0487143c5fccc038fbd878bcfc5152c20d63cb749b7c8ff1d465200cfcf0f666b47cc1b7e5bcbf9467c244a2186184b52cfb7810b738ea87106370bab0c0f66feacf466828178a76283b0617592c28df8bcf385e727a38fbd8eccf434b77fe0fa0b9d0ddb20e365609df958a9868b70286724379f8960317f463701c226348477b833d6bc54a990cf3040cb9b1bb5956141ee6b1ffad72c487496990864e29e3da81ae4c0f6aa34663245e9fd9219ae565ffc1a4cd8448bc4eecd703110cc3c4957e21f09ef7e8553474c63c3191db7ac2688b0860bf9ba99d85a7efe233fbb0b6b8d0105bc04fe80cb8ded4d503f511fa6b15f15a07b9bd7391f94578cea03944e0ae73ac2147d2966778cc51508815c706b8e13d5fffe0dbe1ba9299078f70860df7b4582552cc15142b4e4ad9192fdd3da62456b3ef93192a8960a27b66c9b3fbe487c0be1e3d6719c956cfc7fdd8b51843cf94858677abc2cf900ed6c52d0ec907ea313c39b67c8bebadd57598bfc48f38af5bb0d7babcbb7d4d47a03a68011d57f61b255d6b779ca00e1cc963386007d3ae262a8a34df33f89856a2ae0bce51845e54730f4d8aea48e9b3a51e8d624c74b9cec6b44c0e91bd7afd7908af8dcce2d7f844cf0f647cc3a6b192734a01cccab6e6a771e8da0e271bc813d9b64b16851d27ed45c42a9b4261d5ba0e0dfae730a2f9f6ef56257bdfb402bf20ab02ca84c4c1263587c1daf593cea133765fb69c17ed4f962caa98daacb855e038c16cfe58ef39b5b356479a8e06b6291044f6d475b9c996627b1aa2efd7aeeb5b4f26704eb9e4f66c3c6660d8943c2fdda9ffe9eeb1657e9abba0dec44ace3ca17cfddac8180bd7ac0ab7b4de95f3266410e554b61ed675a4acb576fec8b22f3a409b4185fb020c8ecba9c76f2f4eabe9ecb732064649e92f9be7000434417ca06586f4c6ac0f545b13ff27e86c9a708ab3e62142a476f679fcf4a37ae474441705534985050d80f35d80ea91a900b4251c803398898b6f0e252550c80b5038af3fad98f286a78b0ff2928550ab232684a2e4ba578a1758765929ad054601985e7acd8d1e34ceddc37f6a52ff39475675bbd225b770f93fc734489c71bb75ba6dc1d4ad09764e28a04f2410d280088ff8fabf62ca09f8f9ab319a16244417abfd00d7a2e3dad9dd5ff4280c0f6b1f9897ac941034ca6756f77f51f6d628da9245b748b1b41cf9d3d3c7bf83962e54abccd4cabe00d22205101e48450c7885bc6764e49d8375d02c76011fdc8f38efef25f1812b34b4057ee423f7f9690c010facc3a7caf8436e8ca42c79e3f5072eb3d90e0ebcfde6d6845f2e101aa7237edd0e5c8f6af770697e0a74a21aa22231658ab45dbea3ab52af1e21711ff8f0cf510dbd1f2fe469b94933e1f039ef3dd862ebdafd4462adf1598fc2981d24dc4d53f5c4c17702e06039c78042e1328c9863e9137400378a5460dc84d2958121ee7520611fe355448544aa68a3f676c014c7e0a7f4e18caa48a8feb055467f26912162bc09c64a6c06a62343750d5d81e8ee50d96dc33d92b5a4d2c23e6c820f782f974cdc0a986b86ec91118e6efbebd556ae51b56adfd249b691edd0bcdf42d084b06b6577e8312c1e0b3547c9342bbf51520e7c108cc8ec4dac6f9db81fd589d0cf95c3dc05d0f39f2c18f8fe102dfa604027713cb519d58a6e457e449b5e6ee78d72c395de881a2151fce8e0018c7112d2b27dbc316a7800899f3fb2b46e9693538677ad0fde86be9a6d4873eb1847fc6d8079d3f374cc429abc0451aeccb37eef7eb43d6297930e34dd90b0a7299219c45f28064fc8c7bf34fb8a01976aa0c340ad8771fe23e762d217966af7384cd11466e39d5a9a76c56dd600d89b4da7083bc7afdd12cab2c3f90bcbad83d5ee7a2803420ce841fca5c479a3b749b6179cf3a00cb796e1dae5a7cbb8f4edc024c0f411aa8bb39ec2e56163f5bf32670660106565168adae8f90b1252db77fb4da9d7a03b9edf00089add080a6cf13f64bf64de5825bb9c18dd644f91259e2608da83e63aaae5610e1a07607905b2c34a028268dcd292c85d0f0933d21bec3e87ccf3e9685d05d0bd35d474406fe6833e90ff342b8cd2ee2950447374e661ea2eea87e4a4961f9bbf77f1d3af5c969844aa1ec619907d54a72791162f7bcc0c5d13bbcb453ec53b7c050316ec0518fafd752757e2a9008c63e0f7aa7ec1485a31e7726c6916e476b55f5fac06c68a52a8ed93e295e05a54d2350878c970aba30b083dd3230a68ce7b07c10e004a3d603e75af8a9f072acbd9dc50d47df70ea1e8b6cd1b1b76720ae9f0caba1e21ac0dcd9a79da39b7b7ce2d62fd869987c7e0fe105417d056b22fe3dee73e5f7ba0c1e13880e62f3752344286f6a5f2d1cc97406788b9a0eee9739063c6fe0351b8860a50c46e9dee6774a224433cca47c476dbec2f45d8ce2c35a896b3aa48ca41a8f2f966b101318cf2b4eac4de8716edf9749f73209149edc01f51516028e5ec46c168fbc1ea21fcae59cc0229d89a61e0386f59cb753246666664bdbe937cb8a5adffe338f8fef158ac6f47fbd83db3ab5e0eb4cbe143e30c63068c9972f2acd8167d3de211d3bd779e1ded62f6375628f423d3a16ea1bf56346bca75f253d4b93ba3f0810c475bf736e8197a154ae12724ec02f529d67cedee2fcf296c48cbe4821dc60371a27e96b2ec14a13964e118fc6cc12a4b05c889332bdc9b8b589644c7547a7608c0497f9b7f9e29bcde63760c956f0c415ff3f7790671bab59c5eb2fa3d65c11d997492546ad349341c5513a847c95d041a83e0404f59cde653d3dd6936847e26ad6ed9ed4ae1cba5d02586316d99c5c434b17f9fae046bd543f6441a58a5907e1d453814f2de2f3a3fcaa394bb64f74e9925eeca680f2ca36ebe660cd3d38d2fc60a11bf4ee0654239c994032a3aff9a4a6d704969d16b64cd33514567f0fc294eed9172c8ce8e7abcfb98e641efe7f34c76cd4d880839abf434f9de1dd438e32bfc234079d49a58313589463f7fcd12a5957d8280e2ae43abf5e559d31cd51469535e1242fbf86b3690c2729e197aebbc9badf4d0f1a9a6ab7cbffdf3f62fa9cd6cc34558f3234921c774655c0ec6d2f4c5845df2c28246bb107bef67d0e13b527680be5a1dd952403be1ead99ca60769e586342845f1d3df4a384cf779f4c3fd50b3b69ecbd0e9e944513309dd06dccf5e148f4dc52d0d9311623ed5d10c2189fd9387ba5357d6d58952490a169e04b899cc1fd4c7e5e0a94635e4a65f71823e54c57977c25aeafad7ea403c01bdfdf242da187e3a74200e4dc1273b783e023d7364879d0773675284dac470385a0f0541b4001135b9aceec1063ce572241801d43d6a591a67db4c96f3b83293370c18494254352e6e8b5428cfdb9b7cf1d865c288aa78739e144cd1d9190a8fef4f74d2f629b39f71a5f56c3bfdbed0d0e89ef5f4fd92fec914d027ea60974c80b70ca15c3c82928b59699a2f76b836fa18d235acaddef94a88f1a1cd83b8c65ae1f151d16c59ca7b14042d15b847af1b861cfb9c66da4f4be31f13a25720e547b89ba63d7622f556e1d3c1af76db7d507232160c6649f4a62f5883541fa5375ed6ce31962c030e7f8c2e7dea13241d9732abbf6d6411bdf64f062c876f7d08a6379e511a8b7ea3b4c7944eefe28f22c8eaa63d44f87fb68e9cf765684781cb32a91e22a145ff0e61096042af8877f4c0969969c1531003473f2c4675a40fdbd386a6c4a0152dcb657413bd94606b3cf2b9f3e4ab7d468b6b28eb0a5121ff41fb9d3c9211603b6c31195e3e64ed63359f6318f33247a94f7e850fefc06c395ee7fe5b294aa46df98b6469449c738646591aa2232d058b286c3f48599824487a5d5ae160040532a3237bbdef78ee13d8a94dd67cba1cf749545633a8c932af66aeeabc16a8799e6090cd4c372a520f8b95e247958fde61e13dd8e6082319c3bcfb4ac1072d4ae9712326220ffa9b099f70a927946068d6270c9ccc4a32e0c0851101cc4e278cdd7feb9e7270a5c88228c7650933009a6e4278e515f7fbaecfd82fda72e195153136ea0b5881dc3c21ac9a668db544e4acf68eaa83d2c95c1a470dd6bd2bbf0b6efe77a656a10cd861e2c0fb0a1aa65df1e602b9c3079cb0ef1226d2dd81bf30269ce3c6635dad4730a39837b6acb55edc48c74053ac756bd4cc47ebfc4bf897952a4b2983aa5daa7adaf1405fd526d82028afadcd1f318ea623330b6bdf7f5e694b39c9016e5f9ce77339cbd220d6ccd7d7d3d5a4477b55f8f8b54038bf783aaa9fa4e3cdbc1ef21655513cdc7ba9c327a572969182081a225551719a102a203672fd995a49e051367d8426e374f87456e04af5f4e0f9349bdb864a4223bcc04356a0831ba1f60f1da9fd228811a3c02dfa5baf57c6f67cbb9ef26e868033efc02afb0d6dcaad20678be5b15c8f7ad0d2a72bed475d1053c3c137baf555d88d0f77bb7e24c1ea4aa34dc608bd2ea30f070fc13f28396762e73e468c779b391357abb372ccae64b9378d66fd2b28e58bcc2cd172fec72c4db91d01e5a58bd267bd19421e7418bd3f68fe24035c43645ccb45a44cc7cb916c98cb95cb9a1cfaaea6e93d75b26e2f51bf288cfa482a0de6d17414eb2adab87a782395efde1a3cf6374929008a94d330794ef36336427b55c31945540665d53a8511f44e26bcb4315380954f07b0028e61a66d9a9faaefcbdadc11e55f932f3e19b23bdd31a8b5e74f76124fba8aea731e354df75613d4695c3e9e46206c26639c58715ceaee37dad40c1f7176215233389eea84300f961c1f7c19ebe839dce64392f360e45ec1fc687466387a282137f68c2a710a7584c9df6a82262ce241e820eadc8828ed75f8ec402bcda1e5d75ede806868e0c079758b5a6b44aa6d793aec208958358bb9a979811706b7b7664fa5a7690559cdad7c9eb04b12a04ab17c0e6706c47770c892c51d055c56bdb4389e15e9f4f6c71b4975e62f42beff07d5bf6dcfc1371b9be3f31cea135b0d8e7fea755412fe19fa32e90c261c98e52e7904f10fa82837f51300efd0d576c446e9c6e9dc30868e8ea176414be6f5b2fa81de91c30718e467ad112df73ea0e51b3f222249c0e82e4ea019a19957ccfad1770eeeefd5af7fd4617afe3e7c8a71585715b7cd7cb13f39e4f2df41049ec6d39f54646854e869886175076a0cef39502c5017d7988df80a39589869d32b995676d250d34ebc860aabc0f0c9f67cc1cf586a7a04a37dbe5b94d486fc7fc2f5a0bcfd6d29081d9e43a118fd652ce8c4f5694b5461678563ece11720cd5c721a17b7188b10b85398c28ca6f9bce9d3030b53862bf7d4b4c593ca83f1efc3873233b8d1e8780adbcfb40f12426febbd5300be968bf5c1720c5add16270d47513610354e55b2d7a205dfd6f540974c0a14569a1b6e9a3c61d5d530295fcaeb158134275ac53ec7f6a4abbf5528db8d335b878a1cb2664a41548933159be2bba02b68208856c81798b166e754d5163e5cb07e5364176fd10225dacb0ad2e0f9262dc9925922f18edcc7f4459f4ff2d2494a0183b7c516a634a3112e97de5baac2124bf6dce23aac98fc37fc06e5dfc05203c9953f6b5a9c66126e5582dd0a9a26efd49fa0647f6bb2172678c79f2e1b5f48a28f84b9a541dbc758c9114778c2f589cb7690abc53020dd79d80c2cbce5976fe1a84ec9e2eb99a1149d1c8eaec9338115fcfc1bdd8ed4952f5e5323fc74fb57e50b241fcbbd5727e743227bf2b721a72f4d76b33b791252ee40fd51b748bf2ed5694067c6219f9317fd29987f2831b5a94349b8d06672c4a1c3492c360b6bdd527568d042e8a46c3372ffcef554224895541b6089fce041f18474f083bf6d6f7aa25dac7bf0176d3fa8eade44ef64bd278ef932d45e586899b85c21540849d570b73dd620e37de138facf66fef63fc15e7b02018040d3d2f6111180902895085e3af3d491ffef24d2bbc35e3e64345f58c7e02abbbfc05f1ab2027ebfefafb1c18ef1e4ec4b64a055dbae5fd8409e46df04a8bdccdf0d38b721666e4b5a48d537b8f189f4d78e1efcac534102e02e0fd11b16859c93353e8f0754ff2bbcfec01f78eb731714aa643eeac3e07735e72331b58dea581a9c4dbaaa38b8ad2ba79f3a4c08fcbbfef175709689d9545126f2088a123e9cc531f961ab66c7ee98ca9c65169d62479e6d8193fd64c1a0a4ac697076cc6c7c725eeae0d38e82e9255e10363a1d1a76f857beefe58ab52550dc7f70deb839acb989777d374186262b0f9267283a9fd2fa50686d3f99de6a90ad947947341327b0ce4d73107de1208415a451814025740f853c9168263fbd043da98852c09f0b0b3b5a6b0d0b66e2bf6a2e1c7676efaa94fde7a8127920815a9a7a87c44daff5e9e93287ab4ee545fbf9aa349052abe88cd293bcf0a25e2166b40f915976052b22c86a46d7483796319984479c993e28ed5f9889ee1361ec8ca089ada467c8475a14653b9e3f036b892873dbeaa9647465f87a672ede9f368cbe55ac7c4a894d1d51f5c5bf6a0496a1166ea8a84507bdcf4b7a37298cc1b8b434d39b77f8d3c22e6f753e3cea32a9da1b09d8ea170d6c29412fb800654bf791d05087141a357b4aab1a458656c01296ea8140dd14eb3c2d25a4ef0a0c5d04922e4dda3a3ccf117bac2bd373b505224c81e2cfb241c471d99dd2a2becd1d2551d9cef352f18f5fcbd41c739bd8aab94768570a9e8b2b384cc51ba1e6226c3b3b0418626d93176f8ed0f41c5c75e1b0c2df4f862e77487fab19cda52cfe5ec5e6e1b1e6510e00e7336b0a28fc6d329cafa2521fb62a32ce03ad89726e3fb1e70f1a636aa03ca997fda8e24d491e116f92961f8e43ccca25d6070093f90feb256730527bdfa4548a03d6ea26b0e4d79b8f4e253ed2cd3c2de11ff80ff1e73357c1db2accef497be53103e341407ccb336a4b9f16347ee18dafa7ddfd2cc227058538a62c59c8bdf2624d95f2e9c4bae94157076284dac0d0e905cdafcaa25dfc17173ae7aad16b466c4e06e655b9ce904aade1bf38fbc15bf66295f5deabe5320e66d446d8d3f37f7e849ad3f9a993b84c4051a119f46abeeaae61122327177bc01721fabac1599640eb38beed9f7d5ebaff6df4e2a58be5bc1e963e63d9671f625aa44908c037052f8a991f030cc3db9c55db355665cde80b0abe75f48f067f8a803e78b900a808735f5bb2adfbbc25fe4bc220a381754cea2c25cbc392102d1a5f868baa0de2a363aa1f0a98c003b7a06a9a504f7c1a3cb1b4a3e8f2fb83b79a9877a352620a99a942a5d64795e13fd3a0dd495fc3edd857cb60b7b421499dde6b1fd3cec73047f1cea870043fa832bb2cb8e94b8bacc1630ee8095220d67ffaa9bb0978761f2c219131e6e8fa306d46665183019d7db17a234d9d68c307e5281481eee183af979ac389d1c386224dafbc507d8db07dac908e5f30291a1812301c24e602e9914f89e828ba0e1265c7bb5b3d80ad98a02f06e36ce1e4bf75ab22a1fc2827b52ee7c45b82fa1455627d4223963249921c45877743ba6e7777dfd84c3825cc597423b0a1750bef7652f45af7aeeeb56f3402c7fa2c29a70c3f8ae3a2fd54c8d4b079aad2e821f6d3484d64d13e756f861dcc23a9fa0124cb009dc1aea7a904b8cda93f728ee5f48863fcd78fce0f6bd0bbace07cfaaff4a81c94bbda10b36e8c432ddbb84485c8178c45146cea7c3cdf9c09c54a3449470acab05ba8e9cd0ebd823f6ed214c929156376d18c42ab8c500c6d2dc440255c8f324e51aaccb659ca7d49d57b311cff76da4a49952e48eb2fda30e4c8657bf7e53dba454e343aac2ab12f8b846b6cd96f72011c6f9d4a54398823d3b9b8fbc0691526e32fad97afb8d5da2427013fc1fb7a90450b3dd18d3ba8606e4b70c3d489b03d760f03334dabd8a11f08ed6d06d02d48172b64c8bbaecffcb2d1f51c68bf4cbe31feb4723e643407122dc34c73dc3424678e81764db65e293444cfc1e56d4b879a50fdc6ae8e73847a4590b56472e5f3a794bc153fb60230f31bc74b722fa9f4b47d42bb65842e5d3f3628cb5397ef4da891da3eea43ded0b5e4b92ce8e73dc516d5a6152fe807f3755bbf8e3bf98bcc496a7adb3f8c7ce2c6b1f478d7ce9d5279be01c39fbc360509a00f6e5f45b2d4ede5e791436ee2ceb255f25d98a1e5bda8554447305fc647acc1f47704fb305372290293c47f67de69c1705487cd0af104f1e12df3cec9910a409fd343ca7f4e3a999952a53a577a0afd1d437ed06ef3ae247f3b74a806882d6fb1f0b94ddad5c67db3168b7be529267057b48a12ea9d1149a54e7e2712225ddcee3db87e7b23b2af16bfc9688c15664690440a0d730ab25b734fc77f7e8bf4e1429d4b39f805c47939ef40776100f00c23fdc9310b057c62abaaf6d0956dfd311f7e39f9032cec570ecc910e0683c2890fc01d1f9452b38f4c108865ecfdd2df4499e670169a3561b328c6452a76170a65a4b863b64d7553b8194736fdd86fa2e47e66be5b50f9ceddc8db60df1c28dd0ad7b235291a01bbf73405244557d6d912bc83759d21aca5e3886cd2fe65369f720ad5a2f49c2993a3538815d078310afa73f27e61c89d0f93dc20f064561cea5cb45136a4223248f22ff04bbec73a11a23a0590d821bf09fd634f7b743eec294d2a7c1f5dd0ecf164de2af3d6e8f267fe9ffc7e13ca6957b48fa8af822c76e82e67a0c12ed8ada51948d96bccae9a91ee8dbfb1b975e7bbf5e0603fb24502254952b986f451e81d350f08e932a5a42cd2b10a41b3c9a5c41178ecdf2101bc73bbf4dd7e708a8821a2c6c1f6405d1ff1e518e778367ccfeb52c05182d6c1c1ef6b2daac4b028c45ed7c0cace0b346492f1082ce55e310ca87fad8d6bcd65fcbed2003b99005331e166a49f7b447821227a3351452aafe586ad0ec23d6fb0be3a95b8b9e49aa30aae57900fa4f879563f7edc791d8498847fd63be99e0c72850899f6c12cd1badbe9bf791aadd2c665efb4f515ed421f17dab110d890cc7fff0cb0905deb27cf6a0e004e0db5cb54a42a210d110556a1b89cd795988d933194fb6e9e1c79af0d340ec17ff453e06caea8cd11a48d6429661f5ee0835f05d35fbde15e0a282dd6d2f2f7aafa1776bcd07ab723ac7a0755e0b3db8394a94b0851aee94f4a7d27bb4a92c2897572fe8fd34a731061ec08335c15f017933f49d7821892d510a31e9d274be19b9e072f11ca5c40d33142e582a7a037edc8217b9139dbbcd79e0a92a3b5082ef208bee9ea88f72eb101ea05e2ec06b9fa5407f7acfdab770d7c5f1d6b9415015edaac57d74c059a3462a30828daa83aab9ed2f3de8b88db474f862761d29bef1b54171b9c87637196c21607fb022e6b38e0c06b57c7faf66698e4011377ad9635eec6bf2715b98878e43b98bc0fb1dc462fbb5f742c96ca28119df895b79ab21a15886711749834e9e5f440dc078fcb5c6b386a74b2d3a2a1b0903df00fff2dda96b7eb6e709c368758382e06bc917e49dcedb658803b015b0b48c7b1c14b29f332e9c10aee0cb2df9ec2bc903570bf306664750078a9b269c817938c093b07327e2f2d56ed91e3859cffe91af2e0521059624f72dde7c4ebd0449e4fd9a966e8bdf42f4131813d6cb41de7ccbb77bab0d86c3769142cd4d2d4bb86184fdfdee792975432272142d15969327b06a0f50791b4ee1510c00a1af1d56af81393717e4002b9e40f111c28aabf629790af9a3d539cf09b18f193802288f6bd649f14b7e8d3411a904dbb11742cc56b0a10bb8c0ffed59b3cdc176868c79c9be0cfd3c29f84ac8690b68fa2d61fb50916c78cb0523f851dabb69b90f8194c397600ea92fbe22b86cf99566d24c8065937777340f86c4a74c35514d6a48c248461d3e5522fd7f09f7e18a2201cb3581049818c8b938ef27255a683bd0ba3990895ad608bb8f2c708903b95d65a9c158be290889a7645524c9fa8d5c68ed3f10d47fa413632a0f398ca97820ca0ecafe6b7344ca5974ae82e4613f9125dd9022a35888a7c48771f9a918c6c7a895d16e59a12fee53526604d2e3785eb6992fe73492977f1293407a7708faabb7110ee89c00e5c71c267e527831fab5184dfde87e47f8918b4ed05d0792775147c32fa3284d248bdd601ff5d2f09fd98093756818d0f7a773bcce40f1210e6a087d1897964c131c8b10ad108ef3496b78182d562918e33134c0cb907c00797cc9d0ca562708433f8a74009dafba150426c3bcccb50363d277683fa629f6760c4cddc6facac5cb766a085f5409ce2a3abdb968e8aa1eca5c2a46805bb67eaf93504d34ef3b16e94cd66be18a175b08899adf943a41cde34c60ac0f710dec37cba6146a79cf562de6e9c9977be184687eb3d5871c8ec74835b3362c4528c4e4d0ea4309af18de0680f9d4c98af82e21a77cec20d1edf80c115101515c8d25dd62d74c5ee07d02595560efd7a7e4d69c47608275ef82edf98ff662c8052897b9f94b01805545d57fc8b0494a56b926116368cc5d06e5d3a55ed101b6fe71f4b5ee73ec5e4c24f1ea451fa24731e4949684d3d6d2081409059e72edd5e5d0576e837e021ec8236a10d27db8345988eac124f2daeacd8f6e812088ccb172ecd6b7621e2e67602bfdca478de15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
