<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b4d0558cc13375677123f5b9ee15d7306329f468db4bf51be658ffaa60980204a85e84e2aad8b6aa4594813caf99e60048dd392bf19c944d1c98d21c786793a32b3f296f1eef024826d0eb97a31d429dd93d0a4c420a0a9cb53e660ed174fda7c4aa299cf6fc50ae514dce910e70ace174475bfa8f8a151d11d01c607635272e16a843a869cc00ae09af506930c4ba9dfd2a1c9ee1d25843f28a903645ab7264fa7a9ccee0abed0648134fade8706dd73108e5fb87fada11789ed3f44e6b427797ee7bbe76075314b08c30a860215f57b195a9d654abbd3b12c7f5ed480c93a9b97dc47bc7ef323ac1e1c3946deabfcb2cab8212521cf96996dbd7b47604bba8b7b578a1a0bef4b03240d54edc8c63937946e30436a9c75eccf57fadfeedcc2d80f430c96665a02aa9917578fae5f0cf190d763a423725d3403d8c3fa887d9e8c5aee2236ce5baf99e026cac6a1fecb77175ca41233263c4f22f9d0b1f650ba01283be1992c1f14ea83e0ab8f24b67c66e297d6f96bbf05a142b32a6ffa8d5c5b61d20a8d960db4283060f25265f17a43b24316701803f1572872d53eb04c64e486d63d440b10c3cc483e3597c147cb1fa9ff4da83216b573e70deb26a8a7325d02e2efff4b2b36dceba3aba01cf0c0f27068038a8f82e33d3393ef2abcf6f9d845d8751772be779c942b73e8565280d70984018f906513b70e646a9510e0c500bed23e5fde09c27dfb0f6e2ebea21a2d003e7767fe19906455cebbb64507c291fc549250337834b9628a9fab122af71d6fd800af097f70f45e22e6adc8c866b7d9390e791193bfea3cc5fb6bf0f9a2400af49a64bab58ee66c8f2eccad15c6b7e89d43a115ad01b64dca95ee7d8c7d167c6a6b6e68dbdf2f3ad6dd0618ae1f2d05f44c7d015a3c02883285ca6ab237b3fb2bcd66d5469a58947da38055e43ec7e031b1c75a946fe96037cab4502266dc568d7ee902e7b9aaacff534a4324f5e1a7588f8627237d2aa397332a124d70058d7ced94c36301dc844d9833dcc6943f3fa10e866d442b20efbbb262d3ca8c1f49dad7f3f82d9e912a9bb2dd1f603a985df0dd34b8e373a46ea582a17e54d90002cfaec7c65009abbc0788d2fb19b61c65d3aad384e9ea9664e47a0b9e11bbce96d54b7b7f30593e266609411a77cfe7356f9a0bb4633027f727a88c613d744840b3f7ee7ae821e8caccb354fbf0c0524d2d2fced90e3012ab1051f093e8f6631d5d1f86e64e4dd9cc2a505039867b73da750b3a64642a4318ab96725a06d278b191c4d1feb1078dec583c09f51595136ff4944e40aafb950217cabf639a60dc5e677de633f88488061debdc0ab6e201fdec0e97fbee7b8f89c7991f9875078d83d01c50bf4fb3b74ee505dd661caf29a12306fa0e8c368b31bb8ea9e159e9db994fa28e79302c01f18173b662cd6bcf877a651316a2cddab973bf8480a4f647393ab885b6985f8fd4fb9e6bac87f8853cb34a82a4aa69066791db753eaeb7c096c76107f0c0630366e6afc800c1c8ab56c0c082594d0a284a633b19baa36454171974be70321fee69e12266ab0301c5ff5b40937e7dd56da3adf95e01ab96fd06dd1fdeae09759cc047c71a0bef11d91801884189495324b4ca92311299f3e5e53808424c06db7e3cc443ade1ee2ab2e191c7cc2d834f0c5834ad85b152f3910b995484286f18469afc42403dbec420dba4f9b010d93b5b10a5d60f30c2eb4082f953ee9689fdcab51472c535c92f026d2a14ab1956fd8788b229dc37bc3ef10eb11dbc4e34cc03cdadfcc2dbf84ad6beb519181060a46d36c92eaccb52d4387ad45dbe433d68318e17d4e994cddc9c825f0e0aa5d2fd75652cb544e5a1358a3d44da531257a90df6c403dc8d022d03438db8fcc0b6965c904189753d861a330f79aabe432e47307bbe6859b75c0926670d0c1e13ccba4cd4155c65277ede39289aec32c8cccd9c1649322b9a1998549135b6afca1143fc652138c82af578af0c1cdc8bdc71f47aa0be99624fd595b0cb82e39c1ba0f1bfd440286360e7e788f2e51e0e51c5ae8ac4ff8341333b5af878dd06728029e3d81e7c647445eba8fae619dd4177e3469d42491da939ce977f5a260f5bf20966a1ee8fcf94b51b64ce29970d4cc990863867fe5e11eb37de70846a4a40a8694ec0f3517fbfbabd4a30aec4a3b79a53dd0c25104e52dd9176f0712f613bb337ec4f66f30ce6c88105026aed314f9e8a7b9471c057a54310d57eca3a973d83392b65c43f4090f281bd2be8e06a9be5d5d25b40c5e7e96c1dbe3d071b920293d2d39463bff942fa4d2ddca4f3c1a618c7cd151f7ba03b26c31cc0f2a2ff3e926fff12e9ff914843230c805fc4675d948a966136a2a4efde22214adcec6a32e1cb3b7cfa95cc7b228ad34e953388c03dcd3080d431d2ce38929d12e5c6dcdb7f650c860a285f3a33d1d8c9adf35bd8e5cf900b8b2472badaffb2d1d49b27efac6ca3fe31f5955b0edaac5bd7feb7ce6e39739184e9cd03ffe719b571b50ee81083061e60969b28b87653d8c8e9693b94f3b173fb54bd1e2da44cd27dbe8320c10b2f599eaa673cd3c65e9e07debe4bb91ddc9774b3b425f88b141cf3dd06c995e51a45a5f6bd679940f038ed66b10233ee63812c02fd02e8d7abd3f4358a3111c5614616e2ab5e71280ee85ba8a5d443b9b9d0d459b692aa23c4b3d72cc0a160656b31df7eb4ddf0448611c7fe65e790da98bf27ce27ffa4cef2f473df750ae306117c22b29269e2d5aaea4e4a40d5d60bc155d005289c1c9934f487b7160e96b53227fb3d5d62edae843e81d89a2d9648ca7e8025eeef9a9658f684ebc01405199ff5ea997095b93d960e7bfbc1777a71be59b0fd49d78947f679fba820e10374e3ea16d3ca65a16d5015eb070be10a35633bce7c55c39254cbee5937cc1205c1cb6306c8afa71568064cf5de4501d52890aa3b72bb25b1a60c80d3fccdc729f84e639113e2f77cfac02420a1ad73b42e8ee176c3c526f2b1da7a7935aae5197c7e09577d166f765e8dc7279b0c6c72700419deb6e9638d648ca3cf4541543fded138a3929a562a301ce757a67515df5f9f90e604e270b7e66862bb0762e7f93d52d2962545bbdab796bb9ecf7ba3ff8703bedad6811ada2a5d28935dc268786438a81fcd84bef6e14de40f818fa40f994be9aed46a43b4a4bd53ba1c8a4299cc19c14293e91b57d73f1719208872560a8463e23f0007741c40e27a72f67aa1687f525770448969d77c4c80b889a708535d992d301546e03c4063e11d2b550027f83d51ef6af084775456a33bf22354ce8c4cd9c8b94e6e6ba3d920048b380b05759d0f830cab0865f165d892d7b06828e90d431b2a6d92a3f1e2db430e214725bb8fa0c9272d2f7f621ee56aeadd889216cc3f901596ef9614b2d0440004b37c334e7fc62d9e0175b74c6bab75c96e12309bb13df133604489bbfdf94c04f8c5cb9eda066f5d6939767e988928af69b15f8685ad8d97936b6489284fd208c5873fac4e7b8c272209c29870b7fbd3a3ddccbae0b23e4fccb9b7b7d05da8e7a6eab9bfcaf49c1e7e6bda5c3324bdf1acf5c1aacbdf36f95784f9d6212653edd77c2af16ef763478032cc88345716751ed584925a252c37829d270986dca88f809cc24aaa2691d3248949bc2a3bb8dd601ecd00cc97bb0d98e9ef59d7dbd2e836212ab176504ed41374b39b5c095e9ed5e66e52a08e28144230ac562e352c5eb71eb464a6a34a701589b0d620213aa5bea702eea750a13e7e64567ac8b74666f3a11b2ec6a89b452bcdc2d6005085b8b1e990f7b2582d81fbca7693810bcfccb2a3e81d1ea6cf24b681daca9e25889dc53293466598ab13a190db2a605b177c334dc651a2849a1ce7cbf625f9e4613a97bf373b658208d12895c37531695d670c6a019447f4d2a1d96c2a3d586a49ace23765d847b17e6db68dfc97e148b1f10f05e995ab722ac78de0761b65ca52e467a1f4dd3a779162de9d8db5ef89f3e144ab83ecd012bc3ffff01818609996e49fb3303481ad92c31e68c50f2b8b0f18a729d805311860ca87e8cdf3299780f32ee0ede9753852809f5c122aac91b7548f20d36187b3734cad748b65852fb757a9e55177d833765886beece6cf6cb7a6f749c235238f2995481af26e38228321e538ce776c561414270e83d9b9d09d4e899add75d8ccd8a3b00bf0b5ce996d2ed5f13a58c284a85534dac6bd3aaf36df3d22d839d222e862a682880a6be8e702b4fb42db10784ccf66e14b957f102499f2c85d511b475fb791fb2ead6206c7f067edaf4aab0c6b136f7e04cbaa43321f4a3adbe64787ee565ce4826bface7bfcdfb7a32d1409a300e17cd47b49f8a9a272991c41579ba3f56b1613b17da0d1367a5b8df365c2db6c01ab7ffd1163cab668954290461452737fd26ede42efe2a5ea5858fcd6fc47fb480fa12d00d225f46190b8dcdcc4cbd8b7037f5b0f4c132830125c0f75e04015e86e3d2b675bf1b582f38d7090e9d89932ad6c78329dbfae7c66693afa791e420339470d8dbcec5b3ecb47051f11949110a37efd3e1a1a27257ba76f15bd4ee04c85acd7ff3efbc2069d462f308524391be9ed2c563747f65b6fe1d0d2c29b84ae86828b13e122b4ee8b08e84c14514173bb78643b2b9c542ff07b674c2e4f8f7000aafa70057cd0359c47ebd481c05ee155976271522fe99c5767f8d122dd92b84b08caf492f412ee533ca3a38ed7ec1bbf317df958c784e81643ebd89a9c4614f04bd43c66e6bbba52394bdc15a1827f93e3bf222e6cba1215e0d1cdd97cced9d8f93c2c4e521152d23b0a7055e578f08e8a1aa0281f3be5c0da6a5d1b8062a0164b3fd3a5505b157b9db91ddafef6f0011e0f970732be775c5735c6493c3aa6308038c50de2156f72a105ff247a60f1f792663f66687b60416b26c133962e8f87bc169dd69aed6196e4fc09beac4c72bf595966eaf942126696745133636f3b973e6d09eae3da6276db941739f896e41786372b2f324d6f4dce6991aff50839cee14280cb45c60939354a1e5d562658d76d81940cfe8be48b85df237735bac46a7c18948c4f71aad1c02d06bb6cd2b93059849e0a06a5453c83e03051ee2aefaaf007d960b0bc32f368a59f1e57a01f5e8a2df40009ab713c4e68910a596e62a9721f44276e4e97b4e6f9af8c1d6edc7b22ce5147463c6e85263f1c912fa4b653811832426eb20775f18cb31c7ab6b9820bbb0584ff177bfc99322069f638c740aad1d7d9345d872baab5dfbff3647e4ffe56c38fe8682eb528ddb318727cc08aa8d6cd7b6945fc180a045853d040395b4f984248b51699e2be550ad5e24c94ac7be8d1aba4eb865f99b467e0c4c62513e06428e18dc1c6f2afbdc7c38097687dab14ba6393ddfefff32e4160868ed85e8fe934cec04768c3272a63809655b48f7485c05673f83e0b96b956251639d50c17c645a72307550d73a159cf7b0a73cbd770429166ddca34e2f9d5399d467861110ae9a209724ef17bd076345fbb6ee5cf2744c9e05c94ab837ec92011b4a700fde155f56a0ccd122faeffb1db97ec91303f8dbefc5a8667836ea7f4c6c4f752f9b3248690f5680a20c504b9227948291f03a2ec1ab802c03c3df340bc58c25fc63a44713cdff0e15847286749bf62d4e8ad5f74bb23e0f3030c938903e4662db6f55ae3d3c03c446c9d51f99a838b92b4e9270150208be52ce70bd00b49d7a44f502adfc885aecd6934b59964de1736e42cc8867ccb0544d8d27e04e781bdd29feb42b1c46da43afe153cf0d975ea4affee507c2a493ca74308dcfbab73775f3ee536af9833a7c25a07042dd4f915aeb348379135b5137bccc84d19096056519b817d4fd55b4e16ab3cca30fcf1f7d11faab73323deed0f79be363eff3e001ad3ccf45299e1e8a8d0609ca70c64e4ebd61a6544f477ce0d52e2e7d05fbff09c75647fc019b1b4fb20795d1b5c0786e23e93e4beebe3924732b21cb73a82fbeedf77c4dbab33a0e169ecca6894c598f62bf979f8ac36ffec8af65b4a80927dedc018fd76cc0d08c22ad9704c9febb1181ff64d1cf32a6d8564069dd4d774abcef4497074436524f11b6f2bd21fe6011a0123b7c71e93b0811c9131a2dd7bb0295308dc1ec99b5564166f055da4dc03717557a8e2f3f584554b823466849f66abeaf2a92ee799b4c66656b5248a02c268c997ffa73b0c15a8ed2a6426d5d168a4b5099198cd366b0152414091defcdb42e1d7efb5b0c590deaac85b7222bda447894c7d57e4e8b772c9d3e85156f561d834cff5dc134c8bc92eaf5da86e0b743a55a5c23222cf2d289b69e270ea8c308ac5611e672a989eb7941ce2254a1baa61c33e148eb11087ee2113e700ddbbccc32a7302bdcff8e70d611c2e60d7dadd6caeff1e45053a1566bc47c2118254cc51bd1ee4c9999ec65afe70cdcc3439127ac4e018a9117f55697aff775ddfa7c1204da765af96977fb6085abf5aba5269459cf5d9feac9fbbfa1afe343cba679b1e48f9aa8251b4fd13e924dc452dfe179287a91adfba34cf27b59b19e7b1e00e4e4602ad4a64ac1e27a7f90248ebd9ec27e06ffac247cb3d4792c2bf17ee771a12128817ca40162ee7a629c9d57368e784ee6e60d705e1049b97b9caae8e6972cb3ce4761f6526d23397dcf5475fa8ddc98a95622b4499a34ca6d6de0ac66bcd81b6ea283db555a8dc87962d9891a23c5f934d77709a147045a6baff33a5005487c676cd8eeacf2bc55c063d68426dc7f72a7e0b0dbfa09dabf0cc165f1be9e18ab4a5fc0006718fe7e02a8cbe2c456d862fafdcfa65a7a564f567f51c5a80b96dcada34e0f9fef6167adcf979db6f08c02d1e790fabc78cc6e5519820260f5cb266a524c2899b86ed0215f0747fc6d7651c75e27ee404ef0b1b35a2d131c4fd85e4537a00e631bdcb7bc9785274cb24020cf5b1b511963b55e4137f33f8a187a5c167aa540f50e4763ace05327806cfa34ad9c3cbce72c3f8986c3f8ad000c5142e807c2f6aec17c05534c6e85a8aee930adf395c43a0baaf58319f3fc80f0a77c59c76acaa84a1993e9d0191042936a396d2f3e3fc7c05b50be7cb1a0e40198afa4e9a10d809f2bf6a8641d52284fcd3aa5f8f360e86033e5c7a37145d45dd770945a0e8a7c059c90398f33e10f0c569beab8aeb71a0e1224b9220d942ee9595e52ec581c7d2849a324eee8da64e48cef5c047bed0be9c445c996dcdb837d64e88ab54cb20b22d5bbacabf427c8617cb6365e1f7880a93796250891eac037628c99edbecb2260616fa9eada814c97bdb6a01895abd002cf3438431cda2499f50954753eb3e6f1e902d8a63cbde28a5b22119ba83c1203f1ecfd3d0d10fd5c7408f9dbb6e152d4605bf2f3f93d94a1d0aa8b195b7c97cc639ada7dd1e3cb6fb2d934e6e8aba59ce7234f160a38e80d311210ab84901647cd2f268827ccae5744a41aaa22314dd774f515805cd331792f38043b56a64cb4e53eb5a4d83bebcaa734488f39f5668e0e4d5a295c2f7af5e478f1228c0ce4c193bce9740fb9cf72872b5be06891c85c5b625595012a372870ed345305e00cf76d392da153c7af215eb3334c0c707fff555f0e76e9d634e5c6ada64d698350d47b75d6d66029c724c7abf46af39ad4b1bd809f7ee95524ca6a643a65055364b3c870677f37b5ed626e3b8035f88cf56b39761593459d5d580a6c916165ede44ecb7f1faa5316d6e3866b03fd7680ec60fa9a9da3c66caf3b36767396531940e0d6cfdc577f69572ab5cc946de15620dcfea370293535eb775ede57b9a21fd894cbf2a9cefe4ffe1f594fe5d92fe85b07e98612acb82f5ef514addfe00ed6808dfd2020b4b9412d8e751f31ef956214d07d3eb84e78f54e1bec6f5ffe611d4d39c69e8325d0ab586ffe02ef55bded7fb80c229554624225be061b00e679dd6df6f1192ca5b5acf78c3bdd1003e21d5c83e8efaacc9689c45dc0482e4fbc2e76cfffe0432ac864d98004b2e164ae46b87418747dda12b1d6ab55bc59c93d8f971984dff6ad0fc2d3f832f704db19889084065b0e268b63ef213f0be915629138101ae71a4ef2d2149368db4fdb1ba1795d3c4632d2c43c3cb29cafb6e9dfb751133c53a7883e6c84f26fcefbb0570494611dc557eb8cb0f680560a7ad6057ac70bc21f9408c31463998856399807721f269a0df5161d4c39004529b652761b0028c5ae0bd1a1ef894e020256fb7f270697c1b14ed29fc05afe464a79e3d3b8f17ada9ef4e34f163d927b9ff338f3ca354b29f640b145211930a31040a6b07ecfdcb6f5a6cdcd0be088a4840e96d8a063fd439dfde62b1927589319ece6d2da653fed45a16ae54aee4308255679258713dcf3edb4a68fb8e7a64d1ebb43e1bad407b2536e3f8caf254701ce31885d1ce39c3824ffa9dd7528aad750c1aedc815474dfe3545475dc9c812f18cda5daaea50a0652f8127fff9f1523b1b8ddb2418970a72cdaae7c4e73bc0728604e3ee6b3d95b3a14608cc071c483e4f48664cee4ff5a5e93f219757102172cc7d90deab09896cfcd6393d089477660e3cde6fafa39c2e242ee2f6b7c07a3dc6f7e91d92680d400fcb29a1710e3a77dd930364a492218b6b6348e86157c8af9329ee179b828a67d565e5d7dd4cf46dc6bd264c5fcc1247cf48849bf8c6756bfd83534eac92e082a9a1a6794b4274600a2edb345aa268922b93b68d12ca54144e177314e2e47bfd229d5cc7e105b3bd914251b46c46a2c7a094526b9eb43430b24c3b3e19efa7efa6d4f4fe86dcf606b13c0bda25033470aeccd22f29d51e6f95e0e73794d208475e2e6af1087e7c906cf2e8423653c15993a1f40b5df876fc6fc96944b59e04c98df87bb8dad25cfa352199942a0403638812bcae785d4b3764c6845c9a5d52d52af8403fa9285ddff80ed7b895bb4ebbd1e4f85ed4ae15b8b158044beb4b9eff1733812163efb124dd81907f6bee92754f4f13659401a2dbf03004c0d6b60929e7776268367aec6f6996df00918f12c988808668ac8574dcd7fe2fc579921e957e1cfc6278aa8122dccdc8696e7078a8d65379d969538ab2efdf1ce6432391d6d795eb456eec94866cdc8a4bd70b8357938fb1d25f36ddc7415d9b49c8f13762ad221ea0006b38117667bb1f3df62e5f4c4ff0b9b2d72ce4954c39434ea44773ba97609ef934d03cee1bac5ed415ae9b77e125ac1383b89815cf4732fd510c13561f21fb074a7df03b53d80d932955d468e33e6df08a3fcce9ea81e2e66ca8c00324d417a867ba73e3e966542363b6e33f04fb803d1c993aa8a12dd334fa6f971394f27e6f9d1da6948f09daf681d4e7ee192edfb4aec1869d7d0844adcdff4bcbe14ed167ca53450a2a02661b6cb06b9fbce7c411e007da5233bd7754fe3183157440217db78ec1f3a549ae48d65f93f49a55d648315a183aa7f50f4468e7fe3a476877a1d2c66cc24b107fed6a83b7482f0f4a3214bb7c1298d94e87eed6e68c11545e6f59f53d176862ac85f28cf12416b5875adc3ef514fb7e7b9d7e7710714512ad1cbd404e8cbc7ce5c3734af14d2ad299e2a42b1e96303dd636afe77aaca2fbde780c292415b007136ba67666bd66020784a7194e46b677eef080d2d07ffea6bab2629b0c0d7ab5508fa16b17be91357fdd0f1e8df1b91b6e58a07522cec184768cdc13ab62b81cb39203c853fe5de44d94eb2d56876f095dcbd2f1f66376486536d2603161d2c02a235b0865f0146adec2a5bd4ad969345abbd976838f3a2400fcc14bab9aefe5042d33a327fca9613424fe969bc761eddf3fca6cc1077dde64a6ad2f40fe0bf4c7c985173fd8825a73f2d3af7ece19699f7b69633224a0a2f4fc50c413f87f2679c9565a66984da8d6dfcd288d5538efafc3c34d3d51eeb1dbd9e4f6ba7bbd5085ee6b4a93ce748bd5983f3e33cd4164fe83a4d2aaaf20b2a9fae54413535e594e7314534193424185cef6f603b72a7c670551fab6f11fe3313140523e7263eba49524aea2fe6f46f05fc8ea1e03bc8e098e431bf59b3c0eb998da02aef5332a4def009d4d0fe64dfb6f82804715ff6fb7741eb2e6e9849ac98bf79641d0b19ec395fadd17389d302050f16e53e629233d68d0aa64728213796d34e18dbee995c78601a254a7be0daf142ba84e9922f1aa247ff1fa1a3769d6bc110bbc60f4dc3f9c6a3e43aeb9546ce0506eac1bd895b671b55cdba18243f96d46c5dcab88a949ac685e6164df052cede593fc179d0cfcc701ad764af7ce7a6d6c00e93faa0bfb1db81535a307c59c86750ea73bc797f6c7a9dcb34191a02b525dfe26966cb9a81730b643e424f85ca698c670c52302b175bb1fcf9a5524009056c0640f14f0ff56ede52de4212246dce4d9097f2ee30b4af03f49ac2a1de9cea42d339c28dd9511ca230914627335dc788635137cb3170195ac65803e9195840141036112a90012cd63d9b8ea9d6f84569330729719c81f53b840b066344b252288c16a7c3d27d57c81afeb34ea80b475534dc0a9d049773757faac23e9dac75e0843a3cdcacce66b01efa04d14f219a3056480f83cfda5214cfe11f50c686c7788054e7c2e35a1133143c49d28510cd4c309c51371c86ad2ae1d0f8a8054e2fee5be11eacb821967ce63ca5ecd2b5240fe194b1cdb0e1da9f6d73b2784e2565852f878273fea39ec1aa07bb6ecc7bf5070fafcd2a5b395011008be8677683016de4380de1eab49c6c06dc5fcd1529c3f2e3ceb6dd3e0069d8d902edbeffd6ff051283b605026364d1e52ab886f28c7c97e6a70701e2e805bd99e96c05341ebde2a22b0f09c45517fcd1224c8c89d13707ec23e1cc9c8c8cb4280134823ec228b33e6b08dcda7b6562e1727441a10d2c5944296e06d1dee6639de1ad927f5afd0603879dedf7fd3c3b4a5685382c02e74e569c434bc6065b6b90d8af235e232c3d74ddad571a5c66811b99adea23e66fb02da4b005dda2ee49429b8a90e8eedc3a5dddd556b31103ad515f059ff2af3b4fc5d1778b86e110dd2b8fc2ec951dad2755b8d2623c142b5ee29c53345ea599ab54fe9fb533bd1ed228d23007c4a43af3b2e74010c85b03534f77277b8daa3f5e5304e4921a98edfc57d5b1195aa0ded7b42a41901c571715316513beaf9ad284c2efaf6e5f750986e452727db44baed139bc2cb6b9c7134c78c81c9165fc53deaedf90ce48e796589368e6b8d11dc4e3553c506521f2dd251b6765ef3f270d0274a1243601a573d139d7de4ff0e7fdeb4af5a8934e16cd27c896269647668f4993dbe3127b8280c31df86be900bdb80bb518fc89c9d54a8a56aae44c3d3c291e35cd4f5f3f0c4af2817d5ffd4fe210cc685800546f5deb1eedc15ea9cb1cff9faf40a92797331cfce6c13849727957f5e1d29c0c70b18ea49ee442c22e55a51daf969b48c5eb894f989cbaf55978910b194a5d940edc73bbc62db7bfbe8fb70888214cfcde1a9793ac519f894838b64e5c85993379952794cc8db11ababab3d1c6d284828111efd645d0f01496e718ac4e09d12c4480c297b5cb16558415ed61973e98b7142be362e9c265032afb745cff1c815d059dd54c8bfd722f37eb8fa3e48818085af7c0a5460df99807868bf2661f23c31215bbb203405cf4527d0d87023d87718cad0361f8657abf9eb578eb4677c6575dcf5716b06d12fa20b10b18c5d41c4f51b245208ff78066aa6dc917e3e518266f92b00448b0cdbff86b33a1c578a15f1f6d1a9979ca1aac7530563901418d881f2b22bf42717f5e2b8587d9965234e0f47a683f602408a0578deb4fe02e0efdebdaba13e9e7aeaffbc274d70c293efbbf6baa2057d2c5be7594c5d1a0bd0011eda149a4323dadefc7dde37aa1b091649423e081a9d24c9dfa00f2e844c41e5d30b9c22c2d12d448d0688da711b973aac09906daa3298a37e3ff5011c081b6e4c20c0b3147343905d47d902a3fab098ab33dfc3fa2210b818c928009c235a36e43cfe420d240f7b6bcef30f2016372937e902694724b39c2580e10a58b95f4052de639abddfbff8829af9057df223186d2257261cc7fb82b0d928848458c7372b6f23ad83dd152d30163472bfaa8359cf030ffc7a3e666adbc071e98a98830eb387719f60584b21a2518be5c0d9a361bbfac0072db4ceaed312a82286fe10b43501eb842b625cd98b5762781a966022d7b5360723ecac6003b4deda806a52ce9c09640559ea7cedeb0432f4d9a43045276d51d5e90ce9b142995302e3cdd3711d6fd2506e0e066f242f41443f3304a9cd695dddab78436c304fd214c893848a9afef5995a7be45ca8db7a7bed3bf55b3b589034618a0fec489716cd3c5738193692062ac26bbe9a72203485e028c1086b599f93db84c5870f34f49fc9268cfbaf0a2f6cd9591bda8cb0f4a17fcb2d62e878f97d98dffdb261d20e6ec470fb7a6691261ca5fafa7f78eaf65c3e19bfa3be2281e090090506fd2666239b49d6eaa5021b2f47cc4c4fe5f1e3d365aa9e7ecd9219cdf996739a4da6b9b41045af0e405b7d0aae54c43652eff91cba04069d0248934c8754d4d5bf6c8f03bded3a943dd4f386f3b9da5c1ad01d171924773073eddf17e7e3aaa71a728c4bafbc8ff1d2933f27a51359a492ef39dce74dbe1211b757e0000efc12d551420585ffd739d349ee280f8cecca853fdd4c5c44a000a743be43c22d480077a6bfa0ea308740b7a1599774b097fbb39511dd7b45bb97e9e4051283eabcae41ecc01574a48432f5b6bb26768ed3d3d4c4de3e181522cba27a888f8b5b62f8b5223bc0a41cd5982be27b06f80f99d07fbd15b546d92ccb2d58e99db32792d49e336e88942c9685569bf5a40b67171ebb56c10e1097d40ec525941c1b74edad52fe9687677f5d2d2e8ad72b229a294bb2bacb4edae49abd62c4f8799c5142d2e1458aa8f7c06d20a79d5b390062a9d5cac9ff10602f9448f85fde961de3303c2a2a910c7f6f7dc920e6914e5e76d9ed498bd4a79ed181bb25af5033ab6d09459d3e5ff53979c43436172ff4db3ab48d77b5af880da661a1fa75397f1d5474cc43c1677c05c3ca9885c483dfb08ddd1c79a50423eb26b4701c84530a92257bb23d7538fe9aa807041d579f0d630f67b4487e1209150b6f2cc949232dabb0abe32b0c6411f3c0b8619b925af46fcd01f225b68e79158a589392a1a5f4850d13fd2314fd4a83984177d8b6f0830eb4b838ebc6db21ce1cc824a8f1804f1d0758d59f7b1357879ea4f4f80ce6617806cafa71c7aa75ef5f79449144720dbbd2584c057576348a3bdc707910ac6a81f8e4edb9e8e6d9050c15bf96fe0ea5a2797de6f57b726fb8d658da275b94249917059680e3fc642a8cfa70447c19d0ed1df6aa3033f3caa36d235cad13a23bce964b9c2f99e3cb15dd64c84ba66f09dab38c73a87f9cc997fc9f77c8008d5ad2595b57286f06f16cb5b4957939d787ae0d3e78d8858c228b9c0f87dddd18066bee861d45e436d6f02ce1097b3b372311d4fee658e98333446ecaac445f92e9afde71490a07b20687ebba044eb3a5eb84ee6c755dd64e23afa0fcfebd600ca6f6343f3b7ff7000e1dc23ff2790f123bd62f46bdbb1b72598c43fac71c17d22722cd4d6f2a336aa09145403193e4addd70a099bba979f2cf9bba9b09a4481a944467af9067da05b4a777bb8c593f632973af2c8aab21164dae230bc6500be2327ec8aa384046dbbbdfcc576a726466ba1c99c9b14cfbb02eea290b349b35267ab7289311b78c18de0ea1b0f233d3ab68ea6229abd6922719799fb5bc80d0bc7bbfdfe7d3c372cce675b73d8f8ef59836f49fbf106f2a0f85ffbc13db6ee41165cfd5d537d82b3cc4130ce044ee930cbfce2fdecfb4ec16e74325dbfb9fe33a8baa3665a1a725b3147ba3b5ff8ad016571fb1f90633eb675896077004880ed6ab5e6e7d7fc84feb609a44d877496600cdb0d7f391fd162c55abbd48f03a0e382fd10043d8bc04a46d32e87117bd0bbf321c74fad704ea1fec21129f0f296a8ccc9db734d2da0b3f4b73f1e74369da124003328100e68a750d3d7dcd95e3fea233e60608253069d866877744afc88864639840f884730d415bc842f9fac61e18aa32fac834cffcb50f980515bd39fe31f77a673362b4675b81646583a4df3bef5966eb9f35854c18ae6cb6f63c06951794cd939f92f815ec0fc8c8ea7a10cd27989b2493baeef7d20a522e950b5c2af8b87fa138d225506b0417eed2c28720621e83e1c9603630d2e2a90b1a4e2b7dd230c021e780f56bd6b5d9901c8db0563048fac2a661059be322227ddb321ce27070164964318cff3de7ae6d822ef32cc8d0d5529e6cff84128862621802481f01a9a75efce1022b5daf48e7bf2f6f0984a6ca31f82176b50930b9eac133364556d9b08fb69ac09e9ef1cd3eb676e21bb61c088346cb0774407909808bbb50e5c47c0719c45914b20f3d013615428f50e0b6d2f76313e208cd03ad79d7974d6b772a06070022a22e382fb226d6f3b13b32f52a2fd8d8c2f93004f1867d50bf60e01d04be8deab141e71e42734c3e893288e93ea25e66b5135bcf6136eba1714f2976dad2e78d9337eec1088d8852f0854e6a0ff709089eb812d58589abcc56090ecd2d817448c06c8ca2810e167c764b7b2f122eb569e068022a1f587003ab5475a7822f258b4e3fa5ad07d69f40de56f9a26e3c06e4ed1d128a98bcf9569062c9bbebbb4a64eb3bb182cbbc42baf9517f677f2e48dc7c2babf435542bc41bc2ad6d669317598d52d08b3435c2ff5549c4e705192e58454fb6f939d29ca47ce6e38eae28165cdc2a850390aba204841faab6de209d56861d59281a8c8c1553b19825b1334fb1bc7d7e9da337c62c01b2db3a7f1ea52eae71346460dfba582db18f90f22972cf7d212d5ef6a5153cd13466e5a2ca5a032bf312c6b6a1ced12d2587548cac25d30457f8dcc0a89f0d1dc02b197c2c37f31598c22b76ee2770ce042d9ab90d55d118e3b349a2c5177d0c9d28b611e8b39651868dff007ee2ea666d235cac65be3f4b71a3c2af882e95aaff4863fa02d392759ed687c54b101cdb4aa8c466b3ede70f93fc8f92b7f8d9bca22c3f790d838ed9eeb47e39a7f11b431700432c556afb53e6d8bd21b013fc9b26bfaad1091bfe20175a91d992401a07b283a7f8ffa064e5632f9421c77a2907c92fb203f86505c0da955d7552adb5a58db7443348ff9a330a09f5dc735d51890c98672f99f5774744f52fc61ef15fcae20a6176e00379d2e66e8e89c868312e8f6cc594b66893a5a55464ca1dd5dd719680f517e9ea52c9fcc2a0e17b4112e0a8ceb74e263c37785bad0deac90808e3eead7119b41ed8e88552b4cbad088450dfbd7168adb19aa87bc200e1e5039259a1c4ee483d55d35a459fa98e60790167182ba5a60db741fe6845f033f5950295c0dfa186afb355c147234ca95dc1fa73d41e9cde886803ab411443228c6703e9d786ddc941f4ae39e6daebf3ad568bbab8ec7b87a9091b49dd9c0471927c006d8b361c19e1676ee5963c73c73a7c52090c3a32aaada3684fed083bb4f77b736e6024f1cedef8e822543c57d099b313db656fef69fc65f024b72c6e13fe19fa7c28050b1ef6c1c5c0eb8c2ccb9bac74acd21f16f5e289d14db14cb5dc1828dab0103e0d2ee22c6448b23fe3e47d8e2fb467f224c4f0c4eb86d7b27d234a6a0b8fa558ba96c42f352065d374fff142e958608ea41c0cc69a6e4a1cb8f448a59ce8024b4ac9450c9feeae87d48752c02c804b7b230ea232713b05cc7865dc8265050b33b5835fa8c2af2a13dfc007f9f7638fd7af90191fb955144984c2031f3e94db8e34641187bbe6c98fdb92a2d6a2ad6c4f0f981da295db0859b35cc1e3b98f85cc27f3f20271991f82beaa38d774dd596aac9f5bc1e8b2c7e5e7638032a1013a13a02e28ce27110e0725ca2f21761228373d6b399b7281bb406fc02393fd8f3a465e839260302dc5b81731cfc13d27058c9c382a2ea089a9ee4d93712a3ba8be0e62fab77aebb6c880b60630def06a196f89beed07dfb1b229a1f148081b6fc063e30c2e6370041e9043414d87fccd807bb7b2505590e09aed839e28959ab3581eeafdb382cb02eacadcd2a07827c571e04525f473cb1211a3b3eefee3af055d2ae74245e1d349b629292b9f527693a0be8fb0dcb5b038d6e510e1b927c3cf9b38073e65e7c75c01a91c3d6b63f1b82b6751d531e3eb45a5ebc9e3200f2a5f95a14b508c7d1e9a4e19223eb9751cd6305fa2a206fa9fa0ea4c05ebc046c2775dabc733e22f44f865bb6b3d724b4522b3ea016fccce47173225ad4fd599dea66f6690063b2575a74ac0f2321037372d0a288f07e2221385a2463e14fb76cd689e81ca1e25e6b3bb1068fb197d1536dba120b19c3d5af86eccb04f0c0908481dadc75c1497c7783476dab1334b9acaf844cbc0d9307f194c239f1a796a264c132aba6d8736f44455e8f46dc208f47a9faeb0c01fa2a1a282b8764f09607a235ea5e9e66f0288321380686e44a96aa1a605dea7e12f75e89ceb40508dbd0678d6efbd53c16c84af2a14edd660b2f8e1748419030815094ddd60421a8fe67beb87c2e0d5c3d18849ce038ea35d3816462dc242706861663c2b8c63ee95f7bb10935742ac25efdd1084ec18e34df3df17b6570d798e548e5d2118c790b52ff8cb7ef10b7ca8c1a931a4eacb6651a685725b267b9fb9a39438dbd4663b55aa0571fdb770cadfffa11e4055c4591bd98c19cb49a536729d70acdf38d4524108d9eb5d126c20fcbbb40c0776012be84cd6c77f08dd4542605a44a2a4e5e8850f1caa3d9820b56650349ee329ca216b50c15a7fd50527192ead3ea8aec2a4d6ec7665d29603a7e57fd057c14e38f94be5bfb7742b099a6c408aec5ccf8e8fd3d7cfd5a98105cd66cb65f4d2b5db79f964a5dca76c1f1d8e82c96c539e19785317313badd5f49e857a4d75ac459583b1bb7cdc0fbc86cc650caa4af29412d0025dbf0362d89c99d96b2fa2db9f4e713f176df050ef2105d6d0dede9a5d29e406bba8c1832c1a5de7eb69f48b83e5328df5d1bcfff3c3a18d4de18e39d16a26f7b01cc9429bcd0a736e665619b428aa27b698da1219f78bee569a22709b8e4998f1e6b549a5bec47ce3643eed46755feaf089569dc5e8f5ef3af5cb363d06fd230aad8ffedad91300414c1d25c389885c32bf3edbe0deb0c08d32f01203e706079d86a6ced1a67db6ccee9fdae1dd2aa4d49372f97ba43310d7e52bb27e7924a0283fdec3b94826e1f1f8d346005ceafd17dc96374aad3d507745983277c97130a7d3e62be8f10f55a62fb5c989af531aff6a13e74e8bfa93233f632e147c012092b009c0ee75e4a0c83628d1eef21784717011fcaa8ee8b02c7ca3d621a8cab0f2e90d6f545b089682072a5b9d43c637ccd5f42bf6f0a0d79fb7a5d7b7da0d10501773a986398609f7db74ffdf8bf6ca101416b0b15f813fb9a210cf9d8b4340cd531983b5183941771471188bf3c2569181c9f728cf809f02905429e549203a09c4b394d1dc9bb14406ad244cbe707e0e5e0104e9cc99ffd95ffc6b98025304e05c12d943cc5b8c403f39651914a2c8ae05c8958f8914add6787586fe600cffa5af99b527ffb940fe3d168ef27c04ffd1ade9fb85b4b242a002eb8549f4fcb83b43103dfe0371b7fea6244a5ef0d0a6a834b200f18be64d53ca5384d9413c2be3d4eadb35a2cceac66e9850df39f9e52e147bfcd14bd5f4ee4101156215276b18411a94d6c4cac8f6476fa2cc699d595a7c708558a174e3ca57815c204bf5f094fbd491034639a57db7452b53dc266437204ecde8ab95ed1120b18b1c6138a1aee308e5816e262ccdf6fbdec730b8da38dcc791f0179bd39f332da7f76854c962c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
