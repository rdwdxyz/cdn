<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"920cc1073ce1d02841d3225c480e3c3305dd0d6a7320a0af5a3b3e67481d03a954cc6ffb1afe3d958ea403b4742f84216a6bb9b11f0d5c435b08ddd95d885b90f504c48bdd7e12c7927b40412216b950d432145ade6642fb1564d9ca1713593fbc8f2281bff1d7dedfbc2d0584f5fdad032ccde6b99da6589ce9c5d6e63cd5a5bd1245704a039033bbfb99eafff70c868017ef9fdf61de8ccbb683242cd5f16d00f895601530458e3280bb8c0b237dd401e5edbdb8c8b6a38edac5a2573d6fcb9b0469743962b412c5d9b647c9f5b8eafba0f0a325fef39b4453902a4bbcd621381fb22a062c8c3d3435aedc06e9987255fe26b98a34d0a833f85275d4483da78465414100c01cb9616e3de79f2c5a1e6a91c6aac88589188d2dac5db1c3e0e21b4a854fc8a6b7ad19324b879826ca3acfacf1d2c7ee4540340b50fd30a15991b7c0650008f6b20a4839b4679b7ff8c0200c68ebaf17955f8eb9620ccddd240561bb8e9631f5f7353eca5801ecf2500b69ec6a8a92f1d731149543b47fd693316914e709563cab5644e1fb7a325acc63c42fd1705c3418b9f37b07e6f773d3fa50d9f1e9d7a498d0bdd69666bcbe0653356c15bead3231acb62b3dccc442eb8ff638644055f0492fcd45d796f20c752c88e14296ba41898ff16e36feb8430eedc8023d690e6cd615c689166704690cedfe16793acbd5125b4cb6898849365d0ee3486904341a24dca0b61cf51d27a6a9fedfb71d2e9b50b2e2dc8c5ff1eb5740e56ec6f3e573b73ce572b66da01e9d43136293d8348d9c2431b78e5283baf170d640eb1ee8755ef383f432454f376693546738f5f8ac57febe665866569b2c8e5a9d82d7d9c0924879c1610342e979141f2c7b03d5aea42731b487ef0edb434f860387bd14cda3134447fe4a6465ee0bfb515165406c284f0b011389edb3040d237ea2b0749107e42f2361d497b0b50f2499f5f52c37dbc42750974bc75bedb1ef9c5a2974db8c466b0466c1ba8836b62b5f728de325111fd7094a78e9e22a7a614e7a0c72c4144ef5e67cf54a9d1f17df3caab7182e77ebb902dcd5cbcbae176447d8160b344134f4a1c9c0fcdb56db968bede2b01c697403c77b16ec7b230107b77e5f89d9762fda82d64d2fcfe55bfab2f5e94332425e63b824af4086d3a406ced37eefbf3c4ee4f48674681df8890a380fb39bb8290893b2d7db7c9c2f8b87b1ef55319772211b4e1a165f9111a65d1e8bd0f2d24daec5b690185123be3c77fa897ae6cfa55669ac11cadaa4dfdf9c1e668913b74efaae686cb8f93e32f39aaaa31cff6cd3fe5656f5a2d458bb164e4b97a9a86509c6c8a8a879ea4fab2f96ed9ae2d7cc8b7ca42a84c06ef78ff866e9fdc314bda30a6a9a891b607228e5ce9de3d1bca3b38a8b0495d07c104bb107c2d48e56e3492a74110bf7363927f3e2eacbdd1be242ffbac4214e8077f7bc3d4f6d3bef1fb6fd85a4115bd04ca71b90a654ebbaa0700c6d643bdcb5c8b90140e298c7150c9655951674190629e474a3ed6d81e7b0395ed27f849c59e6a00a726eb0debea00223a67bc4a688e452ad12660e44295103d8d6ba72f50b82a3bd3487e90b271f8db9da0ea649b307697c5ed5ceea357db78f34d9376f038d43011f0bf561f362683a43e45ec484b1a297958293c210ac18d7682a74cfe81c2f8da1529bbaa10bd716df9f05b72785b9dfd4cdaa53ee08c22693bb760c997265ce822e274a9f21f892429945f84183de6521f5e9ce8cc34d059d9794afd4a58289d08b538d70561bd0d0110aa13e3a0635c736bd11e21cb6df34fbe0d564f7cb3e20a005322261c3ba0b061ba1c15c22feea3757c47d0a8b3384d5509af5ea8fa78e60bb68a4d4b8125a0413099101587c77fe2e345f40afcfb63de1ccd7fe0c61b71ff081627b466c2615d0824981730799392e5b0f6d1a3863a6519045c5e3bcb4e5b336bbe658c516a5027747c905f198d1a1ea8a333939311335f34801a450a36eeb47b5928bc0958e5c0e68a51eb52a25c2bcad62c598644d8f40e404dd7fa500ec7de92b9f6c72dc9e49ce2b7ba866674aa0e529a18b45dfa77c4afc156af294a3228830c2512ac06f4354108d6638d4f0a8eb7128a900b7f66957696e2b5f6d8f38609b04c375be6d8375d09a551f4209c62e26e0c77765b8070713ff5add7f8df0449599823dbb87259467978d26eff872bcf72ff640b3c0cad77d1073ec308dba759ed0d9ca7d579d3a7950fabc3ca5c00c1fec9b643908e270c8914a364a6e1c16ca6d4187a7bab0db1872c2b2635955ed9da064c66d8dd08e49076024ee35ce174dd7d851e07373dae2e80e5a5c7fbf3399b08e7bcd561ceed9a2fe5b6feb927a4b68386e2671ecb435421a47c68628d00382a3b5693e987fd94212609e88399e3f678a11379d326112e1934a84229ff9b28edd846a8b75354a0057db3c2d93f6f469a25b4126906c0e882ba254f0c12d94e4baf4b8101b07eeb63792befd28c17af5b22acc87af6ee623b52d0eba6f1854a440099e23b52a2a205598aca1be4a9e0d6a65f4b67baa9ddf2186c51a60aa2ab3eb6767343a434a44e9dcec7f174b455109c54ef25995786951014f9014fd7ad83cb095dfc24f4d8452495432dd97f60f565dfc0b64e08579bb7ac5ce9e96754211f02d0702860666ade7bec0b1146e1bca2866f6c1b7d727766bb853b93b913b50bee086f25cf5cc7d288491ab689e36fb48c3c1675070febc4d96b5a1a5c91f871203469f055b984ef511ede43af765f447959139953b394b9788975b9d207ace06734172cf321b3954788c8a42cb3b673a779907a4fbc758ca6052175fb45387ebade8108961d30bab35253d90b33534869b99e1a31e5ce5e3c400d7b705c6306d7654f600b1b21e16514053292b822c10f943d4c544b13ed997fde1b59ec8580a52444df05cd3fc13a44fd20ddf610fdba013df5d0fb70d7c1bd449cf5f9698a4b2570688e1b56a5ecac85e72f82243477a9edf8bbce2873da6d50ac9ee98bf9b511978442a72c9548ad75b3d5c632ed3a6300f20f70fe9824a1ed5392bb6ccebc397547dd464c9ca24fc91fdc4a97db997ae913e4776342226d856d5c405a4d46df8d1d7b1bcce6ff3a3a15824c825fb3c33edb39241ace8feb9f822c8cabc5a5bf0d7ca48466b8ef9fda4d3f0f9cbbb3180ac0cd2c6903286bf03dc711162ada0e5a40d25e68361962d27ede61ddbc718310ec006c8b6891b9ae59a3fc89cdea815b393c15ba8315259fab92bf5aee1c8f241f14af481712b2d000a6080c5f7a2e2dce5c2880a3166920be47ae78ce53b7391f0533387aea8119b716a1c66cb2e988088bd9e92b1dc276dffaceac713086a2dd731e602e44efbb2e30829f7813ab8433c106f627b60010ca941b0f7ba3a352faa7f4659623d1edb3142ccb827d814da134adb29cff7d1296ed275bda4c5edb582e6aee7798c0b9c09760be259f3c9095911f478bb9588d434fe5c6b6104f4f332e8f364cdaec7e5bdca4c577ac342190e84503ad4b2f00bfcc4a6014f5761d6856912e5eae483d219ffaeb43433fbd938c7d636ca613ef8d0392d59ee05e93f18191d4710f8a41f5bd3bd13fa4d3586cf2e69a67f313b7f1e5fb3f5f896dfc4ec2c6354ecae3ecf94deec1147d7e4289faff9c9b623f55244cf743141c5d11b4c53f3b080bccedf57d3023b456140f05361764102ce4db48c7a27a452a2f030b4123abfb2d9fe51918358e5eda0a0247c867e3a5441ac98627cbe680155ba2283ffa4f5d55d864491009a0414e4464da64d3cc40c52892f909a1521a33a47255c54500a76a7edfd1d60fb5265f3119b50900a6b25d22573405a9a4238587ae69e02f889d901d9fe411b2377ed73a9f8263e1019db496f9e9c3371dff74d0bfcdf05297deed3f6f7262f52dcad6f7509c087ffcb776185aea25ae1dfdb23774e0eb84e45bdcdc0c7555d5c14ad90565a88899856b253a6cff7f74341ad524da82dc2f0c767e314040b1a895a87a4790d257a87901ffeaea8f7d1e44f48aaa36a0eb16a97564283300969d4da73bc963e87d07fc74010469fa03f56c7c62417e6332fd6f15d29814698324bf1cf97e2797992879023331435d4c6450a47c4f877a00e291363bc26cf9b84953bd381078c853949db036e8794c51377e0d3495799ee9fb7e78a6f27a0bc49c53808d6505acd528a85603ecfb10914f0ca2953089c3d6217f8e2d45b33468def4f11d953982f982d4f78c76b95f1ddd20675558bb85448d38bebfc01c498d827e303a79035b450f83c9bea2dec9dbeadda7f6e544934de584a36cb5b533ccaaf26e06da3974b0defac4f82291661b29ebb7c39300ba19411d59ec070f74de7074b5cec5a9ea7fcfa5764376884b2816750c47552680afae56255e67780f2d772082c9a9a21de6dbc6793a07a318e06eaa7a5fe4438b13eafb739d97487e97f85d3455c2fe6b5629d8f7d9c19f4454e608c83c5b15b8c02dc68e51a53c19f1eaf45266241c5731f5e3e8cb0c105339f6708acdd9f19df52ecf171f159830d876fe168d640beda4fa4a974f800a49ecf13bc9ab0c433cacc6dcebb9fb5980e0c47bbdf8208e299914a99dbd2f022840ab27f3906d909b7be6f39bce0b55f7c7b8e6ff8d030b87ff55863ffe3811464464b02387dac1040d6c400e5c1cfcd90c6b25700402f8ab8f627f18ee0b1d14197fcb06987727a31f7bae9c04508cfbc030dde27a94a735f40ce3b86d1e16a58691c4d869c3c76f993618deeb15bcc5aa3964f3415776ebb138e71a5d86b51416307eee3b82f514fa1a1c8fa08366d0b7ab7e965d46ab06df6aa1230a78776c90e2f827b20fa29621d4641913b0190cded7fa9bb38f3606504385f47a727ffe1d4b29f2cb08526bc487cb4a7a15cf477d29c14bbb7963763d97a22c4dcc6618c7b3858e9761aac666a3722aacf1d730fb35321d0ce93890403b3ff096963573757ed80116fd84e0c2d42b39150ba8ec8122dfc3eaef4904a03a02b178874a22641271968b6e6cbacc58e7d77cddb945c07a99d958e08d2b2ec223d672d93ddf174b001e8470e2e318472125667a00ee57dbbfba6ca55b75e00cabd1a94e02da9e21fba8a7f91482db01ef24ba16c18ea575a420ad11f6bad746fa5a9ea94f3982d40a314ef2b37fdb5ee229907924c10cc23a60ce1536571ae9e591ea2250e174adb5dd703e76ec1584b025e2c2a92b35299a1863973e3a3427f4006bd1c8986b058e89ed49b51f6e56f60887fe21990b0c89f63903b1765eb229be48c394a7e152e2dca2bb15423203cbd022c2bc9fe0af5c2291631e3298b4adacda07a1709a2fa31e48cf4b7553b8f0cabd1af36236d29b04ddce14a9f045946ed2a1a885a4bdcf8b8b18bbcda8ef1fc97b97887db4c9f57b9d71490cbd392e52e7973c8937b47ab5350e9b6b6b028f333ed1994ea9143e6e2d927f229948dc41d5cc521a5514271a10fc2e9f8c4617bdde5271530700bc3cd5ccc7b6682edeb0e5dca3c3d37442421476393a6c39f37ad599f8d3aa0824afe8ae38716be0d8de286228edb6614be273c5fb0845f49729f0a132fa46877d87e3cb876e1d192697164ebee8aa5bf7b16ff371234e22e4a0258c0a726fe8dbeffcdd8716f089644e2389833195cc4c509f864c9a072c067e27b793673c3c21009bff0215e72da9acf1cbe4329f409f4f4e914d0f779f515df0b5e6ae4f9c567e50e425b46bf672f072e743584e55555d2456c50854aa625240645312055e2b96e72d96547709a9ebdc8ef905d054644ce903a2499390da0f0a93a3645b584509fa9638210cf51562fc4b4c644b586a76f90632deb88e498852b51b227ae915726799701d40a2d864f415cbc7d7f9aa16ebe8693c1d144974406ae3274d0e98cf994ea6691bf27cd54dfca83be9331cef09208f90c81e11347cf10d2d444691e523d154b42bb77998814c624abf7dc2a85d9b8592d38f4232f7e59eaecf06dfc5de28f54492b793d9be9529001c29a5c8cac256d2ef68327796a8cb3dd7fe5ae82db8ea2e01ecfd7db7b7bac44a051a883312352ec48d79b5efe81837fd827d4816f8cadbcc6a6ba6d6d7cbf2a0e8aec3c59587c62f22e695f94bd100daa24da1e6f8a267fa347c202eb5e80a287028554970d3d0d8f5ca9cd32c47e7e75ea766b8803b2a94f19ff99f21bab5caac2b6a1ad3df45b8b442713ba6c4a74d63b7cad7e05c0db8ea02296d6ca817e1e8d453b74ef6f65d063465423cfb956bb9957201dca3465c6c9186431b1b75eb0f1f56fc71122557ca1f357caaf4e014def47d8d49cec0e1a1d7cb4d4e300f043e44783f6e6686a5745dddaff508b8ac5830f1d08381176b31674dba1d06688f8611466349d7c1e6dfc5a424c4bf8d74f7d08eadc03a36ab5c751b7c3fc0f221c12df5c05421b8615337d1f54ffd7944b8eccc47c76d152157f0f8fdcc6e19a9085d35a58d9d676f99b68ed8e02343cac2487e53a05c9bc2fb305a7d2c968e668a3b81b9a59ac6bf8d17aaf30392201f9d661c87d2015cf9f8562692ecb93350d1526da01098b22cad3aa1c2c10af9c3ca7494d02d7a9c54e3d6042d1ec01a1b386024d9f75869440e5b0119c447b26052e0ac82ae2eb8aa4028436e0315b89315f765826a3143d03450c10cca04253a728b8572ee3a74cf6622b74979dc6320b5d2f0e875f3ee4ebf5137fd9c9e3d736ea402b7ca399e7af47c1345156780493bfa74986f7fcb54824deb944ec5692c0f996831253119e4fddc961b1f7ebe72fe6dfec3265b195bd678fd275b43795feb82fd2475e4f9b1fd03f69cfb2b3635a961715433a007e6b857441d35b5c646f1a484cd03dd52bd28ed09a9b94a2557bc917c5bfb3a9bea7b458d1e9849b4b6d435a6392d946497cc0b1b0574a7fe392f99032bda612e2ad28d582123611daa0755fd6d1bb4291886c505f902335772280fbf73e378126709023da0fbef223ffc840bdade4d0ca384dd23bd98ba23eb8244306f8f0d763b53ee9971e8cb2e46c1632eafbd1afbb1d796c951a4e879db5f89b09586d155afc3dbc37025c1702083e34db856250e76fe26a516f60d8761bbc9a4e0ff0884ec7d96e7a3b0c58e83eb7e4a87f45b3888d9dfa5bca1eb7590c77ce2e7161d1773f889f5accf908a91a1bb6a270d40cf17f88a99d42f6998cc214d15498f7713baf2c6f3513912e2e984cc24546d9f09e13a7a6188a276e78fb007b19328ce89adbe9c30ce8ec2c4bbef7775b37ebd5b04f801fd617f32b63560411c51f3dfb9f310a8a5bcb53e0c3862b32dd72c11ff5ab1b285a175f83c4ecc491a752aba4eff2f995387884c630583db51d36ec5cb0cb558379780e849a802f2b3111be2cdcfddd8c6f8c2538b8ce5c358473aada987c270ec0a5da4dd0ba5012ebfaac944d50fd08e5aaa199144765a6c2e32d4c6259dbab3ab4796fea2cc73f2ede2afc19bf97bf358b82f4e173ac3e1ebc0fde68169655c725c8a82b092d2f9961286f353b0255f5c476c62947b33d520db6161a197a1ccf14d21a207a38e26b331693d14580c95585c10bc8c96f8779e4d4ebf8ca42f8d7aba93f369112aa325e43441e34768fb5cb32ae454a00eb183edb90b98dfbeeaa8b78912853524277abf7ba6901cb87df40e8675f262c0e61ff30ebf5c9df1c4c8d2fae5d3a92ed52e22a3b02bf5f000aa9d04259f97abb9fc242d67a0a03addb4af047818735586762c6a84940bdb6d0945b394ea7ae795c9ecd77e2f86773c35be1de1637aa0656544f96fafc4725181f512971f081f10c304b7e4929606b0df524626054c5769764f807ce04ea8cb26badc456b9d53717f08f3ce60c9149ac97056f57f092a99987e0aa0c1663c3c92b55b82db237f1a9c2509617f41d78ebbf4712b65dcce225750866f0a5c4599f52f962cca3f9c0c309b7a72ea10b8cd6c9035aa2508f184680bc9203116bad40da9011d8d5e2eceeebb1e60cdf357fd6d32e28cc1865b1cd9f59cae014a12774d88727daf174ca2cd267d681f45d7e1a7f1c4936130b3b918c42428855d7c66b6663281da8ae3fd7c305f50fae3f08a08e2820d5c7af15f4261468572a764b83c2b15a9b12283cebe335dbd325b09b3d300ae7588dbce20a677e9c416ead4ff2a5b447957bd4de6763d0aef7b0b99ffa6214f4c57960956c8c7a56b19e45e92f4f11a9561620101456780b1ec55cb521ce185ba1f009a333dc141e7127fb705d09b1d848d38f7f3d561cca01224cf6b271f01d0c2fcb88e62d6d7c81480bd617c7b3f8bc8b664cbdb1c2493909cc8053bd45f550d7fc8930eb3013ffa598ef806ee80956e9020b9b77bb533bd5f0fcbfff74b67b7bae5785d8a3f241f94c4f1c8b10e1ca785a79617b3a54dd5c99cd14d8232362c65abcab7047c268701b4850b820343f2a72aa441a0f8041745a9c922ccc70b8e506bd29e2d00d9820045127d680dff12362e1f45304e2bc61d7d76319c64e7132321d3bad36211eef4987edcbb3a739c115ae229a9b22070f68fbb79f5e54822ef8503bd3c65aa8f8aa782bdf3d7eca08a06904045bd014c290063ecdfa7db88c38bca5fc8402cac40cfa4195220d69f6f30caac2be59bafe3faa3afe49fa6b614958d4dfcae97747bdee4bfae6f5630e7010448bb137908ba666779a2f8c180084b6cf01c4b628d0ffe6d5cc5ad724afa62bf279d02ce9cb88c0bf5cbd85fc09418e0f922cf4e485b386373ee33401d4e0aae1881938dd5f9e7301fd79b83a7f42b6f7d7d1ef812ab633490a503fe15e6f1ca0383ac0d3c436ce47672220d68e68e265f71e8bf98144b0b58aaac335be40fb45e27e0d520a91d6850daebd0a599285c3111eea3f7eed282b15a475bddba68036c8b6395b07fc960ab1160db2767ff47a136e9652bf17a9eec586ab7065edef9ce8e1d57e203b0c480536a87b6f67dd24c8c7a10f3924d0a2f18806ccbee1746df6f505a21e6705da1887b1ad70bdff9c70e3ab69a6a79696cd893edb698b59e4493f46e12b94dc131b3c8694b1354e143aadd0316d22a1ef1a8ede08000a0adbea25f4b20603ccb05bd8df08cce79aa40ddbd1330979beebfa1d015cc74b269ed90050c24322c5e673d24acf85c3d3ca42abe035197783f8427fde766fa889c5fb21a21627659f1e5afff3503b567cf7dcd99434fc9dc87898fd1867f7518bb229a858716ee0e9121cde64afdea7c325d50455496434d9ba6e2597fb3c5bd48bc4bfaf6c7f8924d1f60aea2f9119655f05eb91964f179587eb0e42d8e6e776c04c4177e90e91bb683b822f65263af703588b0e6906f8089f705ba841138112c581de07255d4e3ad9090da13726ae3b73e11e8e8e31dbea1c8b25da99c76f081d34a708181ef3e1c07f62b49eb0beb4366b1997f6516abc8df902d5d487d799c21599c268db899f51c01d75957e77c115a0665f68ca2bcf6a87530b0567d8e631bbda32f71c0edfb2774ea874d0d3c0fe9d6e5c032634911734b8ccb6d90ba70201bb8fa2a0cdfd73df946f3b23ddf79dc1eafd9421ed7b82863a783333dca0ef49c808292a535c8ecddce00d3fd3ffa35fcf810a13f0200f826d51cea276458041a008943910915d4b67a15b8a5de62cc926d3a5636a193a4b9a8e9c61175cac75d875b35a5852cde04214436672f57022fdda7b310876e36762b0d652e668a09064fe08e86a1c3f911ba3d6fdb0c4987f709efd26fa58084ef08a4f341e586903e502c539cb6a815d9c29f06c4d0ea58ca163ff926ac05988c0a61c68a292be3c9a7374aa550b4ae6a8f50601e571746e8d6e16d58120d7480a6093b6ff9d7b120729f98bd5740c2c56502c91251ce09802dbe607e984f249f32c7aff27d7d23e12285b94d7f197f3eefb7d6a91e173c5ed666be747d69cbe8087bb78fa871bebce78a7bde560eb6a850fd1e78f4b15c9272e496e12a2a7d56d5934889c24ed812a74a60630953265e79823ffd5706f6268e862d8edade23b20caadceda0e31a57a836f94c2c5c4266dbd13d0f56cbb724e62a67a52bb3c72aa5ff89859fbdca4a447a2b750d75cce26c9292ff4cebe567af63e5f8f413ee771e66d98bf052e7df4e6d814c51cd73d6ad30a14e2f43ec178bd38e1a96fa290b66a5ac57599c25a964c0db585b69f9640e88ea37b9448ed5d617afdcfd697e04629344df314a1e5af147a6386177ab4f241db999fa81c45be24ec66781f0b49f7683c48c9619fa9568c004ade14146731708a1e91b233ef4a8da8abd0c6950083ca467b6b010d2d65a8bbf8c347bc4832513b355bd6e7447d1e86b09116b2317495b726a3e78c102d94c5335abce1b694733e14a2d6bf5ed7365c68b47a8a67a8834979a2abed18e0ebdd022ee7f647c64b68ed61d812ba0fd01c9eef786648d53a21336aa04a4635e1516b6c29f4f2b7193ac54a8a49d6d49fe5ac83e3afa0f95e3bb281a1c1587524be716dfc304b030c94bbaaf5c1565aad05cdb042250f0ed01be6fd96544b8d3f5e63bd0aa40992dfa4c72657cc1fb3b2a30e5b33551b1bca778dd2ef639bf3411f9dac5fb6d8aeda67ff402e3406c6d1a228a666299324c4b52094690d65a3ad3442d23b4955950f4b52cc1f371fe6f0a5fd8f4c49db92199202faf6966f7e71cf21e26cdddc16f11b237e227f432b1031c228d314d9ac09abf1e6077f2f8d03eacbe6833b184d1db1908452cb9749ae59952275dc67ce10cfcbaf3301c492384bb3f31697af6ce12761b5c6d3d2ea09bdbdbc1d7c8c390d73e787eb9d87bd17da2dd0a0e54c629bf73bfada40a14973c0482b945612a8a307fa7b7d6d4030dffd77c0fc9f747f21b7207e13c52a7cc7c1fe6aa50af5500bf69ce743970f79088121a029064a24a3276927247785cb532e0ed6651ce4463a23b7b7c2751882bcc82583424b57b577164680f6bb61a62d562510aec36caa80f88fd959266e36d2d921d40dbec51f0328844280efb4f7a37ddf8a20a67199afb097013c8ba862243602dfe4137ae2290cccba378dc8e4858fb512f0b44b430acc595c3c83a282b5a60159d93c21128f9324e1d12d08f56eb9d13160dde72278f5aaeba6568eafea42a5c06b43b9ef339e8baacb4de6c8d69909a8526f722ca080459669d47b4bd40d2dffd82dd2f88c2ec6659466561cf295b830d2fa48281b05edc3bb677c8a4f593750ae16c88499022bfc0833de6e0f36afbed1a6bde5cc646cd4278753c7f61fd3207de27c42be60ce0b3fa3d8930dcafec4d9a948b437897e07c65ff8905b756d275011debefd0dfcded1566f5aa1a665d13eaa4337e0ece549b52f531e9e966bde26286d8f24d65d820253bed38c623199a80a63e64194b0dc98245beca946e158d4d2e488958e378557cf88952a7af59bee57d795a38aa57f559445fa8d7a91057246bb1ca179215907a7a84a96fa2ebf402860287167c61fc7c7faf528655b4e55431ac4e43ff4f32d7f29b341649bfc09abde973640b56e710c3d5f4930ea71dc8ca2f8c0cda2603442246cbae73a49291bca30404fe81a5b7a0503fb4d0fe966378fcb051ed766d4ada2628270d9df9768ba552d6946036f576d441925851b09c916c444ae69ea71fa545364965a8cee8ecf49dce96058498ed0865d91bfc82e0c6112e264ebaa2a49938b65b978a38cfe3e104422357e36c4af7bf135ee06f57d512ffda4ef8d5e066e38cfbfa16ed57be11d34ef57c085f31c2345a25baae0d01925106743c114f314f1c26c9d7c93f9088ef90ecbf7b0578f61a41a29150fd3b6d226be1d30a893990024b85b7d17d76ae92dfef2985623063ffc6dddad30b238066e6a097195e2ffcc3afd872f5015da92d0ba403d7bd59844efb27f47a116398da3d5264af755c3a02e67697166991ada8dc65c22154dc78fb5fd1ced7b21c100b3406feea12db40adaaac5c692d269b58a5b42203d7f5ce42407d75e02be5d86f407f9ba5e1f565bc47b09d1431f3f88044316b6ea59764b00141341e47a179df5913fce75cd69dad257af8749b19f463bfa31344b547192064c297cb83e0f55b76e8c87f940b3e07c114a85f79c5c419656f99955e0620b9d09fd139211584baee0519407c21a57a2b5a1873f9b20a4423e47f5ff2511178933399a742b4b33d742c8ddf04d8da9f5d074bd3f0c6b69e7e8ee1e769093cb484b103426baa8fea2d0be2d8b6c6c93bb57c3067dc1056df701d8945fd97422b6bf70b86a4949b35716aaad234bf4ee7bd64bec63da01cc13684f935524ae8c2494ce15fabd6c800a5e05092b3edf6d340b6812cc2718764bb2e3fb3e17383480feccd2d9ad2f9b356448032aaf231d1392569f892488e2f656ab1a5c1e57f2dffe8598b5f268c37d85151d24a9866bb0df96a6c5e65b8b3e46f2a8ea03afab4d5c403678e78b445383028fa7f0412a449788cb96e6ad81b840f1f458e90555919d629812e9c5a1c886023eec8a8ad8c20e3a72e908a9fd5c710d7a97e61e76100e14e37d85f57f4610f11080742e21df75d7d634ca8df15824282d2c4e18dd4606514e6ba64d894125a275af2ccf2fa4a9a670b069a06e6e5af2c374d23f6125d4395056634d41e5fe89a46d16fbe95c845c5fc177f8bf21a1698c44c06a5aae17fe45057851c70c7da779e15f75b056a6d7ab74b40a6e11daafd171121632c0d4333f6e2aa350ae8333a6d5bbb679177f6d85929479cdb9f915cc95109f01bd8abb23dbd5d62ef3d8a9b5328937f14f140642d1ac47fabf60457f680c3b8de544974648ed532fc04c0c2d9f1d8ee4f0422ce8bea7c35758b171e7d48cf59385d5ec673631d7fce3c85a796b433a911d37b33816622606fb0816677177a789d3573b93f72fe4531804b2f9db812550bc30e514f43fdc4e2ba2bd0ed25d2c09299d1cc6915d670b95463868629bbc5a86e43f8a66bc8df57c58e7af7f2b38742ddbd7f7b4184e6e881e51a431073d964ca81e4f5bf616b4d97e9ff8aa48257a95ff7fd7a223b8153b14985e1cddedd5735a12c204bd7bede89a83850ead8d376f6729d7ca0c5779542b39587d056c216fb8092e7a64df379bfcc0c7e63c6e5ecbb3c05a02b8d2643f50dbbec55ac1034011d2e67a01f7ffb1576388322f289041820a40dc8977388c622581c1418af65a82dd93c01c7f6329bb4e91827d2345b8e04a2e3f0ae69e553af9277483be6aab6863dc76d606083176b2fc0b2e86c41c42878e6cf7e4dcd7723add7469e6f7f5f94d6519238984b0084d527886ade476d11a70bfce1594c3262a66246786169acd5b85f3ee8a367e1184f1b09bd6f1471b8bec8f14152a6ff9747b6f26ed0ee5359b7ac932b72108fd0332648ebab7c6381389d0ef2b13ac9ac789261cedb7f30b784b2fff232c0e4e76d1c50ee9135e16d16c1c6c19f3baf18a442a4a20e6e54a7a0c443e73b9dffaf90f5e1b674c55ba3f62b50ef1d9bfd849ad761d46add8a63aea759a55fde4fd63fdc676998d178b8f226a7c7ffc5e662655a8d4861df093dc2c3da69bf34744f157047b3c0a7b946040060db3da841131f7862ae9989a594c6c92b8160f0c7d35a2ce12811f9f6853e417041c9f771bbcf3e27904130f5d6e583eee1bc1e20dd8ae89f6b2026410422f82d0f2ebd55f7ddd1b8d214b4e7acf6ba777cce1211233f05828a1e4bbb2a4843a75cf17a1d2a9fa2f2b7ae8f86c57b045a8d466150e07a969735b0649a671b4ed1a6161c3e42c373f762aebce02fb3a1af3adacc8686482f85328b03226115cfeb9a8eaba9aba43e47277beeea0f5daa38136034437c2318aed4518c0141cc8e86f4daa5719e40c49d8f0103ef276e586bcaa3a1ef896201469e9929fb305d4494590949385c87dc811f4ebab6ee788a9c1e3a2303e914bf7ddce0fe7a20526e637ec36e87a079914795cf028542bca0bcc99bd5ef34319bac444d202f86568b7a066b17df4cf17a57e5ec8ad319a29149ec11db8a59ade017a42a43c4e9c38b05a1e3a9dadbe407cd5843431304938c49b9ed6566942b796793de4d9e30f2074c37b326c39bacb016af1ee5cbf818c4538395ca06650b39d54043844d1a7744f2eba952ea901eebac82c823a16d9a036eb025e53189bb4a20898769df6540dfc138c680f5e4ce23016eb60460e4bb76b5cad040634a8154bebdb0f14250e06225e9a2bbcb8c67dfa2f873500b456bd24c3c6e86e34cb1a894d3a9abfaa817d58fcfa57d42ed693963432db5878813cad6c7d071e0afc81c42414e44f1ee068ed850e3da1ebe8fe536ed951e5a9f5983dd0e2fa61554814feb3121653c04c706377c882400e47020425d86e1a7ce8b383e17d46d318cb324cef02ea999506c58eb7b5644f064e385f434ad5cd81231b95311c2d52bc1da5b9d9aa17a6bdb078297edf26b6a49e726474de5807bee5e8153f8f38ea4ba99ef2f8537ca6ebed0f59fb013bffa68c11483554bdf298fab1f8ddd4803aabf7ddfa64552a74891ea1653a5c875acf703f526551a798d418e964770fd4d237cd3ee2b580ab7e0b986af3f018adc6fb2bfb4fca0a161f9d56482a7e0d9cb822b78a1a56630e48a07d50daefd2e8da18cf3851dfa80fcc701cf8920488bc8a5e8486817cb2a629cc01a4a95996d7ccf919fef3074feba6c187257c85297b511d4418de7ca8e745a3794555b20c0a04766b721a132f8266060e3c891e2cb23306e7122bf047591fbe5b11f761cf5117d59fc4ab089dbc56dc816d031d54038f2359e612bd6f0c1464902933c86704f940010d42b009d06549a06b4f0b1f34c5f93c4c25cc10d1d863893c1ecb86ff38f4fe9fc1cba24b1c1115f53c0c158d929199a0c22c0a970bce63ac1f3df44f7a379b21ae7c13f122fb5f2e4160d22734431b2a8e39aaf0b79a9a06f85ce5960dcdbf073924f4732ec3dc07d025ec13d0e024c5781547df6f1a469e708d2f7b547373bb5769428874a5e4805ceed673bf8fdfe3503fc193757898713b535921f76c79af8147fba52cb365f1866fa809d261d0bd8a04f26cf2a1a6e1dbda0d539adffd3838029d3ff288d6a2d4470da3d98c122f148fc2b32b6318916726e64ef29cc8259c80767030fa0145d52bb6d759f86eee7d62845c915f4c5088acfa6f683d0d02642cd9b552be6680986dffe98258272101afffa69380130d927a5de003c330d87c1e04b7f9e3862bef47a2255df4c43612a0310fb4ac480190ede9236db7d0170524d3c1dfb45aa216b5451949ed52439f402411daf0f2809f51e576c5db5d91b89e58758badb05a67b048a79c031d8e808baaf55927438db0aa8508b409bb08f7a86fe87ac0ed5de4593f3e8fddbfb94f99b45a306740a073accde1b210a8fd5512a980035c12c26f2241c3ded34298bbcb6ff34267e3d78749d22249b8ee79334530213e7e52b7b40a7f44b5337a25802e0e90d4a6c69ab36bcc436e6e82af805f5763bde8818902cdaa6a7f25e7c34e8395941b3891fdd565f97a19c7da4b213d7ecc1a9c4fe664aa06804e6b152fda6b85df04ab21f6eacac24eda54fe6b70e4cba4de639aa95173b4394fd4ec96aa1b69877f3132aaecb232889549b5fb033787ce4fa44b48afc4a3f473c9e005ea7cebbe3a8a06eae2cb79e29dcc5b7227818603404b11f11028a8e85f8f2a0df6665087d854f22620c96ef6a7905351b6aa75cc9786bb3c7c117e5b7dfd830e2bbe5e9d3bc9cb5d1b9faec00cac36af99bcc8ee7aa5ba53b32d03e7e0af3699d4fda3becd460564a5fddad21f78642f39f423698f75bfa399dc2930b2e1d42cc79fd0ed9ebfedac7613aa3db98f701fa1cac6d4502b8121b8909888956960eff8215b4190f821a62ae26fb4badd5f49cc334243f587b304b11958e1ae3913a914beb5482b78407e1033bfae5d86be0ed3c0102638b1d0b102f77eebe17752b5d1b8a2ce52538b518cb0bc288156c8484f6076fd592f3a534076a724678409e8baefb38560fabf96f1352f7eeafb51466cf56f71b534a2cb31195ad957eac06588062097038b70c80956ecb5ee0fb9da6b47182bdfc6902d61d93c2e3c4593ece98f31f8aefa80ff5d3f3d95d10ec0af2cddac94d8973ad010f4f7d37343a47d7ccfde451a0d3510eab2f9015825072a5383b556898779e2ae8d929906ea2a08dcd0a0adbb76795f8e5b7dfde6f219f1125525793ffbdab1827f4c518c3384aa20e3f438e53643c39a18d0ccf7bac2e93378151e7aec29a8df0540cfdb5433d7e685555c942794ef67bce6ef0c6f8d853becd7c48d7bd5ae7c9eb2152e6e5dea2777aa57e6f5ca627dd12f4ee0f51f18973d9d4ea19207aa6f67b3b28b5e27d5c6f0f2672b3438d19c22e3e43c2abb981ededb44a3cbedb96e64aabc0baf0dd594884c8c552a12a5acd5bd98702b1b65b255a117dc5292bc16c4c0c990c56e5a45c6c7a939e0b74fee95b070aa5721037e95996ba047e055221b29336227a9ac37a9ce7d8bb69d7d4190f803bc919da072bdb7470b8e14c5f659dd1e7f9fa1c6e25e49bd83a2d306771633d9f13af146997c4eb9d823caff6131814fcfbb8448212588b9a2735ed05f776a84e63ddeadd9a05e83289b54c08c98055cf80aef2fafce1aad29733b1be7bab33eec3b3e7d22e7e345e1d8284e8b96d6f657601e0108b59282f13a89126ed4ed5e5cd9547af42408063a0ed9559038ce2e897dbc9ab5a4d38e8398e443517245eabefd96ce5ad06a42e2c958d1aa09f2038b7793644f22d1f90b6581f0bb214b0fcf3ff983cb9d63591779fc0c9960a243b668a8c7c8d3bac44a6c92db66610ba1e72d643ccd56124737889e743df80ed428db1895e8449b6afd33e7f141927ea150fae644a201d6cb7582f912ff274f6f4f6c780464b6df1f95798bef2a8222226a668bde1527ef708eab92f20d2317e9abef3d9c9c15a62077f3ad2170802ffb553add879612eb8cd095254370848f9def9bae3e70c3ada01c8f89a673efaaf7e88a4396f1b2efb172af7fc8fce83fd20f406c52498a28659444d97726a41c65e4ba8a6b5300b30e5689bcb8a8db8964a16854ee71eae148101be03704b7a0746a9450318636cf7862bf84119f13a2fe0876c4b6655ec6332cdd6ca252b8eaa2c7e1f669177540c2b67be6d12e1d562ff97bc660801e9c1cb0b2622b287c6cd33abf4bd45992849c13d8521e3dcf6f49d1b97508bb8a8aa3aee4e70cf2f86933b86232a30b09dcfeb13635b72c94a99dd81bfb8ef959fc8d8739f87043c639a04e3b0f4223d96bc2f47fe7d3eff3686183e084c83eb76d87a9b6552eb4bf2c4cb0dda0c81fbe4f26a6388946528dbf197db3a4958a9b94ce4b48ea564501210aace14f46e2433dbec61d97d6d896aa30332c86665efd61f4fde74516cecdba9a0df896cdcd2bd7badd33a5a6fdb24fd443c7662c17deb8e279a5fd83b441b60d73a8e23191b953a93488820c350f419bcabeadc0406074e1f26464e65d841bc589398bed1457f850646fdc10b3d7d9f2c91123198b587c67fc722e65f847943701201113ddb192f57d6de243109f1a6ceb29da24beb1ba444178ec84af2fa2aa3e22ff2880190c7ad6715619092f3aa502ed50b9016d5251f67adf98b37beb90fbe43684cf2b1f8facce1d6cc67abe361ede8a4e97184970218e34d66f5b39fd1d7237328ecf5595ef5043658677d203e644698001f0a8a2174e4c546ecd915ba46e0872ef14ef7ded63b722977c24bccd86ed6344c535ec81c8df74f995181c5468e50f860689665288f82ec3ccb85e90d34f3917231c17bad8d4560240244ca0a1b89b799413f5b04da7ebd8e0e0a926e45059c55f8361489d0ed86646f6275f85feed9bb376947e58c59230805f9323bdee84823c081b71264e5db77432819af840016cd617918e0571eb89fa9870dccedfe8882ccc2426d98a43ccf670274936fec4b142ec7e5f6a4afcb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
