<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55522690c845a6b7b6a4d2fb5a7a4d923c1dd6e9cb76a2f40b63ae81f3424d2e16c0810a1ed8ef532d024c3be30060ab2663442760305646186bc9a90679c292d05495895a5fa00af02838fd80f2551436560312990bd323dcf5a3ef32f127b867a9094ccffe736451c0487fffa33454ad18602ba430d0915fa0f4dd5a293bcf5efcc2314d06d3f52b15eb842d7a6e8b378aa458c055793d724a65ce1956f24154c730c0c84ae5272fa7071b6c8734c0eaef152c41311fb0e3b3a4126858c1e4f3ee22b8a99cca2ae9443849d5b6afdb418c231e633e558a42f900b9b08cff3cdfe78c55637487a64de5d14ebfc73b241d2df2f2216a41675b28a4f6be8dedcbea8987680376f41142cfce19844a5730899c6fe335e5a82e43119baa5c5a576073517b638792a38ddd7330431fe9e8b82d5d235c742bc7dfc640fe283f5fad9a1c738d8799fb7d22305a4d51aeedbadd22ef36f7f67e8fa8cd3d27dc8ed408a69f7a7457da244344c7947986bc5f6b14cca388f9c8c29874c959b3de2b36373de03e495e3563a1154e6f648c7e98b7aa5158666dc14f23f0005b388d62f9847a891030d4be74ce1d8fb040ba183b23a1d3c503f129fb1aea4066c805e8de489b63fffaa0378fcf6549cacbf5504e17e8726b422fd3bdc06af1df3f51e5b8d3eb5a47e2310c158d285e71377c2b8288b7d864a90a6fc77be81a64e2a1d31ec2d1ee717f4fa2db72588c2f28c2703a628bd3bbb91b82986f3f015dd072305074c795dba464dd0313b573cf427ef1095c9c819259bc662e04bd9328a734eb59fd1710bf93e71dc89966cbf5b3719f1f05db7a626d2199d0a9056064f6710c686150cf077afb0daa438567df4d01606fde5b7cbefe718bcc034f904969dd29702994dbbcd17231273d6413ad97af1436c6f81a28fb7d8440779842a712baf9c7ef086e0c1c3d33ea18c1ad85ef430db956f5582a77b439974380bc10cefad034ca8c6ac482032c5fc84f5c527bae196e83efa557fdecca89e7d54ee39b35d52da9bd347e3493d05e587390a5dde09878fe0f7beafc03f039f62d3780241136d323d2107cc678d77d5287d531afae342cd4e6486676c40a7af0ebd9fcd63bb9e8f24c93aa9db60073c2fd219391b9a9770b238eb14e33a8a59c77b06ec7f4b0719a0e01b055c2eda88b6df2a5f0cf190ac5f5e4ba3febea9f0fa1af149693dafbd3da7e1f975dd1531c9548af18ec000eb4146cd5832e04841afe1d9a72bed22f6995ffe1e89237db77d1fc1a9cf3812a42f156e6323cb702d01ee62233a4154b9deb47fa0206416024f4c905751ebb7b061075545a4c6819e940327c45d543a402c6ffe7ff013bf1b3c480e8d1c45f0fd05cc57483c4c444fdf4858f0ffd89939b5547d21991e02c6b7063a86031174ec6134ff36dd9510f3ef5c151e249de9b15f3fbe914ba96c0bc037c8982c1629625c7337670ee4b6833a3d41d2daae033f2f63bee351b9e349326c7dd07c898910c49bea9553b228884c77669fe58f28b3b49481eaa5b9766415b2a051f9af87fc0fea6d981edd80e7d582f3b868851196d28bfd20a7b2317c8fb9d33c3e65a021e1f463896f8acba9648047cd6fc1919ebf9278eeb64f7251731e9a0d6635b69efd427b66c3194eba1a521ddb9d738c72a493b6b437872fa68abb31495924ad9ebe0ff63fcc7654831f262c16984c3a127cea3e2da474357687936aa7e73110a3e06a6d29b28e4e06d63142b04f18a59023355d694bfec6cd4363ee49c2a3c4f02dc6db2d2551c4afe267d1cc31f0359dc682b377d4e262e9dd9149f2158891fc45e96edf69d10a51b6fa8a2145261e206e9a7c814d95e1a34d12bf7fb981063bcd4b66374e25f7130a87643121b096f0f3b2fcacd4595687dc7a73e73992a8365e76faa74f08c10df9ea6b8f5b2a256991f84881227cc355f152da1bdd71448a5d46fa329a4272577042cf38e64675a21f73b618a96560a9a02e8d7b3901adb5c5726f4189268bdfae09b4abcfc540c0e039127ecce5afb64bb56c0eabcf8302f1dcea0d5f1e99e79d0a7e6b1d1befc8e3ca47b434ea007b6c64aa389884ec25d3cefaac0596638a35e7982f33bc17ca8fb73e649d895627a5bad6396c5057657e05e878857593cd363ef1d44fa1cfdc7401c8ec99b60f4c2c7eedc78acb3d16d4cc4fe0bfe91c13be3d9d2eb84e00136066a072d30763cbf1ce40b218611db65aa55d4734ff44848a9c65cf84a241f858659299c8f2373ad474b4328adb8b6d431eb4dca7cd28e576d2471ead90b17fc168a8e7c0de5883189cfa337ed17885420b96e018efb651ed09b0c63ce23c32a6feb9016867f20bd19bf6cfaab8f99c4c711d72a4ca8b328190cb828b3b76eb7beda5f7bb25cd36c789d67a2125e0014d6f62a78fc245f35f4d5d993d4a900588a7710097b49c76be1b4292ffe73bddceffbc194403814040e64dc178e471aa4072d6c303ef9e8b6a92efd40d73ee495256f7dbb01bd3033cd63dead5d34db1adec5773eb28eebf60bd94527a5d7225d9d0ec0196bfbe59518506613d37ab435ede5d0630ace63b31ac1eea142b5b9b5c5202669f89f72e4726a042843ab43af35ed55dec013836ec4ed0d0f669f051251187ce201433587f240fecadff114c4b8cb5462e80e3e8e1ec3019c02db00f8382a2c7211a10d2ccc580853f5838064b8bddb1660c505063b8fe790013e510bd17a6b469526db38d0f946ec5bb1c2f0759c9fdaa183670d833599b30407feb7e3bd9a6bfd2e0de2025a84fd4cc6523114ec75330fce2f13ab42472154309ccf950b598cb90aacfc60a31374872e7ef45ba4bad75a59f2f90c4dd35411aa613445909dc40619e729b46b8da860b4b9ad7c1bd5391eb77f42236325da4ffab73fcba39df31f1f479ce94bddb9fc71c1bb4a859b20d79ad72ede9e8cc10621d5082f511ec37b2d163933b99bf4b399c2f3a746dc697a1986d2fc41e9eded83b56d5171ad582ce07139c9cbbb228912d23496a9c6c21ca001e06a8d4c8d6ce4536de4b3036d747ea0b238cb02597d0463e69b8923197b076acc37c25e4d470febed4b8a114287db68fff0022a686b115bc82d2759498f1bb1e8bb6818a33f2f51ad078a8ceb70c1a7348e9b883880b15994c85f1639aec55fd3633247d55b998a2e42fbfc5ec6957977db7aecb3e312766c0180aaa889b46f97d4ae1f1e0f5f8b1612382290f7357d0f4d29cd176289862cfb53154a3c6dc0ca4781900fcd8d03f7c176237856ca12684b688bb7dd50154e72c1bb22a18c28d03522c6b01ea97a4abbad7130dc352dbbf752133f81f9a0ec1f529dd550ba2e8ceb4caf2a671f9d6eb3dc7fca0e07a82db3c6a565885171ec9100afcd1c91c1790eae5b16d0025e19e08f62cb028d4bfbad2aee4e6486128b2723f21b785b40260b58a2666b9f358b6964ae16c43a13b852060d693a11460c8975b7b74b7e829fc1b7549365ed22443f8d2603161a03425422aa25bd29a3a363cb4c4f15c694748d4f8d1be311829781009988dfdd9b9e7ffbd5241feefe66a1da4457bf8f24372705e7f18265774740c6ca1c6b6064190956652a6ad2301f76c9b876daea1452291a78cdfeaeae3976e3db7c358d00e5626d80b007d52d98cb74c8e84e015dc974a0da10e5224b46f69016b4dd565c2d7e77a81514e834812022951c03cb2d9a6b9d4ea87830e09e40fa61910b4cd9bd479ff272ef605e806598993cc02e3907081f8ac17f797fbada274cbfdb513b579ae4f80103800952b98f1d863ec66a6e81f5c6d4c111cbf5c9ed65edcfdcd7fac7029bbf907bd96dec24741c2ca6ad229ce800bbf3a7a4931da7c9af09d728b8cc1a064e84d58d0fae480b8be66ceedd218281a62e734ad760433219f58308cca1d96920cd5b681650fd35638f1be405896611999705b8065bd02f749c031ee9e1e89cffbffba8010a403ed0419b8a561c682e18741503fb527a38af1b8c94c46b6c92452afa1904663e6a3a94067d5bb083ff61f20a861772dcf78b4448371a562156c60e00e31bc26c4767477057075ca600605fb902e43b1c6d446bdbcad577dcea510c750e5e826646f93b3d1b4f21641d0409b28c28f6fac9c80949aaa1c9544bd1407c229dd6c3cacb4d502b50c5c15c20f8a35e4a0a757e46099cbf0fd524f7e3c47bd658f61ee82fc1a5ef4059dd1072d82556d9d3982d561a8eb59e898600521967ef7347004a15a373417dd2fc34279c2ae63a60a0b7e9d4698aa7e6c4bac832c22f2acb1424aeec9936d39796fdb68fe624f8adec78f3d0ec7eb5959c3b77960b6a3d20121f48e0fd5541380528a7b147534dc975125f6be8e2b4230867534d1baf19504ac1ad8cad4f7d4947d39c74aca3df940a499f6bd4b99fd1302ea1f9bc90bb2899293ef240e8c952d632242b15e057a55231d8fb113e3ca9c560ecbac9bd6070c3769102424de96f01747b1c186b5f30b7f7abad17e2d1bce1a6050bc2a14a9c9a0af80afb63a5f7723fe80ef5f842d6b02a01800997b525257d5126340b1d2241994c9e0ad63331613b45f6ecad7ab2a8213951c6d01920c6617d1bfe3fa4a7af7c3972375744873873cf0e3ff1b4c1d9664c6106079be940d772eba8894d211c12182e47fe7b69f8942cb8afa31f05079311b5869dd8c81a82ad3e8f863fcd5dbf2be0d5fe3f8a63802bb2a61ac183119f6d769d514622c941b64856491c8b48e7480af7729ef3b5b21762497a0fa0fba4baf8c653a7e14d0cfe169ccc39ab886de4d05669e90b10f61a15dc47c1b8f98e29134da9d5cbc2b4b7f0b42e7579e45ddda5bea164c51825a6120a51c969cab995be47130308052ff7a6011ce5d9a3ef5c25d34b0b4b0b528e780b6a8c86bb75e47745e006c459c57d6eaf629b22448c146366ed05875ec9d67111bf4907c073c0d66abfd44d570d6d2b83ca847bfd3caeb5ccf1216e4625c29ab6545ca826b5e80dd7f12a106b94d8869dd6a4541c8ea7f0130ddfec6c9ecf0333a06d7e20d8b6c8298306d3396ba33f969b2954fb0ce9f0d312f70151327956cc667508b8be86a551cda059e61f785851899426ccdb3b3bd02105d85e76b10efe5f223017fedf52fdeb1a1f674d0428e5cbc7358c5d6e0215ccfd96ec8676704b02b6d70b26d2f36b8988fa5e30c8976f033cb369f7ec0414fc90e7fd9074342546c49352c363bf032d2110a94a33208efa29df9738f28188a28f97d0fe60d5fc48faae18f70b385e97d71289e828de183b6f7bcb68847efef5e36abcdc0b3d5ad5125c35d9a18f515af1e48e1923e58eda4b5a837e2d352ff308c29b2b68d3342b14ecc828f948549cecafb8cca808a5c793af0c3969ec428626fa1d24b8d9633ee4fbba61c11c5b430180a0d818a484436671cedad560f9688e205bac94f677f735c184f6a4a75a1a2438a25d2519c7df534b4ec570d0b0fd93373bb0ce13cc33f56a3f8f2e6c21a803de735e697d3a0b3816a85ef456c823c394f54a13bb952a591b8ceabe764620b87efd22754197e8d5c387c6bbbc2247cb7b6c9f52f587b1ef7fd3bce34b7e6b7ef1c69443e686b3f2d6deb357fccac3edf89f7528dfb81a93f512bb3667e2721c06b88031a7b4f15cdf76b4a2bca4a479500882163ae940b35aaedabcde92c1a306901a51632e2c7d4f58450780a2dbd795c5e858fd1c386605fb9bb423bbb10b45cb0a3514fa651cda39d288d0be9c065751a0d4d7cade60ece47a80fdbee1003810c21f7af2f74ff906de7c62550ce0cf065795ed46fad64e357cff589f2d89706b8a45d8a38944a6eec7dae1fa4c510ecf53122af7d44fd12a4eb430e44291abb4fc857ddf1221c4e13f5661c087fce6e5e53d50e4d5082cdfab66139b51d3f9455ae22e4fd90eacd620678bc00f6899c21640a7ae4f1af1ba7ab612856dba32ae7ecea364cee806b3d7c312155e58c92fbfaba62df363725d0ce284042f6bebcca9fa7e4a344139f4a50b19fe5dddf949cb0122660d13121339f34044ff1ad115cc28eecc7b1b36ceb2717b8129c8368a94a52901e2893919256cf0881c6e07dec8b682d74ba388f8e7758d1ad3d043419f2bce546d3ebf4ac1d80feceb08610bd053a4da7051c1db5e258c26ccfda503db1e9a5f705fcfa6291fdf9469854a02797521401b42a282063de8ce446fa05dfaa48c85ce95625db39c12392e2c1c756616ac1f10b61fa695147ee1673ded193e8356057f6163edd06648f908c1264a0264554f9552024ed9f2093aaccc1b5fd3c98df968088c833502c7a755c05cb651ff1928b8922d77153ac59ae7a5c25d661ae5a65e340257d312bdab11045595751a691552af01bebcbfbfd59f48b3a989cf4b5a8cf0a34759acadf05d4af2c15bbff0befb92a700035805945d9cd3e24a5f825aaba98f3581bee6bdc1b44d6c50f39cb4b15bb6899336e5d9f96545a54cd97d4af445d11a2353ee72773d7dc5fb917be660fb1a15793c3f00c0ef1dafcaebdce99bc75b998434e312a8e8c67a995f653f9c6572e7770b18e433252e65d4fbc4e47767e4e2d830cc65f9d42d51bd9ccd4f9c1f92aa6487760c5ab1d64ecaeb4fca5ef5af2eaeab3645787896852ce466d0dcebb3d4ad52a4cbe2183a310d0c70e5e06d0f18eb91a2d543ae300a7c49cd7fcd7e83a5fc55eded96c02065de58125895f7821750f205a7d11a638dd61527b7b406e7b3bc43d1718517209b62b6e992e1d6402564a5e4458f0c25ba057ec6d1eddb44f4a1eb533794f35be287f28ac653fdaa5ddef2aaf1f863769608979d606909456581f17edb7784f51541774650f55a5dc77f1e6369314dcda09bb4dd6946cd08e26de7f408d0a35fedfe338871b9634dc3cb8431796c8adc2217cd573fc715c371ae0a89b0332e2218df3894e621ab241c3b051d2e4bd4b57a02d591082b7b64a3e2b1cc62e3eb6b1577404adec82cfc28a80fbb7e0047fd1c5c62271e1177ceefef138a78422e356113fc6702d15a175af1e5ab944326b195848210de7b9f6997da851bb1001ec682ca8ece56b12c83e305f8898ecfefa641988b98e8167e834bc6815a0cba5644044460a3a20c134e471df716922b724372842acb5134427a19aa2d3f8851656df9dbed1b4d4c83de422d4fdb23875d829c7df5585a50fe20948b7b7ea800bcec2eddd97b8d7f30a661d0d94c2d32acd36c79a98cfbac9af8aea1a009e89fa740fe829ac325cabdf2ae664ac53c3d3fe5f0dd0f554053cfc4e457dea6cae79a9018e55fc80f8bef082c2578b2be1fb3e4d0500d046764ed8784be5f34f264ceac7d9b121633cca0977edb579fa385fa0a7904f4056ab5b410ca4106d19c565a6fc553f8784c4d1690e0ebf1b4bc30b5e626244ac3e6548701503dde6ed2a9bcaca949fdf996054a2015326642070ce06aa1a927975a6f35f952662f5c67e55ae55d293a498f218bc3c114b1691caa79220a08059e841f9b659d9d2b0092d900999c3618091771ae0fc072dd7057e894e539717f3d8bf5569040c0cb3c7bfd8950d1d02a987406c07d81562d754b42b8439e94e3ebcb4779f63765eeef82c48f5c0d45c68c51214e641404e93279a8c3166f2c8086aec4939ca0a93a2ca3572aa8797ee93a2e79f57ee27b34da0b61e6e9197180034707abb9e00a2acffe5e22f9ea3522f2eef8df020aaf7089eee970cbd98086a97ddbad967df3299dfda74d3588571efbfbecfa3414986b31c1560e6bc9bd5d30d936e251f5336d8a8ede826f732d7a00fd85e9353ddb9e16ce041a2e5dc90261820be57a34925f3e406ce122f9d413401faf93b28b354d0dfa81e0849ead5ac3acc367f6ec89b247d5644da8f2927dbbe7d9a5d34c1f38f899f6b557db262da96a2e2cabcf5467363a14b6e07db49f1fcffea79c95e404895afba0633c8ff6b6ea6e67d53131cab26c26dcc8b564580a4163b50650720cf1d49fa56cde55088e641c557ff4e7850db8733a410fcacbddaca8ddd45c48322db46ec3a2bf9a008e3360a00f0466312b0c14defad8d09f878bb7ad458fa16d135d096901e8512a3157266ac160d1d082eaafd32fc42508a42205334d2900a4fbb2549cdd79be87b8b6102b607fd630c0282b95707fb4fd2e534384d37e51554820f6371d21e1161272d62f0f39fabda4539e686df3b7fd6b5cdffbcf0eb9a4f4f8a083845675a1cadf7f1695ddee841d198bb48f329f3447987c0a14a5c07300f7c05199f1cb32938bce9a42ff0ac19b6af6de921a2a1470f593ec030ea1a51bb64e1e2de27c9b25d85d3d7562deb0f5894843702ee32ee901adb4d2aacc65cdbb7dec5afbafe44de1b1264fac780566dc7ee1f4cdac8853ca829a3e4d2ca89193031372c181381a2bad56949964235d64931022c5f0593b36436163adc6fcfd2988d26ae24558939fd5a70787094f9d927830b9caf4fd8d31310e68da1ecd67de473acfd03ece16463d382766a58b0538355918467c411bfa20cce02aaf8b00f02c5f80c5383184ede8745b4a4885c718082a803270b7fa53d6077483a338a88e40174c0dae5cc18d4ffec32576c4bf5b7b6bb3bbf599b670de06f3279c2f149886bbbd7a6f71e8c9d925b6e323172d2e8abc36116ad1a98863f09b273905f8ccd66e22baab791f075d69ec7ed3c09de07deef81826ab54990677079ff62ca87dd154179a59a3dc60e5f5e7728d9d6aa9b404e2e63f9892faf38a9cb6d985ce01c1b62ea22b651414fcef719e3917a3cc435306b1970abb07e2afe2186a596e39ab153696f97856299e5074f9390aa2547e2d8f7a41e99572586d5ca057baa7c2041348a46079926e491cca663857b9b8e0eeab7c32e0de672b228356f679e2a7d54278329ac9498efadd7f2dcaa4cb7bcef2cd44a4e7437513dd23978c130a5f9effe27e1684c9cc4d5c86d0044c47dcefb541cc6e3cbde5e8e0e3c909af47d1b38968c76e5634e7633946cedd15d05ecc9dc373d9b2be038526d88c0330c976f2f90d17687937b0ab24793f19b44880b6fc8ca4b472c0907b9719a64f88ec8f15d431ccc4aedc27f959e9d9c78824b3c88ec516cb6019e194927f3697b19193dfc0b661f6cc847b08a42a48fb81d195672e1a452dc4ab201ec1fdbc9919a62a7c942a104ef66b3dd4b8543b032f2ad946a140a3c0636619afebf57ae1662162375f415a99d38c45c09971b6f0f2d4b93aac4053b5f2cf111a7ea27eb73422f2ffb55dec28a19e9d973b5f118da5dc332c392d3aab569cba3553ad414038cbd58704564283912cbc906b0f5091d041b084a7e9f90662a4fb9609c8bff2f989921bcd7824c51ed5eb7d3f667f714cc2149a80223d072217e9edccf8916e674232ca9c4141a70e0da1cfa7e85b9e427f3a6d05c6d5ac25ba61151556ce965ded063f878907b1e9195370d3dc60053419976ed231f80c07a4d2cdfe08a6895091ff7ec7944e0d31811ec34f3082b83e03d34d7e0ed13df633640fa0a637bae5e4d697a96f827a8b245586223c92205b35ade8c5e2ca3afeacb1652d5dd9da692266a21bd965484936e0db6b4e9e0cc90d0279d65732b715243bb6c11857743887ace054ec3d79152d1d9073ea2aa0f0137f7ee3b804e84920f6fd98e7190cf7e173470933a4ccf1931230e4814d63641ca95cbd980193fa86887891ff4ad1d9bca748ce4091e567056bf67f7cc032cf5e82781a5b1dc38ac2cbd879fdc39f183edc5dd9ff0c08514efe88dd00fbdfc35eada26fbf1d904f3a28a8a720f99c99c8df606541e59319e2b463ffe6d5b02e04ddf3cfc617f75b088503dcad5a4d8764c531564cb42724639090a2257377efd216e263ca484eeea34cf19fb1b09cc9dc985aeae7fec927afa63078bca3de74d27a4b974b6846c502ce84d5f02ef818624f25b5710da2803ebe6198af3ee3fb4275e79f884a60d48eeeabae372a426dfd4a990af4655b30aef5634dc226e3dc562efb6d5076a1c3180bb893b006618504f49f4d4a7f9b2b78a68e7ab2ea786bb1fc0e78d55735248c422d5bf22dc1d7dc59c1db1386a66ba4c2e6c3eb246bc2ca17fe2dcd853c2e5ce4fbfb8028caaf7de9318e62d61f360bae5f6cc6f58072efbd76ca857bc8e67f390df59a572dafc30e3f16cf0b0212cebc401110accaac6af6875d8d4cdbf3d0ec6a95b16562726856220226a2faef7bca88c9353b98a39e1c16582451102d5ba5c5684b8f6861b7c38303b93dec01ec213dad6082e4e04b7eebfa443793f1447533c36333e9ee77a88975323937674f4f694ceabb14231794038f748492780aa46c7a03b7ea4a687d5e6e930d1ae3ba69cafb99ce5db1cd89992fe27d8d8b1e84b217496a6e6cf8eb27bdd4609af41cde1f97f431bcfa06f6dcdb0b17c8821a4d641985353f2010f5277c18d05ddd1f44e01f1db6c0b6176529f14e8ab72b1dff2850a1bfbc87791c0fde593ba1517d172fe208297230b4c9c10dd925abfa8c7f94e90637feba5cabd77dec24ee0e157e3835d9de46192303e552fd060b9216f13a22cf8c58fa8ad8e0158d2e7cd2726374a1303f6cd5d8c703a599df3997ebd5c59a564e643d24f9457fcd92487fc2893b17ef4baffc0a051016ada3acfad335976a9cd938b184014ff6e1337c271b7bd63cf3c3ec966ee1317612ea442ef74eb8f03a3eced57a3fa08b5c6bf6a68e6ad1a85f21cc87d2ab13155418a4f2c7111bc7291708e996c3e7b0139027b23f29aef158849df4db61f38994a73cb6cc128420743784aad8391cceff2d0174e4c928420896d703c1ebbd976e077fd262a57c4d64b86dc4ae0c6289b42f0f82d154772ab476096b58dad83bb582ea55945dbe9f2075c4722ce2ad1a7b350401ee15dc1001b9aa7f80a1d97c24a64fa6fa04a2f4ad0d878116e8d017f8b6cb1f309e1e31ba8f68a9f3a49a34f19ffbf4710a5dbfc2903768a8291bd43d46ffb75a0cbb84168bda98c8fc32d8f3ea6f6c5e50ec94d1f4645baaeb4a33bc1f384fa0810fe36c8f4fc897ec22fabbd33daef94d7bce83335d5f7f1cb1aa10261d620a38e4833035e605a30b942d4cb67cd3c0963756dbd19dec1f308db2e9be0a2904ccaad30aa3a3fede36afe73f91c8f07743c76d62f831b93bc95be60f9cf390bf8180539a78b7db656b1859e36009507f996f7c5f361233bc074f98005f6af0dc0ab50000f4e2bf9bd19205952ff276176f737366f5b0b70f29964af78e2a10d9459e25c5a8cf6fb12e6bd203842786a04183ea099b6c2640f56b60ad76cd997c7a409c3038bed34d1acc5b701b2c2de980ce36fd729426b7b15218056840178d211d3d1593724411b5bc5f7fb59ebd498c66cf934129d75157bfbd629068194789b7f4ba6cc7e8f611f9c67812d2eb97e6f9eeeb07d9b2dbaa11bc04aa30ddf4b0b9c20d4d4aa4317a689bb5bab837abe469b1ec62a7c4a0c7ec8b7aaa9c876ff08d8ea82fd92fceda72e2dd8b7808966c296871b10b8f9ee1dcc1f450837d060fc38d975dfd329601f49fd11be98040d4744d951417a176ed1bc3a9b3ff54c2d1c6f4c5b36d9e8f6aca4846f5ed92fe19674f46b89ffde9b7db8d204a0c4a8d5f9611e70a281063c72307493329687a3ad72156cf0da9cee3fa4d9dc963efb747acd5215239ae7fbd73d1c159f4b20fd057d3d378f4af326e69ada2926844a06c68dc5e45232346151d2b63d97488c7acb028fa4386130f44abba31b164954d4d854722bc8f35c380e97d788fe2bfbd9419beb49047c727be9371fe640795c87e6d7f265d4ac8feb65941bc0691a02a4bed0a597ff2ec333e2c1128db176a0ba89b0f13a9079a108722153266274b9fb86be82ea2435607331331febadf8a0d6757de07441aefa814e3d48f02a3abbe78aadd0e557ebbdc43de1b9c32afe2d4e80c8b2a5e14932c395e098da9af9fbe1f6b75653acf6e35e7b5af30b587f40b9aa2df2f73de4d6caf6ced0730f78f2465bb1e3a23e3e0956a44cc49464961fb1e5fe379644292130971722f3eb753ed2f659b1f034add880487fe22d7587d644ecef39e6c680804a9369acfe9e28f0f34144df488103d6a684deb547984590a7c662ab6871069c1fa40fee0989821b50bf7c7fafb5fba507e12982e0f398edc886cf9ed21113534da52fb9153f61bd97170c18a4bd27abf9e7a873c34d397e63a5b4f429ac5b3fee237e73aff95539e281a9caf6f7e52c3b57b3324892fe40ada60c02f5d2daf0242a154f36e436de49d2dd582942f602e6bbd301d3c699e206c13512735f035e70bf784dd470adcee3591099aa069a0aa6e3bfb7ea39d97c13638606be21b83729ca65a40a588d985a71f17112378adca8c60cadafcebd3c89025b77954937dffddfa5c6a8e66cdb8de8554425586270d543dd86e4a58e87bc6070e0353f77f0a49dbfb74ee58d2cf611cb7f68290f621aa427045519d7fcbaa3904b2e0aeb0bdc051229cdaa139956272632378bd1bfe1d6f9a0f5fb88bcdbefe5c6b89502b767ef48f51a3a6aff4e717478ae0a90fff8350ebd39d703eebf401586ef23ddab2e2ff22f9fa233c2cdeb73c4d8e92a82824eb82fd170b2618231b29bc9b7c5f3ee88d73ffd032e39168e349e3881fad1258432bd9064c61316630ed0a516f0999c6173720cf3ebe42b2e33e71ecc43e704727d8eb025ff4cec552995c78276a3f77c5a297e55c0f434d9ae57c1e911a4344bc25f13ad14bab89dd7203061e443ff5cf8e8880a8e48dff2721febec605a4275418b1952760dc1f2bcc24a25b536be45f0dcdce7cb34726ffc0d169007e3a798bc4a01186c3fa91d962024fe35d085401a89cbbe2efbd724ca2d95e17db178a4d87a47fe6ad8037519432f3e4cbf605f45b3e67711f0779c6096938574b0ea0d13f9c4e0ae32cbd219815057fd854b8e9c79e1476c4e03fa5479b67cfc90e5b5d2cca0f66acad479e415c8e601b8aa32a0e94042fc32211d480aace6d4e65e9bea9075141319ca63080bf3d95c55fc62dd42d2776590f03372ae2d89ebd0b6fa3efbd253f232b5d96bea7deac3bfda3f860fdc1bcf405fdad0c04887c080efeaeb2e9f958c0a7d63c63afa2c0cd946541ad1b9903f5d7113a1ef185b9ceae0862d4259ad19e8c807b2cce61a14d041ba990dd9332ad2a6a9c706ff340ab31d5c5627bea12d96219855710a96073a96054d904d5955d7e4ed90d45c074b8f667316da759d4756e103f138b8125c797870af49ad0c7e47b4da33388ff9d9f1d28abfd293a18135569a2530d54592c5c750e13046da018163e6c0c23a3b2782bb9256c511a5e2ae4e8455cd87f565c6353882789545692f5ec4257c354e09e1cf321f9d351a0995f728e7b00c540330dc2ee55eda8b34463b15c419e17bd0f7c32c09c330dd1c8d9da7c2c492af064e4e920147638b47a64bf2f951b1b091aff8ea683452d4fc0f7c1161a85bfe5cfbfea1884314fe97213f6d3afd4b2a9e0903f0e34fcddb1ad5086c029b6a329d495abb549c8a39ca273528f1feb3a16d5944d7096e519d844287b862df9fa2e94add20dd019c8299b8fbd269bf50c533f71a2c2bbc5c978db56c37cd9ff2786a62c345a4857bcdabb27a00dd95fdd3fd15129745bf98b665df2342122d578f8dfe01b4d1a756f6312f9f1eb75350f4f63a0912902eaf1e073bb443175eacef094469768ed3431dd78bef5c324b16960023278f1a516e99a263bf641e18c6fb3205e873f07e6078e1b7f59184a56feda262d860dac3384cc1f3a413f134ea3f6149cde7fbfd6ffecdf411060fa614f9d06beb56a605a4090ee26212a45eaf9357adf9f1d0fb4fa21efeb1d27cfb39cf90be0c925a78f5ad76ffb56ecd5d4c736ebbb322dc4b4bbc9bc186785a54be1847d1643f14e88177e73a0860736ea8e7543b95ff3ce32ce050907c69ee9789788aef2a0c53e37b4abd7860f58d7e8c0e837cf4651d190ffb78ddf6e518850366a42c5ed31bc725b71ba760d8cace962f8d24ca79831c314bfd894c31adef3b9b723887b7a58075f9eec3952ad10716d36725d97a934b916144498b31c4e69286636620ec4360a1518d273d696c5b3e599c4b8d359ad6a04d30b4a5f627967a2933c12dab873c6d4170ca1d6b1d6442d6388cb562ee30b1c1899f0fe5423596f034b9013288e65472eacf55c49b819efb6dad4273ea3020a2e75c82f5d98693c9de3b0204ced50d42cdd99054637a4a72d06cd14899f5519b6b302d8d96f9f803b220c729601b48ba1e2e9805190d21aca0e6f7a3cf82f19abbc0eeb0fa9642da70e3e9e556ebb322cce652d8ab0366529f9764e358f646562abb041f13ceb6a36d96f85c04707978c7c1f03d7afc7c16ba7cd994d218f1629a407b57b296e6c01c2a026c6da0ec9085e60324623797ca855283ee199d9a3ae6013f6d3ad5037d958993c8adf8d0b8e700c518e7f801ffe4de0c64f43fdbc1d178c44839ffe55e6cd3c3bb147cd1397a01a325ba6c89437cd33161cc1525bdc205447b9ea3c84b9892da023f7af3df9265bde9948b125a297567fff2baf8774c6c3875bd82e96cd03f8b423950821c8938cf40d1bc5b556e7822eba47fa5122feb3dc02deb150e2321a94259ffff41bc99142f975d8bd96af9e865f7d466a3b88f5e7f960a3a66454005ba9ac56839bf42de03603c3b69e997c5be25a3d0539b6d8f7d19aded01d8bf4e88d34d4c92f3f6180b585153dae458903e825d38fe2f56ea7e55da33423fba707553d77b8f80192544ab9f0fc342c4fe7c0ea76e63850f4085fbb51f91954e9edb768901924a2baf50ad5c4010d63741084030c06e0a83f908e1552cf7c899c261fd6df952d6e12a761cef5ba3c81f7da95602ea954bd953c23b2a4ebfffebf1c44406aef763a8d22c28f281af7137e5761b352b9bf5e7c09f81b7530e2f372fe8498021a4d5dc1710ca75c5efc7349d2d4969f295b609df6bdab685b7da1b13143f4997e61eb9222ceb1a220a7902d3d9d2b5cf7205399ffb29596ad4c3210db43462c4ce6948143c3fbee981406a2b8efb3682c4185b5ec4a253d83550a42ec703d5944c56f8787f0843588599e860ce48cdae33720062c6d47d05f2a7ae9fe7c90e6a8ca489d513964bc50421742f6d90a93746d3f2c22c17fdb0f3de6dc3e8a7a6504f16d87d9d9d70b2b997cb40a7fd886abb12420384e433df6e2d9d330669faddea1d6682e782a68ed2ab9e6c0507c87ddd5ff190a164c7c1676cbacaf158e248e43ee928fab918c33c968fc3615e81d292efce89be85dcbe41aa5a603bdcdaf71814b3f47b7c487e65bddcae6c07b148b8c4c2db1c5ebded0668aee6085b13ec0782b4b60348982f0c55eb9c836e646b33d752d3a89361035833cd1694be6773fd49929fb8bbf1df4c63b073fa0a38cb82495252ffe1e8b7b31802df603fb1f05d3186f52b12bcdd7cebc375d5ecee8a69eecac55631a75d404b86c1fdf123697839d88f9aa25d1aa10840537844408fd755fd48e99a09a3674ed5e563af3305fe0d928f04926135a5307ac54260c8f1b61f3571701befe3daad2fd3c13549bef088386267d4b42620c370f7eb098affc3f820dca299b3ab033f1bb50888610a24ee24c8f7e0d4d9e5674702adb79146303f8defaf91d2ec5773dca9486e434765a628ecaa27acd9d2cb0415703472e86d8c87ae4f367ae395142bb11c95743602f4f8321d523957bee10225add220ac65bf873288be119883e944beb9faf4a0cd5f6f47fd293df54b46bc0bfa60b55a21c6a66b7b8e335c2873d1f69e0f451a7c55dba3dd228bedaaeac336106032b4340f4db640a1bf7546c05dde2fb408fa983bdf022eaa1109250dd27305cf2a605f2a436c3598a0492f2e19d44f7640a363d26cc644e9e0a1021d06842b1b3d9b933d17f1a0d46fb1b0ff4d3f4fbfa99982d51cc69e41876f70df870fc88158cde49f6d4fa3ae3e66fdce36e9d78d0a90f4144b77af24e53efcb8655eba619da694c92d00e7c6e9cd7e9f4847707c3f4cdf92b58ba14062a8b42605cf4104014bad01d7d292b63dbb6e932148624356701acef0e24eb08d247836467302cdc50aaa346b5ee321b16f83dda8d5332975b223e7fb5490b7f6d375565ccfd99f15f8940e4e323bfc40ac6812c86af0095f1029ac70e21d9161b847ccb02b95fcafd8c39e5630a78df19cc82b0d4fc2ab330ef79bbf6c1cad963b2eb1527d242c683079c3ddd041292633625512e2b4ae4b2c83dd6145f5a6681791eaaa4fc27defe41a5a078e06111cf60968c439f8c45f8dd6fe31cc91cac7a059b4b5446ac713d579677d2f0974bd085722c8d20de476ebf7f360b6b99ad285860b816c2329996891ebb5be46d4d895dfdbef6db7eaeea9514a00105edabc76c6db083f0063bc47507d20534bd63a050f0d71458f3671d4e1a40476f83569b01970bd617feab604fa85f099b31555e11271e962439f78bec946c2339af37d27f0ac41c625408808ba3e8f9abfa85f41174c8c25572d2ca2e44705c41b8d86f6f88b637cd4b90f62b92f792e8f18235f5d273ef882fd6e4b288062aaee654ef841e0834f13ed7e07cf129f446af42e4f58b284cbafdc2a0130c56e1b5a3502d8ac03189d720a458cda29863b3cea93e64eaaf5f17e1d5926e76b1af95a63a15f9ff17a5224318cb50849d097f5e97789fde6b3b94c9ba95626bea3400feeca852a8899bbf35afbc90772dc4842ec6a443142d7c968a5af6c61ef45c9232a0c5dc46b0978ff536a86ce9aacb7ca77a226c77759d44a19639b624b45eb44cd7515c372b5ec1bb8102ae0bb55f041b548a2840466a4b30e5a936e0d3380675678b23a49e46dc017e3933a7c2b43173a13444eb080f36f724275d35bb87fec7f6fc4a2107f7da5955926b6f770b295f53e4f54926ec348912bfc7f86303388759fdfb4044d6c53454a1b93f34478cf8dd300a636df6aa5c18c2771b76febdca92fd6e2560f4a0c94f02a4aa6fcecab5b9bad325bcf8adcdc3c6bf19195630d808d8b5fc6ba966a76e123c0c7b5b8ff62a3fd61b4fbf898108311e608a0b7772cb7fc420e35c4b1a0afe1a535de850f5e391a43cb4b286fcd3bd9d5d539e81511f3fe3c26f495cc392d5ceeaa22ed233601fb2234a228f2c0c6ddb31af6aa43b813331a0f4a64ad1add3d4760d77a2659843e3b72ea4a024a77d98f9904c5f611cd52bb0fabebdb51e10ac804b8462a8d6f9487157f047d49b32b1f7c9246bf4f79af119dac77c33ad94c77afab61db9e64451642ad021b8ccca5226dca8360bdfe4d05f30b80ef5daa629b6c1e5936054f34a4e8b601710b896e2123f25e5b86091c1e849a7c4bd3b165bd561e208a0995a6ed4ef614b1a3ea3604dca5a69547461e65a5ae5af0aec413c75c9adec5609bde1a67063f6eb0dfaebf8e741707cd41ae00cc2bbc18ac50a58adf23418a4c976faeb25106ecfb68b6e2fc797331cb53c9eb8e26b24a5a3c082e159e00d1761d14cb21e9dc1a4ff7ac398ddc51b5834b87e4b89a10aa017934ec53450858cc972b0366bf0acd030d035c7f23e567cb9313c02bed4bba2ef0719712d083044824a5c2cfe818ce13ce52feb78b8b6ab71b77b848166fa0e851cf02a68ff332a02338f726b95d1486a14e36df57d27e91f31ed74bce59caac1de5cf014565d5354693eb4cd0c591fccbdc179a81632f0c8257d9f2311eadacf4ff9bc76de9cb68a46a17e957f8bb58bc8ec650d9a1281e90bae5166d2180eae28d7e82f8e457e04d98c00b1c05aa98f98d022cdf7f0bb44c48e5c15eb7030717f111855c7744a57ade023244867fa352ad0b6e2e86d5ab26e2b462d7858c4c9b5afedbb0dddd01bcfa33ea186862674b1c690a0b5791beb84a15c81f6cd47f342de5c23db817a1fb24fb191e7e6ff569a188973efbabf760be3c8033da71c46df307792268f6d0c8c545fd8d2312729786f44bb2f778beead","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
