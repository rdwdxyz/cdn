<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b312165c17d48888930055391d86118679ed7f25f004de31293eb153d58d65c81627f1e3b741da40e0d4d01c439cc953791861ffa4c540aed69287ce95c2a6409bf532abc4223a28e47e04c9333efab1d58df563d295d861f6d3225cde80672790430a1d7932ba80da77e0cef3425117b3d1aba1cb30a316c364eff821cc994f57e25ea999393e06fc16c59677de626544aca2aba0f3e192966cefee60b1fdf1f36ab8873504447f3f37477e328bd5aa9af13ecca1c6cc0be4a7237445499758a65a73082cf5ea9785152a8de112340823c904ae6345937535f3c3361917afa0bc790c0d484b05a98470a8b6439c6ed2645be4080fd2ffd89f0d7cface6131aa7ecc95ada5d94b72a584a4f127e380dca863c8e727b4f1d468e2e9762ac07dab3e53045f568177ff101bb8f4f6275dad8a4654a99d2f265567273bc85bd66c3697a196249fc716ba11fb9095f0d15242c4beae3981cdfe07f13de96c1e5eb7e9f863ce8fdf0b1ee293ca453ec5991af4c06ce3bce435d0700f8a42e059bf44db27847fba563b6295c5167f172bfeaa9ab59be25b75285a435b19d63de7c068199828a4aca5c06f69bba34f2095c9e0890912a00de02f96cf59e59bde3ea2f810e731e70f484e6af08e90637cdc0dcd114637393bb61db1f7702853330e654a27fe7e32eb1cca1d39714b6334e5638a76be4d7c07b66b043f03b469690f3da09d7d1a31df3f2e30278868ad60bdaa70785f72250d5cf77627f51b2fc595624c35f0afb5184552566d27a37aa9cd13e0c7ed3c277be2f51b7ca69e60cfaf38ad26daff8366cdfeb0d7010d3ce5027111e4b8fd9864a7fab1e7b920b9947a400f04d83d05b601cf589a11483ae347e52e029831fc3be9db20e531fe07079217381df68832ed739ee6126a8d16d82c84ce33d67a5f2cdf6ad0dc445188d5ba93b440703580a9624d97f135f3122d961d6c127c04a3ecef2179b50ac9e221f2e8db1385348a6fdc0b87c96c93baf25ba4f4aa401a759c252a4c261f00371e5fbc7791a0dc0bc9a25318fe2b67fec28d9539ac9830e7fac24a92d06aa4d885d52aa56164d26835748ea63431faf90bf5d15faeab30ad36488eb8ac58a3af93dc6b484dd166ebc6d183fce6d8b1bf420e7c5a1ea3378c4399f3a16905c840a52aee3789462b9bf9b49ff98f8d002aad211fc47ab4e6a162357dc5f84f31dcee029be682eba1f994a2eef99abbb1505cdb91cecab3b5c2e3c33857ae4c8b4f03e424a9735be58dbb9143f859bcc80f64deb7fdb521b102f5b2ba93d2e8f112e4aef6b8214a133037c5d06417abb8480a1f7b19cda883fcbb98733e14f0685fd6dce514d22871d846d8418102a728d8ecb1b1b32d2cdac097404fd452e70d2d143117ba03dbed20e43684734fbf2ee124e8ad2c851936496c1034457b8d7c5302fd8fa04f6f7b0ca86fa247b1693c972d5bd1deaeeb5cfb12a57ece26e1888acaed4e88293cea6a08215d38644e7e1e1759395a2d8062b1e171b44225ca215b23157204760fdd89732b603dc6d962dace6e9410493b076335cf17854247bf9ea7bd95cf6e0c2faa5fedc0f1b9163f678bb2fcb266c2ab47df38b76df9a5ff9eb854f3a7b1d0b4f1d2802e53c29291b175bca74db42b84d63781ba4c0e9a07a9b94f227e08b07576340d8d130f43a73b6418d3673481bfc00d9e6ca5ff8df0f1ba8a0fc92a76e8b160d49ee0f65ba3ff64ec47082bde661fb0185ca8d800db080b947a66b8adc858aed8a6f3b0aa080bdcadf3798ddd77b4ef4b33475d402cc086a81032af6abd33f55c11e00990e79acaae96f84da78fd988d419d520b088dc921ec4a6e2f4f468911fd82dcffa4b6eae7d483ec3016c267144e9e3feb460041aa208e00ceff0c2f45aee2b8961cff45a1a0ff09357ae4dfc36d1dc692b6a969dc5f752ba2f3717dab2a601f66a401ba7f44188c5cfc62abb46ea1172ca5db8bb313a0c99c26340412ac5c09405366ad971d9b5e5d4acd09fe393d1a83c7e781db089f23c771c5f24f512a2b8ebeaefd6ca5bad2cbdd1d84ff1bf4ef867f73c7b1332d178140bfb2cf4401f1ad492c47303fac246536dd822b6f4f81a3fd19f78f20e3c5d3ad0938921dcadac6e7617e2e1952105cd948a00a49b001d9b6a05ec558f0eecd051608b71c4bdfc254e41df2f0c0478ed1a6ba41286753bf9186333b31348e262b6d019f0a453f3bf8e06045f7a0dcff71e57303800514c3245162e3890ff5711889da518cd5a8c22a6fd2ed1399f5541013598b71a5c04940391d3488f7c83afff586370145f48c8a30c710be39075192bbbf37fd4e5afae04c1d5ef48e7a624eabc2302f106f53078317a64e732f300956eb14c7af8b90c9c7307eb0a5b84e538e2da37f21a9c3be21b8bdf31312c250b597b9009bc977bb471a98defda1574cb703f55dafb9d20f98502f51cc486771530ada1e0b639e76a1f24a2d5b611df9dd416ebe6c3c6c14dfa4f0e3e1c1dbc2b166356e8aed8f645cda77210a15181a36b8f6951a602191382d9b6763a294eb5fe8d066f2fe95f805309291a412b204c6b6120546dd4e40c688eefe79e9225b1513244c29158073efe2209cce88809bb99e6e3dcef3785503a8d658ff11f9d19c270883631c2e6a822db450116aae6c43286def64a5d6c9e2f219d7b6bbfeccd69fe4087d7bd8fd91582d6d73328e3040c48e05a8edd3f8a71a91662ec965238bb1caf20778e1e2a6ec5eee7cc4343888c2ac86517d4a9d915c59b4dca095ad7cbc76e51849049b2d68773caad8395f74e668575a0708223eee86a616246303d5058c9cf1a6521f1f6903f32f07fa3d318d616561d8eac42ab21132372fc66ece4c8b57d87bda75c96c18afbf7d8c2728ded0383aed2ae8aa59d54df2314d72c1340c39b5b4aa3ad4639f00ca55c71b362e9be76d98a34ba4797a20562c76f8f0a01bc920efcc214c218366f0f427aa6e547e115177a5b96171ede28a7bceefd0254de7b33fc1c44952d8d2eab23f3f15970097ebb5557c57c0d4a1edd4f63645184bd6fbce3e5659a7a310bae2cbeb5ef9eefbf394b92cb55bb3cdcec9e8b924a72e89b7268e1e49b2ef640ce4d9ef3f7ff58b8f0e16d3384285aaf139d49217b845c767f6998428435448912998c4d3fcf33a3ab6ec6a8d42e539c3014789fd5ec1c7fa27e04a85217af07e964b8286f1433fc902dc2be96defb8d35c596606dde6df6f262625cb35c6ea6331ff17c617900360e159790be986691d01c8da292e6ca40bed19eed2f8e3d5ccf695b574467c497325198fbf8657cb5cc25ba5387320c553ef05bba598826baf8d8df91e1fcf00f0e6ec72aedda072ecd8bac6fac223df44b2454a22acbe1b9c293aa5376acef02e785729fe86e276b5f926470972bbb2369e892e537cd28dc95502d1f9361b64407e12a064bb6b69b083a370d42f816e3139f286fb47403694533e3fba335da66f4aacb13fa3cdfb8abbb843e91a78590ed7a8b73a4e1c68825f7ad30fb7cbfa2fca28098f9a798d5daf88f3150a955d3e241fdc73269cdd03f38855892dba558ac6c084c7b69e1ee72127e30e27fe4765398f974bfe9dc4c9e525302025d744abb38d700e227fd1d15c40332a02ea701b3a0e3f0f4ed46d0f03439dcde6d362ab8ffb97daf91c78d705780cb2b596e5d43197d45bc77992c48a97ce3d8cc43b00dd510f8b35d688518b09c563df66a479afc3e21e67417e3115d83080ab64fa99971a84eb57dbdcd14083b173080bb51e28072ae3142cf98a5123c66e15b1546b5fdf00f82bcbdf45aeb59cc726f58b282e9e741238f65005bb77a697562248de7767152804d2e0fb431e75e318686ab3125dde867b71214ee5ca11dcebc6c19ddb26f2698cbf35894716853d0daecb1d19dcf45c0016e9445135cc19a79e1c99c05e981513dc01e04676c585e3aad40e48928d8d11b8408888df2b25ec17ed4e0a53c5c977eade371ffd7e36573b9fdd57e7e7d2a30ebce50493c6ccdd795b16f29ddc842adc53d08f258ba64dca71ac857b327df4b48484c99ad5b67f052f91eb8d1a58b74424890006fd288d6140ec30ebae095393ac73017e626c11a751d1d760ea2f60cd3ba12b85485fcc5a64fff1deaee7742594f55541b05b6417aca0bc9fda8a613113f3941505ef9c74fe009bb75f5efb216a0501ddb7471fb1d51932f3178c5e7242bf85ef3537fc122c4696481c16d095253e145f993ab3ce74f2ac1a73c8c1572e8bb0233cf40a38f0ff6cfbea57796a45ba5d3a83dcd83b2c5c64b2c30c8e663a29811f4f7c319850803f1f41fd5aa4a9171b2dca5e85191145c2f60d5c86388cc15dc309e75d6ecb4f757f613e98983c289ad72d97ed50893206a74d436ee8e2037f5e9573726abbfe1aca7fc366321e456468943e588b217f4a1b5996d8d8c17509099a63f13834abb3f6cba77318d60efd33b047e19322b21d9f37be6da5084bb62567275cb6321ee4a1b8837b881e6e6d1a1008fb3e7b669707da83373abb04d2a190b05d9411bb846c3f8c3a68a9aba6378dad6ab1e4928313331bd4a6864cbacb0b70e57478aa6092597c9b115a9220e719ac590188b83db0c8922db0789a9310fb64bd51e8f1fa175f051b3fb9bd587e6620be64b0ff86b392d96cfe3f8812e79f02cd6b2adfec82c7779dd83b3418aae4af8bc4ac8e0545d2ea3f1192aa54b706fb4242db48a769e51c78c7b62527c66e857d7cf88412bbf1f4c5b73c0634d61f25b368ce7932ac7fe2e6c3a2907182daebe571fb11d41dc3c2efb8ac2f80050e840c76647ec9c7e36b0fc3e03a2cb4ce959afac541604e4f12bd2dfd2701f25d240b0f01b706a1a4ae828e2b30f0e3659e8ce8232cb1af503e862ac2da5021511eba4568c020ced93ebda0f855d4bad1ab509e60b1567b16ef5deedd89fb6dd55857541d9c19a44af7142e355964bf0fd075112b1c7c07a9835f351d96f8e93cdad2f72b0346edf891b7bef4a81876a46f2c001269584117f0d2714ce1873c584fec1f3cd1f9505602f08c52cdd4162a7dbcbf35a9f67dbe80e97bd4614537ede11bbb06f1c32999a9e83cbc2ada361b60c9d39ace7c6d262efaa999f7968724a7e4f339d71abd94147b5a0c2c22f0fb7f573db005c1f8e10070cfed1ee7a6900db7201f30dad807c9be460369baae4e386ba8607529fb4061001f1eb61607bfc64274ba62911aeb484ffab1e021a00f63f0e44074a2c93a0718383519aaa94bfb488c0259e24e4749ecef856b891499ccb54f99a263628a8afbaa356f3de6fe4224a2d090a4217b11495d2f4b89436917c0b3e5a50cbb487db1e5e052f9a98d77aa0a9f8d29816fee02755085419203df655bc90957e134ef3e931a512d07637e7d1e813810381795196a2dac8c37c912363b6395caada661b6f7113d50be7ddc97442d5a46d70711ba3890304c66525ae15720a2e8c4f2e278d0ea43136de5345dad01344341eeabf62f12b5de9630e177370830ce51b894e61509f29c1226b9cf362f6acbe001055daffcdb11cdfadbb2f891ffab1b57c864ad8a13a5ddd2166386ec44cc78e4054cfaeffd79a5ba76d8f46cb3aa2cf91645e4cbb2c0034b581e84be0a7d64fd9a58803e7e9960b7371737f27735392d33d619cdb6461293f1d3b4937f0520e3a06a88eb29f56f0cb57de0f7cdca134fb6bbfcd5dd36baf58cf2b7b622da65e17a765cec45bb0118efd662c539dc7b7f8d4552af2e14951d70991da90ff0fd87601e1927817db460ca0d4cb9470c059b41fb9a8032121a9013fc21fd6f789d3aee73713360497244f4be0f488e202336bcd5c9b8fb9c7d754f636bee0e5e45125703a1d5f2d1f63c731b62b54a8101539057d8e68c1a1ca798c60b65d6e1faee5fdce9e37fef16240213755200085cbeb4eaff2a0a04c2436b2d72683c23218579ef81af78574a3411523ccb329ca1ef41bafe51b949d62f10287fed1c78dee0e3d939040aa75efc287b53d855bb466669c1f70639c11bcdb19155fb2f60c4f49d9b4f2074851f128e8038bec7e329e9146578f9a7a2566bce3981354337f9e4dcf0ac8956bee3f67802f27e89d2a0bef8c9792c27f7ff68b8eb44bdd68193a2c75cfa7a4f344e5a5a0fdb0435398464e81d46f89f3b06bcea87b72be2abed6dc1f5429bc9ecb79d5a04451c23353311aa19cc0094e3556562f65b572e9ca3ca276c8a53daeeed5f0a994edf10b6efe1eedd245a99916218a685d656293efabbfa7c9d0071b1aa497373281619ba8aac671ec51470fde62038be01b79001fa618ea29fd3c1b2dd990156e3e8c18477e56eec087cbb55f60f510afdc2838f0ea4c03a97354077426c1cd02bec4471cd975951c2ad837a76f2307cd3200fca8f84f1107356f19576a60504d5f668398401f3c90bf1815dc41f3690a2a55cb8a185f589a4539857068e11b0274f268e5e477d4bb7fdb3b5b1df366f58e52aefefc5396577a5dc69268b093bf84250a9d1ae76678c1feacc45509e69eb62f848ffc736da52e4fc1f67e6b0607359d6490c0d44108ded682a91222b375ddff136ac4a2f231b171f36b0957ec02b36764adc7a4c07305c2b26375fea85471e6d3eac209a8fad9e05763098161d061801dd3714dfc54bda258bbb2156cfb71243aff985c8c661e025707dde1937c80707c8fe4976b3d7af160e514cff241fbf7812fbdd71c2443261c9b0cdfd6ff2e1930db1ad72a97de9401906e7f5891db5094850f7741ab91d327fe7a7e9568142ac3fcb3bf11e290b266157849fa981986546f43f29bcaa940ef2458c17f91ece83f361acee09e58369f4c7435f3fb3391fc0384e4b14ab57efab66313857e45376acf330319e134999c852428c0606d650120d2ce103d13e65ad7cc521f9a74a519d2297d416ca54b2c84d13bda8eb8b17d495487eda9079c24e8247b6084a60aa4da60c1f5049294bbe96bb1f8317d4e367399da97a3bf1319a24d29f7015e7bd786f1c2b6b06dfca160f12a9ffbb334d43121e82a8f27586f5778773e1fd97a61da0bf6c712cdfd9f8cc57395b0d7d87bf6bcd010911e16f2f69cd0ddee35aaa0689744086124a7ff6661f23e88189ed38c2d56ffcadd4d46ac2ff08fab03f1887a84c75f71a7a9ff71ea8f86217657326fd1f30fff28160dd2d3446d276a8897843467b5532818f0f727ed8950791a1f1e40d610d19e814a5f0e382b09f4aa0574f9333c5e7ce7e917fea6c1d2f6cada43edb662121913954aeee089c4d5c690456ad53a555ea19f65421fde11434240d218b9c688b40956264daae02e9abb60d3993049212ff76d6f55198025389077445f18ca605ab4904bd1176e4b3f9624541d2b384686fa004f51dc1b9d1e306e8f519c77fbf3ec2d270c125315117541ea785334d874470a88d63555a0efb9cd79c1af7a83273aaaa164bffd153967e1e8f806df82bf857de71d959c5d4a8f757fafb3d816dce27b7c0494189ffd493766d817ecffb2cdc26b53200a236ff75df11f7bd237952cf9388d393a0f0591545642ce3a587e496d651aacdced1c1177d21ddb6bb0c35e1234d4c0dd93edabb5363cf053169ef64fafa8c2238857b317711b468517a687bbcd49aa7bd7e9b2e80ac8de544d99cefd9baa5b7eb3cd9693b3e517fdf6fac329f1040638da176fdad90dfdaa3f3e6cfca2f161bcb6b29f1aa2f5240380e3320c08e4f7fbc74990447a3a6dbfdccae3c4b1b1dbf2ae3f13fac13c020e0a683f34ee601363de9ffeff8b0a33fd9aaa0e54137edf1edaa3cede64ef3e4a583afa03431063ab20c354a6677efc52e612a903b49287f9b02b9d3ceb99f0634269ed9e7f765a35411d8e3a640618ccde7a98870a5cc86ee51e563808c0e8a2efcdd65796512cacfa1166cc990ac8288b5e31ed6a7e11bbc835743eb6a60c2a17dd8373ba46fbc6b0a812008a0c733bd20613fc601a62158366021ab2dd792851f3c02c587a8ce904e592f5d64c179a12997c82e64da7be7ef38237a93a7f949f265e333cb7821fa34a50e1dec1dd3953e95777903f3f4ef8e651219104b05d89d1bbf517c26768b86d92071b7a296200afeb443d3d068e4172cdcac75820d03beb483f71d42fe5a2cdf7c46f2bcbd0177148f1e53773c197bc81ba9c098afa8da10a6e95a79c4ecd40ca8b8b1cf29e4b518b8f65a4686b1f419c3c9c29ea931e8ebdfe69fec6a8ee9db25eec565feaa3a0b8df750da77513884881212b012cc070ec3daed34f80da2e7ecf9889d1e9dd8919509e9484a8e619f3b865626be74e488ac9cedc2995b05d612928c9107650386d98d45d064df98aff22d233eb04b74714013c8fff78492fd4361598dfbe6f7e6f192adc79eb2a0c7c8fd8743d7766f21b4ce8bcef37e9cf90f7161b921d99d8e8bc57e20e12339d412eb3a769eb4ef33b1303c91bcf1555007777218b3a8e7c3fa4e92e342215525ab21caeebd281a76312e8c996252c6bd4ff0dc5e592911de85baa2d0da506cb279fcc7f8d9f6d7cacfac82f4920316f727d9d9a8e69e5d0b802950d749739bdc07895a372bfc280cb8b6b140ae989b46b8061954d9e2a35916e86bfa17999d579d0604b8ec442b86bcd9263398b26ea09e5946f8870c54c483b6296bbd76e9c6125be7702d13e8cde14319c4ff89dda0e5406f4937a16d4f2cc10b6cfd68c03a6c896ed0ec328b1b48d0c577cbcf12de9961bb5ce47d301da5329639fab0b43343c6f640b8c7ca803f52d297cfb603aaa5b1700a1e49770f64cb62803aa3c9aa1872092acd2bf9d0760a86f1707a569e92c9574d82560aed5feb205867a1b017a98fd9a2b8da51b409878da014faf8b221ddf58be5f1a086b35d3a9659bb5dda87db518b0c04a17f728e4454b17ae6ae934f15310a2ac19f0bb0b42727a9802234e0a92dd5a0f7d0ad3010fac825d254c0c82e5776c8a1e55b0f0e3f6be214e98de8e97a6cd82800be11b292759bb155b95958306db3b1fe2f018f47f05d44ae4124042e66ddac681c5655aaf8c2212f30dd05b2679405f2b4f96d5d4ec2341411dbf6b1c9bf9394ca8fb875f30be48c0d535942af9c588893086fe17457297116e1135f1d6c1712f70dd5804672f7abdb6a597afa24c2a5fac3e65ad649e6c2aea76349165b6f4dc084118b37e3c5b1c580c58977a2b6759a05f9d60a3b6af41132fc4f3bcbfb1f461dbb4f1fbd6da8d56cb810818ea87c87d90f3e9422b7578516eb16a17cb239b5f9728df29cf120f267d97a37473abcd5cc6bad2801a96df557287850527fbcab8926ebf3f08a19fbe9e923e66b91aeebdf607c4d15b24d35b0ca4b353afe078a83d796bc5b54f8278f99a805a931d8c0c83dea64881c4d3b91c57b9452d2c1e0d6c8f985b6156ade72c807442b1767287f763d72b9221fa9379c070d0725f884af7663d24f0621374ababfbbca51c33191210204029e9381079ddec25199d98048320c2fbb88ad02a8c1209bca5ce74bfcf425a2b988474a1179869aa35405416dc2301fe4603dc2a429f0a3e0b3533564da6a368359054ebb10d6d81c8acaaf21a880386740055dbde7a4ca9911c5af6c6afe386921fdbd194a4b25f628800acdd9f33fbb8e3bd326ea5ef0f0db98b8004b4f1fdd036eaba8e928b0d55a2a77477bd2910ec2217eae5e6432b7316017f054fadaec25622fb8c3d8b917d0c384945ecfd5d84920aae985e681299648a594d42d71639de986e98bc7678d55e41bd99ea751049cc94d2225b2b3ac7e00012694b0b832f5aee3bbb2aba9306735daf5a864ad1158d68c479a01ecd4e519c6cf485e2012cc04114fcba633fc1e6a568d6bb71407ea6b2811b6a362c9b19cfd6fad7b25c46574e23e935358f4e347f8c56d774ec971ae82ac091d00808ad05834767e7e17724ed60f7aa537af7a5b2797904deaef0ec9536f36da3b97b8e7af17fcee372cd8025a3119e84480976a6fcedf639a1367045ca824489640326210c5ffbfb9b1377f89f021d81a0dd58fa303954af066a8107fb6e98e98206016b91ee90c5e18a1722cf5a91077a1454027868f41c04bc04a505c82330572ea39bbc722cfc6ce244572ef5fcda5e2c76e9d025344c303807130455b4dc40f8d5e80d14dc5d4cd0c6538c6f47f7dec57b4ef63f27cfd999da26cdc914251423547d8354ad6c1d1cbe3dbdb76a6d815035258df379ca61045ac69422f9c87f0912774cab2de4038a18a3331e50d7c222ddc0e1485c131d64023699956f2d04b1f326003da6f95072fcdb1182c434ccd5ee9ffc1661f69aedc98af5948c41e7fd45a58e119b4b619c65ca20d05fca9085b6127c8fdc02bccca00cd7d246114ae84df47a346d265827cb70fb98e64fa99517003c5d12b49ed155c935047b2d50524ce572bcbc12ee1fef00c3f3c5eb48b20f2a821b42e91c45b526ce49703e071f248973fcf4ec46ac1685b7b292028b1ab421e8b8bb7485b88c460c43d6c589551da5205f0fdda2caa52cd85d7d080f422b55a1310a04e9bf1b9f9258f97f8b187da55c17ff72f0a8585208bcea543ad73c07763923e85972829a3fc251bf34acc76a4af3e459299d7f18bb0b844bc4a7080abf57402ff90aef95a36be3457b1aea05141e9a475f136d58545d0d3dd4a9177cb0ebc178f83345791bc3ee7bb8a6e3b3478f9918c6aef9ba52d3261504463e6baf806b8ed2045cbaf3b499b00a0818718229850fbf3de7d74c0aee1acb94772841e30e6411da6220cd2bf6faf1bb31b1bdc7c5150a5057a03387fe166eadac2e1d5060fb065d0ee3477164dca6d5565c8db45e29f04e621a2f28966c95f597cd0dc8b4360f11654ee85052be4e857b39f06ac1ad9ef870424136db96661cd28e55610152bb72f97c90d15b99752a6cea8ae22f87942b7a5f5f7a719ef69fc46cdd7e193ec4e79900fbbbdd5cf7b0e51d023500b9c3a68b8f3d2185103272838f5c59889aa6180a74f4fee74c5ea11beadfd5f53e22591cc4e59a46eaf7876fa58ffb5bfc601ce4fe30a09099bdc88196815e8db0d02aca73d9f87173d7362b0272b4937484329914bb7112b06812fde336f945e71927a33f6175d798f4ac3ca06be919bb0b274dbf995c20febc18d6279647ae13ad3e04c872c9b6f35aa55d94ae36f945fe59d2c86c0705a220139c29368b057099d04da79c7ae7a29b7c7fa6bb7f41ad585561a40ed7ee11a804983d56a1624e91df346b8ca336420f851fabc6d6af97dc3f3b6f79bca43a0b7a4f2257c30e1acf0dc508def727100e228e7c1374067c469fab3703fd1da7ee59cf070659fecabc7536f246111943c9f53bf09c752b329e66e02bd71a8e48c19d443630fe67b6451e6521fc6405d44b2ad357fecbbfb8fc01ba3f9ac6c2d8155b707b06aa5090db3b2c196d9a36a45a1f2859692e8d7b6d90e8b3f43da4a1146fa49f67e15f99e0fab86a325835f260291894bd1dd22e4f46a000dc01125037ee2a40b289a0dd91c3eaa5a7f8762c4efc6db0a4cbfba86ec35b0a0a86fa5afa610547f9761d67268633460e50716fa3ac4fd42ff93a47221884a27e97ee412b71f98c52c9b6b53b946644775054017ef83917e94774e67ff73037e7fcd743f01d07bfabf54d30771fe91d794f2bf5d5ffe0c7b6874f6b334857f1f783fbdcffc4afd4c51dafe851363fee1466ac889d13e6aaaa9283d7fd65311f59a91a7783aef3aa1120d47344fe5c641df213abae08622006bbfb63512029dd2fdbab67a0810c10d54e32276ad7bb04076db98901869a1e75a13c9f76738574b2b542c9cce1e5b8810a6f40d5d5599bb87a37332ec06e9c8981c53c647c030db2d95d5e665bbbedb235e87df22ecc05d2a74b04322807a1c38b9de16981da60e02d9b0ff1096b91a01d56f537e63688d0fe7627f40f33db49130e8858d98d5f7d53cab88d57d18eab9b5f4bc99792d57aa6b969c6e1912f03b8350bf06a96b06d2b0e88edbb4924be9d4294c684eb6621210e4ef6ffe56130c2ca58a0451d46bae3822b4b88b6cdec465c4a5ae32bd91e0c17f3aa2dea9849b20e3da1b55f5aadadefca90f2caa4d1606d3b5daa12cfb6a4a0c7f6bff8334cc78081d6c33ac79fc77cf08cb66495891b1da33a97d6263a4dfbf6c9a00b1d3eaa481725a369484e64e1f4f1eec2cf8f49b3603a714b9aca5e9ea4e2522ec0799e7d51eb322cdc4b6d894c9c34bd0df0eec32648d45c102316e11142ed8b74d5da3319de22d434086a02b297f1b16d03fa83356affa5aa9499be86599d00ee4a3431db905f70b494f6b2376a72d47b8c1aa58a31f2cdb97b52c75430319186c1977f515e9edad2351917753b617b4f3282b7da059146c6971a5cd546f0653ff432f1239797f929280d3c95e854fb74feaa0551f6ae1f8c67c1d3d254b7af74c91bd474fe0b9f13eb56269db40ab99e7f0982cd772ef411d83c9263480db18b1a872408be3340bed407160a2f4d9562b32138747a7de5235c09aaccdf5c6ca6820503248e54f66e92fa3bbfee9c53f010321eac7d1530ff0b98bcf1c82928b368d56c00ebc321305577e77b1a5e4137a1188ca27f0e930dfa09f49414c914c8f17593fb1b55b16411eb75c4d8fea4352fd9095ab2eb2cae226fdebeb7bf7c594f5bb817930bc2879d64839cc6d60e740bbb5a231ff82979c4bf95edfdfbd8cde88e5c4d3a78daf906461dd3c090159d75dadc02ca2c6c3bb89e0ca8adc1ce9986ddc7144230e7cde7a93f7bb439a5f4518237d853569b3ae02e8f4347ea2410958c72cc7e3b453b07f70e37a5216d84fb4825c018e3c579c403f7f27b1f0c733071615ac853724d21a69c5a730677adf01949ed04e80c0c2f52108e5ad4682bd85b4e66f11af5fcba7ae7c8d7d2edc0f6d1818b3feb8bff3ab40cd393c7e30e2d8b64b1014d40a32fbeb77a66a68154b324f64337779ab25f86e99ef0f13701ec079cca087c37fecf134a8d3129847fd8d9dd84ea02217c40b7cd494118e581a1a6c71caf00974312663fef0bae272d1a93d510c8838c99f4f028dbeec73e187e9e0d690fc60165eb840ddbab4ce2ebc40bbdd0ee27e12f50c43a08d0cf9413e609a928089e9db86b8e18609bdd514a255d174a0b9a0213b7297cda3a21826847b0085a8e6fb4eb4118059a0c09c8ffb50ed24f1787d654ead1d55b5790c93811da5d99698f6ace5c3efdb3be5309b908037baeb8831c5b5e609c4fa6fc3550ac6041a76c5a2bcd67313e1ff8603a9273c402dbbe220c3ff52828bc161991659e47594f2c4b8cc613fd4bb342437e37786b288a4ac66ca331be271fdc312b75a3d93f25f09efa0b75891e507b61bc12a43442c3a3bf9dd28a77a10a65978cece6ecf9ac9c4dbe8a9be4eb396c2e9998cb88525c39143b629d06f17b989796556a2b0199303c4c3fe2657de796cecd38dfc4893c64269ec015af2a7e4c32a0bf499a5fae033e8672cb731f2d8839fd4374e03c2575a6a23982a5f9ca720e1450b92459521e893ef3832a7dba797ba47a50f2117acc474497f57adba2f7d66fd89b807c44b49a0f187d042426b8c61775b500a1a1ef96f9e3d72cb0e7088d2695f8d5de3ffd4773827c8f255b6e56f5ba0c20cbc81baf94043a4b8b729fc4473b8dc157e5c2cf3173b6c3f09be66c7dda4755098078c3e42160f36ee36bda25fbf1922b0146f41ec47e46f7fbf1f7719804b18caa98b5877924d67146ba79c1469d676355a6db884695bb6b7df46d2a5f32d631968fdb5fc93745f1ae5747ed553086bec678220091fb6251596116f509f91a01e48875046ca9adc4203140a3500035643d1104f7fb5ab888fd37520267d194174520e58487c563293746630e3541e9da1097c6f679ecb0ab9e7858a3e4c30e7f61893d78fab09ba0cf0e10bd1ea3c598a77fd55a99fdfef211349819d2a22336de5104dfcc13ba0eb6787121a992ab30cac61841fbd560ddc0b662f02066fd373e122e0bb609650bab75cce9a6573d89bc33fc4df170764bc6e7c83696ea0cfcf7a4e09af14fe5ddd3878e0e9d6299c19df8485515c7a33353715abf3145a88e6f1d764c81babd500628f94e4277e428dbc526dfb755787f72170ae0ff4b4a35e518cdd2a507a9e9f6fb0a2217585eeaf1189e29a9676bcadc8d87ebfe731695603ea6b3e7e8a4fda3df0668670579ee1e778a2f06afdf641fc3b8bb7f25e8bc98e5587008a06fca93961f0a2becc66d028a7dad38f651a53d98140d1d07a41d09a02f35b82866734261a52a6614bd905dca88cc6039a72b6b961761078995a3e4e66a9a3b5dbf891aa5b55f4ca8b0263676aa744d42d658aef1520d12bbdac52eb2dbbb9c02cdfcefd28d20317476ce0bc829a696153e95f4685ee0bfaa5a94bba690fcc4d89599d5b1e8e614154ea22f2459cb5be8602d124581b803358d1039ff055d420143978f99664d6203c946993746b5871b3a78519bc1be2c6575bdc817792c3b70d4cb1997a7371e8066d3db14ddf712f4adf75942e88b0a34b48c5fc68b3f2576d14a40a14049cbb98c43e9a0c89807c057429a59476039694f5b962efe1ed78ac9cc57f764156b9ece5075dd00d4c583ca073d06afaf1e222e8e083afca28f0f5c2667a33dbc7d00274b289336e0abcc4443dbd288ef6bd29ed17d4b4972f415c93fb9c20fc4ecfa08de6a5e206f1d3bcfb244d12ef99f7ae089c505564fcc031226040eed99a96fa0a8bf475f2ac7ec77d14fe5abe79dcb21b09d2e86d5c1106727f6e77496737b5bfd07eb86e689a675c0c1d51e4605411ec53fd2ce2f10cfd24d63dbcd09a561364904c0eb8cc3794ee651e15eb5def477ef9d638bbb667440fb6dd8490918a9d6ee65268908db19c563293813596b4eb0fc59a287d819ca04830bb24e7686eff6d474ae9c63ca7aa8ce0abbbbf35452d75d546dfb4c4d1d81fe949e44a1ab22fa9cab2129efbcf4185a54cb40d3177494b4cf372aab58340b127bdddabe15e06b34057b551204d46f70782417ae08e308a2c4468f12505ba4441bf61f239c9a1d6790097aab26bf2c1dc52444062ce2b953ed732369aa7f0e50adc540df84fdca2d8df5925514313f00c684d55cec783ac779c12282720422b05f76ec2ee093a96fe0379dc5bb6f2678999db8a4844905279f47c14cd9649239d09f97091bb5dc781a0975df3e5931f2aabd6528b9fc73606a9ccb50599215147334fe4d6d6e5e032c771309d80b6956f291481517f04e8c4361560ad871bf9e0ac820fcf65ff4bbc09abc13dd60157469a4d9c533fbea1377182c417df67676d8f70cd13c3e11fdb8e858ba0f7dd8d5d10dbc5ec59d0799183dd3e39562b86ec4923e78d82fec2775af662a5bcd22d2417a5bbf60e90baae4dae5d63959d4aff812f951de096296fc2ee5e26976b85bb073eb14da4ac8da7ce175664eef5bbcea0a4a2d7ee570eb71b1f293869e00690b9afe01a6b70af8090afaea219bf25cfc67473b8db8493fa9d821d9b601f7b0dd485dcc2fd60d923d0ffcde9f8fe4c0bd05271a0c39da3dae84db8df6d127d123c77c4c0acc08f561cce9a40feae1abd364b9ab75ba89ee24c37c10d581a26e965aa7281a5fa9d965c1cb2aabdd7d2e480305ee5f0ee57ef36752b771f108001b5c0b9a9e00659e8f408801f46c0608234fe0812487c1ddecc47caa7577923d2df9f884290222e916fbee0f8979913333610f4108dc0c805b306f5e7280d7b7b19c6fc6c3fe9db7553ce9135bb4d5f584d3ce7c0533c764ae1c6a79c221d18c1331cf5d44e50f722ede14e37c7da153b2248f36c8b051398c53ac317676db0d3ec074fafec3bbf7cdcd311c523e7023a050a576865000e2f02b90deaa15d1fdf414de6d2ffdd48b985d33ccd9f44cf7127178e3a784c9fe1429bc51ed681aad9202ccf5b032cde130ed4c25cb104d930772df68db71172e8051bf0e96dea8661a3a62064fbc3519a7f3d2ed42afcfb4656d4ac40acff4584f79ebd79bc8d47667d9e4238a1c01cb5840f33161e5d107476a56575890201bbc79a4c6d46f451f7b7ee246001273d93027b07aef8682e72d3ee6bc53d7426eff706d22c71417a42ec3c966b438e9ce2a02ec1bef52a837a37d080fd2aa1a2e4597096536acd2047587dba6dc5ca906d7b02170f833dabab2c9c617051cdaf2126ced0c190f6495e46df02023a83c5f05a4210ee3f092c02cb33048ed79f8831ac85139cbcd5faaaffb4c339f841fe49e889b044168c9dc6182dee2e18216075d93f594e897dcb2b186dc9978cbedb3fc406f047c9386d0d9c53a6b010b2e2abed1661ae0af5027c5b4685947627ca354f8ad51cf760788c02c3324ff7a73cf9faa343b938fe9cce000300b2d6ce751b35a44610aa51d1f9871a286534aba87b5ec8d9c25ccf330dd5efd1183e45e7bcc7841863cffe532adb03ae48e04a460eeffad0a778377500ce66786c2f369c049fc5a667cf02336f08abad5aa95bf69d1d51ea12f85a79294d5d6c5c57bae5d0144d1339035a4be4764866970d2b778c59f8c1950fb246f5bbb3874ae72fec9247a4e178c9d76a0e5d2beb89c0717c0cd7f6a7dfc8d1997a7b756de0cb8a96bfce0f389e27fa46a93fd272515dc707c4b91971b030a831226a051a26985929281b20c18607fa1f3e121d17a49dcf25f0c857df9fb3f61109abd31385fb3a49c32ad2d11ac13ecfdeffea138a478e541dad95fd91792cbcc84d794dc568b9b388791447c9744a608d099afbb8fb8e49d430a64981af4217e973a1224f84bc12f9b9646cdf6d3801da7d0fb0d868d1384f199d5afa89af76e6ae558f16fdb9b214350a54b1eac1d464a1b3699dc7a4569915e83a3165a0adcdfbf85bebca70445c823ab8fd5bb873dc5391b6c1dc1b44d670faf8905473a6322b2fd5884d31b8d27443a31bad10a3eb982afdc0504249fefc7542f61e6ad74915a88232767ebde0572395c2dd5948f03f5ea77fe8cecefbb3ffca56d792f8a5fdcad85341446e70f6da63ad1f062477ca342cf6586a38578f15bf7ff06a87b1cad050a58483d2e275b13d641d42d39775318a29ddae9ed7ca46893b8582c6173077a6a7a04f567ee99b8e128f79c360e160cce8516515ff6e13f09b064b1b2b9ced6b0aca6062e7cd44c67c4e69214fbb4c4afc7b30cb9717e5a023ff3a85a2e8b1bee7bec50f237c6e69383418ef102e6e621b6dc1198657c26c85dbf59b628e72491b78de0ab03f67233eea3fc5ae0e75e95b881c3e5c2a8da962a47f0f994209bcb1700dcb5d3fecc6a087abe4a319fa5eaa1ef0eb29a2a79ea261e9a4239c88f5ce8cbd48c0cfd842ef6b33711b4e890aa78cbf6dd148da03ed2da3e61d4765c0668c5f18fd5af8d8d53946a8ca1fef7bbfb43e4ca55af20afe301881f96c6c65bcbaefbd4afa5c1efbf877186935e817395eaf1a1fe6844fd8d2c76434cbf5430a9e46c07f26bf8c24cdc9a1eaee2395f0b3fcfd7f5e9743adeca3d73578a5aac6d37fe7cbc20f1a94a2881eba511784eec742368506e84cf3cbd1067b875927a4730da9cd579a4848e0055044b2471cc3759de9c0143f0812304fc600a2dc71503c1518a039173104b85e41c22685ea9b8e68cb73a22461771b758ec93bb7c99b022f3931506ea91a13443a8e5c264e5ddbf540c846b5b31f79cf333b76a33c6ba97aa5114a9c23895ff1bab76fe4a7ba10407ad30b25ab36cc54d4a218c498437895c3bf32a9e3f34c2599f033d72be090ab0edd830074b687b1ad8dd5d8562399759f4bd2b52bf6cb6c916d1675f6d006a59a15c8e5d35a9feac895b5264f9fd64d3d9285f84b6e63e9c661ff4e4491b4e65f66a7b7d00fbd814449b7dc1d9d949be69c582be94eb23e3562810c05835b022be2954cba49dc3ef41993c0bff832797ea0db44dde6ed95efd8bde36fe0792b915f935074b5e56de23e40636c255ae0a8d502f0f5232d37873f0bdfa4eede51c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
