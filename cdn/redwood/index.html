<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de228fc5ebb1ea223cdd4eabdf0c480aa24f1231e63c7e5e97990df0d99d3450381e4c460bd3ed948a60004c5c9ca28acb75cb7c017b4e0c178abc9d467c1a971474b04d13cad35c684ec9089aa2d0afb5dc0b9767d710ef38a9a43588343e776e350de589da7bea36b407012893303b7760a7824ce0f458ec755eb5524aed3b2afc15379f6e74f24f82fd557177888a118bf3cfc91c9daf7ba8cbbc03e191930075384f5641c8d099816dc001a003fa1f6b3cbfddb15f75328e220a5ee397f75d19d033225365ae575bedc59fcda36db962cbbcca7e640bd2e04f97b409f857120495f6d461997f11de1388f58798548876f6b5fbf844b62f164b577ba419bfd4455b6e83fa4cd40e5dab0507416084761c819153e72e1fe636e8822e318ecff4be85acdd9886f7a6cf32e86c3bbf3e2a8ef19f3c6a8bcbfc9cd9063063ba91e08c132585ee829598ae1d0c5911f4eaa1ecdfc506b678da78cf911010769a3fad8210ae052b29b2627581db594a54f3e0f0f6179aec27ba4459aaa98d315827d8505ebe8df2db73ae97b3836b88c1a32782450d0d820d1df78f4ef38d7651634d8aab77df7bbc4ccbeaedc9e33c74366b5362d4a84bb8e4f7237436bafec53b2fb414a3184fdd8ad646d5f61f39efd76097d1fa17a47c65a646dd504da39652d9781948dbc5476a0109749e64504db89a5e152180212af42165142ca9f853cd11e9f64f0b938bbe96a1a174b622010f0c9a581d6aefac0a1cd741cacdac637b315abf5003df67f4d71d654fc034478acb6541c0fb3457f5f98d8a51ffba96a9a278a2d1f93b0dd4e9935b142e6a7211289309226c9796949b72496eb6abf8b8a6667bfa0aeedb21a2b69ea6cb9ddbd9cbf08e6f2e7feee01d99b88fb81d69f1cb549910f12626949cbd065750c5da1888759dda20eda89d92c997afbe019ed40d2903d9e42a450ac1834655c1b6ca4457c8a6e7a754c4c6eaedf92164ac2aab480251a303b1b598a8779fa4dae9d1acc39714f93bfccc8d98df2ba8888bb58904e3ef47189a3e06ead61761317d003771e3a56af2aaaeafcbe6b17c638103a6a9b8322638c4be7710538f00ced760ed83f145a0cabae2d3dfd74fb68f44be7658e99dd3f4ea17f8175900220accd2be5890e89fb9327e6e054595cc20ab963c9c4b323683805278bf8fe5ccc05c06cac1f4f77e940112eb3c840035597433c22f530835b540800fe996008872c797b1d8a9b10a4e3158a3b45698fc03ed5c23343d4b18baebb48fdb91aee8690bac43454a0abbfe08980be57a76b5593917cf60f6f23d0aa6ef67ac7a4fe07c60624a1e17e90ff8a37c9672aa909686b442c72e8fc3d43536d6c5b729730cbd0e16efca0375233d8214c457361b4e4394459b97bf4dd78233ae93f1aa1037029356d89eb0fefa9dab8cb3a1a13a580acf27f149eea1ddfaad8af7b938f11acc789da63d50ba0f6808ef027031b82ee8853e274b9ae180ddce5d05e8997908433025c23f8399dfbf43b2c06d5a456a989813d01427d0a98775abda59152f3990e416d23fa9298b122f33787acfc8b14fccf76d61be32fe017eb348598687895643e19e9a62519b9f3f3709729070c480600af69641a89e356f07d955275e0e1aaff6c26415f8bb0c2eb85ede2da39d99b37d94ecce8a67729394fb271b174b3db1486586c382bd5e33ae7c253724d2a74b78140b13358206ed999eb535ba962eee1cce0807a8f762d3cec82221154d0ecfd3b80ded12deee071e914c5acd84cddfa83205fe1b1b1289c1c3fae49033872e3e0c206438b37bd38e206630683960e966d1f1e130f0af6e02333b4ae69ce19b755adda52cda77984a458c20dd4fad84141e59a3fb470924921d9f6b113c290674306a3eae045fe0fd388ce789adbff93addd978fb52959e29b06613731dea03e6b3ebe2461954ce2abb31b25aacf56a79705314e6f9d2142b0b43435591cd0036dfc5533a972520103081ebf48f467bbb5ac3a7508ae737dab9753d380ee56b861ae8634a3edacc21e41822f1757f0b163b85ac086ae25119f9e9185039dd3ccdd1d9683ddaaa1814389c114a90c7a729e7f7140efa874813e990a0dfe43db1e23b95e4be7d6dd3222aa833b8feba57945d6900acc548038f522dd942a8eb6157f824b1c6f83d940038314a233ca756ce080d9a457fa52cce121a04bdcc2921689e1d76458028ec6af861790814ca589b9d45ca672f49f01a18cde3de4a651bd84c0e0a21571f732c6dcd5ef6c403f26d3d2439ea7e48eb7d6ba2f92c3caec26bbfa4105ce28195e4c17029b11283516f1f1a4d6c7868f284131e8f02d4071016ab3534bffefe1c3713622be3d20f46812c39c8371ce1d1b8cbbb6bbbb7a983ba21cd6ee87e61e154db62e94665c1dd46e72f22968f950c3d0b29feaaebfa2b25d0ff44df1381ea38ba30d8a07a41c4502da920f357ef10f352b9a15a549833bc0135d0e8e88e9126255e77f24de9189f9a8acd9966a9736231fba26c8df6415c44e0c6662b1e8b39f4693e1c6e60e78f0a26f6783161ee6f9dfd04618ba64cad14d11f4bae5f3034fb34280da8f35fefa08868be37caa3d77550d1b213833128df34cc2e7bf1b36fa5210c4ded8afd708ecdb58a51e5076d83efa8cbb8377e6c75ccfbb1681690aad47b132211a9c854fcbe58ddf25bd7d4193e37d0abec1b4efd2d10ed89b6bd39445061bdf1ae9b214a529e98f85f25de0e1503974fcbfaa9b967678321a3fb78b442a43fa723dcda355b44bb267532b45ba8c9f3e7569713852ad44222f978d036b3d20fa1f91ce65488892f928f0e72f6d71ef92fb7ba97862497b7f7ee012554567afe4a362501d5ab6e75ab0d9f17b1ded7ff48dc6d12703a4627c82ff63b48162b485f0f91d9ca410254fedfb31f56b0ef432d3d98991a502d128e8c19a4e4b70de3fc0f6ed2eb7b4bb394ec60a55c43259f8506177528bd5b9657034774dae56a6dd2cb639382daf8e337fe544fd54167c831e5808d1c10fc1f3bf7518293b424fc940f158e3d5a90dd1aee0667970c327dc070e126514f6dc0b59e08189939d7878bc9aa640ad72e12ee214519ed35991f6cebc6076262fd4c074f7029c613edd77d2cf364192c0c93f6e066ac62bd23a003cf311dac2a6bf874ee28538d2e9ee0e7efd82d9dc3bf6cb9b956d9c7a0e89f44f7d34b04e429d8fab5bc7a56d2774120db0356f1c0e8e51c9150a3345c8423137618ec4119c025f9b298f278421992187ed362d388eafd13c95412580df5a737b2631668d6e3a13739a1b733bfc5b52f5b7db660f52a0cf06f2a5d3cefaa3df442723fc109d17d75715912780b77e34ec59f16dd1bcbd9b9db9e56cbe497375f7f7ffa04b85ae19f5b24f51535149bb74b25fa86dd42d145d230f132cdd6caebc96461e56f2135ba0d76b5d9ecdccf315fb2e30435fdcfabe65ebc395dcf975814c18f02ae3bfcd4c8adb4478bae846bb6984ac080376da8f29f8592661c88f2a3e0ff25cd48ca61b026ff25696acd707c233a730ee0264738ae45ac29a6b170e10bc5844ac73bf5c60483586ac8c6fa3d88db250a4277dc74c0cd8b2534a3c4f22c7364c3fa9e3cbbeac39f80ba367109a3015bcd6827b67df6f2bbc60cc08883844f4d118d06c2fb199a8c3b04a9302bd1e7ffe78827d40de6409b5a0d21e1fd2dec3cfdc95fc44255290f34ddb6fb048565f833361b831c45ea001da3903a083bd3c486c90f5b5b1847cb3cdb9323273c67045ee90b19e30bf3a8427d0205d1c406438b36259f39457a7d7de6d7c1b72168c1bb6dfcdc6de9ceb556bd741b6530105a5946e0601a84ca5d7028315ad66b7eae335b5ca09b0551ca4f9a03975a8bca7394e10c28f95386dc7d3f205ab5714504c14096d67f4867dd442319afdf71b4f2d68a1bb541e44af5d105b36cd44f551d95be0cc59e35322e5f1884ee32381bfffc813f9e907365e77f900ad26515b3476ae16e957b37bc9e09d613b90a2cec7abb061a63175030c917bc5186caa4cc8f464eff26034d4ab91fd3c895208bb9dab18767cca43b50fd2160681cceb237114752a223b558879bfb23134dd2008370b975dc440e1b4b93cfb541948f228922cebd5571a68ffe7190486efe9434d81b1fd9ccedcf3c81cbd4fe16d6003a03f2c57a85b99dcbeecccec73081eb86a4a694bb8e07d91415d7996be9e4e6758e41da66aae45c1269d086c9dc17d2fcc764a8c80718e7e4d3f068a441bc808b24eb82ab6d8fb2aff031e0c5ae39f0cc3a272833f3dc0d14406e23e367d38dcd2cf30061bce50815caa09bcd795bb2cd572d53d0bb3d503393964656c76dbcdd3125d8c8d668245d24651996332e60db0bb5f73dcd7f57a5dd4059142b0ad0f41983fdaa53f7b6bea06b62a344dce2019b636a938140b22ba03f2c7498359f762bb27a8a4e3e30986eca100d7ab6fc51a511a7fd10c393c9bb965731425a8e89187cb340d9d45abebbc5c616ff2568cadd5966d57c5b933e94393289abd2f5e542f2b9dcc1fad267b7110589109dbb857aa8db667c518e2321fc1de5b6cc0ea82b2b81e79c479b16c1810a8597b0b3664de6bb22b4dead65342a6669539033ea09c40457b81772bdd6dc687be0b4c4e6095ed21e8bae79d48fd272b1c5306af51685ca98b0dc7178ac955a7b7ada72129fd46a59f1e4e5f01a63d2ee4b2ce7356b3905eac3688b28e2b5e79743be641d6568e0bcb468668daecffd6fe3e5950c51a56e4b4382aa07fc41ac08d2e8c01cd1a154ee322f7a794fa3ee8cec76538597f90db9117fe0da124cc8880527400bb5e3ff1bbb806d53f6dd93d77da2ced9110a184f8204252183b6aef541e3e92509dec5f296296c01af19c5b5fcf4ff9d252c4eaaf72b3336703ed64123afe8b8386b0ae47097e26d0371a7b85ffc550faf4b2d4a2480b71dd8ff763d8a0b169774d0e138497761c194527473ad9fede1795941b22d0e6e1dd673b89e2677527c142519bbc3ab565c98d58f36632d9a7252d9380384826b6cfa87cf13b1d7aab18fcb60383afcba78cb5f5fd7ace6ec497e886df19dd932377b2b7fedf0edc38a618601aa8a6616834d4738a04f9c54ec6e00a91bd05284526468de8ec58ed1320d1b3726245275995e1d235b20dc8b5cdfff9a7dd8cc53c8ce0cf76f2404e8acd192df64663bdda31814dadd7c8749f74c3fd5e2285aed22a17e2532b51473788f32c6fff9ea4d80805669713c7a4faf1501b2665cff5abd1773edeb33b0f75b4ca9cd3f899cad4be7abfe36b383608051bb87dc7decc3a84ca2d61302ad262959c247098ac9c08dbfb73411c4c7f982c8ee083238f40923340adad557db6dcc5fd90e6a3ac57b4ca3988c92410044556626451d902cadbafd449967599dbab74084cb6154dcfea690898752ed97fa3b2f8a40aec52c24206a4c5afda8ee4327323283f1a4ed61a742d6e34f0d868b9276a048c80a07ffd94980ac08c08581e58782d2d11e518625e62d3313669a1dd4c35f51b0794fee6bbc60745d18d7a7520d4bda9ba25ad84916eebc5eca92c9b87c96ebd233bf023ecab7a03bc88bd6dd012da194fe3ddbd60a047bd2ce0d1d8cf4d3617fbf72d2546f73d9912d4d35c143d1d0a24c6cca9787abb777ee09518574e2dc8c5300514eb0ed11b61c220af38de5fa5d8c91b9760f234b0d7cd90b4c35a06c661335930af99489f805030982b589f08ccd287223bdda718b86183bd3609d9935f764b64ec814cc0e9a86589fcf0f9f53254bc3ee04197804d45639646ab134eef0c2e46cca80cfb09993b2a3243e72fafa4c4c3df86cd65bc9b8fcdb196055384bb9b17e446396a9ef507393310800f9cbcbb00ebaa82682cbdc0dec0dd226dbd4f1e1150b65be1fe70e375b761f6a846b1b9f6a3aab7840bdef5d6211fc2c9ff913fb3fa9c5495b1fa4add4c6b8599fefb01d1686c56e14eb2af56e90573a1a860cf559da2dbdc498ac5f973172ad9d8ff985fed5722513921fb64de7f45d527f78178e1c010610b063d8f11ab4247778f36094c1daa62a7cdddb1e5968c2f96b08710caf17e78bfebf01d9ebc2570121c7c889bd040ccd154814b60580b6843969fa91a2c500ffe7e464360784a1d1a5e8c2172e0d19ba55a1200a8b82255f6f480e25d2634c7846705adff578033b9aeebfcdeeb7d612e9f16a566033306a12927f12cbaeeab1f389ce9639fc7a86895acc5ba822ad428bca1583acf9f4ea3a728d56a12aacdf7cbf64e15b627853c36315e0bb12005b97e5dc2843cc311ee3f0ff5d030e2605e58306b42944a3b413409b7c060be17a7d3298de6cf7b132d2279d276b0ecf28d0f92689cbb31ad716ee2eaadeecc7df19caf5a4ef7ba19d67040a127599e4df521eae4d869569a4194fa214a6252170f9c40313d363cdb07f6a342b817b9dbbd188df884b858f93b9cdb9a263cbb3ac9357b121695e2e5276c0b8ceef3a52ec9ec6dff8da2568c9627b4db8b3c7f35b114b8f9bf895522fbe91bca7fa4966ffad8f1a87195a0a0f1b35026bdb22f7635abd7bf35f886e166eba3f1e4492c1cddbe97557c89cf7d4e50f40c273fdbc82e24140094b9059c3d7e93e9f1534ceb3f4f97e0b451a25ba3bbab99365b92b96a2445b08d9ce8e0a7b7aaade8d74aed13313527d38540bc0406acb25481ffdedababe35a247bc64aa4bea3bb88c154aa7caf4b8293161b2dbd9ccb692a1029c3661c2fff1be150e4d117f37789291ec5471a7301fb93efad85dc95ab8cba59a5c0c58b459e3f22a7d79053fe3e1afc5139b39dfd26f1f8cf5ddb5f568b9e574f38b0affd31a643e0949aa74da6b07a5ba7bdef028c3ed08ae55d891a932e862667896111ccb16200479e254789bd5e3dcb045fee04501f96d31f6d3b20ed19be67605fac8c5b17f870207c0533765a32a675fd970eb859fc783579a0d79970a03e6a8cb10b0c9c5edaaebf02298d1220452efbba7c40ab571ecdaf6461c88cc629534fab410c4823a6a29c9270be77f0baa298e944b03abe3cd649ce4d08b124f4d73be66b9d01a5ac182af6e554d1600757d370104f5e45a722f6370636ce338769f59762d6388141115390c40e9eb9ceb0845c8f9c9d162738f38949cd840a4928b4e806ce8374d50c877169ac9ffa4cff514636259007a51a99a36e059e78508cd5c06fba11fe998b7852538d0fc5ccbb0bca304145b6483e5054e03bf7b79ed6ae8dcc7e5bf8097de4969381b341d73b441947e6bbe52f8ac955ec83ec242cafccfdb0a82621faea44a2135f386ff7c9f5ed3c19456e432f68632ab238628b02c1b72fe7c50614ff7b2a07492681860a306132550f55352246402d05519428d0ccc065663dc80071cc7cee7fd07994903c9d9529b9e0459632379ceddd1a6e3f044378542fa44ebd184aadcb0214646ead45ccacd8ae315664240cf597c480b684d27491c5dcfccec4a54e871ae788609cf96573c994a5d4ffe0af9858e6498aafeb4a518f0c78ccff79b2f154da660c5ce7f16941d0e1e58408b6d0f90ec0fbb5b88ae683f3aed31e13ff2e069987d6c6be712cfe612f46df9883b8e625aeab2bcdaaf139b8d2e2fa0c2e8f9a1ecf001272cf7d095e7c79c1f828b7b0200c22e07a8af066c6060c9dbc5d1763076549d3943d0bc034dfcc95f268d4a85eb00aee7de49b728f101aa2f76201cdc464bff19aaf35cf9db65fe39fd7abf8a6129e968280f794f970076c4ddf8bdf710f7c774bae9bdc5f55377507b85005c49c64719d94a34c1031573ecf596099fed72afd1b4f23bd6ab2fee41ad5cc77e36c86447e412c851eccb0dedd9ed1892c3464fb5ac8e63204ef2c816b8ec682a2390373386001e64abade7f399db8681923e415389129724cbdd3e53baad2abb8fedd5db2f231d961de104dbed136240e39f2d1ba1d47b99c39f7cc1ca608a1e42431a19e8870bca0d08465168e9953b01809e1c15805fdaca950732c0b8097b046f2dab18d4e7ef42a4aca662a458b5b9796e22bdc91c1487cb486468bbfe3802a6fc3e9636bd4947fafa151efc99e916b7cd80dbfc60957e39a1d89a9d105ff44ad90b5f04a89ab9d97a8e605fe1a766e51315c9e908dbf16389db4b8c149f058e0fd7f32d5ebd92855644527649701e263e9cfb6498689dcf1bbf507c4bd254619bfc7941b20c0277450bdb2fb2e125a1e17c402f6df3501f8e8f89417bebabfa1d4c85e5a7a718aab958b86618342f2bcb80350f33e5032c0214a887feb52f1abf556063b78a20e5529fbeb1a64301417e6c94f0118e3ceaac60e65283be5bb4f58daf1fd613879d24796c5dfeb24c3b5d86a4b4d35520ae8154359cfb9d1ccd942f0417ff6675bde9cb899ef474d7db5f58e1b15f7d1173a70a2ebbefd6272ae27e07dc4857b7ed9b22b6178c6dc951cebe16e2e976ad541806824088da243cb96002fab5cf18b0f4fbb01c176316ffc4ad1fa99a71493959b4eb00d68b56fad690f8a2ea8ec261c5a586f43ac160d54ef065732e159ebe6adadd541a3c2e1645332ce046e2f6d189d9d7bbee6da4f0181a7e9c51e0f03680ce1d39cf13db6df0991e8d39533c34b85fd0408d163bd150a6786174d216cdaa13c2d74cfb990ccdc1c07ef1f8a62cacf57f42437dce943b99ab974ba8fc44a21326cdb5b0c6257b6b352c7759c01b70758a3d94b97b6f77c80dd4f315f27f18d3fa9b4005be2fd4b5a15bdb09ecac2329ff224d15ed18b91ddda4171fb607c342f1bbfe8dfac17974209e3174dcd46394d9bd51d5a3a88e9c0805f271a594bf2abd653c3c031d4f04363ef3bb2c0adf27b7f0a0fa8a3f924ad2f9af7c451d1f72c67bc64ab338d8cc6392c3f7df8ec0afebe0a3c523c93a1752ddd3739b9ecc0120511fb964e0f9435b9d226f3973ec3a14a8d14b6914b1d7652da4da7d06bfbfeca21fe41b0ea56d42886c3f93fbab6f0dd0f7e4bfbca0ab3393e32881500728e29f7cc0c5122ecda08ec1c599b79d5236c9e19e8b64dcc7a0381d7e4415a5eaf8067ca911c452b9af2dd65753a1653b2c7f31a63414bf88233adb05be982f1c7d3236a5b252fb36e601c5c635505b66d13a1564dafd345732567dcb46195cfaea15de014cf702551816573f0dafdae0d8413aa4a869c9c448ef283d192dbd5b96f94265a2c02351f4db90bb8891841828b5fffdf4e21f81c001b30ee80cc82e9a5e21f1e3fb960399feff803347feb16d774168a5b6a4cc2a0101f29945a83daf1ab4d583019284268f4bd4daddbac05b0ef0742d862c7b38feefebcf0100732bed48868b0fec95e3581db7735056d9431ad2e6c8386e93b23f7ec6a6eac659f78dbe4788d7fd506f6b4719024d48e6bf5ca450bd6b253601836fd733e7438445e8ef529a71062267385b4aa40846531f671958e908947b823dbe3bc175159e0ae8dbdd99d9834fa8498b54e4602acc1b016c34b04e2deb22d9444f7985768f043da78171735cbf0714363c4c30bc96994d8ce3c1a834f305b3e2ee29e1a94307978ea01b9a82f12a7a4bebf4e234bf9eaeb4f62d48dadf0c6d87fe73cece518d669f9ebd9fbc4e67096885750638363a099d6367c24aa4421ee0917224c92e6936ea082258e070a91c5f51b80dde98f3614ce845712aab908f7811d06de93cf43a8201ef193f19f47b7211c8c470c075915d5bdbe8fbcfe84a60bd38879f8f5963314bd0dd30a9820399f07d0619369debb13700744b741d08e0bae5bafbde49ca922c9ee5be7cf3e5af0b4ec6d73ffad1e992fbdcd09d6451148e219d8ed6949955e0f5acaafdd795c6fd6d801c3625377c6a79b4942170819f4c2cd4264deb7d0de5a6ff4b30ee9e79b097ce64e1a2810bacba5ec80dd5c343a73a3016d4fa6c122cd6b81ab7a2ffa371209facb257577ba9c89645ebf7af4d0385285de0c79c24f501c91dcf8173e2254858167bbb8df4bc1bb810b8750ee101aebfb0b08afe7eea437f2780b85cf23eb23748e77ab392f7400b3b28e2e65ab8744182964b29626bf25aa854e270dcd171a26819d6c7de7fc493f04f9d688ff1b4723aa9aa5074a7770a63d75681875a44dc6895885e11dad81f0331141b5de2da8dc33162d6cf0ec5e282d73d126ef96d137c27b51da6f2f1566f0fbce6ee23daf47d4ff13990543e5cf6c8be0524392480b5e2bdb99e018624efe7b064fc43522b39b72f7adf803b8e328c06b8bfd4e3ed28194eab6c19717e1339e53f6c274084f51e8ddd6e794e3ea3a38e3fc8d3129ce81586f8c848fa8b1905f66676cb1eed499dd5d310fe5c2871fd03607629dce38661c802be1aed48d49d481c5c2fc5763d102e564a8ff38b9fba17cc13267b438ccc1b30837ae17958c17cff358f4e57e4ee2339004c3383601eb861bb889d38a8dd6d29eded854c883bcc9029e391ce58f5234c0abb6a3dca6a75fea76f94e5ef02841ec1933f38c02877a66cd7d157b7e2915c041d4806789d5a4fe468fbc839c7551772740f780c7d1fb9df30b00eb526e911fb9c2b2a2ff293fef4f4e9318954a65ccf52c4c8fc01a6fd417ddb3b5b5d586371a8eb01200d1c13ab28e36a326c8c28c91821e341f3a4312b81011b922afc615a05130fba09820d62c1d7de55f5559231b66a1ebffd119c4800b85be0df83f63835edb343ebe44c2112a8ce958670e1e9213925d6b69c8df06fd6eff548f427d60d0d7ef821638297411f1442252c3e8839d754f0f7f3235498e92863c7d6e5b40e722eba75540fe8a3a4a84ce25c29dd9d0c671e735a882b0bd81ae72255fcb05709920e70ce6a72436c2de03a6825930b73c69170b53b7d9ccb4a704761f528c33bbaef0fd454ab2cbbf2d11bc21d6bd770c45fde990b5f6f77539a31013924bfed36cbf706a85aac5b355174e3236fd50f83f6d265c1b4b7c4b6963f984b3af6b14f38514b57ede81cc28709428ace0b6d74439a7a9608c52bc56b92c6dc40b044efc2cbc31ff3630f4521b64798f3fedc709634bc20667ced418305e15b184b6eb738fede5a8021e699abe92252936e5df863059a9c4a0bb741a8f7a6530fb75b29ef8e76f7e44a0a09a140ba5ad51bce4b7cde89ed430aa0a8e61046aa6c8ff5731a4d03acdf35603b37a6056f29a52c2c91ec6f92c8c8123a77fd7a6992983cec6ec344df03f5a2f4ab6cb34bce4be90251f6aa9c8e2f47bc4314cb2d6f9e444b19b35b8c0737af33441c1979760619f9d42cd56fc5569f342cfa193f56f735e35deb6c17d3f771805a04f2a52cd704579c28f33134834c1246f5d34159d478246d563460661ab72e626887909ee1bed5cded1ada9f412b8c342b735b7438538114641fc0ab23556b6946bb02fed04fb9e06bfc258960a81668e8df4aa02f530c67b8d44d856ab5794b94e57872d30953bbfe1f4175e160f2e7b7ddc9a5d52ad3e917a6991fe4d288e3da1358bb1c9fb021212c0af8b87686968bc37aa850763a21a78032f110810301d34a559eaecf22633b9011a9e0a5b1d9c004abab49677239bc0a144b3616267f474ea9fc913fd6a0cbac82a8b7ff0e0b3c9a5fa891c0d6047997a49960ee6cc3bcbc875183e837dd7f6930b9f553ad261264818a7dd7dc1a2eb91e8b6fb1bfc2057085ca2fcbb8b2370bf00a4b21dfd6f2618f43a7c866fe5b8b2edad7b85c24928ece131a0f28338a5d9b0d27ec9496b52f0eafaca1533b5e4a9464a1b5c1edbbcccd2fa18741178867e943f6447ff3b2d629ad4fa789df02edd792780aa734c522d29a0b5d2e0a72b023c98b0f80d8aa0912af28542268b9c3f00f541b19f0a893c0ce22c75298ad55dcdb604654927e56e089bb707477543577342fa582e79b45ec15d80d7403aedc556f1481ea99e248d6a3d39287b368e36c36d37d52554d1c1fde696760f2edc512fe485dfb5112fb2121119067435d0012d4e52111ab6bae9f3d3123b70a81255136610195c60b454d40deb158a9ca6aaec37456c729b4b7d8438ea35c4429e5d1e22be1f1fcd51d96a1b976663fe361211ad35fc56236698112bc5e06c5e9e5cc0b868e33707a172730dac51071fc68cf59a8a4321946d7c6dbb1a0612b0645a49c318742ce48841c3ed0c4575d984e237ae345df5f3ae8fbbe138d16124caf37fce9e7ee7a8d9f0b8cabae650a9bcaa1d9bd5564484374c3528e736456c133cd5333a383703b9be7683b2f2339d6863d9e884948bdbb1da5bb4ac052f6230ab6916ac441300549df4d0b3371bec1e33af6b47c529a5371989adf0e88ed9eba0dbdb444075200a654bbdba99b44b72aec6b1f8d261ba9868b54b62f354d496eb13c02c2a920ab7609b3ce889ec6f40a267947bd737ba058027b8f5281e43e7100c99df17b8311fcc688fd94c0695fb602eb1c8fd8392055652e27d15257855744f50f1dff001c0da1ee807c6d635f3baac64ee7ed3a6bbcd9fd896263ab832084a77c60cad61bc43a373efd77690c5c65494c7c49cdaf765540d571d5f8cd42256d2f9ed553193d07880453eb55761541bf82b5f10284fd28d8c95d9b238b015c1c6097db1c15bbcd55aa87e59f5c948cbdf0b58ed411001986e741181bc1207a0400f90743a4cd0ee4f30204eee22ee10ee4c531a99e9590e3db00133d191e4a1c2c5f86ae963469fe4e73f284b2a670c56f34e9d7f9d3b2932ec456dd7e7beaf396f242b19162eefdb9e60425de53e27f98d9c68b5caf2c1389c11fd55bca529f5519f8755f4c4dc2715a4818a0264a36d35c161e07cffdaa3203ff993694b236ad51b8d38fcfc7cfe1e195589da23ed7eedaa586662a74c0cf73871a9576ecd855725350ed686b4446cbf3c4d319946bb70b2ceaf66eb4569aa60057f119c585e8e40de260777f667fee0cd5a14a88114e3e2c46ecfadeaa6a2980cdba8e3c55ad72179ab4054ffb1be906a15e2d7802387e8c8c041ece50eca889e70bc49577f97a20e2b7f1686273d045475a497f850a0d22dc9302253d85d8c7b956d67deb5e1b73d8f1f73fbb8440a6b2832670691a5f0fbd73288c08c082bdb3d5597ae4bd2ede05ce7ebe936b2653514e47468d99a76a46f6ed1098050c69a5458986c6cc4b83a2fec083cc6b62624a3f8e0defc84d124c51b37f0e31d446c3c7d972390092a46b2544c4065b150c4ac2fe2f5d496f85f28ef73daaea000f13a22c86e82c61bc6aef97bf4106bb32001fa1ef62c2b356b2a398c04498bd10ccae778d3fa3ce85eecfbeb6ad53a1cba787e06dc1551c5173acd6349e36d861a95009e27fa14bba2ad9e5ac69140f333dfcc5159eaed52f2d45abed7c33f0ae1350879e872afb87cfc130224a6968b53c73610d92f16ac4f6392bd1e2038e7ca7329894d823fcebe4418914dcb23d0d2a244bd27197224cdb32661480d909083b22613df2eef87a8f40598d935ac6a129545d4637d07031359bb433892d6777354e0a388aa2a4de6a16cf82a6160aca14a0cfffc9560d66f49301af26339bd36a5fdb15139ca8f4bb2b31e69a6d1e0d72f2181acce167f4a426843c420c845dc582e90f1f9d55f12245fae2b720f2dfb27d264820334bb7b0df52a8a8b23f169d988db7edbaffcc39f3e74bf5b787589d65b734e421ff8c83a61121267b29bd3b5655bc0baf49e4c98b57504cf7db6979e61e639db7a5ea07f13273c26001d4e3171d39e4a22d375b5dbc811ab749702d8d7f24d4e57f659b9a7e4ac91a16f0cbb13b87e495e0abe377f1a86ded2131f660ea50b5d1a891a6a62ea1cd8045fe243f47cc8152c956a0d4a32733c365c924038515237fd21a27dfa82117a985d6465a2daf83b175a6b7c1b014e729e77a09b03acc985e3cd62494fc2b49a6de32b24c35ac6f90a8e1f866649f6c7308982c32a2f8827c88fca0dfe2fda31433076a9647d811e43092a0b78518e4e4f9fc509f37d320014a328a6a90c718f1a1ad65d2c4e8ac85b23108e745efb818f3e3e8d412355e152760c76d5d714d1ffe88203ed3ea63cf3e7590dddbedfecad214cf661403e454d8e589078023374b071ac16bcbbce649072836d8332864ccaeb42832d1864fc6c73e706fd1684dd2b3e493a30cf3b596ce53f140d97e75d45d764a71caabe829c15eddc026709abe2a5001f2364f33a43868370e6135c5850a3b663a109e8fbd15e1fa767a7cbb1b2b08520e5f9d4c91ba9be1195a8b59800807c327fc6e9dd52477c187ec852844df6bed787d064164a4288f1d77aa062c663cd5d163372e2fc31ae76ee265b7629ae8b29976e529b32d7a629ae8075d3b3a830996c6f0a8fd29702b2d4b042624806deb6004177ad97d9988512715187e8f906a93b0a115cf6bbfca6c953f609afceceed1adaa8b9793bcd0ff7af333ab42fee822fc735a364b0d765d7ef03ec7d68f5f66fc2220348bdd600c4e70cf70f7f9812eeee58a7700fad1920b25243f26588e719551685b6ad98365b001e38883146a3e8f4207a45590638d19b4da675c75882c40391b87210c8e4642c80f16c8de1a5b2d3899c79ecbfa58e9fa4c6774d4038ba57808d73c5a314030a0f84e0288ed2d1f61baeac7f6d79d0a8cb40581f497307ebcc210f93dc01e11f5fda6d5f39ef887d6ade28f37868703e72c02a2cde886288e01ee6e43aa23c407d4b094db94ae1080a7d83cafedc24cb2a183b14e95eb5de4b14c1f41711b493981f67ffbad0dd6c48c60092b6edf3a9c026e086cb287a682f3b83d6745500e78559d7ec83f50f5a35113daee4c876eea3c7e04c14356a7bb9e3f182075fd88a66c33ba9a7beea864b417dfa2eb1803f5ef8579e4bc9d5ebedb2b75f40fde1403ca41554c985ee308091020cb223857a2467cd6d13b63c3e27ea6c8a54cf8bf1af1d9280a8fa21bf5d5d229ac8ddf510ef49eebc8e7de8bfbdd487d7007dd6a63c456df0ac26bef704bfa09130e7b601af376286b9bf08c0b21cd50b67e56efab1cbc758013f8f7acc88b5445014b35abbc5971832c836b4b1f17bb409f5b897f239567ffae942f7670f88db2040bb1c46628c0207f162db6b0347542c66832ad9fdf3c6841c1e9ca1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
