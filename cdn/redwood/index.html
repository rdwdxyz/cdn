<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0ce34aa8a5b75bce14a5aa11e9e9cdf7351746be75082e22cb5d4281ac0b890bad276343f69c7dec21b9db0a10098792dc2667709d6df1181efc056992f555ef9d6c726092b46d4d60194e451815d2dbfaff2304e204d23affa72f64d12ee9722184d05729f92b942189f0d7c3f26e8dab29895df9089a442cb69df48fb71cbe168d46af7c40d351c57c269bf6bd89673bf4a1298ffefb3a4fc271e8fe1af28d057a5ea46d4a97838500f87cc2d3c483327350785f93999b099060b7da79fd491b919b837a41600dcb947b40499038646375018710b3755266f75a399862456756b8439005699b55ccb5ab7641e8e4f03381121298e0c0a5517aa127dee3e2e2866caf3b20fe1120e888f3096c3de4b645011a9659f966203c5a2403642bd71598c46c3aa097430251ee2c350010aba2d70302c82409f957efdd5513c855dd9c6e893d488b763535916049f7cbe94e147f281d01788dc29c38cad26d33d76f366ae817ff0f3ea31f72b47541a7062bcfcfb2479258a87b0d26866c5e0cf205e6b5aa59da513b931bf774a6312c9875cd83c479586a0d2ae802f2440010fce6fb3522be440013b757be0b036216293552611e92566161206a9014521048019d1e5e24523044f54704c68cdb210682e464902da49ea5df8d69f972ef45b177643d0cd870e56f3bee955a23d29fb861eca07192ce57fb35434ca31fa4cf8e1425671ab0fd9619d745583e46fc1f2c6a0adca3025d4d8f2e54fbcdd270c040c0ebac9d8182c11431eec919fed2b819777b1a451a927e8cb1c515d14b6660208a7e1a84eee667cae767436eda7aa9272037f46fb116074753356ed21e08f29b494cf433c0f590b2b9e5c46206f3499824e66aa29a75120e837783b47fb1b9e9421ed92cbbe21ed1a7bd61d0ec48b936c1bf26c10aa2a06929d6dd7d09ab215b52d781a7c1db2bb6e6b04fe429ab69c327a9d4cc23ed8eea0dc77b5ee71a20dde6961ebe8db440c20ae4121c24d2fb35aa6f173796997a0aef42360eca65826eb842f418f0bd1c617a46e37b270ec6018664d2cb7fe250ad93d7d7c1d6b57930d1f59d5c57cec26cc71818a77d9918b9e010f3fb1acfeb8fed4913e61da393754f69b51e0b16c346ecf5b8c034b32cbbf8ed69f118929fac371ea2af279b2ecc7744d5e65f4ffcd1cd8e9a803ac4f12ca639227ae7e0a47b44beb054b396a9c5935962ff496c0e1de505bf60c3045b54d83a8bdc48b120980cfa87513ac9a8fd1ea61dc946e84f4b3d06ddf2fca1b5e642aff7862631e6eaffd090824dbec0c42e0fba8b9d80a94efd9f8d2446264bf0f9dc2ca85e0dd211ca446d1128e52ff3902974b5cbdbda35ea8f52385cc9a0fccce72644a8aa1dfaea55a57dd8b1b3ba39cae1917dc67792cc3c94c7e5353d5d42b29c310e105e37da57d1f8ff4f84625cd910bb13c19a7154cfb4a1cb42b1c7d2873e298f48bbe428b01326ff262a7717535c1114980eca29f3f375964253c9689960a21905c6cdec0cd507777f157c9fbd02bed5d714bd24bd5246893088778f6f9cb645f1041836dba9c5171412a426ea9da365c2bcb141be1492717380a8bb0d2813b33e166a3d177ed307529f583b0b08f311659901603baf9701a9bd7dd897e09ea57b7366f0b3c2564abe054c594763e92dde8b96f11c44e0dff426d63040cce6dd1f949fd73108693879c1d4d6ddeeaea55feef5d9a75620546f641d4d0ea8e27c0c8fe8f6fef00dcf53f64b67ef76858f08426425c1c60d5238511223fb00c16c0b23196b3aaaafb35c2395480cac7976472dcc0ae8db5aa0566f911ccdab4007d2a1416a81deb7b15d64f6dfbe11e0088106e19887b527983e0a885e67bc35a4c201035c62bee7a433f1572faf27ecbb61292cfacc837bdec08acd38174eb75d251685aea73e83c0cd7ba19b0a3143be64e3e39c2b9242861317680dfcad1451e9bc3fb959d57c352f3edba268d5cf391051e05ad05a411cb80e313e34069bddd052b9384b8947d020457f9c60470390f9aa03fccb46306f1563a7c4d27d2556413308b444a67dda02f3ef5979c2d7459b902e03ad4b1a5d2fdbc57b2997395e12a79c3238bb747de311918811b6c0755214901137866fac141b7c25c556598707e7d82d0da698fd01898bd48a8be2d37098eade4e34e652db446e1ec7507bd00313d782da276a7f93f68109fbb138b901b4fc7bc1fae570a9df249a4896f361abb6668cb94aca3b6e0473e6f6276e56a51613ed5d08668c5556d1218ba86c43c6f6418e842485c34b9bf0ab78d3b90930d3ad6ed2e4eadc2f9b2795203c773992c62d0a02ca54d6d3d50de6e3fb757e7f7390c102ad873f70e7a5185ff7c80b3fd889d55f9cf03735248ec0dca219dbf8272fb2efbde6e9e5afee23b4943180444acb618ebb0b0c29e7ae83842df7caf6425c72693df3ce51a499758825e1dfb7397792cbd7428bbc5ab65e6094fc70924353be363eaf788d6889ae235d497a584650e5ffc431d56f0cc6d123e78ff0870a556a57cd2570a64ddb07fa0c6c0deacc1b14f7e7e5b8efdb6752c147bd5b923c84f4b4cc3a8edcc44f9023bd174f23794e3116c3cb6b6bfb17c070fd74b1cda6d7010be6b2df11522b71bfac369c39a287bf49088f42c1df230120150e0b3104a2117a37a58e8b4b6bfd5a31f67bfeabdca4d517ff91773ec00698e4a095bf14b03ac5091f1685934da16fed5a3ccbdbc724149a5e8ee785416b01c931d5606fea9e30965163f5612f136f117facda58b515b4dd8049b703830ed3cf571ab5aca81f85d3d2fed8d5b159fdaa2b5e833709e031d9accca8a9af7778288c3fa324c3b09762b46569900de8bfc62d52526fdc401abe3a500573021f920aa97d61940c1db83df62ba26d19303dc66df67dfd6f28cb5c7d5b2013a97183a647153f9763b0e44b54f9f798737c67484a8118336a5727427fa89ad42e7425506142b8a0c6198e95610e43c939c6d2c84e36c3f54ab10eebb1ad81b7c08a21ddf07dfd4ba38d62dd896a0f6c5244028c2ef068a014e37bbf2339f5083393bb303385a3ea7c6548eb757471916e34e1ee20bd4cd3abd00058fac9dd2aa7a071db73114dddc5026bc89278643eedced10210b83243690d1216e647a6c5e4194eca393909cbd04872c436cd0824b19f7ebaed9a4a325d8297cdbeb7f844201633293ba2e051f185d39cdd384e5253b973917a35d3c77547d9d9f0ab240c41955eb2b27477f1395ff43bb8dc9a849eec908531f721fd3585015993fe565524ab15a62485049cf9fa4423dc44540f1129f0bd84c54e57ed5a6e0f39d658312dd33c1382a801157d0e93d7809e633baeaa3e6f0106cb9b82460c7fd8366b6aa1c2750749a9f1fb5fb9baf3e252ad1497356a8af93a80529b49af2de9fa6cd39f048db252897b019de315b22e5b99c27a477102deef94f9268ccff27f8ff435c25a5aec68360d26a77d3e17ff6a7179c87f07898d4d7b9ee0a439551d2747a0fc0f71d96aea254f70118db7be9cb138528c9c34e6c68529ad1467523c98f2beece7493fbc394200e30f7a03bfff6310de98134724837bde61ad77106c7b9c622ab1667534a4f592e13c3d6349485a0b4204a2123ce123fc767ec6fa7a4efb5845289e3ce1719eb248c390f2b707826f3c61b776db2ed84b9209a92f5d5086f2759f34da8163747390e27129f354b27aed4e3ac5f69ad3261ccb24dd9655479b01d4974d2787786d138a4844f2f29c631ab498aea9f98c88e6e04b74b2e0c1c44f5060cc17e0fd5b6eb4e1d8d28cdfd5af2c10a050607d4ee05faf9af04b599cf14e11d8b3f954cf053bb25943a46afe3cc3ff36f4a42ce4d36a4f923595a72e414fed373cbe98ee222198b80c7ae502e2276aebd456b97bae4dbb12d7e5a75e99528cd3ff6de832e74d3d4c9536dcc12a3261c3af4570762e4f33014e013dabc27a77098d5e5ff126a1f9fec794c3ec2803a374eb5f992828b2e40b0e06a5de56c74d26f1299ece89b335b9b686c71750d602f16683d226d5c18d48ebec403aef27b5f3f9701b6f3c527340a562e2b0889a45fafc6beba5137407f4152860d89d7e9af54fdb9ccd005221b6badee266dd402fb31a4abccd4d77b385a387e8243932fe7bda52176793ff6e1c9242c3c72ca6b5368055754d0813e656c7536a9137f1ebe65d8197ea381cb94cff089d7d0c7fd1f6be6673892a850c8a7d566fd94303b1c83be944c42d856ad3209656f4c3a44b81edb9bfb0f2062f2ee475d99793e6ffa0784d56a752e14f8b9b8316954930eabd21d434b2fe929071931bf547584c9e08a6c8a2c978fa6aeac187f9f4c358136d6926790dafacfd9c34d95fed55cccad671f1554e5795e45ca94d02bdfc84a7c43d9569e03de29fa6b1700551aeb60045e5755340de8cbdb4a9ba461caee4e6417791c933c264e101011f9dfb46c5392c33fe61e9550e608fa8775d6fd418884e487bd422092b1bd4c3cfb7d7d6ae842aba529fd943a01a03ce88bf204f1d0a61eea6eba405cfd78c9190ef51df18cafe6da3bdf8be4706f7d6fb5acedce0c40dcc7b15c1d74b45e05bd8ab173b668d8893d1b5b982cebc5b982610220846155e7105eb5b40558bf31ca1061ff08438644b15362b9a2d382fcff11f6b54771b789b276e5d9847838f9d4f0a902eb6cf377bcbc4374e63bf8d932e55ad90a8ec190f250c140bb97dbaadb384c4ae5cfccf39bab9459b42258e5447dabf0144f50811e7570d47cb718bf3347330f1510f1de0da46744289894113ab239a65e12a4721805795da2cb43186fa61ca166ee8006cd9557b1f514f4bf045d3e376c083c08a5904bbeeb78ec89b467b1735c2e28036341f67b03109b1fb84738cc775f2810c894cf068302e6ba58c3f24107e5d7d16bf57fb4562c9bfbc88fa12baf62fe68d8082bb9b3bafc37c2b17757ddb9d58324b8cf01cbe210bb558b4ed5be43dca55f4f65cb7f0403c6de4da804cbf0d42c00522c0ea73daf9b2cec9bc2c8cd64c41f360ac0aa545931bab7e2b2a1ef9efe387e673c1529d63f6a8fc4133f7c705cf1b1f3939844fd53f2a6b0b6b7e546cf08664c89c7fd01692c8907b0dba2608a84333255ca5ea65eb10bb362228c682c2a52e2b8c59b78a964208f82d429731f5071eb70a7851313f9c00482ab1536e209833fdbf26abb460534294ce4e04d59d1eac3466f6d1e50ee8c0d50f373c3a02b17e75ed49a89cfa3e31f6f20e31861be62ce37016ff459828d8160917a66574105a3e066e9bccb3b953f205360071d9b62f34f4bdaa018e600a4f222268dfb612130776406694c9165d1c97997aa2680f8cdf1b44f8885709325022c4f7158c9a3ba60342973224ced931e1a631979113cace8f2b7a6686d66a4a161dd9827af3782629b286ae278fbb40f7266ab6adbf27fef0e47037c890e985f727b0b094688269271a91fff95350eb0c3616cc80e77767037bdafedf388b7d50014c56dfa0d4f84ab191064ebdc2e6a003bf5626712a3f1c205702cd4c205bcc65513bc1e9666a3552aaa263e4ca7cdfb686e362229ec79aae4ac74fa53f90967ec985ebfaccca7251a46a3c51b69562521943f143f522eb600cc6828cc983d12a3dbe143adda2f90ce09e37bcfcb17791a6c16298d50d8887659d6e2d65ff45c5b3d48965e4b5ce8e0a45296e020dd75d98b5769c7237e3e925c286caea2428ec1b6ecebe47e2a216ee69cc1e4514e9f844b8b312f9793330d55d1bf5faa3632ca9ca3e3340d27f83c7d3a5b8228d7d8fce610452b4047f8390748e6f997b9dee287eb3e48080c777633ed0bd9a32eb36174846ec363af296dd4fe1e972e4cb4b5ba050c9854150a6eaabaef208b7c704b32913dddbd1bf64cfa9196e7fd824ce3388a81d7488dff16758e034a488d3f5fb69577cf5087620aaeeaaa57d210d89f61d675f388665f92e30bd9a735a1f47896a39da29bf1bc61c80d66b3318b735c0b8b96f537d6906c749ab02abb8a22ca240dd60ff2b834f8a911b47e3b5dbe746f62d4441a99703bb77f6c3b0ca443ad9e625a0df2ffe610ba296e2f409209aa0b70d2ddc94485c14f907f7af09d4f500e54b4cab30d9c4844cef7eed596929277bee1c21661bf9ffd04f9a7c94ebdaaf8caa51e51f51b4cb3f2dd10bf5429d69fa3c75f4c2042c6671cef37c3ad7ed988ef97fe3f1a3ab119c93e24c7647e79603b4cf97be314a809f8ca801520790b578179d39fb7b472bf6c4772df02128bbef00f50205e740369207dd6a1edb5314dd77ec14c2f95976803447d63fa7c8cdb04a7de548c3e37ae93a388cf1b4ccf1d82d91a4e4d79ec005cf39ac48af11775966bc3cc5060257d6e919f9af1dd423ced2cc30862e4a90ce4264bd6f77449940156a907bbedaa86981dae6959ae872d2de2c8dd831d3f80c84830c57760131c5d489f0020c305feb76973e415822fd59e7fc3711b301d399ca77644dd1e2bbad6bfbb7f1683c381069ff41d89ff9f0dd0299d0cba844d9cbf52a85e8df5220c6e6aa810d8933315bf47a33408144bb1639e76abe53026b8daf23cf1314c3fdf885fa28dfbaec6bc1e09a057a6b60aaa28584dfde0186ebd60bc13fbc959ebe93ca2b4902352f752f08bf9d6515f00a348823621b8bd480dbce527acfcd07be8a81ecc2c39a935eadb5a5f10ae46ead2b44d526e61414095d095813629333ee384af345c23a4f2d73b468c07783e8ffa9fe32a5b47de7e78026963e93f4322b48e157b4e6ab643c375435c4f352c1dd60c23513adc635f11ca2c125a3fb6d4e0b67286418aaa96f3dd5384a8921725efb8fc4f4302e690fdec5e123d69965a05a42e7af4894c316e654edd80bd12390ae5e8d6b217e0b411a6b34a0e615cc6b5ced96573b9d66225935102bd9336e338935193ff3cccd77f5f055484d4c7c9912ec667d90a7a7312e5723807a7066863b5a3169720d9e77f8ada1cc7b1d7534ab28dd305e37ff41b58e9737d32b028d4a1929dd4a68a0484eabfa0a63dbc363eaadc14ccfc7730a082add559755c93dcff8fca07c3ac031e60f0a17937e83addac52be7f0887e6134714902f44eb6a3da226e0d97734f051d43e8c16e1e75c3f3aaed159c232a8703d91778ee69bdb64d5d08f7fd84a71d55837fab77d322f2a101303045f1c3ab74d8277a10a8638aaee59b96648811fe1b5acd8ace9c057687ec4f29c6c53c8f96213af2c55cd8381def9477d4752e90ab8f0ba9bcb528f937ae5196809107c24c1facd2d2a466204dfa866f6d0c84bc1d253a734ecc29aeb2924ac3e51e264232b8892bbf8f66ab47865d64dc4e15f3533a631a6cd9e753ac824e85c33490e7899327b8765b58be27b9bc9430ce3ea586308d2ad5370f678685f88b3de456917f868c0d37464f25730cbb8c056eb298411230845eb02214b1f3dd672c9b47dfc83ac7c251db37f555d02b19ac5a9eee73f305a8d816658a31f764db4cdfa28d1a6d92d6666c2f9798b54e714f970a73796ee8c75c1f87ddd24bde1ee39e9ef249cf86bc45ca119a3bd0641c796ae8e74e5df86cb1f773feab464573acd429af5351ec3aae88acceedf03d745fbcdf5c5d4d21669180710d852c58a7d720bf0c1c30c266cab1af6ae9a276d62d6d898672f903040da6b5124f4b420f2ab88264ca23d6cabb459321a916af6e4882df21eaf04ad475f9c11fd62fe3ce740e3dcf3b7c32881ddfb72b576f2ccfdb8bded8c359a41c01d2c25c5b3bf3060d4f12ae24d838753bcd4c18ca0fa9627346c541278bce8d595ee33888bfee1687f91bc931e3b765bf8cf0253038aa5239bfebd711497c1d83b2bd5591beae433f72544163e89f948c15bd7cb11f34d79b2ad474fffa6db6b483e38cbe72e0240ae32cbd3646c92bb5b132ad055c221f8e776fc4f7efcc4cf5abade2d030c6f2fd52619bfd4199f31ecd409fb7629c4a46d68af2275c91bdc10c7ea8faea4ed3fd8c4ad472e48d692dc3f851cfea7ce5888e24b10ad725ae1a426f5425b2facfff3be4839c9814dc36aef44f19a73aeab85d282978ed6dc58767f4907a92e72b8c4b90d329348bedaff58278e32a90294d67b8b0ab06cb386ed708dcfbc257197114fe897ea306a46e7c18d7f30bc9b840433f6cb8b9d50be0fd127c54e2b535c7fc19e7f5e67b88546ec19d2e7d8c57bcd8d8ab6c9ec5e22b86565bc65518daea10e97e592da053a122cd5b8aeddf35ccba0e66b7f831fdd136de834ca9995c5645be5b8f664f8c4c803e48c2932313d4997c6e56ba39460ae41bc725beb1737aa97a5ac3fba350d613baf35e67c7a4182dd84a087e7b61085f21b3bcd58dccacf8c8da87c8624812d9e0fa2474e003cfb673853d4bdcdab59e10a2c9a6d1d88c8a8264143c8604a41d779520f9822d5fdc4e2d4a9e87ce359d982a1c87fc631a356a0eabd30ae3af52ed1f1521bd76ed2dce2d9acefd76622e27cac6773114a3f12c30826a5d6cbe9ca59cd9f5c004579ce88601bf885ab58e1f63cd7b0406b37a435bc35d06863904990d53045bdbe7a742461a05110e8ce055d1426778c6b11f0e0f0776f0fb96dcc645a867d50bf6ce7581110759716bd64302805b1a330d49d267a92803e138ce40b36e792e5ffc0ea37b8f2a25403c7b060ca0d0823fe82b26331c86a9fd64b68fc6afbe7c41f0b8bd381f2bd2ab396ee8ac6499fc25ddde7ea17685d79e8b9f31e4cdd6b74f0afa4bbd8ac4462ef62353b682b3713c013ee53759d36099ac54fb50248bc7b8fecc3b9ef4d2ba0e7211772b716582c53dff4ae05973ded2ebb5aa6ba57dd8802ef02690eabac83aa707ac880ed27eb4e13dbeb3e4f2e5ac4164426dbdc18f14efd4c8dd77ccb9ef21f32894cee717fcb2cb35b95d12701ae2d79ceb9b0e0d9619a4050da473b779c6b278e21f184f21f70c47453a8c0fc24ae95c841e54116cb10263a0ef0b06d407d5f47239c8782eac8fd3112bb48058836ed0e28ecacab61f14246817b116dcfdf5f92ca22a0b0c1c839896309d784cf858b868a0b9c4271ba0490d2e40b32609a41e815a94e209e6a2c759bead6e386a7e5ed967e9cf5f2ad7cbf3023a9871cc6ab6e6f3db524b9dd97ab27ef20f6679b137aea2e681b621fd04f30b0c636a6ca9e6684e69b201ca11372f696a22a90ceb9f295bb4f46d3194d4cebb7f2797a52e291216d29a7d477769874c86f2ab17fdf45e4a5ddcf0afb715e955de4450c1f6f7f0081229d539a3ff3c86423798739c2aa3cf97fa3e4978452e6243d2da27d1017afbef53c6483e04ea5336221abc64aa9439219a12aabc1bffa0c06aff10df949f96da82fccef6ae6350adf4c7ee16ecd262f74b515a0fb1ecff6c7e33b14593105d2c3cc88ae1d110564eef021cdff02b570e8d56b42c097420d536582811af0f927e0ffe851cfc1908b90978840ef89b091776399952a0a5598214b2a33288363ff8b819359c4f92265808c78d0a5810e4637b0941fdd8b02515ef6d6c247e4b56370aad5b4a2d3879ea25c9e28acaf1e610c723b3f031032cf5307f0109888c82edcd4bbcd7b7a5da6d19ea84c02755a6031be1f9f494ddebdb84e2080a4c097b8152e408425cc3384887aae2585e72927c556641d371786e9d654314260e1dd06f3560383eac6a8975dace415f0efc9ecd26dfb95a071dcc9536705435e64d8b7172af5dfb6c4be296c19fc470c651d2ac70d1962ca68425f98066c0f2a9bc2cb2a814b6b4cfb037c371aca5ab8730d7e8911c921bdd57d1fd1e2167cb5437eafffe9481595597450eb71e6ee445a57d423533687b6626cc0cc70b3d1dfe1ca789d4c533bdeb4e6b5c709d19adc901f4170b0a287b332243971c36a52ad4296af398f4562bf3e379e9e228613e3c3cd909c21e29b258ee6b49623df7458816f1086ee0281c8d1cc3688a0d38e5a78339a46b1eec1ef9d2f3134398649362604eb1c7a4ccd1dbcec9441272fd11194d9b985835e38906bc32f804f2836c447211e8f7419e5dd2dd0fb96f862adb86a517c152523145b68c7e79b076dd574e3af0ba20751690f9b3091eca35ae9cfde5a7247c681fe12b227760bcf7da0901943c02edd8f81d484481cc37a7556cf7e0ca1fdac104e2557ef87a2d688ba5f231bdbb7c7bd957a23087cfcebbf51f58364e0505d12d0403309e96d0cc02e0c5c843b5ed23dc28fd053f1adfee342def97f8b72c58038224aed3ae26dbe181adbdca4071f33b44d2cc1ccaf7efb2ee10a6e3a3c16ee76ff1c386ad9bb60c9de8cee80c0297e793458624a6f7a291c7784f4a35f5b3fe162154f659d186384b7ce5925d972d8545f2a344116e3e9040b4079bd49728696f63ea5d9eb745ce4d5a52a67356d983a67186a212a092280165cfb42690296feb1021b69ffb342039092bf40b918de8d78dd4d76fa57d8865c9bc1109ee70a3204ab3b04fbd00837e6eb1e659f919c5da70f153a9f14048b498c4786f09b5d78de43f46200063eee85a12105077520365b8b6dceedfa3b30921d692c132c500c8daf782d7a28739f6e3c0aad2acf7bd3adbc28f6adb90df38cca4fe891584c5238587fada2198c31c0ff4c31cc2f024d48111355cbe263b90e9d88cb9ee7c8041b6d2ebd494f356ef19f2f880aed14023e7667581220108428e7cf365d8a05b18bc770512aefe671e4a6db5d07f5e632af5b2875ade48abdc6e5674ea9e8d52fc62770140fa00896ecd93166dd05c090bacc15b389e26f00366a4c7d7d2d99db44447840e77216924b25e52a7407802a3ac21cfc35b25707b79d2b35132d897d47df61bf0adf2a2c355b064849417d9494b2beb8d24965fb3b2b2543c4790b76807d61c9e76e9cea85329e176fdea0e48e060f0bec2ab77d1219000ae60b970c30f67bdd2157153b66b40dac50424751aaf572b61ca9122cb6cf4fbaa5fe947ef8ca72a1c885b3579774472d67049240ee981a201687dd2eac3eec36d40d497e0303034c026088d3929828480f022a819c39fc5be5b8667a7e9481b0599110249c5fc9d4d1e105542c2b551f073f929c40842d9388795f1ac8c1ce8dc9a62e4da9fadd2de34550273cbe8656c13a15237b5f60e56ef52a894efa90fd1cc1fe93c131f66b07b8917d9e3978f19105075070e15be807a5097e032e62e9951d7928579330ffc841a47e881eee760f52403dc78dcdb462ab961ec1159aa63925782d34f09c9305aa75cf5dd151d263c3919fd44631685c0bf8afbf9dc887d388199264035df59089f939d4d9db1d60648ab4b1192b1ced1f2fc2b5462bafbcda8d71d35d2624975323adbf936ff9d12835847e40c1065652190e9e27fb156d9c28a6ddc61f8c523c01665c5e8cd53ddfa9d9725a151178112ed8dedf777c022c2dbca42518d3638bd3057c9d55abbed41efa81d8a449b3c89b392e1cb6b24d4be25e425a0281232736821670224e8f74a7f8c5639c906d9280e18bd99034fc4b53f7ed6b0412b56b411702a2e3cb642f0e8019913286bf6034dcd90ca76518495a422e368c0cebe8f64037c8e1efbfa63086db29cadc7ada019c757e15c044e635e3c52ffc9f2d76ca10c00c0567cca22f3abb6e628fd7e493aee28b163a46b8ad93c4d631ef1a32895c50088c2cbc41b82ee6feb70fee1ac553602a0b530ad9f3b50ef93f5acdefad2154747db48a7d3eb4aab20d5d04e5513d059d4f8a6d8a9a2201e974fbdb1edad3cd32fabb31741d930743e7bb8f03cffe4fccedb3b904778e0bcd8dc84777b91a5b85acd1a53a3a10d1f2f91638ef387ae0f6d30e5408a73883de2e7aab8112f7129dc55be47667b1ae1f4ab0aef47f3fdc902985eec0db75f132b581774ecb290a1f47698d363fcb1fe3436b92eacba6ff3401e0d300c54370d59b97d7b6dc99730098786b59a07f1c975e6d966aecc60b8ec56e5224d6470487e72313907a9896c678614fd2bd5d389c25426df3ee8ef7a593d276c7b9e12d1131c72d77a07dadcdde5f82bbe6138b9cc3b1f316a26ab379b1bc1e87f6031ca1202838a378c9654c0f1eff1642f2fd4f814256b9d42d1b74d3b2fc4a1655d94d0a676198a4e3c96b497b4a7e83dcff1a6d75fe00bf598374e3c26ced00ddcc55b07697b500d544ee7f587f57401361270cfdd3e3eb7a4155c8dde9ca09722da0822cfb915bd93902f0579bb5e99813dcdafb21a0ba171949ca6d9c6221c77e272d900f67e88daa6cb4a673e6ebb83e1e9e8cdfe13fb5d04174fbbe789c47f464dd5ee51851ab8354c92a68520f6f8d2e858336d5f55710b41626f1ff0044889d47fc5378e0986d6548db1fe977d2e0dea3ee2082c8331ff0f1f83d930026ae93d2395aaa75f566d93688f42c7779c21a321dec97ae0bd0086e49670e3974fe8bec1d42b046106dd0e8a2bfaaa3205a0cde5575db81ccd603dc1bef87e3476e3fd9756cca1a07a2b5c581445faa797df9a3a25622f3f62c6151c6815f397d2651123a475f0efb2d0a23f5b7dc0c93c4a405fee755553183a461bd27284bf6cca9a76b75b4de3a7d957489ae56f5f217cdf3b8043d459d0383b66e4657ea6b468aa9ff1f275dcc0e73491e3032c0142acbf03273646c1005161682c9385f034e47a7c8e1d4001a754fdf8f28eeb6aed26ccc510315c62a92c3020e9c13415a673e7e6c2b8943fee2d9d9573fbf10dc8394c6a57ea7e55d8d73c8edbb2ad62437dac5642a9ed26b8abbf272835ffcfc70b95e0583204afb28582ccd378cd7a95c9d8c1bc834eef19b01af9280b9ff3ed23a357c0fe71bf1c7a9d17b7f612c554ff45d0fb2f9200e09ecd1a717a62b0aec6f2854085ca0629dfc0dda0353090fd1d193ec6c8e4cdc4975320a5f1fedd773c83d4e9254579f3e3f776f5c05c157812013d6220a485004c98d427e07a5535edafc2f4698733d81f15b198fe363d9e6863b88adc5da91d681c18732936677d2847b930d381db586d860628dfa2dca9084fa0eea9fd992614c3a6f567111578262a43e332c8bb5966cf6c779efaf840e41eaa4fdcfede7c75bc6e5d845dc35839c2e1c991926476f666a7550e5a4bc5e9bfdcaac4ca664607426f0d8dc113938633196338c9fa7e709768768211252a36fad7ce196c46dc445d80730892a4c5ff8a15a147124a13528956cbf1c99f0ca2454422260580d6648728e628de6ed56248652898580e6e4dd015c60372e42f3c351cfc6e277ba13951218082565eb29e55d1f74680006f075134c524369b8b33d9c7825b9b4debda144feea7fc9bfa8b197cb531353a05e1f370844a68966623784108ae06aa54bde7725452720b10ba2fbf25a38b292a50d8603e728a38a91800a4f286ba4efa63cd8dcbafcf03d53f556131e399e07381a0464934dee313d5d42a0c8b37a7d47346ce1bb290756178e0e4331a0c82999eb9d9ad1ecee2b664450cfdad1722f67a2fc3eb89a90f95207907420ee54e7947d3830ffdd5a5e89d8fe9c4cc853c1c29b5df4ac8a76189713b477f638dab67007e9b3c3d7976614c993ab2432e736849d51cd47b38d4368098d84ef56859a9ca65f7026580f64db2c1f0e5cf33a781c81f66847e48f412c936fa8e1baf30ce25e38313b4f6a924a376ec95fadc1f5f1e56eeb80294b33ba972a4a304046a2ff35cd57eba6f16d5dfee8a9a8a0339bbe93dead4adb9d65e27d285c66111a216a041802d7e173f22078c52733480c0f77bbc7b4d62e42d78c6d5948d1aa15214a4a0cb5e3c6919d05fbf11513f3a7e092bcd3d1e4ccbf27bb15c0ca87901a3aeb43080febe8c6b260a4f1fe18042d9e11c36a5273449fc4bbe6f2bd0c0e71cacbcc680df5fd832d7b7abe732242f609027a5ff063b76be1e4a639f367fde09c80f2cd048cf1e2fa6ea4390540ed53d507322b818a38c117f3717e5ee2a0659d1525d7e37d87a7f1bf85e600c65d1048fb5c3689b03279e5de99a3ce5928ce05975b2dbbb046f1f598df0f0e561c9a2778af18f305cda585a5e5497bc6bc0d90a1c9ed1afa7aee8956d1f6a0cc4f7497a2dddb071035c2e0ff9a308334e8e64175909bd699a080b20e46cbaef01d4d6475bdb25636e1970823372459d27920dd2be8834683196b6d2e13c45c59ca522869fed161d558f0ae41a591ecc028da475779ffb8843b7b321fe4d113c9c162ee43f455677dd755d2ae298200e5e629f7069d11fdd26272081ca8faccb707d30e6ce767664d765fd64aab13ee0aa4c68343351c6c31fc7349287568f6bff5d1f287d67ca613bd7f4e694ac836c152f4ca627b8ca98b3773cf91736617964261e8d695ba6b1e72b16a01fc6061b4174d26917a17b90adc5082a43c38533c10d39e8ea83a8c9d6dc38e2eebaa382380df750140ae2c3ba767f56df597b8bf3bad449786b6ad9ecf65b2a809509cd096bc60bfeba7a97d338b0f9b01ea73f46bf18a568722385dd719d067fa02b12cf07a3f0f8b6b58028e367104c3268f1a338276591e32ce3903c5e7860bff1740cfe0182f64a18a974785ab6f8cb991941678582afb1e0de8c07b8ec10f85e828bbad6af27ec26fd826c4a141f132acf7a789bd4c301e409de202be20bd5376b5e94903b1874d0c05de0d3e493245b21a62e43c6404766722f06f3aa24de68f7734ddc23239c02f4f95c37e718945faacfdeff42c93326e6ab5a658ce5080b467cfca5a4a86e400e8cb87bd0f894174d67e77ecf6b4c065d3d3a2846fc596fbed53289cc83644fd450862fcdc511c8efb58db387d0b0c8a870b8f1b2cd5d885c16fadc73b0b8f16a05afb004e1812f3bdfbf9e2436e625fec640e8cc924a3cd0423e5aee78829023b44efcb1754978ccb5650336a4154b9294a035b13d7e0520a47cc7da2e3a1ee05a765a5f2e328d43db3574a9e78d21b80deb273371b11cfcfa94b73996aff6c3143f1ac1d99b7fc9f29d2dda87e6aaab5142160759ad40ae58964c6849b34f5ad2be6fd66bb3d92016b6d5f45bc5bb33a0d8103d10585ec31a53da0c18fa93fdcd1bb691e65d276ed306530cb7d2eaef6ba887c8e8f26aaeb1cf2c670a097","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
