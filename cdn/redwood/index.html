<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"487d07fd5958fbc7a19ea4b5969d0ced864071185cec0ec3a6a4dc875466dc2801c3a26b434cb4baa52f3601505b21c14095dfd81a66bf17f279d3062737e46b8aa028b79e19105b4c671570fae5ad5a481d929bd8d072b1ead394d9379389d1cc8aaef7391455950a65777538db78c8f65edbdbbcc9f32ac0276af9a66176d0026594cacccf2169a913da76c8855809d13fed8b500c25b18ced33a25e96dd402a87c12c67bad9bd7b39706ff6810d1e3ac0062f434353da7641d7480467ed605eed6eab81fcbf572f1410a62a01137712d644ba85958876140955517a83a8c4af72f5348e947757e8698a2088eb2084b3b3b0adf2103a1d5fd80398adc4d69b29c0dcf6d56718ce3536a46c299324673a02d0ed7d9b3b29bd6decc93127c81674dd7c9b04c1703b98ac9935bd95ea6f5e29c4f93dbbc7d7c134c78d12d396e778c36f6c6244a1fc9c9078275cdce3c350f13be3a789bfc594c4ced39fa6f862241b2f43f9995d3f5dd387f26e65f8b329f4557e7a67a0fdcc1c45e910a228e34cec75e52a54296d4e9d3097e41fbc23e9caafc492a8feda29eeb7f7f48b84f7ee0b7ef8b395b808ec07bdc3c01f9121241377e9636b27ba3175bcd355a58e15a819dd0646f0f7863394828fe031a49d132bde5c0ac38a72482d487607dfdcc19a1d73abe2deeedaf6fe8c06ef886d866af624988249a22d1b54619da17c4549e71f8c4964ff31cbd01ebaa7533a07fb60e2956a3cd03fad344e7c84e02b32f9665606af3ad2b806388cc9187d0c83c1a1f2d7a1db73c3ea7dfbbe2476391b185269b9a3f15693f46709c79c6f4a0856743e57394e1e5c91ea02ee6f88a6a8570e055ea68cf57544777dd9ef0e7603ed1cce52d74c528cd40ff8b769f96eed3c0277af9765191fe52376afc5a4620337759b4196524535e7ed4bd341a15e67e5305dbad9d576ea8d7ac614a7ff7923c89b1b41ed20fd0bab8cdeac2660887bbd75ec5692d125c0f04c4f63be06485e8b4957e89e96232522e1c96946d7fcd7cddb830550e96c0facc02f129cd6a78087d8edd19d49c381f52408f43b3f0515a12b424238108df575314994a2ed2186bb2869be7eeb2c7cc96f1cee581ea5f01f31200cba1c46fe6a014981e962f9f4a115deedbe3b3b86c296908cbe96b7f6c38a3e0d375d181b8dc1f233c20105ec6540d7fe38e0e8ff794516992cf0208c7ea44485c85d43b76dce93efefaf1e09eb4079adeb3796210641afc8c6ee34914ada3cd921c87d95cfe1473d19af51548080a05f7644a9ae93062d3335e5faf73ed4c3c64bd7c2735e81fa8f22a2455c79952c7d0a79346c359a646b8519f10da3b882f5ac9f19608a73a64e482a52f6e4a14b31f9a00b26dd0377a35c46d773e77a4a95dc0c548a4fe0fd35a26f829ced3edbfd8a84e29eaf9aa94758bbceb0d4d9aba877952c85ba5628110a321310fa3151242a75f60145a6b65cdde5f9036912ac9e1fbad965f8c7e38c0ffd471d5f511d910aac0804ec28eb7d8d4e8ca37f310bf008f3e8fad9c4d017c74c23d30efd3f26c29fea9f36beae765108a33e3e8e8cec026743151574828d2f43bde0f9937c66867c7010fe2b099e505292dad92fb145cac3a1c05e0334abef39a857fd725d6416a3a999fba9e4530e871379855d6b2f24a141e9d29c49ff04dfcfd3acb551d5c1dee79f608c191190cb551d22bba4b352c049089fe41e1c8a2095876234856f45083792ddb200bf5d672dffad112f95d061db44a0db32ad2b9f89e30258d4cbf99f16b966f78b02b64ab92b4e817e99f6379cd6f8977aba711651bc680ffc12d4fc1f980bd269d7b874e8a190550442ac79324eff920dbc7b78dba4c2b909d1b30e5860040db75cfe86bec333cac15d54b3121afb75998da74c1545bff177dd0e01975bb2bf2234c0d08e28bdc6226022d0ad1f5a32047eed24bf4fbb3608cad730564392edfa0d68637f232bc1f82b5aaf580d5c2715932c377d04219297d08aa931e9137a68cbc9adecf822f36984e28634709543fd1ca65d971505cdc1c6ff835331f0a70a3fed033900ef735ece80492097eabd3616c8126b820b770efc79f0dbe77f0e55ff2b33c786290c462de432df6b41e6acfe57366f3890f68a1f714286c8518a006ff5a93d61d25808896c7e4b8173aaeacd3abc8bd8c24193a7c792d354ab947430665f16ab3368a03e83fb0357b72d6759b42089a5896beea86bd7ba0f52e2cd0290a6c2fd5de33c55e8f21ee12c7fae100f4c7bc69863ed2094003de59ac8c24aaefa669078f44b2bddaaaa99369e5521bfd13d07761beb7409ea345c5664d397d265680c41c0de14787d169511de7df8f3a9f6cf9393cb6f69a6f48bb3393573964009c524e99784d1e70c17af9e903cf3470ddcc43aec19df7ce198d29a4fedb6801556e2f18c66a3ea07044b0fc1d411b0f316f26e5cac77c238f4cc5e98f30381a0c3c6e6faaf8cdc12dfb6843a19eeffe7229a141b4c67dd56a136ef55be47764e7610f236a421dd13e13c28d5bc37c2a9546958bf7fa50a086512e6f5f91e63ca0b68dc0733bd4abfb09e0e0a28a11f950146a018cc3b5b7267b9539ad5e5a89d4d91d5926b9afad4e6a259c26c92c8b5215c62305ab468fe1afe67142602478c865e2f164058bc2886af1b84b63611c59bfb16de5f8beb9b3f7b4c863a71ce8b62b93d9840ee3f4ef3c17b49c4b85470e8e41c2b2570b92e7e8408952a8d80e40fda3b3665b6dadd7b7a00780bdebfd9d38bfb0d3255d2dc0ea231777f5ba76c98c8bb6c27d34914275456ef01cbe28c4536235c7b70b1205cdede75b6f9ac80a8eca99723b97319d0e6edf4fa4df747c131144fd659d068da6f5a92e3a760c94cae735fedaba7684f4ec9a640442f6be2db3ce445ee7c9b369e4f49e1d59148ce41b6867953780a9ba9957c0e8ca584b0191f991acd36803bb4ab85daebbe0a430ccab393ba03699f5a8d9f4d045851feef39ddaf5481e3fdec5b58971be0bb69c45c9a4e67a2e57b2084d6cebb6e5a19548b10464be35b960910a9022694778614d16215b7354972c893359ea0a77cdaa929cbbd54f630f64f366cb03092cb577c633d0230d2938ce5a2dd23314a844a00ae9f14c6d64fbae5417b8ec21fd6a9eebbcd807bba13a9d942bd31327db81943335e4e8234fe0ef588f2e4b4a3bb162012029572d260684b7131387ad2dbcc7a93240745ef2e72aee6597ab293ec35d291a0069c3d0d89b4cb6bbb51cd9162e26cf737e6eaf760f97b908beb50507629dd769dfaf8f58ac920ed9bd8416987fcfffe29ca25798cf829453981b7a2b5450567e5e7cef08e85e348c83850b0e3e90def963b2e51f01d1411c27f9a7463258b8b38e5f2f795a2e3a4381e2afb6b8db3a62161ff0b7037def192772f3bca2f766fad5684c9bbc1bab20adae6fe4c923d57bfb3d89c59875bebe2b120aff3b27a8e0bfae23a85f35d649c47d1280cbe9684ea8c1859199e6acf878850c0ff12bd04b23a4318b58245d2147f16766b3b0ff0961ce3de8c4f96866c6543119b274e838ffd84f69b537b2a0ea4a39842eb5321139e93f977f7791ee65431b3e240b363762e2e73dcb7d1a55d7b4235a360710060048df1b0fb974321fb890cd0175c777612e727cd2db4ed9949584971eec121de919890d39e5fdde310c980a815468d4c9524c2ed1e79ba20eae88aa48ba4120ee8385024d720373ba9298d0af4d935321eeedede5e9db5d646f2c3163c54b3065a20f6fe63dec7be4347c005709e533bc5b2140566472c67060decdf2fd60d9239d680be71b146f745beec7ea86c987e59e4dd6842f87c0593f18776e247f874f683808b0a9639fed9020941da6ed08c0d095991233fea30400b843ea02a3123a36b80fd5089726de165e601d25ba0ce935eca5ddc99c336c97176eb80c7cfdb3b5503b94627ef37c3c7d172f616aa272e9c0713e3088af62d01f0226d39e0e59ff3248d4665e9abc7c0625ce074e73f15dcc803e8d9f9966312f01339ded6842cb4dc92fc84da30fbc1f796509f5d35d3f692341eede5a557c3bab9745b72db59ef3a17fa9249854755b77e18b15f1f6c5ff9515c1424f66d4073b40a22a746fac11f76d6add137fd64fc593ab5763adff0f29bbbde104dad86c328f8b59e1b354651e51efbe19a442bddb2edce723028324328b67bba92f61f77162d51c1c3f579510bec2c11277d13137e443ba17b205fa7b33c9ff917214127fcb5043165b278073b765c3a35b669f715cbf46136348d4bbf32627a0d12d25b4dbfa32a5ae5914f0e5a6bb451fa100dc0f3473f8ab96604183e7d4978bc3a1c98d20b2be581a80ae690a0b33fa32972d664124351cd915e8854eb9a64aab769d26fa9919ae2d3dba867e20966e1ddf0757161d9905bda35b3c9500933bb9ef5907a339d48e5271915b09926bce822ee97985783daee45700e3195c7b2db2e9cbe961ce7b59460409b7103d481f494fad6f1c5663200bef349ed36dffa11b6381116f3e80cf9f7535133bc1fa238717f0f624c57ac5c47458efb9cb273570527b1ff29356e37d27e36dc0da1290e78b82027f1e2fba36e4b2adf8a24ffa536af1b85496bb31810277b439da83a5c7e65d48ddd88a7d1feb2f220220ea87e58abc43c813073e4324565c139b13e3764316a75553bb08d64c61fee38a0be1184f11c28522bf5cb7de0f14f0a8bd5f6a0e535f6c7b3b5320ac106255706373179a6aeb6e35f292037b167bfd6ed30ccc8dd60bd95cd0766e1701472f07b939d0a4c07d54d40b26ab6615e9b252daf97be1236b47b67d9266b9f8f7e0322691d0af426cd233ba6c01409a23bf2345e2f0e0acece1081e9a54b096c16848893b74d9974d447bd4efdeba9370b2b9d599e69eb8f78c288e5bb5a5fb19a73d4210a95fb187aedf7ba80ad47c24bc9f8da8ba04aedbe131ef7e10a583a263efaad7f351e845c33ed9071bb2eb18c38e2cdfde16d05406c5a0f2c0158868821a82fc43604398a8126f88687eaec1e6c62cd237cd8bc4b7d429863ae023c2272eadd43297c64cb07a29f5c9e1be3b68e7034f0266ade0f97606241052bae9ece47bdac431f0b7a5a3c7bebbd5352184256520206d1b9cc53241a207e8c8b59864fd3827d78a7e70ee260b8fd7f6359112c5afe6c32e67427de048efea4d13162c1d924ed7fb0c4666c3581e969c17d1c66901a6482deacd634068415aa87fda9ef9e8443ff780bfea8cd4e6b67cc26fa7e45281f8025e136c4fe8a106f8cffb3ea7c78f189fd68384b1f18f1d139715d2903649886a13f75867b5c2dd411797a31cc9fe460806cc003f7fc8d5001d686b9a10011fae16d3271012dc62f406d2a761808b5302815a9c906977ce7ce7485b7409f944f5230234bea8728a3804ef25246cb21c1d4972dd98b293daaa2b6e20f3757f71b369734ddecd48c2001378e1e483ab0891ccf0222a4d56008a987712101e26e4f44239ce0a737322a5d72c1206fcd1153edc1a7f726b3c9d008941c2d9be639384870ebae99611236cc08092a8c8b2506dcf506ef16a3377239fe984271f6a72679e86400849661bff9c8f5063ef0d95774f5d12f62f565b89db0bb7f53fb81afecc753f7c5185f4998782fd98ad851eda99a5fb89c67cf5ad40e88ddea3cace016fe6519962f9ec2bfbf68eb6d898a91ed6003fe678bd5700f161581c3f90bc6325916f1776e10fa456e48a497243fcc5f94850050f1f4a8b8ee5b03dba70877f5896be7e8ee1b9454eaf3e3750984d56b04c325fa4c1b827412b359a032f102b392b51d7927f39583a372211414531ea930de52b62540ed80f84d7d4ea8512dea736e7eeaabecb8ff40ec6e370a6f37ddf324218cfc8fc841b87fe72d57e18e25232be4837ed4b20f16354622c442cdb1097ca0cf198dd5f31c4bca70dd82ad6bcce55f30bbb86c3932ff87b0a055907f450b874c812762a481c943cf4475813abdebdfb993ec97decafd9f94645a9bd7391880ba99801b015daffe67a712f682d4521f50b01614b710314d7878bd2b1160df553361d54dd836f09010b8a0e7bc84eaa8931644246951302df5bbb2a0c9316f21986690192cf781f90e98f94f942e5a1aabcd1d0c2747006f0b8ffa6b57c79ea2f72a0ddb21d40fbfe251f9cfd4401a318b09a2745f4c00aad6e562fef65f99c5779fac9a6000e18483e099de02c3bcad4be07585c7864273f752a0b7dd265f75c4060a40502e18c2d4787f4b2e5ca60b251714729e3b074891d964c8a9026f0b58a45ce23d36b806b46868a23195a7613c7768cab4eb6c145bb7f21957f1e8c2a2cabe7ace6ef86164cd67496be12c0b0bd762bb4f761276e3f079d19b62f647e4731a3c5af512657b49532e017a5b93e578731328462499f3d79c932a74b8f00e094f61ad4de456e2abf28affa91de454a8df8ab227cd879572c3fef02c621e4bd603f36f6a952cdf0a7974ad62b612f4eb1bcdbd9366dc42582ad94bb153319d05ab700c8ea4355a9a7d3abdee7597d5c60cd36492417cbe553cf672d590effdedffd1dbd6fc95acffd266e49643190e8cc118a7d7f88f8c928472b4ac819dca89a2eb6816a0f229aafeb7310cc505508b564813f4bd965b745bc4286c2d6f96f7920d0c07f189c79c6e803f472411a61bc9a7cc63f4fe9c2939d71c8783fa28dc24756323631c0ec0a3dd4896c1d4257042ee50e3d37f51d03935bf6ab3739b7c200d972939dc0462ced560e7b59ad3a8c94ef3f603ea6c4bbbc362858d5fae513660a18d038caaa87fdd138e5d16b383223ddea9982834e4982472b6272aa605c7baa1b1e2a204e100de0a1511551b8294919dddb6e02cb9a26bc97e1e07aa0aae9d16514ede37bed5913491e7a35654552a23df14f672b297e1f9078bbcecf3ac34829cb95d7cc250f78adac70963bf6ba3d67ff1164c8d5a171baaa4df1de302cc23b719bf44cb507d9fe5526af90216ebe35aa9090e18e4979976022e9128cd673c138215ea5e5daa735023450192ed4270cca9a6dd61587ce6c97046264b2bf95653e23bf50dfcc033a12c615375e28463e5b19dc4714fa6f26d5e833b3081f6a7fc3ef531e97b1dbfd014f482cb797055bb37d59ff400fb24dbd6012216b46d101c8ef9d9e177584a506d4f50501a8f0cdad42ff0b0839c25a2083069f6d90143261d644be91a85cfc261c9b20222062877e8364e27cb6235b1f0652b9169c0530b53a5d4401944cf51b273b02937f8a6f065e007ac46a91d7977aaff5cb063bfa61c43030e1bb8ec7b294c6cdfb86ca9ef750c70b8e2bbe167f73becfa96a9e61efdc5eae5c489913f99043cb2f9d5f96ef3a457cd5ae87b936e1b8928620e6f745f13d12735132fd8925ab9f828f9ae88343815a32be8c05b1bdcb613c3e32e5ddae58e500bb5d44d6b3ac593191028d19b1e5a5b3b07af458f06cbfe8559501a5a04bb53639209143377007d7a293a514e23ca29bb4681d1111920c7fa56d0c9924fed4e5c93726ba8ffa48cf18cd911146b98ae64fe595faf323c1810d73643a092c37e6c82f3dedd55dfe6246504eafc1e200d1896c281374f1d813f04cf67417af2bdadc3399e7566c79d5cbf5c99e48e7abbb4d84248e790862f65a0e99d0072dadce73308a617636801ca4410e99fe5595a12fdd92d081e3536fbced5cad965bb22817f53b1a9b662c181e0cdd832b7f02e85b78d981f75372f142b9b9110a82f0c84ef47e56bd86d4fcc9c6061196db21d75a5f5b75d158e539c021f64ee25721af7c6530cae8ebb19b31a587df5b985f3931142128254c175e456efa88472dfbf37426a125c175cfcec8da1caae91c7dbd0831c360d5f42b4522e52b95c438fd6d0c30481aa8f2aa587b982a4a492178f417f96508e268e35872e023f6c4a25b67afba5bd3ffd8b246e66b5b8fbad1b1d90ac5bbf8f04dcff55731fd76e9f21f7423d4d5f39104ba694af1428866bd1e07a2bebf7ae40b3d113bef6ac1ac6913926704226ff88cbe73778f4d5ea6832cd39d268326b58a2fd14991c4a2cb30ff6a0824dd12246a9db46a386f71a3546bb9941e1440a025d7ba2563e4da8db17b8e57d244b155bd6dc00884f091a779b3289fc87b86a1d93c412a10b2c85b269a2a6b85ed672ddf06876c721dc18974ca503e924a21e78dfd64313b2d000ad4295e98b1b6afcf1aa01a9129aa66ef6e464874121b9a9f2e310586e835d727e671b30987a4322448c9b889de11db25f6849caa240b63ffea013fbe2b16d350d58e553761e03dc8d08a967b2ea4d04eb1474a2ecd70d76e76022304a88bdfc88dff2595bce0a619dd061c78f7e1a0fa8c6db88ba9b4ebd7eedfcc76464d05d5e3514e68603ca87fca6d994cf7fae40b9282a2432a1c3b3f6755aa873cb2a08a5c96fe3046aca6a8572fd205a7564ff0c179f2f28a83bcc9c9a724a558d2be2b0c77ee0d40dae46f8f7c4ce6129ace2b0d7fe372d8b8a429e8c98ec2acc67fb066d8ae069ba7c42cd547dfcf2ef8e72b48bf42b5fbd6070344584846ce0cd8f983611d98423e3eb71a33ec220845c60d1c89c13f75696d20f6be61afeefaeca5e1f6ad3158b94bd58ef03c35517cac61cfd7decba9c23f84165b7c9949e491341aaeca13ba87344b252742e6fe3d0dd66e705cb98f277349270696df5c60456f7a1d66f04cac2c77946ef709e5794cb4557d0bc557f62ba8381b722c82ed343727daedb4cda7d3ad48d4a1aaebf3c1ad2d5e11c4d0c2c910e775a0d455740da663908f7f686142383aea9ce1a4beb7791eb71f67c29c96143ca973349bd9794cf2ccefab8ce6f2160b17a6739b1f6f28b193674cd1d0c08b0ebda729cd8fca958b9291e2b16ec02dccaaef146e482ee4281e1130ae0dd891d12f7ecf825a4222b29d1d519b87e77fbc35030f213918644102f0b81a33af6f8c679224b9519867c9a8663e81d7f670140b90ed64ea21fb716f6704f1dc9e45ff6693d6b928d682409fb5efb52a84a8cbe93e0741ca455285a494ba154ac72281f097f71d93e18747483f7d7855c42b10263ece283cf6410448c5a8a98e1032ffbddfc57b4ac352a7f3cd1d7093c5b561355245dbe9cd542cee6947dc04939b2db42fc89edd2ff12241a1dd48e46b5cf27dd87dfe89bc8606f2a51d3980220f631fe641a657377447634ad81844e51b36dd520293a1a97505e214137d042192766e6622213d8db3a0417bba41f75107f1a317a5b6e374e91e0274c15996bc3de4373407b7b6f293cbe4ec64d6119027006ff9eaded8d8d65c62019d586ec78ac552b7a06703e29bb9aa5e7732bf4219f4776310eaab9a15e6d28084351671e7ee2491ac43e9299190f9bd4e2f207ac2cd124de8a0baafa10efff5eb50b1fa2deb884ad1e8f022861ecfa17a0e48272ed14c57c6d20e94306b09e4da5184ea19f115b5490ae11fba69506247153044602ca187372fa9b37c66415a585454b468a7c6777a3983781993f05fb3e42b431ad204f1066ae5f87ce4cacf1eb4362daf768b8fa7054d77de4f4f6ee4df96c999b1f39f17fc4bf3db62f9f5d4ba8a687d128ca1ea2e0dad81bca49d6faff604f571273d80c106aba1d768f7f3689a63ecebd66db4f0e489c5c3e8006864795da072b5dd9d4b84042b9c73b05c22be47c5e10567b2df22be1295e6c3a0b288c5680dad14e226828249735736dcf2daec958bc32e8665506432a0fbd0cf5e13d24e891dc7c5231fe67fa0ee95fa0ed19f92c756c7ccc56dc03ec23510b3bc0acc6607e1d8f62f397bfa37a652522ca3a519d5b5b5cc911943f2031d045188635ddbd70941817c6a692f190896954af95352d6c3112b1c7ee550d7434992ba0b066aa19f76230b9cdc91a7cfbe47952decd4aec1c6132b46a4cc0178b4e2451e89a20a1fdb41036db65d72b0cdc0e7f42b3a69f2deaffdd0c64f3f08bbae23d266d18d332296929343931d778e8ed2fb7e6774bc109d3d103e6ff432e71e033ea218385d45a856dd7d7773c04d9ffdd2212d79c57549bf210a7461e27324b8e3b2730c656e19b7dc4ba4a3dcfaf1636b7b29fc194ed67bfcb919321028f75dad17ad0114db625eb7c8ac9366f800cd14bfcee1424adc41160f11dbb34b1638b4309600f2e9c84e3e916b7609c8e9210a02100fe6de516bca42ce3083a30a2f4704cccafef2f86baebc4262dce2f8b4e4900c42a38d09b2c84f23566ac8916bed9ae6e11fcd1f80012711a1c1bc800530db38b000e562ffa4bf82e876112c489defda8797c3ac0644189e6f27df1bfbbbea03105d905eb6ff8a76f5d4af63de37edcb8707292de26ff4cd8f85705680c6503e1bc477ad8a67c0813ff5c948d7a97732b82972e169f3237096174c2b8ec3748f4a890cd0030b509e1fe8baa43b0ad5a00bbdb3e7fd6e19a8a12b2ac31539adf431a01afbf90cda5a933988cb863074d0671ec87cd22d19f6958dfd83e1b3ccf736ee89e23914c5de82cbef9dc65ccd115c7dc98365fa25f10492eb0ea64f66ddee9c216d141f7a1ff391920ab29f9241870a867fe0a89ce6afb17de13b48d30a23f3cb4774442b00daf9b9795e5fd7414c4cccfdd835958fa767a7caf8e8b0636a7c8411169b369bd0a8a4af72df379faf7d8bcd5645602379422a15de82363768808f1dc026b20e6b509feaa8bc9b3235a60bce0159ffc62684303cee86489031c46fd97d568e539bcded6dade5d5914e3ce2261c8edce2824e417f6397573eb807035d4653db91e244956b80d6d35e24c3b2e3d587007f9305b708986c047e7c4e8161362e4ab73a1f3b76680312388a721561d835d8dba17059a9a80d44eee9720515dc40a898b425195fc99c8396f7b3d0d6915db62247050afb17458108ece6789ada5200714a02e52bfb4e451ad9879707a17645ccd7fe6f599236e766249a1b01cd96485d49af8c9b5e06ff3a3e302c53a264032be7afa41e55d50d0f5bfc085b1c7f0c7fe18c647d4d2f4c199653688eab30e06e1309e4f763481f8a950643d0e3a259a9b3d0529d0e9cbfbf92f767200337cbbebadcb849851d4ed67d7f725b63c613e676432ed6da53723c51792a3b4d3e2b7306358d2f219191bbc439879389f3ded876e479f9ae14bd3f7a789b321420e439744879824c5fab354e31d22c7353bb78bb457cfc3fa01500afe6937f7768756b03243e998d51d545271021aeaead115b420931eb377985343aba22520d359e1d11c4db0d6f6fbcb88b591314130b89fa471fc25b1f6d4ed190f7ea7c3568fa045afa913076eca6b527aeeaf37911ac60d171cc798e33f41c2a0d4f8289ca10197228a6b8406badc6b7f7c02ff7c7f7a17f027e8d1b957880efd8e549b67360d124e3889d00bbd654e9521eb1b98a62b32c99551881b98643d129348ce23ac75b1ec39ef4bda64fb4156e26be58b78a3093d03e2e2678bcfbac318350705725423aad7512fd3009d6ff9dd94c63e42f5c3b0fa7e9c38c63c8fac83669475de95eab26f0fada52d0f9ece84b67152af2ec9a80157964761e76d7421017aa3b01b7ddeeda36601286091817e41f211b51df245f767267582a40e2111392b62f91ec3e9000bcbf95d818cfae605b52afb5ebd2a28a978b1c3fec2900154aba8bcee59b07baf99117cefa58ec244b0a1410bde3e6cb12c6792215119b15a1d78dad26fb5648f46c2799c168b14d16c176115bcc9c8995f77dcf56bb361068a2af77c988f0b6d45c95c116171bf94a0b16991fb3be378aff43b534ee2f2714d37f5854256de36f142626ee5cf9b5edb6719bf34e845961df4a467bd08b1c294c5adc58d0eeeb996d3ea92dc0b06ffcdd8d7c7823ec3d2ee4fbaf84dee97a808f85dd45521007d957c71737539cc452abe7a010a03c83c726b05a3f47bca41d64d9bb69f919aee8e924e3ed5450ecfc75b6176555e2d4dbb7f7ff7de040b655eac8e7d51d4fa5cbd68f660383e099a0af71c9f836c6a8742d9aa7baa316375e956ff306c99961a840e9597fbb02e16d7661d406044ed0714ab1eb82babb427a6a49e3723c58e108f4e19b56dde3a7f98ccf61c8e3709f631d94fd0ab6735f89051a90f9e875c42ea9643c9285da17d9231d3c5dcad4a1c948768971db6e2ef7ea34e2ac00dddea78588f57aad98a632e63bc9998c5a461116c6d54194a6cb26b0f39ab2759da681573b60438b5c1bb50cda507d724499dd1aef4c885fc8f2cf4f5130847b87676e54ec681d6a188a67ed774af98c5af208c7fcd2a8e982f5d63b4aee65bbb959d3f9c8510383ff978e11cc6b2f1764ed643fe834562efe6fdae1105c35f9ae2787327c48df48afd9e1bf8b871f0cb6aed9a4713b7001249332e63c976c3f83e9d15cfbef16229753df6007044607b2cfbec10b28dba70919dfa910befcd48b0821275913275d1b1fda24b1d4bed179bda0baf283c49a4f7e13827416573590b1c23cac9bde0404e3c90ba6de15a0ca385946f8a00409499a8d6a2f2d7be15102b73e93483c0dcbf553c71f4fb9c5a1067a7f633710261fdd97606d370735902bb72c04aa32dd3409d8b7ba825d5af63a7ed2920dec1ccbf63762665f5740b6b6248e88be3dd1776c247011c4ef200a9ed15d04811e70282988fef89f45086ebb06b27b456b3f04bb30d88961bcab42bb63cfa147ef7f744c38bc0a23c3dbbdef61d69b2747e561827aa613e36d3283bfcb8c5908d49de0223bf13c8a2895ae4267c7e98c8eefabbb3d0a62247a7778a98576738ec583a3a7c1cb435451d94706fcac586cff7fff03d53ca26c9d4ad0a82b0a5755377b993af268455e327f3486efa65b015150b7cbdf17d9139278b1cd225b367268cfd49c7f0892ed14f69625af58c2b466c97db04d23e5442ac0d4db14381f7b6ab333ec95f7b951fe19799827e6e6e63e3635ba490829dccc8bb4d29ac24b018330ed869b8e9193819cad0f195656f12f059229abab89e0a3ac36d268e5dfb3ed151dc15f27a1b6b7387820d8b598aa693d75c5b2eec3b607a1916ffc09ed0a078f6dfe2f43015c917205ec7a64f42af4c822aea7d37678b0958e2330bac5c57a4a695240c9dd5e757fad25a89d0217d790c506b8a1aa6fd4865407cd867af87037711a77e2e6840a6d94a5ed156f87291d42d97b3b71c78ebca1c5c617b300bc8a9f797578f6249cbf06b82c005a98a7f3fb00c5e09d3e85094fbf696d52191b77ebd7bc1aca44144c4387232900cace87e384a30897507d9d6e0ca37e0f2b7dba76180f15bdea84ce6fdd119adfb0c7da3d36dd225c0b648e7b6451f4615492fecf5a0fc40f2670127dc43b14845a9ddbc363925d3cd39232600ba082e25c8695fcbc9470e4b6e13d7b656600689fead4ed843b3dfdef56b267320496a7bb7c7d692b4537289ca71a5635ec24018eb52d3df29b4d847be6400dc59a715e5857160a4b287a89dc919c12d1f03f226c4975eb9edae497e2e4c9f1de063e1ff39aed36e38058107c4b1f273742e81b770a487ee5f3cfccb8ca731b75ba81c1e4399dd4844909381647c2300cc2a0e590e361366d4b01baf4d72f3d144c0bf0d2fe5f21bc8b5027d119e9b0c546f6419c52acca3b7999b28368ec486db0ce3b8aa58c0118e662c6c52c6b2a2b63db06de87ae5157b4dd1edc2694deff6df90547d6ad0cd84ea8f31c077e627ca727137c907910150068f1920780887fb1ac9753c2e6a9f48baa9ae6f29318166f1d66680066b0aeee868133ac485fb5628afa20e82c23474b590dd9578b7499782d5ac00903e166d8e31c15fcbadc890b23908016273da9f3383f757a186211bd9d0780729c8acc7c3cdc79dbccca47fc9e95bf9bfda8e674cbde41d4a872972dfbe9d1c35724a8242b19fa2a307ac1caab498951a940a99e6ae98058d6874d327eae3905e38c64d6a93ee590645131566fac5e0fb25aa6e51d1279e34d4c3b116ef2bb7816cd9b894e6c109772e4924d993e7d0f004d76167c574629f3df45cd4d80104e5a3edbc7fb4ad9780f00f5be35bc68ec1e18e7ee33cd9efacfa863cfe0fd239a35124a466f28372040a66f8915cba9d35bc963aef3b4aa6a111ac7ef37205b18cd5f16352518656acb8c2c060116ec2fba1c06c29f8db38d699c6e73eae13e4d1a134977355dceeda833612189ec589ce07e0085b1b8c8262d175d4a3317a88becb5de9b08d27e131de853992701f69a5ddafeff695cee31db2edd2c679192fcb6fd38babfea3e8bc9573958efa03d8c5c80b676e3bb23e2effef5d33e32f7b8dd71dffa42512b7972397f31f121599c04aebe09715dd15d3a2d54f6d007523dac79e596c0e1cfa86683a4dbf5de7453cdedff15b13afae0fd54d0a004d4f1b7e5793d4f767fc6d06cabddd6f5fdefc87268dbf779a7c320942afc35663d73c24e6bbff2617cdf2a409a4c0e1b43388c9e4fe758d20445dd5a27c0bd879497c9214504c09cd69234d7accb6a2979c337a18a097944f85e37354720405c7527342254d2311a5ad69ecece9894e5118d9db32fe505277baeffd09e96020edbffc1097d3561b4c3363f9aababc499db5b4b8e70bcb2d05e45506402d974282fb4bdc14827cd4df9135d714eb960d73d0ee1f3c353b93f790202a432a363268569261ef54f8f6d8ce632178134124a67164095cca8b528b19b72e1ace9a921d49ad880f51ad106ae19939974955ca5352341b65ee943252c5903c80de450c27ad4c043095c47ab8677bbedb7007c119894972c9ad1d67a178c7f06d7d8eb7740226b458980f41f57c9a5de1399d327ab3831ef6f1b0623123879c5014eb72a396f1c4ba4a148ec9b8847879413b6380d4dff2af5ea13bca4e14f5a8e7d7be628fed56a37d466ae5113a9d632a290a5de797f4bd6bffcbe2981873ee629413429ce8afa0f64717165644b47e8256dd96060d3a203e72ba59427d2c5b1af121c51a7f66abbc4f7694db00f49401ea38f4c1fde4806d7256a3f42cacb1c9af1bb9d83ad3dde55f5fb2055812cb907d818407f30da666ee339197418298950f0aa7b1cd530850aaca430b1d0d9d4aca492104","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
