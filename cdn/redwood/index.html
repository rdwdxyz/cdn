<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d97b1bd2b30f2d268412940b78c43ce3e66a629fc4f580f25c68a4bc409e0aa0a3ebd62c65bec0c94bfd2fe386f70488d2f4c2c40dcb73969f1dfe6bbbd995d4a48ad6e2e7be937596631f3363e43cdccf8db8768b7ec801f10381e97f95f3acd7a617483eaa0adda873e5f2b63013f8ee534a6733ddd6407bb6e76dd1bb484b0b9535c321f805cec9f3fb16d814a7f1b26d245e7bccb84e85fb295e32b63cd6defac5d8850fa2237dff13642e4208cae2b35053ffd9a9cd56d95f96d29eaa4ac49a06523a7d5a8c45012d318abb977e92251f75c3bf0c6dacd7549744aefb0a2c94b9bacd97d4e3d562c4c98bed58d655adcd04fb16e13c267dd29761e76b81bef34b13d8afb7caac17a4713cdb976aa807b2e64ccbbd2a577cc0d7a6e3edaa4b74aa48c21364b6c7b0a22d52e5280196b73fa178acbec9bc781a89c4f21dd99e35ba2366ed37219239597a78aa6deb82e1ed2f8296deeb5322dcd552e9cf2557672f7ca0aca5ae74026425a7d4ab847648c23a0f8d1b4f7db065ae232410b3d2e4442fe088996de9fc948e7bcbbd11411bbf18b7065c9c4bd0138544f0b41d86fa7c3d2a378694b2818795c01effeceeb3361229cb5ed0b2fc2bda948368c502cd10aee7631884fb8503e513997dae4c0997dba332a5ed43e8d72c7439c7506ead680b69450d3b96e621de47d486b62006fd90a983985e33c55a0aa580cad82e30030c827fb784d89e91b086bcb444ae767b5283ca759178b059bb7136f420d6add7c6db5865e4f9c22df04eb5cf127ee23b13d8fa9e744f8863f6da6e958474e521d6e0e7368b5689fdcf3b04a4ab23e238a1dbd4d2dd69005e8eb4ce4c3d2710675a689abadf3aab110a3992b7acb83696f39b7718a844bd34c649ff2314d0084d7303a13728e23d59005f540115f470b6cddaa212af90832675a511529ed41c6204d2a95c5071826c4eabb35efd0c2d3a3c6590290cc588a751bc801d0c19d1f7aa000a24eb27020e862db8bb94910bd41f9acd0578b938731a44858a82f58042b4df703ddeda9ead953dd4db72fa721bfdd94e36d8cd9efeea5613663e6a8234174b65dc494515e3b6d9d39ef841332f58a877b3006e3b2290603c8d562bd37b5f747944b9909ebf431138ef258ccf356ed861280c0e9c8ae13dd242e93dfa121f10b07c18ba03428bfe3d49db3cf20686d6ce618f77415280e4c3af3ca4adcfa1eb4fa6a9a48946396a071a7527b42c8e53f9b6c9fc19b1c09bda918aaf7f2d182c344286fa043d0511ff5b81e39b0d8a69922c5a378b9a983d7841710d1e4f4598f68d3ef779f747dfc7e5477ffe66492015efe36164bc8a8bff8113dffd80ed1072c9e2b9aa6e815563a44da38d353c9ec5bd6e27ff3299a445aa4a16673ce6390f5be5a2e2768d2a0ddb76009d1c7e53e89ce6af62d90414b38c9f1f958068edf7b32c346bf6a25c8a7c6b5bef913d9b4aeb56c8a977789232f3b732b9b6a4b8dd72aa7a20710852e00a1b26a6f29131db217bca40fae3fcbc0b1ef27f08a7fd371c4b63670faeecf0e35e75d8ffb61760426e2e0a36a7234f8bac2962b01792522b6b817cb48043b2c224c1aa39fb67c71fa92b57a979eb3d46e94f0f1386ea8ab2f41b518eb77712c60e9db9d8954d4c56f0b4f0a5d5962becd3daa910c4073f232484f925ff9ce068e0e0a958a70493945b491df4246fd1e5108ed7817cdf554c6b102f86c1b10198b6dbc7e357bc21347e49cb51bd15fa4343ee6e3f18a80591310b6e6f2b0a5c8ea016c3752f6c6a95556bec919327ea6a5ee9492143bf09a1a27c1ea7bbb1edc654f9494696a5bc9f94d57170f6d6ced6451dac262d458bb5742f2b212f8fd9abc9ae25c7787c2dcd43d20e221baa32b795d77ca9d5599f20e1cfa27ee9edc7b120236bdba462b8a3a0dbc70cfbb7121e9877f901561db236f05fed7da592e7b45af0ff0366902abafa9f5defbaeee25e3b87ae088ff04d86dd55f1ca23dcb4f1e340034412f1c1f20d1e24019e6f24b22680d2ec5cf98f6f92e528e2abf3e47f9dcfe0719e089f2801ce8d2fdab33a48cb8bbbe77c2b9406f7bc1016f59be2be8bf8ffb32fe8b99fe126de1ddb47dbe6034169e32102ae4d4a77344fd9c8f70cb05604f8e7852b3454e0efd87bf7a573729160d05855cb65ce159f2030727182f6bc3b4829d4aafbb4e188d26bcd855a66277517adb08068609ee5548d9de25dd45f66ccf3088a7fe3eade0c0c33cb7ca2e122e5375dde3525683826e1dbf9110f31d9879357f44458ad000fe7c9d3c6c94129c8a23f00a990195af88c3907bbe6e870ac30e6ef0b089180ef00ba537b2e30e8a3184c0a423591f2dfd89e2216f07d3e39311f2fab6095137eeb4eb87372f411dbe62dca073efff3c342080ca717fd26683589287cb79628b0dc584dc3dfda47a254115e744fd3cd3f73041cb986627185f9dc8da77a2e06dede1f5ecfe65c83df91835b75f53fdb012103bf48e7524b74df96795734a2765733805fb9e5d8ee7db3b77d8b50d06c2ce328bce601724a169811de07e0079a2a5ce93d2cbb0a6d3c579788f8d32ff2669567a85e5ce5a8b5cf810dcac43705651b2b7bba2bebe9576a48c5774047e24b3f409976356b5865bf9324e82489ac944d392dd245e837b9ba81a91169ea51a0c9d4a552fab86579cc325d32a4c04f3e071a71698d25089a2ff2de4cec04c2e1588d5bb897c44209cff97463f3a56e523856e146337a3215273f5a71034871838e30802353c7a7482d157f1cd1fb55bf4af8b3e4347ededd18ea824d3ecfcd1ce54f322df102360197e3bfe1256fab0c79e50b017aebc839e1b96dd03632ba70e2b3d31425263908e79ba87852cdc97ffa6d721730a79b17d6ea1c21d4cbee3e309f1f550368da29f92894bce86b96ae78f870b4e39d35a57b896ffde4c4281a709d6ed171bc19794702ac8e23234e615d439263e59a960609106da31c35438bfe36dad088687c3740850fef8d5c6a1ce01a3d4911d3cab7e5c2c064a5eeccab336d935d072aede3bf1fecf620cc3373d76dff8c2cf8740c8880c2087dffd70da1b3441d1e9a1938037cda0b3339befc309273419a1f3e53fdd470b80e67c81ccb63241fca15fa3095a196433c34e6c143d860714a98aa35f463b99e6ab3dd3780dc5ac11d4ae6e3327d821b8e22aca3d2346d8f0c8bc3d1c13fa92bd9f2114720896959bff353ac065654168fa2c9a2db8f06bfafaf7155a661db811949ec010c6cda23a904f573ae2050cccdd03bc29dd0f893de0ae00a4d5fe21ba830dc00dc2e69725a1bbda9936ee172336a63b0a9acad172956ee79d69e3751ade6a1efce009077dd6373e3b13be1ccc01c4f6ddf8fdda17d13f53c4aaf3c748df5497623ddd1c98a967209bb921b3ce90960f60489854391f78a8f8b2d3255847181d4dd11fa6af153c98c130dec1d46e7665e279622b39dfde212f39993b9987e9cd259416c489f8b982dbc9217fb7b06ff500cbcb5eafc32b2f0563fccc45d5748ebd344c96e940e8787875f62414b512e458b17df28e405263406c8411dc3f9238e5d99c6a122d1411fad23cfce2e35ee1ffbc587560fcb4ec477686499133e1c2e53867ffbfc69a66bb9cf452d8c10901034332770245b15b3aad40862fcaffdfb11b29d4d50504812977ab87fa2111272a8cf88bf533e404b25c38171c4139296d6ed29c2caa91731b178d64611739954da664e3a46650592a67f7313db46b74fb995dbe743e65f2521e73e78b0a22252430f9aaad9ad48fa5a1012c5557f432dae0daf8752bd8b1e8490c2acd73935e07f40d93a5560f66572d8f394652fe661d1d8fb9a9b2f2ca12989d7916056add0750737365274d44b79254e15ba4442bbc3a881429edcde0e41e3d399667b6fff22f1fd0ebcf887883039954fa38fd868111d888c0f74cb32baa3698088bdd54bd31a366c1d906229a43e3e2ed7504657b646900c5244dd6a597a904f77acd72ef33bc7ff0aed1e88da9489c1402527d2f432a361c90d89292c4642f570e5de748bc120e1bac91d0ff055bb8a56dab372f7c8291687629090df6851cb8e9a0c0b0786a598d91cb1eb6fdc15a07558cae3f5acca06eb953c52cf5ea72202cf2dc97e627a50a46be63b9255d3bad12984b39ee02f9f3880b222236d3a7769546700696c65402e62b203b8d9dd79148bc1c3b48efc7bf531f985768c2bbfb1d0e3b922d5eb2807116dbdbfaab65f8fbd2ec74fbf960cb0d39bda82333274d0b08779415dcc3dbde7e45a7e37b104fc99d0d38b87119d758dcea4a0f78edf6607a169f332678cbad945fbce93a7a40afeac80686e4e49da0ed3f4f05b07c5faa50a23d17fb8178db8b1ddc72bc7e462783023e666444af1008b2df957a6eaea9c855ea8b2266c1bfc68f2d063b5df9e436cd41920e1522a5d32a29f454b4642417efae6f18281645cc5be1bdfa03535fbc496bf86b17aa97ef2f846591e5324cbc8c1a1d8a99b8ee7604c662ddd6949a150681df12f3d1e1713e6f552a8664151fd19bd5f6f5ef08a225b6ec620286b13b8ee2fd303eb109dd1c54cbf80954be2fceb0051f0dad514e23f30a99f95ebae3f0cda3a0b8268b32bbbe966a96f201de23ebd2f1907ab8f610ff04646585df44a5da96490929e491806eebe1d480fcd98782c418830072cc57d2610fa046e6e896cb2ef8d1932b778f185a99acb198418ff61c5890876fa6dd2d128b4a42fe76c0b828f58a5abd287a132839ec4d72dc7b932e733ca5fa207a49f0cf4db90a79c3ac63f12d13396b7389a2c42bd5e584a24c04e5d5ab0e33a7693af43908c23e73e121ac3c4d02294dc36bd99e4ac439680b4b9fc1173f1d62167a6910d0a5d9616f6af656877a9c8a296bc176987905f82966de3d8480e1c7fd8f998d68d6a450b73204b66216b965362822c9e3e0dc681b3ed2a9fe4e4c40d072ee0257a50ade200f1b5e5a504e3688aa83d2484e097c79122b154f96117e0b343f12370fcfb2781675b8ca64f790e4351bac0b8e1169d93cec888a103eb42884d9f0021610042af8a6b53433781ed433d179dd9c32656e085502c89c3acd1e5b844222d9f3653f62930f55aab7e720ca1dccece08fbbacc95b14f78ac952c91992a8e7579f542da5e88d1f6bf0a6af7ff99b3287d706fb3f41af4baae1552af0a27e86687257dfa7d82a25780ce4fbf02875d2a406707831017698b0a645862aff115b34bbaabeec1fc1dee87f967882603c320ba5a6c8532e28776a18222a7cb281d9c8476a51557eaab9f66e9046324e5768600eded2b5b48de2b3492a3f5c4885d676cd18a4894d69d1d422bb8b355dad6b57639443854695ed5074e6a28a9d33700ab99d10ca5373f0e96fd6c2da7a956e3e2d04e23a9b0cccc2ae6c4f09cb99858ec2e2427990f3011648de116a00a9729c2ff3e9da0bf806b1f87c984f630c8ae3d8b6b3d05ebd5e06a06b8cce445d330447f14f7d17706f066d2d2085e334d8f61921da7f7d2af0d28528b001767a337e1abada631bbd9efb3e385d1b4566d7f950440e4190edd5d2afcc0dfa4a824aba34640217684c2984780d8ea8009c7a2ee2980f847332043b1480b99109001ae2cbad5ab1c909386bcf309bdc20eecafbfc2991f8c877564bd2070556fa0744696dd1f28f13bfbf0b98a3c272e0a41e7ec56373f42c159887f49ffe7538c0912fdf4b0c00354a16a6958d5673afec2fb0b1f90ed5978bdf3016a9e7160567daf3885c2b6da43b980bd6ee330af8302dbc4e909f9df7b271c40ccf894266df2ab9aa5c4e8f5dde66e4a438322e0d20973235d5810465358a2cac8f33547d16efa3d813909081c237bac20acb88ae399827e458e4ca2fe3360b4c74ec0aa9b5e52f6c64718cabe7b02f1134d40885ad0de0e25c2438e5dbce1a95821f9a9faece7842cb47bf782817fc128e547fc9c178a1d18108557ee1b30fd5c35018d4f642a8b92f45f22703407205d297ff0c99a80885fd6903295715ae8f5b88eedc93ae37c27b3328e626b63368fd710e0560ec09813e9ed41dfea23dc71c9612a5ca89d2a1dd6a7cb5935ab8d7c6ffc52871c160093d371a276ded4774935b38df0664ffcf10719b18c8763ef982343a12bda40d92cf08192db9833e8e0c37bec64c533d08f64e0220553177edc1dc2da4af41f9d7ea2b0b5749a4d1d14933b779ec19c650500bd329b300cff29219323a78fd0c95836927184b098787cfd74825d0dde8cea227978f42c891485c5a2df4e4af4d51a38e81c4e36e7db8c0b8cc77122dabe765ad4907ff2d32b6caf872d1a771bb33a58cee2ffff04cae2290d296fbf857640f0629c3575ce691738ca0fefd260a8f3ca777423e5857a1b1c511ba44fd528ef3c4fa0414ec08f3c93249e07b28df1d6e72b01adc40e118e1a58758e5dd0138c65f0853da628b270b09dccd40bbd33ba996e19409ed21170a507e00af25f7eea6e5f14722b26375e235742a941c9b5d120386a507ea4a89d8cfc054e9e6c8a537ec3a6147d128f698e9595a9d5fb50dfe93f0d8c99352563dfe848b78ba5bb109185391c7a5d3d683a0e53be51f2a0d651901888afe12a14d8d80f4e49e1c92c9b760b8d6837c013bb15f3bf2ba2887fbdd868a645ae5a04d636cc93401a7205308798c40d684dce7e76a93f3a69351a128e14c7e443d73db3ca9f21ad034f56f7f0ab41db8b599f736e977c69a52b560c485da277f4f8b173aaae78458a256e448bddb07518c4e426845775e23e42f8a158e3559caa2eaca302cb8d37f65fb4f1234f3f04629de326599bec38cf328d36a1afddeb2e96144e988b31a316d835d9e9fdacbc776d56df6751b934771449c52b5a730764e746bfa40a069086d855bb40d568b736549037132a645e3fb81c03863632c961f5ef1628d739350c4b3b0cc6f6ac3848339d47a8f6223fb711f6023401ac63a95b78ec66d5462d5699bad74f18387d25411de797528f6e6191aa665e5899ffe7b366a1230a73221cfb3ec09cb467d0e613f8d21c23b840dd6e10d548fe008892af4ca8b448f62b884049b1fbea1f3fe9a49383593997f0f76b6de19db3bbe5baf1388739bc16b8a9013ffdf83be52b3162fedbd45b07486d98f09f9b18c53666f9433057041cff73c190df982c76734dd3bf9339403ac4ea80606ee11167ef7efaba1c51b4597dcf2ec4b2220ac8ffff793e88c125757a5c3de00bf328fff65a985be0d74e8dd4c59d7d59907956f1d43d8c0f3ca7a74b239009b6420f33d22eb4d61fbe330f6b10c638a09541784dfe8e422088bf08d9492e449d7f59612e6f0ff1b2d2a8a2bc0d5bdf7e11bafdc131a373ce6ca45feaa1c84c00ef06ffd3cc489ee29f38bc7877ca6275b1303c38cc4e6bbeb9add8b7b9be82585b284de3fc2fbec91992343b403098afc4547266ff7e34431fe6270c2d92e14f3502dcecbb3749616b827e1516364d42e45d8c0e4f32e2cb86b8542d81cc5b094818ab2576e6e47df616b6b9060ba2c6e9e65bedccdd49fb362aff7f9a8e186747b160b144c9270d8d3299ff963e98f31e194ebfba70686bb5bf7937b710fe94c14ad1f73d8f4a026948d119c2b75c7203a1abb035fe2fdf41e4983e1a3e9a8b98472d5060aa1b86ece67d10b48cf03f4a41a458582ac527860c1c6e6facf64383de09e1721f213b00e8b010ba383676c7384c915e9ed558516b99b8b917fa16c54a2e155229f06d1df9ad9f53b7f8f268c4e014a3f39d2cc05c1d630259ba5aa9ddd131feb359545d9b1bd96cb9dd21250c1ef85901e10065427cc1650df7a7d13dd1097a72cfadf85b9aab679a5b267d45c85e9293f6f6d57ca9507208c37c990fbc2a55bc516214627cdc4f0a6ecb832c377d6c9c3176f2b364d9798fd5f3378a655a6affc841aaf6e6246db74ad5c6052886df828cf4072bc29ea350c2f91c04d32080d998b821754c8921b2b1bb915b2328fb4b3fc1b008a92c2cf791b20ce6ecd92763f44ffdaa010d0d35bc1c775fb57f4163a48da967b8dcbb178c4634bf5c8549187803926a855d5a92f7c44bb6e1dda4fb2684d792f7360d6ab6fab39257228b2c4b64c1ba8385ef1a275979f7d8b13309709aee00776d9e933d1da94ccc212880ac3040a4533f7e2a2a534bbd1c070fa0f6c997ede6484fc63a741a10d637331fb9308dd89629413f256cc592e3fd65353233451ee870d753fd416c41fd7ab3902ed6c7f96e05218002eeebe2dec379962e324110e5aaf0f16167b5cc6fd9f41ea37472ed0c6a9d39764ef969d8646cc4e33511712be79e9d276829c6fefe6029ce3997831976bda9a33707e470d6f4cf24630adf047f1cb6970291fc83ff0e4dc79a715d7ce522955088bcd2b8b528ff83a18f154ff15ba10385c35a77ad7ac4edb44c1ab327fd1a18304dc022ad95875743632fa338e4540cd10096332c7b34652137c3e2e2830e522079f8fcb0a00bbb8f3e6549cdf960b5a87ac95481f9e267599b651a45f4226eb9be13912313b3a2290f928a6991cef3c17e84534de2ab00394044341a8278327983a54349976593b18528d0a3caa99b84ba7a0eaf98624686bc9e1036c10b7415c054307e59a6691c4befa1d9f4a855201f6d3d7dea313ce462e41790f939e837a35bdd1c87d37e78c2b7d5288d23940486a358e19939fa3976cc9925e2985310391d1f0313549990ba853322bef57c78a178d0e16f35ca2bc1b7960a768526961f15d8fd7a9129b60a40dc696ec79ee0b7404e697bf2c563e1dcb0ced24204818e540857b74201f510de53ee467ca8bb91abcaa44ee8681a41b0dec1535d0e0aba1d92009384d75bbedd0ebc54748331744e682c0a6a6ab14a85704a5cc16158d49340f002a4acf61472594fc1783548baf8ef5e688340cd613409b27d4ffbf92274063842440b937e663f1000a0b563b61212b453178ef5254c6464fd30d2871d00a2fbdc6d022682e13dc08eb21efa9685a04d192604bd18711c1484d551fb8efb380129ece2f69fd45c79c270a3a5b4edffd9642151e94d530e4794c4bb6191023a1c724d491e4bff89d8a2e221b734cef3555afe3e8469b8fe515b1b556929f3a42aadb2d76e6b6e314caac7acb7a5c278d862021dcae704238abaf8b71601ec67109ef39f79af251e9c1127ed6ab881704406dcb64ca65c23fb02f628df46a6b378b4713a0548afb73367f05633ffdfc64142f9757522346b7c9492b2d35ff2abeeae567cf2929cf84362fe011b07dd1293c76fbd34db2f92f3231b217c0906e833092b2f1bb1e668077b053ba108a34a560e9b171acc836200fb7451f07ca8f9c330584d7ec684d86ffd8e48b86f2e1291b7c62e2009878feed6b17808a29c6b21ff858842ae33f9c47b907b81511207768a6022d479028d757d65f69242abae097dc1db4a3d4c34a3c8f65b4b30c946f82602d55f47d3752b5f729a2a20e1fe7b07d97ba914012cc2a5766bf0be47a5f5d90afd1406a79bd50b3e01e94309b00668ee9e23627b2a71323932e6de4cb1932335953c38c39ef0606184611d714493b7ca3b6a3e19163dc9ef277556eb6695494b9fb9e33698870a54d32130f1988e38b42a3b3d13b7e467918a0fa7493416ef7cfdd9974968f57a67ca2d205ae17bfc6f7d40e5abe33b42edbc91f5b4c89be351368ea04ca006a7f19cdb78618a2c6e695e72a44844f7e792cf28db3e7b6de67d2df41f9a1a60df6fd49013bab84f212cd1716f4a1c5689ae41fdedbd272e12c23a50beeddf6deefc0bbc73bf9b930b05a7dad6d8a249ce55711e663b17e290fd193a74e90f982c6b992f498c4b031de52c3655b9ee7b97de70958e6514e8c9edb84dcce5026c0997d87b2737d5e141aca4ba6fb4db028b854c6e79c036362272a0eb9809c1655e579ab2a9dc215b38f6a62f0d5ebe0bb24c09c152d894e2ab3ec9b8848929a28ff6f057bda3348b33c9a3f8842a68fa4767423e1ec3c39fda7c713e698376dda56d0052684a62bca99898ab7fcd8327bf554b5b1f5211ceb83c7a105a5d71d47c7273fbfa025a01716e103c07c3239327bab058b22aa7411dfcd8aad02ecccfc07d64bb66884947ffb4eac474a4cf67cf5366256a9a53b2f1eda976ba56f7bdd5a074ecb1163ce5e42378fd4bfcfc864882fd33d6362523cae3f7a45719e40d23696e87463688d1faf37fdd06fa2536df4673674d5ada318b94ba48b1ba0a0a8245d523a1afce3432a2dbeaffbf2753b781465ab9a92c37002800192920133c9572f9f328f32fc43553c440e1e9bb30804b88fbbc56a5be304c560cd2138b760d01a39e211b15038c03c084512ffa141f799b80203c94c0a9fbba8dfc44acbd9cf311058703419da12472a4d5e5ab7530d861e0f8f3e81b8a50f308f189c8af2c64da0173c128ad130c1a589a9fc4c7a474ca2edd848ef0a5f77abe8248f32fcddebc5f11dee3e40c5b39b032a59ab2a6652a1c44f18e62b245f30a3032e0578700c0087d8dd00d55f29d1999faece40eaa875db72ca56af493fcd0ed1bc7c9dd280bb7291915569227ceb8602be7c317a3aae59c3c610a727c6ed14f337ca3434344fc46c28834d24542c1c11fd7fa34e7b537d603153268916f6f0772fe5d4df831cfe69de3d1ec84f2c5482563231a363402265b131b1c9145b2fa07d2ef2e0d15ee73f566c43a35078c01faa39618aa866a69ce19518419580159e6cd329fc17b10d7918a47956bf901d0d993fb1b7775a35ad88b0bceab2ed843bb4b58919b4e81f9b85b9a0157942f301a84f0dbb0faa4759237fbcdb94816608d087e15d3c36fb7b238c9c9a0f9a543b70e12dbe295f4f9d261beae6d01b6828e2ba2e7f778948ae158c916c99dbad600508a7a25667568463159c91809a22bed92f2b3834cf5ebae0a74016f2bb73b0ecf125e8b82c2a6a89d4a268aee2c427605d1440f93769e08911351d7536adf0be602ee8e7e67dcec61aba6b0016891044903ca230e68cd44a62bea64cb78e4aa2f957ad97858ae2ae7ebf040cb9a10790c5fd4483c1035c9462c55b611caa06672321019e1b60c70c12552789a728ab032eaf2d668d4b384f915d32fd959007a99543eb100e17ad61be9cf8a3c26928c5190517479538e1e419681e387b9dda8fe0063bf3c38709324fe4c6b05e7cb7edbea87724c204f01ea1db56e000b09c6748fccd53a477572e94750eb8a51c864caafeb37602313a0589e95d074ff0774706d79ff836f12e1dfbad970585ef841ddb0e2026326f7f707d5ea8ef7232599f22360a7e556d207d73b4c2e516613132b1bfe13012ffcd92f2866ee1953ea677dafbdd6594488b1169ae5ad004e6dbf6d7fadab707211e19390231ea3f6c5d708607a5b42eb1e94f04daa8550c9939b8ba390ffdd20a5597d1d08d1207392852870e684169bd83461c50888cf0c4c7d859eb3c6c69afa704f491d156f05a79119197aa9c6b0b52196de1054c5684c0191e834931a9b4a37643fe913249201e1f9cca1836e019e96fbd24e373986cf872005867189a0ba6217eb980613f4e1773988178bb2953114df7474ebb89993a6fd44768a2dafdd45165e9649a50459d53c29afa9e3dc0da163695068943b3d44b2c5d729ffe01fc9060134569118c02bb141834bee2f6280c4d20d2cb1783f4b4eaacb25cfe42f1ce03dbd86ae326ba7d76bea5bac502b4ed13d7ca18248d3d6425ab7d77f98e2c483ed0f669d3f26b90794ad2caeb8bdb9d7f9cac65ad72dcc200834dc5c5432ad228145fc19dd69c9de039075fdb81fa0f7816e9bfbd9bb698ce770554871580216053cdc3840d11900e85b7ca8067e9c06e05cd6b54c7819c064bbfab859c50489db2d617655bb751fe2a492f1331a741c7d260dc9044d9a536243bbb8ee5ae8c130f050b3676f52973c9321df586b03a90609a3d62f6baa27a19cce4436ad8a63aaae380866b9149fbd061fd24c1117073fed46e5f04d2f9e048b54ba44cf41295b34e6246bde9268e70530de36f67b8d64930b5044f20fe4c3f26e4509be20cec460eca5d2ff066ec5401de8ac2dfef77c01eeab05288321c5750a37471f45ade680459bda05e92d2d1b9bad4a38216ce506b6ad2440d9053b2051061269f7d6528901e7b16b58d96503db0547943becca81f9dd73ca7c59056af9b7a5dfa60e518b76ff4e279c186d4d7804099587303804fc8b761b3c6ce116ff5a1c71123f7cd53d6d663eaf34515aa390f47196f0b23db2900d9cd53f4d699b9719285498d893ec1dd6af93f714a6d0f0f8053ddf542a145af9be17d0eb66d77451dc683997462dda95984bd731ccc2d2bf6ce2fc0f30cdbe973c3ebdcbb6b10618c4cc22dc2e0e1e3f86e5f9d471a98ef7f8a4958ee6d04d87ec3989aaad37033279c5334d3d36fe4efc5bedfff35b31b535247209d35ae7249811dcb2427355723ace474e50d8ce67bc3e2139d1839c3082f0920c9d3da40b0fcaeb35563faf2828660193b86708672a0a68562e5b0fe22220e8cb5a3d2c000df0c5ae72f9afebb64a54471c6ac749679f730c44f32d1001e53bba3b8097c85cae30379d711b2a9dec900d163efe1f42576ce78f4aac14992123369f30d0a884b82e57f82af95ce509b7c93eb2cb423520d99c4622bd0293a87bbdf863f242f62fcb72ece003b83ccbc8189ffb0c435b7df4b357a07144f714dea902b78b6368a63e370aaf8e197faa95443b7613014dfef1f32df927d2643ae43ad23d88e5a3e89e77915e27f68c1c579626dfa765fceca392ae9891f0c6d4d3c27a6e7e5639acc65838809133eae8d3a3c148e4105290402223984f697f8abf9de4cb69d60b948519a9fdea9513574a37ffdbddd4f295d16c330e2cdaa3ded9428bd4727ee6bc1b8cf626a806f4391e5e51c9a1988be35e464f5b17f430558e12d38e2b1cef760fc01c36af490114b5b17ce4132d28ff431671762e618bd69a6607ba97f65357477c5c9d622e96642f509cbf9bd1f09a783bf7c492e4d121822b678be5847d1ef952269d14fd647375687670fdc66ef1a3f07812576a1ce4cae9a5de365f76f5f92d4019e2bb64c4b4a1f936a16ded5f04745a90e8462b15b795d9ad91e9383a9dc77673f68524778dcdb02d132eddd8a04964f946abe6a317cc808f07e2f20fe03a5c80bd398d73a7d55bb3e2e3537aff33bbd590c10d0c212dfe00d629119c0c6d50ab8de4de513fe14611106de356add1e1459f7a02f2c21f1958ab812936a7bd034699dfb84af9674361b0605588ccb833f4b8581b129c89cd9711e289a7c74b1d67823205c2635e2291a82f65fa3de434d6c709beb43e423c58f7b2a561f386195f8af71a57056e707c3e067d0e91a2fa11003ebc71b95ae63f9bba798fcf36fe7faf5135d0cbf3097e2bb3bea76160c3b9cc87e0192a3bc23b51a21906434b220ca34355323f9aa8b6bd57b25ddb43dbb6ea50645824e6ef81729534d88c63783ecb96c89e65d96d72d8689067060798a0c758ec7e5ab29da705968956c9f4f93c98e248806b576d55ea0c8f3bc52d5d76b364afbb9f29a813f9f24ef0058d05e22f93c3f49ed304c0cf3f76cb8ab42a94a2278072e8ae67c0a0ceb96f597eb6dd7e253dc29a6283850c7f62364d00dc0f866144ecf9a3c099a0a7435815121489e50337e5d6a6bb3d638dbaa34fcbb110e3a3f637453481278f93ad6ff93a5d5c57b622f255e787806942752fac34742e74750b10be2d323900ebdfce1ed92001b665f219e69dd8db0f3fba46e22dffc3bb6a3db6f23a3cbc999552a89e8b65f954ea865b7f34b0d0c35f921dabab5cc637878e626b3497a50882b79ddbc11f9f5278218f8c35edbb8fdfd45c1b463acca31020bdfeacd4c47c05fa8e533bb6ad7ab2334769026c10023c0f91150021e4e3e89ff569f130dc6118893c338c558f8fd9eb1592cd8b57af88e481be20b6ea289eb85085a373396434fb6aad4266614e10ec6c1951bb06e5a5c78e7e0d2b10bd154bd59efed92e137de0761a3201dee16ba21b9312ab72230699e58d50ae05c8e3b5349c4e3c858f4a511d7135aa9334eb35eadfd51c73fdebe1a9cc81fa94d7882e506ba3dc9c9aa7d9f9b8f63493a3900ebddf9a335c5034eaa7a747839725c14d7d338ff0a8f4f19691a375d2c3c5e1de7c983b21dc08350ebf5af27aba4037d598d1e12e3581ee03fcc1863cec93416a5adf2da21688307b1953786136edc97ca10c74f22db4d56f8c5c168986178d68888a71863cd0a28c5473fd804b3ed7fb9a9b05882b9121df1bc7dad7a5b6140c8e34fb5f80ebc77fce3d81a5fca45f3d898d9db92feea0e3b312a223b8e42ecd0591bb7c3efdf1036ee5cdcfe74fc31ab231d70fc3e153ddafc6560928dbd92228594ebab8021702246952aff28c68cf2f320ee6e822d85a371eccd52819c023a473472cae381c7b3f6f54fd1c9abdff18267cdb88cdf1fbd328f519cac4da23c64a2afc3aafbca9a31a1fcc3bddcbd3ed777cfdcdd7a6b202583d0d8cf10115f98c5815acc5a5f4ffa90b3d2b04b49570ffef96667a74214fe27a06d843bb57c3210d3b3e4ee3c1acfddacdccff39212a0db2a67de672bf379d48b2b5c3b655f100b7f7c6d92ab163666f3e8d4f978309ae8bb188f2bd870cec7d5aa025884609a6b802c9670de3b41755f619dd9324d2b233210fa6456a618acd7f0af91ad0d37a439022d01a619cb1413dcae67fb9f71c2d45b0909666135bac913f8c9f176e378fb60dc7b9b050dd5c5b0a960528e7d3b5acca75afa3a332a95f34e697011061dcc330e5ffef320d7d2abefd14c5cdf2ffa6db047e316255c6148cf37495e4b62b70361ac609177f7bc04d8c594e584e32b4ced697ab3900541014fe29f8bdbc474bf66c4f4d774c7d6c504e5d6b6170dd8098cc0e8ffaa14378140ae5b905488a805352ae5471de251ff36806e2211700ddbb9e304426fc68ff69080123256c5df1d2d1968d833b3aa7859044cd6808f10fe135a671603fd185f8d524bf0b321080685377b0142fe6414965468cb3d54816995a489971410d89c2f25f814fd270231d26ab0b3c05be4f055860887e8d813e869cf041440d10e5480f7e1361b07495bf3ec3ca8c1c57dd82e4087c94ecc03917e65caa434e92f8d8226b80b4fee05bea598eea3a19bf6aa896e75afc5c8b6873e0ff2301978e0436d5d3fca02b7783e5fb7a35edc4ae7276f2da8279e2b3c7b0d4a935e8759b4277eca82adc850f2e6f75e883e7eb0546bd39cb0295382a9537066e09b810f605b2762e3193de84f6d25057bfb139fab506829d53316549fa963a13deb0b38b39fb3ba2dfcb653ff7f0129f4ee5fcc67ef7095e64cae711dbe55773bf27c03fad73ae0716be65d8aa92ed428a6d89c246591ef337a0fdeb907d5f190120f42fdfeda7640f591129447c87f1b57f91be29b42571bea23edf1d7778e149ae2f8971af617963179092a8fb48ed2224a6e10ff189329ac88a6037315cd38ead11ba26d1fe2216ebe9df05bb43fad2b984faf82cb37289175bb18cfc1f400f93bec648cfdb2692f4fee72a148a259ed047fc558d9c4838183db67b0cc103d558ba52a3cfd21739c6076e174318465d072537d43905e0bff4043be03dd7044ce1415fa50e3e77dcf3ce4329efe0d02d8b5329b77770e23346fef592aeafba40f80bb82e678adb1a7ddd2da025ee005de95eb782698190afb6ddec4c075ac689465348a6a3195fd71f5d680c2b5823efee8e83c9dae63bcb2e2286d6c8a7cc8113c474b876884eb9ad83881b425a525a962047f7bc9fd9a45f248aeb87e3b4954f1d9b8318ad4fe49ebea142de90282bf51966a721e2029f430bee4c90b739a9c537c8d4b7ffe5e61ac1061dac6d6d8d29c01cf1cb1091f7e47b28f045460178512296cb4957a86a7406f55112b285a9a3a9f61e8c87aa64dfcdcc353df59ed6bb1b2bab26852c2d83b66c6cf7b24f6efeb9eb65bd4657e9fa83cea1077f3bed300676ab86c72b5dfd981f20cdaf6816a7bd195e2f758feef10c55e433d1f948d2a1447fda0ccf0c7631eb156d1453e2eec2dbf63de723ca8a94eabdc6130dc61f163a6d6093fdae941394f638fc351635dd902b4e25afa12f3a3b1df9aebd8a7f7bc44d6c059f56358b8f594bbbf77bb6a9d311e70488b2218a0d23e875a0b91a9b80f1177167a0ad85bdb1610e426302ba79e81d2d5dd219d8c070e1224d57e6ad15e04724cc028c7a29c1fc264a8f77b77d0a14f347a79108114fdbec2fbfe87b97cab5fe0948689f9a5a37d86eae559da3be7917258839c92225573ac6eea0f7c99b3c39aaeb4f1b72cbb7c72d27016ff8b7379d8305ddab37b6ce1339bb37efa3f76f63f20b79238252e2f8e21da8e27ab544d0d1f693ca7d9c4881c621ccad2ae44188cbacf112cee21bdb5d5a91c5a23ec562f5243e1c74f82589a2100eda9c3854c21d691e6c05bf4874c983e5465e4066e0282fb125bb181c4963fed9b1cb4d4d3cab4ab655954ffdf5e76cecf4b59870aabb2faec637a4cd75c76d79d8295ff2b9e0680bc586190545874d4d86117b2528950bc7b651f1638556e08f0304259bf9272448be06e61174d992224fbf2f43a15f0bdd8244e64929fb356191cf9a094baa9b1b2f418b1a4c1389306e452fbea68c73426e13555c31d7a31e436957bca973bb19a9afb54fc4b35d058597f31454ed0eb992b9386406b5b512dbb021177d4041477d88a2c14ee763a81c0f4312befd42cdefe75fda219d6c2f0e53d3c07028e45d6f97c37937f44dba2a09dceb9d5f62dd9233128690bd0ad64e4cc3ed1f1d5b5e1693bbd5cbea391352c04aa6b14c5201d1b93712989a32ab86026754d7265ea12817b2520da2e454f0972ccee728508674b77c226f1151b12920248be5ed367b2c756871254424760140380b9a4adab5dc80efb5a0c7ad4229f9b5ad0eaa335a7b2a1a46e4155452e00a99fa5e5eda620f64f1ac1c3d78c0a61222213428fd50c3bc48d78a1c470e88f678a738157269a2aed7b4fb5dbd925df0b26a29972fd0df64205ec15bf79362d5aad21bd01f45c8e78d10c089229ef5584a6f359632bb2340c279b9ef64e5a8b524bddf2e4b4acc1fb4f71933e80f2aaf03369c04cda23c220cbe66d8fc93661663351b0ef39979aa1fb54bbcd7ae34db5327b2d2c2ccb560ef6d9ed18d7ce44a2fe3739ec25fdb1b6d308b88fb1327f5d6e81990d37125306c53bf0b817f78533bfc046a0d6f585531b9853210e804caaba5fe7698a7b19b57cd304b5c4a5cc601d6ffec9453bed045fabedbf294a9a07da2c2b60cc73be9935244fd7ea2960d8082c2e69674c273aef7825e44c1dffc04fc799a9068e0fd5de64f89583e9afaf0d686374537f6ebfdfc137fa12fafa739864a49a6f49d0a6ecf43005744488eb0373b6e9d43166a543a836db0cadee90d84208801d506e01684e174666a8b09a0e4e334714e7154de13044712437d24d8d5de6b69bcaf80efdc6494f20f8cec87662cd7da079b8f1a6b7d389cfda3b98c9ce059e1c8a861af7a3477ac775a89456c660850a73fbd80a4fcf2c929658a59304b98366c72e99e60e9616622a47e412fba7c259acb53406b071f43fe730d74582ba989dfac73380b2275dd1bdc965791c4cb8132feb37f1f2f9973a231b39d55ed8ebe0dc76b146043a3cdda35c7b527a8a918a394b7e3eb0b51acf6768c7130b286995f20e615a7efcbe271842ee6ebf5490bffd4a70276766e7686c034e2a9da0477683900d8d9a628aa48f5c217c96419610d04f5ec2fb95e36eed0bcffc688aa50460bddd2c98a07006e0165c723e9933e6f610d353a6d192b1457906680a8be88b4cc6bc58df97ebf0fe6c1fffa2fd2e5785a0055f88135a3c1986488b9edf823e657ef19b262c7d8c9ac22d4a6e8eed1878fa87709a73b0a6f9aef7c9d54acee20ab853f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
