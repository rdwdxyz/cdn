<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad226c03812f8ae7bb6a9e9a11a0c25bde3912bf06e17fd6a890a9f62ce296b68ef03c8215c7bcec0c731799bf6649dd250116db54496b3b75da5285566123edb37dae6b53a298202bc065aad71042dc355f64b6462b09bc02e38afbde265e9c881ce9511b3d8a24ae49f57e0e8e1006aeb92722a414037486a08c774cc72fe13a8530fec88538ca884633f468b7f9115eee2d67608da84008a70087b565a2e587789b443df2d7e8ba1328eaf0f0cdb1bdab44dc1c197b342bcca0fda0331d9acea3e21421925eb364658ea627d09369d08bc27c5ad71c41ce4d8229d8538839d4f8d07c72c259d0e4401815d98f01f9603827940abd76af436ea4e9d97b09bef24ba0efeb1d7a980f93cb876f2ce02dc40762bab9424fda4442af09544750a0398638c400abdb3b5f34cf84beaba7d9169e8af74e9427f9ef9229351029f4fd34ceb7c83c0be5a876d3993fd3af51754e82b1b23ebe3bf699710c6e92c7362427d43576afeb8ca789cff1db3e5804fcdf49d46ae47dfcde6002c9b54fbb505d2089d8efaac338f9a13ead046ebca1ed0f35dad99617c8b662f9cd8237e11e7e16379f5e8c3556bc647712d912d0e18558525c7cea29918e48b3d054581fc9a518803bee41b09ad1813e71ccf8111f3d16e1ec507c2be72c2b28225fcc1dcca283540724857bac93f387fd4a976498a9a74eb83b434a1313ab410e20b2660f544927d0e9cad7cbfb36eb345ccb2deb82f4a766495526ecb481395fcbf25ef277bf3fc2e34c22665092467f6764a7d369a8fee07722ce4a6a13c29bdf76c60038c7fac5933dc46ec1a372297593b67ee458779436b02eb2135244b5bf5c16dd854f22626994d8a7b6dec43d01ce4065ce4425378db04ce5736f503d176ec063b5b198ba50d448c28b30fa0aa79c34e98a75bbe59d091c9acf5c14cfbcb77d97dc6b086b50ae27db0563fb1a283a6fdab316aeae01a9e34f046bf6f5518f6a79d576fe4cbb01c43634622e6cb20ebad38a58172880cfe7f9a4b20f0dc0fefe9a2fe28366284bd6a0e07bf4e89c5da1d6748d8631b67cee4ecae29b649130080ce2cf20ed83d09476535f5d41a53e5b7e100f3df9b3e1d4f3fd7ad833b8e31b27cec3077ace94636e8031ee6eb5f41bfeb8fbc4801e8bb14390ef9eebe7e5f619c0ed6225e12622368f1ba981cf31b23a56df1c210f80e4119a23332874613c263166285477b3864a9ff0885a9d9c3d973c981c36be982b4193fc0b8f1896a57a350a865bcd8cfaf9f4d96aad17400ca8b3a92a2aa37cc534c4db1f40a10733475cafd71b82e786651190118d16c0c1ff553f36b6025d814580c129168314f1da378608ce889e2a6ff43648ff1f8753eb1511fdc201c701781bbf8fc6ec135b57d9dbe887a5ff3eb26f6153562f7b3d01aeb54d649885e9f31f05ea3fa32a12e833c1a07a7deeb9e18e89c98b355e564254585a67ce9d2983135bdd1a17d2640b1add8644351b497f1c827c1e5da9de601f0ebf9e89d79729cd930718effdf7ee7786223ec772bf716fa1fca4b1ab77bb42162eca610569eee5741b811273f56735e6d2217afce197c25dca07b00a1c1a482e1bbf98055b2e888d1a94c91fa1938dc3d5c62e7562c7260f494a191bc97d5717f47c6b17822157aedc95662256f31a24ed1916adbaa8089fbfc31679214737ace1b3fe286fbebad8290982d5866d9d97368dfafdef87c67563f2293409610ebd2d13a940219ca5ed4a135a01209df14e527d95ef168787bb31f7fa71ef25ba4b28a38d9b167e586bda73c08d93ffdae49979b2b48e0c56f869189809d9178f1e6c629c364c20853aa9366ca6020ce57479e75fc96baa22242463a1eb7da846ebcec02272124f614ba6cc30d3bd949a12ed826f84c8da59dfd88ccfec61f7ff74d823e434eba432965b3f7b5d6dba83e1245436909d519dd201bb4ca881fd033ade4e437785e88f1e2b20c8050768094370adbc0ba11f8847e02719c4d14b9ecdf93358410945e288e1b0d8530742404b24969fd690aa9864013873bba412544bc092747d574f5dccbe5b499f680d95754bc3f3e3c72ce7c4fb9cb888a37db4c14788f9663a804f5a86b35e8e7fbf816d944c8d68757a4561c09f68c8438f9a1476e41e805cd0164cb578ad5ac29992a862f5d983a4b30abc1a3c0ba944695adc1185fef292aa6ead064398a96699167245bb9612f2420382e241713b96a4b34d53383fe84fbddc4aba9f54ebb42acfe8c44df57f9d7d060001aa46c222726e240ba665301dd26617a592a9c87512dadfb94d957aa8fd25b31b92482872e24e3978e2ee19cf1107e798be02ae868c2f33d23ddfc2b29751adb9f6955a122314f251f34d8d8a6271aa9a704a6f19b0d99e96a9634f87d03f024ff16aa6aaa3e5c7eb35f34e97082ea1a35f09fa8db914f269ffec65a27a905307288ac1015f99236602af03fb108eb4bdd9d8e5efa2e95bdfad9dbc54126b6297fab44eafad66a92b70ba7493d9c24a499fbcc2ad5c6aaabce44c87defb74ab4e207e6e5b53e2a396265b390681dd3b73eb0a75e54cd81cb1e1679bc91011bf594c9913a39f6d3d23926665eb7979088cc762c6e4b9094348a6d1a19c66de370902ad1b605c097be6c938de0832695feef75b3819c059d315616549ec033af74c5edd83d4b4e190073cbc4411c779bc702074e40900fa4f1a05b7f1bf41acce23806acd06a5ee1efa161524b395cd0f4245bdcb15893dea6b336872a1f4157d60ce5806cab6285d2c2697483a5e9604f7675216aa409c250f5016b6d80a7558934e02b0ea838bf8492c11fa755d12bd5d7daf1c7d85f8d2657702d56d7a5b4aa692738388c2f1df81c5ec721e7e118a0db9aa105dd5796ba8382033ed29c890f1fa0d95bde96ea6f867853832541a52d80cba3846e6e8b4941f28a801d64c14171ec3323afbbc49f5d1a6e83391b7727db43dc7333a52a04cb72e9a399aacd24168fbc1c356886db2382e65871e771f53c2096d84e7dca22ba8420f3df5e54a58b4711b83c2929ec3bf14ee778bbc85e02db486c7a74c425e1cbe750de058d483e4ceeb6d39c0d51006395d79a4188533c0a9c53af4ffcb51e808e68deff3f126a8924442855a4dbaac5e044cc7e970dc5287d975f57bf0eba025dde2fe2af782a402d16aef92ecda3594a6a3eec2d777edb8327316ec3b9765f24c3985b2c9c4f037685901dc5abe7e2d53bbf5c8e95b77b42c8b76e692b6022130fd04d2af22e92c1ceb11fb4bde849cc3a7c3f376bf6a3c6723523246b298363e5d4d4284b4cd93b219395190fdd087da1382608616760e53fd93bb26905bf085e3f9c2da0ee0e13c6c19426b84e2f4289eeba1b42bfc317ea4270efa8935a8e85c7f1f3e9d6fb95ff429e57a0dc717cb22da95e4825d81237d3395fb09fc0a386ac34071a8aa8d9dc28db65deb7a6805746fd752c832c80552ccd874d546e353a615e25d45ac3f435127cad952a2d02d2da7a047da9f16a58c81e7a1610c3c47c6f3591d8562410e03bcbd705fd33308f9ccc4b853219722f5f2beacc111831d273ef14ddf63358f407091b8485d71918f66b5006ba767c2233974fddef2bb6d055c2ada44e5bf9182a9f99b7564c7110dd25cef25e7fc78e4b783ff7a946de4afae2847734fcfb18b3eedea0d8bdf002e363bd002789a0262fcd54caf75e2248ea15c144e2dfdf0200d94d0301d46e604b6e8a19992355a7aca3d5e743e978b0e978a0149cacdc07152ba579ebc401f75791594c6b1015002bc7d28069082af833dc246d94d555461272552b2ce6c1fd51c9f31a0f6d8835f7c71416e7541c4a4b06c08f1bd92022ab4950a6dff8ae8d01e3342ec877fb6b736f0fd19051cbf99b2b0a245dd34ba27138cabd27aa913f1233b7cc907524e248f228711fbdf622fb36515046878e8ceba4a7c702a6d0cfbd83beeafe9d116e7ec1fa9eefeee50bc864a6b12ec92e66ec2a6d5f81e28b49f1a770c3dcbb6d3cd330bc24970d267e20af8432c621e0ee8c94f8cc78b2cde8fa39c58528b727d65bf14d2adebb292d90135bf53eb88cce736a551e27645e1b53a0d4b4fa1ad427eccc40c9e29518a1ab566ce30bc43655bb7c7d85b009c305df990dcfc1cad14fab66ee317365c3417cbf1d3b653e243007eeaca47dd830e9320df522f513d7673ca994d31afa0f6d715433d89b4cb1dea039800ae56cc71d54b58e5632277cf5df7c7fe506d464b476ad11718d0db785f18ef42a689fe8ca2a823f53395feefd10bb0a5e009aac01b954ac579343fa103ed76536e7a9e0e5b76dc39ca2f70e400e2acfc408eaa4a65a1f2d8f70366bf5854fe05959a7934fb4bedae466a55483be4139f67abf02b7b33e8c9d1c441e04ebf6d54966ac945ebf9c5ef886239a161a6165737f5c6beb273df706c3a272152c4ab063eaf4ace0f95a54e711d22f24448bbe8e2510f4901f62fa067635a6fe578ad1587ce5b0ee521848560a520fd412c752ad02b09e00f3d6060fc45305d7d7f098e417753d16981d140329aa835a1a3d08b95cfbde923b1e504508025c2b47c955bf6a2b8b4b81e68742b296b30b2cef6d76070962a26b27bfe4a1e5cd51c295226b5ca5fa7d52d34fd008409d3e3a00f0b9f2c9473e8a72ef131b6df21f324ecf895e0de00d5454537ed7a4ffc90aeb51c0f2e5dc0b57a08963ada7bb38791ca2032fee07867c8609109b49696318350ccbd728c819030a1f2eb7c0b164e0d3d2a91d9878a26c4881d90cab65e8d290bb8ca4c586d193a5283f8aebe6a14dd1cf167112e237e2805845b4b9fc9e20367f57e5367e9aed69d050b970127c1d9ef2f51b113892b35073a3266c279a1510a106e13969e823439df57143c883de992e8f84acdc18ea992d3910d650bd5db33847f176eabd35948d4d2764e179d41ca32a70cf45c37294b8fb89d96f5bf651d2585320309a4a09396c3aaacda89aa7cb24b9a53b49c3c40083c631d7cb4d692d02cf6cd7b5900d8a1d7dae3476dd17b81272fca3b77d15bc804a3ee8d065cf755404e37d89d8d3220035e436f26eeb3a58709dd29ca1f148a8ef3d772d54ad731c94a90ed97a7f8d54297560ed483a920c942af62a5be62118f7d1054cfc2fb86d24db604ed35632a91725eb2505da69593c9843885a8e7448eeaefa517470373bdc0b61fa81b0b8feb0f35edf3bfc85c401a1e1c9bfab83d23c69d7f8e2ee751c2471244b80bd51c19bce60237af23dc324e6c6d008f23e5e686e0175463c307398f2cae6ab8c0a18cc04e8e36535143abe1e371ddf028dd86575bf21d25886ce01ee8119863de3e1f066135798e716cd15237b365d0c45baabcfb292be060f135901e328db00f5e55ed178cd9bda9d5c9191b54f596afed31519d45ced8c13bbdd00fe4eb740dda6bc22e5f4892edaf4a423effa4508b291841ac27e90639f8f3a9ac8325dd92006978b7d159afa969337e1aa485fd5b28745ae3420c65343109aa3deeb71e022524d80212ce0cb6c6fd3359ee70b4ff1b16cefb02cda7bcded015ccafd31130847f9ac3b8540543aacf8d737c031db82e4ea1b2cdad95e0506bc12881bd85916e282f5a2ac47c8523560196e563ecf3d39597d13e8e09cfc1af99c45e35745cf49c835705ce47109deb2fa4d0702779c68e2540b55f1997ad1595123bc1d738b56ed3830644e84cdd5711f8bfaa8b28eb963023ab9ca7587f8e912c58d21d2793220bbbf1892411326b99f07ff278a6e6c617a9ad0c0979a8c6242d7d00e875a82a2d596ed2e873e16631c8cd6cdc9e19a4da65dce7f50ef6371aaa801873114918763d579625ef5d64b64cfd6bc7c369cc681e665f10500006f431579c6defce24ef5baa43bfec3e01bd453d0dbc46aad7b19e7f3ed4be7295b72dbb142d8b26719248a2c9af32cca09df10475e49c516eb63fa918f1baa7099b05f6be47db5bbf21c8867dea3d97ce5968ed86f817d6db252f02d42ac8dc551bbe378c912bb11c7ad12307bdee086f8e4b9386d5d52cfc423a6c83f3d7f7bc662e5de3b082e00eb5a115c4c9b619128c50dddc14bc1c3f3eaefcedb15b39afde84f9a8c9c574582f051abbed6a7346a15f27707ac159ad7814b750b5eb56e657e94660dec27495a81db51af286a6dab1c506d1e2bd0096b9f7b8af704692753e08152a4e0b5e22902ad0d0f8087aaa31635bff60568a16ca223c4badd1a7ab003f8f4c814615f08ced3872872ecfed71ac631acd6dbff70053a7d46509189ca586d7ad8faa91f6abf97580450c3a5a736edd5311158bddb0ed362141978d13cd304d040def2c7be1b58082e0b8ac4c992c7b8c54a1b4f924001b2278cfef3d964013096ace36d2a154bc6f8441fd4527fb91146321da499c3d4f270878d44abea98e02c3ab9418a537642340800c1061de44bb30437f58d6af0250b1b479ad5566bec7d751ff02f58f7164f4bf39d4c221621012d6974cbad7447ff6009273bd7780e700c64b967ce092ab6f7c2adf948ff1e4249c77becc843255171aa6307f827ef92b1b35c5f6d71dc1869899a7734a4a5153395aa616a16053879acab4166260e3978562d91df63b1ee2679b423aa682674e0febc3e17037ad32894eac489b6e6fb612aea26036f3150cd73d09150fc3f38b81c6b3e755ee1231c455d3485afe8019b95266d67d7a8b1fc6a4033f27c30e2747151b101cc77353deecaa76ec6458e7f6fdabb01f1577ea32e0eeb9729c9dce3ae216f35414082a5fa744fd5e6a9c8022d5c5c3776d61a2ae35bacef545f51565c3618fc61fe224512f446bb3a3a0fd099bdf16ca1e522e7f352beaa56d703a89037c5e451576462248dab7376646010e1edb86f501bc5480bf4d13203abe71599aec205172656f06adcb227705f8dcf62477b7e4f0e81c0f1968a126559eabb7ecb60b45052fd19ac28a5005e9077a424626f4cfd624428ded4fe8bbdcc61c0bb79ee34b0dd01c89aa1a43747614dd735125137d766d187665cc00a5a3cb51da1be5f15a96513d51939e9ac48bd336112dd00721a72490ccc93311a9df889666ae6a210b4776d10b291730d1bf680e03e7c7fd1dc5bc7663d30080cbf6a0aaf9ece151c211b5f33e97a062a52ae7181da3ff51fd9d4b0ce846f2b35bfc7fc19b415b22fb9d9426ec3504825b34c90e47b32d081cf37227c4c1c1f91196e9445343ddc87ebdb8edb039a8013dd32fa0bc4d1d691023e7732bf0c5b45035686ee2c12a27494b25a107571f7f3bf8c24d37f4b156c3acbcc167d53775e5f7d4947b37c1f2818c040c40d77111ece50d00993a6e805017354522330dd79570c6d686d884a95b3c9ec2af1b37c42315b6916557ccc738bf790af5644d7c65621fc6e71de01519e637d958faf87182c1a46874ad5458b3817325bad68bbea3fd74bef21b3ecbd54669ddc83520837d6b54a0c283a8ca25956d52e6a6ae65b7000c8ba4633144ea11e0052e5fed62e52b537f6dc56afe432ae28a2085ac35d278ebd96042b36c5d62f1151418bffc9f2a1a309809606f0b2f33511263b8ab98ffb970c6da284c756af6b22193dc323295b55d525cd139f49a87d0d1e8e7ca9dbbd0172969a03418b64ecfce8be0819e94cf8eafdf8b4aa144ddf4ad1732f058381c07e3a53c5c7ecb08f668ee0a702aef2c72026e8e7372b27d891d7fc80b1e9be456484e8ef7038d2e7fde130911145f6cedc9c20025aabdb1bc57463b78524f7bf879982a2d7ed3950b442e3977ee7bd79bda2fe38840371dcc090d3a01e3ab2299283cb3a1619d761e637811d24c0bef69851dc9e275e3de48c77fe9bd40c0579b2349a1fd3ec9a13fad7f33d4e12d2e5614ed3d9241db8a8ca2fa4984e70a6841623601896de311aca2bbac03218812a5ab282db79c28b671c2a5b77de9efb1dbfa7e669c44c23abb5bce9fa03d80bef7b9a9e970fa09e1a7d231d060d91aab85f13db7fe7989a15202115e6243a0fb9628def36c53a4a60a9e430ae56f5094237dba1fb8dbe597fc28157393e7de86bab09eb8617566dadc68c4bd1343bd319a564883f4887d7ded3b393f5dda96de5a8999cdc9c7e70f1bdba06f6e8c26d7dd32d478b9b7ac0d0d386ec85081414fe6a00a1e16a96e7c7053d3ef23f6eb1bac56e10e3588578fbdbf06dc9da5faba59c2410c2e1f28b6423fe04fb8ce28ea029008b038b053948efe0127ab3118b382165dbb5beb63235ce1e898319f3789b1a34b3a0d5c6db9ba581c20dd2a3fe1a531ada501907154a9a61623db7d41c0ff458f41b323fa8f8f8385ba515946013aebeed522882c22039d92daa9a4ae3bc3dda759785d30a1db9a70ef3b145d7d962bac20b92295c1334f8b55cae0baa7fa9c008132666ff1e3adfd478774893e4e1b915210930944c3ae072f218e9dfe7ee8a927e3dc2ccd6fdd4ec4ca6c49772fcaad0181b9618f229adb88ca4aad57425e80f657eea87d9d83317529aec560c290a10d46a0b1a5c29b416c4c4f3fbec794f7679840b82fbec8e82705bf6f28a84d4ab7d0028629fd793ae4a64cac3f0674aa71f7a47fe196987c0b7178842468ab3720f832a154c86b77946fc3652bbb205c612874c1d07f6ffdf152d48496cfaa4cacec11b386b0070919f519144d3eeb7f8711883d95467c08503adce7ddadc5bfb692b19fe3627bcbeccdc2b6fb98495f16452f034f3d8a0bb0316b9216b6d865b7d6a8c34eb134fb74ef0d0c552aa01f86e582b83ac0ea30f9b075794d9e8c4ebed436fc1500ba25b23c59dc2a1a7113b7f3ce7f4fbc6510ec1fdc797735e509e0bfa1af044dea322657ea92ec4796ca07dc7962a9f25302cecb8c024260c0592bc07809ecb66ad32d09d6c7242057c2450490ad8cd223dfaa5b7d048189bdb887defaf4f727bf1974462ffe25223dc7f2f3d3f780ce3be7d39723f4ccb6f08fb3bc0ad1d3e08f55ee84e63694ea9d752bed237f558014b59bbd635883ed7f8df850aa3dc035bd094d0bbcc2f3230417e30c0e9185820fda62a850e2c7d7bbd5d67d9800f6ef76c4cb4e7b05deee1f31d0ee012662c7597901473fb204a540d41b81d4af8187516e4303f7e17229cb06d6b9e9078514b95d74486f7fd00cb60c4e18f3d993b046bd49231518028eaca05758704ea7edd0e45d357d9ced9916cb624fff0253e64be5add8f565409336930174ed51f90ebb5daaa38071e79e56fb0f035e3e6384c8b16da0fda445b5ad9ed13755b48a4a839d487a243b95ad76eb41b17559631cd61a61077efe21058d99eed29ee4d8da0a2f2ab39c7899711c781c3c766112bc1e16a20edbd5d1659891cd2993a80c901c22f19cb755412ac46af7d3600d1f259c4af0225cd82fbf8af3f8336d1283c130ab6665a3f308dfdbd9ebc6d66ff242876ea716b1175c44aa3ac1b51836dce9dcc62587d33cc277b4631af9af7f7948508da4afeaab3b26985e1ffa13ca851e5f4ccc50771236d6f49e55cffba4e9124cf48ff3cfa79b728f49fac5e139767584437ea74fc63955db9e082f013938bd7587ebadd9feea734d1441b28944175124b07a3aa631e72a2b71d1783dfc2abe39b48e764736650e2f690e01aca86084ab66fb749121edaac730259604ab75efc50604c17a56395d18d546e0545b45633ae574542ae201de7905cef9070f0adc313dd680dcde97f3fd373abee77cdbf4679be517371ca8c87ed45ed1d6a7005235b8ac9600aaef7a4a1f71984b75bf51e489df06cb256657ddc77291c908c53fa945713536c9db0ba696c9d3721f77db802a807012818190edd2e5e86184645465fb905f002d8d782b3e1a50ff81162c906accae42cbae85d32acd7cd3d5d040e83c07d76f9acc20034e19bad3210fa72d55345df479da93d80ca5a1de049fec56e8431909f382bb081c27bf27e3690467dd0430d2d5f2a2bab218056011d26d9d6b52ae8b25fc11830e534fcf1f9b236a89324562cb60d470139b1885d876be515c4f661175eb40bff8630cd23fde552bc8e51f41b5d5dba7e9876d56ad26cd70f9c3ec349883a865a4bcd80def1493d1079f419d64e3b29dcf48a30c4d39350224fedda07a161b9500d850e38207f1b3625037c320c385f1a9ffb45d4f4f3a4d0a22fc2315f402047ff99f55d2ae57eb30115980a04696e56b3efc7310fd7e4b817b5028c521ac644404aa8e313b26c80e709f664d4915280f28f38bbdd91707ccd91308f9130f425b6c1d3e57c10715bea6887e791e4b20e1ed018fcd322d36ca07049701552728c995a388ce1b3219aa6463afb86072e267d0d2d2cd7e544e02976d9e5191e219db2e4e6293237c72ac31e4de85b0b1eff660916e7bd8b0e2408a89503335d2da49393c061b426d0a8487a68316456257098bfbe46116eba991d4cbbe90af42b3c48efef465c91edd723dd47ed9602743f98a2590876b8a467c0e8e2b1ba0bab374ca86304589f0e24fce10bc8bace84385bafda0bfc97f72c17fcb5dc39484616d1176912450d73a9ae9d009769b0265248d9e0124f9a520c9dd0582433c121ac3fb1355d2d6a89b5efd99ea45b4b94df47157fcad6a5d8277a09ea42e0144d0e84fe0b95d25470de81f16c224adb4069004dc2462c0e433e0fcc542793279489724dfa89f0b8b24f42960d55f090bfa3fd4eabef8690a17d9c24416dbd0ed68b859b1e685a70b576133cef2ce1b0df62cbb28e0badbc5f72f8cec0bf033f9283852ce09a05b94a8ecf2cede820ed2deee9de6045070c0a6225de615ea954037cf18c5e0f184ca38d9b7e25ff7c1907d8e6f81689ed0d1a626ef373140ced9e8336c5826c7f34bdccf97371b8cb06938e9f78d94a330b2b1711a89f369aed21a9e4cef5d519fd6ef29a5f2025001cc9fdbb0d7d4c4a78e3a77fecdd91e91f20a733af3046e09ab974f296b8bdbc74f221858222e730f0fdc767e750d0af13a80ab541dbdd94be494a8f92026bc088b2e24ff4b74b18391150f59f1d99d98829b4e8ee7cc5a5f19edbfdc7fd28b28cf05dfa69794aba2a00dc9e5c974fdb0da0906d3bff2eb1a37b0c1a7724e564d80b924bd4c774f2a21490a28a9bad33ffc82a5d0c25af86d1bd7f1e5a710a08af180cf3155f563a0c26d9b81705e9e13ae479891594adc9fb046905207ef8eee72f692171c9ffcad55e3fb7801268afbc3e938f950c794bec987337fd1bbdef0ebeac7886724ee709f92d94a1d336e4afebb983a23140e7ef0c40e577ae58e2d6a27102f7c04e8c1ada01e0a96b064ceb064cf0abe1b6655ca5f2ddf5dc0a7285dcf99e6d9569a445ffc42b0f5964423f7f943c54790cfe7f8927db40ae8633db711f992870e14b45765e4490631d1bf65e93d2cf84075abf58e7a5e68230ecf6ebac7523aaccaae242445cb260f6707699209cda2dd2ead2d570aceec96148c3029839598cb4ae398355bb573ddddbdbdbbcfd04239c0ad0e3c46dae6213fc3024ae0e64b6f27585ff7a9e6e80e38ab352baaf3881de08a40a140108d7e7e5738a4306332054c42e55621ca293c4acd45197472e722ac6a38b2195933775213f0837d81fd9f661c4f5a270e03da9d8f1fdf2cffc4059bf1d67a36e18bd6eb951759954276721c1401191c2a8edaadc5b234667b7da8575cbe037641c90a79cc32958e9418b0c46752db307e9bc64711717f7f3dd488e5bbf96fae7adcefde5e395255219902084e7ec4c4bed6b9c48757910f13d2f357cc770ca81dc5c940edff559859d132cabc5fd5d8c61837b937a7599897bc8ce985245ea8b8db38fd6820d29b4f26a887bcf8b0ddb5c83c7cc829372d9c42c1026b74ddabbb9cddadbda667c5ed20531554a1b52951cae668e78bd7891bb09d5633106271d5cff590afea54711877d767a7e70da883a90451c89c7360f4664bdd107d1984e99df67c15fff5e8e45fe76c6029bb5be808ad6c0b31b47e34631dd88097160d6a8959e105e09631a556dc1884cb0abc50ba038e9cdacce89eb810e9e00ef1fe4f1097540434b72495ed42bd40f05a80f0daa9d8e513bbc4839ec11de93e7e7393201ab9e8a6c2bf0e264d01d2c2bbabd76b112e18c4e9891fc1254e04f1c21e0ac8f1b34f4ac0e4c98ed28c07e3f5b03a0828b7ab6c18a7b12a10ea7738cee9531f01fe1d1a8a2e99af6f86ecc741ea2cadee3df038fef143884df407751043247e5f507df1702121ba98290f22b1fe385ad448fe756d8013e553dd8c253c895f226ef47f2041d5f31a53ded9acb7d8e25c0b01c2b5fb2e65dd5d73af5450b828a46ed3e69d32cfd41ff507c86867f7ee04e66249825937808ccdaaadc0979dfb98825b566dc149507329ca95018dc0c029755787050fcc5493de96ba797c7075db586c9e370537a4aaafe8abfd4b41c24d0fca606fb856dd554c5e823cf037459b89b9126d599a45ddfafcaf08f929d1fca1073969088c0ae3588b70a3f290f6afd151a823219753af12b4d08f2c3272d33e57f4ed35848058a65b79acef95103ed64be00eee9382240ec02bde842c4312b4c9af31f97a0d1f5e6f20acf356f3c4137f7634c6a7dcb630b1110316b6ff70f64398fcb00ce0b1c2eae6a42d71d29dcb8e522ab163dbe6f8a9d22ba6f884f238326f9ea70ebe2a9bf1d5c68674ca6ad2df1650eb786c9ed961383df245d53d8f07eba3e83c5dbd2aae6d647e843af6643e77e83f9ec4b9a09b9ce078830123f5df30e58d3c8669e8836fdeebc0d72e657adc27a8638a797ea6a5fad00725b653a18b2f7cd1e00da3ce323e9efaa47a5160053703f6b8b9640b3caf84b2eea067ef8c09263b3f1d262e7fafc209268104e819d0b418b0ab777e77012324e59ac3e03129fd3f2f8226277fed4a5479db722fac3cb947ca86738519cb7f98409de4218b2d019818b4949921852df9de1b6cf54b89fb51d1b0e356940652f0ce0464d605564a602f83cb926375bcd75f723815a6fb044180e4992d47978e2caff50d97bd59a4b04cb9905b7425de1a4646607cc4f92f0e4aae797b22ee915c2acfd1b271f5eefee4ed1cbf0ca3a6c9c93a0540850ea8534dd741cf71a550f402b933fd3d25bf5f6c58ac04596f5e45125e423957154e014636579a1c53743a817cb4a61b98eabf135ced8547e670bd3135826f08761155f01550c5edc0c58a2887569fcdd530bea2e18df186cad11341ace3840086778b38a28f1a42b3b7fb62e1d948cfc9d29e133360b225eac20cc2a6f3139932a30d686e4fc1c565748de9f5083033fad27d49a4580d2ec192f6faa93c5f15d2dd900049185781b9b170bff8c1c777afc5bcd5f03c730966e1fbba10a249086291f73a81846cfa3849e191e7aff1a597fed9a8937c87da26ec5eed02f77342044dce7d633f099f8c21f8ccdc31ab4cdbe732bca7b817182f9baab5bf99dd206543514fef9a7199e2710cd104197ab018add1b1fe01f4d7ca74a04c885d874f3c3809903ee3317fa55b60f0dc83f56e9ea5a85233d217908a32c577c7ed44fd3586907412d798ac9d8f6639110aa6006cab99a36153a935de499c268308f1df44a909d17ed5e11677b845d85b68428504f6d520bf90012d46b0d74f5f27d1aee8bb27f4361563f3cdecd91a5b31e73c5ec5f6b105674f0f02cad709923d14bf49d190f973d4ae26d6761ad9a0bea14e6682a957c13434972cefae841d470e6fe8a6c8ff69c14aa63022c601ca74a39191700d25a69c3a08fd6db23d462f964adb432a3855fdbbfaed40caf38b1b540f91f0703104368f4cc6178618d255c3ed7159a7cd9ba1586adf33b627d5363e82909fd9fdc1e0e18c41599e2dc98e470ee1ba68620c4e608f7e47784651f192d95afde207b4c5ab2ec9e505b54b3fa8ae2d6756d39bcd0efc578609de4d3f97840b6e52fad73afec988af927fc8a78d42f157d916a217247bf0b5a86c0faeb55d955df8a832253316bac1d820a621604f82fa5ca2ddd7ecb440f3114eff438d6aa6c9b3727d6a8dd59db4d515d38420dba5cc7e11dd22aae2deef68895824035b868ae372eaca9b36cea88c14a81fd82b839357dd119c94c3b98598624e45de0edd0e20b18f96f27ac909648df7162a1893551f408624ff5b2a3fae5f9149e1f1048d65819d0fafb552a8781143dbfa1b721339d1c8681c8fcc8c9f95c622ba2c0aeb216cb02dbf071cac5e97846f891f88829e2108cb63dab6c6069bd0837df2d70b4cd00a24248436a70b19f0d429d5e97323f78b8c149dd846ec79c99e538e6b1ea9c019c8acf7e6d43184ea7fdccff681878401e931b1e0f94d3d7d7325b7ecf9368fa548373e52ac18ad833b21be77463d5ed53f04e46cf331b1857e9402513017931d366fcd839950d5345a4ca12ae4334ad40be1b94578d448f480384a4f1345eac4521f2d891b2e98805342052df8d995c557de80fe51efb81f19f6c09302e23235a834fe2f1fc15ed156edf57eda1ec99609836f158bc9db9be4769289e9ad8127e5e27a578b7d10795a1a27453c1257fea3375f07e9370ddd733a5033d958c6ab62816403d021c37e0d3c9bc577330fdebd9f9119e5593a2295035cb322a8cd1bb32e6ccb2868a94dc37f0fc59378b0607ee03f6b5da08072054e9d82a440ba24d0a3ff95f9425a22060d9aa5dbfb3834b691c1a2e224d70ae619422f5bdf0873a79c3e3da5b2d8ff6dd5e36ed03902aa26b3357d7e08b902037f3eb6ae95c6975d56083eb62c55339a819a877eb6c49c519777509fa95465c762c04d5cd154836c5c0d619b5b135fdf6aed4e7d78983aa5174c8025497c1fa7fef495d28d09328342c7fd7260b45227622463fe5699ef71219905c6768017b881fdc056e93a5fb1c0f9e97876358cb43dcebd66fc61f6a7e63fc73f20846c7a9cbab1ad26b102fb48012491b665428561b6de640f009893ba1ee4e59f3c2c891df1aba8f4a54563868169269c7bcfe835edd85d4870a3f6281f5398bad6564b4c352474e41d6b5aecaea08e674b471abff17968f3ecd5bb98f83964b6f0790c99170e1c3e6873ee477f1abb86f7ab25dce74471304ae3cdca9e836e751a3503f7f9f471030eefdc7aa46f7c248f6d5193d3bb4ac932f8adaedc1717b78f0cb68857d9d357fe2cfbea62f437be1ed18512bd836e52f125637cc7f3e9501a900feaf8203f3e0ec28a2a2d81478518d8fabb8340ce63eaf4e56d7458d20ae0933f1486c9fa9fe52ff064617aea3557874e6b6f9187783b62aefb05a171ede757b3e57f5aeb3fbbdda601f2d66fae1ffe71be48099d8041fb745b263645179e23a661a38915cc18a9c098061140361e4778f10c1ea0219da1195966a3e7d7c7642f210693becf39892f34173fd932946289b420a2b90bdb92c8450d8664352c039b937ea1c6541ec26ab03818f24f31ff5eb552dc5e3f581335ae2050973d8ed977f861802867013f019e9475df9c4f931bd5f76cfbaa31043bb1c7e83accc6cb354f3220bdf83f070a31cc00647fc9f63c016d5eb0088bac8cc181d11dfd93e37f22e532bd84409306a1e496337b35239e19b3fe4ae883adcf626cf2d9be7528660fa9d54ef9fc44bba870bdf308641910526c31514c9fc92dea03ae451bc74abce91ef5258f2c3be12b5396dfb5fb688f2d06a220d7dcb02ed626f4dcab83cc2987fb8829fd18452e2f5e0b5de8866b2d30ad3c16d93942bc0cc0a27a169c8ac186aad760599fb83796f249088f3a75185205b5d28972171166d0825dcd6c4643ed6217a94c7ef94f7d0737c95a829f9de751f799e6be55c70aeaba478c80d0c66e2712e82d7bcb06a8df30416cb9e3f724d7590cf80f2c1a829159bd23f508860796a513b3cd7d7774799b93dcb4b64d4d6c174048dff605e69fc3fc646be8d204369e4de52f02287e51a3fe42c134253676b995e15d5ea9a7e9f26b9d068a285a501316a2736b71c852547b9b4ad195c24d7a1bba16186deb8cbbc76c14b201057d72c887e027500dbde64be35f2029c559389fb7175cca676aa0771ff11c4d8d088960ed94110d4c85cdfa22a08b33c4ef95577336a0d90ef21b6ab057e7df2a86deb29252a857960b8210dd7f3a196a87b3950203c14a61beda4e98c01642cc9bc3d547fa851f4bf5df82702532732a5851fe9b832e61e38ccd5b18c0171d23e13b5a0f5c6d72108262470ff4f2814b95bedc885505704dfce7fb0d0bb045fd9177d2100695289dfd1ad505ec241f47afce77a371667ce479734d8b995bc419fb3f91a88f3a0d91a09f28395c82f525927693552c8dd4757bf0757f5a9fe323913e809747cb2591dcf1dd51c3a9edccde0761a1d630c4640669487bad9e0971c10d279b639a22c7070cee48a249152e21ab27102ed53e706549f3080fd3f22f889585234a5e7dde4ab07cafd9a11c52bd1fda1e3889482b967c6053f0f8e7a6c0e2d470bf37efd1f00ddc8e3d7390174e4e88d46b82f7e1bf91d6f6e1cfaf3290e91d307149560921dea9b33c0bba355c4e702e5365114be75deb99fd6ec12f57c2151945f7277db8f7390c5822d8cdf04106fc2168d4949a38b81d4c0fdb63f05a79647cf19e4f6d15621a0be313207ae0280bbe5da72b57f95a71f619dcc7157d0b487d53325f8fbe3fb6b1393bbda5472b466b789e1db0a1fd15a96a306061e562105be06a50aba5cdb0b2b1ebe63652d3c1fb6b98b3bc56a3ada1e1cdd4f8cc01aed2efd1119c1fb9f4b6d8e2ff85ba15e5c345c9319bb6e5afc02be51df777b76c1286169498fe62947e6b5802318e5991c9ebf50fd650b9d06d5666221a696b9b24df6da30fdc255baf56a0514e82710111d3e108327c724cfbf5531f85645586faf8fd3d31e00cdf4381cbab296f0e3921dd7400367e11f359c6a6aeca99e1401e64969955fbad0abcf83e73b47921a2908691cff9d7c4646bfc0fb76271e2c1c2d43f5c26783a6faf1a7fa29ea550386c9045625c5bfec6af697d305a5c8c074d8bf2a81aa807833579d094c77bf3f0fcbee1b171d84b4b793b2ff76e0cc1f99a198cba0ae5a55d895dd7670f56fa394e45d627ddcb378ec4a3379238b419684703bbd60660f200769e37776aeb4ecaf818440e0214af16d3833da882cdef9fc02764f177cfc70cf6d276f16072fc54b8d481ade7421709b3570c9d3d771eba7c6cd708b5844075c5b302248e96d8ec87fb84772582b18807a6b9dc1bea087bb6f5721f1471145c965daf7f22b62205e37baa5c73d324736bd84afbd9aede5242daa95562eeb5b466167c0d235d0d13a36109a0da50cfcc63e225e5a23205a4fae5f17400aa1cfd930ac8c4ca74b4657c3fe14f55a3fb5f068e65d1e9d030efef7cb2fba5ba1dcff3337ea26a386b25a924efa41150bb04224d0ada06fcef46929994bc8b16c088b0f2735ea02d9b92664e72c33584a1e1e902bb889bae509b371865241dc82f46fb231b68997982bea59fcb725362b4ff3628a22584ed8a6806548763b07d3dda20d3d805074dbad06dcc440b75bf0d9d43eba70db24674a76b3d7b83872b97510e328737b096228880093722e9d9dab12592805c90e3e6563c8b4377778f01f34d7fb5d09ffa6c7dada443825eadcc87abb6d1c3d8e47cedb6a314ca508427326da49e11f219793bc4c3f64ddf17d6fd0c4ef86887738f41732e048f754a4a61d445c4b0fae5e09ed71579ed602f6608fd2a8dd6160b327a716f14a7c7002c358386f11831b25f75be18802c62efc0d1e4ccc1d27ff05d398a9c4bbff0bd185afc2fd3d8fc851bd02e05503e3c22f5ce968e000df1eea329402aa73287876f4b86f20d7917aafa4871b0461a52e0f263dadb6452bf4c4e6b522bf713e909cb7a5bac04ec1db2812defb6ae262008630fda8f3504923abe03f2a44f18ff48bfa9e46d87ae31e777ae1efbf6280ac54be76b2d7f7b9803ac7c66a8cb31d69d7ee134516d47b2ec2b3a92dbdebbfd35b242e6a72a2cb2a70de94ffb866c747660","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
