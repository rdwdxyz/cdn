<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f582d81ca7b4501937209318f8f4cae2cc0e732bb62b17672177e88c26bcc837d3687d1a3dd234c999eeca26ee887b76a06eb589978dccc397e6d4e17be55955507524c3c524b9a607808ab5ee12165f81cbe38e3b1b5ba060d17b0c121b004a3ab6cfb9522a579019839862271766931ca417189b1266b58237479b9f06dece8d7912b44e142cbf05ebf427cada32b060a3293c8f1f92b7cecc28229a52a7a6fca6227ee7d4f975f6f095a7a3452c8b05e8b8f3923382fac3689dcbc0318ad9c5da5a7b97275addec015d282f8e61a3b5c1034849c98330764fcff7c1a57aaae1b1f1597d0177b0b30a33a075ae1db27672ea6c1d379f56673ba4cb2c13347adf0ca7d69f2c017e4533503d4dec75a707b41d9f19690e3ae207653a1d2ed1833ffaf2c3749abf254b23d255c17e38867ae9b8afa2aa0d772372ad27451938c5dbfa652b30cff01e5508b4f03944059e23c19910203b753b316e963027828aa9eb241d3f3d7e8871f8e72a694d95611475ab6c94b52d7c48d07bad9ea8ed8a607edd5919c6d26b9e90ffd2c40ca9499ccfc07e8858a1eef23c35b7d6254aaa05a3e69d3f72a7fe2e1b65dea1bae0d55ba57312b0d90359d5a47be0dc790a5aaf41ad9c493c2ce94958519cd3aaadd80529e00b1b26d0be1b450de085b976288c1718a2b8227d881efd5b8be1332e531f3658edf01ff850c1e5f2500aa45b012c901934ecf9315e0acec83d279dd52f8a6b73d6c73f490302d7632d7093e460b03353ea417b91285cc39f19ef2688e9cb831c20302ad0adedf007569421b1768cbb1e443997a6b89ec640ee20105c4e2121e4a7369f9bea79e43954bc011b823e77c10dbda89eaf5ddf295aa948d4a4ec45b5291abda8bd350541d3f063e5d6ccd6e6dcc7a6d03ce8811009e75cae5a93b73b3e08b86d95f893920faa3cdfe3371d2e3c3a51ea6bdf582dec94b374dfe109ab4c64fb9f89882a270f5c9f4bb37434100239a8eca9f9d26685fdc87d0726040cffa5561d795d7d123f76e272886452b2fea340ed0c0e0d8af8838bbd469b17c1eba9a442d39e1a815595092daa45f1d037e930b910dccc6a720c9e79d05403f4c1551ed879043172b181ce7e7b9da58f7fd0558a1509d22fe3866c5b90bfac03a3a58866656cff087c2aaa81fd93c4fc3d762a775ff19e29b05a98ee31c82940a14aad3a43b3b92fc048e2e712862027618d3c816864358b7fb7c55eca06c5f9b7e756a409f06c7b4cc15186718a2950cadbbfe2eaf10cf193c62561fb980b6c915c10f9d0e683b428c05868b06a1c906959436d0d629d109507a6c6f3c334a1f23d7341180cc982ab397cdd3189af6c70091630cfad8dc74d86fd329652b17e91ab7d651728dc4afd7ddac336022eb9fe7c13a876505d3796438f6af2f0d008e252afef86db54c7171b52e10494d0415823ab76017b5cf654d7e7e226ce0cff1f0cbaf96d20e1d916464a95886c25250886b0f8d98f7ccfa48baf030124f00065b4389fc3d8e6a752f3e7570173b0cef17d1f3306db3966b99227c66503bbf8c045990d281f4d64c4c0d4805f06ea038be97597094ccc0a6a5bf4a7c7344abcb61c3bf4a21f2abcc9d893797bd746fabd46589f831bd92e263d4532909d252f9e35c917c56ed70074d01642363ee0e8e4768aaf4121dc2018e00d6606c15e681ce220160a358a550abfe6b798fd2aa61a619a13d637d7fccc32976b7cf9c9a4e266089c3d3446fe74a0861979f33ba8c8c82573d206a87c4681207a20943e133cefb12ce9c307538403896ae445124139e9d7fdc37e14e9259d5a71c670bc362c3890bf689036d0305ea94b4c033423ae5df9e538d875568e15e8b9b8587b5b2a48a5a5918267acfcd2f3e71442206fbdd65a4aae8602f40650b876fc24fdf0bbe0b87ee8056b3ea060e12830b0fd8caff0e6a9bca9707715c9d2b317ba3e6e01b0f24e39e666aa43d302f15c93555fc329d823442405f3baaa160d51db2374b763c5014e075acd51e0a95118370e789d49c830984c54a0884fd29772a207b48eeab7ee9decbba13d85c6704183955ef7666b1cf71b91157b8a8faa396309de5c7acfedb4c22c943be204e59c2b770d7d9196ecc6e598baab63e3e05f06ba6ff913377c74120ae5fee04bd896055302aeea833e10a2e1132ed8d5115dbf4251e6cd3cba04ac65d76bdf8152acfbf90de93cc0c621ce020bcca8d4b7e28c3dce457009e43d86d80cb1ae75c2cce54dee57a52dbafc03b3587e79df9926600bca69727059b60d11560062dcb14360881b7d239aae9ae64766c3bd42c332fe3815e9b9af65f527077bb2c9566d1638155f0484bc41819dbe7e04898237677972543722d26007d8e5df6e697b82349cae2a1a93b731acb1ba0c69601c8610022c45f47ee982e0da6ce8e2f16d711545981acfa149cdad3996cd5086c0e88a953aca97367f1725833297608540ff45a094cf8a73e7500662ae16b51a4dead3ac181b5dd504c5f111874bdcb8c4971f7689fd6dde249a94a7aca847b6d519c428fa8d477c4a62c4411bb8093099abf9a7bf423a9fd22448e4973bdc8ba3ddc7686ef9855d1cea2109196101c76e7e533e457bedcbd57a992055c3a0b750716c462636f95c330b832f79509ddf83c3f87ee09519656f2f516a9a063d82ca60ff16cc263236271e51f2aa91078bc7243e080f2c81965a07ba6ed4c79b9e377eb06b7f6061da8416a11b87fddf49ea9912575c276352d7f640f5fe41b43771881b29be4437cc794ff94bede371a9558f19e2dd9919a0f68c45f5c4191db9cd01a2c54ad194f9a5889ea4ec87e7969e611c55e5d261a3915dd749787ce2f90ff0e92af5479f5e300393fbc389a4adabc9d61c5458857a65d43002c97a8e00a334435618111dcaa841d027a788ac241ee8d74b2fb96b32bff206a3dcd298b5f765426d2c39eef5b960599ae02e372b2e7bd41351be16221fb147170dc1cb43e145db8c4e81fced96feaae69b03d4ba8ed8a6fac31d9a8fb03e97cbae2f297fef4c0f1d77641074ed4b1eda244d4c541dee488ef88a1ad3fcb930ee115c5a56c525941c310f298f0c1764eb363bcf476b7f838c9331324f4c4fb346574d06086e04625ffd8ab258c656c99e4a6561256797ac0282fa25a8f21ad2bb0f85d454275800237b50d5d92ed62aa2d3d1c67b6ca1ad2b7d66de01365e8378365d62259d4136277a90016faaa078557fe70137af8d744964ccbd1f33ea8e5079be5ae03dcdf1a7190b8524b34ea1dc80069987d9907ddf6a348f98f84c41eec6fb80aee9cb47e6f50841b744b7cc208ecdb50b83704c81675a46c2e7c5c925218ce8fded53ce59803e29f970526ee26329b6bc9a2abddacf483798af766db6c96088d2e0c685d8c4b4bc0262d1e270ea9f3e0e6fd5e39e78a31ab4c5b773bf8dcade2e09223e341a2eb7fc619d004469a8725ee963dbe77b199858dfc26d76f1b8c66d19d78eaef6fc51b2c09f3bb48d6238f05322f1b2ee88d9048c1a2a65fda74127ceef1b2ffb96662acbd20fdbe5a79efd6acc0a86aa64b379abac60712fa9a268a36574c95dceacaa75d251efefc5facdf872feb65ba676441ce0a66a6caa1a7dc3f734ed9e7e7de2dd2ff1c89f6aee4d15046390de56425a0e352bb34804e4fec931524da83d0cf6ae5192dc62357c1edd90fcd934c37adb67bf31ba62c17ca1db068ea27d88ebc417ff1b7d3743f57e0864c95c37bb164b17c226098e85bf10fd010ae898ff164fe394737f9d0a81883696168d1d25f454f73100d77df24cde2c7f59dc27f9d8702b46f968a901cbfd9ec9d19580d96121167d91fcf883a946311d0a3825fe5acd488d06d818544f5691ac68b1ec6b9547605da4a2ab796c08a2e45ee68878ff338e53ba8f20da75d868c279077cf29a7045593d6c84216c0ba31491dd75adbcd390a4fdc37d4a1fe6c2f1311eae2ba54171cc0a5aac19b045fb34d1b5e307398dbe792ef33a5b7e6bb7b3b53c267bf6a0c369acc443753d0f967eca08f69b69c2468f2a7a422f52ee2324e6fc99c650674e7fff2e28b1984e90ba20d8c3457be500458a83d7cf2abb20cfc241cb5cdc591681c6b9d395ab23ff6bc40cc3f4c172389c6a646f9107e08f0214ebb22fdfa325ce5cc1aa0e2cd799778aadcc0de4b6a4f22436dbbc67c9d78a815dfd9b575e0fafe79756a9145a1155a09ce1ce8132a0f9f197304bf1135d0623c43e3ff07097f828cc9b4582ffdddadee4f9748794186d26a7f8e6777da9112a5632a04f6cbd15d300456d7e496023072a60a7ffef45bce5f06e87b6f00e940ff3633b9cbd1ee310391f2d8996b01f825f8a8c2f6a7294bf7bbe2ac6452bfa70c1c4631dd31b9e362864cf5f2317bd6165252024c66b5de1326a82289706f0a50f6d6b841e0e5d36362d5ce83b4ca89e982fde1f8b45c20f490b26ade0affc804739837106b28802325adfde154ac7c3c0c27865c84429d2c14f46dcd1e0a4a51e2d7eeecb5774221f98b61b3b14ef1eff824cf8575e4a80c60946e515cb28ac18b24221c874bb0b2fda814d71213082cb264794c49686feb51469b59892e908cf6cb135f2393125b5e9084cb647156a30c7f7f77c9289e5891e578645b05721edc56d796344f5f031da55c5366daee221d56df9e03d75abb33d7075f1750cfd5244a0d264fa8cea95131b02fb0ca4b3dbb1167a67bd3127f436a7beab4a4a40d3bdde4f42f0dbe71c7d253a615bec210725856faebb9365205429327adaef53877645053384f4403409da389fe0d663a89a1cbf9cf2f58a4aec26da3e818a15ae3080afd350059300251cd352f3d92420e842c6aeaa3ea998c52888d3542bd81b17539a853a668936d6f2cea8f4956af5969545857eded04cd4e2c2320975244375d425e80db982ae6459a759317dce5d9a6d690c7f75a2b59fa4e10706d0a9bcce69bfc77aa732f42cf11022d4923eb6a582a102314c9d1ce45c3cb90ac26f01eb88ac661cda772fd78fbd5a9292c44b69d7f5e4bd93699842e7469c60ea6f8b23e0337a47667dc4311dc3780e2c5c3d61a01bc66f94c36844ed24153bf704182d975ed34c20e88319f58dab9841d581ada1bc055db10b254e3ed105e018cce16f303ddd9edb983e8f3ca6837ecf798793023d3090953811e63316ae35d55a12d85ee57cbd054d3717054ff36828e77784c2468439f651213f73b10903b792fd43602a8a30d91c2eb2e0bf0ea0f0adbe9c3c29f52e9f230bd93c17d39abb88b2f0caeda577cb3a52254922692466b9d4bb3e777bd05dd9750ea528dcbd6e166c4c0fbc82c836b800a4ad22b4dd25bda402936e33cbd6f8d7d427a2311c0168ba73b2cee0bc83c7efd358b3705833ae2fbec3f7107137a44b34fe483c8a86c21ba3c97962bb7f5572b2d8e8a186eb0d23c10ac879a8698a2740f7ce7422fd22624acc48ede0fd29c9d90f3486cc8fb659d142123020e5823c5c49243d7a58aee0d9db660cc644b4c5916b3092f9167feea0895799ec2e31f211724b20a89903b83529bc75a08ca2e7158e55a917fc9b6e5883bf67f0935e2e2b86e6f00e6fe71f9b06b674fa7246693504a40680771e06842506277cb7e1f66e9b3252e07df8eb0fc122c4c7777d75e0cd28be5e834a9c7904b85b7bf80824aef3e78b4d394025c6200862ca6bab2537f1483dee87bcaa79697d3d08d826833ac5589e9ebe4f5594fbc545e7096597c8b4486b65f8f0af62c0f63ae8a023e6d9b02ffe4858efe5f298da47d22022a069f3569ed6bf55c1ac1365e38c7d2ca781134329c646e7f36e28a4172a04a3f5c9dff8c0e8bacb0bcfd2232a92d1cff53d22b35236cfecf407ae65f9bbf0449cd2ba1bf3389ec07394d6340c95ae476aa2f49202619711226b65908ab6b650ad34008342a4e3aaca2abf6f84c1ee3eeeba0d48cc9d1dd6eac501b46ac34256d5f48d8d60ca6fff7fb7d41dc33b4597ec4caad950bfba23adfbd9d86acda1f5445e9ece2a58f4b9a0451d2347f42115a48495dfba240d994d00f7a8ff22e484adc4b2dd088d37a91203b1ba5e3e6262e9ab7b45d3e4e23ea1fabfd93a15d626f5d4e63b8ac38ca8fa79ea9fcf1c95f7f0765121de0b6236cddbe189ad487e38a2a09a00074b2427b15313ef0d7ff61a80871125e5aa1b6b17b5db39467edeb1b998130a364e2e332913b94b854eda2d4605b93cf515004387f3c7d77c6e0c1c0485efd1424e73a422c486b240cd59fb7341750f44e25e4ffa1958e33cff5f358af3c4a309d87c5088a2d32e591380e3c3890a95e820debd78d1f56b4397c67d10a82a771414db5303373624c89069cecf02814407c4df7497f6992e327e1be23f2635adff8d52aa710607e166a9f14feec0e5b34040015caa1eb075b993302fd8112ad797b5a49611d3c574cf39a7cba5d244a117978845f0d3f65a842f07fdbd8f0fe51215c653d49ea1a484736daa34ec33545476af72f58ac8f5152063b8645aea32fbec5d8bb422511052f1f1b77f3416d2be3b2873a54094a5523a997c3dfab5707a17d8e4cdd6dfcd4210548a6b53fecd8cf38005223798778f6ba482614cbc768b991cf6185cd2d4e005947b870c8bc2c7273f3150631b0759fd47bcb63e6715fbd57d0502175dec5fda71141e1404b3362052b5970ceab2a5fc2517b95f3538b4c8ee4abc218d75c1d1517267592bffed6203a4e92ca6914ce7c5eee18a81c07afc99e2c8bab0a684c3af77cabd521e686a276445f804d3cda349d09178909e1c3f59abd1719657b6ef96fd2419910ea5612c6de1cc7903b8e93a9f016e622fc7b991110511958b77599cc11ee87bdc02c43e84685dd7e59cf4038b08f455dd80c8cb277dac3668362d5baa81a12ca155d5e4c2a033a61047a3ccc365fb79cae87fc0c249e9c634c20b5ef57cda63d4a1eaea002fc812dce2a317a2c2c0201b190a251a2da758b61d20c9a808c339df6a9567efa6ad3f2cfbaecd0c023f90e02a42cc6058d3f92edda3a7e423227c7ed3169eb5300ba757fe515396300d1e41ba776c566efa511028045804d18bc3cd157bfdef68b99407de122131981518fbf0210a2a4760a9cdced5f3db9d9119d0629e6004265c49cc3e34c2199b51f1bdf4ece27db7b53c350532114fdb696d0159a880e3bed8ee845ca5039e72dfb82927733ffe298ce942ff6c90b10e086f3b8cb468eb7e1d2f74fe18388ef945df362433d80cda4fa8ac0a9fec208c97fda80715ffbf8fdfc6c35778dca070e29f6a0866f8757041ac3fccce0e7924b2df2e0121546e80c3c8e63d8f37677be0a2c659ee2657204a0ba48df0eb4fe32e1a9d8552b9ed892c22faa46844676b72788390a159100cc2fbea73f04bf22e501ea5802aefd80df36fc7dfde8bc9eef296dedfd7094f7135df45e797bad47dca9d9cd11cd29ddf1a4adf8d1cb1b7c9f6ff49d3d176c9216a280b8186fed9b5655a0776d8f35024deaded591ed8c79aea6de121dbffd176f73eb6a7eb7a8b4a0765dd414ea7e02d26a4d80a384f826ba99b731ec93b05f5b8c56937848211e4b02b3c0e0a897d901093f544364c05ca4c75ea688bd58ab383caaa382036894462f9d3beea58c18932e4db25a35533a09546572c779f440f34d9f278b55ca5a2d3b98063b327f6722b38b76959e1d24c15feede15934c559899e57c023dfb4e710fcc7a1f202d706f793b9103b92368b5e5f13a7d9c917a0e18a24f679fa57e3940045ae8d5373481a133bc760e0711eccfd542ae85381dd9222c0f354d492f0e05724b021d6be89345a8f37931a4ac5e4c0b3d56cd58879b863a920b04b9a8bb880b95747c05c0d85050df9cc9e1f7e15b59d67795648b406d24f4c0b5a558c5d013faa7b2ae50a619cc150dd431b67a3ce5918e21edce7fb27ac9f5a8657e3d5dac7d6c3ffd1ed561c4adaa99983fb76336056eb083432379747cdb846e300c9a1da9b7141cf58bb19759f51715abac6244bd7a26c8713b0a1ce14729fe283b769b48c7041bf8f1d29e469ad2f30e74db4e763d01d6b2f923bd7d797bd329c076effe79e16f88a9fb931b937ab6996ccbc795e6b31208ea4f23a3d03e1ecca2545148762c36a131458fd95c4bbdd32dadf285b88dab4c4ef8ca7db2ae5ca105836b4198ea6fd6b8b975dd835918939189893be0a181dbbf0b1244aef5850faff79a7b8ca644a75f45dca783a0292544466d00177eb15ecb13009ecc6595dcbeaad8782be80c9f3fc90a27150b16f5c7ec843ca52b0de1c8582988a4eb72555aaf3b26648716ff753ec77cb15b13b91301dc91ccfddd51d0bd122cfac656799be46c78aa72d08c670a72fc3ec82cbf4e6012cce7a09c2a5051f40ebba74113d73f7002e6d1a941f2ef66770bffe17b63004afa3432f0b08567c90fb8a3c99a6877fadae7cbf034654b119a29637807c0ee32e0e7a88003fc8df1c8e0a8c1e5faca17fbea5244986ce604e268f8112440444e8c6739e043ea8ebf940e8b99e1151d3182d4ab2a489025ded9f3d316e027736aa28d5eb54d1630550fcd86bf708e6c5cfd00989c85a75af86edeff6c2e7cfe3dcc0de9c688b681b70f169190e4d12efa0a310fe4460a70e9b90fdb1329c3786779272ffd253c9dbb92b3b39888247edca6dbb9f0485acc81dd1a11c5053db68960c16c584ad38453730c14c4340b8188211c999906f5c5e6f5be2a93ae37e1f9cfcc75962b7f25a0b2beecfb1c101532e053610c2deccd8448479cd63dc89a6ca39b028bd599b54b96aa3ca927cdbcc092f72b71c7a6405a6ee4ff4a4145961a6ea5086caab421986f3530d12247141280168091b9472c213d90de1519e3d8ce9ad91f93e4fde0ad2e1bbdb6d81888182bc8ed48137c08d05ea2aa564d639463f958636f2cef06f4634c21cda29761e83b5c5fe0067195816e0817ac449409148dcd6b7337a337ca4d2a630fa079942dda95a6f066a79d9b6b0d1076ac58b79e92e22f779e21d50620ac488af93365c251ec481fa80e007b6964bec81a4ffd71ab60c225967734c5df10b4842319dfe952db885cf7025d130b7d260d8e1d74d91045b6c015513f92868bf189ccdd74723d707d85ac83b58f2f5dfc55265d320851947c6014a215272174322200a6d354d0154f86ee7512401bd47370b424a5435139527f2ffa28fe62afe4ea736537950014eefddd0dbc0b8d672ed14d69e92767f97b9f96f706a82211447e5ff8d453ef79cdf8b3720d0d8b61cab2acf40f4dd56cd5667a1a7a66d970baafe7ea5bea387d62df02c39d2f2b68dc4664f1b916a826bfac523743a1afbd38c2ad45339b3881dcc49f6a56cb2da1ad3b4077c1e752ed7f9ee2d1f2372afde28c94af891fbb586214a68fab124ce8b9de3824be22841273952b062527584a8e6b299cd7033cfd9dadbae3d41d5937a973f29483353f56ebd1a3caa94bbad434e3b319ef6ede9c00d0af9ce4463051e496c94fe3593a572bdc17d96fd23785d4b0b064b6f95f26b7ede2c1e474b5d17fb3d74b2815a6fa124aecbba546828d9d2837bb5d32cf04f4b745d166cf22a77a82aa82a83b7fec8065f6f6d1b168a7775fc56cc4b8f287ed8677457f142ba266a1a69496c98e010af18926bd4fcc6dd59ea925b52fa36c0045590e3737ca9fbf100ea6165dcbf9b899343887c0ff264476a03047ac6d36bf0538714167b7905d7a8a9bc68129e78fe88f8af6c24a3d400050f8d4e0d99109a2f2e53413942c837acb70f6df9e0127640978707dd9a9d7e9cd2f3a04010a5a5780d99520049ba47de72148baed1939204c9d18e2d7ed56c294fd8e863ba9b3a48bc30bcca6946fe7c617f6284b4da5998378e95efb440c466fb3effaffd1d9c9105d556c272e6a417aaeb0278c6a2a02107e16fb449344a7c4d3ad1f197c3f184b04b5b13c49f7447107a458b895e1faa4ad2fc5d9c449e02ec2e84c02d3f4422ec4bc66f1eb2d173f031b6a44f52f6de6278f80abd3e9395d2ebbad3d319d7a1faa00cacbd20ff14cede68a31012b4451aceee9f81bb6de173f8474eebe1ef96c439b05379f0fb6ebfd3a24a1ee07ba9895ce2df717bd37fc892f0148bb8683b7fd68fd8f2cb431b42ea98ffc9a30e50c84bb2249ef8e1ec3c0885629a8e742e72aa2580a99c209bb747df28c125870a904bfbc1d374326793bec6c76142856ce21cdcd0e7df258d56b6ea8f2129dba99a6daf1735ae54c71493649ed8c30d2d2abd4708224c9fd477c3b324dbe3de0755fb1bb2308eca939e4fe2ee8ab70a7ebdc66cb556473ba10fad2f9b7e6e77b7fdaac7feb8fa4749dacd4bdbf2adeaf8c4d4f517e3e76f1a98fb10d33de8e5b20634b8acccef919b680c1ce76d6826e7370a9e8ebef07c4b341d951fcaac7531fcbdcdd00f0dce023b91e18cc04a19f4e7901eafcece0fc981cb8f303cb663cf2fdd1323ec188c213e4ccfe08f6a7339ebeec93089b498dc6c210352bbe5e1d6310464ac682c6464026f5d70adee3c0feb8920197cb7497940eeaa106c7a68259e3443d653343f029d0e047240f05d5bec196908efd963f2eb68446a0edfa0558ea2760af9fd4ab7af3368b1102ddbfe4dc38d76c1ff51c53a2cb78371f95a8abef48b6d994cf275d23913fba90fc2e985c89fb54e12db618a34ed56db0bdb3110b0265cc0c5fa0d424e5b53f7aa40cf7f5268b4a8e5f847e056cf2bd41bdbe80f622a0cf1ee1a717e311765764957b63db41fb1ec9086e95947e5e2ff6ee170fb539157c5e4cfaa1767f9637eb29da145b2d2e599de20cdb54cdba8a7ed1d4486c7ef9e57c8c6a0b922b4438573ecda806607e234dc286c37f0c9c5a605b3252ffba4d249ee0290593803106827145b906f03d56dcaebc7843a857472e62006329cad8cd6cd30856ea65325d7a6df9c9990dc6146089aaa12382f3f84e9da730ba977cbc9ce170d091242aff3182a40f32b66cb87325ddad5f60e969df91e2c9ca5a42c479dce3d14e41e8a0827e536b434d8e8703a156fc31a8b5253559412fb951d36ff7e7d5fc60972f9a45684ca72a817f78d38d283b1d21f594defbf03414f89eea329a8c6d66d40cdcce4ce2a6a8c6e83966feaf03de42802bc245e2540c6e839b78d1ceac5ff3fe01988b8d7e8acb4c57441f918c25ac6aeae2e52f22e2beb17a54deac0b2a9b463fbabaa82c1112fb53482416c62313315640843d25e5456cca052d42eb2cfe1c9cb2c29f49f8c16f91549c214001899b0b6b4137b745218716d6fe8ae32ea7f92280fde892cd952239839382bbaf6fd32b379b07aaa4bbe6990f52100db6d0e51df5ddb3dc523c1847d203cb271bb3860e4b48058170c35f17c42e2f8fe5a09a2dd3727be186aa75c865fc6f4d82c88084e38d53dbf29aa023119f6dd22c20d90b58c3f1510186a6b7b5f21ca8bfdb591e1186abdaa3984caa6929b8dcf8579e13c8d9f6ec1a71a0fb713561133e626c4101042ec3c1d267a3c3bf0d5e76e779af5b68cc1194f9edac13b0061c778111fa770d6606fe8dffe1cd34db1646f3dfca36be33c786e772a703798ee5abff735fef4ee48d7070020a60fd1388a6dd2179e4c289d647301a8be5dc69bd9c4f574e74575e3f0c3361fdc4fc6afe7dd5f085e4b5a12d4bd659ac03ad02048147158e0cea9f0c4519ab460930d8c7a8f612cbf96ec73899bff3ee1c11ee2355e7d3f4f7a71f4f42b79d1b24c0a0f41fda6b2727dba7f4afa79692021bdcc5e157a4c6adef1246d3abe9f646b2ef8aca8d32310d2bc2e867c400a2ea30faa5dc3eed28489b9a9f52262ea091b5aa0d6b81841cda23684fde7edf77abf38f9c63c3e9a2580b04453b50439b80d9502c9b3c4fb63db35185fb1de32ad127eea2eebc7f90968c19a6f12cd4f3c26b709140933943ce07189dd3451e88098576dbad8b4e60c146b73d9ff099a6e28797fc64dae3e525b548926b01efbe703dc7a81bf2b0fb1b65c0ce46d4bf40aa7ce415b1dde2762e5b6eae0f96f33f90199b811de6778ef365f68def8c55b0004fdaab27befcce6f22f34f1157033c1a65df8ccae9a62473eb8e8314ef683356f110144b6418eb4e58b4bc22364ccbcd7f3228a735d4c5cc2fe631ac36372cdeb1149302d8776f89aae00c63e3ccec7bc622989eb98c2aa35dad65d2db6436bce5df5c70d91b64d16ae4a0e7070e04669da826b5e91f857e0265ce0247c2365dfb4a1d0b68e845d378a884877829456eb7ee301c446d316bec1b0247b66d614745904118cc50c6fe62dc4108ce29206bfc4769f61e84c126214a2e397dad5397e19e3c0faa873e49e4b17cf4e2e6bab364a2dc2d1bcfa7c764df72d6a992c16a70e5bc697590268eb4bd660892e1fb3afdba3aa6ced693b8f00071a5bfe2ba05f387fff521b0a049f6534a086d16eb48656faf5fb53cfc44c59e3392f92d02bd37f4b73df2fe788ffadc5988b04ebce1460a0c3d5e06347fb85da8b4a3ffeeffaeb827779c07f4e4d5c2da5559e2a21998cb1a552cb4c9e492a6afc31ce3d0187160cf2813da29dea24b27db40622a9bf9f4d572a608eee8b2e90ace6ce7727beded3401da5138ec94a724fcd442d7662473b0844b7dcc513480279218c189f291b7fcc90c00713a2c316c6cf21a4f0eb28286dbc6ca576ead588acfd52ebb85352fa123aa4f731a6cbcfb74022e8983f7de5469e8393c4fbaacdaf182155e2ec51bf3b56048d266a99591dd9e46aa21abd4bbef62c3a27caf091f93b961e2b53d61a6c755026a530196c11a0fcafdfcbd173cc9563562592a4892e977a2b0fb55c89d294878cc37db9fdd6b8b33dd740fcd1b9e899f90ea25291e2490ee2155fa6a7246cdc3cf7799b0b883e42ce7daaa8992d4dbbad230de7dc744d4c5406820aa0a5b98e7614955aa55cbd331e707e49eaeb12bcf4a11e21e5bdfe153542914e58f044502f652e24a60ff54ba1f3ff52a826697cd86f539a81cc42d94372000e69fad15c99c2efca08c4d1df4353a2f219faa50023a88190d70b68f8da7aaa2596c2b6c0fb6021e8179b5ebbfa5dceeba8edbaaeddc3bd48a558090ddc7473c6834af79ff6027ccd82111419b9e8fac6facb233f64b309eb3394e39a21b74071c2df8074fdd8359eae21cf998e30041376af07ba699e272a3ac3f0669ddf2584c91584e1b8bb5181070e1f5cf73339edb9d97a16a641cc6975de688bc3e852c20086679fbc877dc614793f0fa767899bc4909b05ec0c9e69c77b8fef77f9256b270e2996d8d3ed4d933f78a06ab5606fb9e12256e9273c8a764f68c350679a742df457beeede4aedb78c8e09eef0c3ac2801127369b29a03526ae8a35aed84ae665da24df26f6914c9ebb4eaabc0cb2e6eaf94b190565dba04d82a195385cc95dc9342594a407696fc6946ee99e34b12a76e73c89da5bf9e78e42f9fbde5ada1f98cdf31bfe97c6dd604191ac4fc875777ce9ef594130845f5e5ee13954ae5d36553f0c9bfc39eb4977253b809cba119de11e8e1f623c00624e5bed07c30004895259b40d88e6d06b56fe89550f4e94d2b145a2e836e14c51f9a4ae959bc150a54cc822736e936114eda18ddac4c5d8dc0578c8759fa26735c35e43a0e00b3b657e0ccf5ba91f10d9db93442dc285e80379f3ce3d1c9ab4cdf85e0208556e8cc01f46a7dfedf2e0207d28c76b95e40811b681cc88776347e40261f07406b6a59ecd4b5794ba9757e82372f507e472f34075f1baea2859a997355c8ac923d1ce720a30a3df05439f339fd80a2d170d7766a3797d7becb97b5cca35a0370d9b8f01a2728285dddd4bc17376bda66a76aaa9eacc753fda18a2838a553331d774673a32128ff3a7ad4840304b0d760cf60cc266936080346011d4f6077c53725fbc72688bc75ee2650de3e3b86cfb668fa06b5ddad99552921688f01a9edf1d2bc250b01057cea0a418c3b0537166854f3062d3d2d3d8a74e3659847827ee618fd92ecae399a0b5e4452df6695e29bd78832b85a59e29d134678ec74d99b1c8c83b1c68cd417322d91647eec90282f3ac9bb8919a159e4048ec8490f0d433997f06df3eba32a978b491bf02eba4b52c062899044002fbdc7c305a44cc1a5ffb89687535df58c47cdbe6638e9e7d285b0e3a70753938f7afeb2f8738a54f2d84acf164e0e7f80eb12531d26a58c182389470bb1a8d75f41dba1478b73253fdbfd8b314fe379346b1772cb8884aedd3aed84c1f13c9cb5418aa56602ad9ce18b457cb648af614100b78202a7299ef3c971b238a69b88acd047e47d8921934a6899e683e386c4aa12552339e6cebe17876b1f4aa94232923146b578014f820f030ae136a4e89aa98a69825b3202a7049c0c592c7bc7fe8fbf06e28ec82430f012ada5faada87bf0fdc7e5e236b1ff1f38318156c1d2881964ab73d1c4f41c9c70ce90762005b0256664f4836d6ff2ddaff7b0ee99d164abc77406bdce4ca00b3a202126077c4d1ef8bd356bf2aad49ce3fb763c40e85f52a460ed91d6a8bacd6407af18ae24f5cf7e36cf3919c363c921bd24c9d5e8e0fb5965abfbacc88d23a341fc671d27735b911efa714b31d379de1886b1e480b6f2523af3d5d64c3d9ad69f27685bd7e95a18f53703058711a3b6fc2487c9ec14c8a0cf029af72696011043ba7c279b4c269c91cc1c8979d2456f7a55eabfd8d755c2ae7788bc6c36aac7b4175f182f7082eaa1f0cab0416ff4006187da2837fa277e67ced1305c0af22e1d7b0c93970bb10a84b8a5cbc7fcc071ae28ca8e8b74bd4b655bc51dc5dff3c6c9a59e033792b669bfcf3162aa8ded8f1049124904b1ad310d45a9dba45959996a8e88c6effdfe59f90681612ad23447a72aa1ef6363349dd9d0275a12380f9dce6641d30ac1983d586da065b2f0ae51cd26a43e5ddd0dadf08a9ae65dd1cd2368dbdfc8d719447a86ca540f929d83ddde16335ad2b6ae1e85ac92bc9e47d3018f6ce27d334d2ce74ca0a2e357c9109ffdef1f4220fdb19f044c773146aa703a14dbd72208c4af648802541062a8003e3a541e440ebfeddd682f5d316e8d8f8838a42c9220b0616c7afb96a6d58f224c5e8c1a74767953eba9a423bc3458c9624d566c4978a4adcb75a57277e1683eb1524eaef479004ebda93b7dc7e728c6fbdd6a3a082c769c320329f6172d58c21c577d730fc138b60f97fc7fd70e82c047ea5184aa86f56c52321415e79fca91b8916c11bb3610165664e602c0d3e07e510342333c431de05279d9b4f9637326dbc3e925163db5fdd65f7e397fe57c3142d19ef5389e0cb0ca223c16d5151b421600d4e9eabfcd53dbe536bd1148f250e3090a43fb67039548da1b1d1c0a9817d75490d246946933e4d3e54228466de88db2a79ff934f7e897442399807faeae02a1ca109ff5877207257a1f0c71a2b54ac79075716be494c44c7072899838299a11d2b0ee4422d1234eb89474d5f746996830170dee30d34e1ef8aea2bfb8b1a00ae2f3312c82e9e700993598dc319c65c18ef743a3c3de9291d2308d2ec5111bdf29982e07740e53270e25030e76ea41b01df07ae19443ed46f45f5c448a8447953001c5434edadc9e626a0d9bc5ec909a74c59eda5a209e5f933260cd56151159cfd202b6739e4f5f528b37b0b673c6d6f50b8c3b571be3a68308b148f0a7f957e2a62ec6cb45184a520a8376afbd40c8fedc8915c275182e783752dab6f8b73a366c5d9a2f1b924844664c0177a24693b610177e2e8194c9efc4771dd92850fb35097e558d19255d69a5c762dcd1205b043a328d5a35a399c17f781dd84baceb6f9030665392cefb6999da81788408417169830c4e11c854869d817802b546059094cbee9ac7840a871106484cb7d1d37461cbb907188ad6a3b38523af281ddfa0daf83f32ceb63c03c7a868c89ae756df7984a3b1f954decf9fdfaf63cec4763099fd1420bc85b3d0f4f5da37340b53095d7190b3ffea1a3ef52fffcc95295c26b48b6ab82f1093c53364b80ab9a28453d8aee60c36e99e736a433e4a3d4ba0fdb97d3f517bf90b28f4b02eac8ab6a79cdfaad0784a6cadce43eb7de401e98a647b0c0b2d0008ee15c6dc9a4497c7017a8b7a25cb5c8fa22e835f2840f098ab1544951aade4806d2114a86a3e1bbcb3d1c0c2ca009ede07010bf8a61c6362118a10ebfe1529bf0f15c21aa61de7c4557f4c3577a24db1fb29f8f18297747d3243d68a68eca2515854c394bda6525c518bc332ae2479f3a833ed6e48f36892c0bf8bb63de96546b2d5dd1c2bc07da3655b69a8f5f50d35a54c3b802877aa16c0f5dc4048a597c0e7de5bacf7c371c1d6b48531bb8fdf60097c7a1476cfa4e2814fdc1d2308f17610289c502114a7a65053029c6c00e2648ed28652a2a1a8bf34371ca30f548d55aea4c3e445389e057ab01b707a939b7adbd1b3b71ece0a3a008d97cd37922cda0d859260b9eebe2c8da27e4b4a67824c70db5681bffe9b60b3aa8b2b94e1a6946536f03cfe19b56ba8039c53e30962857f1a67560236f75a90f056a716c60894a3309b32e51f7e2af3c34257de1ae6046661532b9a310a4726c1272a153eb44b3bfd1ab04bb8c25d1598c29229876c97814c1ae8980433729574df6cc7d652df6988b54ac58750a6e0c3abf14f4800cbff5976348239615154ee6081bc4ad359f4d116b2dd1b4555800435284800fc9536e6b0bfda0b1a63ba75612d7f1e1b6de50088805835ad7d02331e3c2e92d11963f95531a30452823c122f4627af63d519f50bd856e9f393454e9d1ce579f7b301a90192a68a3a44ada03af4d7af2d8dce1cd8e3eeaf02f4be2b906c05846f25ea9721e5a16dc78ba912a42afa3f7e83d4869ec6fd7fe7ba86fb9dcbf982f2faa4f55e9e6fb9629c99bd637027c4d96ee437033206a89417ddd196b26fda9df8a5509c9b288e5578ddd5064d19513ed98c1f9d1d8563f736c5bff88a2f18525bb2a3aef6f8a9ce6c11cbd463dc780559b2a1c137530f531582deb66c74cefd89664d77c8ce4e8502ab4f3d7899aa2e543ebeeb91e44778d140a70615d147f389737c7139577fc45ee5f08a901644d6ee77142510463e65357711ef58243a4d693456aca6b7a3d97039f0434cd9f2ca6bcf62a3f331d9843302ce8201faaf4aba9c57b17df852781bbf2e6a951488110fc92c4dbc9ba84475b71fd2ae75a6c825388825a07d72091528480b4a4380fa8439da8987f9d645813011c15c6dd2d534a004d5506df103fad7c0f27c102c49c69ad94250d7f2023117effc756cfcd5a0a43cd39abc74453367399ee15109b8c94cce7c222bed4019d8f88d7c6181b659815c16cc9d8b65948412abc2acac6875d9ecc95a25439b105df3a6cf053efddcd543c0f57d23c8157d0eadab933fa4b62a6efc2c7644b85b829229f5a0b4a663507ee96048643de5086761f25adefff980c121e2660f2eb671c8d7b4e67567c38319cf11b4cb5cb2bcaea00d6b2f0847eb7f92258d5f42da2d928d44eded793516caf1d008a158566f813be771d8ffce148dab24a041e87327862ad141dce984562a3146af75e824c748538cad4097ad1c31c336a922899a3b1d93f34c090cc243c8ff9844206884e72e9e43bd211f8fd2ba97c2e929004d87ffda109d4d6c998034773f34f2ad52c7b99525f02b2e6af6e5730d3b1326db4df1066fc041254a3d8535ff29346959814e6731ae52282f444c82bf302b9c6e576c8d249620ef0a9bf4e8f01b0b896f7228e2ab0d994323a179c89ee17596f0bf3ce25315a35fa0f855d013194453afe47916578240498c6318a2f16631366d12f2cba676a804d5985d8585cdc722a2c68137972d0c560a93ff179ca0ebf3c6b008d60850e93f5593d5600aa7d6ceceeb884bf7ec0ab8c3c9d4643af74c3a16739217b79b15d57ae584d7441741c3e59d2af0dca2daa223d26b73f5969c59172b1b4414dae8c6d80ca1692cfc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
