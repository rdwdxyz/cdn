<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8454191298a49ec1bbf1ebf8e7bf4634692153197ceb2c13bf3a077fb5eb3a83df7ea1a3e3c0682a211c15b4fea9cb69ef212d47b2e3075c47c6b1c3aecb93a99597d4498029e4ac7f3c65fdd4cce808965f90c0892a0bd076383c470e86a7e60b4f9e96ea9d33122b8576c25784b78ea4718311c322a43610e5bce546052452ba2243234df934c34f953fa68ef721dc15706b078b097784ebc23f2d3f930608c8f8737792920174a220a4ad327df8110b1018535b94298bbd5858b09331b746238877e632afaa25fab319c6c8d14871015b63304d9fc7e0da3f12b0cf8ba37e4d0887c00617b8705c66a8b5adc5cdfa75982d05583e2d9ea891e790e136e6b45b9d0bc9a685155281a731163df9f6bbbd36af7b091cbc38dea31aa27cc492dff5b4860d39e6bd526bf300a143f2b0d9ef7fa71b20ef936943229115fae083c23580a887cb5f4cc871c1f9660cf8ab221ba7af4f1fea969c4ea71190ec5718fed4217577085fe4609004c823694ccd1d1875f9aa4b222610bb3db86748524b74d464a018bffefb2e597b4f2f2ed9511db06e31255f1c290a34f2e52f7a41262a70f89953b4800402a17507e40ce196b0ee9f0a038aa37ecc3c4a29446ff60f10cc0b91b63f4916d95a1d7404f5898ca44e6a93e428093f39413b11e5c9dce4ebd0c8b79cd5eff81ee46aa48cbc89a0ae3363625b97f7253105aa886153c970ff46c1da5af425fbfd42e9a5397ef26210c45f1bbaf5fc5d956ff8033cc6711d57875af54d216ace9d958b6bbd322528a3858d2c1deb752b784c999c4bf65f0e124f2fc1ac7da8d30c734c370b1322f7c1b98ea8a272c87db40ee400f68488d94552650d09ffb74b0d9749fe55bd613f01e19f7b854093c4e0556869baaf18a735770f65c2a08105d96b1ffe88eace36a0960731e8f1c9eabc62a323980dd9572e267613541086c29b7844409575263a8641bfeea86fd65f76a66ac71dcc17f96345e0dafedbf792efdbabfdb883648e6c19e8cdafb171e083c283bb2048a6862fdce084281e588fcb1c57e4ce2d0e5e341848398e32894214ee2faba0827643b608017c766b9b134a5ee75df06c9f2cc5a6434c8ed936dc2a2a4d79db0a036797129f547f25a99c80dffce6a527bd87cde25a48a694a8dae274ac67bafa2d5c45469fad55c9e4c91b60d70bbf41b737fa7ba90f6f9673b128d1cd1326c50e30422062de712805402cd1019c3cfb2349c576af02e18f7cbf368e780706ea7e9f08ff78803345adf0d1c6fe8756b82735a159c3484922189671c85c7cb6b2f17858eb0796d66feabad37430006720446df7f1facd79ffa073fa0cd07fa44c75857d944e4690c7151f15d45a4042c49120c7631e63707e83c81b119da4e92200f58dca2a8352e1efd8ade10d5716866b97f2f2605ce3903028b10b6f1992f25d61dbc85e3de30f16a8dd750ee00740bd1f4eafd9670ec8df3d2b07fe28a86ff1237b6f0100b52c7b430afb14ef71dd082a45040758133dd692950ee85d3fff7b03a4cd0c4ba88eb935ffaee3487d86ea5e7145ab1b7d26e70ad996c7b7a974e8710cb25cf9fecd94433092834a5fe4302cf0029f129b731ef6b1ee17e332a7a80a978e6d6aa79f222ca40e8982f638c034742b4875ca21ac2ca64a9a1d8b800133a180a711d6016689f449ca30ad84a5ef9c5fe7663ddc9eab6cf763d7fe49aaaeb640d1e7b2538f26db7f3307bad59641c0415e4bf91b8edd080574e85027fd2f338ee10d1d32c2814f07c287113e5dc52d5699f002b6e2e70d5f575089a4fbcdc1674fd9ede24fdd7601d336648ca223da6ecd1251d9179f10928742238dd7abcbe59b6c06391df3bc3681d21d7c82a6835c1df332d2801844455cea4f2e4b4688b169c7870b59b9729977eebbd290920aaa00fb638e565d14a64fdb632e17819c37741e691132c694be668242f677930415aef0f0471f51585fdc50209ab7069800c40140db126f2d77366abf96271d8e1ee8fe2acff945a7451f504fa9e2a5f5491defe644d528b92732feca9443308c504cbccdeec2e07230a16821a0fcf4b175203c748271ab2b36ce03a0e7633e48f8d97e947167483d8c74fd3636ef916f2aef7c96ccfc58e1457079c02b356ab524aa4f18897ecbc4d98f094480ca9e5c13b1694f132c8aa60ff98d8da10116ab905201781001e1feae4edeaa38728c638b2c577d202122bed3cc31fbea8c9d0b86a7a144346cd029c61b239f30dd8b398923076279eeccc47ab1a383d2b1c5d410f266fec8e34106fb758918e7b3e34b75c3367ee786ed4df7e8a48104e5bf3a1b5997a3c0e8b9942f574d271d5585b5a07a450354f1153700bd178d909d5ccf0bdbe7f57119899ef7d5cbdfb9d2bf36eb63cbb865b2e6b9401e0f0e45a224263f973d01b18f2f54c39d3c254eb7f714bc0dac21b0a0ae1414c52126455eef62e307fc233af114ae8b6acad711a421c33287e9ebd49f4d2ac72d98a9dcbc412cbecabe9876f008c611d82c979b0fda7239c382dbfedd3c8b5af821af038e58eada59ba3787b06f717e32616cfb024a4ceafd156f9b05501825b07347a5547779ec93633f949bb265fbc5b5f5505f6668744f43b893a290ee12440571de0849178a1c0f6b87d5758b75cadb234eed27eda844639adb365ad3987e770f60cd43e2e57b15e36371af662bcdcd79b52cea11c051993f8f00847d36a00f2670d0737c55765fef6bd48aace5262f8059a75b51c9127787f6c835d72cb964e9a8ba0248ccea44f74f76736e0d2da4269f485537e6295e152658d46d9ae39d3657abe12db2958e3744f738bbd146f65d57827555e8f7f488ab15c0a0e51eaee1a54076b2656c982658e5d35a1c43951e8c703149942372c6983b22735d9df35c5c67dec8b60c11ea1d9e2cd0da1dc4e87703043d2a674d3cea9b89f68ff9d399fffe73cb81614b534a1137157edb66e6e2b26c2e66db1b4dcba1ac34f3a6bdabe7058378bec9986ce8f16d309f51fe2fadedb20456189627df17803cbf8fc11d6fcefe014e2882bf9fdb9e9a1fb735b491c8b0af276ed39dc122cf3ee35ebe926b752eec71a4a56d79064088e3996070cfb3266ac613ea4c95a5d26c519575178caebc0cf3e7d552991dfe7cef2bb34dcbd3555f14611e4d745e0633c852bf11ad84d28f5956d4de7547c6907cedcf585b96db48de208edbf80cec3209a3910ca74e3363ac434bf0a917d73f2c44203f8393f91341bcb2a46d87d9c71e3cfb71325e1cd2acb0ba6c552c8ec8112b1f826e3136ca11c653963d6a2ebc2dffd74e845cc37568e118b7fca4ad7d12b934d6a56e74560c0a4a42cd129544d8aa5ffd0665b2df2012022ed99f56ab7bf9ab42b650a8493ab2ab899d00f18f9091b49468c1b485797c439681dfd19b172144cdd0ba1b5824e6e1a89da6e3f3a1bda51824bc74a575589f130a4bed6400a32e4b459dab6070042c3788c1bed97145535ff05e8a215610d694831eab0009eb1297f54814e943fef9d558abf9fb9b3fd15587ae698eb3c20537c263f64bb5ada96400be02aa1b3e2d9a852d2fd31ce360f66745d823cca306f7c65eabc7de1bdfb0f3264614a3d0f7d359a9aa77a49ec7b87ceebfc2aa329ed102b7318cd08e93932ac3fc2af95c457ba744628ac3390ebe4c6496992f501a0640d958aaa40a5a5b18bb7f64c9f025396cad19e7629a174bd9c2e5b727efcc417473d309a29bdd4f58e91942759b0cdffdd4a6746d689fa40af9c05854a0b2d20eceffb558357433d4a4b2432c171ce3d2154421354cacfa067f1b53fe6dda4e8c7ab9461e2511972b07b7694d65351d513b245324e1973760dad1201feea9273dddf50275b00f4d1f8d7e14dfd23e75e1a2221511166711da06c7eccc76307724d3f252ee1c569c00558febec368b922ad339173e59cffd070f9edd62dfe3e15edac4d2bba5781463ddb68ef43bb8a59c7704ab70c44046566ce0dd055a51b50f2840b1763b77ed5ec9dc5c3d72f77a4f7bf8125f39fbb4f26e92e1e41f385770208044df339d0f1f6cded9325b8af32999a0dba253a96fa6664050f5d760cf16e902970e2e5b5977cc024871b6c4ae48b8608219d05d0773e69107638e9d1483b109d64ae84ff0dd4ca56310ad8e75cf849de98a468bf90cd6e7ef6ff818a38c78bab3ea7615a6d16a5a74c7926ed747eed491b9fbdc9d86e35038b9ce85cd89df5bcf318f0cc0ac551b29e0f528ca90782ccf5217e7094f37a63796efab8e47d7fac7873e917ad8f7e994eb52fb07d575c4fd3556d056157c3914afc5a6685aa94a6a2466c754cf3f5dad30b2b8987964424985b85557aa64c4bfcd1d231922ba3798fb14b2f38a916bf9a6d4105b4a9d25b59a5ffbbb0dcf3e4c2face7aeb73d163036f5cff24d35a4b1cdbb0f476d9acabf59f98938b1d5b58310b947413a0226d83fbc7c26957d0d545d141fd556a488a31e0e9da2ea990295a186d9ad9346acc4e14c235d925c29902f969b25adf9331353357558ca422e0cd7a47ad15618955902ad95092a7df96f7818fbd99f210cd966460bcfe84a1ad67f5fb6dc231045fd61e4481d487e5f23cb245b60b6f2e46d3f6209e26854fe506e3b529dd44fe106ceb49e75a0403e00a28af22fd85cb9f426f851dce01fa42ca02e6491f6ce6fa05e0db56dd33880b369ec8bd79319793175977c714a73927f56aadac3785dc48f573fef4e9d50d8f3564675c34bfe61478b6c96dec571fc1444f7bf7b4b41b99896e160809584bdea4ecc21567437ef3922214d7d04c392f07eacee66035ef359468e77dab7125546201530e812df9059d45c4efc1dc1f99a44ce37171d417860bf7d06da7b9a8143a708d0d8f53a7394c5f7ed2ab89a232069317608033848e433aa038b5f8a97bfd2384a2e52e9b85c9d4c5f4bba1265e110520d71f47229df72dc4de9a1b7e1e3a993f6d548b5e2dcb7de80a223d6b225cbe719924d85d281a383f5d62de328cc1824e1ef42bb5b84bdf0b1056db3428818c7eba716b5c7ab6a383d20876cffc24236e91b272c304eb53a237c54098579956ab9408afe3ea84b0e55ed1813209249345853b6208dcc8efee295e48a1cf7489194bfab203ff822906e9329dbe90f70054bcd9924bc8da7571af4bd0bdbbd2091c1898b0f0cf61bb2faa1d2444a87f66e731980253e2a59109e4092ffe5a397de10e87de3cc0098f8c3c990079bab15f10cbd68e257ff037bd99e7146f28ea7123dd905834387029ee4326448bc3b98afc41ff22e39dc0f5c3376a17d2748059e70cb1197dea1d56c64a24cdfc402bf44f8620282edef8f527e394ef3220646d50f6b03e38a18f5fa626ebebf610feb5184e7fcaaf5051d7ce53d925885c65461d2fa6e9b32adadb9ec91baf412d9914a0613ff90979ad58a4951065c90f1df541a32134ea607ab9531e9d73714084f55cb68d544736beee191b63f7dd8a83d7ed02fc5196d28b4f3e35fe825a54c40e20af530ebc6606173ba90d6073798e05149d4506e64445e618e083464a1356c535940f7b4a56752fc6b5a5b2ba3eedb5cb953bdf218fab93ad04bec7ecafa703d6a4389091cbe0dc6ab4a14c1b69160e900aa5fa8a3691b4e9e2a6261f94371bdb282fc2d222ef7cb9c0dd0c7b5c63cd8f93b30fa61bfa600fb36f92ebeba326911155bf7bc38871e4eb746073b991f14fc525f39a4ef2f202053f90959c950f17aee6812f0fd79ea9d17164251223559fb306de4bdd76b1c238e5aef2faf82ae272e1173f276fde01c077216ebd34ad5c278c7e2c8751f5da30ea6547152f47f33143bc1291a4a11c7beb2ba5345953b3e0e93b516081263e6ce92162473d64193165fb70849310a61ae6742caeb95789cb4c6a2c233a9f27e119334e8c3c84ae9e4a435624b360648e06b04b824fe1f1b2d8fd8955c241f5e1cb54d698551ac35a971cf75ce81c4935f2cddfe8ab03e2ce5a18b716c0e33106069d0133f4f57febec20b682c1430ba790299c3637ea86b1bc37924892108e80c182c9cb5fe51ad818194fb4af0e777f05f55c7466a727e055a77f1171cb850e485c3527feeb0d012faa7fc2630a9b3ea8187aaa2650f8a99743e8d6201230b228a587e14ba1cb1bc59c8fbb0c47f8d2de362a7ae6bd20382916d8f549fc6260c92280ee204280023457a2246a1888ae372d14e0d8aa632dfc2d1b1ea5c6faf74c2cd65cdf40b213403bbfb27a8292b24aee5811953b8a1dad8042878a76bde6a4d652f6e530b0fa4dea4a4c8a046b1f6bc49af5f28fe93e4f540b5743bd7a8fb8d52d3fb666fa1c5ebbed56d2e8f8c42b0cbd792cb070b1762a33130185212b9507fc639ad0572c1756f0607b80303b4b65393d77ba2a9e3e545de81f900752582df0aa54ab66370b7f8a94e2561513e0426ebc5ee890e8123f7bc72c98ed7d2795c2e60cd170941d0a7ada65265b8a2d1a4264830119d6e9ad51c85966a05ec1d517125ce7839399052818cabec15828e3d91578718583cb1db3bc656d74c7b0d262447067799b1afb03317fc64040c28108086393ddc0e574385872e015826e859269c049093e56c9ec19825613389db3ecf5d43db6f109df0ab8a82ce2dd35d4e81522e59c6d4a4ad7be2d938bb0240fb53c55cadd6d406bcc30e903222c8a5f6b365d7cbd38f505792ca89c5a85e3c7274fefe44c679d4582cc66125aa2203bc8d677dc926755ba30b9e3fd457b72e3a62c9956448fdc77189899b0fca05bb8f9fd0f5533c75e52903fdba76584323136c7ff9164a2c4bb8593f3800c91a772fc429e1bb6ab6a1ee45d2d8c0548eb9c7ef4d3c540131661449fc50b8b3355b88204c670e8a66525ed7742b01cf7c4a906e0f595e4289921738691df9ca6504af1e6babe4af5859d33294eef49742678b1d5c790c262418bb89c64a6dae8021c303d46aa8648b80a290507bdc116791ba43ebc2ee59b9741f033170b2ea0863e004ff8109e2ccd83fad7e0a0ffbc357aa53803d759d187aa6d697132fc618074223da5afda64fd55d37cbcd8967d12e2dba92e45009c84b74bd4cd4b1e819067c56211ad1e4f6442dc5213e917ae782d0830d03a2e71d84f05272a52551708ff90115836eaa6c0229f46e5c53317d1fa4b9a36b3b974dd03d7e2557d8c3c20940c35a1cff87b67d73c5467e7241bcc81dc842929bfdb201ddcef775a79a7e81c8ae9a38cbd9a979ac4d4429e48dfc1f815a46fc4cd6282a33e0676f4120ccfcb7abdc801e917d8b97bb048215d097d5d0c8931498d3922477f9b3b23d112c64eb1609815b78c260bde78b74fae7bda6ca56d13f7d722e335fae0e9c50b256148f06e64c6638c01ddcd2f2fcbeeb2a6f8008699a99b4dcc523e25a2379c4d9b8862d0acbe5071d5a13941434731183eb02b2ffd147ec6c822df303a3403cd14bf48e8dbc29b503b47ec9fce5225cacc1546de4b053b6e87f640a4e64b7f00cd0d018b799daace7cd975a2af9487325f0f1ffd0482eb09c6218b27d915a59f2dfc763dd8b685ba9fb64eab0eaa3b949a98dadf2940cea3b65ecc494991a92f4214fd49e9d772803a1d6c7e0ea9b245696bedf1118e751e1e428a497f77ad1a014dc5e1a6c035a99bfd002cb5fda721fdb4495f077ff28e5da23ab32c044a6f9d90a9749f2903acf5bb38583175004408a69eb9611c73f93c9faae2982998aff6bd52d944f6efb4b4554d32d9b4a3c35325f9f6e08f8dcb435fb186ce86b68addff770febaaed8ae20e79a9db9b8af1c9ebfa6e9c97d1b7c7ead9ff4131fbff1682a31f9e235d0544babe81202790209e697fa0f658e4b5925953c486956b6d71b5a9d41d44491e18c44d41f2bafeb60aadf4b0ed596fd55cb4b365ceef2393043d7ddc1f863e5d961a76c3fb6dfb8cf7072c2ffcd1635d835b4c97b9b84d9f30cf83ad6c99c2bc0fd726a02c64df81366f5b812331d11f12d3021c4716035d6a3e3ae453dcfcadcb093fbd15614fe077e91253ca4efc19d2d59760dcea31e7029508440c293ae94f5cd2d387889f5b05f5d6766830075852c3ece2f5899d2e125ccb87e705022aab59da1421471edc3182d4d3d17ec2a119232ee42fc227f05188d47354228f5ec2ef187a9592ffa47df0cc601c8692c091275ee7419bd392308856816cf787aa96470edc19d3290b8c19d2a1d1bbb3efccd88113adfc38c663546f448434e83ae4a819207d5fd163d9de193b96b26205c01c2dc3687e6ca471a89651d12b145cd936b64df07b5a27ac745855bb1503bd587e09f3ef43a641c47860190536601209681af3223da80effb64c7a3022c839897997bf763e920f7b11aea3b01213c84b8901ad7f489229547972738e490c7f8ca43f191ee682802c058b4c3f1bbbd7b09833827338d76a68cdf0a7df36ead9250edfd6404e099c109dad5533bc5d7a49989d4bcdd425978761f8e51dd3502744a8e09ad76e3ccaadb8fe6107ee68963034cf345fd55612231e88475afd5d59e5b7a1d4871d56f651c823ecbc9e14426dde07f2862dea13dd615407f688cc35f84d5ca21e6f3dc7fa9fe9fa3337fd82584ebd9d834e673330d2f4348aece4972f67aab107688c432d59854327fffd6b71e16cc4bfaa02c76d73d3662db68e13d2c406319a445235dcb47e3b00ffd5e35ff23d5ade43b52ad554a0c5714c7e5ee80744828fda455a88d2b570d5c7b0898de6a005405141dabc7a0395e323eda8eebd4796caccec6d42e48f2b02f920b96faaa3d005cdbb7550a1d45dd450c61031629c0ea66bbc2ea46bfffba8124f66399f12a5600473c9fff5bbedfb0e61c19c1e3cb69e0cc4d93894c62736824cab96421e408668c54d7a571944d8bbb21d7a973b7de1e854b3e089875878e072c803d96f667ed3f5f936af3313445a7e4a389ac1826a37bec150d9343385f95b18f55b48a7e08db384107868896401fe9fedcfa204422a045a0e1347925bd8d65c528bb59ac39aecfe32559c3b9952a9e8624418e5254e257c379cc8681b08337315a16579a499ac82050c7dcd34220ee3d0ae448ea2f9aab678900c71c69a0dc57b5d15fb6dfd868cd5e9cf825f8590c9db8ebda950b27f77d891c4b591bf690b3c0370759119a691626dd9d5c2fb8259a2367db0946ef2d8e65ae9102e15f0c5c2fc50494ccf0f99e800f9d966dd914948bc66118be476485c68c79a47fc79160212397f90cdb152d9c44f139ae9870287393493a1af0134dd0dbed325624a01837ac027c39753a64d5808a46639bb8e9ba238eb8f529b7346a5ea9c5733e5945335df772986c3f58b7ec1a000c438a193a919765ac50f543d2202d1fa3462f7b7067ffbbc67e881400f44a8e2a0f5c91f74b015d868159274f3a9720f6cf7638474b2c21495bf641d44d60f9e3f142d0394d3ebec17c3469f70aff392ae1722de24bc3b7901455a3d27bad56c2e0eabb66cb17ddbb74857521f1e29b0348e2ccbc255e505b71f085f7906bf668a51d03e04dcabbc70a30900f8f2a434520e68b7b1ccd9852c9272d97f08469284f6125cf9ea566c66c28aad2ebcc7899fa0975ada424c378490beae3cfc9e4cd95d48fa5b8b815aa0a87a99bbf8238d0a75d3692cbf64c1c977da614a5fb0888d5c397c0ac71e8c087dd92ad09854cc42db217c5fdf3184814ac06b9df1f0a63a34dfd891d3e8008842266765c82da298c50a3ce81ef9cf49ed865f4eee42e706587063e546afb73120e221953aaddcc9a5727c53ad83ebd27f3734f4ff64abeee3b321ff88df54f9ed9dea94ba759b8af7f9edce7c7f595af55b59eacdf639f82bdba2ef60013c93112edf76d3405c85058dcadb01e2eaa8a6a35409196d83f67be87c00cdff2e9ece51b4b101013a2fddb49f98014e2006ad757144aaada3f0035addbd04bee4fdd141562c72acf9c38d18d5bd93b32e2389588c89f2365bd8b8855be8f3e1ecdb86cac85da9efd4d000a13bef563652faa1b6551c8e9d8edbc8b3b8f4c1ca27e4f8a6b0de8f3de5b0f2fc48ed9a3c5e14e044b7797a3df831ef9d686d17bd75b0b4ae301f2c8a115367ec35e350b29528cfaefb60cb74aff9ab04b347f1ec93a069737692c7987cf381b2e665ca8599ea8e3c46a007ad7269d5569121215c4c6773663b7bd10eff12168f6fb01b8a58e3705f9cf62420ec25296398e4ead99edcca5a4f42974547b21de6cab2bb8ef2c2a589c850d7c93afce632f552a5d7bbb543801592787d6da9c3d1d601aa56406d81de08bbf83099b53fd8883d9898c045d47c0c2f51cf0760217167aa40b42671ffa52b38a71a9b46bc10fa32e51658671a6db413caed47e730d8febfe682541a4d8faf3ca70d722384e9671e089d384efc320632fc0f744a9dd5fc4faececec16590e177670b813050c498b30fe09b102f2121eb68059907aaf0f5dde40dd49b565c12e24cac2155c789b51249ad96afa8be1247f1a7630283c0c5b9a2804c84b292d01ceb0d698270d3be8531d1124b5a7b7f4a8cdf781f3c843dc49bc5d0713031069f804b4c729a39b014fb18196729624ea3eea204d1e6187a2f2056e9a22b9064dad5dd8516a082f16bba571a94fdf042a4fabd2e85ade2cc39bbee8031cf1c96fbc81828987af1bc088192a7c4851ec30ead9294f50a2d0fe335ce9c74026a46d83a69e5fa6beb425a9953d4e622b5a9cf2f7f2be498d708969775932f58e17b2993b98ce3deae7f2be4692639baeb12d86df3a518524ee88a8b5010289a63773f4a7cb0cf2f7a9eb063c05cd39e738bcfff4e70bf2ee7dbed027e847bdf2bb36ab1f6f4198f527a9c02bfe4ad3d31c3daa4ead2828e11fad6301c910247f85aa08a2b5a87c7f42b27d5e159959e0e5e498a7225361090f12d24bb78efde1b33162bb0d9af60855b4270f45d8b86f421f32aa9c5d8917f19fb73e4c3776399b1e34046d2a3b4eee8b95837dbb1ce4390533756eb566a6993baff488717c636966251c76d86b200973ed02b3b21728405ee6d04dd73301078a30617d5c66eb35b88e08ffcdb8ffabd73d3274d3cc3573b9443ed49433ab6eb760162ba272affab34cb9a80cb56f2710ead0c1cc83959af777c7f1a2a3a60b59ecb86f37afbe4a92f9eba14d8d5920c7db774b2b8a25829c719deef570411f7dd2ba11ab3342183f13f90d63d8dd55fd3525b992ed8bf5db860da56b29410d8925034ac8f5478274ccc6a01b4a5310d630f2ca62ca331c4db17278275c434db6a6c373b130cdc1705a4805f78994a9a1a22da9d06f622bbea44e5a3c12e9d52453b8d226538afea38f870ea232628e6dcd75637cdbee510a5981b69b0b26fa154a13e18cd6ec33794159d6d87be780c86b061d375b224014607c6ec3144f6db79207f6688e6d4955ce4c4025108ee29174776f0e2fde618f2104ee3d0ba5032af24a7b9085b4a48090c80fb02a668806cdd2430e8963549b68e59806c0fd651cd85191c74a086a6a823d04298a1b4c24fef664be372c62e808a5faa6546ecfd6d32113395c4758683926787d9335087da58ba79c6afc770d961f2c86d0ad1bf440e263f03c25c7d87f009d30bbb948b9163b09c1aacd0062c87a5b00db43311deb1f862bd5ea25a151f1baebe523c08cd78bd7427b1f1d47883947b0579016f28e1a4e66a84a813bcb805ea97b31ea387c83a9838d7ee858add2ee8283905d5d36dc7f8bf45d87d7f70f8643bd443677d3ffb1ca28c943c5ce423e6968a2d97efe90e768ac9801177869f22a5aab9040a0074ad812631b974e9b1d628b298f07aa97a93620bcc510b81a7256ff81df1d5a55a668942bdb24ab9d0e16984d15df5df2813566fdbf400b3a63f67db588c671c225c132dd9dd71bd6bb32a4879b69a39af65314c187accd4c743a5fb75a49bf5b7ec95bd50f2917ca7ed5edee3fec92b74b5dab0cc5f80e93a58845068083d10f7046ad1d27df9508ab95042e6ef837191789c5a13a5f32b45d09801d3099b5b42bdf92f22a80bcb313208d7462c0f4edf12026fa94f7ef55be58555ed9a8570dd051acaf5b669df570c04844c713c2892e69f46f00d500a26559fd9705974aa76a1ef33109d4c1a4134285d766e29219cf4801e489f68bd40407d42c3db3f7b5f46a20dbb06605f3caa6d30d040359284e138cd89e223f8646ff5eba21c2abf6d9a0feac0a1cdfabc2fedc88398928559084a02cdab76c08a774c7ad819f48296ce118d6bafceab1bf45296e6624c32b187cdabbf3b8e4b42c5a632c1733ca192f2021006ecf23003c0bdaf5e5ed18009055cc1daf9cff5a2f7ba210220b126dd10e257518d74546e39c8194f2843a990ebd1785115fd4ee5063ec34433457dd0931d2094b72d72dc24d1e0839396fb4218777ea7621b40072653d26f6a05e6c14d662be1453895c827b0d2d98504d9bd2556b418ed1add59e759c17c9f8757cbb60335a5f9ded55cf3d94eb7712782275ef9d4e11c97579787789526055e37b7965e6a4be5afe20da76507335c9dd5ab6d514081b2f08c543a491eb0af8c193f2d56f0b51a4eb823d2ad2b5b082fa27d6ec316413a757318618b89cdfed5468a42c00d5a2171092d40dc7e8f0e08e19acb5f7b3da9767f36bfbc584a61ed97a5a8a2ba70a1f6a5ea1d00e11e33bd558803ad8898163fe65c34c6dae0c55ff7b5cd5f165a1fae0a80e06f6dd1e914e8b940c919148fe4b3939272b9d9c2a95bf6a9e61e812ebbd00199df27e8f14ecf15c2ac0e2105f3769a573883920d35d21a46ebe5c570eae752ef3406c542f007c95599a3b00befbbe00af2f3becbe2fd2f752e89c0e5c03fd036aa87ef3abbf6a2560907c98a3f524b091e0b43202daa1991d86310a7a47eb787bb825ee4bc5a1fcd08e46d58cd498ab74e2eee38d9f8fbffc1528c718c3f76f3807d62e27dd600573c862c8fbd10abc3e78417475c8209abe965b5e735334c1c71effd9302978852ed0c9684213a02b23f2152580fae4cc32e7917e789ddf26c200c16ea13ae0aab097d5c4ba3f842bddb586f20fc592e712cd2c82a6c60476585f13164ea698b4928ac7e579a3e178b8e45740e427a606c52c6af6e55a4eb887998dcbfbbbce861e790993d3beceab09e99550739617cabe037fba3ba0dc81136788b8eb727fbc48741d226e563ae9520e49faca362bdc994b8bd7508fa5833afbbd597e456dac6079d7fb09924cdeec030a9101c5d4c4b825f67d17320d4bb169df78880a5f2f8177ca8619dd9473d08ad916ea30502d2811769e083240973b1f4823b6e885905413b6569e88943b0871d07727a31d9171b058263f7c66481e097eb3362ab4eddc2d23db54a2f1d0efd1c0f24f144f83a8f28d146500425000d40ccfa4a4d7160d7f2a78f21d9bce67f5c8293ebb178cf562d158ad67f455c62194432a3e2e3998588a1799f72450389e5c8e5459fbecdc6ba4352e4681efa2079f782a549c062e6263e0b813a6a23796ace0f5150afebcd132a954d5d100449bdee3162646da9c769434f8ba9c44f46baf1afd489e564a983822ff0fc4dc8232d2500349396fbc6eb6c030028c03ff5a21252b30e62ec8614be25166ed0d5ba883fe22b0443249ec189efa4b1db88d0823b7c40a72d7f5652249d0c9eb1d2974caf158e67337122ce5fe04c10812d66b7ec558cc54ac239ac8d1222e9596b685a2242b4dd1dfb199e4b14336cc720d1ee3f0680c79f30d8562b37e31dd1b8ff3b08d2ea310134503e8e182688ea2f80d7166b93aa4f2c08f1a045553fbeb11bf3878a264ff1df7fc2ecbb9701864b3007b5c1b7ddc4a56d3022d247e664dd90e48411ccbf90b355a20dd9182dc45eee71a9c41a6b184ddb5921b06661496de4fe4691b140cb5304e43f12b0de05088bbbdc857e5aa8f1a734ebad050fb526909807a1f9719ddae9a3804d172482f09161e6a30b0d6e9873bf4856244cbd4d53bac1bd96f467e1f035ca207745df6c30aa967d8d6a2335f4d9976b0b9abab06f44f6cc290aac8ee93518a6beecbff2aedc9a921eae4a3d5ec0653a9096bab60c3b940883254fa436d7f9386b83257c600b1282a1f24b177c1ce33451358400cb674bf467d4632e4b505249e6efe2bc94476d183518f30066c5cd3b902f06ebf494065f56a69950f34a3d8128fbc523ce9df56668fec9274234b058f3ed44fd91be96f5507429203063699f345f2ae58e8a0856edd88b6a4499f82cc75c7484fe78949fafa3a59cee82ac766b200776ba05fa08f998e95fb211f8d0947ac760cdbd2a13e3bc46e31a9b45b35853b1c75cfd91868157502d11f6145c9ee2a5cb087d5533d90c0a541b128ca7a8619fb1fb1eb63f58ced16c004dd786d251aaebc66e700a54065326c6bcdfe598cff753bc4cccf330322d16272c161e8814f2ff93dc4c200a41510a06e11c6818c90115ee1f34c62dac192439a096a694e0f5ba08dc4275d5ec6516b3b6931f83ceaf1b72d83af439b0be6e687f6fabb0bc019c51dcdfd805cdea9c040f0d53822f0a7a7ce3474b1fc1f8dca33320e3d5680d0dd9bfbc5e6d5f9b1d69fdaadf3132c43e982e56e5079474f6b9a529501dc3cccedd2a5d675b75d49df0bae31834e0a345e269daf45737c8caa8a2629fb95c75bf950e6122073be5f8295abe8814bfae3a0143c37c05addbde0592ce40b27bf4c4976e618f56bd069c5e6c650fcf3ba49a7c7161f15af7158a616629b0686ea72a9eed77d05d042300ee45ac7774af6ffcb600a1277803c8e4623ce7799a3d0e12ab1fc12044e1539ebbeb61a717f59a11a969b4afbfa08dead618eb1277a3eb1825c51a58d5103e04e1a1eaffee21aed146d01643f5f24fdeef52d71dc18209f0be7e597e3bb999703e16392d0b792311eac3517779e869f6d498f0a108282e3ee9f0340c9dcb5ef760e171f5871ac97422f96e2762db347016c575d207b0bc0165d0d60853880a8daa33f60741b42e662cd49eaf856bf6e319984695c63ab35210314e3a50aafa73c1967f2489df6be5f56623401e37cd49d96e8a0e9b23e8f815a9862c70825443d1f98f343105e23ea17d4a80ce8df1f312dd4d1f3982f0a01393a800b36096cc124e4ce040263951523c78c42d63181dd3e3fe63876d187958e252f52ee64825ab8ab1531aa0a466cdf0a0281177800a9ada4a8488f5461a0eebc4f84dbd97851c679f2dd2aa458138fb4cc8da9d30757ec161be2433ac966e0a4c38cce910f25adae5f175cd2e55e50b43818d9e68e0a38916aeb0004b47f71a2b17311163b7be38857a159f20750ecbea5ddd7e0880dc92a4d3eeaf610e895bb1f9043069f40130be24ee18438697c09f93ebcdad6681aedf97a8d111eaa3803c6bf9297085d3490a59ead2852bae67766a8f993a7b69b3cb6ca3ac6f40b6fc223018e0ee74f2761828628be6ce139caf7c8338d098c786262de8a45968ac20b59f785eee7b8747ccf58d7b84c5c0d09a9a732c0459edeb4aae5e77069635af5d3d56b302fa7fa32e7d4de913cca76852f9eedd09a6f3da264e17b02fb3891f6dc086494ce8fa25b7913e846856c224117976f54b7805c8207fc38455b915900b252a01ff1d94707a634b2ba34a1c7710797e792f64aeafa3651a6d4e7438261ebe56501fa377cc85248e37db214568afff032b107c8817063abd8989a0679e8e4dce4529f8603b310895ba0cad1864056449f6eb61e71a04f71570b2d9ca5264b85e6496205e22c485cb06e5290d4c6fecd14142ceffc5f5a016b5d60092c50e38d72950e940f370d86386c10e276199e78e4173694f57a99533d85a906efef2770efa5c4d82f2eef2fa72856beae151e27fdb15e06359650b27ca86e83d5113c41aa79a9a8a9f576587c8b4221caece250c51ac50dfd6782173efdc27d02db36959544919a22093a6747a71b2606ad870bc060cadf764e17a3f98c4fb5afdbfa32d530506dd7605a1559fc9a9c143b27e6e3dba8acac2ab01992867afa1ab7d6c425cb92e42d177f0ad12c04c1f4033b54f9d04fed333782648f37740cb67cdb6922adf511d29aeefa0fb26ab49a7f5d1d668f64821d22b23a2315be52737f91132dac10587e3e446bab876c81686077cbb4f5bc9927d197a55270c9fe6ed56be3134862411ba390fec92b594ff84db0cb6ab9cd2d9b87ae54bc96b68acc8cb3ce22b92fa6ac39e4764f6401db981d6f67832d176900759d25397ceda48eb77741683a07ae8e97eddefdceb2abcbd1561c65b82dd7c6c666eae5ec77c90be696f304b3295e21d72a3bdf39dce55981013a16a317b606df39ecc7f21a2856e8c200379ff76bcf991c0c298fdbc314bef9ec4a39c429204c97088aaa778a30ba2aac57b9b6cead77a274bc5ad2426d99b55731be4ac845e27d457e891873a63761a485213566732193070786c4d52d21a18efefe79e71262cadcda7bb2e71ee885bceeca26fcbaee1c8d8e5696ec1e263e12cdf0063ecfb85e6f97ae34e91a23f89a64a737dcd31decee974cf0babfa0bf625ad16ac8bc6cc98e18735537324ffab2413f61eb777bc499e0d675ecf3eb12def2ce7977e72186d1066b23abebdc90e0b20f99b9e53a1aa071c6ca8c4086e1b5de43eefa629a943067dc2f9161dc5a3d00d7e3951bad3cc000357cb9166210b6be137284addab7c4a9762b293d0726ab7921a5fa482f50169c2aaf7465f602cc139ce285dc23c0f5aac762de63f9bf0ac7ff33bdd1d80ebfccc08cc069979f1ba0e32a85bf9a031681737c927d2950a1306eba4fd9f63ec8f357d57ca0a3b8d4e834404a111c567df16a492da9c1a51ae6197ac96607ce06c385875424dbdbd3a3f7bc5dd49635338b18c5aa4a10bac3d0c69a5b449474fe9ecbf64ccd8701d9511eaacd7b4cf2ea907263deec8ca4d1261091c4f3d59e7532204e6e3513174fd441bed0b3c0feff3ac73615193c249de7546b11cefdc4a133aaaa2a23e9f6c952b9305090f182c2bd9c921edfffaa3acf72c4ffed386a4588cc3c3d4deb75566d9832ac82f28680ca0de25abd0b48dcaa3457921776a374692ad02cfd105e935a1152b7daa68f800b81e6806e5cc21b2ce9ed9c7089884222c2b3138dd20d3fcf8520cc59e0f6e83645658747de6b7130489b3450616642a385205661da23c40c2f2e0f8ba4cc21c1a5722989428e312fc97884a1c1d533deb3aab90650c25d801a77ac3857360e607ec7d81bdd71ae0062f14a23b32ecaa3221663ece27b72215341345d783f22c3d4227ec17ba7802a71250cfd8faf35b581e76003fe7486fa6b971d557f7f3d56929866a7a060cbb80fd31ac2819c602f858741e2d8d8ce6eecf3d688ed5855973230c2e59160d31c18d20beeb6eb6dc8241ce6c145a7195d29fa394fa5b46424072c07ddb9caa67c3d7bf3013187e3b5e98f6073abad87bb2df4140eac48fe103955d1fac1964bf39023af96e4f058c1346247637eae269b78c4b4c21a246d40576045aae52c226e2b35a8461493e1e84b4bdbbad6d7c1945e4765735988d0b234732fa3df700ca2fdfad2fb2848c390f3d7242ab21cc31a754c7b2b3209d16eb735b67bf4f76fd7aa9c37d1d47027197a04cdab2d4abb4af422ff33572970cbd2413a6bbd4ef1586dfccf8fce9d423912777db40374e857172b0913339721df641dbeae2fafe55f713fdeb7c1e61cb0eab38b8f40068add1a20ea43bd2068138c1562a6439e5cbf393d0ba07438b35c26e95f291165de1629fb3a78577a138bfa987879d0f198b739c269b229813a17ff54715e249161b6fc6667e292dc87de44fb6e87df54c5a9edfb13a18aad9ed88af103054c58e55e98d4fe8018d287fdf3b93aac363ed447defbb3c0eb3568bb7d1c77875e0823fbe8c4e2205f8314e83c8396f06af4fe14b73ac8ac63f3dac7a9d32c6bdb499aad54b94532dad06256cfe6d68b223f3a74a19349bc3448f4af115fb1c1bee381a6f042482629e71e7af40c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
