<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f410fe9a7687caaed4fe9e0cfcfeafc655507cfdb911137de57ac056494b8e5fb96ba6713adc8dddcc232ad5acdca9202021cbb504d7a8cca8fdafa4b28141c79f2a6c4e7b46f705fd01c322ed3618251cfae238a2df58e34a53dc5ae4842c632da4c1492ba2800ef427c7afbdab1b94ca9caf90f573fd9a5c4842942b317e2d02b439c0de8460eb43d0ba4465063af47791f3654660b0bf52cd96285bc784c0d2824f5ecd3ebf383e7401e680863785639cbdfb1133eda24b366a2b8e41b1341f13cabfd795f74a4d56fd8449b5ddde550e65127f731c0e5710c9fa53850e3bc009f4b728d2756a8264c6d16c4026abded8d3c1f6e72601208c1c732f6d2a2546ba5de7c76e751b52a451a2889b598a8a1c8c21bc48a9f1eb4c970b192c26a69d1c8b01959eb387a1a64c4245b72f45e054ea4a5a965c9c1d74d3f9ffe98e2e7e47a6e4ce53d6fbb3ef0ab76e4c693c3dd70d19e496df10f499b14ac95c9df9d25ea93641428911ad5018039a0508b6ddbcfa0aff3ece47abbdc8b2e9561c8a8757527565706ce15a43006e79ded391ddf1fb315ce49f9ba495adf508420839b99a21dca1c995d025b9a9ce6bdfe45bd0bd51eb1095f6e9f20c2a754bfd6047e07bdb1e4435594636d3f9a892d5c3135d68537a599119ac4639a70f2a8bc6b77cb57f7f8b564916b106753712852cdd06b7ef3ffaa22a5c0496aa9fd219feda3c087fef3283dbb49f55cffd86e20de0652a35a5893a9986e46c5bf52ece9504577a7d49f92d5bd7eaf63c38d24089e275a722aa9e56c14c9e059add37a209b9d27f9c610da892cdfed1f2b141a8e532a4d82ed71576ff9ba4d6e1e6e98179d7806134f013ae70523e6600e2e1eeaf74aa3422ecc00494929c4843e78d0c4c4e75247fd02012ce2db33a7128ef86a1745535be13244bf8f032881b68dfb55cd282f64f0922bd6f4ce434abc4f3a41436e6464823baa8c935e076cdabd0b5ca487109f8b30f0026ea7a1461782162da1d72808b22275529d76e7ba36eb1fdf8ab3ba5fe61f75b2d17f66901b4b5d38436336a4c6157957a96ec18f9e72fe6b0cf7c298de25140800b20f6549e69dfcb7f1d28c818e609157b2f5177b9ccdccf63f10a449dbce17e327dd76644ef21a093b529d839418b680f27ec6927729d2b9993eb3c8fa15fa9c69db3d1413fbcb24cf5f102e01e291f4f1a289539ca9516851c0f42b437266e41b7f699010458193e4658039e43c8a9a614e1bb94a40d1da14e80e8a14d55fe9fa0569e4c40773eba8997e80671ff02f2a9860c95cef4435d5bd2f7e517fedb05585c69dc61b1338ca8be8dfa38d4558fbe87217fc2234665f2b5e0a91c65954a1a7633ebe39ee2126b38916b59fa7841d43e333e5c68815d17b1afffe68edd717f2ee8135697ef522f2ccbf7ce7a5554691002a790fe9a61a0f7a35b92fa7a6b6f18c1e644e8f6193df4d7c8f2884c84d6fdb7c6e0756cfb7d482f7d02bed4c76f0f07e9513d3f15aa1d5debbfcc016a1fb65b908ef5a489cae24b3dea6d991ad38995b6a83756eaebcb9349d36cbde61c682f55aa1141c6e369a20e010e30283983f13435c28dc78960b4c7e2be2dc75c712bd038ac72d1294e1e7d0cd054ca968406cc66c5c1b1050f7612da9512845385c1c94b75ed6cef55eefeea8eff3e5f6a6c944f40152a47a5770888e0500ac88e3e72c71e76e52feb7559da1905511027bc6edf468e83a6312d40c67eee29837641fa638bec4460dcc5ac284fa0cd3de1e9be77dc4054ebae03648a9e5f6254659c6e7429dbe96914cdc6ace446adcc7c6d7b4c1434878f2793f429e8d6021faf141822614e657eee67302c8f9653ecfa4f1c9eddb7bcc2a1f524a7fadf4502d864c02140683f1f6d1af9e0a172d03aa521eb50cdc46ad4fd06d2a22d279842b96cde2c6d18e5a045b44f1afa04bc41df17e6cb33ad47ce560f31d7ab0f0909b3a74a609a990ad2e86fb154ca8f200f325dfdc4c68998e67aaecaf080de9358f0b33b6a060dbdcc45777373e5170cddd3835427500e218a62b5c692b291354f80e66a364cf8848e6b9954ad3c94c727c4d876815e80776b5e270f727a730c0bd2377b0190f290ce58a6ffbd8b5866c190a778d015c6e460585d12bcbeb5c94af68840bbf427e7dcca0737aaf6afae31620a25813c4d88c5b1be655ffdb878db1b34f98ec7c2d70c2126627b3e3da1da66c1e8d4e739b7374fd15013694d007c372990bf7f12d8963373a28f2f2e6866c308f4a085a11807735e272ab7d33c230d0dcc649eab9b8ac0e69adb1f104383a63256a632bbfeedcc0f984d0839a5dfb619eef8e0d5172c61cede467293766d68ac6bb5dd5a5e23cd7a3e65aeb807ec073468fa32af67e27aa6b02980a34356be07c7fa2cf7b5a041211f8874af20c511f0cd8743851661e8f767d428e9d8525da82a2ac76292aba82c78de2393114bf98771931b188380f54020a93158e7c0cef21e668f8e2cd0855fef2ab9f4d173737ef6919c81757f8c2575eee57ab0475bb12fdb21f225fa4d6963929759eccfc25934d14fbd25986934530d0767800ba666e243f465e38f3180f1867a067427f1f1bb04084dc6e3b1d9173a8da26466f80d0ca6cca8cb552debaaf088d7e01be947ad2296654c2497fa062707d0f4837d50aa1dc9d673c3e0d167f9b6f057ac27beb119ea38bc18a69dadcd965ca60f4302612a1590bca2feffea93330a65390384cc47b80107d3bcc9f0dff33ccff606324bac0cb81452e4b89506f16bc5f5e4a897af691a1850161eae8f1e85d12dcb7182efdce7d9cacee14a31ae156b0a8f94284cb85523a438a648a64afbcd829d36acced24a38962877babdfa3d6b84fd33dac0ba840266372fcf309ce1d6cd0f4a4f604cda5f4ad6f284d4b13991d149e55929874f37af95e5ad67b2bfdb5b2297f14bfb7e47f25125227f1a355377d50c55ed6bdd26f90ddfe9e9d8c86c084a01a8b0fa44e2d8373cee2712907d8e6e2fd905c107315e6e3386a60de2adc255e198ed7e2770db0c687093e27225067acf440a3a5f7c1581a5ad75daefc8c9df522f66ca69d063d3566c8e989bae7fc85e6d9b5d55ce1db0a5b14ea7945ebf23db5637f798bb982d64bd8a23a240d26a700744238702e6563dcb950e8d70f1e5b13089fd288e409a6ddc2a3e8ea5c9929c8f5a5a4a20b2ee0f50b256afa315aff4c5eb466afb61e6ee361bac4893eb168260dc80917eee0052d8beb2cffc92476b61c9012e89f39752f6cb3f83f8bd494c9b93a609c82a86ce9708ba24cd942c35ed0dc0e050478fd014c26b66520ff3d9b22839b537926b7a28f5fff20ce3a57255446d51ee3fa948f0bf51b3360a70fcca2935689cceeb6cb7f2c4282580b2b2def106ea12b507a4b152c370ce92154ca366b82110e93da53bc682f6cd978301cf8baf35e5170fe782422ee709150c91e10889019e63254e0821ecb5403728a57451cf83b645e783bae055aeb5de8c79b90fdf89f906a81fbec190d1c5af412c38280b7714099be9255ede7e01f0951afce091bf44ec256f2f211db8cc891b3263059c0a8ee24e3c21f83e056baa763d976d584dfe0acb0195394cdc7060823ca6142d9aa51e403c0886ee9cf7d7220319d107e171c8dcf343af061eaef37d1923acc36ab2dbd2fbc8dd4599f7357280125779c7878178d890684506d4f0bcb4cf4e7c60a5461b1577e5af74f756ae0d52dc8bb3d24fcb22e5a9e4ee3f1bd4e74a07d2a022c669fc85714f0c33591ff62a8bb7f10dcb28e81ebf85e2fab29afe5925538338e8e988e0b2c9547f6eb286ceb3085160b34671c08773cbb25ab9eef0b4430834c14b44493446db729975a2b07a3da753b8d90b916c71eec52fe07d5cf6f32633e5e16e433d0f70edee657a97a40621e831559c04e3d9418de7e43e724a1bfb8a376c492ef8c5c67c4dfc8b2bdd9b6ff377b6350067958346adab5b811be1e0f8910dfcce33b646d79b25acaf3b45c269a50179dccb6912713693cfad632641ae4d17952a6c219412900b12d40a3401bf49e4802a6ff9948d20c0a0b4af6ec0e8069b7f7d0b6466b6220430e09ed8921dc502da8734e76f097476cd97d00669ec62b10e9b2be60d8515be028eb6fbb0758a3f87c6c50cd0256811a58e7853dbda2326101c5dbd7fd1332d63f9eb23f3ab4ee92d2eae21d49a1bb976a7418a80dacc74c5a8a1e68f3f2feec17720d7b7525fc60c8d22da245f515fffca962bb6d523a76dbf7790613bec13a22ee20bdaf8a944aa6d0c7a01048dcee115a6a26064758163a2ec26c57b7dc8ad0cecbf4820b9dd0ce42c0909a7d3c2859bb82f715eeb52cc1d6cabe0b04991649ec23401b04b17ea184aa499309a73c27e7910ca6afecc0bb1b98921c00bcf1c6f62c88f46c27d43e8dbf093f728d32bf17d3f603300a6961bfae6afdc8cdcfe4edf14acdef832ce62c9b1a8f54fd705963badd5300c074ff9687d5b027568a26970c5fc882a7e494794749e96e1c4b9f47293a7fa44c682da1c3768a2bc8ed42d358841fb344de2713863565683115415f48137b0a0d15d7e9be56f532063b31e56bbba7b8116c60dcbcccc6701209dd2dc525dfa33f0469941c939cc7606a973f48dd4ea4681bde9785ed6c1a9bedf190403211d8a4a6d2f339c141f1fc0083c6cf3bf7c09a3ddf9703d45472657fc187567f5218933cd4361ae938f49976e1a18fc54cce53494012f9d298da0cb2e8775a40e5186b0d5939ab3ce269565d3cab2806c537abb07615b0ad159ac772030605f229f647ee5e0f63f042c433076069489de7a0208c231a705970bd0387c5a26dc7fd4da9fd325792c3a6fcd65e5811adf225ed61265bc2f549a35f11371927f7e54a8767bce8fa9e526d1c3d1344b74aef219e30a4aaace3b1fa22f796352e3668df7e8f35249c1320b98559ddf9e8d10402cc3e3d37f7174947ec86009ddcc0ec85f39a6c817157bc4b6466e7361236ff3d91d584f5ea6cc62e0afcd0e864bb11c72fe2b41dc0e5b06ca47ddd3353ae1f9afbff98d72ff8fba2969d3685acf056c5f80c264eec0619426678b255d35591ac946309ce6a03e9a364dec0c923661b1fa1de81c49c12cc440a8d76d0b6b97150625cbc2a3b736cd7540880f1f4f6f4a9a1ab7decba8b403e3d0a54289afda6e5d015081e2fe8de51a5ff40e38ad300dd2e15e8df58d41cc909dca9af4094e4696522aa6bc31630556cf65dfb9f164b197fbc2345b57d6335f69e6c2fc973e526097acf28f7cbc0f87136b567b1c9a1506cf57fe3c2f9cf6ea77f56aab02391db161f941bf8643cc1b37e9f350b2d9e185aed3a18139acf9d0f17687d373a6c6d2353c8a0854d4d8e2505268a967d670a51ff2cc8f8c6310d1dd8bb423107590c19bba3885db49cd9e8562ab3fba4b327af376b8be11ae4b686dda8dfce8d247b2b1fd23c326c43a31eee7418bec758611e87adc740584652ae0f46577481eb6f336032781e6fc8a6e143cae75dfb1a57b91a0ae069734bc8851d2c6aee0187ae9b74b8259b740ab076e54b15ebc1a4af876d71057b94b952a41dfe8dcf10e14302b9856808ac1a89b42a9208d32c095209a3fc21a3f2bc8f2defbc8022df7aeb10eb5ecacd82b2e209c99e3b50446672b82bfb4d9ae78e96268fc21bd384e70e477b76b543a1ac7dc1867f84788d29a96cd1e2e86697eb679a72206e65e6ced94aa4ec0797e4f0e2e319eeb319693afb640163ea7401332201a690235e99e4e2a2d2c47a74c3af43ec85345323a19854edb028015b8c125f6063bdb610ff104f2c153f68c3a7a144e34f6d8abfdd0d85b5800abd0ad8e8e21e0f0d10e689d09d9adbc05d867f0691b078f01c4b7797df543cd754d53ea547e309ccd5fe8bfbcc17c20142d9bcd8c2d48d1dea60af5ec769d38505a70c16a88b581c28f0ac3c4079c4d890104b93a27e0afa2071f86f7763cf7616e3ab7640a549a168aa63f61dc5e79202d224b6035d88e82cb6743b4d5c0aed43d3de1c4746fffed9ccaa41602dae738b081f2c4a34149d047eb01818f841459272f604f3d36279360fa9d9a9ba301f6ff0c063856b6bf8de0043ef05e9db7954bfc3735cdd64aac650e590b906fcef98f2acc456db5c4448dac54a5509eb76b9a7d246ae82dfc581640325fc5f100a6be4c200f7213153c02d7c87797c800aeef281ae25ea25d424b7522cadd97011169d869fd140ce1e9a06754e440c1ae61493bec6e756c9b7fbf20813ee49d18d49d8db6e95e8f620dae14823342635c0c0ed15bab015dd181a637a1175b27f460b3257b12826d00f72f4040456b240aa01c18ba40809c0fdd27795aab589cdc0c281e3744b3e2856d1b7a2ce1b4c1cad4d89793f29bdfce911a94a2d8e4b6df8564aa1efe280af0476c822b6580b46b5638694f1d1214a919430616afc836949a71f9b55314c8044493951a26c2c82915389f60f5d0dcdfed2e6ffcfb85ff787fd85c8a6a43d3c80580b835e02786ed1dafdc76910bd56ab9143c8816a449fff8315e978cd36a646aa5682417ff791e3131cd68c70f44f5bad7fbc6142b96fc7705eb7866c877ec84c4ec731db9f05070434262e05f07926f479fc8389daf97abd1a4c7cb9a106537a941428916cdd6215e72b1a40c6f4a8db259acdab75e17dfc147fd5498285e5ba5cf21a46d03bf6871ab0017cb0845b687973f85f2f43d0c11006d80592e3cab3c5badc7c2a47e0ac3e17aa8d65f61ebbfd0dee092ff1a7d52cac5aec9cc8dfa5016433f961ea587e8e008ee13b850ed9a364146178bfed8216c8f58cfc519de0efc281800504e21f57d0cf0ae387cf75bd4c73c981212c9ceae082221c5144f1f9771f2c552c9eef9e5714c6d3b443b95f3f38b2fe62b00f121b521c7ab072dba01bbbd8f071e5d903caf4b0ceac3c227eebea275b9031bca259cfe4daa321857d763502ad42faa25f1c5f09d39cc0f40b701cbcb16d659917dc646c95bf15691624fdb4c0a64ee546526837b0cc78efdc2c76591bc2970b888d565294c9738e6ef2e04a43c4e4d59beec85efaf371c999c612258f9409b95fedbbedc841eb26d424cbe1f7a0ef00028e2be7077cf5e6ac0f44cab51c1aadcd73139c2ded268c676cf23bad58d8688f8384ad8a881b6037628f4094a5082b0475d2803be1cef74356ed092bc1eca6f4df5a9817e4ca83cb954211e5b485cf12b27735d8c28bdcaff54842d5974336ee44b8480bb7d935bfcdbc96281f35e976ab45e7dc38f3bfc544804366e3dcd277f21ceb711bd4df4c00479d5483f078bfbd2882de7ce465f832aced80b11b2cf831adb767033c4e6d97f7755160f7144687eec6f1037151d726fba86fd381971f74194fc1657119de0dc8f465df7a7df0a7d1cd75bb898f48bb7766d345a407d450ef0511b1667dfd52c54e03c28b4d952926538cf2e949cff238336866c9469254fb2ee29044ddd98f38a4cecff88657be3a0ff3c7d36b7865284e54fe43f737396d5b0f4eb2ffd08fbc7fcdac6106d4c63a352622f2ce756d4dc3f9dea9181dcaa7bea83c75962b9f1ad812917674c1a02bf10c995add43703499bd387e0a15f1a5cdd03719653952bdef0ddf2a54d54d0f7d87eb64c90ee0644f4632233e14544f6c54ef98960e15aefce4770456049a40ff113c44e6b753436b61e92f472890105b938cea64297b6dffe730134ceb3bc1389f594486179bae5d4c506a506c4a5300fdd518cc44b2ec3e04ee5afc4d0e73afd97817f5ba4c107c528c7fe0feb958ba92f2d3f3469e961037079527cb39d8f48670b45d5a216658290790dba400d193804d4957a76e00dcbe955d8eb57a5d3a1d2c3bb5b71f6e4bd243fb624262c5ff444e2e5f42322491e673868ab97c98c5d65d90125b357665d9301d9f72e15a0a4a8ccb9b3e2eafe9e5dcd65a05c978f46e4d326dfabb2dffd4fb243c55cf89a1d40e0385610151a8349f421bdd68dc5e0abe16254b05a5f5785fab4e2907cc6c982f0f486d79d49d0c934495b8a19290d20b56db4ce512d15645f44ad2f825857d726dbc9fa0f97282de7020636cb7b944d6457ab7585d85e466e7b02f7deae16fe144610633c8b6f4b2524451d2d4857bf7b1ebbf89312d65b5c700212bc205339bbce2e6157e4cc59f34283dfe12d87f8c5dc94926007cbd73074b7313b93331b98799c8c0eed824f880305d0f1dd596d7718403b88be8b0d34207aa7085f9fdfea0b6c9f43ed48db483e31dbff7fca8322f3fea1eb7a7b1c89a36cf8db218496899912a6bccb85960b64720beb8cf7b817f9cf8a0be004ca3686bf41428ee55b875beb052a9bf95aca5cf09cb2881691972bfd4f0d43197149ec87eb5bfc30d87d47f05df84dc4eacda8e9b2c9559f189a7e66db55d86816eb88d9fbc203bd480f01d2faf56eff45aef46e524b2aac74e100bb6a3355aff9415d04de4d86834c8a80e047f917e5800eadc70b8d6e8a8580e66a1d650c970339d8baef750cd0f530fff5dce8d3a909d2cfba2c0531a2b2658f381d43e978c07f8055bae2d157b3954049fd2427383c8982af1365e029d52ef2b925baedf2c28a9536d1441dd8202c46a2e0880a8207472053390e80f1d7b85f80dcf1c257526ea7615ca395a5d79b21e4951399be87d4f184466b380d808935d26ae8250c69d609d1286c5147a5c01bfbc830c2416cb24b93dd85d0b9e2bce096a3b3d3b26a8f207d47e56bbe5c709f93a98b19e36fae3ced62c10d4b12dcec0c5dfdc5768918d05137c7854e1eefd20eb874072c39de78ea17741feda1722900fbaaab21821572629e4862501fd021b4ef2af1e55c5f0c69d38b5c785ebb77795dcace924690d03cd5665699193d0e8f4fa999e5077a6b4e8601ce6d5418488336ef94d57d41d4ed0aa12173a4824a217b4e8380c6e2134f4023e1f040b11f27662617dcba25b08a031ce1bcf187e4f4df3ca52b0bf06404163bbf0ee626084b2db93708d42aea571de7ea14c3772075dcb91488123f7074ab585c29b81eb7259d0d2eebc30c4b4df2d89d99d1923aca12d00ed7924f57eea815fe934ce0169f770e98b53905baf0b1cd5c8b617a30571690ae67c7a2712e7e7ff5fd6bd26e3afbde13d5a7d4fbca371c0e1b010c01b16c1e625ad903e08515bb742d44cad3408e74521b571f1d2b6d52f21aeea50bf9f96d288da909c28f30b7e1c5ab96427bb3a3b203698c419593977a996fb90ca6a1f025befe1d889cf6e1f7b1ba6e7674243a4de78b71239bb9c12bb28bdaf5a7f92212c4b948a690f109a7b615709a5ba3eb4183804f139f2b92bcb4184df82f5cab044b332656ef5ea732875be041539bb56e127e26da20ffa538e9cd3e8bdf3fd55af99db3d67ebf309aa82d741c48f7c7bc2075839e643c14ae86b035d25a08f01fe323a67420a9a7b0bea2646d6fa4a92edf58a35fcf7e3b4cc7d34195cd61e11e9be79ae8ac62a9d892b3781751a55d20731a600720caa4b5450e67ebede4b0a8d2a12681fd1375bed8d08d4b98c116b35acf2668e248c8f7020fc33f36e082a2f75a940d8d5ea4a3453725f1b71f4303afc5869c87c03d896cdfa0e531dc8955e155e2fb427a9caa410bf196bc145464987c3361c4de24263c60706c82c58377b402fdace41152c1206d73bb58b6fa2af4e3258a0688fc28dc0404d94a1ac3e2df7c30f3c8a0747c50022aa1145a81666de228ae8d1aaa0397ccf4f73fae9f7830bb463cb63cc685e9b07933a023e8673bb5385c07cef17c432b0f976d234a25da1f3f936c8f9df25ee0b6a89e8393ee3a98c0862facd0642fe9fe77b2b6f8051aab3b2d4adf0f2be422950e612d1492015416175f17f2fb1724ecd306907c9bcbbe1e5b77d2f156661b7c0fb6585b9c6dec015929f9f9a051c30166ed8d11880981a263f2b0a98e8ec1edfe852f3d7f93ee9fd94f6cf1559306758e8654679bbc6d5f302a43ae9ab8760bfbd49fb5a0cde65a8b292040f4edc3a0f53dc48cea190ab95ec36709d784d1438f56d1e5799427b5c732fcb9651b9cf6f4fa78e9ee3169973a3bed7d2dd5a1acbfc936e3073b223393ce399b7048e94da202d069d8d0b1bf65707c344ef37c9316941f01ddc4c40d1915cb9d8c6c57957b14a1046ed644a8dbab91f4b4420cbd64bab230d0a91e4e83ae47c29f09aae8323765e1e117aaf89ed0d939d208ff88b15599cfef2f45da3b097143ed326d27befc330d97041c53a793dafc114cfd139efd1188b5f171eadf1e1be67c5b11dccc5b423231708caeb1472859d448398c7dda2f37530bd5bbfa4514af884f37ed479a1926ea114b5bb8429378b588b2493d4ed610ed7b5ad82d90ca28d45d0b9fd57be0308f7e0515c41471a9f36ceee06e5fa7240fbe6bbefd2f4f95866829837f459546766337ed702034dc71b00405cf3034b637c935f7f7dd6057244f8c0ef34d9058f78e5ac6bb17b6c656401f36a5d2fec6250a2ccb7db404861bb340ffad8cad822b6f321d30a1c9de72b8c70ca7ab5ff8eba2a9139e0bb911971a30bddd4986dea5459bb524d0691df0e36d9ebb047a0a079b5aade0b893870b45c4a6be20e50bd4ff32554de2ea5645658a3d75c16914dff0ecbf2b6c12ef31291519602991181e1b997c9d0d2fde8d5ced33d12c4d4b32a9f4206745d6ab924cb77a087ef2345af87979926b383f0ad27e01e6f097b9a4eac9e6a6ed030af9f62faa7f77646f3990519c5106a70ba9dc6a4ccbcccc5046e40cb734dbb8286c931ae1b085fd69b8a69ff0225199ac5611dff9c56c813a5c99db3f08a1057b0fc4acc20f2daead21530ba262f2ea56f9ab102deeb250a07d703eded71d25595e0daac58a486e5be68b6cf5b6c6a22c4739bceadf0db56eb7029f7e467d32a15bdd0322f55e18b76b63a8b1631a2599c0f612c01556f564977ca715fcf3c36fb43046771cdb8f8e494bc6ba8326ee3afee98cbe5f071c2d00762cb495a7cbcbbea921f53c1e3fac6d437bcc89216123e9c9935345cc18853e7a1d181e6f16ad720a83d4a905f4e1fc77b57538bad33b8ca33e27107c43fed15e8c836ebbef2267a2264583939bde46e02dedfddbbdd996bf23a923d0411ad244f7cb3ef464c261ea167ea74fc493776f1ea34ecf004fc3b498f42e1ead7077ba7b22414f2fe364f43bb975116b5a8d35bba277a3bc97bd47703e3df4bce4edd2cea22a239239d2b58258bf4501eb9cb627ae11b65768c141f472e08ac6ed138f43051bbe033efc7eea03cbeead76ef5578cddb4fb1fced392adf45c389ab3e26e23990b50857e572d4862abf1c708cc6697c5ba8cd973b509b419f2cddf1bcdaec5d33c5c9fe43d8c82f46b44c7ab0bc2f428a3d5db72d74481f9b09391cbe46991305b6dbf7cbfc1ea4d998c096aeecec1e1332d2776878719a0e2ff898fb72ee2e8de525599ec5e41415aaf0fcf61896ebcfb9381bfe0cdf1acd0b4dccbbda24b7a6f46206874af6060e5ac33789bd469806ab6ca01d8cd57d6fd7352cf884671ee27a7976c5f59b74595feca71008fc476a31e289c8302558a44b4d5469d6fee737fc2f02e780214f225e0c94c09d7218e8da331317e602b194a58c353fabf2cd569299206217aa3a77f0c0cdc16ad121cff7552ef1ced28285c79769aa1619906d5449807868e73bc4c101eb3d392a752be61987117888e807c47750379707f64eb3cbddb0d7b31a7baa5266a44441a4d938e6d2dba104a88f7193dda1eba1e9d9105bf6fbaef20c08ab69287b94b602c1f021d1add3c3badcc11b1c9d0f0cde44838d7a26bfef7df10c533ea44b4b9b96bd36cc3da17e8a8928d1dc9418390d3e929e0b41b180deb74e155ce106b52e2649e42ac33ac8fddff40e4af457394e8cafab6d5295ed7b1308a71f3bf32db615d4db4c1cf8c28300fe9c207707fc6203d0d662a4070466945b4b6425a5e506fa104a37b76f9b0b1517067e65a7914e3322e46ff4323aa6efb98cc13aae6ffd9167ad27197b066f79570bc7345700122e3958fc3dc0d5912455a70327b541310108564145dd79b95975845bc119392e00336b66165cde2953f4c01ef5a90cca7efa191b3a2a79c3e2860eed975e574418a9afe4cb5bd16611a7317e4fc516af70c4b2f87e23829f1fee0e9ca6084b0ec48fbba0fe09cf5bf27d47a0b3b7a18a6fcd12e79fd53a2ae05035304defb6df9b30572708e5b2de0a1f4b51fc5aa3f5a87eb6323bd5cb17837f49fde7351dac38e191f8adff29ee0d07d6543e639bcf643f023a2add681fff4eafdc98caa4403fac26d4fafe4d31b9a256f68f10090d1b04e5fb449cbe03a32bab85134fc8c5ae0a2bf60d8904ec86530d5f880d3e8af4c27a147f6813e88350176500a0d405dcc069cc95a091c88753f5842441705c260f0d89400c03b9ee78c8e44534388f9b9608d29d5f50adbe54a17e81b364ca0965f1634b51cab785dab2aa04fb16420862486d09d54c35f79b5d6da8ac9fc2f0c81bd901d19a0b5ff512631d4137b97ec6cbddf25ededf3d91e1f3a065960d6cfb9b43a99aacf0ba2ce3d9b47288068f09ef75bb007d0c217fd47982d46303aeef0fa05b496ecc652a1577fbcbbc9c4437363ea9f8175c2c48a2a3703f2787061c27c45f0152cf2bf8aea34926ca8d8113628b103fc0f9bff1b32c7665460b1dbdc27ee155bfd0674558a66f59fa798fe1a3c77bdb98bf9e8b72a9f9fe963829280fe8bd49e1787056351fb45fada2d783fd57558a0ae53d097a46c02c325fd05af7a65f37b8a32f520e1a934ad1d6f9f84685b1d67c333686c4089c66ac04594466dcddcfe247678b2df09e6541873abaca5211112c2b862ca20ebacdacc1df1a26822ce14a89d8beaaf8ea3e9778946f7769657b8bc29c93eb31f73ecae13bae3e2ef57076ba430bf65b748494c7652e56dd71b20574b735d7436cfc08236e988cfb8a903eabb224b06ad0b979aa4251457c037dda69e526fae46385bc2f7301b6cd11c15172b55b22255f7c854d2bc9537bdbd65b3831e64abd027d0df57702793b54c9b2c1fefa39554e187ed603fc7bebeb830f82b166adf3bb1986143eaed28cc9046f9c5b4f9b0c008a0341ce828daf8611e2deb231ff32e84712b97b0e9b721deac6da776eaba3fba4acaa6a7ec1fac987260b657d9ef3cba25c18f9edb5585d2aa942e7e535c609b19cb98680a8896e6b4aba0566dd081b5267fc63cd27f4be76791c2473f1c3bbbfc66b0abd55732a2324b38d95b6609b37ff36e000c6608b9779cba898a6686890881ce026a1a0faeb84b2dac208f43ecf28d46a9961a912db4c4a674401d4554abc97044c62fe2a008d031079feea3c8ee6202412d0f363425b36f8c59970d9894a1043a718e525fdc4c20eafa500f89316708ad4f3b1bc1339c151502f03c95d747006da8948c162d7f9d32de9124d839e1090c01f4d77898843b6e664e3572649b10f967f1375dc9cfecbdcf9b97329139482c1ec4cf59f47372e285a49da928184cd889c14962db98051da51dee7490ca7915a8bcf6859956575117aff6e336a956063cedc123341d401f3622fed74c606a80167e95f0d56deb1b5a97a8e7ac8e8b2a26573628ef22f9fd22ab713582115fcc0dde74e661567f5d6b770ff2d25ee24c64d55abbd1d7105ca441785ed5a898b7b6ca4d47f7a94b51c0be5344db6a0d5ce066ee655f9409bf334da6d9ae39bd59d5d1a96391f4e9abad0285ae933ae261af27da6561932c50cb0651849a7c8d7930520442c12f3675ec3acc8f7cfc493ec76e024e1537f3fc2a97f9901e39883e2974e0a12f8aac6809947206918cbe88af3532b8447aa31ae584dde5b0192dbada3babda50bd2ff4f51eb9ac6ed851b5638fcc35f4b78e70e0f5194a2eac31c98d56a1b15c58ef9aa10e486dcd0d70671b5b5e7903d276429551b6c2fb38de951e45772a50aa744928ecf5f614040f665e077ed211c9e49ca230d57b03772bb722ac6a6602c32d9fa02ea2e7ff0da987712b366e3a39793324bb30615b7ff7352187c5fbbda7e12d2bdb5b3a320c58146119571e41e56306b139467c85ac51565302103d33a382f0c5d5398f648a5514de1384d2fcd0ead91d5ca7538821ca6da0e866eda55711a15348a7873004e5a51710734237884b2b55477052f46f1d6d81580806d4c7ed76ae4e759d58ccbfb029e394ef42f28979e8c5fa934ca16522138c9978b473db8cc7217106c61faf8dc44e422ea1775e85b789c11ca144a4b353125459c30efa12b43b0a2c6605156841a3d204a500ce62557a8bd372a3827ea2e2874fb0e274c28145008c5c25971879d950e1f21a8fd81ee4ebad6fc7b4b96b5bf18bb2c7d11603cec9a0a193a687021a50a5eecd0344694059275fcd67ff2862db0fc43ca59067fcb10dfc67eedc1aeb9074dd4fa366289df50d557f7d9881ca1dd7625ac3fac23ec1ae1387a5e6f4e44a9353b10a0b408ee863b7691b646217fd25142ec0ea7d18b191fda55caf274d7fcb2bf17cf3719212ef2a1b01f8a646009513344a7a53cdd7dd4286401b0943996005d3d65ce4dfc0a7f73438a87ed57c5330a0edf97857c8ddf7e5db0d9954997a39ded1ab5bcd1db2075abb136371edde0fb39c542ea86c1878bb1fc76df07ef790097513e60d3324812557282d7b5d92fdfde1cc07fcd35599dcde830f666bc59d9894b3126793eb2b53b04bc732e2870bbcccbf79d5a29408b7829cf09afeb4a8b31d674eb191914036ba40f73e7001f0848dd59a565e9d2ad9eb29aadd92aad93f909896fcabf5b05bc9c0baa5ebc9db5d629cdf65449f50cff7058cdc20c4fbdbd1e5f667c403e54e743a7f7cc093891b4ce9e2aae5c185d2816fc66f602f947ae911be1d74e744399515546b61bda464ed8123f130afb039042a625cd977aeb71d29b56a1a74ca5dfd2de626927ea4f8823b13022f8b646bcfff29f0c5ca4d5cf8edd61d3664327b2b8acac8d41efa1eda7557183551cd689ace94d30c301f9ccae2740efceaf551760c94573b63f140d0209b0201fadeee809edb6819e0b051b6b17746da1f703fb800aa8ba8b18c332b6372d86674b231d3eb8aae3e4ba3615836331d7ae04d95fcee03aeac712c01525b3a6b73226fea307bcd01f550e0d5c1f5f4afb418129d52f00aafefa74ede7ca82d98640b13f6ef26997cac7914c669794b8103995b9939e769b3e791434d7171b4ab9a43965ab88459aaa98feb858ba07952b6e146c8e43be41f07530900794c3e2a94848d840320859262687e5e2b45c66bab20f18b0ec118896c98225200320d7dbd1a03c98b8cb6365462de76fca8cdce5f2a46b67f0b416662e0f74046cccdf664e67497ecd191891b1b010271d0913964da9d58cb8557f061358df24eb09583f57eaa4df7885712343e46d1cb8c7c27978e82972b3b3f8b7ea3b341aa496c72b6ba4820dfb6b801856da1bf2d9fa426a3f2018e6a5c673d94adf992ee5fc620b2108b307d1a922a4622f0a15a8fa140759745bc2f9b127cf97da2bbed8989ea5a84c4db1d53954ac319d866d4718412bb3418024a04f493a4a65059ecca6899016f2dc5b4c9109a588a1277badba023ca873a932e3165d0ded9f39ed87856828dec62bb3f0ee22d397c92c1c257c5c585defb00ae07aa2183124de6d44f13be643c48b0cebfe4307e60cd0335c6bb1a0b5b75bdd9c8accad3d1cdd0ef00c2ea19d440a8b1b4a470f4b547e72a4509ce6e9ca64f624bc5e991584e5637dbb0b3d38dc118feff16c6a313464517abe0346947fc14f8bc757b2265277455dc3c9af528c5e0262ebd96e1b8306d7a1a03b85a145573df44cefe7a98599908cef731aba3562a04b143608aac222105961998596cb439a1f46455664f436ed89cc98f850f9aee0391b0bd035da77a418b7a13a66cb70adc50b6a205b17562ab2581b9894d4de44c5d8d19d5337f03609cb0a4d362b0bee65fb66ac833f4e0f95f9c6ca6fec94362af38495ffcc04f04f8e53297289f565321e8ab383d2bddb069c73f9e940f959ac7450a05d3ee21e8d7cf5f92fd4a44e538f5c930ee302b9037358466c5f178d59357d040f6da88b110edfff62fa7290884ced397709ff4c16a6a0118a5d479912a35c5fc8f1efe2a9a91aa74c5d6aad6e91c2d4a7ef2fe1d5263b98de11056c05c0f63da898505744bda8fa8019fdf4b261595fc9c6981e0a78194a16447b062a5a89f4593953d2782cad7716795e8d4e3029cc3c2e533e4cb9e8a00a77b223796b78cd9b0862c84a25d23f7588f764a1a63360ffc54763c99373b3fdff652571f97fad16cc693b267ce1a211c0aa10ff32aed1d049892939072607f989c890ef549647301a08951e8251054e4edd999a284808f21eef12c771ed3341447146addcfd6aa01f3229ccd97a2a06e921585c15d5c9a005eeb0db93d9571978a781297306d21bc99fd2598582b0400d9fa1cbb070458c21e9c709eac6fe4fb4f2ec35c9d59c5c03345e95dd6d0205b636ae0b24aecb57fb0cb1a1466ff174058c12dfd4cab96686070d7ed8d568bdbf29ecc70901d6d6e8720b411fa16c4b9c51ac5d3f16b23b1877051575540f6bcc80e3169de00ace1f4a5c5eff0439ca6bf10feba2d61e1be2048bda5a31490ac47bc18be787110ce75039a3f78fe309ecd4eaa281f587f19cb5125101bf48b85a0a54f7eb8df6f6d71f1aaf94aba331a2407e08cecd0e0b38fa919b312d6e76583482c3b32059f077a9245f47e952d102f5f546e9ba3a7472dc2fe2b81c53b829f5510e252c140cd93216b04afcb1ef08f7df066a2c9e7ba4d2bdfb7a96d32dabf7535f68f1989957fd26107cd4fd97c3d41cc4414595cbea5b7aabfafddb0072397b0b12270758fcb7deb0b0090fdf3cfebb75db6253620ae515d6f77ae23579e9182b3600bdd6ccb26061fe7926a53b80256ad133f49345a99788c07419bffeb722c8341f5495c6f6ff5ea0a280b0dd37ae8291766398eacba90a6ab8c63746b2329ed05c869b5da7d5d29f579c7f8ee2fb0350b3c1dd50ab1ae22f22b8ee4f386ddd44e83d040939ec8a906ec21403c073462c9942f8b4b57b91ce1216e9d3db5d7a27f0dd05f28b5deac816a02f89d4f5b381630053201a1c1e58666cbc0d94df6d0326a875a14e6a5fbaf98b37dd1d71110024d6000bc1996ebeac1e90c69a55529ce7be0042967669ed332bf1be6b3cc6da0a436c5732469216e2a9d654c6e6a796e2bd80e69221899950fee404b4fa71f7eb1bca71a1717796fba0d630d8ae61a0902301d8fa64e459130e08f6bca4ba619c0d591e616b7a4f25588f2a5851112475e4f7e938505398686a677969bec4ccfceb39c50f4c4e2abb959e4fb02d786ee06318118b892e2337f33cf1dc5ff84633785b70a862b7840897de75d6078f957192dd2160f284168ef1ea253553cf92aa67213b67ee4889fb5e013502decb263a5df1ba869b39ea6d9030f15b3b5bf1297dfeff3d3a55c9f3e60fbf5b15d4a802a00e93ee5637e8bce2b4289ee2b0b540094521bd05d2797aa3218327946c20cca2540cb62acd72ba4ecac563f38d6a650ba639301182699896a7362978fa6a3a53c4f1ebe3163909599e53475b742d05e4b697a20ea78dffbc29fcba99c9cbb1f8f8abc33e42b5928086f1418e6414f242da83f4747b7ae5990963685b0292c9bed5a3a6c62c9d33ccfcd8952cbc49428b38907dcab8f552d96a55222f74b9eb503b1b727400d54ead3a45576bc85c26ae5a7098df77e35e537a9f13b1b9077265e6f62acb02673ad8415acfd06b2cb90007a68b358a7472287c514b6fe31acd7ee82f25641bc423b9909c5108958959cae7a5a4998677bde8f4c9dee0be67d706e120169ad96725e1650ce3cba0358b21d6328dfeb389b8d5acbbb533b9240e655fdacaa9d487238708f90fc042700dd7ee8bbcdd96afecccd9da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
