<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed79ca200455b25bdc69e102da92c74daf0644a87af74cf33fd97aa789bebb2b1a4b86f230d3a5cb590e0943fdf7efdde59b97fe4b7d53d2d52db13a02c0ea63314e5aec09cffe6a5f5d107c213facbc3ee6ab6a6df2f0bc5fa0ac971c739409a632c807f54c98e81fdc5c9cf62e1195ee05e78def76cf332d9747eb43ffd1151da7e627ffb72cb592773a5692344bb3202372a150ecb7697a654a08eb7d459ea78a0e5c2d5244ba0db6cc70473a96610c9273609f41eea80a4f23364fbe9c4cae040e9d7ae9a046b1b1e9c99dc5dbc7e2daa1273608ab6b29ca9342b98254df93abd5a9b40a213a29c178253250a11afc3805bd2fe0af0162c60c07fd300438d3be041b385c232a534b107dc34addb629be61fac4495da15095d9b5061d5ffeec8fc011aaedf68105a500e747517717ce09792309ac83bb84a05c12cd61c04004ed6c9b6c527b6e7ca19ccbd16a91ab42dc10005a5585e750a77f17e6eb8c8473c3036ab553d1d146e15115909fa36eb9b28b25b663ede627eb7296694b99147c3146dd3f52d643ef152f195a240d3990052575181de64bdb66fbfeabaad3ef66444c58c36f8fe24975a90720a67b070c3d0786c82483b737d74deeb7452d9f7fecb1691fe9845ae2572a3cd11dd138aefe53382483053df9a1b5097cbb082f02a3b8e3b81a5905a5521971a2169ccbb6178496a15f232e8aef90874bca29d1707122198af002c69737a592e81862290b773f35020c56f9be2027564b01431add93ccf283a7f7d6903acf92ceb1883f6916911c757612f3ea4ad1b4a0276f1e45c1175dea116d548d8cf1cc5903765550463ae8f4af560c148ac7978e3cdb712faf236eca2ac4e532845490e8b8e8ee7915938135dd1f1ad2fa1c8618752c6129ad2ab7197ef63c95dc85394b5922bdc30d5100e0f3a21c5cc07b38dca686d27434648a0e2a2cb24fa8b7938c8637c97616950b4b609773489487db7a213d2c6b784c2942dbd148f9cac83893c773b54b2f652ddb740f9364cf950042ff34f6cc88979a710c6b3fa9f483981c3684d5deae76388dbeffcba063a2305d62df5c4fd1b9be64b49687cdc3d10490a1d41981bb5bff58712cc355c5f8e6dfe0b0e9b5b948e8bfe4c87659886de1c6dd53aaf2de64fe6c522c54645945b16cc24d703592bbdd4f39a869886555d1f5cf466d07fce20eccec5079c7624137599ed613bf02297f784ecba179eeb010641b8b68ee5e987fadb1fa50dbc322852423e27cec3011a9909dd41a3c8d766118e4fe885ca396d6839a060ff4efd81df713540349a390956b19567f566de2aca108a78211cb64080f637e83bfe8db86c972a742f4347e3f57d943db551aacbec14030c90e64ba07ed70b4d1894c38c16170c90868bb9672a21ee0c1918d07d94001cbd18cb8ed40b7e70db282fd4f021862ceb64e212f3db5dcb0745714e7b73028c1abf1432be3f04b0c54dac101a9558d18281a37b809e98891f461edba63670718d88dfc35ecc4a86a2be6111aee8845fffb35c2e803cc59505efad273b555fcf21d54a09a2ebea9f44a9fd879d5fc03a675fc5bf1b4abc2eca991587b663517b6418d3be6590419c47a8a91da2154da3d619facac35cc6cc6071f049e83faf3322610af3073785a2aaedb4ecbbc838535fee4451f2e909c2b2908a16f0a8a0d872a8e41e9d794132f3f50548a8f6b8084047d82eba47e4770b7c45a6a92fbbf4d36a07c10b958e42ef6ad32d67b34a33f848e9dff6a1f404dfb1751930c9bdb9c8d41fb7ecb8bc9b49b798610f8846efc6a6c36475dfe3589893d5dd50af3a39e29a53c6ac9172d8dffaf91750185a5e48d0f04d216959a5cf0f81612928055bfd4993e22fa15de277253de0717d04660f05a8158a442c551f782073aa2b218b2f51d1778d27a30f3448f7f003327efa4837ece818d5327acd899bb49a0dbfe8f1487936ff9a105c37b1e2dfb80a7bbd36228df2b34a50c5452ed4fdcf85ca135518b2000d16c4119f63ea62d9fb4bfce2253db302300024742d5d988abdef7b7829caa9cd6678bf0b5088d0f438606c9135207c796b630043b79a33f90c34c46318c21903580b970205e004b544f4865aa8cab7bfc1047c3db78e779ce7dbcb30624a628d9fb8a19b8af8c85db1661521ff4a00bb7ed3f3c4169ac084383b2f37475ce088648ce51a0e921f08f841e977b0d42c6441205ff68e3dd6a48cc69aa38357fe114154ba4fc62bc38ce1cbb0709b80ca7c0fcccdb626a304718922867ba6905100e7f334fcd63e4d13cd4b39fb3da06a5f7f0b6f607e4d1563621e23af8ecadb047b4462465a4bc0bcc263412034ee22d009379b824beae302928f76d0a78ea57e4199464621902a534a23cfb73d8885a289ac77dce64f33589e1e8ec17b55e5d348446a16ef25a57e9039d8208a43f0ebdb9743b0d476e5e06b2ad691aeb1c608237bb97d4ddf849b4995b549522b528088e5cf1060e5ccbb702506cd5144f0bcfabf1a954e2373bd8c8339d1da6d8c001424994cab7aedeee5acdc12ffd1148dd23109a8a334c48688b9645284c44cef1acbb762502ab3c7ea4be4ad9f10e137b73a4e82c357351cd7bb362a37b2fa5cbcc4890b893cdfd7cb771e0b6901e9abe42bfaea2e463141f0204706ffdecde4e7e4f222086effbaf207fa630bc00effb2c5753a8d3564f7bbe0aa4c7582c3c3c4d1f8977f089956a33f7d86cc160ec58952efe2e475c37e2e870f6a9daf364b6f34531c3baf4999e8ab03a7677b35e0a69aa9a7e6f4e2b7d8f536f22edeb855fcd2efdb5d7e4848afa8a2f2c1cca27cede2c02db1501c4abbb205e3afd05b6089addcd7e95014e12ea99e97d94ff852a130d724c2d37f230f3d5487ce5e618db1a9d5d03b7d77393fadc3c7be62f76df05849a3a5870e5dbe7efc301333cd18320e2b49439cd0aefd55c8e81b26ee5423bfcb0a524b8c5dc10d710e034087bb2444755d2b64810ad18b76a1876e7ace3723bf3d9d23069d7d7148f9c81597000cc2e79ed69b770cf0cb9c383597d3d7b7fe8f23c53e8e2fab0adf2518150002560626cab8dedcdd4189a9be2c4ca944b54b086a357aca1bc126b1fb4bf764ad86b7a4649302f9da859ed1101b121388a39d7625bcd43301fdc0817eafe3934189350d0b03f89c2c7ad049f6d1a70734430319d6520bef5707da7ae7c6cb73683719fcf183c5b941b3e67a6d073320fcf9f393e77ddacf87c469e37097f2fc65e202fef1ffdaa52c0e4bbbb1fb48dffb85df80c11b7ac9e66b109ef2b0fde376216e05d4a6a2f975a58f924e54907263daadef1b1082df95c06801965e8ac64009425ae75ee27401eb1144244f5309e65eb7c26a0d0176958be4e5857971679d57009ea1c003dc443f0b472c769d755963f0fe62659a648650975ff4317b7056fa9392d17a01deb4b012aa33156d6817746fcd9b5c9090b5dd1005c4ac01faab51591cdac37cb60eddc7832b5e8db85cba55b0ed822438fdbc82c3dcdfa222c4825f9eb91b37b7995bec11b87126e126293ff4ec3de3699d10ea43cdcbf600cc9e40abfc3eb0bf8adb6d112117218203bb5fddb71b4313baa809c1756773068a92b313ffefdd9fbb54fcd7ed6f7e06449628d39e402170f412c43d85c423c199b815957e9bb28ed79dc705414052e3f1c39d03c6ce5e177c09554ed0f03f99d8c2a3ab111e2075697347246057f13035b4a1ba9b55851786996fd735116d3c8c263ab3504fc394f6d035219d423fc97d645610a4b3c99283cbefd997bb2dd5c2317e4624ef6e024fac11984f83df059c0265d0e697c5ac5b02f653d05366f93527880991f3afb26c9af93dfbe88a880db8d3f49ecb4b9f1b45e9f8010d6151a1f96a1d877f87ce3637e53625ad7f413375024ac7fa01e32cd7916c71284775eec39e456111166a7ec51aa55522a2ec5c1e36c295a53945a5b7ace49e0ad81a71b09c6dea391ef646841e05595809790c4b0dd2e3f57d6569e6b7ec733cbeda4132c9a1683c9df3804f643ffaefe0bfa7ae674ed1ccb53566d6cb365573eed6bcb752713767b0a144917d82de95787be5970d646c5aa35197b246856c1b69e19c5147ce3339665c5019db1b49ed7d6799b1df126d46446eb2cfca3a64101f3959080134ee5f3e22b83638aa2817d2fb35ac9efb60f619b00ac140e60d5d93ce45bbd05058b722a00869b2958cf4da28f5ebd1d3f6db5e051db793a399ba2b12bf80a341f3f6c7b33e165f51db9656250f5112ad3b7bc4a22447447d4ff3f6d6d041f4f68647f06df5263286d4007d56916bab1fde59020e060dfe698e0826ff50e2f024798fee6c10d25c860f756c3f320b1b3621e6041f6c68ade49cba7983f9971e95e978a89bd44de5dfbfdd1ca4a8cd04932291ae7759f9d0aa9bbbfd7e7131bb08dbffd7e979c379b261a6658f66bfbe8b8b1bfacc96f327a3edaae1bc28b34570b31eeb68cfbc7f9f29e775c0afb8e39a673ce6c2329d428725564941e15b4ad5839d6a3bc27fd207447e33904e5b60d352ba6cc9ad199265965d828c1e71c3546ba4679742c9c711f37b6f55043b3a2c6d592bbf2eb8d4db8d05c5a4ca71b99e35440fb5e3e5b1805e45bd51b084adc519914478a1e376977742cac67039eacf0b297890e95e18df46f874064ef37005e0261a2cce92c2e74246171c11f017b9fc90cc3250cbd979764d9b5ddb3caca0f3bd243bb9c6b3c565bcff680742fac5372d0dd2ec708ca8621b702edcb7cfbf3b5a05aa4af2f1b7ebd74b76e01307a02f00c8674efd3de27504b1fe5453ca51f16fe1e3ea5df63659476cd0eaf7efa8b66b9fc0a37863b8dd50140530c9fb4c905b36559d4ad0a7996c15dd6cc8fff67f30030a2587218d9a968f70d3cb0ecce058f6c1cd75cf2ff30162cd896164719c4343ef6b56c74473915eed94661a8d1d7d4df826f0e6e1564ad6ca6d9de9f9ca2a152bbe638c7eea0f0a3f1b630d90e2cb33f69760a499894d471489c24745a65a4719f1d58ab701597c2501f3597d3459e598fcc024672c84fe355db0fd6649912a0bc1f97b47f4d0b8cb1bdbefe2d51823230a88d29cd90e86c550e300f38b4b039bd1578367cc245174a201b536bcf838d23ebeaf785e63524faa442663e40e7f2606464a6268ebb6b5e6e6a07f584523eea5bb74bc4d9d0200d156bcc77c88384855e16c39d41c6c1bb497240ffc34a50463281b6e7bdc6ddae70bb9fc99dec5666309f318beb940fded8040705d48c9de7b0fc69d4e93d3623be461cd1766502c7b850d9306a525dd963056e2cc4a247fa5decb75ecebb89149e011310027545ff30dcd3cfff871f75a6a2ccb17d81e29a5a918673d005b0f2b4ffc9d7745766ce6a0f9fdeb3fe8aaf0ba2d60ba5f0d14c3c0c2c341e15c90ac1ad9f269a76d2a1688a15ebb02860de9b4ea9fcab265ff0401513bf27ad3b7d65274985e05bd77fda569378debf8d3b0e3d11eb93e116a3c5f596623a9dab08e8223bc17c84b99c5b6014b18319924417e75f2a41c3b2f53c121186171ad84890a8480be8564455a55d0684118ad3cdfa3673a22daa62607929186ed29dbce20503cfa6cbb170ac454a03e45f197eb63be2564a1440d6eee034c7fa3ab325fe94bc910966ff0e8f3c1e191f0695914a505e9d65d18fecdfd7e022816db7ac8a8172d1389e4f9692b99ed0a2e79be090477ef9bc410bf7b13c5f1edbd0f51dfd1945c767ea8ab4f4c62493e1e25cd2a5c9675f7c3b5292cd386c0b30d7ca16a71ebb265fbbc96a7a63e81fa1ce5f1b021eca1236a9b4fd87e7cd322954867c05d2980843639791add616a170a04f84c5da239a2687b3f9a1a2c9e78c3c2417bce6f78d57a4625d261e3f46b5c2e8c0eed26b16b5675154ed5582ac9d5eaa26af8c8165b0bd088a8f9940b20a9ed06c37582d817e99ec71fa2297a507ecc9e978ac8dfdcc3d94be53207563a1fa455342e359e7710bfac0d966a9e12b1d90bcd68f307f8b95acf62df4817145aa8bd61ba3da155165bb4d8457692dc19db69c667fb1c748dfef5c6fa0fcc4a03ac9a77ca73c9fc8cd5ea00c998daf3fd6338db2b34b0a0d59cff23799dbd57a1cf6f11f0cb1dc64a238e99cbfbf503634e6ba8040bcc7d5af538bfe8d9a1152c66265b77059a3ca6fb08bb5c0511dc8a3c83fa3d8bb1eac48779431aba093184e7068448e3f5a612913015bf2060b8b69ef73cb93ef7762768d724848f41d167617e1ca399736dae4ac7c1acbc382da60c9a904a232e67830af6d5dc6a1f897fcd2846de6106fd91a002777e096fa6d83a0ad96b4cf8a99da2f39dd627c00d0c6c06d2fcc236496b694d263fb02ce73834d97d9f5d9463adaaed528b5c3def7d1028909f118602b331a79d7ee45af6b3238f9eb05df045be4cbb5748f1f2582412e0365fbc1b7133b9d7fe880550c273eb09d71015b6c19d511296512e6808d75b36ab5663d92e239e57f25155411a665fb5f8849d4d1bd6c4a391b4b57b66a4c10a6716a97bdb5b919f544b788f555cb72dfc24141a21075be3876a8cc39abf4fe526c1a44fa76038029b3bfb396d3470209fe5ef929db9e8c3dc4ac92418c35edad43c0f16c254b3067d01b99d81f0d2aa261a9e6dd5d116cfa05443971a9e21ac952ebf7525dea6591bfd0e95b211999aaf208fb67b28885edac75ac3b725b8f4fdd509effa3ccdbb557153f120272e357001b6b191663a38f849fe5e685c0ea891833aea53d60ec7b47ffcb01f90252eefe170275c7018f90b1b55597cff451307c0a253738e33d2e9e7ee5304cc51d61dede0447a448200684c5e47524269c048cc8524f208f4ba799d4e802e57d14384628d9c3772b99bf1468d27a8a4b57df1415aecc58e2d802a9d98c77542e3a1ec9930913af375d2117dafc2e2a331e424aacd3ceea965d282947c8a090ead7db5802697c871bfc8e5736035621e0e754aa3a47f0af6d0cc8b2d2069c5dee39e3b2d7898d29b3e4566085506c6f711024d147d77fab19763b878e76fc5757d1924f848c97fd83026475b2c626eb353783073aa9fe3e3e2ef8121b7650ef62a34060ec78884cd1bcc9938ebfa5881b94ca51fefd77cfe482cd4e4063b7a70ae2dda5c20630725e20a2cd9f76abf56b567bc7636078084b3d509c6eeb5d543b381b077c3207a861edc4912b3295860830fb88b61776b7d475b558dddbfdba0aee0d6479464e43939be7aa0735d0c8c2c3afbd296014721c3bafe07fb8edf0db42346223739a543e5b27124c8e30d05766effa633697181bf2c191a7418ef58f699c183f84154812ff13d8a27389b06fb3e345bafe1656ead7ddf5cf59f972d77d5d6a64a9dab68b57ff71e68ea990d0e57ad55519c2e74b8b05b2f73cd04ff0ad506415a1beff8db0ff3444b2b36461ee1b4d8349f2869969872471defe32dd0ded8b0a96c861e386a5ab34eb83f990cfa83eb8bb1ed20f98a30501660960abfab1ef1cc349aee220f1eb7e2a637f9e4bd4906e74c21728c652d51612cf2d9a1a14ec06aebd93807ed35ed7c9c7ca8456561d45510fb898e0823ca81a545abb09ace5acf94feadc8f3ba8d19d4d6c5bb7f568a1ca948f73053ef04adea4010117dab81375a79af537156e2fd627a26d1597c83550249c19bed77e5f6377b167e66ca1f42b00cad5b6b8cb5db35c2fe096a3526b65716c2d8bdd921cb5e6a511e29d7bc4e938ab23ff8b621277e31a9e8acb0721ba3b87967ee2bc1005720df185030fa1201decf621b9b1bea03cd0a8e65fae6870199da20b1a4d735ea68014fe66f0332e8e960e1dca54f78973f3217fde6fa00ae3526bbca10bc5d057eb49514f4d1110acbb996c3cabe6647eab436be44d39efaa247c39f30e27e6a4e31ee6f211f37389f3c6fdaea5c4798f2de35573f3cab152c381dedd0824e06fdfb402f944ae6c2cce5de8922be2f2354cc62677ff9f6553a39602433f1f7301a8cc0ae3c6a2992477b57ff64a8916e4a320c24b503351ca626ee9f53c73b88e7d8305603589c100f9477e78f1dd0218ecedca1d3e626b924d8bbffadb8b3f49c808aee74bd77a7d31967eba145d7b3cbef4ed1daaffa6a58e907a1b2a7223f5c3c1c55ab778fa3091daf9c95440d32e29e4f97414de6d78502035d9798943448a420e27ad905a539529d94f7bd19c955b1189f44bad9d9e7b6083b21c9447b8524e2eef6d2c28a0bef3a31d90514adb964521890f54c6aa9914359852a0cefda645fa37025bcf149c15d704fb8cacfc5f70845ef333005461f3381d2b93265b6facc9c2112924c77598efad88d9129a96f4f81f11089bee0989c21729935e7a0803ece8da1733cb9e069cd64b6642d56364ac7ba1c6ededf343c8322252fdd94b7eccc8459d5505652f8f634a96ca68659e81ca32dcaec87ea5cbb05bc2524a5d011c82b7a9a452acd0f6459035aea0fd32357e05e1b3ab2502b1dc9bf06118c93573957269d443496d88065c7ea3c7ecb816b89ddfa7e7c9ef629fdcad70b6f7f4c7898a83279f8c9bd904443a4863baf703cdc9c6b1ff429380dcc40becddd36650477f87daf91b39eb38faa9657ebd9a34b46fedaa84039b45a27a524d10a8bfd78722e9e65cb982aaac204bafc824ac7c9d451f3349a7096ff5f6adaa9e1d5fbeefc026fe3857ccc64a8f067f82aa085223ab9359a5706dbb955a0a6c156c554f07165ead21ec7d8ac29fbc0a2931685cfdb1be117303aae1b61756e3a16746e288d64392f53b8be232ba66604191978915f76d462b3109e31d17bd99d0c47d9522098c33c508e9a9bf6c2142a3745ac2474935b430ac05d047dfb2d7444dc15db2bd704f4e6971b79a52a798bfa02668fabf8ffa2385e8ffa21f5395ef1a97e0f1cc557bfb49c530498ed0a8b1e0cd7154e1b6f4aff60757a00c543cfae23b05b4c61d019157586013970dcd22ec0a52dab07920d6cd9dcf6b9c7287c5ca34674f846d99a6c8fdbe2911c1be929e31ca4f452a4c91790aee769376ca2b9ac9df702db0628dd374221b4fd489e3a2c72bbb0e86882d6abdad88b8adbf4661cb1dfe432ca5d2c17bdbf8654814f6b3ba6184aaa814146c5896e19b32cf8cbaddc71658fa995f0ffc1da109406b432224b5e5bd8b92c6d93668fda1171223e5df4e92657018d36fc0572074be0981a6c0b3a71479d2ddf0c60b081ceeacb9e5cab99b57786dddd1c5ff7558e6622b7e30bcb05530a1d231ac006dc8a7719435e3e5a95badbf4e792d27f0c057a7aa8166e081f8c5e24668cbf2cf059988f2260af7cfc5a3bfffab21d9e6deaf3823ebb49f267c5ca14d2d0b1df17f8524c296a3cbdf7f7a693fcd5d20314c71dac3f1cb6d3947faf11d1244c177553af7476bf041eef4e215d6d1e1557d3c47b8061a309c391ef5ea993679d2af03369abbda193028017f07ba33e1137e5d0abd017890c1ace049c9f8e6026edf6f29ee7fbf0697e30708dddda2ed53fe7021d8f39d0c6180769ac80b870c47791a1a32f2ce489f22225d7d61813db2f562aaf7a41dafef0ef94b7e74314a98cf22c447d402d013d3467924f344850d56c55eb95988c8e51173c84507c6042f9942d898565d8f23cac1519e2661bfb002f0a4e91df439ed5d0be514364eaff29ca7672d96bd315c8dada94b7d6a2f9fc74a7e8e8190dbb0a7d58fbed653d3ecce9c17f01467f44fe956fe98098afe8f735da081b5c18458279bed9daae2537b320207e73cb12ee96562a6e6c05335cd07c614da4050eb7d36700e59b0090144525401d886772f124e99e26b15ee5fecff25ef03767b311a95b4f29ff3cbfcba89ee681a176d7a5dca5892e98e4ea5bfc3724afe3973a2e629c91439e71d8e4d755da008c355c198929bdee0c97a8a38357b6a7422a0e3ea7054be452ab634a26043ba951e0ac950e55123b507297ee6fa8d26dc5e969cc9c52dd89e82d6455e9f65db35b5a0d86498e9cfdbd34aed5ca92c2e44c04ffe971ad1f2f53aa590509d23c0f27b3c9864efeab44cac11d9bd5887b849611f9e615afa5acba0bb781b4e9368265f498d093be807d9ec4d966c62c54c6fc5b9402dbc3938a815d12a1a077da470e9c42de90ad3135acea2fc50a801db5e58ba3568701779054ff584415770b6bc09db12e0739aaab84b8c040c1ee5cae0f3023d576d0e54a82bdce568f45e2ebaf90951a183538ecf4279eece0094283dc98f9761d351a21e7a0750a5322e96e76e114199aa3caaa1193fadcffdf6ec04c38b20a5f321df155fa7859ed0e6af9804bd037088a899a803656938de01db9240b2e61d42b98f7802de1f6fc9e424c84be889f370dd54b64a6dac9b8a5bd8d161fbeea6b1a1ca15d11256cf9af5b99af0cadca86281e311333839f7b6f5d97b3b14c17fe91a33ead5c88992d75f01b1874ea2be4b9ab32a6abae8bd10eb18a9e59f1b3e6c8a2a49f08fd1b3318d1034bae2a2ffc12ec1a0b9d831999347ab66f8ce971dd4ba7d7995f7a90d7206ebf6e452bdc07177fbe38dc4c0f7b82488552bc72b7e5c445f3ed80690566b3d85bf53cb54e760e6bc7a28e09a375318b04322b1a0248bc14b996e5b41025f24b030a56c8022e1ba0ceb26dc93c32dc34222ac486f505dda3fcfd4794f40ed9ee6432ac0f56a584468595957dafde8f3e0d322d477a1d7e6437fdb4e0b71853a465877723b84dd0419315fedb3f994bf3c667c791a38302eec6d93293e25ee1df5db9738efbe8ea20e9a67a5273913126e05fb3b9b0f2ad034e44152fda3dd26577d641c922649320336b0b9c56ea6beef506ca4f22b6a7b9b26e58a2c07f644694ba6b155a91e71b92bbd49cb101f9e7b2e296843d6b25d31fd3686e74d96c7b3de6a8a44368d7334a1421b12f1bab2b063597ed2debcc95749dd19fc1913b88d437bc217e114780ec910247350669e96f4d953a2eac14ebf2a57c37f9596b4abb9c32331e24e6e893ee2287bceb1f8212bbe65f7d7d60901c31554895e7366fa8e5d15b0d918dede31dfa426fc2ca8ed3b92a3bf9864118ff56f76144e61c23932335297416eab72c3efe5eb028df0abebade060957cfabbcae8ce2bf58196d2cad5844ab9c3e59c4981230519c22129ed50ae42bdb4ecc11a71a740a85c35b0e95b5705140a37ff23767271a661212834bc61b1d0202fa5ace1ec14abda09b5171c03245bb311d2b9a398e4596ae286add9c262e4f662c1c781b303da831a4fcb00f8e0203134d1b39b3df98f61da0c7d3ee7a166dd42c13608d39cc4e2989c0cd87efc9f4ea4d6c96b497b819b0b8d8d465a4ff7d134219c47da0fc36291a66bd2a66a433a0ec0596312e13056e6b9c0010e29a10ac5280f1c74376d5bf8a17bca5417407ec6d656420a359b39e3ceb75e3a069ab762254f992e4807f5757248faf9723851d7cf05b953c846cb92dfdc70f3c1d79ef77928b5d499b8a4a1a8fc8504604ab0a127bb1db15f2d4fdc5aa78a1ad914c7ec6023b892d9a27efa9c32a132cad06900d28cfd2a982eec6bdcdf9e8436428fe67707da73863b701f6a7c3f4542c737a26597ff309b86bf1bd97c62dc3e21d6d682502fd7e86905bb0200f2da2c45c9c097406dce814653ee0f0fdaf27414224ed2e9cf6467daa09451a7c6d28e4783dafcc3cbd68293bd7efd5fe9ed7266b8bfe94f14355b1079db85f59a299a6cafe8fa50c045977231aa6278f54c52e6bd54bcb950e258ed6a29138ce4c61baaa8e3f758e900e77371812b78a650423e563cb084cb76e79278fab6d9b5ea25766ec20a97dac5453bb650b35385dcc0541674604f2af270d8a74cf7629ddbf3d9d78bd786261c5d05e7984b3ee64f386442f33401e17262e77c41bc5778241673b3edd535d3b5eafa5c65e23db641c9c1fa29682804a9132249973c7d0e6a880fe8dd77f7147c8bd4fb575fd7c8d5afa6e152080af70a3de41a2d6dc6c7bad47777305407f811fd178362ff180fe5e9d24d9f43f37b936fa9f7cd1b23cf30c40c0c931db3749d6c1decc288d6e2400f25a8d13f5d8b07bac533fd06c895b16cf07b1777a605b343d24c31ff365587259096e34f18c2a1fd7a42e057f87f529fc7db29693d8d54fc799aceecb1918424b0140b0f128e33ad75f5667d124d9e2084fcc19938dbedbcca0fb39ac38364cbbdc9dc353a2f024085be09259ecb177a63f4b88ae020fed98fe3209be9143aabb4840dc4379d9bd4d12b02f0f3e1b0455a3e3f5ab5e01eb2cdd372096e2edafa0465bb133295f7b6a162069735e0ea8eb2cf3829b90115815d22a2a8d0a407db3c04d0c0c7bb30cdcafe58c5c2992e19dbd3a69fc8c0bcb92d702a02a3080e6185e2e0ee47e31775025ad110a3a4331c59d1db8aa3e3943073aa9d5c28761aa9644c8b406b6a409b48d83f67ec5558eb20ebe53ed1db039e5f02da232d84a919e494092447396f42f101b4cc4a7931d41821b4b226cd874403a3ed35b717495ffa4156011fdda1657e27bc2d8903b74faee092e96e8023223c61e8701149302a671af88ca331d7d6ec611fffdf40cd231ed8bb1ddba040b37a1382bf6837ed3716df3599a11e91e994fb6fcfc42f50d543a74c3e6d26ae472597329bb0dede1673f01e29c763c04f201f58f65ef1079fed867d1eb46d790d0b01df7cb3ec22222805f9f54d747b78bf309179db5a4c4fdb5196ecf47bc205649056d7a9d413abc2c438f63556486fbbf6a62421eaacc6a0baffad5e9139e2b7f792d63305b63d8d2a1b1d527b1158c009a653f4367bbeb516b71ce7934fb3109661f4dc9b2cbc362b98dd5ca2341d32628f0b306e37f71f787d8f64c182024a0010f0d31c3a17eaf99900313213691654c3e65251055cd27ccd783267ea6c7794c75c1441a27c4993a57bab9c5059691da90cbbbebbf05074bfbeaccc03f025b238393ad4785829ef973b5a56ae8ada37fdf219a94c42e3a6b896779e2844a75015291582df34d7073597ef84fa793a4286b37ef0de6c360448adb593f742efa43f26da9893085ec07c2d371f189c638e825bbc94cd7de89a97f5478a795f4209f9269f5f14883c281705b5e736d120fc2d30d1b4457da6fdcae06fdfa0a44e4fcad67bcd1d59ebadb4a5e4abc59178b6e3385430bfdac340d7f48cd85daae318bd41fe55c330c396fbda994548c1938ef663534ad07cc295ab1f10b097ee7b72048956e83ede0fd193b4c05a1c8bd80cbcb3c9456d227c48030e69ef3729d1d4dfd80eb350cdfa0a5ec2a4cfc748d09a11971d6049513749c7214d17c177e90123c619c2505ed354a4027e74b3ffa1b648ee1863a4c0d8c54c6b3289f5ff98497859b186bcd8452c1bbeba7247c150aa451a6893480607ec848ae3035a0daee2993396886568d2624fa83b8b2dfdbd601b82bb3bdec0f92154db019cb5f0096c100fbe33a1e2acf9f84000f2edfd84eb8246e9f849c51dcaffe2e9fe0ee25a055a24f42b84c732d759bbad04ad476915c31501bc34e8ec1359a55cac60019015d82b491249fe22538004af880afdcee11cfa0e54fa69f25399e32b16878b559f04c9fb2aa921d0ec5153c760ea0e55a370546e9b331eeb874f89bf4b7290f0eb754f1c8fe09d8a63eb609b69e72c9582e64ee4a34b45dfe3a06df8baf13e287aef717fff551b3434d0d07d5478fe55613a82e9a0eb67dc41b9fc1bd8e7f623a77a3d4ec8a8bb80ba9dbbe2c727b79b7a841aa0638bebfa563cecd623d7c4f0794997b721118de9f3eb242baec287ceef75358dfa1330e395a726fad7dea65cfe6c90447c4b22196405027222ac59f64e3616c7d305b46cdce3adae465c1f07534f058e3c5160d5fc17c420d9dabc2ac6a37064379d0a37445bc2df0b73fda8654b4402cb74e92f1eca2ee94438ffd6c4a92497b42e2612612ed6c419194c33bc1a3d65149f463b690996903d4fe37c9720affbca5fab60067baaa6aaf16be08d5ffb3f19e4b65d485bcac51314e82740002674301ebe6a3f3c951e31ac5c5c66b74f35c249c1408452fcc7e1f2f49954898ce02ed9722165a3603789f1655c2420eab9edadb4b223a723410171377ed55dab1f16978a224eabcee5e1cf47a7f0ac3362cfeb88f39b914196fb7ef0b7aaf54a1ebf92d454d530b103fa7b37570be9244e8e3f131d105d2840b1ef85eb65e9143d1318c141b7b53fa238f81198f738d9603768f0d64ad84d44239a116c1efcd8b851284d8bfd0f2536f68a452bd200ef365369a57e3740af0664b5ede8aaa27a3daacf07775769897e0afb2804a55a05752af0304ecf0dc966fff45f5196bed659268df0587c41828be3049b9fe74532afb6d4a9de4e93e7b35fc1376e5ff6911147021960b9f20cb9c80a9dfc0c4997e2af4618638b202f310016a8867a4366b683309da0047328899fae1ef6ac0a8a989a33e64ecfc9d36739e078e26b84739578d8a3a5655362d7da844d89d20e867d34aa331817413bef87e1ffa7c770a1f22d062fc96554b3ec5f2f3c12d928da1b8424e203c1f384fd5952e1b6bb3be614b2e4d12c3d1381f904f4b2973da02ce95351784928e6d4867c030075d3ffb0dc05b147e2f2322c766b24ebd85e98332bc8a63b77f588d9aa149fe39df4d6bc0a9c9de1959d9dbe654de9f7a27c158c1d2d65881269be2a939ee06c70cebc5d7da3716cd73da85320c0afa054e007d964124a904e3abdf307619d96a7327bb5ec88ab7fea82d26a49fcfc3b443add4715137fbebd6e56d71e24a245cc996647f225807c1b3c752afe366bd810a341b80e693afd2e9818ddc0b5d5948b06c97aaeef47c724b11e5310a03733c0ad5971a38f3eb3779cdd6b00f07166b4146d6768260f0e1330f2d3b12d52996c1ab3aaf9d51c716560aaee86e2224ab6b00901ab605addecee5660070fbb0e6bbe492f3987f4d8823e09d04337876a2f10b3b0d48fc4a2c601a46bbb90237fee36e656ca3eda9438089fc41cfe76282b821a79c174af9870c1922b0d9db45da652dfe022e6b71f7f3bde2f2c285ad751ccf3c5c1e9ccc62ffaf20ef9637d9842d3a2e79d53c72bdfccc79b6ccdbf3e91ea1e213899929c6213dfa40a5fec85118baa5acb38a9081fc0bff997c66487bcc7e8caacd90a700dd78527c17e27bfb7323259e17a73c3e46442455f17a2a785699e1c1bd6eb1ce6ce22d5d6b045b1a1a98ac8f3601c530134752ac9ada9632d2234342a5e7a7f7431a31580ff2b333008072046be7e42786e21c913a06247fffb2f88ec081be1ffa97afc6b85e9e90e751c1cbc503a996e7d9c2f2c68792c1c49692bd21d2fa7a01f710e8dcd4fcfff8bed143c00f52411514794a406a96bb966c8c9f8d1aa895df086d97170a5c35f8b7d4eb0bbbd104474eda5b6acb22612e7be8f65279d6bfdfcdb9d25ce44c4fa30662c574278c33c11d30f06c983db9b26051488caa48a2abffe1554ebe9620f7788f3bf148b382fbfaf88fc5eef08f7728d7251322b63ea9fd2dadf8988f9a81d90159cefa886122a8ee485329c9aa7b6af958bc8f01ff5ca8948a6a6a85c32dcb53f1993432134260a57cf02ec8e64e31d703e77b9872b257097d71d11d96f2ee7da5dac9675102d6d0e193ae39fe2fce0c1fe0cf7417e41a12a1a9f31f016a03936594144091e42dd2e8964aef3769b637659ed39f903147f9d185977e82ec6405ef9e71b379f914d04247c15c5fa5243562a5a257c3589d4d5d6f839ca24de2cf5580555d6958d694c52db158b4abdd22d00a6dcc548fcc7b6b74389327035c0ed865655af0c0f147e7bae2b00d6ceee7965826c0fb4e1652fa637871559ce0bdd6f3126d41c327ad4bf934ff360a4b61b285f0e61e64bb141df9d6392de19e09a0c09ef7eb2252739bab75ab3f26f8ff0783b4f90b53945f339c8306b45766061b254d8d208138a4fec9f6fca9c64ad5040f2c12ad29cfc7064d2502c5c9824d4e544574ed8a2a1bc6b26632a72db3025b4ad21d3fd43d1327cb7b2413b870a59ba2c3c905150461d19d97371b3c0f1a56837970ba9c0cc0f009d909ba7b08ee7ecb77ab3088b7bcdf1429753fae7c728ca84f0ec4ec4ad3c03b1b516b4292065155a9e871292529f6975a524c6b8de0f208394cdd9323dd2c30763d4312c9c1f35f12e652710ef416ea80b29462c9d49784d9a446959f8dd8b0187ba866116bc5ce13ea2d28a328658d40c82e3a8270a38848fc2adb797bd9379f1d750c7a4093b2ce67f52e03eed63ae09ea6c55e1cbcb51104a876ad7d026d6626f97a3a3e01f1c8c0df4942085ec3ce7e10414a3db6cedd05929967bcf14ec5e303ff13493fd715ff595d61bda6df0fdc744e79a71ea91763eb3cbce688859ebd4e7ef0aa9b49b91cc6df27ad373409a4ebb45bbb59f5cc78c759493eaacd16d65b1b6b200e56e67b96c971af3aa3670cadbf32b267fd322658519516acaec0c5ee33d9fa571fe0ff0af180ebc67f4c43e6abffabe88b5d98e1f8de2dd7a91158496d03111ef9b79c535cca00637e006856c56b7db7f0af7cfdd771ab903f7c598046902a1633e44eec40878d26c5a7c6cf8c566eff7e849b4dcf685bba416db1d5dcfa534c076bbbaf6b11567eafd3c4f9e21aac84bdbd92de5b4f902e6e8b2ec915313af1f085f379a5f53d8493cb6db2add59d3a5f9c530911fbad69c2fe6ee4a9b244aebe98a3edae85c281422db3c506e48812f710fdf9fc6aa92d7645c52abc2061d542f2d1184471af2f48a11d172684871d8d701ce82884eefb4231057fb03e08f694e1ee903d818fa265f06fe71265bf8731f59306467cad9828505427eed908a78f457cec809ecb099a4edae0910f82f3639e40c9420e08211f3566380e20af5fe6a9a72e61ad1038da0112c1ac1b3695c7210b04d9e1f78d5e1b95faa1d31477297dfb5e914f19fd1e624e1b472dda323f9b58f25d69ac6af5612b31a61b2b9db0658413dc4d7b1070e2c2d4af641c1baef99bdee223f85e70133582fd411dc1fb06a434b37abcc14c53a96cda998d1bcb2202b0bc5252abf1c78260602b444da9b2889563423bdb1b93f38a5c9923cbea75831b08f2d320db7a0c202f08f44a6439a89a1ebd89744e86ecd702af7357d2d2952b22629e0676ba7e4b548ffecdf62446b9474cea437ab82b010364ae028e1c6a17bf2ad01416be9616026f2790299e385b62c5f6aeac000310bcd650530a9743991b711c798e2361a9ba33a5eb7ebd06e35768c57a685c8718b0683fc4d5c26aa2115418dc0a03bb32c7736f6101180025bd101ef7e22ad572e4c762477620a42f7548010483bedd6711fffeffce978175fe0edaba5bf807ac3f4d4f160c726e244af8b665e51397123328e95ddd1157d728a08521e4f5288bd122df5c0e0faa3c00ac1ebca1fbf618aebd36e3ab6ba58b1d0a255e6082bf13e7c22ae7ac168684a78e12b803f91c6e0ffa89ccbed418b8a85637da6352dc6618d340b7de0970394a2f4893a8f7f221524a410924d038e7fae2213a49e71d6c11251d5e492ed4fdec25fcb3e0514969b54bcabcfc0a2c3e33ac2ad7637e504fe1e181dcbbdf1546dc26899fca45c4a4a3f1611d6f33720d70b0f874f73033fbf13af76f6d67ddc3dae75e6f5d8cf6f3846ed5d482a2b03bb91fa262fcb75518b890481f431274067576e45db72e3f1e0e1e66f13e681b12c181a1568963a1373afec0f3f826b079645507d538a0e053f140f13a1de903655f9ad7ca64822c837cf9dd5acb985e6d44cf5d08cc98b617364ef3ec3fb926498a3363e375f1f07c96d905c432c4eb0f14c580844864579f657eb7c1f3612c7607c29563fe3c1ca46ec9c9dcef249c92e8d1650c0072950254d274f53ebf097b9a02c62d24d943440899454c5847a4c1ab85722221fabae67213065c998c53cc68664e32af5591af3ce56406dfbf104f974a62acff33867644ee24b83d3d6773252da267aa2cfdd89697a3fd1119b77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
