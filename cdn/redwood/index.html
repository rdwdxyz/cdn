<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7096804661a1a12500dad47b9aa68c4d8fef0ebd274ef75e771c2bb163453c98afe30165a8032446fe2db0d8cb6b19d54c2be764a94a10c288dd8c5970ba75b9a95f39e831c7975444bd9df79dc0e34988a6204a0cb0453baca64409b4a2d38d3e17204f75081459eedfc06a45cc92e6774b5605d8941b83e2fe1d5ba920f3c7eb4bc660c57478ddf2051c07aaa32c9ce70fbe91024b0fa8f010c03ff60e2fca8cf6700640fa1f24dbb68f0daee593382fce24704b567e2670eafed4a5685a5fc6e35d5e1ca4094257dafc8524af22a0649f37644c1299eec45115adfeecbb93aa2155ca7f638fe9e136b5f31648b13cc635d1508151a5013125b3b9933fba5108d57b6e7154dd44669ebe53b84af3ea6c968ed1f69e46c6ac347cd466c418abb5c3cd9ac8f6966df66a139a4e60528cebaa53bf32dc0a0f7b00e907c6ec7e63693c5c6e4b735a8cd7f12147ff7cfea803699e294d7a637280660ad9558ea6bbfa0ffa6a95bf58109eca693e3b0e6b8a13f1dc30f3fcba5181b93f69f8ba97242c7a8f117cd216972bf85b89c6e14bee32b9201f9d1df76ff5a33a874b204dbc6aef3e82ee6dfd9a3ae8a890e4bb229e568400d31446a9861bf1cccc26a341c9613313a639f31dedaa1ecd6a5fbd2dbce52c9c2336c5233bbf905691a6814e231d6a2e5a809e3aced30b084fd5ded945bcfa1ad71e2f8db9eea5a72c5c46b1931f45260de4de88a98de1c1d87f69e6a52e8bf237880945c4cdd90aff0a26b88aeabcbbe3bd78aa70533e0092d9144890df2daaded117ae6e2ecb81d3d842a8a2f1f65ed09f6360f918d35cbdabf7ec9440c3ccf36dd32e97aa074ecd4f9344859a4ddec2b31906b33a64ea45966855e40341c2ae4f6c63eef2a69f3e46048171ebdb6f8d96ee242f1361c31d877322e3a8b16417637e5eaac294899f990131bd99eb1d2ac78ec86ea86c7366f86ea8f310747e45af6fbdff2abe532c7c73d7d5204a1cbdb59410e26eeaf02405263832dfed5bb4b9bb895531ca4b85f7d03bc2319ea59723df2e92001d070c05e8890b0338cd7bcfb218854512d83eb8ed6abe7df4988cdf26a997ad64a6d4ad895d520a971e0ea37f4bc6f69c14f124a4625a17dbb537533eae43aa00b833cda2e4f6f5ea9f8725b6eefcb40b1423245bc7932d63a5a1bb58f25629ae5fc33600f9640d3cb229c2c049affd8a60f6dc5a860ad263d91d49f67f224e3310196f80b2607ee860874465f197b02efacac2456f373eef2a1cc4f22c27fb6b7e14ca297c2a3687493e0cadf399a781419f12c69b810196e257776bb78d82e8237b5000fbeb20b1572c8bbf626a72c82ec04d26b4809b2199f770f4ccda8827bfc49f97c1f4f3834b90fb116b6fcac6cea5221b81227e0b2df1c5889ce6dcec14fa0da06ee3a96a9d690caf9882599cc81fbacd911382a788f025538bacf5907ef62afb5c0bf1e94bb22eac24c3b73e69d0aa0e7071895459f7c8a04becad301813eccbfa6e090b64b373df7dbad8eebcc38c2d17458205dae310a3246aefaa2b7b01df8fa1970e7eb0e6d26929f97f0e71e1ac992ccfa4e91c263a1509bc0b804e635970e686b7b73bdae7b616e20e5dd800422039c001aaff15cc583ea7e7adb413de903e6e61e48305fe5318b5626e8e9f5003571c474559bcbdd33f6a834e0955d541fc0deaa7e18dcfd394773fe0d8b86473ffe713481fab2151953df87f44f19a29fb983bae3625c2ea3b5aac9915594bca729742474431a1f0dc030321bb626af82459c16a55a2d48fc0df21e7bdd63eb708f62311c76fde1c228c4ff68a3608a4eecb51fc0aaf737280e6322f1aedee640ebf734a065f16a00f0b26be4087c27ba84cec19a584879c92e90a10eb3ebbba04fb60248d5af49846e3d8948702aa5b6bd97f06f7c585eef818f3f3bc5ec1c29c73ad653dc0aa9d84ec755f7de43ac9a5f823b3b0939e4e0de9090560466d4faae0c4a572c44d846eb28be69b8862c292cb2943e104a9be6bfbc86e338dbb4ecedec6ebb0d5dce2f5e82f2ffb5f5d6bae690c39a97bd569568cd15625466542493f5382702d793cda0cc348ee04d60452b7b2d2db611e1ab293f6698dc5a1245df36e60e17fae2b0a2c6d9fa97b79a23fc5ca851e914ea807bc09facdd6696e53026324a837ca9b5d247f2f1386ff3f743f392c927d1b73e9c5aa16b7191d5560f6a0d20375751b9911f45aebc5b4a784ad3cf2fb4bacaa3060c2c24a6c0515b0e123ab3f95ea5f603224ccdc9eef5eef5df71676cb1f90c7651a49af10a95f5e258caeefaf3bc861b9dbbaa06d7f380d7f6f2cb934d69dd032d9dc7dcfe702824969092fe3ffaf8ff8d1ec0503c6d013f47e54f651121177a7a0cc58a952106a5c4ec083e824db40164f8cb381104430bcf3dcebbd2c59b7e88ef89a8b0ca5bb9c701d8e87879b08d840abd5ad36ad17a7f0c3f90d4a6e5dc52e0c5f99a0d1b86c91703d95b07dde723b647a4caf04caa78af2bc1031ce031d81d64539cdbad719940e5a1dd5b85ea822777c98724c479d7f42451c68613764b0cfc8684fe7747f3a06f16bbe998de38834f05c4d70ec9afcf3d4858fd65786473b7b470c39d7cfe14355de7b7e112f187e4a761574e87bb030651eb54aa766c5760b59d18dd8712524ec5a2a74a78d70ffb1fcc5a0ab114e56f22d1acaccebd4f6a394c1e5ccb6a780e3ebf50eaa301144c71f616d07b07b3008793c4a2476ddfc751afbd73621f6148698b115f10c3befe83d3315ae8e69bbf7b9bbfea93e30d3783098d432966cb66992855593339754f4e7349e8811cd777078d3294f582d3343819b47f752ab3955f2d5e06a83909455668b6287d75806ca0426a2f4fcceba4e6615829770417afb671dc7b0839e1bb28505990492b3fd72127e8df38ba9df43e438189d6f13ba4b1db86a29f08f9cbd267280bda3f2fec8890cc9d563b2a733633e1abff18d6c1b6e1be17dccbdb4a222153225c36a398b6db56d123e95ff33fb5a4508b3fb34eed278bfb7c73bd2251f14c3ad59b3691b9c3e02a3e03f20169d8dc1376ade2dfc7d2e5c9175d06088fcdf482d3b7aa39f97901b2509b2584c20ddf2f0073daa37c010f88b11b3da91423bff677ccd28e768bad2cca83434f733cfbaf1eac8644a02077fba8503044e8b46728dbd49f2445ede5fc370e019e012c2b316809521f858e9187232c4e0bf0f6670e536186c41e8293801d98390a9012b437d94b3f1613915cba6483116257751af3bb1d519d0e0260870dca6140a0f96a59b6fd73cd21f44265a59a6495407e8b808a78a21bf9ffd1b15b8534cc68160b98e367c8b89f86fbf82e1f9b568fc8ffa25a11ee9d146c6aa090f2aad244fec270bdbf7936de3c3b39abb4f9f22172a85cb6a9cce4a8955834a3addcff6a0230e658edf0faca9aa45f6ce752525c4b7db6e97a4a36f9560092d05509818ae79c91cce1d79410565cfe9b53e188a73c53afd50c28e5e97a27cc60d12ce00de0f3ee4211f60cd9497e22292ebce0a042ec2a1d1d41228d204cfa8c468f77576803c916ae9e4291cbd846d62e380a003fafb441e44f78e6d22b24027603fc48a775254418e363eb559f57aff8c3051b149265091f7e423a81159ae49445ba95b67216cd5b73be05708e4f0ccbd1b24382ce5ba934797fb590e67dcec2bf6781833a935a30670cc867a8c032c5479b2664de553cbef5a3b52170fd48085ef74afb908550db5de3a5b2aa336ba4de5e22b7cc8035785baef811c93d40ea5431cb03b8b0ed75e372da7a272bcdc480b1bd8b7dae0be303ff8968842d3b6702dfbd7b2935c1c4a8bc666d204d33c010fe20304d8e5ef66e61d41dd29ad3a7ab3ad43ec3c4604d455a35e8a5d3b60fcf589065c5664eadd8c5b377db89d62238b5b9fb82a98a12d47a609a3ab58b7eca858dc61dc66459573ba77c219b9888c8ec08576b1e8301f621e03530a01370ebaf4ddfe30bfd4a0bbd4d47ef985ac047735e239674b58358b0fed8c682abb952b56a3825c0f011e7309f343cbd8556fe51c8b0e57d05e2809abafdc6f2df0638ce536f09165d69222edefcb3bc727d7fc4e253db13f793704d31819311c8b4e4efbd47ab781cb3fcc4e44c74dcac357e7628b7d646b985be21bdd7d6befc5f6c362a59e56c3cedfeb69ce7005e21fecde32adeea249405c2508f64ae71b518f07679929e1094e3e1b47ff80f778698564abe1aa3db3835bc964dc699f726a4ed9dea1383ba6f968ce967fd37dd2fdebb59062a30ac5775f39f8edf04e3adf05931598d61c2d887589c2385248192c1c7994b58ac83230cef2389c8f6aa93c0d51987af66f65aade185d55e632b2bd45f99b10e928a9c36a1f32c5e41ed0c934502d9df6a3a59718291e4fd479fa5287c6cf5cd4a3ed70d2272db4c814b0cb531ed71c19f8c1c18241b4e0483e88a5d68a9c1192e2b536f2ef63c5425355e79031768aac17763d66a65062462d4f8756da263bba18c531c71eb2e1a2439526b575289e82b87d794f658afe65d8e1a5f60ef1d989552d2be5e73ce225066104b284e25763be963acd1b4f79addd1931f9f7c9f37b7de844228cb3a9d522cc0a64d063df010e7cae0f7f2fe88c0314cf2384853f376aaa6b6e6d69989e45713263ab55ce108de7a85d84b9f2bed530cccb14ca8a7e9c2c501cf3aea4d7e2b3d7c316cba07b89d348b62e7e55608d1af85ebd9fc05814a03273ef5df042e68dc8f146b8f93286ada9fc7b83ca76fbb28bae18802d35e8aea1b506c5abd1319913e7ad29ecc29633b599ed3a604ac10412fd98b77a3e2bd1281e1ded9e90429b48f448eddeb0fad33607793f49fbe3b246ef40eed1622817107a1ad5768df207965472d705308d9626e715386a43c3d1293c1d37c9c63a9c7e08f23fba3c59dbfede1e6235935ce6c0402ac8269b2d755bb139f00d9df85c020fa97abbd359f24136f8f017596ea3f44603de959c98ac2ebb581099c975ee7a69ab3f757143a99ebf18b29c3d8826091a48ac2d791878bddde344cffd000b7df78630e42809eccd8b9af3f0ecde5bef94b24d125d569b87bafcfc0ea0dc6541cb2e9c44958d1849c8d75bd70e665fcff792796911eb3248b1f5c445be8409cc05b40d769a661bcf24349c89712b8d169ddfefbf016e084405bc011526ff571d591311602ceb84c36202c8af4074a0565347f83e301fd2822edf2597e83eb93e430331d8d6ddc22a9aa2f529a9dd5da38957a12ad2ed6f5fe626334257e3b5f95de86608a1b3450042c0e2e98d8d036885ada838e5798fb7ff914d0bc6961249a24119a77f64821323ce33c07aaeca30378667bb5f1ab6462376bdc6d0dd9edb0b5b762f57ada18f7e5cc62f4aa0ae8e36cb6f88424d3480f1ac7ed0e4a6110a96f1903b525803f5af4579061dc47f1b0280ca1c0acf0c90f97cb23f6c9fce2c92eb1078b2a81d8cf9a45fc6353c0fe4a462d4285b5128cd968f02dc3d29563bd8aecaf3cbd67e563c5c732f06a6994d1f18e1209426ae20b96961ec52dcabcbe0277e0282ac56bd5224cee499aa214ae6921c41041dc524340ccd11b8074d401c7c1d6528906813cfaf88208a9958d455f0dd4cd07cbfa4345776a036664fdb3b52436788ceca70bbbf0a96f452c2f0979a09f1e28bcf40ab6916548c7a7854f705bff32f532c9f4686093776db4ffbe4e942ec9e4f24849e6a7acf2743e8365b3fddf65c575a759876176db7b5975d001e993abaaad10fb5f4141dcd94bbbd0b0ca8199ecdd8f7008a0dece937ee19c12c3238e8ab4fa640fce2845d2852954aa1ff6f48c1640b90002e7128f8b995612099174ed1abb4f6053c44e0440029d21343fe0be16c93a2073e85b4cbba2e5cd82b71477b0e744b7a3b098a1f5359a437590837267dc09bed1947b378dd74c888dc058a80e88f086b345eaeecfc990ea2ec46a28fbb1415d0aaee2e44f6e23f01fc0cde496600e384a1cec5b553a8fd618614871116b772f7397d7695cc074dfecaccad64ee098abc1f6dc1b5e9dd513dc39872a03325be9135fd5436f61624e35bd0325dc938f96b69abf3a20b0fecdab364f58f5572ceb75b16e703d8181a7cbf3e8108d2b4477cb88bb418b4c48328e1312aef75b3681dca941010cf5f5704722245ee9b411e403f79c5ace0a7db59e648070904df7aa43ea90e682c7e03d29702b7cc774f81c099588d7c46bde61b34b068c6ec1ea356407943582988a1b342ae44fa9997987f1e61a2bdc8bb0900460aa7b76f6753c1392899c0f394b369606287a6d45088be4d58b73a3763de556c76ffdaed8ad2445ef865c230164e3b438e5c801de62b0ede9752ddd7fbc8fed45b0cc61eebc22a36033361770fac6813ea5c18fd0e8dab8d532c8f9e2a6d8d003b68bc19282b10ab4f3b1cbbe0ed15402ba22bdbd687339c0dcbd4a4564a9410dd025375d0cd6c90ef104acb005cfc69a57a1d7d3086d719b57a3fce17bdfcceda8b6660db922069d4652e8bdb4641b02abe2a8f395d61f0d7e3cf94dcc669508b27922bf8718ffd1f45529f2d57123aceea7a62380c6069446a5307a4bc3f05389f4d7b8aa5b149d3950fc199691e6d44bac9529089311729c365b0992c1c35b364240ffca69bb773a4476d51d64cf18fcb67a8973cbb3f5b90dd98ec71834260f725455a7c10b0083d5369a6eaea780799aa6c0fff5119d0d82d8908b5cc28a78c262304f8453b0c2c6a0314e9d2b45cb9192b72220180c54b3886bbd5d83297ac00aa697685d846b517ba883e7d7d80755222ad6d0b7d366a83c065fd3b701f121eee530f0afed8ec42de58856f102a425a5a6b0a74a536bfd08981005cb755497fc05ee1b24c62a7c735ef249bf945705fa4d7a1949195069d3f22267ec4f685c0cc5982f88dea68fddc0637a34e167bc52fdb54faf172e627d213691c424a7b6556e6ae8891036808cb199b7038280fa61637c71134e1631db8295c6158d5de5051aa5617be75ca479a7b18b2b8e582c1a9c5fc8d7994a677e6938d599072dfd2953a97a5d9d890a2ab299a6ff30b271051b38361c007072b82bfb7d3133890c47d368c3e57931ea70e20379dcb8df590d14f4bc48bf1f88d061410104e6bcec55271f54c66a806cc5ba71b206be601ee76a07c1632eb05393af0ee685331ddf2a8532fc2ee20456f8208dea2e48c3a5bbb5f0cf49cfff6f6acf968b63ce407a9c4126a4ceb08f2ef610a91b2c4347ccc2c5bb92b94ba750de327e9d4fa8c46ca490504ff931fdbd8140951ce18ebdb3e359b80b586c4e340373d341b264f80055fb05ee87f822bd7c0d8b617f608335ecde9e961b3713e8f0b62ab187b06c5cfcd900692424eabcbdfbe744ee20ee3311d94bcb563879fe222b8aadf0aecd40f58e1218bdcb1fc3214c519011d4014600e73baffbff7325029b404415f79af67b20b328ff0723b8fb561de2372f8861af8e4a1646431a583c6233df94e5bf933d4250a6dd2879626029c4ddab40ef24d95b4cb0797fddb0d799c557656bf86f4611e100af996e620333a57f71cf7558a25b107dfff226856941c50ed6d6634122c1c4ffe6a0317df63a1cb1e0243aa87b1055b5edf38b348c10afedb94a125137363f797dd138d242f432fb6979e0b1f1a65a5197a748e5f4f808707f445cd4a04bfada92dbec820324e4206fd81bf552a21b69ed9e56fe949269acde58c04ae118459accaf041b633c58f5f2021e4f817f48a676d146a13524dec95b2d032d639ec467f59393eadd26f662c0aef61837ae4e39329ed015b151044f03f71af4f1b51e18cd2e95841d4fed2b8ad91699a811cf1a6bb4017c2dec770c96d59f30a9ba67762c485df4bbda1d0d1d2f8c1f83418abe0eb7d67acfcf92e931803c1b570470a923d16eb658adf8661a94f071befae11336652cd23b6ba7cf2b7f4eb6df4df67d29ac2880bea63278ae68219a8f9d1715ca3992f5a5b60c7a79e6b4cad86a8da9b05d1dbf51780013793d83634798cd7456bee71808a166eaf33caa9b8df07196517054517294d789ba318cb00a2446aa1d891c9b4f21351f761f5127cedf062aabf4624ad94fddbe195c6a975738ecea7d94bed4114ddb8c86efb95cfaa02afefff71b851f2c32478ca365c0329d651c6137fce33d96a33e33c03488babe85c384f3a58bd24afb55beb71ef5b0f4d29fcce22c72ef9f98e506cb5a2b920a0d8ccb403d7a5522f0c865e41c9f7227072c072032d9357b6ab3bfcff862be89318ad2c608c720c13ab9d764e9a510d07793260001f55ea249e29a90de373b53e0d6ad9e03db8888bea1d720ee9d35c1b689312e020c5a4112d093335f8e7d88ef7331cc1e26126fd0cb33ef27de89d5a02a68b4ccbe0290e664987c76a853c72dba2eeb171cd2a6de6b2f9912ef2e88d3f0ab6758004d5a77f63dfda9cfab7c92d40ffb512eb924c25e0791e41a49bf1cad519e1217ae276e684d0f960f65ab450a2a95017784cff1a88dffe022342f44d8991ca608206589e4e0ac8bc57796f95dd0063fc344c0e58f0852fd1e133fb16dc164253d3b20099cbcf656cb96659fdc985e7b9c0d1352ce8dcf2f5b8d3aa91fc5c2c8d283007e2e1a895d41fd5b706debd28492e224682129a2cf7f1d93ae24cee283783a624eabaabfa11cd61a818e21c6ceb71b79800ffa643c392214cd6ff46e705a730e28d912363b4d2df8edb22f6e389234892d14ea4ce1b96dee4b3070bcbf14da15d2215fab9f3f6d2335ac887608175466ed1dd7d6c4b47fc7d98c8bcce8633c79db9a79bc7076cd650eade19d2103536e86a7e2a6774f16604d26b86ecdad5e1d411cb1ba4318ca163ee8f846ddabe7791b10b2d03c0e5b9638b59fc835ffda622152c6a4211e4f941cbb098659cab3f3092c225a326830275d5a2580b77bbb8a753ab301de8b473c4454ceee6efc817afe6f133c862e8889d1e2eab56d259ca688c31319c2dd1170ad8c9313c050412ac56e65d2df35868fcd6a09e1ffe1d33386a224cbe466ec51230bc3575285c692225c652599acab0df3886c9e7aeb17295f16eb1674ec9f8122bc4b9a95a5debdee47c9dd2a26d17aff4f246996a822588ccf91ea53d3207a4cc31efc780204f9ddc91f99918f1957aaef3c3e79aa42b1f5785d6842e7e6c584ab56c39e9d9c42e63929b66e3e0d2d4b863589e0f20c5d1d1a175bd019b47de7acf8beb6cb8a1a44d02e8d33fbd8c475d13dd07f97d485e3c71090916d6f1fc93dfb5764ca9dffd20b0dbe92c669782669ca83dd342dd35939c42154c19e91db6051d934cbb85265a5d7b63086fdf49c4967aad8062d802910102b4978707eb9403c270b16c553c9ea768d9157cf7c57687ad0a7f4d0c4240b14f5b88bc6354db83691f82ab987de7f5601a2a351e167763a60da41976b5116c7ef0e1c49e3c6318ed748bab883a49fd5cc7118ba752e8616501ac9dbca9e229310b9f4ecc60c842c9670598fcb40a08edefbf302938a74208a5c838ab4786a0a7a134a96384fb3f23328cb731a8169a843fd6acb22a73d364617c5b265d61d6051a7535afec286d861a3bb15b926451c63c6bede058e1b23c7848c5afb1489cea2558134cdb8a6f48454b2f4ec7756130be32fcd6a66a965186c39f11f11d14a13b5020692dda60058b977aeafb50f26658b43074a45432b7e253b08ebd6c2151c94f4cbab033f7dd5a658fe6885c18e7efd67895cdc8e35159c733bd0357a3eeb1b0540de3b6a731cf1c922806cd855d774f1108053603d0c95526353ba8890786247baaaa0e542dc8a55cfb82136652429f0a1b57c66cab758173d24535699228a75e20ab1f24525222bd4794769e87d961e463c2983183666151828d67d1b63890e87adc7020319b79e595db730648cc8a1022dd9a3d8212ec4de16399b66f46013117374d9e0c0fded0292943e77a8f44a07c639247e93d217ac42749898b9b296d0eb5de0ce4004f2c466c8477b3877096b7f347fca691fe713e4052016389e0b57185cf112425f370b9af73f92d10e55101857b0e64f7687aaf3bdd3a893ce31d111980de915dd1ae209d81dacb77351a44e3a7b80d400030190832fa61e84643d98bbfe44df089ba2d8c93934c251ba32318b02a283f9ba4bd7ca427758f75f74b6e4583d429fb312cde50724e9f22110ef409c40d83e6101a6945b1e1199a0275b66b3284d2b5c2ff144ee56ca767cc25c99290f99a87164f32e7b79650c2830354941ce33409d8621a829fe7813b73780645d4272f7d139c6320830c042a102fdd3cb1b35d8cada196b1437763fb8824c693fe5c8e2f012c748865888e0b21aa13e4bf8da0eb7b89974ef0226cedbee2b3f8e5662a3bc0b257063eae9e5cd2737c02ce7a873a51c7262079382f30a8b68d3ddc3fa4f01e73b660bc80fd5697b8034bb791e13d7fbabd46ae113984b157b8284d5fac6e56383c15670ed2db71f245e23bbe74eded4f0521c992706976270eb735f33094e3c67e9596af5f8972fa46efa4e3a8d0bb286963361d5bdeebf23e9ffe92ce725f776e7eeff35c25e8bacd9ef407b500e8fd2ab415faba31b0bda185df5fd7bb7ea3a343bbbb870717a37fc9a26e30c1d4415d5dc0238a463839a2c904bb6f162646c448731163e8bbfdf46f974a7a3f7956921be8c5002daf688b20ad096301a8d53195b92ee45a24237db6a636493a13c298a7d3cbaf85231e353fa1341ebab98c23b43dc76b5bf5d329c415460be5e0a8015aaa4feb26240303e2c20040144cf69267ec7e163b508309ab6119ada45da980a007b055037d72b44027cc9f1f956d53cd9d5e59902c191e092075b3cb51aaec0571b3291ce29bf5eee837a545f15a6ebf684e1f5ba33af0873c908b24cfb35c73c4473ca005eab4166a167a57207d1ae853e6f60f6e2d6c36c5e52fbb05c487cdc0f46ba8a4bbea865023e9e73ff6f76a3b9960fc2799c2c289ad71ece01084c1661616eceef3bfcbe0ca3b00a926cf267599240eeffbb63510ca6b1b82215b18d014f8244e23ba8d66fa0349c12c15f0b31be848ad1454bf985da4d79e9463221e020d26257e879e644b9d68bbfe424ad53dcf8ab9dfe9928af5f69d571da72af46cedb2705f42d4efea2a4c7f672f47f0fcfec4974e36a5c5d3709608b8d686361aa4ecb7506dba91810b6711fc228ce739a12fa69753b8c51f92a7dc738f57729dcb1fcfbac3f46951802f1f57449b8d3cfe09cadf715548405e2c9955d73eaa084719237e125b93d2eb5576dc93e584a831253817b743ba20fe660e50c053cd1d11897f94853013b6f8527636859dbac1592b51120812b36a498646271174e4fcc51b3cd9b50da349516cd6da6772f32382721b1c07c90d0eed3b1106cc502ade9bb8ea8b8cc83bd2330f9317d4813466360736c73bdcd4536c87e2ee820e6d99083bf7f615b66085bbaf89e537443540705df3b7d1b5c59072363790f47d7dd27a6e4090873b645efb1b7c42daa52c58fbb81afc37aa4c1901a3afa7680328027e4338e80c5f0804de8fb3e4b9c1316807c309e5ea6987d4101a2148738cc27bcbbf19776f4639cf58462babecfb0ccf2343af1fafa5d7e3ce9da5fbfda4a805bd12458b956eb6d7ac3f8a3a7c3ed99554e4757514fc5ab7480db226ac346ec10d366bdec8834a90b968e232485244a0e0ea2f662e7c52c74d641d36f82d38954820536413fc2fab60e0cabcb9de266f644d6e70e5cd0b26615b14090b9ba8cfb69bf1bfb06802b7d254bf4c6306687c91f02ff9ffaf8c9a2f9ece5f84fffc07927404825ebc9ee00a6d6251e88b6cde42d8ef906d4fb8bd9fd3215ba452602cda7f3e982a5368d7984f224b31ddb4155a10f9f76522c9ffcfb51a3ac83101fd06b03db8bed7b5f034ef479a354026eb064a6d34cd2b4b50c9d03cfeb93c6bd8d8e5fdee2421008f1b669dd1cd16813feddcd8576463273c42c9961b5486aef9ae2a31621aee95f428446fcbd84299d4a319863ae55b4506ab21b997b150fbc938b526615b4ecf545228116585cf4e2f3daf13aa1457bfed9caf8972add8ca89e4672203e2e4d88b837420184ed412727c955d2e06d58be5ddbd5091426cd2d57d86cf8e7dd7f03cd3c013e1ce5783bf62a12db6b452678e2d858bdd7e3895d8f40dea2436159fb3a174fe5316162e7b8fc1e3ae6822f1531436b710a7e0c7dbf089d8795dd1b6b8e7d098c32357063cfecd924a663c52daed4450b140fce8e0d50daf195a57bfa22a0008d0c2afbc33e9a0209eef559c7452a9ec0c97f45ecef926a36371bd411151da90f54c102423c77023114b8732e9fd515a765089ba7c4721a8d24f1cf76bdff1acaf803fd9df23c5f23c219c27add3af4ddcdcd7274df951a72bf29649b0742bc308152ade9938063666c199598dfc0b55898a5d1015a47976a0425b2c5fda2b6bbe982754461fc8e8c93433530219194b01b9de4ae9fd55748a6b788257e803e4ba39c56a2e8d41d49c2d04511973a9054a3fd836ce4cef4ace4a92089da3e8617a1a4d50a84d8dae1de52c89583b2a5e1f0228ba2f15566917458f4708645f617728c4c15efe94add100cedec023e758b5fc30069cb0457b07dd2b54ef3e690623a71375afc30ee6a2970a1c43f9ec19bf4ad97acd2738276b2095c679a6a18f0b13e1727b66f541a5b8dcc39e44f4646363f677c8cd859cfd5690afe0acc19619b0775ce0267aa415b46366213442fce29b27a6f44d450bc2d86ed11f92459dd3c62d5f7be91901facaa4897f81e6346823f374b32d8baec647a1e0d5a8dcb46a49c829b26e1cd84fdc2f2f2b88c399045593377732c4f2686dfcd70f26c7b207b133b78c1001b16a290c034487a60240cd7545b28661cde559926e91aa562b04ff610e64aad66e8c9a19e4f715ec97263e30528369fe8c13062a6e379767847edf7049e57f5cd80b9f901f6c62a10012e7c7e3285252cbc14ea6dc81a61585f144a772e9570848acfe258bbb102b2a9c4936fbb41129a2f082b893693836b4634ee49c64e30495e06cd4a8c3e4757896a32267f846b09d9b1190d6b44e6b7d00d12dd1d646406a7a769025401918a8da86442c8f408f61ab2021dc0b750060fcd57ef3059c838c7565957218a6a8abf286088f0c3bc735c35f97c5b63d9252bfbc16e516ee6fcac8d4b4c8a53135e71338bfb44011bad4c6c0f43b834ed6e86ab8b0cfeb224ef837fdcb3f46a008da7a65b58e224bef58a75eb79ba1f2a06dc61c5c566999f2f637ccb6bc45a8793fc19d5d36deb038333c50a134a71aa9d132e51eff8b8007ee6b0fd3eeb4d85459aad8b168970c79964684fa041051eb3e1ec29f9c8124488ffd1d0db0d8c5dc688818513a4b6949372df9c8d27c774c2096556a4559cd0a44ba28cf105ae39fe443f2d4285e56f4e3cd160a8b1f67ba6e1e8073f1d4d20329466b673e9f7cae63ef5ece252f62d67a8aaae008ae6176468e4b758a43b61bdc2dff698df415e0b4b1605d6ea5ea18561c97e30c61f3974aa02a634722612307398fe80729706594dfc554553efb76e454e24c0496fbfa3fa549c10918ab4414a8ae7454595cb3cab9744c23a414a15eb2eef0a7b3c86928dc21c0e08914c2788258545453938507896bde25ae2a4e5068e29d44f3b66139572734b66e124184b7baab5f0c2c39fbc68f016b604c1fb6769f965f231e2aaaba35d856d4c014227e76c130a1e5352d267ac83e9684fb2723d4a9d3944e5fa99900dc360cbdd4fe356d379caf81d5a32ab49f6d35312a8a5bcfb29efbb0a0469cd79280518359292351d76b5095f31cbc2af7d6308a2148fbc94a7dcc7859c23d07de41b3a335930c7f56c0d3d88e159008a3f5d7fbc338eb054e665a9c2d91e1ed7a7e14e60224731dc492ffef8b8c80d70fe6d4bbfdb61782ed0a522ff9061f407f81cab196b2a7d013f9121dcb1f22920d09f26a6f5071a1dacb373561ecfc9bb3b9a5ed146f3c9538b0d03eeae8b8e5cd31dc421e01392f8323ca83257a007741fd4b76ce4c3f1a2784a9e2a384befd2a37201c432185dd49e91b7a7946e22a3bbb388e008eb823c887c72301fcecbe7198b6e525ef19ce682974abc47308c140507d7cc74cc5211842efcc450330b51376bb4134f57772427879c33d110009ae42a57f3dbef21ccfb33448acb5d254eacc0bdb876cd8d2f2621f36e65d58d9687ed7edb3dbfb7373e5fbc578960a5c8afa0cae562a4b0ec395c29d2ee355538804550f57dae944a6c6fad1cfc7147429f023b67a69691881e10b4ce65e21f5a9044f2bf0a2c2d9f03c6d64af215d4e61b96268575d5c42c662a5a8222a19f3f362bdd3233c3a77cb804818b2ca8c1b80e880da879b72208919902609fa96e5257e7ddb73f16a9ad371758d9f3feda5db3ffebc3230d2036f971b79d4063ab7e1739fe078fd7ed2f3577a7d7f775609ccd181a7b7b986167aa6bacef74923bb4ecae44b735045c15af833973e39155069f08dc99abf7a557203a0f8caa6bedd98bf069cd33c6fc94e8b7354b2dcdddcf4ac094bdb5a5a0f432640edda1c899221e390ac1cbb6a13fb0ab3c58698ec11d68ee46868908f9273c09760c6f7735add1fb138235439501a58dd5155f946107b773ca8d7f5452d27bac9323cc8c226a086c793fb937a9b3e8772f5a1193e5d530e47ee4304dfa289102da5f4bd863fae94aad140d953b6dc9a08d569fb84abe5405b3aa7a811d38f322913d6d4872102bbad0faf4a9edcce15a495c59460a1eee39a770441a53ad82a3922f0b8d5c6478974950317e15ea1c576e69b8cac6994b2f6280a50d8d8259349cc814178daeb088ef7486c315ee91d1ba3c897065c84967a7a07bb23d44ec039ed1b3d77b321baf330a809e7bf81a97245729aab8366a9208a5106a34cb59fdd2aa2b91871477a319045181db6fe7d91d63f86aeedcccda4aa74ee6ebdefee29d8d7d2d71e00974af1b70429ec56ba2196d64fab30ef946306ee7009575843814c68b61af779c00dcf8ddd04e6af8a31ca288ef0910d0bb1d27cbb75c35996b92c581b3e2945231c7b9debb5d1b982fdb133608fad72ee443f711711b7c73ff1c12c45f8a4a11c629a494682186df550608b586078a0f741626e3820ab72ce96e669a303f01b8cc1fbd526056ad401b44c6b3b17fc56cec0e75576d71be21e257226806a6775415f83cb08fba245908cc1d7e7664af226f654724301e784439d61d4c9929da6263c4117c91e93f7d75fa786cbce7c90712e1bba15142fce32ff6d144f9b678f4da7b67ea36cc02647aa56ef04b4b8181e19a0a7075314b3fc4ecc68df544d6dd951372ad2738d683c6678729d1f3b65310628c4c09cf75f8792e60e31788c1fbe985a5de24b3db58158fa6a86505fe421f492309964977f4d3225c826e720dd4d8f6701b6438e1713108aea79101ac2e5a680d1249f391022ce77369406cc7ba28b042f4e910cb0631651627291b226c2cbb795d812afaa311de559348ac9d9eaa5f6a74e37e1fb57f8fce9f243472929033c590a72ef7f0a90251681892dcde2282d86d40e1c5d20abb509c779a34dba95200ccd84f502d40b76d8790f5201c7d19bdbc36d334ce4f04b205a8696bbc8f9978948b48d911e90bc6e66e9a992691f32da6fcbc7ace65eee22cb68ab2d4d25f06e5f07852eab3e307597be12d34f9b385413705697afc6e2dc96942565f18696ff7862f1a051b34dc0f77683135b859c1cede51e873051ac2c5733f325ef9f58917ed4de643cdbddd75df67f173647b515bdbc445e4477f6a3392dcee5fb590490b95ae1dd2c8b7349bc979c3ab2460abdde27ac59d2fad049f6ef3c2da26dc874637fdf41dbbdbf10ac113a4aa74c327c6e64e6234f17188924cafcc0f3cdf53b8a02315703dc668ae465be8e8663d206d2871d473da4a9da58c7a8c1837f42360d599efbf9adff4630289126192ec1687b554c33b19cb83b5bc6d81e2f2a191784a3873ef9258662f424ae9c8c45c09d48954552a2c7178bb0264db7557de865c4d3f4f2f802b6db1d9751249c69897c461d828a53311e4631aa4f37ce98bd61dfaa66e5288b708022920ef47c1894f5fd42bde5c39177611f44240634d198c451fef0de915d583c2eb53e1fc26e2e9aded03f545ad098f0ca21568d44e615cdbbd8b939331a95c989815b8e35530792382385cebea80e5316c4620b6db19d698cbe080fefdadd9316c9d5800bd2aa56a3587010e5154f7594b39ffee7ca9d2e903d72ac1b66529034c17f32b3bd6b816f74d2248efbd395bffec641eff00759fbf0994e41e34c4ac263eeee34de698ef34a26e678d59660f8bd380f7ae1027f525d56958363aa7808f3be42e589199321420d3931d9f0c56011ae8a0ca3ea774438d29fc1b81487564e75253d59dcc08eb5f1e1c44f3e4bd60fcde260c258398039bf700954c7c29af7dfdcbea7a3cabee2e31fe890b8f4f2c45376515bd3aee4419833a764d2354954cd64f450b9d3478fc25f072ad6184f48c8158ec0a331e1f049e2d86cb763cd5347aaaaa8f9050605653324c8654008c10a4583e5619d4ab2f095797adfbdc13c19d4b0e1327d00b686e272167106b0fec4dd0f865908f000e57948962841c2b81ee634ec2d10c8586b2ecbf92b62afa0d71cbcdb4c0b00d9a50519648c0c495d0f30c715b5ebc1644d027923bed747caa7dd713e58d3d7fd342627776f908934c5195395a6f0edbceb5b5f5d0a7f0cceb831c73b75d025b29fd626036f0a47e22bcddb07a9dab89432669cb14e7aff4bc66160d7df7c74e36288b418d07c28f8990999d901d7ab7c09f709c8e65bb49235e1ab774342fb34771d9652e1c179d83e4852e3370943676b72a49dc61080797c57db3beeb2213e2724f86b32443c4de7be2ac419666466bf4bb0d8b15ebe3f7b569077d5a9c1d079fc5a5cbdd498699119d2fd33bbd767b910216d32a5bcc00d19d8ed4c5d2601dbf7ef6c743fd1c168a088c8d6f59bd859b90c9ba4d629459b0dd801de22f37ca1c2fef7b0b16d12cda4509ddd1515ac583371921e3d8e0b48dc8e50ad02f1945499d9dd13ec7fd509f8e647e4596b95a84bb3fdd2235da1cea923c4ee6138d5ed3dfaf9396502c594021c10aed017a3ee1711bb0e954a68fb2ff41f65f76ce6b77a5a563a1c812fc7cacc9ceb79d15f7baca03078ef7092a51969f61ef1ba401c6ea6dc56bae9caf52a55962e65df9b7d9893f86412f3acb54f96918b679873f717a639667278b96328b0e6aebf6da7f2ad9114220ba34d76a61949a2eab7e01d81c9be085d025a14218a67278b5638fa390f7c1e17a9d04c9d9b66c6ef7d4da9638e1f60a70257f69eadc24ade8dd82c30cd5c4ff814f5e699f3714250f0b0c1b281a0ba6d21a1c2488d2ad725250750fb2215a2515a87a90416fffb2f5bd941538797c0e3ad570848a7843857da427a34eb22f2935d5856b873917bde182a9958722d7014c284a80f43598cd7ddb9c38734047773142b4b5479bb5b47f19263a332cb69fe2315ccd94ed454ee0d0c6e595e2c3283da97537a1e630a611dcc642816b6e584b5619999b0dfe9ad6db264ad4a1bab94b5eca3882cff3df9bddb9dacab46d0b7427bef924da6dd5a09b6538aa08f0c30cf01c10b4deacc55a0b544fec388883722f3eeb603ee0573dd500dd884b5cc61a2e7be5f28c7d12b502fbca00e6b57ea9ea78174aa55a266e66d035475717b69938e57a29f5d4622bfbca4d5b335fefcfd5202efcfee91b1579d631027fadb6ef32360123cd036576c4fe7c971124e016f57f3ecaf8c7c1f000efbd180f315e8d9ec47f368e92b636b22d37ce1692b96677861fab77670f105350be3bf16e147aa53d3ef1799facf8fe93dadd8741d134a2a31efaabc04f747fd50610d85330d7d993d83e9e266c4410443f8e13852d891d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
