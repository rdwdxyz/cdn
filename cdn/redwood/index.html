<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ec62485ff108f734a8dd12196bda5764a8381508974a67d158f379fd4a95e43310121653ccabe77608fb1d41641d2ea4f44a87042df8bd8138e60acea89ba3c6a3487074e75afd04cab75f6256cbf94f0041413d33311c6eed8acd3d0938012f9c25ddd7c91e8cf4ba4af6c7f4572539cb2c9a23ba402cb7dd763fa18590de0652141629599b556e4afe55943d8ec2d734906f99fcfeb0a445cd276f71f09178d0580e22d2e249bc3d82959e23a77dd756d41ba2ea54ea634f5173d91fb9e58718b41621e8590f2dfc6eb5f7ae88b4e324df22d60ce23b5590dd01df21d5e6d642cf56f007682b23d1ed1127b18c514da7ee46d628f52a4f8880f02a41cd7111f4cba94aadeb1d28115b7a4ac2acc26da87866ce6fbe8e517a6b7d944de39332f3e84b5a840193d68b83dcb92476c6a3b99d76aad34861e48762726d4a9e6510539040c1d1130e41f33faa6a6e7ae5b2d9a9aed6d8e65d390f1fa595260e036a131b8e6e915e90f2bcc025ed7f3a438a8b792340b1baf3e5fdf29a441181ceaa7e4ea28592beb1f333cf2e219dbe6ec75a87814656dff683c4ee64f0749d5ab8516675c340d655e3d5edd97cc431eb5a9b037a869daa9a026e6659a07040f48be94311b05d3051d95c3ed0ca45756fe7dfb6acf6f4fcc591557e5c481e872c6dc621504309d0897e14780ea2a7583d8291db366406972164daeecc7be3b6925493a06770084fdde92d4310a080e4df160a00aa635dd66965e145d1427475b0730e5ca7dfd5a4bcf70e272d4e10a8e90260fcaa1118c771861e7e6bbba8d6117af1e74e23bba0cc8087f2d2064edfc9033654c2ea0cf05db657947ccd1c83040b85e5acdf6cfc3a8c49039d978c00bb5668d90422c6e98f6d2cb149317d0d7d7d9002501c7d6f08c213d94756cf4f91a9d8741527fc291b63f68d7722fdc60fd63eb73c60f9a22ddf1c4beca3a73f1d0bb440dedc088e37a4f6d0d58da52f26453fdc84cbb6ed791f2faeb7585417976c3bb033839e6689bbac0d37dba3a6ad4fafe31feaee83674af6852063b2c546ddf89c139dfc5a15acc8dcae049edbb878fc645b4d2919278f40ed2c2e1669e68941d26cd9a1bb21b98a4c24a088403519715e6f286d61e4ec0e93eca62401139587f3a064b4e5c2b487b041ed73f6e791359017800ff46dbbf57d81ca76cc7db81f65cc8ece24181d11d6784244fa5d4584122f6244bb34f0bf1ffbe855c615b08702d4ba5388ebd3dc0601e10dd3c827aa5225c95c34d3663cfcd0765f9c10a37e839f1b0d6627cf83c7c5236288e19fdb5a8b67b7a5b81d7be9a081978b8dce5ee1fee567b80b8426251304c24950876788b2825825eb554659dae4d253a5d4ed09fcd7dae55461a913a85d746499707ce859d6a117e53005e40e43405dfc32712c2fe95d195cb0e5619621360152200ba18af899afae29b6640c51d9240e4b29e3116e0fc61f392451610e2138326ea824d8d89cb6b04d6cee23630f814fb55da48297ec1df8e9daafe7bd8112058777ba729793419fdfaaae3308c0404a99ce37e57e047eff21a8eaf318a8140f6b10f9df40b90b9f8013148e86e764bd043165a5bc198ed44dcb57826e7ea07d48b3a76bd927c1e1af0b6f841ec23f179fa861852b45f215714cedc959ed4e91162df0cf9df7076c66f1cd11d0a9edb9fd1b92f03930bfcc6dcd127c17371ca5baa3e15941414490fc6e37f53933eb0e9befbba0a055c7d6e6fcd8c36dd18a1bcb8d6df01cffd871b4c81f2c892c18800536ee483378fbc616389173a4146b089e1919617f961b9feaa38bb741842255ca434e330d27c2ad2468dd3cdc9b6b47ba2712e595792711f5802abee5650854d62118de667f0aed03694ebf4d498b3bd89867edbd20527b5ef87312eb9aa9a7dbd5a1c5a481dc01abc213540f9b58bc7c204c1983434370444ef0b6c1170c67e5be899bb08ec5098cb845700df3750c1b29ceb835f0dc16b5446e1b3e2b79010059d7ee15eddc85c3d1f2b642b13a6e4ac72013269c666d25f7b763f2157b932a0b8ac5e7143da8e7873ba0182006225ab129d1605616de519a45ee4d4c392f83d542d1c78c696cc0ed5443b0692c7606a4201efcfe17e30505da8f8f93b5abd69aa9e0c01c3125a19e3fb059030ff70b38ca9ba777ae0b41dfe70256b8192e6cae0c2727755083546e460c8405cbb353b1f8e8ebbf9d02bfb4277f78df4bd7a022cd0bf0f0f589896da3c7b0039afc1c218a21652ed2aef07af4253f3433013f94d276918fb0ae917c684733ad95a6077a0964978e36ec54a36f7e8152f81754d7aab5e50e41335618ec5e06080813d71d1627ddbb5e5553465aa46aa77eb2ffa4c780ee18a323c796fcc9425d93114c1828fd2bde4e37bfdc1c23850e3106c0fac108d945139b5c01e2026fa89af0f823f68b860f3a155c3e8db3539ef3fa20d05e35faeb0600d3af62dcc45371b8a2fbb2538d3fdb88224a92c50c599bbf3910e6171e407fb2761b287d48bcb532ea640d648e97eb3eb2e77ae66926353bc1cdc358cce5d79fc7dd1a919c0450aa7683ef10745627e82c6a5d8b67da4e50b760d132a96e3c46016cffc282b8bbfcd4f4ea939be04c4dbc00cba7e72f2f4599a2274501525a062b57b9baa89621cba8ad90d83aaf01a15b67884cface827213b70ffa561fe036f0547d78ae0878266424e65bd921900f118f3b9ea5e1d571b805e14f63b41cc5fc20ca1edbe1b4b61b91cce6fc4e696ed87b79245e2142ddc12e1997e981c16e1b0db55f84893b4f48b131234f00cca0fe8bba98b2db557d79b9b788662e7f8350e4b4b97eb5b222b42e3b071559de225bfc89aa603f38cda89d205b31599c80ee44a742b215a633ac24297b1cb40ab8deb3ed00abef37c817a378a3e0d73f382cadc0587ba2ccf41e8f651cc93901572948476d35c5a344253174080b9ec11c7895c4d536f6509551f5003e6b82726a3ad6869473a306173e9071dd300cae6bece41c8c90525a4ec259c70416524b14907c356b708474efed55b2364a096b8b0025699223dfbab96dc8a57f4b00e5450d7d0bff343642160d828f75f072a73bd974e6d2d8eb9b7fb7ad9dbfe5a365ba34506ea5288ddd056176fd6d6d767f29324b712b9be3d05e4ebc9c7fcb8569bd1698cd24c42969d0a9027dfd0f4ed243af2c233fa81deb7da590094bc008f9857d2ad245036cf090fa433df422b765736712e9ab6fd46c00c1dc334c0823567e7e8370921da34d07bd17e47f793f404f527f4de464cc035a53e0e4eeb3a1ebb35cb5588e486d0d55792f81adbc007ba218edaf429fff833e3cd9f51fd3b916ce4e54b82c3c79de477c28f22831a76198e159a3ba9fe172eefd3f9bf33e83fcf02a8fdd7ded5a1893c38b1c0980a88058350d49a21a501968b60af18aa23aadd3ec2a1b612cab6285feb650645a93d1500e5d00ef02d4a4271d678c94e45244aea9a082907fcc0a64a432774ab70bf7273f76b115e6b44a1e5db41bd5607919d56a7d87b2afdfe1c266ec132ed0e53bcb1b7814be497767ff8ccd9c74fba555776cf374edf504ff72fb87ae40b2b8016316ef56493d2bdac6decd6c1f229661a29cde05bec5623b2635bd6ea76ceab2444c894453ddfb1f60b5f19121aa6d9b074d2b675018949c222b06e9c71422b659d0a1b9665ede544675c93bc0fd710816a3c15483d445da7f704bc4182d0a986feaf009e29ab3fa35af93788bf6229e7e699069bead85069c2558308699a9ace894a8c4e8e2f8627198ca4134fbc669ba50eb91a89baad19d9fdb5b8e6b2f3e03113882a411514e522bcfeeb328b2e0723deb1e02895f471ecd9ee68ee8a779fc4da7c46a02985dcaa5c69b59600fa35500362a4b4d19ea8f948eeaba38add16bb87817ae60568900f521bef9a6a39dca635feba88812d8ccb1aaeb59eb75e9835c1d0eed61a52f9f246625f8335f83bc6628d43b1030bf99a5648a0e8a24d2548926d7956a708ccfaf0198aa202031926c730ac5a865f70d9e95ab82cc1c3f62c284526408e698aa22271a0d1c89ccd1c7c8d228efd437c09fed001bbeff7562f69cbf4a91ebc0b48239e029e04330889ec7c0f9bd43430b602d392da993cb780d30e533d2262b81468f44ba0dd15128b235e09e25619fb6a519294e4b0914f02bb25bb1b45072c8e8c7a58e4ccd49f641b8f2c64a9e19b4bce2982323d1660e6f95bd97daa8484690bd5845b15cdc98dc53823a91118d0ce7e96fcad35e89ea38217aefb059234c16e4b60206d5977329d4960804fd0d82066920c4aa1689249fef0c0b1538b4b03b257a55b46aa277e9d898f9c6139412422165c0dc4867c4079f7538bc10d2a31761a83652256197a985835525ae738a4e292887c3c8cce210d3fd81a5e43d8795acd00eec23136d7981762519cf771b98ae958c0d7f731d92a0b7d6160f25da6935992346deb0053cb5a6307c5b1ea84f4e23175a79a76d9b252eaf52d28d50d6128c96b51536d2e51e6a43caa52b59188c298d886a634d39659f9b0e5042730f6858e00b45ee15c7b7336b501d14a807cf3832e27b5803aded6eeb6682c9300bb4f93b7925da51f32bc4ce9934217a65c029f3a452633f7476787c1499ee7d7698b9bce077ac9cf32c7023f4703108645af84594994b21686f1686ea7c099ab8d703eba31ae7797819429ffcfa00c8c2d31853783d871f29e100f4ac40e2ca05fb87d449bb9c38e50db0614146f299c4e346b82ebc5db0c99cf815ddb3b44f6793b43a5d73b93f4ea91a0d23e7284fe17ba90a8710166e68f4beeef384ffa33d4d6a5f7186d6581f53aef604b4a45254d34bcb7e67580a8e76ab597ab2d283031ab9e616a04d4c4668fc272511d9ce324ae003ad9adc3c90f3a8af184517339596a95648a9d03fbb602a6de091f548cd80f034648b9cd70fb9722f22105974580f510df5543c173229868e8a02af7702dd9b6297c9b88d2895fdb19518332e6d2d91e6efa922999c15cf028620be46a8ecbea95938f47f5884d4cfba3da117e3aaf7de05179088ae48e94be000fb8ec665cddd3e690679e2f773efbcf0bf85c55a6eb2cde21053031c53dea9fa63c5e78335daf30791e25888086512e8745ae86f1a4c84ded3b0372306433c49cb0a6e07c71ecc2fcf89a9e1c8648416c343ae76bb94149aecad5f60a5edff70206c2f253a1936a7beb9130c475a8edf08047f2531cdbbcba9b2cc94a4996bd0c4bd246811d92ba7ad475f697e9fc4cb6e6e49fc32f31d7c4512a35facc978806531c72a928da6193438d3819dc5456e5a1fc4075e76ffcdb9d36664053b9f5ff9006f979f10b509e79099c1400462b99f90ea10d1d4c39710549a14a2258e829a85e2fb11bbefaa7f1b893428ef461a44c5c3c392a68e42705ad0d38ebf8236100135150df5d29e7cf2922282dd45267116fa93ed4f6efb561437fb30c47d211b87a60494a32910a11ac567a3c0efc320627dfb188501c30e53ba6c9fb37945d11f9cc6b5b2fdb940540cc566d37b40e2bc6e3ba602eb3ff3439ef029ac1cb696f8c689fb524263086d0779f98491c1d943021b25f4cc4869c2ce3f0c3e5b91ea5bace808af2e0c8b865a6ece5fed3456651ebb839cffcaf2aa7d31703b20a3c593d04361ac31d0af7d9de6a626f9118c61bb6acda2d0ad65fe985184a2aa721a48ec3d00f76459505e39e097c300daf4758b4c93cfddb802476cb5128d6abe9cf54f3676153784e37d226f19fab3b3b343fc144458acfe9b6a89623c8edd5939d2ee7f2e6044e749925d04fe4f4eead3a2dc7ff2751f95c20771aa5ec8f9b7628a0ca5534975c8336a5d8a7e3231f0769c98fbf3d0cf727d7d963e8804aa868002d167b19349ae24796423e3b56eebbc322420e4e845ba410b18155b0edcbf29db085475b3c2371165097702aba1dd0f86fb84700e213eef8b99b91347b5a1fad7a577e09fc61cf710cc71cd300663f7cad54f94861afbd3c77c2ca754b15ffbfdd76ce3e81cebaaabdb0bb608092cd44d04314e29a2a8e8ca3153f3e92ca69977dce9f07f8a3acff1de394cb0935ee3ea732b778870a3c435b13c88df0f645eee51d69a1ab3fee9e2d94175fef9b4c8b2dadf14d1817a91ab991fe4705a306c9671056316a7eda969359b2492eda9ff470ae5e7082f8997f868457a28928cdb43dbca41bdcc4f9fa85a42d2200cc7daeffccc4c780ba24a34ead307942f63f01f70ba107c823534fb1b1d9d822474f43052686c66f8e5f7e2d0269164dbffb2bdf39af3b3b42f7e41118e21cacc138618618acb72e7151fa7949fa78b2955bf028a7dafb2b9ddcfb867de4723f4c8e1304317e960538aace45364f2e9061f296d483b9bdb251e0a84889b13d506a8872a2d9d6b3f0213638fd0021294ed53370cf62d8ab2a3aa35f9d5afd25c2ac07ae0c3c0483f8bc48d912bd4c34196688e0fce9056047f8d4765e8127eed116b26e5dc8fdeaed2b318db2650ebb94f4ef061e4b564a1fbf872a3c234226662a0798c4f46d85f66ccc40f7d56ffe1f7553bdd0dd8005c12a3243dfca2079ad50bc3ca461f495d6853117276f14805f4323d98d9d84e1ab4b7579a30b6ea6365d5dd3fc9a3e1a64be720d6de99ac543c64212adc6b20a904962feac7f04eaaa9f5378353f80b9deac0d9a75636044406b5a662cda62b971303d12a8ac5a933166b0b7aff1d548bc03b8c0df3cfa3a722a40416210e8c3e773f4a0e081c474b942484d1d06244998ccccde40afad20c213d2e29d71e998effc4d4c916b21cc046faa403a2a1621e6bf12d0760e6128820bc8e710d422906d382e8864fc925563c816f46be1abd6d643681c1a9a3feccf40415d1a2a9d1c24222c074962be25ba81a6e14969ede2590250e9c6e8cbcefcb08431a115583a2bcb7316009b8d056d7bf4acbef5a275c84d621629a3dc1a1e1b89f359696863b8545a271c92d035005881ba79cc71f87dc7254e428937e93566b10ee5e85146c395e06670522a520798eef9805374c861dea6cb16da6522bc1ee87b3efff5b54cacb888880dcde771b4f7be46745aea75cec0c5cc268a790fb05d1a5794b7bbc8801a919e0c126d74d16c312eb2f08fde7d9ab6e7fcf36b498f2bc79989fc3a530e287ddd2dd8b87d852365027288e4b06eaa0b1830916426f689d8ff214e37cee54ebdd4b7cd1cd34bf83d1a8664b46a3a5e967cc3ec426b78b302b366fbbde51ec507e4d04ada74896624fc1f736638f84edb6c08a5481d3a6014a1310c8eb53302465d1f52eda69f10fa845c68bbd7370193070d0964919da85c6bb656f5a4eca3d1adb85760d238d02c8e9571772044c8189c56ea9edb112fedcd6e44f29d91383841158823e6497f38c16856d9be33ca03fd7d7d48a69c7dfef4fb8f25e1c0ed096461e28e36e5d3ecf6ab6b5974cef1c805f112c45dbfc2da96120d56a4e860d0326055890b621a8d77b9c9282b8901aa542d6c56447ff806eb816b88b6ce3365b1a222d63261eec7748e7a2b7be1fe65fa4e22550a8bd6a2ecdfad3ce9ddb13e4b631623f61b038dbcac437456af281404b04f045ad7d921540db221b422ec1d7d4105374e0cd5f6b4f1bf0313a206d3475abc392411083d7c4c50966ca87629bd9e1d3c2dda9df3bce4f566f9cea1a956777550a815360248d957d046653f62e4b6a6e0586bab216b6ec4e94e8c49a420e02364477ea95191bf54d25f59692b1d53e26e9f152330b66dc5f4fdc964adf6def0121f5199cebca99505761f06936140cf4e611ee76815e43f1b07c42e30f45eeb24e72f133774ba0318c76d4885637683f90218513c194b814d9f7370f8632faf5c49b445b9347b4557079773788f2f8c891a535cac81d01a2be24c80e417d9b3c40685ca9129321769a87f93f55f9fc5380537e207f82e53a52d4dce6397a5d62ecd0d4a9099bdeb3e7b8094c9b1ee35e3d00fdf99e4eedfeceadbb8de9da4e9b442d8883c5284f044396ffa45b278cd19c24f71c0320257f119aeb48c0759a8884c67f78108883cf28a09e0161254d867da1fa65ac9bed0860b6f4f014783b0c4a20bab620270f29268f73d7e107919c888b7b8abae1c74645e59a9e1f5d460dcc336584a8f16f18ff08fb734e22c2dc97616ff7b27bcf88d0e780e312da5c119202f3918611a286a3eb85345851469852aaa6702f3f8022e8c684bdfcbe3da39358773ce1c55cddd53121474282f04c04a0bd623abaabce80a141b07ecc2e3f9e1ec8177eb095145e407e7fcd1a019dea2c386ed3b02ccbd1a9b6cb365595d6a7e45d36458ca5cd91a21ed0ff115fbf197cd7532001db265c3ca8a524cb767da23e8ac97c093572f5a26abe8b630944de52ad607ff76f713bf7b783f67eea2b1b3998289ee17cfe4d4de4998c812bf484f9706e06b6e465a291b5c3851bb0a8af428585f9a7ebe9611729eb6bb4d099e475dd9c22232c4bb4cdb4ed0c8df4f1cf83ae00a113f40c6a3c16baf4e1d7f303c4b0236d6afef04e8a631b25f7fc5a145046ea85bc4518fee9b30f03863d92bc0bcc027116bfd4e726099eb2a2caab4cc44a57d104b215e19dd13aeb863fe2e8282ef77a32e8e892e8fda18538b3d1ccb27a76108306d76d64cca8f76a77074c7c1b75059be42c7ba48172ed1ddbbc73f143ed9440ddff8b7bc2e3782886edceb077c7713ea47dc0551261d5de91e374b7b1f19615748f996a64f689ce092b3a22654ae065b8198d6b6089c25cba59a72ed5f10acd2242ed7681474d38b89732bfbb4c03f9893d55fd256d74dd97ec7dd281090d90dda02cf4529d518f64f72972e36401d0be8803ca925a42a39254e0c3799d0bf5b3584aff03682337e8c1c7236971cd34614b710b657755e7bd1a25e99fabb201dd586881c72307422b7afd9cadfc3d95cf69c248a083cf97083bcafb50458660485b9f53db3c49619d105f941eea0fd81bdafef1f6480deffac99b1f19a3a2746a982ed419373963f5892919ebf873420cdef4720bc2c87044cbee635cd4d56957c5ea46b33655dd1040ea16534e5311c4786ffb914f4981307ceaf605fe48f76da69845e552cc0fedd190e42124cc383d327ea26307bfdfb5c85d506c7ae128e820207e6d8ea5391801d28570c0db66dcca467b20787ae61e6a5b5ee61ac24b42755a907a9c70a255b540b2f3d0cb9b9edb6531229fb872972abac3495e7eabaeb9d45a8dd843af0e7b0bbe9f141ce3cb014ac0aa840f3e238fe3eb4bafe2529e6ba73286545e1770bd502f6cea9d620a988eb53a15b0736b6d194a98299e950eb1789e858347e319fa1c068435f06993570c68ec0c91a4bacd73b462a6abb9a23393ddb2c0f0f52c83193f5f455ea14d7932679c55d2c6ce2c3cb9037add52e2b77dc38f148f031b98c34dcbe400bbc5ec6e09601cb7aa37e594a8ed49a9adcfbb9f61dde5a1f2a14a73e6c5c4a1a6da7642b3b55a419f49e0a027da651537e4f1542eb658adf5d5bdba1356634d91a9bf6f6a56687f22a41b105ed0d20102a603cd14882f1b3f26237d6f4b08e3858c73417af2a332254dadd8c73e78aae9120e0b410b04443cc6cc242e1334acd2f55eb1af34d291a87881a053b938d2d29d6e54971c2c18aee55f9b8e9e557d8a02725eb17502ea3fe0694eda4457254b5ddfeb2304c599a350d2fdf9a3afe8ca3e0da86dfc8665975e673e10d7788bf26702a2a4e8da368867e2a38d814501d2b39b8cde89c94fa1ee97703acb71f007b23dec92d6a329a40c89ff85932e8d5f9832363ccd6eb152338908f5bb3ddd585208ed73d90932419e7ab159728d7a3c6e2f95c5b26c69fc37f41d421d7b27a6ed2de56a30ee651cabe0696bf547d597310a971fc3879650e535f386f2525fb527a600cba2da2b37dbbabc9734f315d9bfaa8bceaf9f70c249abef000a48b0e7895267e82f70981f622b487e5041fc8448509ede4de72821715edef383d8448cb1517ed3513bf38662fc61e6f624201ca7e629e2d224a0a16b8372610032d69e686e503e964f4d0569b844122c106928e10001e2ae0a7c4394890c7b6b45718bc1b7b3f74754bf5c371b69de8e71dd2d8b28da7938ded6cef4517e4145b1c3f0b56c47f0e9d60edffd03250fc2eda298df7a28cfd34cff6e3e09039b260cb47a4c42b505f46a8ce2de51969ddaf46b5bd8e65a3bcb22cd62f98de6842272f64933ccb54052dee790ce7e7fb98357167ad1aee9242603a2a11ab47d354f4100498acb22e3ae1209f21a8e687ed6a134d155e409863de235d4c2bea7d4e89cd8d5c4033e2bafb65a57ce1ea9ce43a509e425624e4f0136342ff48a93c7f42a05bf32a2bb90dfb0d813623acaa3df0d7697ad188c7101e9b28dad2a9a21e6666915a26724578519c179b677148cc205b8b13aff887e2f91bd6b406646a6701b7101b27705018005e7796ecf42aa874acf6068d3b28fe7c88d44f84ef20a588e500ebc0edcf2c649e3e56722c9f9bd44f42d579aa8b7500942528631c50a7afcf17ad7b721e37c662a4823964a1c66ac98860ded517be7f14af84b82155d3984c6b903775d05dbd2a5590d40229351b08132910e2169a89de8353c9ffcad10885ffce2747013e463ccee91032f7919e111bf5a59cce9388ff2958b4e4d05eaa5ac40b89070af579b50a7e870fdbcbde56cc987947d8bc574354aeee6c5844e7b22b01d842fc6ad57c8eea225401ba5a15b56a453ac2e90d6c5eef19b7764a91ba219b213deb6ad9464d1cdd0efb9520bbda027bb1d6d0026b0b2209de5be0fc1d67cd604110cd429e359886e18fc5855ff88431485685b27a567ac56b161c8d3441278612d80a3f2c5837f7fc0a39d82c237f148f7e7bf896881e02315e1178e6833b5c6a697e56202d7f2718bdae46504a4ccb8c013481d916aebdbdfb772c975cbe131671f5d15a50bd401a0306e46cd3b1f93d2fe5b14024adc0f0fd412451a319b22344d43a6d118ecde23ba0c577397ebfad0d26c565bf47ee81b78cf48cddf9e6b3d3c8693bfbf2a51c0a0ceb6b79899f096416ade56f9815fe7ec4d8401c7a19951beae69a72d06d33875f728ba019fb605bc89524f5be7e94d10c919e2005ed2f11a98b6e1b8210bf29155d67ef18bbd210664ea0fab2db735252a7e64c346a7ba7e296a7711c160ddaac9195b11da5b91a000bac55415aa2f4ccc08244213d04a65c77e5650077ed639f05c0b884a2dd3d83f2780a410a5e248883be1ea9a2fa1e37f7b996e3c601715ac9783e4b22242a5440a7acc688afb9724a22430a741eee3bcfd69d0fcab0303522ced0d4b40eaeca74a57d42a41bd4c93de1228e77dccc44d0a1cea111e111b6077c2b704bbbf2415cb72956b988878a6f28a9e3f4f6690879e9d13859481f8fdbc84e172eb63489cfb6b5739f6e5b0f103842f32141a1aaa3f5beb6d45a164ff7f500ef415c3266e664ed08c38f24a2cecfe5e37fa01e1ceb7f832addf6fdf6cc910d7487eb8b193e42069dac18ded8da02f931d1996a9a0fce0ab435c248daa23c05139fbf7e621b8af4a3007e7fd62a05b592133617fdacc757358c63222ae49425b717f324ca6121debcd3b9fc95e1fab806ddfd538e445ba8dd6ab21996c82acf536fbc1e49663d555af46e24186a57c3bb08068876cdfb79c5533bbae286fae86bd73531bef6432ae56c5bafff7e11a078a0524cdf6b8699f7e89c2214c1ad4592ed992a61acb7d846cd8d4b1159b50c432c6fc03db0c1edb3f189bf4c3b84f3ee4c5eba1f7b9573261792162b0b7d1be90d0fb501cc01cc0248f0f247236375eba4eff5a9ba6492cd48ee8ac1d28e31a0f20ad555841fdb385d0aaa305d7eb5ac69132dc4c7e19c765ceaa11aa1f464b0fb7b8b148b35966d2902bfd06fd1f89351e4b282dcfbb88ef7eb19d9e0c0c1206588ddf2aec468a9201a3d1c0c03bbfe028dab6364ffa6a2e90913649239a16808790dc1e06244ae3715c0a4a2137bb42b260394d8e04bbd89e746150a333e40c49c4904ca405dc809e420de613104fb1c9309d253016df799d4c37250a7ee1c87373fc235cdeadcec7450aac7fd9726d391e6178d6c89f6354c51eb8b6cf8be069b6607f58cc8928f7fa79e19ad407688acc092b27fe592b9acfefc1bbdd5c065e613a91410617e59a02edcbfe47aaa2af40a713905054fa58ec8ff5a6b517582d94a0112fc5820be741edb79c297469f69b9aec1be3539068da3063e41acff1cf4dcd1314d15891443d25807e6ec99dab9df53c190ea663d4d2448cf0d34ad942d3ed702ff62cf59da7eb405f4fcd6cf04c46767bfcc901c7a7cd5928b3172555bcd089295afc96cae39c4b161d055d0ad09c42555ea37c1ebab8a7fffbbd91edcf08b41b6a2083894a67cb78d9954e2bb4e2761cae688b35989c70d2db266c3599523f89e89e68c87c883746049aeb6c1b44ca38bf47fa4dd0fc630eb0a78f242b75fc8fcdbbc5e4a71d06f88f35e2e5f483b747ed2b52252094986d2625cf07f739c97404d9f4568a70519035e5d0517019840fe11eb5c6fcf5656aa841ef89048bc9e72c4a3f0331e3775491622764e3631149fdf88e580ba26e23b0b907de968873cf211db09be024d0f727ba1694180393e8c281f9433dcdca6e5adda46cbfcaeb1f2ed39a80e4254f967a25d75b2558040be8ff741973ac2251d615874c90a4f1bb85e99258e17427f4f6f49322deeaa9152b7d333dc3acbfb8b8a469b6893fbcd1ab91d53ecce309c12321396a772a03169198e29a199ab30ee32556b4c91682fde7d723873d3a1878f7b36475f8e317d29efa5a098b848be3d67731b8aef85eac08d235e82a13f1c2a96b88654be3a3b5785e82f8eadfdadbe1741e0784104cba15fa2d9dd1bda1365974e6109db0325215fd2b8e2238b0e2344aa2b13a62ea6bead3cf05c41941cb900d88ad2127f8f2a87c26e7eb27fd28919c9b5e9ba04f4ce1f96cdd94db7b762eafded3f2ae7c308459528b2cf2c8f461b8ea5cce8dde6fdd37c66058fa5edf08941562f85d16134a594108eb0dcb54313d26b6bddda518f913ca269269c1800777a0f6d78e6a6fb2f799f9d3e3290a41d268427017c3f64f7003ac99c64e2f2f53d6f9cee77dc9ac5d75bfc9320f08e4319757089183f52e9af5d7075df8f0c9653ae955f6728b763471ef3f02d069ef47f68768bd4882e3fa004df95196dd3fdc4a9b267cd3c05a94fea72e60088555ab69d894a3de5a5fef7e161b8acf513c49d2a6daf1fcb56626543c7f0c475dd8c05fe0f5858c598c5812f426a4a5ad1071dc4cc5154064512b8b6fb427889e5d061faf6c1f99490f80003201f885061ee338722ee888d6156ba4cfc1d5392d2c92c3be0bf6864faca4d5a32d75add0693d5611040896a98c2b0950361b0d87205d1b06793865a85158414c9047527a9141b8f345da1fb8ddc216b095000a2ea0a5cdd6290a5c032268c633826cf3188cb54402a484beb32f7a5a064bc0f8a304e0e55771aa6f4918e1f6e59fede3ea011823ad3ecf27336bb6f645dbdd3ac7407b06aa17bcfdfc2ef6aee7124ec7d5752f027afc3b2ae4a47a19db11ab21d3aa82a67442fc927df981527bd3495bc686b60d71cf26231ce073235825d8a42c0b1f7eef2444a8acbedd096390ead88cb7adfa024456f475aef49c05afadd89798b900927c416ad2ad34b419d85231636b45a86736b46483ac25ed2114608145a49384c884413471699c2bc31e405f2ac14148623462bdb86a6185e743adbe399ae06c5d8cdfe0626445784bfef1ee7e49cd153751654bcd71328e170ef8c45432a0c1cd96df50b12ae55ac18a7da2dae6f87384c0b3f777a98ddd47fd934023dea15a8f920b0098f670de965a126e8afaf164ea6d8997be6ed01ae33f29c9d73eb063b1aa6824ffd88d71d761f404681638705a18784d6931551c1c4e596011a99896eb98d81e0b9171d275470bbb407da83164ea023e1207fb5d87e5260a24ff5d3714a7d43d31e47b1c54ed8cf4debe9ca5345685f239d72dc96c59764a442d047481bd5597d47f79db3e863ca2df75d4705f41090b6b200e871d58e3e1ccad1ab59f2ffa81c531d83ab98b530e6627e21443213b17adff5dbd4c09978fee685e87fe2cea1d2b4b4e94b90de691b1d0714d4e438e6019daa1bcc49a4b1ead45f16372fa30d4a0edaacc18dcb9d8a34850237e85775ff775f7514bf57fb5822f6d9933f76b4ad2d5b5cefa67db9ec2004b7b43f8798db76b1920eedc48a3ed04c4425aa8425eae891397c7e34e1fb9c622ee71bac2ed57de9e910b057eb13cf4036b675c759d705c6bff2e59f7038a1314c9d9eafb42d86ea1634655cd5ed96aa02cf1be62e8a18fbe6b00fbbeb9f6937e1c5eb9f84ff039774c0ae6c115391ed1a62a5834831cdc403b82e3c925f2447c2f9d651752bf23ac06a1ea71147fb453512552243683a42aa0527553bc44830fc81ad2060e5e234eab8bc9fbb5df8593cf14480c774f94df534b3caef22b71331b85e8ef077dc47faa47e381cf2f82bc2be59cbcf1d4569a74c5ca85437a2124f964203db980388a6b9ed3124165d9f87b3e399e05d460c1c6e7374ed1f3f9239e6540f783fd59f7cb7111bb61e8d1de8f838bd2e6743f77d6e1c5d722f2bf788324c5c679c1d044a364929192ed1223a3d507b5e15b5893c99125d128b14f6ad2db4276917b8a6b8120d4dcc6a4aecbcbc207b79d6adb08aed5b8171fddbaf1234ff83b1e31104deb659536f46aa9d9f0a97758e1c98a5b1c8bf86f6d6775d237ef84b8fdda2e1546d83741122dccb82ff0cf4612cdadc3ca6b9b52a3c3fa48d67fe69e4e149b1c645f8ed1b421c6e539ee2c446f39fcddeb34b49a66580ae1d7fdebfd1f0ee65dcb785a65313e15636e2b2221e28ca7b395423521563c2e1920ef6ecbf82d000402d7d8ed1752283226638529aa4efae09786a4e57ae42caecc4af095814ad8bb4c6116ffa740251a9e501721082806012b45c61a59c5fd3c0bedce4f9b5caf8fb74ba6a96aeacbd4f554a6a6ae78157191cd2f67bc9a8361f244014a5c7c22ec7a865362ba2b40ca246ec54aa5dafe017a548eb0ee984e4219a8e9bfe51ce3a9e00c7752044aa37d71f71987a3e843899ca007c227003ecc510dfff39fefadf5365fb0e45f744e735817213037f2e3e0da83d8ee333fd8d7f4242657c76ea088d83b8a90b263ba917f0207e252f42a6928bf6c4b6dcef9c389bfbbe2a3fa081b4a7ca548325f7d8df2c60317fc6e040f4556d7675db15c4bf58908aee432ed924a3776ce34a7087a5d164dbd8186fcac7d2f74170c7a18e340b0affd13814cc646924a84b0e59d866250bb8d3c0962acf47cfe38aeae8636cdc406e4e33ddee5c9a36f65c9d31aa5b8c09fc7e1558a3f13a0dbe5aabd2984cbe83071e6da8654ae6a9230864c8a75e8ba8f9d82e48d76ee645a4c4acea7a5b166361fed1fac100b3b72777950fe041610146a8498fde71a47e2e945c09d8ff25af62badd28d7a3389e2763164dfe40f13c11b6fa6dce6ab5819dab8f8d0039df0f1695dcf483050318f6f9f43c06ce22ae278505e0783c8231d6b4e97127a9018e0e90d198d654e911c3b220fcd583d5723809e6788df539cded4ab2c430a607471a1eaa27cc9e80079aa2033cc8f772124d7caea8644120c0418e318cf1b28214c91f39b51120415e52f040062afedabfa86ca407e3fa267126857366d99293d304445732807da531ccd0d7c4019c62d8ab7ecaf37a737080d29fadb56a9aa95028b95b17d7b70149bffb1f903fb7811e376ed2a46a1f5f3e9ffe85a69e8859ca728f9e4f3776a979cb466f2437d922de185820f875769b006b0199aec84993c38f4eb50e474b0942896b2284fe1d63f646b05d038626e0ac3b6d373fe137ab8ec9ba1f810cb796023116bba86586febe5a6e24bb114ad42987906caea3ecf2b9fede92954203d710ff8b22e59a661ecf61aa7b970777d11694fb70dd4f3f8211bc66b287a03a06ff9d364b30a2116b4d26310b36ab6e50808177b84f976c82311bcdcad12ab1ec983170507621de8e692c1a07b9d2c643e79dc33ba8977bb76e7738ee213fc9b6cea935c5bf5d50aa71276e872cc5a207c93e01845751664b4d452671e8127a8b7b110d8ac0e90882e34c6023a96ab06f38bd2f1370e5feec1fe2732ae7c877c024a9a01ead0be5739f420966cf3aa9f93d0ba2e8d531ab0432339a30f7778693345da7002de87e51b899f209731639a9c062786b0a79effcf189d081de8ac321b156de2c7dd67e265521914ca218c38784ebd45b99cc87e343acd6c81322632e0ab6322677bfdd52f10a5dd014a984f36d7d04970642d89ce7ec5fcf20d5e37f5aa3aebb050ccd327d192b3d9de09a4b78ee307ada7bdda6d4466d968bba088cf977be6fe73612d7aebc7f239aa8f0553a44f6addb3a5341f5e57ed651c422daff03d12dc694d72f4939a303a700badc27381300b5f7368233a09d97cae03ec66524568f1cbd44f027859f95f810f9145f5be3a8742a6c42054bf18b74ce30e631839cca1e9d67c16c2f3177353695a517fc987b3f414aff5887eafb44fa6d068f25f755ec1855808a989952babae8f477a3678941ce2e73f035c0fb64b70fd3e21b24969babacc26dd1738481ec38cfe2bd3937717e00ef5999dff04f74304ec59bdf2a17ec7713947288819285bcf4af4fbdf959a35a98fbdd04085aafcba7bf1a64b1372208cb47f7171657fb941420bfc628642897270fe69a677880edf17cf7b9c10340ad773e5b601786aa5baacbaa77ceea08df741720d107e6361b479825b33f3d9417fb0458c2e2fbe56fcb2b76eaeffc6d1bf3fa2cc709609ab16f4ba00f88a83e675ffb341cdb7b9ee634b431361dbc88aacc75723da646546f9e0a5c3305d25f53e6b846a5ce86d85ffef581efbe27d431cbb58425a9fea4edf22499ccf291a41c65f1d464ed90c9d38b974311400d4601f0d7cfef079205a104b9e7f14ac06940741385de7659622fc5c18e5ef5c50cf0c1259ed8f8e185188ad3810b9b4af51db30e12cf546715d5f08f21f04e26bb2ce5c90b94328fbd8301ff3597e942698b3d25b57ae0ee64bf55a220756bf422d6ae4e436d1cfecfca3cecb4b0289b64a0242c9c8031eebf0091a0f36526c1a3f7885356ed3831b4cb53012e2d1284ba1d87e671c355c35430efe67391fc10b41e8de2f85baf26e207f111e59d4c81507f7e4828d042faa8644433039c82f38171d17196eff0511996b202a8a16f513720f717744c6ccaa6dea92e9e3d462cc35389c4e113a2c047353121c5fd139ccfc6ab0efd2ebcbe138df8a0bc4ea2b932e4bf3f4eaa72ee293542a39a3635979e506497014d4c50639a98ef983792be45f4bc0bfb661f2ab7110d8a4ea4f411233f1c7442f303911eae31b7c6857a195d4f40f877e4518a8327ccfef66a47716a591e6f0626014699045b67c4643e6f240986fcba032461bfda4b0d16c78aebfa19af8352a0be804f5a6b10c477476bfa6f03920d052fe8fa9cc416fe2038eef71e1f33bafb8099878b75fe59dec8bdfd1b4bf96d1f29060fb495be0c50d5112e7d5f950c2843d6cb4132dd0e4c1765f1848e303bf0605252457f8d1db871409e50532174005eb0eb42e7f4633e35adf71223b521a9f50938f3a0cbf2469aab44a3860d21ec040a05cf4ff83a0eb279ffc90e9711a92d86d3de3bf35bc06dd96061d9dbc4f2904114bff1cd272d82c307b9ab91823a26492abf8e161f801b8062b1d9fc507c356861a679983845cb78f73db23ff3021a4f19f548515ad9f8f2c4fb99dfe33ef0b12f943b9a7074f7bfdcc58b7baeaffa1430250fa8617ac4a2d898952c4970652c7de8fc0e505d684e497a4dc61780930bf6186087b844256f8fe10aed32a9b25d7ed63bc41e8b05394b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
