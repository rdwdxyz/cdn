<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11bed293db1b09a17b70e935107ecbb36dd939c8940ebd1c719813e59da7ca7edcf4f5276f84287683e96b4f7e6c4faa6ff25ed7bed767af28d5acca091606c2d4c1ef68e6469274258c81a2cf864973504acd05856047d2ebab60b33df9821a189a1c0ad29a8cf08fccdba6cc00b930429933d050ef921614c4f75a70b964d0968ea71e05109b568b88ec66666cd88aef00b4a1490e877cd6dd41df9b247a22320a54b0d0503f3577b4a386a01d090c1d0645bfe87912b90729a8de15226bbf952bcefde8bac410e0f5d5a6588157d1a9ecabcf1d08388c4873c10d68e6384b12c7dbe547d5126d11497aaae5eaca55d27458b6bffa338a3b11be314ca3d4c6c1bd1bbc613db0639d2abcc6907f0150c75bbb13bb6c5380489e3e89323c9c033130d0a11d338fa022ecbea9107934d95f2a429948fceb8d1669ea965aa1f59e59031e16790a7b0e8c5ec03632c03329b79420bb027da0ff0d4a7028866fb0dc58f157b5d950a2a0b57a598df2531e324db215bcc279f3b6f19c0e985fdb5336575154ff1c93c1460345fda73b3cd179c496975f2476a98a1c8a672dbbeaa0d951098e00f757bcbcc7546a6fde0a28c3e72aee54bcaa658312302a0fdeb08fb46a0946ba6c554658e4150b52448de6e9a3da971f8a23d99d804a44370412e86bb6c754d05d46d141fcbd1d7b716d271a2d3a97792b303def07d8f1508e57eaa77a6cd981d7cde3e94b0d617b49879ca1682ccfc9e56309ffb43fdc58cc7a209e1a419455a7e9744e716e113b460138263b042beede83bc9cfebc55d96e5ba5a8d65c75b6cc494cbec52a80960d1e2029720b7613645eb73a7602d4f3fba997a25f9c1a31486b29994e329c7a0ed537b2ed5abf9e001f0cfdc977b147a9d2baa2a980479c5d020723c8495213e04aecd3356b6eed839f105986933beeecc4494d7d449849c1a72d7c79a9b500b624d06d76dcabe7eea356ec6b7ff8683c795071cabed88c482f4e7468940c1d8d55234fd536dd3c3a13949f91d528038ff1453fb78687a681d4865cf8f30705d66a7fe066eb709840588436b5ef0c50955f8bfd1deda8987bdb71b934c425ecf7825a3abaf1f35fc1a8a3d24c5677c15ade3f85c9cbd76ec5b9f4abebccc8292a5f21992066c4c7c786e005dd1b70730b261aaaee5e9ac31830d0897b79f23114cdb8a915ccb3d8c8e7920900c73fc662c3586adcd7233e5f84d698740289bc8f4e38ada86c58464bdea5a0b66d66ebf9ce2a4722b559692018ff08596bca65d27f430ce5d272c17f71a1b0b784ffd5dae73cb98f1a2413c5b79cb4d20da8c8b37eaaea34b9775a11cc861e7e9d9b76ce73f4412682aeeb646918595f4bbd9e7891534ff6cc355f690c3a73ec803d4ab2f8b506106dc42dcce979813898ecd83d5abc04034c6e428a0694d15e53e095f625e102ee9711c6814f44105724e2e6fe52ac04f4fb1154271c769e3643f9a4d140ae957790154284f2a7cadbc1ebbdb07867e94b6b6e2a0fd909ec5a1c4139fbb7327a12ec893343a173e390acc615f09b9a459ef4ff8ece5c8976ddb60598a1cffe7d29829002a938391712ca9326b05d5b9112b7086c0906526be78ee9562d400a2c032b46caff760a110a0d3f777cb8ee9f1826b3bc66231043af9d659bfc9c2d3cd5b0622af70e46fd387790898f8170d0b2e6e265bf3a863243ac5d75a720b53e703f8563b1696752e3f3d08df47d7c69c5a4b6149b79edc5b5e1c3253db42f076cb9c8c8fb0931a85e719cdc739c40ac693a4225b99b48d7b4d6946b3bb8a9c28be101d5f3f3e2cd6b9bfe664b14e7e90918f31852077e52e125992beeecd98a7dcc13d1a63bc5ddd0550ce8627074a10606092037d9a0216ff51fe5ac59a33710bd7329f641ac3889627faf04b2f4d28bcb7b11d4798bc78014fc8bcbc820526a3c3eb3fece4edbf21ce1ef7f982a8b225c664c51fd9b620a86f6fafeeedd84e16d3ea624f52045f9f39ac2feb00e6fa09721cf392aa6900b07fae93012716439cafe4183c7e1643572c42d09d722ee3db5ca0de4c005f63bad5131c69bf9277fe50ca6ca5309ccb0e6414024aa62ffa70a906271614bdcb9e2a584a1f08d7cc114f7d5dc09a2abc757ac4214e11389522c53e0d317f17a3e4160e04cd50f264599e6284d004b1103571f1ba6392913e0c3302b5231ce86ad97003e8af1bf47ea30cef24891c41b8edb8ffde104b35d76391430974dac0a29cbb0c496bd308488cdd7ace1c5d10f7f943e9f98a270ba5d5e861cb335dc083eb288ee90bcb3af5ad81c93fd5f657ed923669f2c95a4788c6088ca12ba7c86a9e24a1ae307a1c50b43ed12f79a8148a9cca25e3ff5e122e27d32ad3725d5f3b9f44d97447721d3a6591e7c0915dd11b78bfd4337e7f0e85856d3358993994c9cfb98cb3871fef0afdd22a2c0c348d6af10ea03848d3ef8d09994cdb67a0ea6d5f10fb06e8f53a122dbe651ad0b9b5c83fa76fc4609b80336ae602e1eea840fbeb35d5c99434122caeaa233acce0e9888d3301b10ae558c08c79c59806f83c8df15732c2e7f5b56c013879e688b43098727e28593c1a390a6858d36e1bb9b44d3d5032e04dcca3eff8ba1ad9b086df91bd783664f0c1bb0b06ce311662bac37d6b4a3ed6841cf443103e004cb8f85ade7b2aa6fa542a2047f33fd948eae97d8ddc64a90a2fe2c11142b14524be4cef49ab028e6dc4113d549dff8d2887393c0cdc8b2639a9030bf349d98c0534fcf2d65a0c046126072d623d8e69343af2020e3f39f2c115e661e9fad6913c25b8440ce7a343fb434df67918ee2ae421105a68daaeb6626ddd7982fddca4078eb948dc9d02cf1d1522a4e9ce0042338f39e60a4bcdfd6195f801f1b6c7763c7a0b8684fbc09be23ce29c762cd674628714271a549bd04f826321ef66cd41c9f970c5c24ed468ad6bc854c63e31865dc6ca4f43d5a130915c955bff7fec6853e85547491a09fb7af3657651f3f0365b68419da1189ba114a30ea9f7f6c9abeafbbd946235f11f5148c1ebde04c9a4ff887c11d00ca1a038ae34def9d2dbf24f957ca469e3c46cfe996c14c145de9244b4e7926afb588e1c536d91d5ceb8363bf69ec1cef8882060925e7103c57018afc8862a0cee7668044bf1cf46ea2782f2386b6e736366c2ddb761956a2b18b4ffd6dae32a7c98a12e913bc60574c4aca2dc199db6660fae720baebed0b8ccdb31a7d782a28dc5b4b6135ee508fede021e9026233dbde20565131b70c2ece514fae9b94158cc466ab6cafff4e8b4f4fbcc099c704003a1af34e94461a41dd5f63b9e895e69c00cb6818096393517639c56e9daba977528fcd485065aed0377039ff187e97631b8d6468e62317a9e2e9cf59a89a9a56400df5c3afc084d5bb46bea62e4c9750be8470c22e4833901e22d7914318635359773804f8edbcd1394df34d6568b86cc12600676dd2e09f898efb66cc064557aba39e8c2826a0b7e296e7f64c9a76bff4f7c7a23b5c7e41bb3286dd4e448c9046213757eecb5ff4930b7d95aa18615675e0815e3864fe67b15bc67a3cd85d9e93c1a006a0a4c1aada3353aa3a5f1bf07b69e1d503d867ae70afec04d1fd51e4c9f5c35347061674ac29b673934e7f830cfa790e972cf67d5791bc8f6a520f8465589091daa2ed0efdb947231513d67c4d55a9f3f97db33e84f45a047a0b22d38b1e7a31a735ba432218a0ce0270a700f5a9b81beff35c18fd91822be69aba65f5cd4b4875b2ca6f8c79c4263a10e2f309bd824a1a139cce83c80708016e7b95785fa0fd8b2c71f122af5cb006f8bd23e419a52b0d07c050e43ab73eb69425da650604e22b7eb7bce096adb57aabbe07e7551602681ad84815a1575e9332e20f946ce3582939d625e40ad8cfb5fa1d515feec6cf83040da2ceb5f0281d15f7124e9e51c9136054fadcfcfedf1342a34b97193d0280d1c292702630b8d3d28e960e62cf2fa54d6f50da6957f84a8e2af6d7d547b74894b85dbf307b726acbf5712a3341bbc8033b20566fa24aea7a78e0256e85f8b45b5d826c9a4293e8ccb322dbc554cdca03d570ddec822375a61bbde770692e7f096477ef1a9d2405699224140b7d9c84d020988dc67d96bf50c6f275c6dffd2876020ecf972b1e2bbd99bbdcb8b30a9f56ac177e36f6ddbaaaa403503dd7674f71c820d18ba784897864097a4a8e3eae43020c61c9ed381dfa013a6c6fa697246b8e9f2d337411fd8959aaf581f8965ad0da9fbf1f89d7a89032b7098aae312f838aa80fdbfa70c2039acf152d6d23445e52c0dcd0413b696d5918812b8723e2d0e29fd7014795415a2e0b31c39c98421e6fbfd898ed6d531a2083979c75c0fc34f0e3241ea93f34cc06f79fa0586f25cc7e195cac7425527157dc8a9382aa0584f98645bdee5845c63298555813fb796a7a7545a2af7f529c11f9fdabbf54e048feecd7bba85959ccb395159f0d3f6723616b2ddb921e4432dfd05ae169b520761155f8ebf49955a2b3eaa8082f41294b5b9bf5bec62003d746faff905a34a11099e137ccc716050edea0bddcf933a30218e60517c327cbfbbbfbf4028efb2fde9aaa8867080de889278a81521982591ebb78af53961afdb69ca9be0c1ea4d8a71d63dcbba80c478d766fdfab6ca2f9cc20e7412648a24d302d7c66bc916e87131c8ba7c8471244cff41d02fa31bdbf97933e9183635d68f95a74a05642a76556ad6946398d3febcffe5f5e230024b971292f272896e36bc0176717c4ec9d1c747e955f1eb63dbcb6ddffa65e33891f0053573ed0c86097220878454c35a363ee86fcd674bb24a0e86dd6431161151c6e73ca44b3140e69af565c61d5b7bfe24b88fbf409f2382f9bb011cb842b1207b4bc71184ab475b900657afc179484b59bec0cf2a77aa2ad4a8b183809d2810f2d87e0dc442a6ce7a6f94dcf63b41d9dd6b750801492b982e65af8fab61da205aa755d13833b2b99886333aca9cb826a269d81fdebc265ed7026c0b538bcc7cd186883e8a409828529b9652417a9258f0c2544547da2c950672b698e6889a042918d61ea421d79ddd31b6dee58f542b40cb630840ab1c177659ee600873fd0fb82d49fc308ce3661eb89c91317ea88008e59ca6b8fd5f868b5d16152e0a364da6058058124f63886da6c5e3f7caaf93c2012a27fbfdf2e44ce92bf3b6f0b772fd7a8f410ec54ae98658e1d0ea5ee053a37d7cdfef1c7414e595e129b6175e865c2bb34b46759ee50e59b1f5aac1f161cb7bafd38b9403daf99e5a0439f2baffcfef27b4cd48733bcb80fdc4342badce29fcd341025a3d56f17936ae2cb72784719001d17a48fe28a359d64552f04a9b227b71dccc1bd1ea30d9713c0370a6c160764323b16d899bc1cf24d47458089188e0874ef22263fbf8a37a64a4be7f10614d7772c563e4337cc839cdfd5484b42d81619a2c40772cbc2bdd5adb74cb5e596e17b545287439ee20405394990156c78692737fc3aa18d29630b4e46f432b79b6eb3708c01ce05512b877c705449a725d9838bdf8f99925e6a69c37a8abe449d40a70c6b1cb9c982980ba3e1c54dc644d0f302f6c88562c35b5ec779d3380b7cfbf1afda8849ed9ce77900b61c5b45b7241d488cf92487783d51ab4bab7a51b52a5161be9da15d54e545c7e83a0fdfa6e211aadc9d141b021ac6873b842f85b0e558cf40d842899f223673c6363ea8d26c8ff67c3afe95e6558e6192431a98fbc1890a13461649c09fc92afa5c2dcfd783cb0880caa61e8bc0ab5e6da3cf2bd4262f58541a67ce0e5b6ae74f4bc41fc01844dd30e212406895cbbd5f7c806dd757639f1632d2589b42d0c1ba8f1d0e5f20e1158e397997b389a20d7930986764b03175b418dc37ee46bfa45bf5079be7144e3df223e050623a94aaba3752bf9bedd866ac96f16af8a2da4fab42d7b771bf9fe798132d4d660ef8ccfad2181f88dac9701eea0c4fe6df7a7b0ed0962df29d20f4944bcd25c32069efef43232eb57094a7a5e9213f9101602c7ee5cb4f28148834e39502eb65eb4127c401000cf4c081a5645d63c56fa4a9f9c105ae1bef113c5152943a436f0a591d6d79e52ae02525c11e0fc1d230cfe67ef6445966dd8b38c372516a577db76997788184db72474536a468d97d5fe74707b3c6446b9c2318bd4f54e19b6635f0f3bce7742037523382c5700f354d27bbaab66d7bc777dc8feb50cf6d9e415bcda50f6683ef08f022fdb26117358c66d3ef3082a4873e7018236fe5f60fc4eec088a6591930592f8bf848ec18788bc15bd5ce3841896f31244aaf4423db624d8a059f14ecb5de3a90a36b1a6c438e09f6b75cacd98bbbdaafeef234bbb6ec5d1ef184110ef100a9af5df807826e988b8a633610975f1542b29c1dbaf6740117e42854df4b273da004ba15418bb36effb0d04f21b6d8ab882b8f96bb2e946cfa13fb4ab9314182ae938f039ea32734d174b78443b8c6a3947f78ee03f6b67ef74a889366a407f6d106d57c9fcb84a21980161456fc5339362e3d58a146aaa0137f91b9406da59bf3134a880c75a7aaa29a00bd80038ebe044e3f45baaf14a7c8fcaef035bca2d48cc5d69851237fae8f216062a26ff2dd3138bc567dfcbe466d281f8671e236b7d4c0bd8ffd84078ae659f073230762e1028c39c6ab9f976f00e6dc874f6614c7b406ec12bf7c892cc219eda5e3db6f6c5404063780725f363e11d85eba96124bb8adf61c333eca6d777aaaecacf30a54413eeacb3bfd77c211c2ebe0b7990237664a4921385e27a98fa26bcb53ecaf3474e77e542f0be3c7de14b9a3b6795f1fd1a5d151613d184ebee1a0d094b1710e4f07d1d2388a6633260f4981a4afdcc02dc83eb6209b058388fb27ac852819d489be023babdf92a09ec3d01636c857b86bfb97de6810b6dcfea037ca6f4834a9953a998e4b5eb8329121ee6e3c1c40b88f5a40b222eb72d7cd13814ae05916a6fdb3b92d257332b6957e55dead0f9b263f0078f8384aec5eb4ab5dd78ba44161947cbc475abe507298f90ba1c3d7fbe49e27e2c95a45c9ddf1b9fe78b69bfbce765debe7f151ef96a9dd6d48cd9bc9af74ce1cceab1f5794e13f1b2371b91aa99d96465889db12cf07a6a090a156813e2656d9de81056cb069b95106952f5ca857394c7e11862bd63a79b7a57fe13d6be9aab9e224e54d497ec3ff650c8f8716d0aadf054e4d910123ec5fd3707ab92f8ffd0c6b41925f3459519c0b7f210ed624f616a71301a7c793d71036c94f1ce8cd4098023608562a4c9ce258071066a429cbc161a787ca5523ff36027023d72bf6615df4b2fb04c150dcbd57aba6207135037379683cf1a1677ea4bc5a626c2672eca075977ed095141ce31764f1c18e57c7f9dc853e30157c9edd0ac54e0e5334ba6d47cd297d0626f79dfb73b266b71dd39b40955e2fe3975f85d7fc5625ee1110fbbb30dbeb3d030bdcde963b0b038c20158134a1854c0842a265bffb0a91f675e187916bd4f248a87839bbc5a86e5f783480458895ea300c78ebbef0bdbe9d8a3c43c37b8d08a1454cb453b7ab965d8d77c58752be5857376e217d732b74865fe10cb20e2c72249b5bf44a100cb0ceae9915f16f2f6804a9a3b02f8ebb6a6fd6374900c29d3dca8a66efb733d94477442fad7cc0e03ce5930ed30806f66494f021bb61341c7d3ea461c5992683aa2ec6b09b217ed067d12d6c60b46d111fcc6e0c9226c6b3ca3b30ba38888b01fe25758bb41918a496ab06b4fc21a43bfc3af611be2c440702d315ccf4684e8080af26d4f33d8a370d197975acdabe910c8fedf82adc0124d30ba841cbe7588c1252331597423093b16a044c4c0ede851067586ed9470c62dc0a9b0651cfa15f1d4e9cbc42a8878b0acadcd22326868e8d6f0bf02133f31792d655b41abdd4d54e5ca90756b2ffb5f2bca49a5d549f53d61a592dbafcb48caa2d167a16d308d3744b21f864d19bc35804aaf042c67848020ec3cd43b2240137a28a84b9847933226439bdc6e3ca71622b2f08ec31992ef9f5ac8c5baa3ce226f76e9c338e531a92f87c5bb3d4572ef484cec238e477d8cbf8eb6dace6814bd5af1decf976a2d28dcb5fa987b67e58083e4f0d5d236652dfda9b3abcdea25fb8822599b805ef4741841f9941d16de6661a4975c6cfb8ce2d3fed90fa4b5ceeb68ca8dd8c3741fe17be804e9be07b7bddb5170716a3d52c3047a6dfdac459cc05974064d27ed1346a4f2ff648d27db791251c9d10022e884ca035715a36d179362dfa745f317e2f2af5cb4c2d8f11dcbc982fda282a578ee550fcd68779e1a4b6bf3e5bdb198df0a45404bc4d5acf530c879614dc3714ba467fe79027bd7bb1fe50d177b90d25fd2c8f4c1a8e0df22b629f472b232c9df202fe18d34dad5092a210db3e1538132d17dbf7f99ba9b3be2acad940dea15b803e269ce73d9f8fa154bd4c397bbb53cb24c95bc7d1e0cfedd4f5ca44bcb6f371b66b8e28b0ef5e0b6f7ebf4f517610ac59df78c339a8d986018adafa20c121b2451e732012310ded164f8a6eb4d5433022ec88cdf17e3f6a28399f19587d6abb7c8dd77603f3eadf301d4fe319421289466b96132d7bc0a5a56ac473c585176b13616204415d617f45095259a60d01c2e6d98ad7d42bd8d7459228cdfc2bd44ec20c59e1753389d4bc0b64c048f86c2de0fbd24f6fa1d9f7a4dbc761c1a0f84e5a8d10a88cdbecf3db13dccf517bdcc29f0019893e7f88d36d1e97fa21ba2ea614e0fabbe3b967632f881620d4143c3575c5181b95c1121010a6d2ac81f113231c3435c114fa99e2e001240d37271601cff4420a8ebf7ef1d07293ccd86c8b5e8b69051015e28c4c975805faa49f37dfe90981c2d0d9fccaf48ec073d18b76afdecefad0104b1f04f4ba3969bda798f10d95724f6515079519803fea29f7117457e0de972b42b0d986145bbcd2efa67d4fcaf3cdc01c2792634fceda74edbd6c40d433516796870c4db0fe1539d32928558fcb316335086f9077a41edb5d2da44d0fe65a2f147b49498130b3a6e8d76b027ab64187ef137a24f94d519d1620e0f93275a135c1e54a1883c86d48263adf1f504859b5982df4e196b7329cb23112f2a96a38185802aa1746b83f277cf4ba31ecfa2c516695511384ecffba383c8488c7f878c0d416a39219aadbf1c5160b5b72cf78b8b9ac93f952d8fe514775c1a7a6050cc2bdcf186ac7eb207d05eb2869232e43a401af9bc61e84453687f3dbaaca0799eef4d2e5b487c01d3d80ddd9edaeac7f3cf9e5f4e4344299b22707ba3c5b1714fc322c8820f47c7cbe65dc9c05043f94a1e2c8325a174c379fed3fd851df6d48cd29467133cb24e20219f8d1d33d271e35ef54ea753d758dcdcabf0a12baff66b7e593525e6e95fda201c203d34b3e286f8264501b5477dcbbb65e25dbec965e5187f36b01ed7c04ea7066a88a258b5bfff4706e709f833e6b04ec17a0907c5e3a788aa7b1a1a664ae3ded37db5bfdba9bf47f40eeb99eba01fb36cba9d0bb3cdc9091d1ae3a84796a24bb4bd98099413e2b83a7e7dbb0c8c0b17e2cb2d3453b80bdb0a520277e440f01c56579dbc7590f79c372b42b8775da3531532b45fcaf2fa0b81f9d373d9bf3ac11cc54fbb224da75865f532c28b6c311312f7b2710c309f3c5375bdaa9c171e0e967c7a92da8a6cbe0dfb6395ef1e901086ed3adb517b12d522f9be7d8bb95169f39cba6361c3335427abf822332bfd6d9471ffb1c4153f4f45b60109b09adc752bd9e55f44deff11d1d6dfa78f9cb149386a2ec323c6eabdb116d3f96287acf302985905efec6e8bbff0726471040408d458dcb25b712931fc3004f90e7a85d3350c964c017b870d703c4a6d3e53c23f88c539f8acbf66c2659fb1ca0bcf9f4fe5cee5f1e66b4fb5cc8ec1d38c2f8dc5ce671f4503005ed31b3fe20f0304f257235d9ab9a6237f8ebfba7f618396a103f03c0f329bf06efa06b9b6d198cacf6a70192cabfd4dd0ff71366b2105ec947e7cf4a3d2b01adab6284160ce0ac2317e74c53c870555630a7609a3ae91196c87875ceb6d8762451c9780c864d2c379a08505901ea24ab9d4fa813a365be9381eb02d6eb836a1fd014fd79c93ab71fa44079bd25533ef14dc4a9adc858d430e3c725be1bb1cadc983661d1b8dd03b52450556928a53825d57e0f7357e07c10c55c664a585008638e5a90c89acd320ab13ead68b6a6f719e20814f43d623cb3026b615b08220816c3fde2667ab75fbd4a4707a4f1332c62f8ee41e739f2221027e28ee2d74cdb177c95231bb25bb8d1bd41717d484cec6a8aa4f94e09291fb38bb673a1ac85d24c8ef1155ff7a41d08e74a77f8f2bb81fa13ea6af181c9c3ba01c76beda30690f6868783190c2d4dd711b4705c223981c20e0cded604886b8a8595e26efd277512607c3cc2f793f6a03557fd8b9844bc62ac23aa63987b783beb3beacd5df39ad4a24bcd13cd0bfdbecbcf25519b0de8bd3939031e629408baefa8495e41400c5973d068567948d6d2695836e21f1b6bf37d8a10470ea9786711ea265bde1b93adadab6934ccb2b9901205fc4eb71077cf78939d6e474b0d144bc64a9aa02c40ea6fa8f61ccf92fe74e793f0b1bfeca274746671e68bf078adb2ae27742df5163fde952f07ff82ada184b7f0e3710a698b759efff9cb207439cf4b981149515c0cafcda877006f56fa145dd29da50dab33b25df354d31b02c14efcfa055865954710087af00576d9d2f069c8a70545a18e23cb7f7e2ecc5938fd630e974182e6480cc3d93d71e0331439e10fcd947e4f37e33f403053dfbd0e5fc95863ad9f931e066dab13063e387ac3f9ffb1ff8f7ee0b37aeaae9451bd08d8c2a04b072f5dab57bc848a365c52d18eb737a5083f825276536e96eea5ef3cae8613591c9d90d932a7602e465f84892f8a5095de0f333c6805d38f113ad69efcb4f87b1188c02181091b8fe18c7f4209afbe3d2266d8659ccc6e66b6d27eb59545e7b3113859b67c0e8e1038fdf3b804e7fadf1875c1df03dff72b422b80c22e105806975f8902261af2cde016b27202a040ab5f4bf1a641f1be2237983e894fe93988635ff7251acd4b90d4a62707bffbd3f07c0d96e1537cd36ccbf5927f5cb09432e948d43291642b3c3b43d6c937fd639ab44d62b071447f53029f1e1ca9f4a52c3821434d43a7618835b8db1977bde9e24ed328170da536c459d0660ff1230e01e7dbb53d5829ef834082f8d8a16777efff16f2d8c61ec7d82ce6f1d01611f0792e6e5f3338fa564c763d4f22b98c2ceb0e98148ec1910852b5b153d9b8e1345c4ff077e5821809e0a5dea2e6278d4d2b35ffbff587ff14bdd24c1fd76da22a7d66d50dbb639356951e7b581eecd420c35f3c631bdb879ce2c8acac1a59136169f157695b92e3b19897ce8112691701d7234c32d243a68465ffe7f43dd318e1a0f711f541de84cfcd642f94c3f7f6f46cb7b475c5e55df29bbe27058b52181516742924bd76d5b5fd94a959e9c996bb8a05ac6e34c7763d2512cb58796ef83608b34e60ba41cf12751788c21454289cc936b221630ce0cc0e642454f957d40c59e9c4745c044dc62509232c09f51b6d1cc04118b641c00962c5ba8356317906b6dae49a6867b542082d01a1622a53b584bbd69d26a688428998e0db7ef3cfa2e10fbce5d86aa2cf4fb24b98628c1dc77f65d23ee72d1faf2e46a21efb8234a9a129f9792fd1f0f7b8687f5c3f1e9ebdbd8451d1042ccf1ee53c2ac327698efcb2f83e3638c36e93e97225c1fc95b1a10e5ac88975f49ef3462038b68e190099045171a0351545e927cb7f7dcb5aecb3f7b261dcc65e6994fb913a63b3e7a5155d454c3ffb86bee0423d7a725d028e9ca438129c98047e450c3d0201b7fe55cca38a316ef3bbb72fce2d0b5e33acf4a9f03ca350445b8bda1af524be223ea736723c18bdf7a7a3c67179bd1a257d96ca5a7e7b00f740eed0e602aa3326f715593d4e79d76306e14b8505d6229c08a391f5e2d4068ddaddfc27609e162a360cb19b0426c9fc517b00e1833cacdb2a22502a099063526fc14ad34986385ffc7e759655a8c0f81c63cab55cffc070869bd87e1cb36580bb942b8ee7e751a4fbba9f20a0756c8840e285b4897a3f8aaeb82654bd541b0cba0e6edb3a5c29bc3ad30f4a8eba718afc6068a69ca3f80e7f5549db2cace22d670b6317afb57945be4f7747bc7a07d1519249ed37508f494e487b35e252da7ea9913dd3d57db1256243b7d351f43629b846f5b6417705fa0c560e0c8db46c2a12e7f8ff53e2c28fff81387c084608adb29dfa2e1271fea698183317145577a415cc5b22bf9cfc11474a18b0908448f7e838078fe69f713e03b6a556ec01efaf82f7d2bfb0b4bca1f9eeae8a61a0dba180cb247659edfb164901a71740f56ec038d80c71cf463bb2850bec25912fa6e46e78be832129efbc62f4cf22f36281194d2b30229bbc57d5077b75c1388e93392605152f9152a5a44be5446d2d99f9cb199376983332cb012a9adbfb4b35e417d5ce68d989f911913da4afedc5fcff06bb29c6b57d6ef625a7c3113ddebcdf0d890f957a4adae5ada79e5724d38eb21b3a7a6a4d5c372292b2476a344340739d3c20c454b944525190a374138dbc0cad03cb54d18accd88890eea16e3fb7ad9803c0f43c41b968236eb0deb043cc5c23b85748cbea1ef5a032dae60755962b113f86403a6567ecc0a5966e5e41a62cdfed731dbd30bbeca4279d240a8b8993c8a04b1d9bc44f64af9cd21b41e664d2468a6b6ed0bab32027072589a087859e05402b11cc5b0c791486f17abf9648ad3db805ec48f96ef95684102fb309adb320e9c3d9ceeb0c12d82787ce06164bb64301bde9e84c53a33f750d7d8522771b68e614c4ae2f5a4c719630982484d9ef9f7e4285cdf2d833faffd59330e2110a899a25d184eb9000904a967fce383fc38f4c06c98d33f459488395f81d05fe53b2296e7d9b046546193eae1c10db0962610f7595e267f738aa7df8edc7941806d963a453292aa0800b1c76e389feda1ffef1f8aeec2887ee792a5fdc2d00d2b4d0479052f2d98439c6ccb208ca89f810bd057d25ee11faa782aabd2e5936d6b1de1cb584d9f82f4ae71f0753eb5a491446ccc90d6e2315378173d4d7096bda536ac2738b2eff00b5411ddc41a95866c2a6f942e2a6913fdd129c3de62386a1876f15225c70f6554a6d4e43dc84fe71ead498fd4e84e56be24dbce51acbf97c784baa2ae5dc66b014938135b272354da84734d6f0b47c6d49257fd4f4b9a5984d97954531b788e43a2d6d52ef633ed2d89dd651672675736d61683d91381175bfdc4449c2f0f944949bd691c7b83b3caf8493aa23edc975621ec96f0abc1d3df4c07d53464ce18b1dc31a531841eb17b445845fcb1d81edd4043e41243adce0082df038b640cca01c64574e1929a87bf50ba400ceac44d75af9e48d57201dce2d2ed4726c0bba8cfaf1f8dc56e0ce7ebed6336da576d7800d5c5215287c91d50ef8b9d77376b395050bdb739e2c24060976b1f1c15daa467c19d10702612ca12221a3b0461f4bb5ae71f3b174db59e9073e870656282e4ce8cf40ee5436ae53fd3344396e0ccdf22c2c0cd8be21a1b18400ff13dd6762e89ce29b7a83dbf2414614ab3709b569264c2b038b42b4e1fdf5bcd6b1cb2037f7f8ef234406268efdd205dc1f69a50ad0a499a8a2c88e2ae44e3d589d99eafa0050d3102acc15752a42f03f09d2621d8f9dadec2e084065ca884cf7a98a66889c8562186d54f303e7b8df31b543c5140452a615dddb1817b109739221e14a5e0ee8c3e8acb278a013415e9d2b1979cbf40592780535f8d2163f5d64ec8c0b37b046f4a86d2f34e65ccdcef2fa4725d179d5d983aa08543072f18cd0f1cbeb3433fb0d39705f152755febe67c0d0a6219490df593a5bd71a8d39a4d1b1f6e8b063e033b879a8ac57dc28e8614c8de86f32baba32acf9e6734fd14313b64c36ca8089d73de292820a15cfa2d1c65ea2359a74172eb5d05765f6173bd09df8de0ceae3c5075c05d2481b7eb2352b60e04a46eb407e7bb52fb53567c8c6275734e8a5cac0a3afec404154f528dcf52547a1dd51484fc4ec5dc8e68370343a5d7c8db8a0750fa82c0cc607e5efed520160916a1387cba48664cb8c0f6fbeba069356e8087bcc814cfcff12885413ebfc4a61f8d3d3ce284ae9c3e811ae7e698dc8a56b9b63f3261e96bd93cc0aa02e5e40bcb4c046f859bd84f7672df99057bf7e6fabd8514a24c2b5647961be9aab03c27a123d7ef5098abf0545ac7e138e612fd400f727e23035ca5abc7d4a0664c8e6191af8eed3edae5bbe9bf48162c8895366f5e4fb2fe57cb0a96eef856cdca8bfab980430d64f23b8acc881e2f2502ca934f6d2aca030563878ee7b2723c75d5a2098e8d2593487c3b2fd5ef9f45a0fb9fce2a3b69c65163d857f8339c7f8234d3e4c5802000c3990286af626e4203adb0fe955399917a5c4e21339a6f62c337b8a16a8c72d3962605df4c070cdf6f6caf1e1af78e99a3fab738be38c42660aa7d92c921430abec2625aa4d7b30869664f96f4a94c076ac276c61b03657f4844164df4d877b75ce37d8d55122c5b156c3d0d3bd6e3483bb9c5d4a4f4744c91c7b3643d6878fda36a659f20d43191ee2c9868cbee5071bb1a1d78ea369b5a26b5c4ea69b1768cf8f3d3a607e6baff86132f5a895f61a3953bb3f2a0bd0b3754d9ab6dfb8ce966f40e33560dda9b48af0c51aa5bcf180699c6d3cb6e1c9b6481ac127aa820185a8f569b0e2609457bc7e053e0d609eb59c6d38b3b20f63f5d60bad4beaf657268b48088beaaf2afb2fcdd12e01fc2e749da7c133272187bd7a8fc9d09cfc8df33f963c62291c9878b5247e00f702198983996d8e5f404188fa6fad72c0be01d24c2fd81e9469fe8d14bb8592084164704a17b5df6c838b0d614590893dfd05d13cd175645a0d802b575665ce8aceb4c5dc714145a8f39383303755ac448f8f657277c4b90a6f8224900b85c4093404e144f88d5e5f6f6141c26659db0b8d4262a5e961633327a139ba3436d7db2bac14829ccac5e5c296cf87acee0222f2ea90de883c4f27475dabb1770a76786400a2bd0efde5b0dd44558ff5f12434916858b93c866007104b4102d99a8fadbd6b3ee642eacf7166540bfaffa453edc5175f59aa018e9346198f78f5f0633e3b3d9a80d8fd121ed444b44726d02439e047985c451a38398a1ca652c69dd5eb13c8d682a5000c13ca576fe9a5e4223e073843160b9f5e6fd525bc46a9d6d04c765b63dcc37c417eddfd1e262538452ee9952180de0f0e3c0ac2976c2cca29888ec7e18d616f687c66cb814d767e4d26712249bbd49ab4c1baef86e9f1d7ef2e75b3078b3ed16674e52a657b1b7e15de8f2ad9b798c0fb28280c31dc1d981e4880e985711865143529f8ddfe6c1abd535aadd0cff908773145745a9124672a1b1343b244b01122de1b60fb605b2f10c7a95ede9da7650f273a3c4334ece1349dd56edcfa265edb7622c5ba7e113dd5b5f5a04cb797111d2c55d051ac585a1af9ea2f6ec9d9db920b891e0b832149b08bcde869e671fd2fb8bdc80828b7dbbac45b0b364b1275eca052063a546aabfed0703bf3bc1e430f8871731613a3fc79abb8e6d3f2d646f8519b0265da928f8f23d4ce123fb7e87eede69d2d1ab45ccf20e6ef2e0b5c028ae7851d26bbeaf8dfd4a092dc5989060cd39325da8d0c768cdd314848580421f2e0e18f50f25adab9b358ff20d9f220076fbc40577153a9129fddb35764da43802ee5552952d08158e01e8988ab2fdcc240ac8642f07f4207dbb6271af183a62b4696c87ffd8edbc425478f855f06ec2af5ddc9e2f6c8ebf0c32312d44de01b4733755116715b8ccb193938b54609529553a7390c612b1f471f745bba43a0dd5724005c791e7016bb21374de590c0c9bb6216e776b2b920b895ffc7d97157810fbe95fd7346cf476bfac46c5c0aa537a37a5f57f7857e546a4eaf89ac1c68e9aa782afbbb29e0d64f2416ccb563078af3c6953f6d698e74f66c7c212a3c1c00cd69957c0dc727b5fc6d4c10cf83ab0577324abbfebb125309bc37bcd81e4b278d79d86565f33652e3e339e7e3d74fc42edfc9f2e1fcd8f075cdaf635ad32f0e88485da02cc5d248a6aff32b2a77f6241115693a6bb62e33155dffb2c996c76e3623d7371cd747532f154d36467d5b1fe79e2b8aa7324a92993829cc66e366f113d794e8cb2426c33462642f4ca4df060c2b2e171487267f7e15cb18232cd673123d40ee36eb6a5a04ae542e30e03dffc2b5797938a14523500fdc25bca497cd9db104baa9fa0fa42df0c4d9ac2bf08d9f61fc6dfd16c93cd8c7e42fc3518aa8fa9931c68f32d77e6909342fb3b549196f5e0331704ea57a711958554bb5c6d8e09dc323c3720b9c7d77249350c14e58171d2b6dae9b651bdef5bf244553764d867b6427a090bcf18149991a66bf9136c050c790073a49c8c43bcc63ca4f750ecaa52f3e9ea08e8967cc99bfc1c66e68a8a4d04739837582479cd7eee038b0af5d00a1f3cb33f6cb85d3f89674d809a9229307a908f4829740ee4f7db44334efd4517432b14f6aff5e8fc60f61378eb61715b12e628f3a10a6965bbf12e90395c2dd5fef69077584ae6cc59823d184ffa4ac29a5e6992e372a29a8e1ba3c8025afee2ad09d49c97302fc5c82a807c2d99eae3d0a1f16eefee7a3d6aab6f81c2e785c0e32552e057f14c802602ffb6e1714548a93053eeb2afe72df70dd147d66db351a2bfd7eb1754ed8069ddd3a41c6925f26d89f5c0f333b6bde08f1e35f6d24cc7783ac67b989d3bce79f2a1800fbb75bb4d4b8d4495a0781e7665933fe003e5a5bbb1dc6d7960f3ad6b8282bbef00071d9bdc27e2488180000d0964690cd2e21ecbea034c61d2e3739c4533c26158139c71d4941233529ad956e6c6229b6f84f0fe405bc3b7b1e55c898c4691a6afe4ea4cb4484b01b2b681fda632cb4a51a1a276257b73693e1e957fd80c8b764a07290490634c8e56eaab49b11d0f6095a62f8061a26f974f1394741166d06e981fc38dd3763a9fc12cc28f5234bf2cfa91242e4997834ac35a3e0d40c539248dd7954b5b1c21289026750c5f4f6976006d2cce3370771c4cefa148caf7329ca630e21797c22ce73a46b20d6109b20f2e2b72191dc658d6d46186f86b9f36d91c2cdcb275b79c15a8e03c1b5ae5116a132084139350880fb3f012ea1cd8bbb46ea0d20ffcd031061393dfe7149d13c942d3191303b996cfd0c3969ee910a4cdeba7feb5ff1fcb91ab2676178ffdde930ba29671140d3e43345f7cd819f425b951b017631b8dd49acfc05b60dc7234a7606fce16485b25f7f4fe3057ae35794a15c112f282f5c07c16e023292b8110251a6dae4c2a65b4099708f67559793d044b472ecf62e9ed72407b1c0aa8c5aabb6ee1225caad891797ae89cbe32728cb2e6ad97d09a8c243ad2434ae61eb5f1d5bb7b7c06b153311f10c5a5a19a126598ed424435f6fcb027a66f5c28217d05e16c7f76a7a405580457afff5552872d6d9ab006be9d7a3ae5177eeeca62b176916ae5cb094d79f10837cad8a4efa0d0922417c9c5abb7bf20516ba696e3f57a5aa25454051675c41315eb175cf8638dd6668cf8aafc1c70bbb27798671f3fb62f79741d38e84a0f5b264e9ed553f2271f778f05692d18f528d52d7a86b2a430919b51feb39d9125ec35ced62d404d103faa7cdfa87e4fdfa95045bf7b85a210a8fa261f439d86b7dd53db0686efe9e143ea3e36455461b5d32244e14dc194fe94e0b6df898d01612e0d384c807dd1c419ca6b1a8f3dba7a78e503ec186c7810c3b4713c19231f3565a7621c7982447fcc332","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
