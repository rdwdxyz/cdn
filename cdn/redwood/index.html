<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"560a8e4e0044dee4944f4459b0cf50368546e4a2a27f542760d8a6c234d37569ad3f3b4442e4f5d1151e3954e0fc483141963a736933a452fb356acbc55ff518f3be150efd579af934233296a909688a9d11c1d2e73219ba6cd6315046109570e183b3450de0c5f7464d79cca1d09253ee010873d17c6fa16a197962cf6b62e6fcf4a8681468ef1a374e1d5c3d32ee200d404a10c9b687e53e3db9d0f4ce2c45732c15aed4bab03f61d8bcfdcd6344f31baa11104703422f65fcd92aafba9eee998cf377536934625e5d44aa1a2d355f1e0994dc0c0f35864c2cf8e659071f6fed61627515a9f06dd4352a5861a321631d77bb11a9a7e32e87fe68e292815343fa2a1da7c6d712cf74174c98190bfc96e34f93f1b0b2092923a94cdd581673da4030a7d547886ab76fe2349324c606f3aa1fda68d5e5c63775cd4763ff5993cad91b1e6c882f259895a423390b3ef4b46400d79829776cc32a6ce8a9499206dba3c061ba0de42155861232012ec030794be36f0fc648e3d327ccf335329eed5490c4b7d1667f0aedeb636a79e470d5c82a34a16da0fcdfb20936c87ce381eb91f260593148c53f83c92ea1a93af71e5416c1b1cbbaeb9a3b59925ed567dd0d013beac627f2b52055f30b65ac831e1b79fb02f3afb92ff20c3aeededa23d97c047acf59ef4d8c32cedc674562df778e63e7c04672f7f91123964a785986dd658bf9e7e1f80b0a2186ead81d76f49a1851a22f48bca9a1065ad4f8d5d7614f6744f3856ad647a671afa3609582ba1d41f56b74fdf0d0c8259b1728cbfca349ec6b25fade58c50b0f2e4b8a91bfd8ffa59bc397856e111f2921b4025c57986326935dc1d1bd5fe3cc461c3a4670319861d64b21f42d7331638838f55113109ccd26bd1d478496ebca50c424068b0ebb6ab932ec5dcd5428a4e31a443337d9e773e347f46f65dbf52f0fb10d8729c09379fad7249d34d8357fe0157d806187bfda9b573eb12c042195d9be0713a73e588c079828ab9ed508e8108513063a0a3ac68fdaf425dba6fc0c8c127bfc40cb3a4b7aaff349c593c6ab9415fc0048e2a214b59bf5ca5c77a897f233897c86fa40504232031b19499ef9d7fcca3008b9b3b964770a18f713f2c6f769465a262bd99041dd83d22e8406f7b6762b77bc0a44a8845d85ec1527c2ea42242c7bb2eec374230ad9549439e3cd97905201ab36d3820d01d2120bc8bae197a043ddfa38787d44f62d30c961efb011d5ed90f0c15c0d2a440b5f7541814423d67387f90f779e534033a4ade11ee5e0915c7d525e1be07b261df99565483f75e06fb7e4bbc7f10d7bea6b7017cc9b041a36f3d8a3a10b258057b03c6c660dab454792ba00510a3ee52cc6c06e29f27ca251dcd15da3d0c5858743abcfd18a310b550d45beb96a56d8de207245fb32bd1a05c66c983df49afc454c009f1a311fee5ed974be5d6ea20b7943ada2b159f58f3d8471fdab7309904602ad98e84d78b05a1636e0c4f5fa6639fc44b466ade954979444ce0c3340c5adad552b862935fce52a16cba0dbeba9202f4e11dea342f9948affcf4feb7429c42a0293eebc236ea881e465a02124d088272b524919990118fca5d093d2a72f1585ed0ae6cc65f92cf9138244c4ec8ea45dee57ada89c2bb193465473a93a0e5a2965989289690b35eb1009020e98c6ef44b6bbb0d5b18263a28c0f5221ed17624ae6211ebd2722b20aee455eac1b82adf35a39851357531ff5af91a63dfddce850a18c9e62ea83325869eacb485ed4d0c3799ca2668bf09224be32ffeac9db06ad0d97d058ae2f8a2cf33c4bfa02d742120cc78e98f3a48dec09d43966c47f35500f255f951185d217c4ccc15512906885b12a09b4aa2dbbef8469227789710689762e44f9065e750871f57a65aeee33ffe98c4fb152f08739fdf405a6610a79f812a037c08ba7baaa5b6e8d415af40ddef67722a287f43c8ae7118cb21b1599c9bce8b0d1c2a25a07900a1632e2a4765ea4f56c8b94d6c3c2b7559c6cd936eb735bd9339e3aeeca084a5552630a809849ba63c9e21e5e748f7f9a111ffc25a29e38deb2a10a4f460b9ce2868714454a1edc9a419eb84d1271c9b111f843642354953c7cde01b58dcac8fafc938b858ddbd0ac94064e767876c4070b5e3d249aa34205c5dfa9bb702bc08d55505ae0e6c643d664a423f12c7c3ab80b3054c436ed92f60e5e8bac9641568132f345705ca9dd15810fe21ca4eb957d26b09cbb570f0af3d87d49af78c82132068271c9093ecd3a9f2e8d19008bb9b17a6a4f3dfd66a7e422120e5855da43db570a92d642ccde7c9fddbf6678846df2bf25c72f5175bbd3ee43cc92e15ad17bb1a05ad8c73832d4b3d14bdda3b9a421f9bde5316763070bbfd670923bf2720aad99690a2c06d5bfb9ba87cb6f81ba17db05247d92c1988f45710139c6d7502e5bcd73185023b40442e7fb4a3a1e10a48731a139f5665f9e991ce0fb586914180e528ce2518abfba41c6f6e1ab7d7dd6e09c1debee4307db92865f77d9b4aeda51cf2a72a6d12f03275df0b83462b968d0755ca8c56d0d88eac18ddc565fd4f7416c1bd81e3a87a01b522e5aa2b7202c09cee7d2e4b9080b9f4965041991c27744328d77e6c7012df5de68f8cb98fb19ea6666337445121a9186f5b7b8e173c0fe76b9ffa1c93eb0fd73aaf81ddd6afe9b4a0f746d4158c047649ac3f20e2baa77b3a15f085f494eb713e9abd3a1e4c35abf036138bcc296eaf7539950890344899ca4ada581ba38336f293f3c7c7674a5d331cabe42835c7254502dcdc207948c7e7ed90ef4ba4e47d0287385369a92a02e36b6e2415e0c9fccbc21b6e23850cf72e18db16ac0e10add0a7564159e253e35d982683b92f25eccb828b14d807f6c6319221036c05fd44b51940d2ba66e8f9305d1c1cb6e4ca53d5101f3d19f20ebe150589d2c5dd4705bf0c759e164cfbc6bfabdb55a44531fe9ba088dc19393b51548c4370e6031c0c3d6e034a718266a90d2815946368296d3310b3b4d7a57780faf3db993a8aaef4b4bcdb5412fc84c9245efa6cab74efd530d2f29b47fac5b95393e28d10de56db98b1fcb0897cc172d80273bbb3cfd2a98fea6f892257f3324a19ab01d628e556878a8d08cee6dc4e17b17bf511621c93e6691119bcf3de413a43910c7bf778abef609cb0463b114239c8d419d07da3b2a4859165a3907fa9397ad47589d190d44562ea8882a7228e7c4d5aca34cfa13014f7625bb679ba9ea8cd292c8eeb646d24aea9014d9277894199ee1b1ed1bdc38ff359894fbe4a815217663bb8b2a9988836170109aa274fe020ff42687c7fe396914616f8836cd9c9e440371f604345260418f7dc589e24c2946170a376760eac6902c10d6ac45f749d5d812a444dcfb0dfe9b49c2e15a708e5fd3d774cd8a0c06aa775ca659c2e93dbc92d12b2d726ebe0216ce683ffd7f19c9b08caa47fffc0ab9523196ccbb3515878afad153fff48fee7f5ff9af4cd0e947dd9b815ec108d48ab16c256580ce2b8a257d6e4ed5dc1dca4d2817a500b9862d588064c3acabd53bdd83f59f2ca914feb4e14571ed69d415c4fec92377e7f6caadf6b68022fa9770059d846df82ccb43e8f754b8e6edbbbbd1f65189089229a7e285d1a1c76f7e0e064e8cf16c9c36d901aeb4e2603cc04ad42b39840da00dc461d5e0a66e2e05cb589cce1a3b8fbb266827a8884cc77876c0b17dc29c0429b1186834598ac9133062513f9e0b8589751c02b326054d9debfda9ca645402f9152cbab987f2d123e3f4c376577491be7dd46be7853377fdca2d4ffda5d9a2f9aa5b8190b6964d99cbd68bdfaf863cf11e206352ea2641f96a11260ce3480872100d58fe732346e634ce7048582deb5536b50b0d49414027374b055b6796336bde454229b306f28d59814bae16730848dcfe85202d8b16c2724e7efbe0e14a412563af877934ea4e641586bf2886829b5679d38f71ccca422d64669e73e0e0340a4f474784fbe96c5ce571b3c0abc07fe3c661245cfb1cfd916acec759b478e8159776ef66969518e45726308e5bdb26172b5a32366ab595b98ac5044a27b46126c7ce9a6d06bc67e198230715a8d3d559df547b8385e6bd5ffc46ffaffe90720f4ecec3ea237f2f58823a5e922ab8e692d1d9a86bcc17b84e54cd044898668514a8f2a6c4353a811f36bf736f28a57801221aecfff55b60bff0fd30c43a84383b5ee785e3ac0882a0f5357399e8d6a020f7e03dd37a88aaab6ad97a3cc73f7c8626cee6f9be2569a5e78151a6f3a448ec331321cf6910e74356358fafadcd9b5b0e59fdc6d71407df5d792cf0b7e37b9cb0d3a316cac8c12f4db2983ac586ed8004279ecaa6d2b0bd963ad4b069aa6a5d6645631448bd458a42d39d3f85fa976a2196b30a71a504dbc68932491f874c7b01d3cac66e6c4cd69e08cb6d7fe9a09f388963710bbf5df09aa0e5beea9436a4097a0cddd0bee104c5090bff7d6dc30a09476e2eb8fc3f369ec4efc71d3b4254d963af10821c1d4a9376d35a0ae2c223e4c315768c8f1642c845b3b3c848ef841d76acd4fb308001354d94c16351f29479195abd5f1c3fceee2b6dfe8e98824a41d3d542a3b2ba7672a9afa660ff639ba1d6688a925723da7e8b4a33e3642d02795848bcc5a2820c62a7c87b0ea4db9c6c3f37be57b1821313280d563587ba59332ecbf8f0a45dcefec77e656f2f4a6343a17b778cdbee76c50a504a86265985faff89b62109ab2110fc528ae207ebb9207278d5b6c623b17a02816cd89ac127c36f9c916129a6089108970ab1e8863b43f96f5f987a0af0e976c25d99940db071bbf75f4d067d719bbc731c2b712eaade49a70965ea2983c5087d19a3f0b1ea01c812773ed363c7157b9c2c0137a03ca561ef8eea798967eeff97d091944d466f1338c2c06b2ba03725b64982e869e535e1cc706c1414089d002b7a991a805ae55ea442405c291bee4eb1785c1201f0bff14a7a00b2ac9d1992450c786b71dd46e78a4b7b1de3405237a592570a322f1f0aa95180ba3f7127c11cbdcc736ac41002f16c4f9b6754895b0c4ca0ad17df29dbb6aa2631d2614a62fe236bc857e732f54c71524e9dccbe36aee58bb41ee9a53670bbc82a99ed6d8c2eceeef1eaddda30a82165439865538e249483868841a5bbb2cd51d1de79a7a62918522da4b649ea8b780419b46ea0a18f11e125a253290d0151ef2f908fd47185437c4c0a6001e147ba3f2b361d8aae64a019e7caae602855a9e54d8219dadc5fd93f9b00df82d0839be5237d88abafe897787684eb009586573c1eb75f17b83fa5f8e5587ba35973c44e102bf3be15008c712b115f40bccf4fccbff780d1fe28cf49bdec443dc66421f042795ed6a5778d6997bff1199639981be7667e2da9baac9c4d8b6793faa3f279de5062d9f6f5b09f36a82434a3798fbfee8416857a414c9dbf3f39b64f1e78b997600d58905e7658151a4f0137044efd5ce27ad9ea86330f69cb64c8469f380af106feea9a189d53e82e6a9accb82c60dde74d80678287d6f48de3023246fcf85cdb9ea4f6e32da5fa4db479b4d1e4939f5dec6e5e198959d7e429e3811ebeddf844e72dabf8cc39bef8467d962bc02b840a54c48cb049a566ec2b11e619052e1b01d60a1439c2334c1d501d01f1b5749d913f0778d91f79335c2a5894f37d63d4849d8cbdd52e265b5d5354c338ee748835678693925018074e8676ccbefb2e7187ecdae5cba218c224f364ef280493bd72927c6b5bf3c5c27a5643b7a2ae0a0110ab111e357489d3c485bad5ddd80719f345765e83296fa781e0e57364dc108228a773bc8d5c96893f80a04eda9524233468f90fe58d4d560d62143a2fffe6628426220643b5697f424aa1d567ac0e6eb795dd10c6b06efef89b5f3e37c7b960a5e44db83a0bb414eca961703e87c49ca0899483fdd2fa565c31688168b9d896b07804d10dd36bc87dd653f2189adef453d4cde5d3a2928826f6836755ee8ab22db8449c702b07514153ccf164bac75c9a2dba2f52aac8e5d1596dcd83820a76cf35da03b5ad3da817c3282f4021e2a4e046b2eeef3bac3b0cd31dbd8782438204f69630b48cbb5f1c81a66f9a52faef9d3cc1e4f7468e4b9da629c853ed0d0703e1d2d4e6ce4f566438b20d10ed78f495df93c0e75bdad537718f15da6532d82bc79383b5856030141d04dc499866d9b6f121a85e6a8150c37b64fe23d570a8cd4122e7ea237d6cf1db1d5d55467ab8ea80ae97bf4c6774f31682bae4dd096040b3cc2c99df8b4c0ecd37e5c2784e8612f824e9836f08b27f3fdb781e42618d9a2f057dbd48a8e427a38d0f550c6030766b1969cb32ae26df4fbd745bf75a51304295572125b82ad51f5836da80af2d1412a341c781db0890f37485bb8ab909b8b2cacadab6fcaa2e048f60ea44995fc1dab18a5d82c22033a4712cba1281ed2fbef7bbae02c8d832d49044b30f52274b9d80f6db4322392a4bfb2a4fe63af3d943fa5924802160ff4e3a317b41d232400baa5e52a07c31b86d009979e87920374ebdb1a10d1ce31ce7ec5a60f5cbdeb257f4a7812131840c06a6d656dc07ae551e99a1d493c86f46b07b37f4c47dd1e88dceec8f1ce5ee808c78d76efb0a3d8037ac43fd2d72d5e8fa03ac655f1304a6d0346106a442771ab09fb21251df499f88e169e9932189241ea3234eb9aaa6b89189e6d42c258433f45680ec620d093e8f47e7c1fc56f68c9e6bc9ee813b3e8ded3916f8f1f8baa640a533be97904505f981d8c4a2f8b86cc6d7104855b9a5edc17d7c405e05ca7de3d36ecbb9f68d560f9d60f44de0a9b29c890bc5619bf33aca1981859d3fda5d2f02cf7164596851a63ed098590b7c5ddb619465a489b81918a781b84e01ad78298171baa741a839e4925c42e93ae7c7dc6992f0228bd96d3085216454f6e1ce08d19c26e7ce7534f78510e2c97743ad561be897f198cac634d7c30b57bffbc16683fdb4e81c002d7a8ee107296b32e134fe34c72fb6a6d5ee5e54fbc3063664f9a3746c25d56b283a52965d93e9fcb4b3cc8bbc379e144e448fdeb4651728cfda2bdfc37a30300938bb1e3e5b566d1a3a5236c0b1b51634b09fa67309b55c781424b80fb5587f6caff49a182b0a88b7360e25d0793cc7e5a2dd5c3d1e828e39f59ea2d7c1f6ec336565dfc39d543f1ef5cd314052009cce59151b02282e0b5a2748f05f176bd190408a86184766de9de1f56b48b157e6951313b72f7363ad125b01c96762186716419d6ba9c2308144d18e10739af27ad53e82715176d2158b1f469404b169778ce0e92881750709bfecb962e9c5c3ea126d94be8bed437a5df5f969728be8e0e91a299a5130237c6836efe94104b3d494014e27f2ef3724256c362a14689bbaf68ff92e1d1e723ca66a49c5a53d70367c169c8b0dc8b6c01a7e0a6e9e1908addd50387cf318e3e47321ddc3c52729cd10ca3b7c2176ac071135e391f92050bc6ef99c3dd2ff9f9baf85943d4a412b9945540e57ee78e1119cddd0706b12ae7d24a7402189707cb8f069cd5ee73398c650cf7cf23b29bc98568cd5e079e7d3a8e78202f214e4123070cd7978eb5deb9053e9ccc04fbfcc19edf51f6605f38093d0c688b6f1eb41e525939237d21d1f2d32fae4bd16c8136dfcba95c9db14ecd9165c92d6ae1002132aaef5bca96b5af5dfedab3fd3d3c74939f6d9dbf42f087c39cee3ca3278a5f1ac849bf44633d1aa778ab8b77e08d4e8444d96f0cd4228111383fa39e75b86f8d1fe174082f8545939e95078bfcf5e85b6644c07eded90e519851c5ce68e99b4917528e7d6abda596b8b5084e342394138b4f25e0e1120eff3d1851442fce0128485aa53e6c733e0dac41923753e7232d2f4ae82c009145351e1297797fafa94d217af4734b0686d3ce6f30a3a8b85578f2f43a56c3ebb79c7fdbacbd9995d1fec5407712ae8faf4bcbc978bd998dddc11b6154f09b1a46272bb761746d0996992b73c09508623e5cee85887e4e2a30dec73d9e1c84c783bb32443559a60b10855a97ada34a9822e774341fbf4163de89f4f5071087cb9d5e99e54a3182fa3945e2b9d9a1fe2730331e9b8a60ec32da730237a3ea59ee324967ac88dcd1c529d2218c6b16d7167a3930da7bc66f53a651375c3415b817866edd24979e1827af4cdafe192b0add3029450a10cf1017747edd7cdcc3d35f213e46c8619472a2893bfd371fe602a869e71d5496c97a7c14aaf7a4048fe8298a099006133bdc098ee361c6870490c87024211f777dbfab93c6f68ac702157943a983c231d977288afd973863383c7fcf9683411df335bfb41ce1eb14f807f961e72d70a49f77aa182c3e8453832dfff6f417038ee468c05bffd46468125600d2453576f5e7c3e8b66f17959523f3f5be92313bbff58e98c7e0ec4232f7273c9d76d642212172a1ac6981daf6a83613ff8875ad9f1665f09dfc418049a9ff52f96879d72a4c2aba6e514f34514d85168143732e6e04cee741e03337f0353000e75eee57f311c9d52b0774f8b10733cc61dfd614142bab122683f25043d1f4c8b3cf09f6638bb3f1c8044f06da67f9243bb2df00ddaa810837d16e263a4b5cc975e51f0931f10840079afe6cdd0382eaa83db2733bbc06b68a95c20d20e06b1f06d3ff40be87b526dd62d9ebe3f0487b70443c2b98f13bb2df6fb9dcc4f6a486d94deb7b10cf753a3149250c35c98871da972931a72b2010eda945205d732fd4e59497a58dbcf1d37113ea03243fb4e0b5b5267823716e6b0b0be2bb8b0933e7bb1d81d80d8dc7c2943a91fd328de15ef99e6a4786fce4a73a9b383878af9e2d7f1a531f42c7fe0dd63f1bbd42c04917d16b3907eef21e262f00dae0c277a7d19da3c825926a1cef4ffd989b966fe97b01be6df6cfbc412d132779399dd0fa076b0e943d01125809dec4f26032b6f34b6112bf27e4af7a895d8e72f3992ca5152e41114a5eb8d41dd65994ce7b7557775e0ebf6c553de4a675518d16412ef11dbf9e5f5bbac17ef3562e4f11ca1dc4d5ce1fa449c036902c7263426c5bd60a46ccbd7ceef35eb2095beaf14ab2c5f27c65e785300ca1adb6f3094425107ed7de89b83ef7bd81af9a2efe571c1cbe1f5b326bd8771aaaca18340d72b0eac2790785beefd091388fcd3303b30c4d1afc859717e3ec8ad86f5c8f9eb80e59366dab1ba730e0f04575e080d6c099adb8efdd11dd8debc2dd5a62c488a41fa82e5619509b1dcfd0d9c515a984b060409718ba973bedc7756e7dca39f042bb09925a77c0bde704846fbf3d7df517b822f2c864ff803d289916f2e6f2c03a52fa7b52355491fe3221c22c68df033fc14f89c4abb96b41cd528e691d397a068be21ba1f33a42f43415175d8e29978b175b0eebfc86672e449dab7698856d76545b6f10f0761250df25a0e64850153630774eeec059069ccf13b601a1652d7155524bd1d96196f87c806b0f57cfc707c88817e018c70c0bd0b45656d4c16648668539ceaf0bb461c5e200ccf2d258eaaa06087419218bfd99f02ee8b202846040ae07a5427706e197ea3763c5f5bd2960fa3b75026fa7a91c3d014cca380df2383f5c5530c7165b9475efcd08f2661d8e2f31dff722f8c07d364781e4433060c34a63bf352e9c976fc11c7ed8ca943cc281ff07fc850176aa92270cf169da985eb1f33451c892147ddffefc509fff0705a59bff2154e2d72fbdb958a71d90ef740093217c91ade7a2ba63b06146196dc40e09c443a9bb897d3480a49dd8d405ca2a78c6b67967ea95ba8fd85f33465e0c2bf93013282bf6785b7eb70521d957f07ac258e81b406583dec9446698f553b75f46a69a31200dfc25f47d001d9b4598696ed7e3dca85613ffc6b9b1ecdce06b2f0097f5991ba37bb38442ab6f450f2f704ac1ee0ecd0fa8ecc6fb0df5c3c6a00c8e3d30c0deb18dd37580dcfe2850fd29e5b588025690e0a17d85e79a5bd796ba503396b3082645a9b229cf624f13364d6ac2981be4f2765f9c47295ec11e5a128a7ca8706ed1c434cc5dd22768a96900df0f2f2a054e4b63dc4f97be1b0c2fb60bb39a49e3458aea2aa06c850a0d1470e4f1bb8450659f54a02cfee3cde2eccc19c89b67101816dfbcdf6c63189f09bff14eeb699b6a83d3d656eb07c6fdc08a62e9abc7353dbdd89ab8375bbe622dc36c6ffdf1ecc96c72de08595a515bfdac2f4ea9bd0003e6000f92e770176867b6491e34776646f3657c636ef4c2aeaa668f009d444e9723a978fc92f377fc09b84a63a3ac0060341d75ee28bb498569de9544f3c9c4e85eef32afd6ece6a7e76293aa82a03df2bcde7e1ad02bf08351948a88fbb5121e81736dccedb05aa0699fc4b4cc0661fa599138efb335986b2a3466910b8243b2e132cd20d7456e619fb510ecd913a27a5c3732f7d99d4708e55a3306c38365adfdd088afacce9af098e73f4535ee96aacecd8c6202ee94e2c8821ba8fbac85f13cb72adfe55d79e1cce6a14b8bcd4836e0ee27182fde035e36cd7756da1e74f82990a0b201d16ce7170ba7282c7d4d56bbe71c3a15ab76732d384bcfd36e1269e74acaf5d41a0c6c0abcd84c08a608160b948779066c556f098432378b3a1266c2a78f5d021f0e77fa23cd128faef3a8e4e9cfe012c79c2c9b437ae57e579e516eddb26405f65b2d680e8aa85c3cdf85eb3ba616a15790e99fdd8ca2b66d87f863554bd5f204f6c5f05c1b04bd9ef9496f63a6fccaddad3553b7b127cc376149fa78c4fe06e1ad77cac4786067b5683ddae96d0d7b40e14b7eec44bca95c8632e96d20a2c807dc7abc526166966a5a1798c9d2694e28a223c1fa302f89217d682084221760e2f585142e4da47071d9dff065b04d0162fb8bec0143fb02f8ef263e17102a87e80e29e240640a05275fa32d2c7eacf80adc407886268ffc443f03d6f242ee4fcc2f2b67595406ff0a2e63e9925252a881f080f605872cc887afb7a38f19959790b3a863e667282e28ac591e351e17c47e0e304da0e0754e9d6d481a7fbaf406254aa2fb876f5a61a78418ee71fc7ee6cb60b610dfa9c6d324b2b5551a040d7929c0cf3c89c7b07f6896f62573024ef52a5c3aa9f1fa81c15108e032d7b3d4a5596fbce3f75a485d23716961751235bd21dd59daa92681c5baf26e0873106ef24aa340a3dfd6608a5f93abdfe725940298d8ba2dc60c1034de836ae19fc8a80a5876edf5534fd5d2ec07801cd243d4d20e2b762b5548bff864132706184deae0df2acb926e6323dde5dfefadd34f4b5ee6b1bfaf97d6d44d2feed2b8d96d05f632a62c220a1b430e5af53baafe732801ae597f611872b27da9f507447c339eb6630befc6638c82b8f1b7bcd173aadb03e3fec0cd98523b83a3d3014a9611631b8aa18edf62dac9c41dbe4b4d79d2c9704a1348eef8edc317ad3470811b2fa16ecd368c1da2a0296e1f2513c02c5b3fed7717b052ec52c9407090eb972c7fb8529eabc42d7d8af581b78bf9b9fbba5a656146a0ae86820a46e925827e8aa3ed8df4525b482e6761c2276cfedf89812f6fc4c51af8840843e88c367dfb9d3706a783474bfda80cca3a4169ed2b5929df98fc827686c060c3afb7fe7e803afa23b6f095ff168c5c3f83b227c82b2311a6bade8e2907757962f210427597b545e0321a8474ec952e255b2da78e770829089542b65b28a29c6d5e189212d37b3bfd6e99fa008425ae5bcaf905d9b03c2a1901e8c01ac4c5f566923d9182e853998cdf6b0a2faecb1311de51d2602c2a4340bba182014f23e9ce83b42d0e7c98c95c82487053395450c90e51349d56118809d7b641357dc79835637ca8cb6e22b464c439ed5806eb16ad3a8fd05ee975412bd9727558ae3db0bc154261989d84b9a8c26c94716c79de09eea483f8626755913c52ebd894cad262dbac02f32b869639357025f62be357b77e7c8ef6cafec98ce10c0e06ac9d0dc55a4390258641460f6f0812cc115d1518693de9e6b0df84c110cf5a539ec1ba88ea8da1bc0c1b40505f43d411f83f29a7efea4ee6d23342824c43c1462faa616f4d34ca0256bb9c3c12be70e09dea692e639fb07feab617a57c91bab8c06bc0cf62385f42c021048d73ff33a38d5b461ef6c7bccabeaf3bbc9b95e1789d6e8d50c9620c19dcf33950505af5985688e539c2e94f801308f4533222112cef5f7b63a266f09b86c829204e5401d3a2b1eeb24d24d9a0e66859b0be3e8b8565395b1d23b04d1441db943831d053f1084784f7640a46df2a6feec986e8115c2f7fb146dd499b21a3e1c645d3f60f32f90de4d211ca504b2224d788112ae95613d8553dfc5e83b3ab870d4b3b4b18bc91fe066c59e03cddc6ac25c85e92205138acf2aacee495265acfd425e897a57126bf8b0807fb4711c7f6285a186d0327a6fa96965684ed7c0d3e6262e2ca93cf2b52cdbbd4d5e760cba56b8fff013c0718d7263b5bbbbf4183c4fb87749ed0e62ae0100a49b26c789f7ea93402228172aa8c19a4db8f139b57cba340b6d85fc0f4c99e727fc46e3fbf745f2fcc230900a876be4fb1017174c6677af8d808f989242f177af717a35aa27053825e22af5a0fc4d6ba3edffe06a8861a12db99685c7d9f79118e71855fc46c7438a8333cd8c0c916ee89898b839a16cc303e3991acb7d4da8515abdf5745fdf26273c69be7af97c60539b0897e273a12d131fd3ab24522d0f5f815267c9ce42e17c47b9a1fe21132559797276fb5d10920829fe6ec03f702401962016d9bdfdc7d1abf6672a5c6de0ea74bb9dbfdc79c7bd77d649f53ff08a24a72ff4c9645787ecae707729d105ab7e9436af4b9a2ea3ef54e0bf8564600d2c99055d41495d2518c01f27ba3cab44720a6c297622a4cc3b84f3c3ebdba379b326af6687ca12787313e74cc604b1d8ed529a9227d8577313daaf60f572fc70bb39b065938267f9607e6b78a2e3cfa8c06e88f44a8263697039ae9e7dd37cf9803e781f68a2b570bf1ffe7aa2035f61956c2f21adb558768ebb97a84e27d1c1e5b2e3f4853a384588710e9255741a809b988e9b3dca263c1d83baf6b71b814c62fe64b0e718e404175a180f978c649f49ddac1f7477dcebc042741a990378f0f14a31608e90cf9666dd647a682fa15ebc4bb428aa931426027a27a6f313aa491837213da2c6b2b36a95c2704c3ef2b18da03b125481ee923a18f0014e69e4a0f554010c01822cfbb76e78f87c239055a103a5d0586ca97fdc61ea3f063afa24350689b20578990f7a48651b56b1a8f35df163c77cd2a10116380a2872ed46ad3022a3a5748585b5a207bc7f64c16e5c863e91829e38e4867b3a8966c7b0fa46ba9db5aa5dfbd3a321ceeb0a5e7972ed12c0d14255c4e2539789a284ca43b37a225c61d6a80ebbd25dd4792d2c6f65f53a7673859a6ccab94b28f5dee17c60a83e5f9ac759cabe69efa4242ad5165a5dc26e296397187ca6be2439ff36758a541050abb112e6eb5b4fb914cdde401c63949aaf4fa1be1d7858d00c9d1b49bcfbdf03c938be73681fdee4c5428046b3151fbfb462179a9b95e6bec86b22e25454e002a748cce96e6fb770289df7f1620a517a59af6fad8db41f52fd679ad27b26114f963daf70785af90bcadd4092f1fe7e7ead07dac8ed4aeb67be4a85b2abd724e27b63d6359bd4fe35cec9893db23fd93eb640099e4a47cb06d147cd4ba275207007dd36596d6599e768a1a7707b4e06fe895da3db74925bb38b8d02b8022c29785afaba3c515dc33284eeed2859547e2d671f2f7c68c15537126b31c5a2e3045b5c9f3e264efbce1fc5321416872ec476aae77878a629e1366787e406c50475d0f046a805577104bbb176b9f4f6720ef0c3e54bbdb9db95456bdfe4031c5c1ca68cd5a63b95e4e98046eb261a5d2cd53e5f8e0887933af028bf15a404680de43807234ce337ec31fc2e3100ad59d7ab1ba6791c5b1d3e46b470effc7ca7df3c850a5983588e1c443ddded57d5660c58cc5070432e93efaed0e25aa2a7d7c643b2060e4f96989f1627185ac8ab4141bb71eb4bbf637aac48c0fc5120f2dbf4120e7186ba94850dbf87fb5a55580e514ea92855a9c1750963cc9820a3aae26fb94654617591e1372f19831e7ec99d29051e55133df184dfd8812ce87893313bb99d957e1f01d160f8f2f1a1cbdcfbf223c4177c718a9ef6febede1faca3152446c02fadb142099d99272ee8a85cc17365a43535f5e9c7b7c13b821b38ff09be562b426620bcd9502a70a9e9939972e3dde457dcb7c11ee326ad6fc49dfcd5b55ded80f42f8c38c70fc4553dc652daa5750d378d40de636b31c73c5b9badbf264a14acce27970a0761a054cc9a2a43dfc850b5f3e6a9b8ac2f280e4cd78d81e74f7612f6ff67d3e19f7645add620b3937550a60edd6062c72f5096b60a5aa0bb6e22c7ddabe894d41c279908d074d6e9014caea5257cd89783fe3cd5c92ff2f9b8f5d5c2d3394b7e7d8910aeba8d282b3643c6a107daebdeaccf7934a3ac089a66f973878c24ca6fd70194b04515c90f9a9c43b814afa64978dee26a53144f80465e4c138fa19ca6b125c0c5ba8a53db6ad15ab13343d947f5f89b3d52756d933ba525ec8dc53e561f9853d760c8c9226555407e68e5cde952ed758bd843bbf8f27c831896893a99133a1d2fd2207a9093e1effebc880a74f1aa3e758ea0017ad9c29e865c9b150b1f2e31210e14a1cf669cf80e860127380ba4da830a77c80ca0023ed931b6259b28711f63d3bf99fc58f19f9d8c225fb96b9a99ad3b0670607fa13c9af8915cc5b70cc9435941001623338a10998b3e50cc2d0d31939403e521c47e1feff42bb7d226db21e195b7386b63e16f512afb219a797819e1ac5fdb2448c5367512732ea0aa31d12df6d06b9daa2658481ddb6c756f98dd454cef8ef0ae408773b502b5b3834594d0dbea1029d03d755d8aa2fba8eb5e3c3b7297de2830c7eb7ab03f753d5d23bd1498574dc2a39478655d71fa857d754087c10cd42398549cf269ac9f32799c643f6554ae3150609d6b59cc6592b0631a5b85a23ba66894931ecc323ef0abbb2c4e77b9d90dcd7d5d52bb51c40f548d43448fc09de476ccb91a30c3c36e43788ca569bf15bd045c0af93d47ba1d257f27ac9bee7f05bf6843de31493ea1ce759fafc03cc86099d376203e5f500e656f4f649eb0a8d5b09f1598116b3959d718c0bed7205039b7a7e64466cd561b15569a98dfc60a69d0eaf5f0baa4353a01790580bb69a43fe63ea3b278cc2a66b629e112e5d4f184a17720a12c3676a3b72536c6abd1689e8a9cb207302179e7ddbf1da2a2d23208e62d10ce96df3e4060585fd80fa596420380a5934d6a064237ba2ca094512a20e7a13162a3869b8b9d1b803c61a1c5401257b32b18c3bd481a5ff5e3d7776d4ee9c7af93bf0cdcbc4057083ee5a4312b552f350f5378f8c62ddc58e69037f221ef2a23428dd8d4484f540473891e178a3e4ac17f61b5e74367831a768eb2ed6f5b2bea28848c514dd6f27b4132c199036aacef5af2fa29519f1fc5dbaad00329a506d8b1517c1b84855f00c7b156615566233412e37066c46b984a58b584a017e5896acc0358e4b7c4683d5f96a2954811af9e1f402698c714b8dc1cff521447f443cf15d50908be8d4dd9b87446d724c91d5b26bd7a9ee8b532b7bb882bd32192154a4be0bf25b04ae83e186ffce97af6feace4c2397723600d6e28ac7df017d832921ebe35a2b36da3f2eecc1998f5de772f0809e2f8dce49b55ee84ca48685867862d68bb664ba9e39aa7f7b994782991ede3105e48ca83bf36f9a56817a752e287a4c640b6585537703c1db4f184ec218d293691f0f931e9157a27a2027ad94bd3b38a02d0140aefb956f411614a68c9cc0ba916837bc77a805a2f8980da837fbfcbc3e3f47e121cbafc9056d91eb835a251a4476496160f41c10f8ee58aca901da1e70ccbe308cc6c95d9cef03b692e4da8520ffa072b0835e7c4d4c0cb5beac801d48868ba11e9713abf35bf8ac9862ee1ef8873e8c766eaf6c57af550c4e66173d068d4780b3ff386dea9ecc1eabb247827ebf37bc00eafa3b152161b5b40a0144497e3f399cae4f628bb726e0cf03755f713a82e0088928a335178db9a48224d59785c707b7976d540edab48008657996dffe60b6944697da8440f8c8ece834f5560e925cbe8312d04904b1108152c04f10a69d32b726daf2b48b7ff44517275dbc6468ccb570c9b7d848cef78edd7d97164b7b1f4d6896c157fd9b36235354e1b7a7f0a12298ff987c52dd3fb2768745f1625e0e7f2130631bbb3263b71a2ab5f360ed19dcfa7447d0b43bcfe1e7524ef6ffa007a8bb0f900c7364d5f00396c3a5bb9e750f5cb05dcce4f5b7f4ccf8734042b99639da10e868dfed2c74fe4a8f3bc29a9a61a9946b4bc92c7cb629d43f9f72b3245285b73b83bbbf0f9e03f63189e069aab5fb2a806ab1d3c3f59fa9e3636fa11831449a027a3afc70e1db9b47eb0fb7ea0ea6da6971abc0f6716f63b0159972f56769600a4cd1dbcc4e03978e4563a2773e4d9ac0428fe6c216001ac206b87e68e4d0ffce1405f31a7912185d1a54767fad10188455c0d0a1b787a33c6193dad4f10e8ad2a53be31b99cb10a5235ee9a43e5430eeb45b46a4022ced4953fa57ea5e5f2246de7014f3719a30b43be9155b2af814a2013b2167e8d2d9ef9e7b22d05a20d3c8c67be01fc158b0a6d85d1581c929abd3b384a7560cd7724bc17a32877a27ea089df4dce9cd2877ea5b55fe367a02d3128c024353785201947e8278d2f4a1ac4418c93aab3b55ab00dca1908cc84ffe713e35bed3e95387ab58264f475e725046b275a257820a9658591a0dcab0e36943e69598c25158ab40608e84451563d6b2c9f8a6559bd8b86bd4e3f11c76a515f322b1917ee9d72b6396440f298c01073b85f4018a96af13528b98c921abca50401be8651e7783f921a592a2d59bf663522a080a74edebf0e39d0733a072a6a30b2b16cd4987751d519033cc0afa9364577c127d7e9e2e75c53f057fe93c44e4669c51b7eb67d78988ae1f586896f199b8534301346355480aef094ed2958b3919d4280c67f2a8ca51865d9217e01b5dea951616f108eff16cf79d2fef2532d014a11435800e4561475290bf1677f46ab76b5210d0271e3bf9177be9ca8bfd8d269ad25c666ba3f47f76bcd8505eb06e9a1942e9cc098ab5082d43e8340f6f14e29af1715cba04a52d6b105cdb28862ddb6b8132a365b9bef345f13b4796ef96874897f10d42479cd5b2f9cb6a29066917f8655e9538c21b68de10262d76d113009cac5494b41445a3eb29ce707281bc85636054b824364889c77500dd68101a1aaea577da8831d81273c91ac6943135ee518d0878b0803ca266108892ee8e1220c9cb2e7adf3bfce42c7d5b0cc40772c1005abebd232e91c8a7901345b814d73c4bffcfbd4fe4a75cde80940446250d408a125d0f582078b18abf4b01a35193f973452607cc4faa78e23d3c7d22da1de42f8d905ecd83af2f8de32f6f8d68420a9f66df8dfae66d754ef9bd6bb4f893e9cb4f3b6f6f1e3112caf00c4f41688770ca8275ad66532d49a712d4d616f8699597b091c81e438ca4a0a8c261d32b144108985433ab60e87f46e07b25f074355068f9ce9aba070c9c56e6620454f29acb4018354b73e2cc228384b40d12d015bf0d868734d77b0669b71de0e71ed2343fe4a398ae104dbeb05ebec0e69a46254cf693c49f1a0b5f8339e618863946efd285348ca20f375517aa25eed027ff49f236ca8665f092e604c7207ab3823985a534c1f461e70303f742d689861a868baf09a1257dca1f5ea5e9f43975f6aecbabceeb66121092c1ffd56acf591ebb2c704ff8b3aa21338cd7f18f3a5075549","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
