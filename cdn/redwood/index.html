<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"931ffdd780a61a0b099b805ca7f3ca07480d4e537d9f309e64117095bfdfc9c1aa04e4a184f45b614a00a888ba5933dec3cc5cc4ed28551572996d50a96c2195f67409acfeee4a04bb738b6c6c6608fe34180498df651dc788d73cb2672d6e2269fd672ab990489cc7163ed7c126b5c4a1a94fb015a0e5e582b2e6142785f1e216b161382190bcee85211f409589f02f77c8bde7c41a18554e936d02c9334f0254fc35931ee93758b93b0455e8f21988f16fac183ce0f0809428adb1957f95bae7b4e3e450c72fec9c6f70b1b18a74d8b55ba6ba99106260f0bfcbb3868cbf4e33785d07ef172e2379748c7e742598d8e4783d629497472f770fdde134affeea82543ffeacd801ba62e8571dee0bf2263cce4fad64034efefe6dcb62b94b11ef4db1dd8f28a42a05a583b59017e42b318aa4dcf4dc691663efc17482b3ec52b196ba399aba9a615bf966b14dc5b8bd25b32b6b2503518315f0de628c985d2f2352f2a498bb5180943e8bb7759021a1b83075203248160c7cda0a6102a565d06fcf9e9717121f35d406eff203a0594022852bae66bb0e4c9df590ace1b8a6896dfaff9e75628442c9eb506f1a69eaa523774f484066a7cd8a9a76e8138d339de80f83a70f36ea2216af897aad271a11057368b3da137f8b1828cd56fb41438d382dd4fb7837ff4b7cd077462dbca344113dd6ddc68aca475bb3bc753debeae0dba324016772c49bb91c17d37bbdffac07d9984e0adc932cf683d5a40fabb7f8e7b658ecc1a46693defc418e18af8eeddf8bf4f285754e34760196a507c07dbdf024663e5637f985375b9d07dcca53e3bde0e6d9e6a0ce3745fc6c845058b2bc972ebe8ce90fa197c5ae6d668a4f0e1336d125d3f207038986efe58379d591330ac76cfc48fe84b13d96e441702950f5bc6fc5f5b4a79560f3fadebf8cec60426f6326ccc2f0f7d559eab61645ee10fd3787db5ab3c1347a353902b640746565cb82012272233922c67d5915b8fe8ca5bf599eb4f8e9f75ed7ee2bb8b20c55688a520dfbae17e76837304204060e0d1831043d6b1fe13706f2ce826075d206dedac5795e9b9b86d69a05fe0aacafff1d94214da388b201e30b5fe06175e3af577ccf1670c5fa4f77c344b81481c90d1f354a04e98bcb76a2e6146d7adc00673ddcf8c5f63ea9283989e306e2d2218c869208fdab5a7c7578669d18bbd96ac03430ed77337784434ea9512783448e317dbef3715d186eb8f007ec27efdcde73ce9bb2ce7244f3342525a8b85d0110a88ae101e8f0f6d974e119f1c15424c9a01b7d82f0ff7b55cc4e3e05e9c2d3de4505a8bb649d014937f98e205a9a6fc938cb43ac54bf126f7281b45eb19ed2fb7230d29b548b7e15608c0ba2eef8ec0889c9cac6a12ba522978a27c4e2268a30b7f45fb82089f692e290b90b66def877d7925db36538ee6676b29c0ab9b5dd46f47e1a4e2e60e90bd3d71f47a1fcc3d9a74a3e7fc621a349fccecb8ba20da6034fa5c920326be4d8aab0abf166fcf3dec444c32cbb3d5d4508d2a2facef56c9d15d04f2f7ae6b32a578b07ae2ead715671e61d98bc4ed8cbe890271f7951983076bc3070d0021267ef49ab106936e53a39cc7564007a912d350378807f977b585b77e1a08625f407639bcff12c42c153f1f1294179de4580d479b3b495a987dcdabe3ac47f47ee05e8ed75e1d0674bb8c7767c3528487af35db9c03bdaa66da7c3286faa71db634a3e9272aab7c78b2f16a6b0b83c28bc4be657c5a0e3783ac9501cfc23f6c8674d2cfc66a3e9bee0888ea0fc938dcbb291ebf7410d6127a7951dd368ad8b6328a4d3ee42bdc63eb05c1774d01d3adc08c0349dd7da1d6649d805754370e0ed5068e5c700ee5f52f73a0853554de49b9034bd01dba209784e1aee8b9a0d476d6f54ca7bcde1389558b6305d49201ec319b35bb1a8f735fa4c3fe23bfac3dd7a5e748625d9add8b6eccd8f7af30a0d617b8736bf92e04a8493f90595347dfbfffd8e0110d740429fb906dfd1f12153f0e7418286e6462be0a4b30d42e395dd43c2111ec475f35e284a3136bcd1c22f283e8c356b6e97ec5fcb5c4a2e471039bbf238f082f0781da44a53e78d3e7310b52e88d30a5254580b6498e6e07e5abb5a716f83ca3afdfe8395e2e22197b07655f42b87f02e358f1634ea33dea71fd56ea76724944dab0e241f6697e915893961b885cd2e728bbc50e22f9389523411ca56d1535f1cec970b01fb7fced7aba7ce7a8b74504f0bbb037cd0f405984a6862e94512fbc66f32e05dcda00344fa8851469c87aa052b41a30dbd7ecb5ff8f32af69687020389352f468e4f355adff94c579599d8a1764bfb997ee7f35f1592ee23ae34250894a8af1b50f9432424431c8554605e31309f1743540025321d44c3827c04e62a5a26a75488f045dc586921c851b14120b0efec20a894b026eaf4a7f935052e801728a468d7dd884336de2d15db949f74ee4a9b057e9b49cf6b2d50c8c806103a4d66f7978dfe89fcc4911ee0c3a71f78435c4c0bee4081528746b383544f079777dae66294264db3e2789d5cd3987ba12a1477f5b55ddb3a40d19a67af84b3bd6f329c5fb7877433ea52f2cceb567609142b3a33bb0a6f31ebfd8dd63021483abd89fc354deb8703e274ecd09a15bde2790abd9a901d04bc5243a3d4de3e8efdc709bae8d1bc68e07d566cd2533893e3a87ea8be35b94a0aca1ccb04dd5ad7bba33bc95baeca30bbf74d6309039eae660b0d86bf9fa85088639d1954ea1724c601388387f280b72d6170e4c7de733d8eb6d71d39d1b42511185925bbc5b61dc45df7474b96213bd55e4788c5bcf1cf10e8f0c4d32f633e7c6e6677efcb48b4d154463c7301e51f6c65298b373f90554e0e4c6d941f1cc647951d6a13d22645b88287043d9c525e1e1e28cea5847873fcc25580286c116c0ae538f8a5aa7dcf9fd009ae271d62a41c376dafa0a56dd0d25419f59f16cf4a1a71e40bb60c44eaba580ca85de8b95584d4d8080b1d48a7bdc518e5d03ce1e61a9ddd45e6687f60ac9a36b2e7a9d8b31eea07894df6654f4474d03092e1a0bbde8904d05344d6087b2b255f34800c8e34bba310b0d11777c6b955539ae88b90827cc8caef0748248a42f1cb8bddda9c29a3938c9c6c66dbecd43f8dd993d8f5030d344118d93da433e57d5f6dcbd72d25bcfb390860e7766ae4dc69c361468a3eef473dc0d0db69acc42ff8a90efb535e8b0ca73371cd5ad2b3ece57c4cd481cc37aef12ff043c270a0fadfeb3bc84efabe3d4fe8e1c3737f5d144bed38f2d87545d82cceb17b3f848de039c7036a813f3d87793ea16559bf996423266c2de404968287d46343cde0acca24684fc21df5c484a1778fa6cfa517117383823ff3fc136874bd6955bbb43f1263186273f570ce1a659ec99bfb0f717fa4e0e6b19b0dd0b8d171ab48da40183a5cf0e12febd5fea810b98b2db601c59b9ce7e7743efcb2a0847fd0709a9abcbf3b0adbe3d0afac1acc9141418b89e2208678d87297c4c59d4856bcfd4ac42afebf04f633d4353ddaf54e78a16b13c8ce8c0b46db18ad040cf5f49eacba4e382f702864c8fd8e597b6dfc19336ba6020182223034c52570af7837c71cde137149c2d8cc0787890226b402db8b465f856b31ac8a28ab93d77f747f013ec0962ac9193174fd605918bdc33067d20f864653f8bf146c9d7e5070b353749de1eb058acec05c4dbf1b41c7323954ee95c7ca8bdd2402d54b01c805e3885306f65ea4117b86cc930fcad707c2bcc7cdb0540d4f2fe55e79422c3b782d39fd59ff988cc2d4c5edbf56c47ce6ae771fe3f4d0d190f3c5916c3c15c1353db2d17c28cf78db4b636b31faa052240d98c99d823116f237560b9c31358b7aceb03fb14db1b86e49ccddacc69a3d3e9ffd9ca4fe85c85ab9a9e94407942ffd6d7260988d0f2d69fbc39c6c652a9b37e22d469340c3d69412848775407dab7792f99f284cae8b14f55f9bab6f9718d082076730f664f4b8b80156f9ad58f951a822b4aa341fff694ffd262169e5cac0651dabc7816799b35cb96031c02e602194947bf417b3f666ef1d62bba5bbd3a4363cb19307184696138db29595050d31b2c00370b999cb084b849cae06555bb942b29383852b563ccf3beb5c49668cdd9ca19793d8763e4a31a6b1defb240f516ea8624b78431d9d92c3860141b2147e99cc4fc1d071077b0612056d976ef5873b296a58be8883db66bc497888bd8a2c977c6e66b8bf8d5e0ffb6e0ce098843382a1e81afcc871eebff1f3c46d110d2c66286a14fb18e7849420177aa70754a74f2190318369ead7de049d64a26a6991822de6d8ec03db1dc1d9703dc3d0247b204726fae5063d1731df06c3c09b3bb6ed37a96a4881457a4f2d8163cc0e25cae319c970b2d834553858b1f5ac0847eccc9162326e320e27cc0c9fa2e915474d99d55b6c215b021498be9961d3911424359583f0394a49e1d7a0486d74e7556f3f94407e9465e1b449c23d257cd79f6f784c24884d5142d19aa94f7952256e2946e38f26e0a2ca9c1c4d5a829b733572da1f0d035b471677717abec791b979f39b5f883303b53e18d4c635ce1e7d2d3f8e4ac8150a2ae6e932cf87936fa9a246a7fcfa35bef93686a5e76cb2c67cb0810234bd21d4ad131cd858c2018e98f1d4dc2d2ac0aacb8bda5d2c719d8bb12837dd206e8e55a20d76fa24f8e928f8db33decb29a6b906b73273a65cbbcbfda2428595f5eb4014f9ba0329e82db3b7828a228b9d2c0c6a77c6e0e7e0d649b3f1784ab22b57eeec41d36213cc10ed01c47ee7efa810cb543f61b4b3a7c873dbaeafda6aabd6657c8d838ecce59f07c4b491c6ec53f894b738a68a78abd1895e17103903396d0c2c24f83689f02a330e408f9b1a57847907958592ada6e8d9b64cdc946b64829e45741b2e5e5d0821d73b465efa14981b3d30356f76bacc99096e43230bae9b241adc6c2ab17bdfdfa415bce3ecd88c9115709c778ea1b49c892b1d3ef9b5c573dcd943c7c3445ff6830444ec0576dcec30b01064ce26f8650943f82f2afe8fe3c8c2b8fb2811a562a290de9dfa6278c877dcd7686ec785309097fe58273516252e9eccae7b23c20dea5e910d256ac827a7d2bc1106ccf3162d20763044a75c697d3bff5ceceeeeccadc2643a06658f715aef792b793e99dc7a4414401118eab0de6be577fd5fb46c66d8d8af73d8a3174170053cb1637b95d8191763da3d89c4f98d64760ec62c6448ab73626b2338f4e25dfe013045b63c39aeaf8ce5559df1cd4a915916e6eff433cfe8f3f68fa4e65e30a298320ab479a726215f7a4d70fee29e45551f4b04f4c514df868ab4609697b2bd34b2818ea4d24a4216c637ba1d594825f791ea1bca0ac5e12a70274460f9748b933bec0a71f3f6baf3c23e8e956dbf00415755d36b1261382eedc394f1ab395a63dfdd4468c2927679f8167059d4c50b3f500ab322652030f89536597e847766ff164b18a8fd607423d19e101a396eee13e0a77872abd8d03b7a97bcce9086d31a97398bb26e193598cbc298a101e8d6e82a15aff6558099eaa09cd83a44a86abe489aa1854fd398235f2f2845ee340410d7365654b373c44c8e3a2f6b3477bfcdc425ba5a2d2465dd70bcece82071f1af6c85b065e0cf31738db89fd9a661dd8f62635dc82307d35cc3cbc911fb148058a32f49c86c284b974fb6cc699b11a01b3fa55d41497368c25760c86ca52800aa6549020298272194a5fac09992e1b7d4a5a657625e9bff842b623a0cc189c6706edb6921664b13fa14ea4c58b6d3ea8976a1e900bc75cf5de1ebb912f3dfd28a38fd05c9560370b8b6ce5546090d9188b7a667a625ce9ec80e19af17affe5e8a82cc50ca47778351124be6b5f3fae237c97f3762918ed577e4e74de4614964df1b3ffd12c17773f2afdb427a1480798a230e1018f95b0040f88da3419e21170386ea1f50ec8e42cd048283a79eb9a96c66669bc080c1f73dfa12badc922ccb69dc473f3ab7ed98555c4a933576ef70ecde3eb08c4d277907d641700077b7aa211b6c0d38164b702d38268596f6d58da843508167a687e7977bd7d02b9df80a38ca5e9c550e805f6084c9eba064c97bbdf6972e8961a406236ba21e3a3cab0dbfdbb2ffaaf32a0a41229e9ad610a15c969130307b7b6ed2b5b08935e092391a2e2d24d66525c89be310145d394a20e9fb6fea3cbc7765faf69ec00bf8c96683f2358855071f7e24a27fdc326bfd648e8b31a848959635c4b1d5ef9767e5dc7838b3a14efd309bb206bd11860aba0ceac01501ece7844d02fe983c8bb9deb51271f509d9b13f852f07f79edac7585a87fd3370dab1cac748c162a63aaf9547f13a78ef76e7689561a4113982416f654bdb44631f84a56fa0cd3d5b0d3580c91af27c074a7796738381dcb929ebbfa1d4ab9d3a3bf4473fce41536db5fafa48791abfc393bfb9c58027c50d8bd459eec6074fa61841180136d9d9d2392895c401d201c7ac2042194aef0977d4fc1be591ab79c9989cd8acb9778546e36a4cb66a1390643cb3b2b689345f11ca93344ef0f9907251cd4560ab0b661cc86c1de665cec3f4325b51a5b14b3a06715a508847d225513f51934dbcb14a0d20624fc04dba0fac0dc58806e3d57647080e00c99249b3feee8df2096333b6b03d6a20733bcd6ceb8988ad33eb4aefd3494f9751d9da789708cdad33c7bc95eb2ae0926e028d5a0a7fcc99cafa4cbeaedcd9bba0f05b06b0c757bab7c6a79f68cee644fad5007ba53da0c1b9be9cd823f92549ad5ef1150de7135c2325ff8e4c48b65f3906c84b2bc4d8bba3db8df8e1f417ace02926ece9b5d8ff6ad0b37919a7cd2668badc968f94a78f3aba3d6fc0c293e243915cafeb94e83b55314abdf60fb1072c4c168c30f87d896ed15cf7b1aad35ae812ce0fb8b0570d8a5dea41d4ad48919f5811ac2f2cd048e6a62a23c8a0de03985ce2ae23ad54d66f9fd1b743d96c5a954dff1a9e7a909c8216ecbb1a7e9cda353a1f32214bb31c5001acc9431a49687c7fb8395ee655881bc3722596864fac9fee0dfde78afedb0e7dff0a16bb69735c979319a059a2ca1afa5b510e48fd95df9d78fb7488e4ac87a5b7e7f8d344c7dc07d96cfda0a083ebce08321fd1956b7e3af46965a1fa412cd042ce2e52ad129825b6e985de2fbdfa1cce1dc0ed6568cf83f12c1a7e167f6800083a0103aec133750edeacebbdbdeed8e65dfbf7c0b5b862b2caf60597398b11fb27276f570b9d8e095d83b91b308ad8b9a46cd2bde986f90e9c27ff0d623e837ee6291cf3b8114f35f9bc40a3088d2bf1bd47595fec86c084782a724111491294c09cf6652917da2c2453653ad3cb19899be33f4650c974768d1505a49f2a4527f39d6d0047d2e99b9f9980a39043b9553759ab73b849bb00abdde2ae51620342501adeebcc595247801905c93b7c5ef56a6d35b8a86be2e54c10222866745190abefd9102d99e1cc96c866390e737c6292baa558c20b706d298426b8e2b2540b8f5aa261473172a9fb762a5a534eaa4127cb89a63886869b112fce24ddf6ffe27354c1279af1207a085caa7ba4cb612130cddb536004a5492591d6e7e9eaa1d6bdc4020a20133fc1552cf2b8ee70c2a791a8a93835f347e5e184ba39d43498a7c74ed1c96afc720b1d482f8b34660bdbd8e34282b03731f5962e19d32b74824d0f21fd8d2799f7a50496b779d78b701f81382153c9e9559d77bccc411287a9ddc1de1da35d0fd50291c8f04a0ec34ee3ea20590bf2634cee79a961755111ebd208f0d1175b8c5c07e7f50f38c9a6b2177dff762e5e42cbe15ddd702b9144fc3fc0bc11d5c4e3a5d5601f356559c48415211c29794720552f5e636fd5a0153ca64fe59873ee75be84d50d12bb07cb36bb0e206291c0ae07d6ff01ff2df9ffc4bc0a10b6fdcb10d048a69747356e4d81cb6b0cf67ab69ea6d9723f6bf09648499514daa5f6f91072e1a0af4d12cea29eb36defe79f272f43242ddb3c43d7cc44a96482351c2673a6a890aa80a52f3068cde55ba69613e98de011376a80b4ef6523e7c32251d7dd25c315bc05d4fb60ad844b18f0821b545b04810639228ed7753570102cb02ed1a4073ead2caecf8ba8c53f0d94c3f018c0b5a8a99c64829d32f70c3ef32b3266941e83de8e31d8ff6efe083719077b2773ccb8c347e33d826aa4200d605aa76fe3359a7743cfe8365870eecadec9215ce160f2917f4d5dd90a15d4a29376e45606a90f24ab17175bbb4ab9a44d174bd248154e7025356b35fe274827798e6b1f981beb3eba0670008541617523a47fd35d0e775dc720eb6c0cf5e090baa59e3132852aa1c12557a160329b0b8659cec9b86c68c720a2e153b0e8105dfe717af2b15736639246f2befc2c21b0848aa18a70f282e44afdae7e730e5d28edbf883965bf4cb06168ad4d759800a08c9da1bce061965157583321da570d4c0efca0f2feb3ec1914e8029413451f9ca705e2fbd88a39b82959cdc0fbbd939d8c56a31dc7db8b15c6b3a359c6b9197f642908da723f09e0e07945ea66b878c655bbd21cfe73ec72fa3d65b6e80114b40d34f3448dd339f65142f68084630544ec732058b12d415f3484b14176aaf5bbf9ba67fbc50ab3ad060a10309f4d815de2d8174e2ceff91949b5d45567d53f9a2dbf6f00d3bfac165ca0d8ad52bbeae60d6d07389f8975d13d287a85ea4b92ce4b02a883c83e8d4b703d4ab4e29b4f48701131f7fa2926e1bc40a4ca380c2e4fb6d6d1744145465d2f7f3defa7ae8ff76c3470e7874f95e1b4b050ccfc765145c65e34c8bce1c40d8ad844dd464b06eb06e5f2081b3fa77cf7610cd454d89a476022a3170606505be4b62fcd5a5b3e8627ef80cf4351794eeede41b38e5460aa76170cc8c263db5516f33043b03ffd592b35871befad9d5fd89fa3b4d26a3e12f3411c2ec64c67ba9e566dc25bb5e860f1a552ccf10399f37c0cd601370c650bff112a733ca54c7c9b29d2c7c3b9a39fb780e9f3786ce60cfdfacba461dfc3154a5497bf5237c486fd6ef2971636d127c4fbaec24f07b5f917e052e0d5a32b7e85b7901b09d8984b41e6fadb29c7f04639eebce533bc676da4e20b13af2d7d17a92be176a720b771818ca03c393ddf9531023edf6314138a8c5e02baad61cd6b3edaed63a43af48d2e21b0ffc81328e1064f6898d83ae981e56efa681daca17cf6e703dee95ea62b6c332ae628811b4c598255d48bc107ec5580a1eb5544c2541608a7b813282113bb4f86621979c3c8233854ce4cb81dc3398e7458e6dce1cb1f2dd58dff31e4f5e189e82e729a3fb31b370d554c82bc008a49b28d2ac125088354a3434de87a53512862161d6f7ce8eb99aee3bcae5a9b1071ad8ff097f8a21afe617c16c1b489d0067a17387506564fcdf67f90f7611be56fa141b68ba2eb7befb5fb099ea552aaf00511cc60fb6172952fc8be15466be2c305d90d89db5d56eda1a524b9e6eeafd44e6919b991991840c2a76ed2e10c8269385d31642a697bcdaa7d722ac349fc9b09b89fd442b6c618a0e740b4b3aa162683c7798a094ec496f62c0ba991bd38ff71bfd378f76eedc4b2b90cd2d07495078d4f782e9b8e42d82404f30cc27991238229624cf88f3fbd7de583d57a3359dadc9ff1a8fcc8887a5f770adf2a20c562e30694abb1d284bb0ae0c5a86dc36675933c47cb1dd0bf077657504ea4fb338fa7f24da6631a4a6f75c8ef0decfae20206bb46d8941973313715a7240c76959b48d2e28ab0585e0e733b8bade122f9996b68d0dda50da46ea8727d26afbf212b843da9462b943112328f3e0610db842b89f5276a54f67ebaa97eb0cc8c0a6b969ff2c5bba2979f30dc3a75b5d95fb3e0de9a088d14e72aca6b852e2f9c545cb2d619d0f8a1aed6e705c4f6a31b34cfffeb9c904bf3d41b4386f771b88abae32b6febeeb11451d1f8efc729c589fecadfcea59a888e88d27e4c6123601e03f57bb519f8829e0ff5e4baab5e10f3138ea4d121319a8a502529c96b326df9ed84d7c262575096e7a46b79a6a2e4f687734f8e690d4f52763221ac6d4310a7b12bf22ae60ce8c257b4090f7986e0bbda9296900b353044cc895c99cfda7cf987fe01ebb926a2bfcf9e8b22a599faa784ac31b0be3bb1b15be3b78b2f1a33aedaf5ed3e73e30a10a3352f4f4a91ec2823472c0618e4e3bcc2758ddc35ac82e8d6121a5050c09e9457f7d3ce52af55c4d318ad70d15fbc1cfaf75a94ef40e6b6c01bcea609a32984cacde1113264e9bbdc85c2fb01e058baa59401640abb79003fa85d612c673b731a903cefeee16ff8b24109e24b7c0d8a70894c62c7f180f895bed52bb2bef754dc1ec98abcbf0526b74c9705d617c98044cde86139efdb1401dbf1f069abbb02bc0f0d2f39e25f0c8c6c885822c4f2348d290e8869157d22486c80d1ec50dbaced8792e9ced01c81f40e743e7f35a605a1a74217c0057fb7d9eb0a25ff7a73adfb156737bb89a34cd999765f5e3bd2279ec6d9a139e23883de96d0bd0b4812d6976ad7140889194c4ed068da3c7a1b7bef1df87c564a4aa040fc166233ee73f6df7dc9de6293cf960d99a031f4aa43f49cacc4aaaa9556755f26f530fb251c35a2020d1f3695c4ae8a1627561f9c1dd23fad21aaa53511c2e2e5c6b9f17a05b6c3490c8c94dfc9372fcd24a470d9140e270e94abd5d69e5d72779ebd502f1274e3a2b0b5215c36d5e4aa6b9502eb3e1e32d9551bf98dce02bd2a707070881fde31a9c4adb3c7e89e65b93f1c4c162dfd41bcea9076fa92d4f34f8f12fa596bd4ba297b0afac123215acff7fa55621489974cabad4b3477920c5011fb7210955e5bf0b4443b4ca5478b2ded51ee602f87f877e80772d618566836fb4b74271511b3796698c38fc30f3ffc9bd67986c0284d854b3f9afe4d60ec3d4b771d14e47e2620b69f8c04fbea3cb9f7f59862f5c0553bfe8f4a596d37842c09278acee0b0937321ec85d48573451146763f0f505bc75dd1767032ee4f0cf1ef75c007fc8e551ff4acd0b84e453b660472fd03093570356c0e0a5f5fb217558e4eb0b76698883ab97dbe4f56d9ee6de7a33e76fbc81c10dd7d6923e4a6f1075c8003d002ba09a651f5bbda61775c7c107f0c7f0e67ec21873f069ff6023a8438ef90ffe05eb5e3d25bc90c1d13fb2324cd99336e3bb2a0b11e94d4c83aa72d8e7ee90f6b1316c7284dd4d399a3cf123d8abc1eba46617b1217195e0735dafc7c312cd900814bc5e2171a9888eaa2a53d77a9bbed474b7d2acd58622b06db86490e62ded359bc660542cc1e3e5e48abac3b7d182d9c1e9a3bd38343f9e5f788965b9893e9c3dbb18df43f99c75af69a85abefcf226b2102528fc26bffaba332fcea1a681db529354f6b9e9cf753af401d655999e6290459ede4652e2904912c9455001bc6342b894dd59a0d09a09e7d8459b682d039021b8432ceb722612bb06728bef3e9dfb1d1561628b3cb9540dace7a24c16af0a977dec81aca9d0f2f6d51a91e6670139c2248b1758480c19b1afd84801d13c0e9cfce0666b6d607cebe840e735e1343858f2daefe816eff1df56980b4af70f257e5295ad13004f56f854b484738e318732c04b49ded8ec9a604b5ff716d452510274483884cce9f3df3b4eac522eb81bd49d8a44b3f0cb984853bce9594a93b9ca10c84d8c153fa58be067a471eedc76ae5e2e8761c11c2174399a87a44090e22ecf64ad07ede7646962e21dfbb9ad7a9c264f62aac8caa06eb075fab3638c46c7008153317a5f7de0495f193ea5a303f1b2a2ac29b4e6c526c817a9acb3bf9c41ab9b35d566bdab21acb2d5d1ad82496eb09c47054b96cf8951393450140eda4fb446c8f8fecc7dcd597613b2668352b17db830c2d771433291d273a9377b84b21ccafc819b2b071866bb823efe9bf4a0e68e69c9d9f581b31e9dfa4bbde7ac2959e3c94211fe654fe2a7cb4c3ce06b601b2ba78aeb198c7839aa53c33030ac16f1618691c823e4e3a372aabf16e47d090b7aa5346d8116b2e43041b41e62f02b4de96c1303245c303e3dc41d237f99fc7391125792dcec3e020122fe77e0772b5988d976359300606b2bc784eb828dc0dddd65f5f3d64a4b67c6d8fb6db9aed6818b916d972fe1ce191dfa693cfdb876a329da8d8c1b50afe8ee52f3ebf0448f99e02f5665184edc8113acd1ad9046e50e8137e8e4d928d502c417846b797459bdb450f7ca51685cc1a766969dd2b5c9d291025f7785bf16b65e41690edffc6be293222028474c2b195703fec3a58f785302c8090b6d12d05ccfbe9ad2da2813e937ba3d9ef625c49ae5c337560fc8405a63bb0635bc5eb8f0e9179afde7d21aa089870113658d18e5d1e1cab310c7bd14d9e69a8e0d813d31ac3e0c49675a45a50af9292439c3d1f9461723f562a357f56e1ccf7a66351c796383f50c9dc39f584ab5ca6e749ce97ce7e9e454887748f2b96a80f6ce99cd080bb2cc26e5927c469a98716779f9569ddda19cdd32191abb44c6a8a30285736094951cc4ee16af5e1be3cea9fd2185a7fe7259a6c98bd3c80a06be46d6186e64facbd95546b41744e3a77dd66225b822207eff40f5b226bf40bc6e44716f135d32c8ab00965108091011ded65750eb5deb59559d7d1a0762d8583ab10f9d448b93953b8d07fb99dab6bec6f991f063ba2b3285c0db43ec81d3e2f9b93d9cdc6304027f01b0ed2ed564f651e175dedf8c28f436558cedfb67f18c5158c5b164170ee44ede9459a3744f40b444730153fdf7bc422f8ec9aa2232441c7898bad478637253454d3a24efe849fefc6236a0f2edec71d7ffa358f8af2bf656c3d5fc21fb408b8c9692295a18344b67f1687a636d9ce6134d3f31da971d0c018f2477fa182d2a9df8cfff2b3b45c4cd27614d8d473e8bbadf4287cc8974543a18e86396eff0ecf0cdd7cf92e270ced8f788246980438c7c17e310ef3272fb1924319dc388fba9ba2cb89bb75250d3cf505b3d331f773afe4a73c499f0b5847316674fd2451fd38ce31c71f4fb9199f1f45c05e6240f26879c64a06ade156cf47fbbd14086ecdfb090ebb5f7aa412477dc6ad28618f2a96c548967d9561a138f8d9bfbd4c26e1d250f36de026ad575e464bd558bb543fe4d8f93423ab9f3ce2b9a8c5657f0684ae94643b09781716038b98b178e20132d1af48c5d7582b671b43cabbd2111c614b0f7575e6cf029c5048f8d1d0af73f25b5876a9c9ece1f8cc30141deedae1a2413ff7f4753d9a63a56b0962a7380ce2b05145a034fd158f280de33dad47a83d871529f81c06ec7ac622a9a8d3bfcaa4a7caa8181e431700255cdf3144968d9580a2061cd0b21582ba8af0a8c32240f6f3de5e333c84dd80864387f1bac870d608fd94f696068fb58565dbf826bf6cde0ae2bf07f2dd6677e646e12399e87a724affef860c170ca7d7e64f694955c47a9dece4eba1ad21280a399fd5d37b15716b1caf7fa529555ae5dc2adf1e25fc4b25fec3b7a155685289d9be730bc7a96485f2972e346f20d005f9b3136ae7ea63bbe99a37b87dec2c9f07cf88a3d39815b294b0934d26826053631f7e84a08c0d220c166e06bd8c8be812a094c073f53be75050dfa915fcc3909b21c7b38306f55432f66b36e87d0920ce389cc4e2b640b0842dcae750021a3075eb1bf89256f21cd9e9d1da6bd137a39167119ce54388b40b9a879e2b67576f110fc9dce868371b01f15d723e564c3a5cfa801d03a8eabdf00c05bf9b8a853203fb119246e9443e6d2bcf1381fe53f6aa66871b430a601572ec5001dfb120086bceaece5629d8918fa1ba25371d811dbc0391c40d3a0f37379cde9f7d3d601b5d9672074cf9da60561f0323e4de4664534c56abec8dae016992184619da09f8741b11bb9a9047c1fe8c7356a291e278b8e7369fb3add73d6b0dd866a83a9b4a5d22d20e8ac08d2e507b7b8fc0d42cb7708156b2d19e86156ec10e50c626f8bae2a14bb4a498e078497eadf81ef07412ea5b90e83e1d9dc4dbd2d87209b4dd04425e82d7b58faf4f8b5c79dcd8ad29c672d3b34ee2f401b77424eee6f4c4edc1499fe7a73c3fb11e3859124ddb1d51e45e8bf82d050148cb239c49c12a35c7a4f793951dc0718cf4e19719d03d571435fbc823f9b9311dde7ad8666c4e11a06a5d9ae7a212cb6a6729b57d22769a32f2419ad9bcfaee251dc0e7138c9ae85934e51a3d45e8a70057e8e4f1a11a1cec4bc5be5c668ea1bfe660328fcaf1fca9b78d9ac98ce3e41f503b7d3409c2175d43be7c93694bb11c8af7c1cd8c6c92d20372e37e2b709a1153fe77380da558a3e594c439fcfeccc91ef5b8df2cfb987b589e01a47c1b5ad60915b87967d730fada4ccf15aa8cf7ffed8fc8acfa93b5f2cf2793c80c97bd019d3749488767d895493650d87d8f8ce1377974bc9d1a6e5155d4f4a3fbb3b3a11207a2fd2e15c56e9323f6e24a96e201b2dba85a6d784d04fdd3f0bc9f8a61bb5c6c48fb97ba259f655daa27b9c1534b28ba6f3f26935b90a891a2e0b3b494625fee13297dac1bb922a3f2967174315a180fbd2abf375c0940cf5f51163ebe008a606fd8329638dc872ddef9f8814971f6722b074461ed6fc5f6d831bab9c5a9811e1ccc74ec0888aa8bbe44f08acd78cfda9307f1e26bae4a4768c212281a2ef6eb5d2f367cc2309d48f4e5cddcb22ce5ab4013f8394cb662ceb071473f19230294e7a56ddd14f7b7e7323a2c5f0ebd5cae368b654647d7adf018f74a0c0095011366e6cff25f385432d6e45ca16a48b32a92a4be6ababcfbd62a218a5b830ca8425ece3e3a5a58f59340efda0e4ac889a352a319ca70689f2f6acd79122a306a110311ce33ba84e9b87163545b0c6c19ecd7448efdcbc7b57f8354b45674708ebac7c82a7e1a9f539d168714ed64c62e72b59a48984f088880c26bbf9165f633009b54b9422848a671271fee70b0d9c0c767fc72c01e579261328481737d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
