<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b57d2ba4dbdcc6089eb719bc35306d79823be252b50e9f96cf60984cfea92aceb5d43d0c98731893fc910c696e90895fbc8ba89b1ccd700c267c4cce3d7add7a4840cea428999ea09992a417340123974899bc3d0966604835f817a6fc3ad66a11f6fc151c7648a6a5cfb954813feb5c5a1e2b6363f4a1eabf49b534e3a2f1eba0c9741d79fc4f6ea0bee205205cc897136ea48b6a7d257a012a836f86a9f87ae5bd3649a6221ac01c083aa02fc41590d9a32063b45997c855fd2c43aa927a6dbf3c1f22eeff86b5e858028021675b1027a7bee31f9ec4d750699f79e016c8cc4ac9ca58cbed9ceb88fad7b4a8c9480bdd25a94f350bdaa9fc9fca2dcbcfcb561b20cc3f5c24b6841809e1c8b5fbc91ef4888b4e2b7531570da546388471806461a5d35e01634a5820db0beaca6423eeefd8bed0a6f7316ad682b9ce698b8848a19112ba86a27d1d744b2bea76034ce4130babe17606e0582a4cc14b0b9f031897f87d492a0fff01dcd8726e252b69cc8745678184602f7a063b4f9b306784c523e9c0e2c33006ce6614e4576058495065a24c0c960e5a68d2d7729a2a74ef4b7cfd46bc60651ce94da7f142d23649759b0070e52174d73b1f5dbcdbd39284858e1789e8af9fe6e9340eab0022ad40012a5e1bb2b87625e93ed3f091a15bdb1f40a576cc87914498a6984c1d047227278aa2693939d5bc14dc092c710e890ff99a320e0ce36834d95e8dac5a9a9e692855d9164ef919743714044853a7dc03c45f4cfce7a16a540fc768664d0d9844204ca9ad425749b6bf309ea56deceb1d23ac1adfbb42c0d11bc86b5b54eb7a61ae2e9b573378e7a3298a90fc088d10874b0592d5c63299daafbf8b3edd0b30cb2ffbaf21c9dc259c506b95794a9dce98f1f1015fd7931f28285ead67583d57fe4e753522b22b68437f371c694ed658c4be2c338a3918a48ecb80aadfc1bd930bef0a15ed212d2fdce7f0d021b07afa3e3d587cbe2d3008b857eebc7ad9cab11795b290bf917a83141b12a89a37018bdd67b7ff9f5a0e76c0655c4dcb9d33d870c3244f6802280d5c3b90d7e58e9266523ccfec475e4734940f3703306b380b5af3ce2c72930e865e0ecc0ee9575b9ee6aa6fa6216dbbf522dbf87d7838830d7b852c80aac1cf782f9c154a0c209e5a4461cf83b946e24483665fe5627918c8350d4e3bdbae1a83c5203682254615eadd7a9299df064cec68d075cdd657e55aa09bc21fc89af35263941594058bc56de7a5dae543dfa98da3c112feef0f51dda3c4f3c3c9f31291262c59cd22b7b56a42d03a731305898ab9d90b82cfd36b81244ed233ef380fafb33f2a834d832c7ab2a2699f6c6d445c9200209962d17b714d567fffeed8b3cfd5c62f22cade4cc09d4035e242ba736b45c45a007e08f78abd48f7f568b0d313912dc6e65380d5b4d774e8db19d85de9089fb47f5516e2fa10c23a366883c00f377710547052b18caf8836f7172efb67c1038b603e72b65d450082884ec615dda265383b185966f652d074ef88ee97f2d192433914a1e0207c0e77ea9cb9f936d67f8c92659c04bacf0f0682710c9d05ddf705e7ac00222c6e7ff8b6cb66020b511af3d1d94e907dbf4e011edc42c122660f3913d25bc5e5674bd82c5f3582c57c370c0da06f1d83c6fad702ec78d3d0cf6bee7808d9f023c8072298581b51269653c7f1809560a9a4fd232e2bfc35940f433e07598e598b187ee3b7071f112124155a259cc7425c552b9ad30eddff0301514173a78135abf27911edb8ae82bacaf27a3306a5d5a1cf27beb6bbe302ea59e41b0388f9895a553dd56435476acb3e96444ef96050127cb74848f848c60b25be5dc2f4d48abf0f99e5e2a9beb4d56d550e1e1c9b6847327de000ce61c6651f93d33ffe70f6d43034f8719b3f4009f3db8ffc71519d21b56bab9d6217e8420fe5514c0f40bcddee7db0f3d9561330a0ced24ee6816731e3afe234a06cb9f0790922faf35d2c83a84b5aa614887eccf344b2db5fcf0d2d62e6ce92a0e75705234962e51a52cbdaba73b78b689cd207db4670fd904f77c5279ab7443def76653071ca212b41e856c10cdd855d9119c993333533ebeb741d1f5b2ecfb5ca216929fd8ffe66aab99e999232ada5a50dae197d110fe2862fbf3fb3e2f3b8613932471d41c7eb868fb74dfebfb02dae28eb64ebc7c5b9619cd18885206dfff2d52f6b0d37e34790a20a525de27b22aa42cb2b227ca8a7619a50166a46070442eaa6252bc3ce72b12f3fdd1f2a6aff2c22a66efbebeaddc4fda4c5f4becb6ae98fd216611e7eff05adc2a0bb1efc99eda69ef051c8bc13560c224a203c75aab4ed92f88ccfa4f72eba628650a76de1e2c4baa102deaca92c7c068291c7bf46e15dca771048c811ea6ac8fb2872b7dafc95ca301c8abdbdb71cf44f6d58bf6d6c34cd1ba1e5d622ce1c6962e83daf5c8cdb7f47013c53b348c2a7c5a012a47f79e6b8ed2aa4a7dcba12a821537fa9438f7c2865cdba6793d3a5aced5aaa0d91743887bde575c5e96cdc04b549b6f352079049b33a05518643b27333bbad2cdf8bfed96ebb6080f4f895bd94cd84b1688f868818f933af753cd37b8cd0e2b256b5382fa7883b1db71fa8e4ee62674d4fa37b402ddca7c12f43560f9d791fa8e2cf07a6852e08a7b8a4d0a5e83cc6f71d461ff77c995c56c199c02d2a8e40c5c03d5928b2ec99a31f85110cd49c32d5dd5fc030fb2298b1f75e5e671c411f498789c9efee0692dec69ac1d673e87dbc5cfe394674688f901e84a8284ce5d2d484f384f2dd74ccd83923579d3c047fc3cb08eaefa908bdd95fffa4bd2f82f9ea11621da90cff1a7de5ccb927cb3c07e88eec4086849b535696da9225d3e3ace6bb19dac20685b34dd98073e5aa500696c63be213fd223e721f81e4b4108d5ef076900041d9eb2061042d9f1783efc22620c408ce87483e4f3a50b7ea1f95d8a34c75c408e4697c993faed2cf5f74c68afc747b191f072a25fdc274ac716370f79b95a13ac8cf002f99b6691374d357d5cea0bcce8b5366762798836d689e2a5ea2a6ae8d4ab95183902d0246c7e6e815b84732e4a49ba0be019c471916a69ad40bc88c4988049c2ae6580c9c5ac506869f44313fe87908773f5ad7f7be80d48bc8365a58ef886bcce03dcedc1f844d1fe72d27708c28311acef3c6796043830de63d4461c2aa105be906688eb7840f3f9cb11fc3e9ba05b934b470d9a9fd38424e4dcdf434461c417c6836bc14f8ed60b2ca62eb73a9a6f9e031dd0292b2ab490947aa8fd56e4b2b03b1b4608b2bcb4f897dad1c738adfbb1ac87122f919a6898c0b3b9b945f6f07050793849cdd5c7124f0e617758332ee766139a995a6791aea2484ca90cf1fc725cf618a3093759e8b8468de61422efac432abff8288c0822a27ff0dbe08f77de5ee8230beeeef1cdc3ee241dc8a15cdb51ddcb6ab199991929a1d97165060bbaa7f4500f12e922763552febecd02b5aa4f63c476a70702d8717bb5b809c505dbded9517f7d1390aae982ecf606104246dc3732adc5b9306889b5096564e898da3b773452a64f34c12af92cd0a009a96d38b80fb3b711a769d1fd5338be8339b7e76c994819a1080c9c81fcc2b212a9ea873d842f6e5b5f4250ae4c5f0d9f2fe0a9c7affe6e3ecb34706c980ea4f478d96a376d2e15f7b92243cc02f668d97d55c160a07ee6f4f98d649d5dcfc6b42c4451a1224ee2c908da674b0130e94cc2d12f2ae36359954c2ea497404b07406037d12eac99ec1d5a4e516cca6eb35e7a5d409e0a329f1866f51e2b278b60c94e20f91604ff6f9e676b31d373477955111c63f28e514b8961dee87c2157cfd8d9d61a0e3cb26275381e32daa1201d386a89c1f3cabdebfa4c42d8a25098016389bda7f1d5d032ee50d0158fab7a0ac4bd987f9eb48b5a5c3b78471844eeff4e33a66d06a2278f78a56d44afa15d38b4df7dc5e03a1d6d8978eb4fdbfac9c29610ba84028c6bb24695bb9fc541e3c5334cc93d5075e15d8a706c24985bbba361752e3e7d102024b1e31f0c004fe2916cbc9185465b30dddfd78cc9bb60482c70acb11677643ebebb0a800a01a6f2a2fad7fde53531450df01e9cbb46a914a8524646f3dcdb672d32579620032cc25960b4992fbd3ac608aacda8ca6de46899060b93eec102eeeaad52ca99b6a873ab256beb89c4a50fa3b51c20243815a5f16994d39a1fcfe6f90072aef8620b3f36c848c794dca5d062b41b151bbc2472b6018005c9e28f087609b4922c51f5d05c645dd2654f8fee5b5731228a4837f4314f386a3ea014246d976cf0cf49c872dbbfb5e3e4b2222d81ab4c45a0579f31fd508fd093379238f819ee0876a7e90ab5df2cb76487619052d50be1d5d8c43be28d03b8f62881f6559d992e2d255277eb7274e002c513da12ee381f4ba809a707b85ebf89543a4ada25c94e0b411754ecbc36f047c8d3a30f3b3d64b6049d3af0b3181ff21678bec9238d2f4aa3f6b501081559701c276f51507659b612a882813f1e98b661151d51f2408c1241641033504fd4de9334375a14dcf0e4a3a678c86afcf040837f438b6f58a1a6888d0349a9c9cfd2fca6d11070dad73adfa25a9b15d592e100b3c95b6f774108e0b16f7384c83aa4b4e209103c1a7685ce54aafb42c34b6513be095a34da4fec32a2409420dceab0a05e8473492c26293f55f788dd2517d8a4df7bf93706c10da6d9bbfb1cda00b51b1414d11ba18a26de5b2e0872ce2eb6416eee2a1a566f7a3fb4d8359d43c7ead5387a4e7a16e56342e09c4c06942750ad9a5cd5b75af3c77c63b380a9f65fc4707348fb769948f6240573a7fa832d3a8574550dc64671f5b803865deb64ee012eb6255c461a30078ec68600fbf7832fc9b6571fb288b1e4d197997017556715bc2067b65ef8e2ce3a4b9ea5a93b571f5a2812edc7729e173a517d0f2f1b34855e114cc362a2ef6c9cfb7965dbff7ce242c4badb5d72741d9d007df54d099a5df573d7bdbd19758a15a38a2c1fe0bcd3549e38d6960aef14eb14e9bff42d77af2a9def78a360bfd2232c0b8b789e1d84166d2b111fc69f3b8c9f251740c2a5559629e7e7e358274ed16bfe5d8bee759bbfe58ebd62240ed7b000b246dd7bfd41b1aefa5f98647a9cdddb315ef52cfba4dd71e967839427c3657353d42f58bf3e851f979e96327f98ea3b0f3f3f55591200a946921be36a08d850397a4ef1de359c8ebc8414fb68d767993c51f9c82cf902512e32ca13305b117d3e588360336ebb4845f9a7751f94691569c2cdc461e6366f0d2e31897cffc1b4eb1b2406afaf5a033fb5ed7f07436f4528e0cd3db5901b3f395b39346318be3aaf15cda3dc05419f293314db1408a81775ac398622ff9c1552a2963897a52e36c950ddb3f58340ee8a675e4d876e319a5d9292e138d4d300ae650f4c5632dafc8eae9dfb40b721c61607d562111ced9a4bdd347023fff90521a61e3eb1156b7257c730fced73f07adbc3c8e66700ff66d826b4f3cacf08ea2ec74d8b84a66a6518b4e0884a0d36b13bd5c33b4637d91a18d820aa550833b2a3314e6604f1b527784fa98331b3494b827ac9e0f1cffe695948e8087ae685ff2e6bf5ef40c45c691fc4b4233b08b75b51c8032284d14fa8d03cd1830447f6324c989aa6a233cbb33e1c173ac63ac67b1566e39dac193dd7d8cec64811334aaec093ab697f075e4ad8f88c456e4876923f7b286421b656582f76eefc8feffa56b48e51bdf3295de206efd2f2ad9cbc4c62df1e208e8d78b56363a00ab69d454c9689a7859a98d9eb4ad6b5b408ea78663b721b46cc39bf8a69e9c096a0a743a1c860a5fd55bf6c235c7f9d34eab516a9041c0e97450bcb8299e9bb9e898c4b20bc1d86ae2c00a9c35d5b8c1dd1270b9390e83ae551a628748d22c0b8723f38a3b3ccbed659efbddd5d99a0f14a74714c1de3585956655cb6bde40ce736d0c533f47d8be91ad6cbf4f026febbd50222a8914333d7fc0258d042c82a97ea3bb093befe1e4309c72a9b4c2b93ccac7515ee3f677a260d5c4cff9a66f931584204b180c24bc4de30ef71be4dd03c0ee3d8c324469f0cd9fd659bd0ef08961e7537a20b552b743663b38046d3d69f9ba06a3ef6a2f4fb1f97ee13e40288118329fad1bdbd752ef50269c1c3db967b4b1065c73118faf30e04166b016e59b892eaae9bcc071d1396a7fae3b4333ac6ac708e3c32e151295b6b903d77a2bd8538645a6265b2fbd0057aca8a02534b33dc995c3b9083957c66927acecdc5ca9c7a034a3ff5bf16a35b35aa004c5d8e76bf7c4406226c0c50958c8ca8f1ee4a7a18ec9975c8f39dae4eb8ae0a7c555ca403680accaf3ceaec2848e94e0b661a26582fe3a92ae34a32230e74a6056f2ef07e7a0d36c0cec37e51f3b0a566d8119f8b617cce5464f8ffaadfcceee6b5589613575b5896e99e9e7a4f36aa56ca344c6d8ad911552e12b52e5f3d6c818c0d86b1567c35410a4f84d16c737e001e295433557623be6018e2fb49366446c6bb2a17e6f1e7b3fc52395243c6c26c90c601e816bfb90f16018bde1cc98ea9781f4cca365c2bdf6b8e7990b90eb40352948a991adb511737b49e18615b2d3c08d4074fd70e7a41efff946b8f759333e456c0f01d283d4026e85963793eb4f233f581f92d5759026f54baa606470e6d597c0f3de76fb2e4db691fd0170bfeabcc6854d46abcdccbdfdec46f8bf832f40a1e2328df0b7b0c4d8ff07321214299ce6688257b83cedfef0b27f441269e028774174faed1b6c0b96090b13268f2c1f530948931902c3859763faa197bac098a8777f93425594437cc9d733fde2fb526b84ce1d56d065fa6ca32d0ac9bde8b773722e0a0098a02f40f9abafbb95b5d5b42df2837fbc9c300af980a4c9139ff4e0e24a62bceccdfa456e29b4d72ba3f8272d0b8c1f35029bf602cb42d0d7cc491e3102f460a7e8c5ce75e52fd70eb8e40fe498bf9d089a03f0b42e6161604a8da33c3cebbda194bd2ee77dc3292ce048218bbd0ba5fe60e435219984aa57c7ec1b4d939e95df995f14affa0543399dfb1c43c5e767c63900093ff3f18229e7242331dfd10cfbf66fd527698d59fa003ff683e03aa38d63508dc2d24a9125ec4bf70e10e752ab8ef8f48a509689d54a3efbedcafbc3bf4ec8be8a5169fa5259bc8bd25a7d317bbcba1d49338fae5e07ad3c0bbc251ba09cbe794c2e2cda61ee7b93a20d4e7f50b8a226a04640baeccf76752fa161f0f65043e54d2807800f2fd6672055683d29693b0322047285a855629c39605105e3b83f359620169c3289cbf32808bef9b62e6344e0b6d1c2d5cb99960c4c807c3464b0705b4f00cd1345c4da735daeff36a53fb1e0175db1e0c44f7a7bbd36f4fa4adb3f7b8bd5102e7151e5632d634b73c5fd27f4c64e03bd63ef0a3f1a9f84cce822f0e82a26fa17f7c3e2db6b9983d6b94a467b62f26568ee9bd40bfc24e02007a6552daac2d4dadd433de132018485e8c508cb61debdaede3203985ff297b6fd3d018f55400c69eaf9dbebee2f331d1c1ab0c3738e76325a8251a95da7ea7bf586015142df1a73d4e43125eba7cdb2f937c88a45d1680465fc8105a2faecf8ab2110e0a8984f9f52332dbba1849125efe9ae00f1894e509eb5b05a908943e8be946b5d6683623047a0555fa28f67540471809de838225b036de827c0ac6284ea888f25fedc30a86a562d44ed4340bdb51f1b46ac0a355582686dea4b0c722f715cb3c241ab9b2ba6eca282cb36aa763fcd607d5b6f1c92a59a27ff569b3b383d827f116e1ceb8f6155c190e572eb4e5464ee8aee653adc844944685759501421c19f0d572eb208ceaef8c16636cea1cc73cb1a3ab4c4c9c3b67bc139d49083b1bef43a600d6ebf4b00d2327d82f9120ac9de97cfa187f0d7eb1a4bd67956285aabbbb8e00d27741cd012b9fddcc94950f844aa0a8182ab15e3fb67d46a3302fb6a04aa0fc562600e4c3364fb89308d0ae8518af61bc2efd2666e6954c10b194ac61736deb90b321be48e09f31fe43681cfaefc27807d41c51f1fe087aae97167332152d5b592aa03c2c4561cef58b8ea0cbe6a0df814c2f6806439440557bfed9e95b638cac103b9e0ebddad7aeba36dbce27aa97ecd4326cad09b08b26ae781467f993612a9f1755df516336896bdb75151a928dff32cb819d9f7dbc77eacaa8b64bf33496b7558838ed0a27324242825770abef275206b5ea9f6dc34ec021c959e6056d2b281aa9800c4e7d144a2c42d5c9f348568b337d36f20e6d4056b1b928dfecd4926f023296da5d7445fc49320aaa4cc853b91aa6c0df24d6ec9f241a5c7de3fabcecdce2c09bc1c2e505f416043229dcf887069426e07217ee53de84bee33ea3aa188bd34aed7c6e9980a0922ce900f96a9ded47754e65c617c96d9f1aa1ac6cc0ee7bb0080fe74d857f1e0289c60d019ecd7ee2d123dc870ac7e94cc686cf6cb0597ec53592a4fdc7ae459b988d3425f71fdd9bf1328fca7674d87c73ce3c1912dc8cddeb78a8f7701b71f110c9a1b3f804a3b4550c64d42f5e2c9930ec4e6a98bbb95f1782105f509bf28bd5a59b31e60d1660b9e79d9850e2462a1728e128809182a200bab48c4c8c7b925531b9de489cc6aff6abd6eaa48d97e916bdfa1a7d990ad9215cc1ac2a07f59275c5dc7187f3294464546816a715e2cd112f5f48695dbb6c1bc5e5ed839570bd0a80b5c4d736c7a956a5c84ad67103d6cd2c0b48106970783e852d8f309c2e081c171d75fc7e3ce5f7c732feebddd46a3308ed3d1163be5584d03f2451b5220cd3676c5824f037e7d6e4cc04b93ca7499f1c002e94df69e135be27317750265da8d88367c67d18313f5a763eb79c9031aa19bfd2dc680de837d012096ef374c230ecbc6f33507b7a1a32aa697275caac9e40f56b9866aec5c7743c63daccc30f0f5fa37558e6b5eca2aa36c685d35ebd8971fe113c85eda68e553fd64abae9133bf3195851d96d2f0c152a7730a35109419871c0d686dbb7b22a8818822cb70e9487aeac4872dae261a6bf02ca601f38a40c883a00187a7957f7f24fcc9833a7982fc4ec62dd500b403cefd6b815ce06db3fb7a2d5d835cf3f5b79efc940db38d506f0e482a5430149676c8111f0d6d2796b88255a688f0b2061cf80e8c81d830e0a3cee488d1c80e952e0333fbc6f02d6f5f4e7dd4639dbf5a2ba01172252f98b9b940f18e9399010c15564544d6675edaaacfc70e35d81231c0cd999338e9cb5c58b6dda7ee3c5922d5777a8532b4880825fefbc036cab4dc9a0f375a743b12f8c94d2f465dab51b51545da4d2e74e40cd3f0258736ba8c187fd5f0ffccdde4fefaf7c8c2fd56c0fee24f2a73ae51e636a7a341f4230fa0953dbc560e95c73c508ccdb89e56b5b09e0e0548ade69659611eeccf91fd38212b69e0fe33f9baddaab030038fc8e95581b44522278ca55e7cb57fbb747eaa6c7f91880b5c29aadcead68dbae4029ec5511e511108671fd0021300602ec751ed71f3b311d6bc26e65829b2fc4924e266d459bdbbb41021458256d568c4b54fc7c068596ba3fb47d28d6556f6c846f6a954a4d933ee58513a68b131f5ce144133c9b273ec5fa744cc464f8c68e5671ca5568ac1a237480a01580025257f85bdc57c05f1aa00de372237222805418fde951f93a0493262213f31aed2d4bc384599164efe9e8f9d2aaeeeabd89ea624deb1117979a2ccff55da64ef4e3519f1777b67589659375d5f19c339eeae0df0872b53697d982ac4f9445d2d304263dcc90e7fa973b8a2cae02a887a4433ed6f186cb4862aac1da19315f07dce76743e2b6b8e7abb778e50db25cd3ca7b671f44f0964e72298337178e088e8d501d195bd0835dea32a7247802f1cb3fa9d9539cdc3799cb60f75de94695982922a76b62e4b0c55e7f1fd6f52be660bbeb1ad665433af9436e61e654f24ba3bf267a427d2d44667e4c9916d5f1d61c6685a71825f9581551e5eec4aa5a6fdce30e84be4d4df1b039533fec4ea5142ac73d54afbff4c38cd143fa4a396edc79e27bfa00c88a73d8e9337aad33e7fd841a3c42f89cf10700f6cf1c4ce2d380496cceecc4225ba226be9c6f2b7892a872f4eb384d34c90dc444403f8272d8d9c95c1e0667323e2b5032090f43096ea4bf3edfa95be1353e20b442fdba1b7157b4ec3309af1d6b4df99a3df96a7e24cf82f140e28c0b6642e036ad08fceb521b08a3ab6a20de149c3aabc4f052e7521bf97383eadb57c67dcb90eab0faddbc866ae0e231def125fa08ce89b7f28e777c0748af061da9ea344a81d7f790ac69867066bf17d9a0ef4ca673fa1adbbd5ade6dafe03c7a868bd559ec8647926e3a880d08311c659182a54f40b27dda4b388cc76254ee5d737a9f718c7798df4b17fcfcad3da7dd11727940236eee85f3967df0c2cda565d241eb50ff7777af551762b93858410b4f602b63836c9119042cb258c06e725edbacdbc29dd93b099db1a8c8844fb82ff36da6b85b7576a2007799486027b79352f004b288e4a856bba23f87d30638ac665cd90c54faab818095921eeed6682e3a67772d8b7734e081c7b879c374fedba174c2cf986d9588b47c0fde0ca4ce66f51a06567eb7f89fd785439a96db4013bce7869eedad680935395d86fbb78320bb465f176cabfe0e28e6fe18497cb5478b57d5c73f6accd720a80b86a57c99cec5a8ca1db9f47a07e2f1e087a6fd8435e9498cdc83f2c67ca6995c8127f0e4a5d70a71c28168642cd3a9f77c50ffae75000e80e3803194e2a4f50df99bda0fb1dd7c54c74bbcb37ce9e1423ba5913bcb0cf034d03a8fe5abaec9c7cdd87f33c4daae51cc5090b819bc91b813c4c60086cf6aba467ad53808c52d403239a8115fa9ff5f99b98996a1cb2604953146904ae10a4f210f759c1547376c3a2485e69778affc6e917e0c3ab7aa1216cc39bdcabe5d0c3f832505a2d167838f21bdb953df8ee2d03f3a69f15f0beb0c24022c7d78e0c188a01ff46373b5f98a254762b74e3e342a1fd26ba6d6256df95a07cd9a1b442a096306cd80ee22c8b5158901f15ea18dfaa9c4feb9b7bc66525f05d64afe1c83cd6c60819c6af169785b3a76a3ca3d3fb86d6c5135cc2d7620de19fdfbecbc41f000d8294df211ef42d44eb6d643df4e8f84af61b74a4ca20670afae22b6125e34ffbddb195e1c887402de9e413c71b5e51881031ed1702466094499700d1ddef1b1389029701dfb77e2ba9586a11c8140b86d673c59e467d7bd9b9050e0054b634ae66544b6f365f025947d496036b63b8d9900ca3a45d52b3d8f451af12b687999d75b617b71c7614d229eb05e9c6cbe876da083bbb4b0b81009fcdff3b00899adb20f3ab1524f2203e76b2967eee643d324a21063742839a0ecd31225fca0d88b0cbd7d787964ccb53ac8a5b1d71c8dac57a7f3b1d18b1e14b5394f81b2e6cf09bf083fcffb696daf6df25f4b25f50e3db8327f236d3d7ccc0616a81efb81fb68c47cb759f9fff4b4d64b79b35a7c882fc15e74ad70baeecf9e0a69061d83b2b7ffd90d79b34569200c9c0f647998efc3dc51780a042b1e2ab4f5597b88fec40c87a825cd4f888e456d466f4eabda83a57e71f14e3de876abe29a8199aa4ca8275ec3fad01d99bf2982e55bcc40296407116d5524bba40d409a5bd5b66874e43855b4931fea58372105bc243a74500513e48b81e598ed32476c11bc07507af477f9b3b0498be40c33f4b505d13d801132a5a7aabeb4ccc7d82f846a68433adcfe1aef8dee070fc9c6cbb520885a6085656d35bd22890758851b485e12577775d7401b8dfb8475c020fe5f212d79b8ab05043c4fb1d365c18b5d1a9bc7386fff97d87cbddaf154f8097df5bb2ae0193d696b11b8e54aba062546834c9962ba0aadf4e95edf12fc58c29da554453b5b8a531305d8108d19e07973181c5e8d345acca7ce9ec65223d065e5ec50fcaff3ecbe62c6e53178a0130774aba875368d7d399c5837fd0221e4901418f62aa90409134c489a9bce3f80a9a98d67dd6abc3cdd469afe09417b45bb0d6ff3771cc8378db3c14e8bb25393f98a14a7fad1f2cbee0cf11a8830392b2a05016970c1e46da50ac828c9d0ac50770d6940f38ac91d4bf48fcdb7c95b730ec23bc26dda6c492e6d891eaa3b05b429419680791e3f2c0ea95939fb2c8e78ff522364532b8d1e3ccf80034178de29f2872750415a54b288abff944072d1bdf431588c0454fb562d9052e4bc58cdc03b00c02f850f76f266b7d7e9f6451b5fc07467abc9698aab6fe18f30e80cacaf7844feb6997a3179fba92fe81551a205a0b8d159f19a04f5fee5aa50cb1e62f8371ae8f5f001e562e2ff6c3a9f7a73b5c56db2ff53a1ef76cbb741b6e4f7e8090c008cb8654da4b8174863adf4f8316b49121410053bd33c31874cd852df7d0af5e1290dcf1944fa5476998ebfec927a9e3af0ab21a3111ba06920824a9db56e150cd7488a25a6df256bc378fbb634c412416a065c536020514f8e5a970e29268562c89a3452a33efae600451ff8157c2c37fa4221b98338d6116bfa751587262f80244abb8ecdfd1fb5a90a80c75dc77d2a0542dffb949ec74b03157d6f05652175c10c54bf72ff72541eac8e1cbd118d4a1f55996e47711a6179f74d5375177a0752cc8512d5f60392300a07096be357f715bab5ba22eb52e3603c84270bf2aaae114d25470a72550a101f4963f4386881dcabef745d5154278c472d6080e5d04d7aed34f08be4de02fcdf2850ba4e98f565c936d28f8e41525798f49c69d44194672c55272419ac104cc146cafb59e1766794750177f74c75b1fe90d2a0b729afcac4ae50680904c479196ddf8e5ee89037ffba2fec50fb71710b498c6d802727caa13a040142a00e114999fa40e0d842b62e9c921feeee0804fc09d14cdb50736c4c1935052432f6612ecf64559e6e4b283d5d52d863d993fd37a98d478f2053f831c9fe76f0e3f85e722b63c6f033c216ee7e98705b0d010dba2b151d658fdb77ba180fefb26d1bb83660293d6672e3dec2888960e391020344389aab6919a6909b5bfbab2d6e9a3cec788009e623bf314f09d54c7aee7fd993a185a2dcd9a3cd53189bf08d4944a01b4eca5dc239ffafb6b30764dc2cc3694daa7e28678f9cfed825a28b5a0eeadff5622c5c35aab335805d2057be5c231f045548c5d7a923a280a79cd0430a4eef9d0bcde5b59428aee25bd68383543546900be7757e59279f25d45ada65abc00515e19e56f9aed0302a09977ac281c62f442e315b095ab1ffcb79f24fe2b617c16de54f3107aebae23a99f719bf0c8cf7218516d60d7f67d86245249541626ca0bd888bfb3f9a67f99522f5ec5b5ed7954212a7043cd7c2e43442b864cfbe848606509f40a209d97727fdeafe3cbeb28df0033032abddc21d124595df2e031aa7ac4f3148826ea60d4771f2392d5a9c6aefe0223c123e61297020b6d70504cbc580f08eeb4cb219a95395167e7430b80e976df1e064363da21b8a355c2bba38787f2add03f89dc74925f6af73eae060fae04f5d5993f94c4d5588a3abb1d5e64929626c0324f10a960bd53a6d1a236dd40ae5eac709466bdcc51c7ced8fb6e78d024d297a781adb3f2698e6a7fee0d9cbfedcd7e8af80b47cbafb0913d134dfa6a31eac59aa3c3e99ee4975e315397b28ebc00b377312b9b7b08a6e3b0f4ae8be40112cc0f5b6728eeec043a19b6826c771c08e2a813ed8b2f4d8c4251c00e111b54c456c41e2860be9bd012e72ac0bcb5fefe0ddfc03025ee4dafe016e06197e656cf3edf43b2fd559bc6dc4f0d5973309baee462d04e90e072c151184d0331e546351264e8fe359e5b5884d5fc10c623b61259417a66595aaa88e2f50c5b452fe94ca78f0f82347ae161cbe175107c5cf4e27a3e183f00c4caa3381a5490c14bdb0b9fb63db8f0aafc39eefcceca3ce836920be340fc6d8640c2a251691703ba62af3f1a1b37b59d2988f6140ee5b99ac6e233718bc2670b2ce376d2bfb121b148a5a70a8f077dcdd0691cb4a41aa9295bcd8dd5f0e1db328f1d6874a4c0c190e1dc29fbd40f6fe362504f40dfa5b57d03d9201510fb11798ab6d559fe2b655d2fb235e43c7a3be866d9264c1b4159742cedd6c8109af34ea11048caec3164539b7fdfe3cdbfabf0cd252319038b7784c3236408f742b4f822e08ed105e16b489cc1ebc0610be3bd48ec739719834d9fcb6bcfd07e843f4185b6b8b1695c2fcb3f5b83f14805b5cf07461a40cb4e876f5c54502076bc52d42cf54d8ff8ae1b86d3c0baae3f23cf093ef293057561f26781425421c4ecd2d01306f819d1ef36d0b14e7d2403ab3df999d17b68173da042db2585a4091c465a6d4ad33c209103ea81441c3236c39787c201464f912cd8a78568defa48a9bb8380c0e087daa91289f4640c57b49bdb0aacabea7318c43667de689d0f035bb458fd8492498a689c72667bb01d231371be8e5293961720568b3c66f0b0f0635a3ecf105276f877f0c73fc751ac9eff669129bdce61bb2cbdc3604853722a419e92813d921393d77fd03b3b8b97335cf0b55c524c770f64ee1f953752262d0c65182caf956c457ac5d741219e89d08ec593aa80c78a71d547864ffe963d3643c298014a45b1134f568aead75ebe4808af09f522ad7e1129e507f9f716fc9d6bf751153430ad2440fbc0b20c5018ecc90880bbdc9ab10cee8ba9476674589001699830970b5ea13da86b8c497c3033b376bf9095ae422725a8dcc1b02739560f2fee8871afa01e5f98a30b750ee4b272526f7aeb6229fcfab244ab86a27855597492b6708d99b2856f088280202304c9b7cbb6f95c5181f1c59f81ed7431e3d2d30a50987f0693e35b503f5dc31b6c0c7c2a14347f7c6693aad6109c35dd71093e8089a003433bd9a86ed9a461e7231fc25243e515b6f6975d5eb401feac86978fbc013f3b804e3c326accfbe22a4cc0cbbae2dfcb1e800bc97825197b440dd9f942a9322191874aedc76eb99c66bae3c30d5590546fc998fc1a8f927e5490eeabaa6001567c1e67e65eadc4214932093dccb56aa363dce7e212864fbda0990b7092aa82d0c938327a4b33f44672d6e748a65e7c951ab62dbeb847323c0423d95f1ee58975ac1eac0ff9ec4a103d02c917c16539a8411304c063d7ddfb1ddf590f7fc7348424ff52528cf8d69d12fca8d44db18d817b51f149761d2805fc895e11b17f01521ebfea27397462f835b8f2966c9bfbba61028fc527373e3b3bd420dfa8256e181326bc695beb1d99911030fa96de19bd2d9b7c2e643c18bb58d22076393917a795d2092253b0cf8486ae4b7ad7d1d773bd30b295ef961dd5bda187b81b3c2665f42d6590baff3ea67ec813c97cfc505e3e4e9d35777dd7acdcdbb78ec18f48303b0491e3662a7f38be60f6f851eb0192bbe8291a02c2cca13ed8c14a9b18a79348389517a33dc73c74c9f2f1ddb5c419179afcb576f3f893266e7ea7b1eee0fb3b7b2662fa7f57db33088d5c8a353bbd32744ee7a003dc6af66e78385521c390b88bdfb7ffcbf96a19b947b9e4fb9cbd5dbec9010d9c4a1f9f79a8ab0129c9883c16888d7206b30b93aee6e3067c1cfa55c97fd9e3f1cb88068527f1f244d49d6a0aec8b58a86f5b9b1599aa54e437c11921e5116225becd41e40fef5123a536abbdef1719b139504f0b812b433b6182c832fcc9ba3f21ebfbaad09fcf66d06460319b5672e461b2e3ea2d5e65adb4a9d8a7ffbdb73e7330718beffa80b3f73a02dbcb854d8e26ee698baa6fac9ae3fcb110493c83238edf98bfb0d323a89a57993de094943faa197624ae8788d50deebeca9f866eee6e1713aac8cb5cc6efc464f89de455e3da3bced35e42d3ed906335a643545f62510ce5a482364855ff2d952ffb3be50e1ca0e87ec343614340870ece5539cfed888809dca32d8c7c39f427017b0bdf8191865f372977147376afe4d7fa05f368680a1d066374c3ba2e46f3fb88e32f483a9155b3939902f7f960d1c547feed9ab1039f1b9e035830f78883a58f435d69e7bc115cf1f507c57af0571e3d88a14173c0521654a24332d790027541bd9618f4b0bced1c3a4878b35171d9bf63cf74f01ba786ef686d537b2361a76466176a8f03d4a99bb9b10899b30fb88255acfaceaed0ef7c7838f3f4d0158a2e8235870dc5b1f811e5903d6864e2900d6816cb8ae166fdd32d215003b07b8651726df33764c9e83f8c6f7cb6d9775f579697421bda6f53c992b23e1332e9f5d5841df7d934835e520e016153e0905052383ae67acde20b113c7c34113c787a46a10a10affff4ee95e2b09e118caf6f259b6eda4a3f746b0b5f80cfc35f4b68dac30d251483d4edaa3a7cd0f4be32f47abeb3da90181ef3113472435c0d4a81ef428dfa33ae5b92eafc12d9546e0fc10a4e6d82d6c79168a05d2a88a63ed34c7f40eb9ed8bd83c641ab8954ee2dd79936af04f690cb3618ab49e58c06089670f987b336a7fa5ca90bf3637bb97e4beb50afd9a0a4ca54d0b5cd7e466d6f2d5ae9ef65699af8608af5918d9097f42b14b78fa3040d9c932f26de818b9b261133ee933d4d0ed41fb67868068c1b87db4dcb9cf4d6b8a7dad1e7191d4a97a0f58eaa51b04e4eb8693e5e44b383427dcef54e80ff00cc6507ba52eec21213f1086534c26e2de2021e08192e3465bce9531d65bbe8ef5aa101c92aad32d525cffeb1cd128ff7a746eff8274fedd5a668f78a8ff84b0eb50b528b3092d1fe7d4ca6a890c13969743eb7e9bd7d6073b0bf3090dc44a49a72b2089a53fa2ebb69f1a21d04ef56fbd2c75fcee481e5977b7c0a78db08896dd81aa9d08e171a4133e3f247f104f65446e22870e27b3ec92734b7cbd6c2f15937279c7e3f47a8980b1b66a0b07da4e3c1e43f1b8fbbd219ce77dbec2ff50bf4958160db1e0fcfaf5f2899fd95a72f071124f212bbe7afc2b81070fd5da726c211a89575d726e9fecbcb45f003b35a514e0d72fa99d773802c803a11833b995afbed55cb416fd793d2056e3978ffb070a6f4ae7938cb3885fff0ceb04231f64923bc96b5431e18591c20dd540cb96f392cf80c98f5de227a403da9c70f105c6247c744c7075a9e873f13ea1af7acb66de898368542c7c24d2d79621beae0ebe71377b3b0acb23afb84b5b684564aa3f73762d8f1fbbde5a5a0d1945186706e6045b72f9beebf4644368fa826201dcfb77c2428d3fd36563bc3169495fc81eb78c1b0c797d158eb56bac23be80f5cd0247414b7c5e3a1a28c9926a9b8e39c7390ea8494ba8abb2a9e310d1193f0e4b98bba9a5ba9ce56c246172a14cb2795dd374b5d9a4a4032b7df8c05a2203865f01a35dd51dd0b96e433120a2e3db9b4dba2015c5d3e7114da10a134b154c8725c6b03471ed95ace1b57976fc0dfb5578363fbf885a0ac14a735de91500525a35408742cbcb7221baf32fc49b67a93dad0496802b0a098b2f9ad4bf7fd46bc396860a7b6c47e36729e9060f43a55537a5ca9ca54cad7ccf2815d2baf374fa8efda41610c6e61d2bb81df92fb0d86d8d7228bd6632f1fd3fed2e1ee2ad3a4615d99fc9ce2c819be63f8eb8dbe4c7edde5376309637607227c0cfa6f8f9b160358f62c376464becf189a0f7d14d0d306d4af7f7ca2edc142626834a26bc1e65ffd17bb7863d0d713a00c568f6693ca7f9f2cfb18df8d7d101303dd8dc6fb8d2e6fdf9fb9b0bc2d4cdd22e9c0f459b050f3dd8f85836b9e20e63c7a741420286f029c3d43915c35a757961ebf289c38e32882ffc5f211e809aa97cf2347f257722954a8e070a1c29d5fc90169b6ed14620a557ec65fa19507a7ae7a03fe985407830deeaf832e7f3e66800b8ad549b651d103c6f1690429812ea5c8609ba494ebfd25268149c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
