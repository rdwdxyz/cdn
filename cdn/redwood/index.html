<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d33ba362f178d5054e065e3a71098f1be76707e08bc0eabe4f3044c0bc450095df5a6c8af02600633918ba1c8ebe69af78170b7b6debde678ac8ed599cc188afffd08f0efa5efef8f2cc6af48370b6d77b2b177fc9dd8b08028f8d90dfefc6d3bfa4b5e7d5c22520cb1cd72bec71ceea01034ff527363ebde37b4be6f90e1a35f64dcce5e3cd5dd2bf64e3f0ea483816ed802f1f53b51af24ed740421b183093180eddfbb3050d58485eae8fe1cd0731cab8288cbf6759126f4e2b26966858dca15a7978b77bd6f82fa3e698dee571a585ce77c04d83d103f26696c5a59e9d7a04daa087eb9cb66f6e9f645406a20b971c9bda34be31b7e64a3efbcb7f8ce0e95d6d478d96ce18a76fb026452aa0d64c4a44c307713ec0620cc9dc0f920d7c12f0ccece1e3728fb5e0be7a2453b0d906e8ea949965cd89146f0db9f1096e29e9e727f7a9c5b44865b07cee2e08cc24a9137a6555d5e993e352e4f7edf2609cc150522f578f9e621bad597501ca5c1238900742254f4b83056170fe5e6b2112b409859b5cd8aa7865528d5785be2eb9200ea390460f5fea5dfe22ee519b07bf487d2a7ec5ae853cd84dc849024f5058b70792acf3ed2ab64df642b3744c71187e62a1b4f646a953eabf7d3806073adb25d69f3a2dc49c5c76ac5d8f1dfd548b39982b2887040bd3b49f160994195c79ba53ce6edb50716502b371c49d6fccab1c45e697f21df3f9f1a57ffbe2623262ce8edeb0c93fe7e04a5efa20b7917e50a24b06953075e2fa02b08fca7d9bba7999448123413cf38f6b43d6f947f406d39db1cbb0a79cf0ab4c59af8fd22536bec0107f6e23a272addc5acccf1e2f2078f3c00d79ebfe7593d3aa59b98e11e693709c83898f8457cbd557e513b04e8d6245bab38877bcf8929ea37c5fd04acb4170c952cfcac67063335e958e76410f0165e74990908388c4063f46d795a6c7a0d2efc4814db23898fb55bc0de09f50fe8c8a5bc8cec61b7660b4c91343de2b56ca96729d00ace92a6f6021a5039b9728564a11703a6097ec4e55bba1ce61816e6b5daaa3736b89fd301fd6e9bd7de636cad6127bab715d1553f2e2ae8761db011f4f511ee096a9d8f9516b71c42b865a4f6925cb19509ddae3cef5ab48e38130ae88a87fdd025ac10ceb4f0ca5be3eb2d3924833aebce9314cb7137bb62f701dfcb920f84f3db0d407669b4ec56978d2d80674ee34726429b5d159a7cd0ff9aa0cd7461c89344c54280f5ac657c3899ada946da9b008a058e50cfb3dd7f296ad2405aff4a6ae82a629fbd6379ec4618d4c993748c42c5b97dc7beb77109fffc2d6a5a913855e9d1fda1be9ecc784411ec70805f3dfe9253bdc3f820c59f075e72b6d468f81a1bdc3a5e59338f9104345a861b3d79f00a4cf342f8b6c8bd9434b11e7e2b70c8d7bba93a5e39c809d5990feee4242458cbca9eedce5c1a605330ac62a7163db0d138b73dd1c5587f5818b1502abf62a8403bfd679ab8914e0eff0126586bda48188a3ae64dba975b2d391d81cf7d347ffa4a602caabf04472121e2ff7af08d06e75a6f4fddbe74ef0475ae43f832a92eff4d4c2f8066a2f943e4b9adb681eaf17f6a290a1e7de206e6e8e1fe9f0aabf97b1ad7b2c207f6c475c7feffd3932bf0f0f8b170aa7f1188b2dc0e67a1a83fc83210e02e76f35572ef93d2867bd8049a9363dbfc1f6eacb600e7583aa9475555266e79c07281a30b11079ee4bde2862baf81b5f6dc6e8c1e1f1d625a020e36bbf16612c06346629bc21c9c06681b05bb1b7db102388a1b7547cfa2883120b07f290eaa78c14050581370c71888cd5ba5a2afd6784e3679c11bb710e657aeafd01041a6ea336e41d6ce29226a7535d842498c8af0b5d006b9a572e41ef31b954328c1f15e2e9b219d645b021bbf90dd5c96a2812b3b23e61acdb7dddfc5c3280607755454934f91330f8b0c731f8d600a7d28bdce069b0a3ad0120be1020c89918905aaa5b1e091a1255165e2877fe4745a7cdd6d34b67d31099a3e6583ee4fdce1e3de28fa66058102f33ee4d9ae105202ea01e82621ddb07ca4dbc752d4a585b218234b079e687123355fa703aa05ecc22e03a6fc3ab7640b3d61031cff89ae46822f535846e77a1d56805e72df68b18a3b41ebd007b488e9ac484772946f0bdc78ebd2071731b0115e8cb49f75ff94a4bd81dd75302b3edd943ca3b1d6dfd7dd678c254bfc7cc62fef8c2c083ad36b245e969174cf5fd7c806e3485644b78cef8a7b4137964560328b7a22d03f35bd695aca64c4712cda9422ae00c0b77cd07727a71c1d30930497e8f63b04702807f72a05aefb2b2c9c3f2afbf4a48f514f9baeee69a5cd3a799a742d961abf4a7c56b26bc832d203fbb1f16ffb86cec84d840ff6376f2ef36b24ddff88b90358ca6767ed32dfafe3f5a2b69c0da176f326de2be2d27ba3153809a19347d3f555bf5a5b2a064898aabca7e6b1045f822ae6f9432511b9cc1f10121d43c71c144345f0b77b325088a58b27cc2d1bf76b1166b044d01a2cd3003f87fdfc943152c62d00b616caf847114572985c188223b59127d96d93de0167e409bac43652841bdef215474db6173b1483264e664e79309a4ee8b13ed9ef696394bbf8dbe66929c0c230fecb78a7ab7fd0c2130c4f6707e32d8aaed4d4d3d4d9cc2a8fe5f04689f3b089268b0ab712406d8822776cc4b5f1f7d4c24b087a23c03e9b2aef65d5bc697f822e08fd0d0da8f1d4c6b1aa29187f8c202c9e7d2bdfc2aee7ecd7f6a2603b801e7f34274b460edb69edd61c9e8affadb6f7aa7f55413f175139264176dc124419d26cac340e72aee755c32e47f7384e1f909b3934b548e33e6e2192f998471529b3c114bea53c0d42b8a2d48926d5411a95ae2cb433f56afbe07af89909bc5c53a8743447b579d78916f93579af6e1f9644440948d8f07bc50fac80def83a27b47f3498b0eb58a63bb73e27adbab12831bae62c8fbfe27041b1c45029dc35cc4926482928e8aaa8ddd153cc0183d9423b76a6bba954167d001085fe57e9574b207d5ccbec9b82d26f0388d788273783fbb556fc0e4c6678205c58efe3f3a2e280df3b6479b3aec8a85d367ba0aa74bef0378cc818c505624670a6f1dbef9fc20b1695ca734045deaeb640f1b3c0e5d4fe4dc0a8dd6cdbf1dbea65ed642f232cb5cc1fff0cf77b288ce9d4de570125cd944427a4bc9f506aabe0c9366ee8c2a7c81a2c9502beb697f17a5fa985efcc298d2a10db6d316cd4b02e920474a82c4edf1529662fe49a79a2f7c9f773bd54a13e6de8b6a0b87d54afc5f7b7127de69a2fa44266826a44adc2084e4474366ee4165301620e473febf47d8d9981442fe7a90d6d286bfb4f42b88a2b1dc369b17f4dbad479ff43a797b25e83806d3a0ea7d7ef70f9aa19572a24ed20f5eceb00108577b45e5acf52f3efe276d34f8212dacd6d67902e25820d6e1f02ba7c9795b8f2543412fc1b08220dc744b33cc72ee7a20ba16a95e4125cae52a7969205f08def03de0b652d57935a7a95ccfad19abd5d2394b6747727974a87ab33c50b7313640f0fd5472551a1679383bb5cc946879205409081c77e5ee4fb7d0a67e631f37576065afeacc9764bb88dc8bd53945b321fb7b2a9459bbbbd65651dfc59c2ccac6bf606fcf687f64457709c26e6b83905954255585383b2cac716baade23fb0dda11482ed68d6be2fadf99849c559117fc1c3eca994b87d7bd3a0d002ac55e793fd14dc24bb481e32d8fd36a9e6a8e51a5a6fffbb0af49dd0f5462a9aab0eaf7e8b51faf96d61c60908d17f608bd465841bacff6b1885c87d4e0f6b6683612f62c2f947f5fea3df21292d8e7019316fa6cdc93e0e487957957d183643bf678c99201a62aeaf6e72e7e411301904d6ba006733bee60b5a6ea5e372f32cb8b5437064eb394e2bf821fff0be6d6bc49992466df2006224b6f7a69ea0543c36afc5b9bd4917ec7a2039d02ef6d987fa620fb8bb9c5ece4abad3cc41a1381b8ef83dee6053a908e899f8538e7096fd291c34a9add3d9b3ca166f13f06a9a7304f0d4ddcaac65faa284c658716eea3a804f547b74efee5797d3b043631eaf0135c6970a65985d3c6a1477bab4b9e029255af23fc96eb8cd125e6fbc802baf207133af9065d1dfaa67d7c4e2a73e05d8e88bb8569fbda6062e6486069fd004ccef479ddec008c2c4842d65272b25cf25a9b403736fde2d05dec85049784c7c91750b2c24f36aba348ff1da5817a05ee4e79d93b2a432ca6b971fba24aaf749451d0520fea0352847697cb705a20cc48f117422b98cefdfe1fe70853f8b4243028b38872f8436d409905255f58ee22ba4be47381a17f422a37d7f0fb132ced65ca217dcad4a57038b9d3443893acebc256fbb316adbf2c68a3a456a4f676ca19fa78dff31af5264bb6fbac33d2c36f5525cf5122dfbd7e6f180a0cdbfcbf0639fdc331e817d286d6e85e29aeb952e8416c10f1f5ea0ca9df304e04a3ec7b59d4b72c34104af1acbfb6b3317f5857c319d872746fb28ab88712dfc26c3fb3d4b343b0380c17ab39a1c4c07fb11b5d5108a771400b9f22a0fbaace631c73b078edc8612eeea8ad3ec8440a2b24969c3e5d033108bec99fa245f5aa3ae35072e75a9e170b67778609e9def5e5d1d637662b31d8861d061e2b050ec25105169ea8e789f2b2f5e38c0c1bfdfd800fa98414c9d8236ff8d68111e231482c4b15ec719422ec06ae86d7c56914581c9ab417af8748b2b6344e34856bcd622bb357fbae9c5a0562973ceff7a07117286d15c102e56f17c2f65371b1e628e8d112ea6c668c878377beef132dfdc8336ad7e2a7dd515e64eb993d4b2df85a0cbec666f53cd392f2a063f031060cdb3ffa32176c9346aff03ff89e9bc0a447b437dde9a8e0204df46d7618f120bc17c9691d5330539eef0732b1c2545b84ab2e1653b4a2685b5854c0f03c40ec23466e8747a68892eb0181cc5c5063e8e18818321af1dd405d2c0dfbc9e0547847ea1da470cacedcd63c8df378308ed45d6390e2002fcf7c04aa221f68b77f4beec0bb118f8df3db431530a10c888b5ebc8daa3f786582765ad21ac1e7cd813a04ae99f0c00f78eb77ed57f7b815f3cc160d9d7818014995049312336f3f82b19bc05c6f68ec92e738288c184e3e10f5d23d710bd976b950f4c305abf2ed7b8cce28554f5759ec551a2cd7a0a5d481c0ebb61c1b5dcaaa9952c4ba3d459897f995272b1cbd8e5e30a04c455587bbaabedebb9be97f04dddd0f0e304a9e64693f760e5c64863cfb207ae473cb5edffbc4d98c8c19a20c78ee797943a68921f32b67591bbcaa5a5706c20ec7700b600dd5bfbb21018cffdf5638186ac805347bd9a37bef2408e8a1b77f077dfba56a12afce82a7d9817da42f94ee65aedfe7ba4b687d6d5e3a73ea1fa78e17ad20895f88e6814b526b5c1f7fccb23077be2544d1dbd9a1aed7e2a21faafc79594e375b538655100e38849f469674f5c485abd0cf4dc6e6310d460fd907fa60669e13949cef477f07fbbfaed99a12f6393ac10a9fbfcf66c95e5022dfa2c595f2a29fe5d3c90a8e610f41efd04f01a4bab63b02f85317c1fad7adb9ba7e2ac9597085fd5031054b4141d27b80dfad731d360d1b9f7831afd7034b1de9c368c0872268a7aa5e88582696100d836e750bbad2a1d77f63ea658ea58b884e857bf2f60193bc0bc04ebef38f8ede7d7c69a399aa96f76451c853cd173e2825ef74d6e2575c52fbd038d4ab1fc8c17fa88cc9fc83d75abfbb685f96338587dc83c2ce6c6170b90927ecf631fce2670148912e97d59a81ef1589761b24a59f63594eb71fb22d469742dd74843981cf5f5526ac1122e85339c10d708ea37858640b27177edc15039d50067b5fd4c5c90209644121111c592fbe06bd60940e69a8685b23e7960913714442ae4540581766f3ee579e407910f62d39d48c15139485b34f723e7a39b92c4b6aeff272dc61d688c7007b1ec1b39866b79d1b66d933bd3f2d00c55b15465c2c35e4e18505e0dd41a1c0df527a2643cb14a2cc839df18b36365211f43cab3645ddd6630fceb409d800a0fe2b5cfae5c47f060350c23fdbb5397edc0d4efbc904670a30ff42b6a4f077413aad235e6db043393013f756fa70efc7da2ac41e855856b5e89afebddf6ff68ee951cb2d2a658f094acdb7b9c7fd25d5297b9004e34dccdc9364075975c368e2d484cffb4b95e468ee418390df1f3f021bd27a57bbab40b0d62da1387e476c7c54ba6422e4fceeac3388eca1f847d44ebdaca73f02940412f6e118d78eda5b80dc9ac7822ad61a5d9fb1559cf486f52c3f6b0023b728c63a765ba74a72c645e99098d08d1971dec34d5c5a0fa8dd67dc18fdbbc3e460fe809a53ac08c1fed21b926e051cab78291f0bcb1355f94ba6be4651d10230e13d3aec150be7de5a31abf2cdcfa755a2836e8edbe9dfb1763f66689eac2c603c8d36b4ee810da35c55b4dd9c587afe2a380ebe3f2c1bd3f30a70d45afbb1ccfa82f2db1a6e2537c11e1a510f5803d82048fbe0034a1972d458bd6207bdc849683ea2b506b8d70ebf65232fd48dc3a70e14e8396a15301678c68fd4f5cf07d334b2f3ed5bdea044ac8a440637a2e563686c820ce1a8d1e270771ccbc93b76f778bce7ddad4d14cb2fd713490784c221802b6d2c2c7d10a670e0a9cfa6a514d908745c709d0663b40241291b369bb3874ef9d1095a10d95ad22a116e42f9e02abf6ecc5e74bf7bbe49409e52a470d43f5356c870195b8c46ff0786b50ccd5e4c5edb7c5e7c345b6958a523e14a221f0f4f4ee1dafdbd2012dd3c018a4b223d0062894006db7379204ef6aef55798973a121db3a19816d12020538d8a7019b04ace3d4d2708a23c811625a874d3e7cfa9a3af22d7e5088f0c0563acf0823ea585a813e40ea9dbe65b85c56a7ff9e78b29cb2149a691d0523456b6df3ba0841f3eebe7bdedb0f473eeefd6d2e95472ac4530aa67f18ba00fae75679df0f586f7ff0ead66448a335bd5fc2354286af70bd7f4340ee5da48181e5669a7cead5993b80286ae0b45e96c7f77bde8ebac50473908301bedab02fa12825f05acc5fe6fed42c0acdb0104da4bf307992cf4a66e26ef7c99588d55419e5321dff4fcc6afb63e53170aedb41235bd21e5d637ba28d150e8ba207d9689df26c3b68ae8d91f15fcb6d3a010a193049b5628be6c0d6389ce368111eb417ab0b9bed8244c4936b5951c58001fa7c42bb604d10f361ca9c99f9e68f65200ed73637941b3a18c0f1a9f6fd44f248c9eb4495203ea690391c2c462f0a39e5d2e345e1513d060b36510061f6167063e56bdc9d7d66d7e2272759afbfa2ac42cd63dd32086681a0c58d50cacf5af74d8fe37097927b70f5a0395be69ead30ed132838e5bb6903b909490eff4c5cb470cc921a1922cd3d53e2d89d1cb82808c8588a85c413429b12632b422d6fe5679c911b03acdc8bb993afaaed36cc912e55d419fdbeac45026f5b8c59013d1d36be12bba47ba6b110ab4a6031838db97066b1aedb01f35b9737b0a5b6ae694a0696c0a05e9dc698888b642df29b2e145ab3603c2c1ae90397947802fe108514aa9dac9d1fcec19eea111c880fff9b67ef2dc7a8cb2adbc2d94e2a68435d147f9f88535edcb326f4b64dfb533adec2c36b7a5ca225816d51c95e18c0c44ecdd35d6831c85d5cf0aea0c33bbed7efa086a73b6c4d6bb8aa5a629f03362f86173169711ef330589c51bbd26c6cc14b1e569e7c152b7078cba37b6e38001efea3f50f5470a774363dcdb4fa8c1a11cabfd393a2d5bc0382c5db081d35daf6400cc6f3d77bb89d181bc96766c70d66f25dc0f0cbcbaff72341c0f9dc8be7c4e81b3a624702af71d4945653332d714a7ab870a47186c092a07d8a23f6d51e7c203fe401e7ab433886393708f3f801afe5cbced5b52f5125f7cb7536377cf74c8d03bc978552951ef375e567919484e2f9efa991311c23ddb025420a3e21af07d2463c87e860afd7cf80dd8efa15ed115f3acb1190ec85844e4a2a4e7d8c938f53dd190e6954aa07291d3311db4d9c93cb1f131d408ee8735f2d8d16b22591d5aecedae1afb6d4c686875b67a374febf6f1835a996c4e300425a8dd02945195c801d1931bfef16e6b72bbfcd5455a36d61bf8d459996570039903a2a188c26e762cd725b67e56593ae8e0656d2686e70040255a571c46680e599eb020629226e53894ed83ced961e60fc2982e6c772a3abfb787d71118376624f3dbbfe2a9061d2ac3e8ede2c0d9fe318a3744d594e88cfcc56e74eb9efef76091f8b9c366e755432bbc03bd39b86697a58bf5e5be5236ca786cfdae66ba0edb2ca9a4085033f1db3d33478209385db4c15c7593fefd6f1eb3aa07bd5d21a5e0e7091c4c601f5576e4345f8a2ebf2da4184cbb034d174abe6f2e254bcbe23b8b009b7156af591c25c01a3f1e61a62d712524c49f9b13cb6e4452b50db0d449c49da8a912f36372332814e789e955cfab353e5c61c29ab2cea47764c8a6030664eb1ab47ecc0c2e20a1d971a9d106ce3fe359595cd2b245efe77296897ca0ad2aa75c9fb4a8d831375feeec733f53c0975a3bc863d28b3fbe1ab64c8f18c04b0eefbd56cafaa741dacd74483dec459b0d134816c3a094d0557626948448c246b5588d763e8fe978e68af1fcffb4d59d8907b959ccfe6a1343015b7e77655f7f2f18c68a5254d28faa2b5d58eac44a891c3fb43885c8798f053992d2f63081ce4fd7bf08bca01ffe912edac6b5ba1645d5e8a3596b56d9b76a6a7de7e115a883d7bc0481f31bc8075a88175f16058f8ad5013cc1043874184eb6b32d259d1bd46f907646cde8887e0ad6bd75641333a51d6617315dfbd01dbaf77ca6b6081801708b13fdf0e34042ab33a25abb2e3c743e5d801cd117f19e808bcd4fe6f818624e38f627d1c3cc56101d4a27006fca15ae0efd55f8adb6e269090643b8e56aacfc90588148cef9790d95a194c8c5ced81b3eab96a629de4a3fb5821320cb9117a8c7996f6836b45d740c66a5d7a83925bb58cf2e4a79992d0357c30887019103f9eaa775ceda0207a52f9dfbde371458261d28eed5fda93bb12ee6070e8f92b6e5fcf1eac4d84677310b31f0e2b7c5eb0a055b0bc03f9ced06ca4161859521afb4c007615189534ea26f498747d0c6008d2426a07deb2834401664abcc0f9b2d1d4b0b9633243870c4f143f47dc2e477aad74c44d07ecf332e3befd1b800c1a8ef8d7706bdceab2b39924a21971f429600abbd1de0682556990aab6aab3ea3abcf0e12736c420afd739e2df30f77ef9b72af62ff41f3bda79388299711268161286c41e63709b731349ae043eb140a1006673c89f93419f24091e75ae400726c4fcf298bdc1306d778ef493e36f2de3cb013eb3b605d531007fd6e4114f11fb61616af2ff20446eed68476989c653817aad5e700fdcea227e4253669bbe891e3c51c2dc3f38e68b15604a01fe149483594e226ce6042cfda07e86ec987da7a51b8b890b557ae866ae07b73eb664fd3828ca8a400d250e4681a7f4fe77e0e29a76d1c0821bb14705a9a6006515f152027bf4913ec6361ebbee9d2ddc08e95272d89875e1c7f5907d901e013d13c5006371db18a166def4381c72d08bb337c14f544df08050373035e35d9b09d3a059aed7a2a4b5338772a3b7cd5bc90da46324a0548e2312bef99a9d80cf75b62857ce91efd73972b39c714d504e61d961dee4c0a9b8e3ce2240d73f22446be1cf28a3ee2ae9736e1016d54917d16490132b5026374b428cad7ef9113d9361ccf8b2282ef22bf8bad169e66e30ebc40d06b12050a5ceed881d5b3504f96ea519058bb70d76cc2234d405d39e5d4de06dae938b1c500b6d7150c390a80e218fe1a01dc148d6a3f8a1b289dc5041cd18a17eef78228847ffe93f76ce892e0696b42a52c95c48865cee6447c9159428b31304fdaefb8128feec85441c49758c11e2aa17cbbfe3b3fad85d13d81a8f84b57dd58727c760416e7100ba20ece35061a687fa6b347f1bd4888bc6337ecda94789ee7a0cfeb7e622d0dd53d32482109df1ff2b2df78acc2cfeebe6ca1202bcfa2a5327d83ba6fb2b16745261e10ef9978c828f816fec3e43444b2af1f415d3d79a1ad0b167d14eef8969b34ac6c101911caafcc437c31ecc56436519a07cff9fe8265f1bf0577fb6219a0bc19233b8b3e1de21db549c0f7ed25556c2fcc876dfbca9c55b8ba9b943c371efc817dbb6c97a339971723fa0f9e4d5e12b3033f204d649cd88d73457b0b5a82e156facae363a2c20235c745581a53f3f7bf6dcbfe55afa080d0eba762264b92d31ab58c0994c6c98a13f628b8ea9789e4b2c49063d3cb9d2046ed1f135a44d56b7ba041fab748627dd35c44286d47c1d7364b6987e2b9c2d07374f09cbee05379c47071fa7a309dad828a74fdbb65915251da8319126499e066acc702a487822f7e6d312a04651c0c3f4451063b8ca8d0b89100e085676f59d4f29ab3f09c0dd05d903a96075ebdd0e79f365889e12a84e6862c925fa1b8822658ddc4016301473d23ce9a2739010e59964349ec0e1cc93d9155aaa0911658d409acba0fc82d0aac1c32ad6ad98b8fb521c62421efc0183d9f3eb92822c0df85709bf14da669643e25cf6ac860280e7644f6439a66205c9615523425b617abe3d4df429abc3117a60e90584e6062a0aeb1b4f89802629dc04b8b000e83bd8e4e9fd7526b32f7ec1ddfcbdc6821450e187f227463452d9713add98340d00a1715b7400f04f2160962ebbfaa0da40c8481a6d73bbddb7cebb360b951423f565c45452042460ad9078d04c68f9d711d9fad5df60867992768721280daa3bd42a78373dc66bbc01d0883321812d99f260067c229185c89dff9670fb95d93dad7bed1e979587b7441c2972c41587c01de60436260acf58919e4e18cbf4818e7720130791f0f4810ea4849fcf45a4547457273df63b85c1c2cb4551a5d72e1cbc6ff0ed5bb6874bb1c839a4b7ea2a2698cb4d0c6d60d6da7abb4d137228b1c23ceac047edf747b9d1cce230bf7fd46cb8ccbf9e02f69c63fb06f4d324446f0e3ba836ffdd8803844f03e38376acb00f89dd9cb6adaac984a7d3d01707f941f4078e373def24bd21376bd62a4a6a12cd1db4ff740b0e1f28fa2cc3231df475584879bbde43a43a19b96a7b60c2b06b4f075b0f8621431ee1b14fb3fc0aaada51cd6aed1b7f5ca223bd6f14e38b43cc83e5d442bdc8b178c4ba6a338591e81e62d0ddcee9eb4fbb19921d3b1d951fce7666ba1b74574f3d023cbb9bafdd51eb59f487c36afa8a0a2dc4c6641c06792cae0a91c007c1155948d8bf545d16bce8ca3033b826f465e2eb35266f392f59bd3def9a25975195c3d650509fa258a4cafd147519b2f47026bb88273a814a8dc2ae1a88997b532935fa054a53101725bf00a523383994ce02be4b311781b67d979557ba451274205f5afdb636b44faae637ae522005b93313320b1f11d3bdf1d7af1c6d2b2346e9833b6e87b1e5e717114f62dd6963badde9ddcd1bb02f3c6e24e1e88c82f12ca0c9646fec8ae0628e5578ee2da1b2774a2d8281be66c4b582e163cfa08b725c214ec4cd6bb576472afdbc936e58ab3fc8622b41b54b76c99a2d83230d42a6e4f7cf7213da143dca47785557b023208c54843c9aced94fce77a6c624b91084bdc2ab9faf099be41fa9a011708fde45789270f53c9988f931943212fc97898b1aae127f89dcb920bf10070b36dd13e44c79ba276aded4bd9e50ac6aa2c13e51fdbe742419167c6bbf844cbc52c262126a8f2cc1e6cd43e78de57aa2ccd829fe77daf6321add8cffd3e5b28c98faf6d9efb01cd9641e5a1ab3e6c620eba55d63c6357697590c2ef4f7a281522432cb598632d9d5abb7380b5db866c3f6cc1e1cc215b089194a41776d273a4bd055e029cfc1cf65c2e11ddfaa65b56b7e1542d58a1cb0d49fae4c7c08324459e71f800b93cd23843d49f5c8c06e1550d3bf0db2b940be864fc9b5b88793b08695666a905f27deb096a90bb83a5f6cfa451eae7093ed02265132ace0c1dce29dfdec8472101b7e6fc8ecb16b7a8aeb846ae98d5b8d48fc7a6bcbca9881c3d0adfc33ed8f7eb94110e1717d9548ee4cb142229c78d7f03af4d22782bd961f9ba737ae1c117f48aaffc218cc76c81a30a815343911530d773183685e73728e4ec29dbc7319bad0419fbc7376d492880c4ed4780d56b66412ce87e3256239db96d2228af5e36b417c4a38e02465b84253aff93b7fe6d62ab74d26a15751c819c3129d08e1b819890824f26c533527cc2e2d827aeea602dfe57400fc227b1e100dbf26a469b9c17407cc4cb4a6adba8fddf8049808ee037b6bcb806ee135835c7c356517a4d23e595ea51f03d6596c69110aac35aaebf6b6fcf905462a273d46fce57c0292cefadc78b39560c7dc4dc79eea96693414acbc4939a3924c406ee3fdcdec748bcc31a0f4795035d5555edbb025f7f6a0d0eb672d376c49923eaa72ca6ab7de82c0e1a316848fe9244e9b909d5d87b475c17f7e588c07ac814297da825f3b96f2eebd3b1460ae584a24cd98926c304c770417a70a1bfbf4984d71ae9790c761dbe7e6e55c2197df3c48b704bc0e0c24dd32a1f095da91432e46d3fbc81e7ccb0d802234370662e6bbe088cd406e868982385fc17ba8da093de42d381657af254c23c1a4bcce801daec530150a778e03119cdf075016ca0b045e9aaff1f41e79f4081e8c6fd061d53d0d26e3621e8be7a3fa1b4b7c1c400c2af87da0222273e739dd72f690c189fa11cc91f49b38526ab52d63f762f251338b0f69044d6c2d4f7cfc249d128b3c6f5385a8ea33a0026316900522a2e0c6a29ac8cbafa2adaee67757b7ad0282d80c94d883aad8a6b7f07239f4afe4d4f9595688dc3df6a3db2d9f6bb1abde80c3a5e3e5b19ed0554cb899e561c5d019406b01cab2d9c4367ee227c53efd928a6fd44e189a5fa425651fa7e343cdffe9829bd052b7ee5dd49435aed507f0f56153ada059fb237b2ee6e5889795a1b014d4cfcacca034dfe952c00c60c2af73b2716db3e8f2c7bc9765a5927e46ed3a5daf2915d5d6570f600a6758334e34b654ec8fa322a58b567970021cd8d951bf77795a9a0c6bdc73ccd8cb18c83e1744810c06f21a129e22bdbea1f38fa44066cb649bbb46818afd9a9388d868962c25301c6552796f8b094aa003c62efc9a7d86e45e57b93ac4b3ec88a3e7253ccef8eed267cacd5bd2fc49e77fc75bf97ce6217dfd2b1fd7504a9f64d88a495883c697ef0285550db8d31b8b81a1e61781c153127720489f13a408c209356e54623a7eb227297e5e623d204ae3e084c2aee1fa6543eaf7ec62c1789ef2c3ca0f7d0e1704dd8031532cd437dba6f40ba698512580568d827d5e47baa31242e8da4a08daa0c7a086fe42e54678f5eb816fc296a5dc6f5347fbd705e387a931c2577dffe427209c0854330ff2a9e37ac300c336de668c8e493fa0de74586388446118c98b53a3e6ca24d5d3d3668030e9a6687e101c6fea07608c77a491a577d712902dfbd92c9b0b60cfa6aefd03b88d10692a9c85e4d4d6e46eddfc2d8b2218b53206dfb5415ef6701c9788fef6b83445c054c5c8582a0d456b56475610fd5062b5b1c7cf0302436a240b7330422645ef1879a9a4ca07487763cd302583f827d8e10259ad781082e100c58d358a3b964acedd28b11d8908ded3937d710f46ba6ca0b0b97e029c1fcb44ae84a51507a43ce9eb97a5e09fcdfa35d228f29d619a59280257da2583abe3ec66b79c7a17f51897368032d17c2ca46e3ac28ed19cc173a3e2a96cbef3ca9d3dd1ec5326a4739c782073369434eac6decaafd3297919002f2f65dcf9af9d225edcd0872906f80a39717f5431e2b627e34c67ae75af0e815de5525529a791a3475b109bdeea7901bfd003cc3879ffc0aeb396dab0f731adee18b9389e5d2aa67dca215b48e2fe460b2557b14b85c447767b0798a77a756bac7dae114d652a1c50d81c8daf7471daaeb1d76659dbd75904190fc4dfec7d8565d30d6af984a8f69fea4dc9dc34f7c155df2b9ee9d436c6c13a663174df903bbbe0c425013028555ef2d20f7e57a80c15d062cd037e5ca36e6f2b1c8a27880b895ec206e0724cae4a2ef64b84684ca8e6802de4b74b1edd2d8a6df7e3d5920c265adfba8a6fa36f6f272ea07f804bd708411cf3bd5c9a03de2f0ff560dbfb5788e347e34e09f920cf8091a87207d88c5ece66b17cb299c36c6b9b5259bf16cbda4a990d1898ddf377188e3a4f673b345e319f2807c380050501d14b35f7dd271ee94974cc2eac4819db889fef9082629c42aef2e9cc254e8c9a8a75018c993ab51fee4edb60c8c593f2fd90eda1cea9a3dd34d82a43422305f3abb48b2603f53d79764417fc0d2275db6a879b39e933f2fd62cc8616c0f8bb61c2e1c2da909ca65eca475f7091936d3090287500425fb6332f0cdfc1c0fb172abecd9dbf5cda480529035a504c72e0afc5906645d1c436c1fe49cbaa083476345b397f250d69a342a25dc0ca970b481909b454d77b9e2f10b52942996fe978f70b6fff9e3d986a44061162eaefe0819cacf47031b0fe999197857db1040a95467cdea97c9a98f2a9777dd1778251b1b5c339a0d5f7dfd81908bca33529b2a3e3acf620c6ca1de20740975aab6fdb094784ea2c8a11146f9564e0746adb36ee4d74a2219c83a272a4e68f88cf3208cbcd686efa1800503da3721527d14aa4e98b46c95dafd4936e50bc8a80594b1b9f99ad8817b23520908f90bf9ff511f2c4793b46627dd1df5dd52fd9a5b851e71460211fbe5c442551edfeb62de2a3447a7c2a7c8f053cc385bbeb0114093d0bdbe5495f51b294d49ff599ded5e6cddb2af1459ec92f481cd308022e130eae33090470774dadce973c0adb1d5e97a1efdcec0e65af302d93de5e475c560ee35469e2a365783ae3b152bb07deb328ebaf4d64174c6bbb0a44a9b749c62cf3b99b7da24812f23914f42816983b07f0ef8bd84201f08b3b173709565441c099bcd1205f359486da11f120dbb32ecd766ae9c5a04c872d7e370448d2785ec95438c1211d19483caf8ecddf24aa65a29476d301cb15343a0f94298352f78ee88f9009bdab2725fac11e42417fb7b8e38ec9c78bc5576d4f9fae6919ca064c6e3af43495009c6333afbd1f343b998407b73b04af22ec99d172488b129a91bef2c3dea72230897abf8d6ece405406ba73268e6d2bc83570bf7796adce6047b16f4298c1a7c5177caa02641a9cf43e56d00373efee4e172599541d3765d05f4edee8a1eb8a0e8fe4a160a6e264c62c29f859d43b684a1427ab50831abfdc5ee6f826164261730f16ee42aa26def68998668c8864f3c40979dd0bafe1947e118559590215d172a9a2b695e66466e8a34d75e78cd026b9199af606c502f079bd9a31919cf9ce2e46f046485c6e043267c0fc46d16e7d56e25af08beac9bbeb263f0c98ecdb6ef52449d91e5942e7bc4f6c9ef11a7af2dbdbdf0107bafbfa2ea29addd63d554e5d4f6fd9cee29ca33104460e9f0ca62a20ac4ad8cf1e290b8758adb42de7f3bec302f7f1e6dbe7e2e74f27dd470e73552330d0bd48e3b0a345bc07e3858bea3ecfb76f0d21467a837477cc306664c42933ecb19c65dd3aee5e3e3d1ccdf782c8c9715871d9db04b4698bdd0120824038c9b48fd658be9f44ed86db8c7768ac395b5c83adbb32352a15b17a91d2cfe407b713985df537bfa8d29d8943025549643d3d7e3606ec6ec95aff183a1d8e7e957299b01cb1445257ebdb0227e609753e57f9a958d77958a10f2c8ecf59de9e3949b81253f4dc824be946271f5376bb746d59f109ea5fa691fa2a7d72a0c659d11c8e281db0a1159c60fe8c9889397acf18795920a8eb19610b431c4f90c63339485c3efa5d298fd343b6dd08c037737118491a322bdcd1d9f9711d739b64ccad1b6fdd7c0bfa309b19c85195796d5adb886f41b768a5e4c1e2492c61285ea0e516bccf01708cb0bb232bfb6969662327683aec5de5d07b00105139f04bff5318698728f3fd57f84054d1fef05a3c75bd83d92c0614dc7ab70768a2fc8ee5732b642060d8a90ff326b7e1a5cc98dd175676459af9c466ee6f7834bc596fa9a781e3fe4d1e812d99a010de61bbf594943d39e6d3410d10524d27ecd1e41a61c29a2975cf9d793db9f49a8e17d2509545dc4282009a82b4212c8f8bb743aa473c6909ac6a0df89ab7e9ae1bc94c833fa0e79a3176249ac25c03fab3ff58d72e9a468a6db4d97dfc5fb66f385325f372d14148444c984a437cd6102f05e4ffd2860ce5b19cc6c6e9d1f070da583b4e0f0847cbc836b75bd0f2e10f45719971088b8dfe4df7f6185a55f0aff9f2694b248443eeb75c72774cfd1b4caf63f56abe996003d1c3d19f06e7ad690b0ab9ea8e7d2cd66a2e57826ed225d96f3e87d77117759efad500952c11fc20994087fa74931e1f199326ac032ec980379ade16ceff96a930cce06bd66a24aa2bfee0866fd2722985ca6b849cd54d3812217d4c53f7478c7e111fe7241fb9ab8585ca73f85b42d9c699b33a4d33fa4d8f115281297ea60f14887e36bdf0c9f7fb949fa6d2c4cbe076e73ea1d21dc50ca1c49364e0952645fe9eb7bdbbc411675c7e41f87e6e7ab1bcc6dadd1aa1455d2c78ea09e78d29c95797466cc2ff08b6b52696e48c8925fb65704e7f393d5595c1e311500acde86571991adde7119c38a5be155066f6e04be2f652c52605b6ffefe5c70d4d17c13c35a8918a972051bf9dbcd0e2fc72293b95d516013430aa5b9b47600361593442a801d638838045f850b9afec6dc9a418bad2d0205d80620f5bd10e69aa3320ddfb66fca595518c598d071c2785460d1d4873f0ab5049d6747e516c45dc232fc458528cc4b1b92cec1a8da4407ab75458f73dbc810cf0923335d224a6a0f8c8535925740c2b21db466fd39211a39a31bfd4cf3081f6bf7e669142a96fbff6a64b6c1423013ea69f0a57c3fef641220b1566fcd9d5da30ec5f9e75ebbdec9dd544ead7f1eb25d697be6456bb204143978965a50451e57a760ae375bb82c3c6c79e42a67ddba25ed2b1af260f343a297e1303bd32bec9a506070e005a7d183e213e3dc832cb43863e582ee8e8f838e9732e8357bf3048014b973b3bfd4146c66b81c5f64d0e7271de94969bbe4629dc083b8ecd07a8965310dc0f2f9482fd24b49665cb6d9b3902a7700d1e2b80aadfa8f15c40f292e673c9f713a2da27a69eb26366a128068a19d0f358194ff1cb9034ade364d2b65b702340503d706e1d29c2086ad3e188820c027693bd5d46e02412728ac3c4160fdc104062c030a284d27096e658834a6d8549f3ff261de291639f44f46ecdd4143c41031b416c0e81c00c247e6824b0276843a458d626cb98cd45901e9770ef021b1ef0019e4013d16eba559274ced1edb5111776cee87401887c0744e36d83d011686157be953b631da0d489861f060cd1ddfa0cb0a256ca72b99ccd1aeec32a3ba03d2874c94e4d8365c972e217c63cb7f11696641c2005a797323d63a3065157f5f1c6c329c895c06d8090599fd60d78bd1dd2522e1f571b187c07f3dc0805f3f4d128ff074a344ea44e347a7282216e902f3e800d263435cd0094abec42bf49c149861ffcf9df4ea263e1e0009f552ef6c4f9606d4db32395bca315e181e38a81cd49744a8d3b497a40c3dc3ba9fb4856a30bf76ee872a1d64026c130b71da24d5a3161f74ed14f975eb97e9e385d92f159d6c4e65928a771b2ffe99cfaad51157247062105cf8f4724fb8cc3c76e451fee0a08fa2e821bc694414630d6512b60463141ded4fbbe33eae51f15445cd62e95470c8b16e553a0942288e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
