<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8069bacd733a86967c90d316d0d418ddf0913ca68e4c50ac32c9c48226d8577d23b24e27ef3eeee82dfdeaf4ca9bace7c889ac3b58ba0f01040ac2a6fc9ffae00f9bad4aae75b21afe509ea16f656a25bff55665967631abe8dff0bb0e5aa22986527aebefc98b32d8048f4440cf7f327edac8bfa105d73d8ae4b25e0d8f9abd94450f7e6499e0204bacf27bb8a68c71ce6f555b5f8d0eb9718779e35e511d342195a9bf53a1fa65b713521129c60c6f59d96c3b275ae7d066687c090fa0f80dc4c442ba21edf55eb145be143456248557df93f9b34b5487712276797528d520877d36107757734d241d43e16c7a103e7efc4c2635a038d695816d606b508ac5f6d182da720c82a8e7b8469880b286a2714e0d0a493d629d23a1da6cf695e71c73e985dfc9a958523c27146e8faf525ffe582b194ecd55839313d9ebb0daf907ebe13f699f3232af98935a17724e450cc91bbe5f65a984182aecae5434fa9c90240e72bf7d8e137f0a17325484e28c2e57a4f640093295c2bde2850509ee0e99e639523afb77d04f42da483d3e45aa594017cf22f214a871c3c857c7188e20bc0477d9c6c6a49bfaf5e80d66cb8e8ac8049b8fb02fa05326f21d067867523f6a43412250315ea501caf9461fc53041711749910cfb770f4e9b2afc4527e0debe4b9ca8e17c494f0f97b9a905543aba1f0f50509a87e9a265fb74e570606d481fe30fa419085795e615baf72ee125cb858ed9a4177ebf9b67cdab513d6c80faa9f93b29e6a21d576d02115ab81cb0b6e5b341484ecf38a2569e9bf37dadfd91fea45fe361263a46badc809eea1a00367760e22b3e1f7f1f5cb30a3f4a883c3b746451432a76dd82b849fcf1df5af3ee704e200b7e6f15f0f13b6a76a8dea48fa73bcc822ae6a1cbab137d071a3f928934f39439b75b536c5dea63b66201e7a20d1dd39eed86c910a07adbcd7592eebd230b92d7c0eb543b523c08a8b86633c77a07db74ca7566db26ce82c07ad57ee0dd30cb06924667258795b3455471262a18e8c02c2fa7c16932da542b841c6642d4370fbb33e5bdddc6e6b4cf377ccb97c6260fdc88c1a03d9139cb43fe93ef7558a0e441ed917dfe3c3f8cf9a89175520547574e0c9595779dcf699aa2a966c72eae8498c35b500ebad0046324ae9982cd04c30dffe6633f2632af719c2e9de7ec4dfa72e68557918080d02ef4bf9bd2216e3f26d360b8b45878d63d0e203a6be72e181754445a89eec4a9a457307d45f9cdf85e577b8f659cbc020c1de82353d6813af6ed79cad80332f63ec9942901fe5f57e1b0a854de5a317217b0e801eba10c5a66acf7974315ae01fba3090fa6279b53238bfa0cd605c950962b47efe7eefaf9120e268e73317e78778448cc5466e2ea2f2efaad872207653345069f362bb5cb7281a96e48420d88825f204f3427810159ddc518c2cc4b4d6ed7ad0732314bb2c001185d68b250c3fde01fa097c9926825f4dcc9485253e61188394597e0b64a08cdf598de2478d947466dd829d20cfed710af390aaf1f4f667a2f9207a7681d6b79d305cdb507daf258dd3b5b19a78927e2bbba34e7d1c056ad3bb00ad6c47594f438d49e43c739e0867d0f762d478eba02861741b8ce4c66220b52c0cdea089b5c7bd84e7610aed2272a91bb727f29916075aa6931c2e4421b0f652dcb3e2adc53338ba8d987c8587bb4fec0081faee2afabebaeae5b15666f6bdbd657545a1a6264a0f99850c49a6e09cc522a6f14f1830a46b9709a6b6cbd3151fab82e92f522bacac75d9c3f904a45482b9fa5c6471c09eacc02f43e8f346797d91efe458b6081af2c0469cbc6e56005af26c36f65c165cfc36ab4156d021bb6a9735bd6ad9d14d1e834f282684ff96b8cc893340d813e2cc700e650cdf2ce55b4a59abb1a5737ffd0339c31225451ffcde87a48bc16e4293528369af14b0b3ba0c1a0dae649c0d96bcc3c64e2768f91fc0e628a29320d06f81030830076dc564a8b0e97afb54e24e34175fdd445726360c0114961d4f502d28a86ae9c8eb30d0a363100a2121f6d2b52a9f846b4f5ab027b91471172ad9e1c323077251053cd2283702ade90fb34c21b2e4fc0842f8dd975028237788b9349a7411da0a86e1193e10a61e20d5062b445693b517a4ea975e3b47e04b47fa93901afec4ac5368019dd3d36019ab4ef626e9eb01244ee97982c12bf3d28d7ce56595cb63f5108201c8b0ac8939c9824151e33ecfb6815338f3e5f4ecdf2944e13d646982abbca5f5f37317ea104e28c2a098b246867c7dad2b32c83968a83bb9cd55fa2e51669cf59ca795f3815170a46e4de1f609251320a896819563c65275472df2eb279e228da82a2393e7f5692040aaf5d508b5ee18250e43da310ce9ee91bd6819d9db1669cd2c9d366a37a8eb93c264a253c7a10e12455f216103de08250a2fc30afe3df7b83a13dd563af61e182e16850ce18b883c0bf0fe186e7db8681858a8aaf3e86705a173bfc8b80570a667a1e59cc185b6276f58adb3299539aeaca91752f7872a70492471ba9f3e02208cb2600f1ce1b83a92d9ee4ae5eca6c4a23452aa3fbe4823f8a19f9e07de5aaaa5b190ad162f35518c2baf1ec54f7d891b702caf8e689acee698512d4bf4da329c96985122c75f840aae4a10dc9ea27c76e1481e73c8961838daa3a0e5858a5c098e31256feccd43516ffb853cfd058c55ab96bc294a0cd63ea09de089eb989d48181b7bcb67fc7c11d2337585675da74f209f07f522261bc3e917d5e5e9d3858b8f11a26f5d84254c22564f097aa239e7b3af37302f1ebfea5fdf6292a76e8c7a48dff6d9a366f862b8212a5d05cf016328dd48b28ca95472f3542644344da08546e000cf464435aa1ec550dd56df4ec55636c337e7056aa0d08a7dc1a5b15bfa512f13a74477f806a31079a82653969765a3690e47fe188a66d866abee04bbc1abeefa1f4959f43040350ba3db81237c944214174c55f6bcd3a5957362d02de3e20ee49b9cb0c425d865fedd9318f4c0bdcde1f52d5c920115a53005ebf8bb9a87e11e6b3995e644a0481a2ab3200f7700ccbf374064f48e52f01dd88886366d17af9babc011ef0efb34139faf390861c54d25743b5a69c4717c9d4d8d326f306f75ab9774c1f730bb2939a638ff9b6f74be8f39f62da434ec2310f156a6a163c7f82f97b7d0dd016a173758e14873189783d5ee03b59a3735064c77d01c28a7908132cbb2c33aa5cd8cf1952a8ea0ba0ca643590e7ad40537f3213052ea1c0478efb5b5eaf57134e61e3102ae785d0e6277ec7245baf87229001976f6fa48dd3840000002cfef53e7d334dd933fb15a084e029c47cc862eee2214ca5f24ebd8242f5ec36b62fe7600a246f7b8d97445b0ff3390fe6c71b6e41b93f7af557949e3077d6fe3502052774b9a612b44790c70ce65c33750171e9f20ce85c7b72384b8e9ac53dd1a1f6d1acf47db04b09ac34ea511254b8065d2baef137e75a1a28d8174914d30e7866e55157a88d813d231aaa74d918e0f0229ca76b26c7084ce7ec02ee22451efccedb93e0ea7d9ad5165600dee7b9d4d8817b58e1b5ba9f102bca3987ed829280893ecf71663305fe0d85bc0be2f0f9cb9ce8dbf63b5ca535b0b94a116583b14b9286ec715af783967c052c347580e54f6e800a46dd6f8c869145779b9792dbe64e536848863ec8be2028788665c418d5354d6a2b0533dc47cbcda18aa0d918169ee1d48d922848a8d8139e18202aaadb1d4f1615f4ff55990eb5ceefc2e91de5199a57a83d9da5f3137d011e0934dd12b1ef96abadc7b70b190499afe11dfbaee25b1849279db5439800d43b9fdf695a55baa5504f0765b8395522bd4e9134620ee1a7b970760b4eba80f7c899825a8a3408e8723d01d2995c7b7150fc03f259391166b8d2c17b9722df39d349d71de3cd85c6e593c54bab5a01817c66b8d360f844b12691ffd80a12b4bed2e0df3e1f4d24cd6f1b9f8362fce7723e4b3886159bced512a3d3db4b31d5195481d63217aa7bd5108c8c0128fd593f5171bd8dc053f8e1526bcbfcffacd264468bb1de7275d3e1a6a7b4042cedd4060f94c937eab6238f7a0c1dcdab46fb49a15cb474c144c1288ee7ddf25bd38d73eb18090fabffcdead9a1c8df4fc34cd90f0e59bcabeffe155adc318b8dbef432548d973eab30d710193c519f57a7b4dd6e78302739f2a15efd6393ba29e41c330b8a4533c59bffe37c4e048791acbebbc1dfce5c1eb4bbd58be4ac10ea51236a688d1011ec792689250df7136220586625a56fa69ead8603db929147b7731c9b5ab6a9199a1896169a5fb954c876fda2533a0984137bf94c5f42c65b0ebb8b2cc63ed37beefa1f0215468daefe29101861b114b81eb6cc65579154055908214000f9aa5e5ba4d3a218cd4d93bfbbb18be59b14a3bc951158f80e747a47f9c8ef9afe69e84ed3f5e5fa360bf8f826294cb32459cb67b7714eb64a4e92074c0491072460c3df8c73e050703fc0c3e8d6470aa39508a085cdd6c6ae46709e6010dde120d059afe6a8317ee1568b148fe5339d98b6c342ab862b2b5d54cd559e34351d6db33915511077269869985f95e3eab0a1a9c34e8e6389ef64e06e57c41d980198cdabc952dd4820185b7393dbd09313aed03e4fe6aae9c18adea5ecb4ec69bd84559bbd4cfd29a6754ccfc76dc70693dd5e0c9f4060779596a02f05f821d3d834fc3a06fdbf0105d4a17f4931150c342bd3081885f84f5919020ec194bf8093d0abf0042a2651787af4b2e3e383990ba41963b04a643a60328434cfd37b995f542c7d7efb39003005a7d1b797ccd0fe59397a05f96110122cceac879d660a79203444885151fbd1e42f2bc2d83569c92f75f1a249ff8aa8a3c275615fe4f24c13981a7cda7a803d8a0905875a3ad9d3b92cd7ee20e20b04e7bb3e26ff64f9a38b31a07fffbafa72fa494bc7edcbc4d03e7220010e2a3c1606b9638aabdaa1702c224dcf2e660fc10af3be31d1eecf4f957f387401e5acf878351df6940c6a516dc6d4f602ee228e2b33ce08c6371e1978370e3371ad8873e8902f9c328ca62002c3f121cbece77be864dcdb63fbd8c5a1fa3cb2b65fda99ca089b7168ff45e7836f36fb4c2fdbb27a08b2bb4abf70dfbf4a68ac3670528516a7110e02d13cd1c8f6188b2eb457fd2edafb8c254eceb7f62f6e2174083d17603e37f17079455663bd848063b3d08e29cc2f0565192d8636fcbcf48e4b01d04fbc34febf71e389ca887e9b55de16a353c040c1bbf3b5758000808cf762703bad73b75ca741ee6557c3845ae7ce9164a214e61719da083a3905b0a4a0186d36f38db631a6bb65ed1c2ed6b08006a690665818c2a3fbd9341ef7804c3c517378f986ca46272073bb52fdfb29f4b0b94211c1010c96377df69a7fece23d2d785c912e94d8a97860775769047a0385630b684bc164c890e49b610c462a5f663ec4a7f42d837049069ca97325022693f805850b92b42dacc6ab08cb61c99121d69c63f9444ac77bc1fb60fc39e6e8bb9028502424e669d7abed3b4ab6430ea13ce8d7398b157bb1748ea3b93ac0768a47815d22d438fa9dbfe777b26a10a9ccd5ad1d8364e419e536e248fae0b30236212d46e41c1fc772766c75ca8ffa9dc09cebe12b3d70b8cf96f25ddeeff7b3fd4795cc97cfd2223267d0a3a8c526a3135cf36e2e2ce39cf864a76a65bd6d74c28852f1a4ceaf9db506de445527f8cb7cb1fd0b032e79dfa2c324b0f1291192475b28d875a8346b7294f825c30e4433b5afa2888d272f6335b2bf7b5d5f393cd3290d114ff7e9a7f8fdaecee45068669ea3d3eba5bc2167637e0ce8f70bb55d7369f6f72d287be07c6a1a5383def5ebffebc044265e0bd7904b9faf448cf437ecc65a07d3f9815f43f414862d2c35d5a2968d22f203d5019a1cdccfac8b7031362f572d5ba513280764996f296aada023bdd8006f03e9677db3c60feba7a8cf13e5b6308aba70422d424695773a60a7e294cded75fa920b665d4f8692cef4e74960cb4256cbbe6454f1e478a9d051d490605ce2b5e7e1878321c82053b93c3f56372eb054ceb9f55f16e9fcd7f978b82639ce673da61f3a0546a5ddfc40b7af3aa1c4efb6bbeee4daf069853b67bc82f9bb1557662b74b256ba1097ea5fd0063f922f45f09f68726c07f9daa3c5575d0078246fb45eb2e7f8883abed67bc3141a67a2b069c0a7afcf3bf0d7b970ae3e9dc26c0ef34323cf849ec608c1f40516d4f8f7d5e118c0d1ae2caf65c3ade6b82c81eec89fbc332493673f75a0084b36e59fc2f2bb06d10f9775bfe4cae448f95df0a9ff5b856151f2056021d3079ffe430cb6ab3f0f5201dafba0e84d3f06d8d4b0dfe5bda45ab920f22fa5553dd80988298aa8afa6c8d7a01891abf0fd889b03263b369da51f77ebb96f31204fa287a77e411fe2fbf9aa3d2b800e89360ac1a3d895bbf0571e57b41bdb98e236a812239cd613ece9b5031bc85c571afed60967dc0d4671cfff33cac3545d9813c6304c93876fd6207a15ddd712a19a4079f3b0edc50b8dcf924be1f48808ce301d5f56cbb0f4fff412544558ef485df669ffbfe10750f24049f90e7a9b5a3e9e5f2f26f866c6c1db7acec961d64e0094d2c0affb9bbb37ad5060e51d13b7422749420a42876dfec4f0657d2fbbc2431191e0a320f96a5d41ec58a0d3ea799a2cad15fda696ef8dbc17d6d35c2d5f9f8dabff17d40f306d2b1e54a527a7f784bcff77eac0521ff67794a0d0a0012c9856da84efddf1372c2eeadab5e757c50bf7231f1803fb9ae53259c2d31e15e8ff55959f7577f5cc6fc3974dad0f39528df5b227ffc49ffd370a99c84da6fb1b305f71e1c21c91a95bbc8bb31cec8a519acda4b5f4e6462b0e6d9622b1c50515f549e8518972eb224b86cb3e3293c34865e8254d81bce2a47bed68bfe5e093514dc627efd4480154a7f54a1e826cbfde8d0930376240e244dc52ade01cc4aa76605c9b4be45bdd1a81b92b1c9739c55688f8816e784c9c488a48ecb5ce8c353738720709e7a64f873bbb2898302da52646c6d47edc0cb35ebdd75f25d694a76ecc8e7e135f2a0e397e3cc73fd30933f56848acbe282e39852aec066ac4057f9342e7450f75bbc1bfb233eacdfcbaa9f1f34313f365cc866bd150ce16f5ab5bee2f652c96f65b54a934c323db9bb72bcf1314c8881e51295b9a776e8d1970269a4c706772e162e878e0d24bf7a34cf57f1d7d3ee3efa68f026ef51a15e4601155ef750f5813ffe1bd52ca8166dd7506cc7f6c776562bd1a14dab99116f5d51ee6084ac93bb61302045465d1b968d8da6e5fe5c5bc0b028883228230648c1819f122f8dd021513239ba7410cd7aceee03054adb37dadee9ab364cb36a0047f80741927d543c69f8996a5e17e164ba57b6ac5093964d3d744b90e3463195d8acd3c7323676dc03c56b4c350a5942e69ac064f93e24050878cf819a87faeb86e469c2718a794c937f631a946b5c6d3718dbcaea4b8895b6042e7fad4f5186ec645acc2979c53356b47f71ad4fbfb3eb47f4e48d9df9f46e6240fab48cc38b2b45fce79de9ebc5264b01378726c390aedeedaca218e99175469d94fd20402238d2b363ce31a265b2b14ab56f1e62879ee5bae3833aa86687db836b7104478d611d0f90fb6eba5741a45cbd3449b8b10212be2cf3b6b06b0e3fbeb235485821474902c67d3849de97da403e7aa2a8f777e29bab59b9371d6cb22df02ce59f79f4ff3af0edfebd2ff5b1fba24590f5ac21b4c5fe7b96bbf18234efce9a4d282b301f9e490f0ddfd07ca6744e88d415b4e0dace0b0ceb1a510cf223fb94e3a9cbf16336470b52c5bae813580bb83d3a9b5807cd23ef9897e4933c8b4d74518d48b6fe452b397f426b83e207226a753fd6b1dcd214cd5de62b4e2961d6e1b0a1c3a4df107aec967f6506335a67bb975c9e39019db6c9cced4297185933ab8424bfbd342aafcd4a5c238f9fdfeca7c4c4f0e9f5160f981e95c3a64770c38cad7519a35c03fe4ad50907b410e602d01895f13089cd920cbd9fdcac8575d5c3b042cedf887b6ed808d53f3f8ca44d5284e9c38c5c52cf74d3f7650e1d4b99c277a63f9c6a8f4554ab26d54547e85b8d3011f26213c8fad79499abdee7cfc6d848d8d18cce96ce57f807fa6e84ccb00a58b41f7f0ed5d0f47b1603427efa9d852548f81c832c7e7514dc1ea33dab6c62f62c9d8520332d5fefcf4878a4306da9a3214b455923b2f80bea9e8abcd9e8e716041f2c7ec30a41ea1eeb949614653e526a13f416fc14e2efa5aacc88ea92949d9cbd498b8749348ea7e222d97b9853043f4d1250faa64223b00f4900de740b12616a5181f023700bc8fb87dd7d9de24c6f487c47cd6904ab6343069d62ba9503ec05a29c70dbeefa06e2173b42cfe1aed5dffcea9d6b6321b0b8388188b54b8b8cda8adbfe52710c0fdd073f5826598629456a6d86f44f08a7cf509597549568d6c47f37c142c31af658e8b5b9876affcda64d69105d79620d4f02dfa1ded3837606e345017eaefcd2901db515c66e67c5f97385ea9ee6d1095558644d4fb21172a5b589212ec639597ee06ffee5f5a9c0088055515f00dea99f893e33526d264ec78cf5c715c89c1b20f5611f66703d0fd0fb3b653ac576d8cbde16fca200c7d9299bf6acc356df79852e6f7d6a27e4e82d3378b3322305a752f656de5db6b5930c4b20dde4c4302035274015ad6ecaf593880209beae7bbbd7b8911bd808785f68edf8ec004da103bab5118eb927e18b11b378595398bf4dc15f685b2d6534274c5bac4e2680ad6a1928e7f404c4d524f4323a71cb20a97214331881332cba5cc0df5df6c291c03a4d5f71248a7ca9083e24cfb2abd9a926ffb4990b8e31f94e99debcd3ef5a03855f654f1b90659ad961cd6f28d71857099412630f860e7c30c68eebdd0b81e19d0edcc9f7cf8708ac0e868dd7e3c078ee98a20d468052abaa134389c5b3a18c975506a73848a19b2cefba18eb36cc2f7995b004e0ef387889da2a71d352ace7060326be93fb97d92ba46ded35fd7648890d28a6da5ce7a34b12a6621c63168eba6ca5038390ce43366fb35e7924987047c5fb9c0f6b7c99d9462db3b9ba14be7d86b72b6341f52262d14e78d6d8107cc1de8eb61131c93f1b457f28d6822241ea04e6b0a77c97b85969b61dee3ce96f13da39369ab31cdc63eb035635055e5331d801c5b8b6a200c853918a9756bca6b21bcc2706f70aa57404c83415695546b7c38d81f173a0e759a19b484837e75f05743c1ce367cf7ad26e2ba1169d4a76561bd68d00aa796648f440d60eac1ae9593cdaa018e366b11084cfff91bdf36beda950a0cd291fe05059c03e3823c4e73ee77668e9176c8bb872f382dd569943ca602d52a457e5326a664d2c196d7aca7bd1f2e5cbd53578e72d68bd89f2a141e382a0805f764586776b64eb4438a0881fa195ab71a0580371d788c40ca032deb0903cbe6b146fa298ba9a6e172fc1d285fbb68cf2e5be6e40da8166218bce43e71b6967f24a65c73822f2907c01b6671a04adfc00a963267baf64a23aaa676a44ef54363965f9c74fa287ab9683a1703133e63a8ecea0fc256b077dbd6953e412444d7b14b406207901b4c9f49a6324b9ed6a29cb5d0c51084420e5973c1f94fca4fc7d99084b30dda0e6c79aa68636f89817005ca274db6e53a2ab3ca4d684ea2a126f12c98f5056c265820ac4840addfde0722cd7505429347e744b41224b64dbdc9b1056dbd3fce8fd337475925ed236c6f4051d29fdd4d00430e1fbd44477c434744f225c830f55a202d0b645354c3c902ae2aae71d38c7777b6934eb46b6ba4b43f6e3722c17f588294d4ea0b6b50f6684679691479975b237e30d394bb60cbe6512af87e3a7fa0fa79683bfc4df543960b7dfb21b6d56fcc569f2425a8868f684534cb59b2b55e27f8b9ec8fa727f797ed6bc1be627ff4acb4d2471c6595ede15690385c9879bfae73e920b13779db5531dc19017d1a17633d5cde3e647c511a75cbdf2a145bdb2db8820747914f4d9b3f9f5a8d8ad7ae406cd654d52ca8434c51d508342bc3b9fb26f224dffaf26844dff8add44279bb84a4946d90b9de3d952cb200652cf6f23aa613ab200b2ce1d00fea6e0f2b54ee5507020c2388bf5ec92c517392fde3ca9bcc01d3d9f4922054c86f97542bd6e5a7d6febdcc23c8acb87c9dc5f5f3d4889727a5d5177e54d889ffcd99c4a4dbb3930e5c9d6c5ea8e158251eae6664724cae297318e90234da5baa0f42c0212be708f320c78791558b378c3df2ecca0dbfb41b31ea2d0f5bc689279a6fdd1f30e7d24f1e1abcf8f7aac50a3abfff0305055d70381a5d99b0586323bb7cf35c366ea4fdb0e9d92f6204bb941922f58a0222862982f968f0a7ac317517f388038d3ccfa6bce62cc47e8a1e0b11f3777b7f7db22b298291dcc236423d9988b6ddd09c3820d28a2dfb11903323cfdabd82ed57f39f17b5084fb8de50c34e53500c352ffce7db72276160bf979fc3752009e5a8d8d367d4f668fa8527c55386fbf0752d37402df71c20876f18f40b502dd170297940dc75fdd223fb3bd790020ec5c6e2bf32fcfcad1ebbaee226ce61162e4e3c26d8503e880fe5dbe265c51ab5d1c61f97a604b2dc581a6baa1e3ea1af3580fd0d34f60c2d4a9295722382c09706af0fef30f953b22d768f447836b293a29524dda75dc723cf663eb4dd597101705a592e05d570cb6d6b56db8a94f2e8bea140e8fc86e8119d282c8887ac937bd5fde132e245bf4e5e525dae259577fa95b42002c1255e79fee0f0ee801d3267f4b53c0148b074745360b7115da4bd33b750faba5ffd69a658c0bc2ec3a3951d42761b7a5485191b26f1e7b0537914c99b96ce94bfb660e385301de21e29f80a687e64ff0b9716ef982899d818671d8c05881b47a5661a294ba9efa29a9e8450ec72af0361145bc16cf317c6ecaec3d2b3565340d8ab261bfccd206547f127375486576933c96a4940a79c8b1a9413b8d939eebd3809b78c081706276c0116e10d42ac57cf8cd7bbf3a2ab2b33ef2097de565086d4eaf5cf6b4777aa5de75db5df884830b0fc4c4c83c07ffd1e572d904c12e17d5fd2862efe7e82532c7ae6f384acfee3b72e508bd73847d7a3efd009eb6761afac5cc97a1f435ad84023ffc2def29bc4a297a651e1943e4ff3dd7873560a2af78868e8e4dedf4459991a4d9ead97fd5e61e017efbf1497a7124504f95f4edc3e76d5267cc61cac9ef591cd325b657dc55db855263cd0b8320ea8ccf320651901e0e8435a690dcbefe3eb16194456b5e2147921c231f98ef95d6495256931f8016be661648bb479d59759a82f5ce7ab034089398f737693f36530c4f0cddf199e0ee4f92fe1134712c8334fb6e8c6f399f57c8bade410e289ecff3fa62e480500b1aa00a0e2c25bc2991f4472d34d2d4ae4f1889de6e7d247f0f2f357d1107a67fba7d391c04ba8c1a644a23adcdbe4fd9d48b0062ca4f486edf00ca4c1b947d172cac0fd8f60eb9416be5f4fa1e8a369cacab40cb89de99baa3b039256380c80c436f7236ac9347c8c7982bcefe655901b116883e94b372533f844e186e2df5fde12023dedc48e0c8ce1a3888576436546ed3016edf43b40e00ecb86dc0021101a7791c2e592e38e8f0bb380fdcc532b42a5e666b387ec298c384ded0c8e32f4d4a14b8465455b796d345541473d331fc02368a1dbdbb3735d5efd86e4d38ac405c02df72197288438182dbeb1a2b211758f49439851db66590c5fa539d9cc462c88c32b3c8bef9a514ada963fd51288770c4d96833c554f5517c0fe7e7892a38777db815d5f932c9e94f0b89de5ef5e569f553f49e4782b260c25845ca6501fc6dae25573f53d31e7862cdd99d357e7a5615ba1f2595f93e5970006cafe8932f322b8a2f5b2ab8ccd349641f79eda6cf4be9c8a90e882e7adac3682e2cbb2c04625c3db344d058f0ff756a3d257a9f261c0ad173a19692c1748899b09c38703babed2b241ce7295a5674561c4e022f5f1157cde80b06dc5c6109009b05357ffb680fef4b9819d0b68a1c643cf4b910c1e09d208d9d148613ede1efea5d121c1b0f73dfe45875341ffc8536e3d0e3f0025d6dcfc518d40eaa596614c1c6fcf3bf87a6639013796c15f128ed6f953f11ae2adb6dafe24dc0e7be746e5e715a7a6b1b9d5bdd7894a48b85a0054ccc716a9043199d04908c00e7493e6317a89ee003e2ab479edb98595dbb071347a6afd8724648e87d928ebc9cd38a04b612410233706aad75af5e21bb8e50936dd9668472abf07beb40489c96409300bc46a1f2fefd44d4c92610eea3daf8d1c3707758e4abd16384177faaf60375f94f97a0c342f2b79b16345ba9a46a2eb2efe9e4534fb9ae8cdbdef6493690a738b4990c0728b4dbbcca41240cb3342f1c5920b5554702dfe12068efeb20f45c9bb77ced99fc5435c4f0694d594452e3dfa0445382b6b8ddf03b30f468f8219320e9e85f5ae2bdb6853d1f04d39ca2de0e517afcd0e05012411a77069c4f8cb8a0c052fac0fdaf21b435d046fdfb4b132dec9ce370ce4280c10c06c9f59897dd95910febfc1c94d91894921ea390a4700b74e8b45ebcc0dc65dc682104631e79fa1058a3a5fbd2d82d7634de105d4206cbd3fddef17c88d085ed94df6ffbf24fc84f7aa3255387f8f3a2f306a220b7170a2ae25c3a2dbb4454e93c412a9b45576eb4624cf9a0dd161b0da0f0b5014039d2331a2efbce17193a1a51ba723f79bef1f79af6649a3c707317f4ff3581f2d6b8868823434bb3caf8b739a6d011841edf104ce59e9b96aaf1dc409310bb6492fad508694b151c6ebed834bad4f7ec9fd657a49c9ecf006697baaf72e8b9349e6b24a815f9df6c761826fd359149b8e567fabf9d8969d3de815698d7677471fc4e65fa7f83bc0d42e63ce5776c28e33a498fc24792cd9745ba78995306848992e28c81e3ed42f8884c1db5685a108f1165cf2a4055e83481a55d38bed7e12a8178c1708bfb8ec54f726b9927f927ea7452b545b63869d28dd3e34df338c25634ab31f9bd7cdb9a5858fae11baa00c0cbbccf25911d1b16fe93385438f1d728579f15d47a5ca61801971127ad2e62f5c7472f8cad1c3978f4c458bdbc982db9f7b047c554b695e7b09bbf73190d20f353273687c52d9df4a1e84f10dc75009d5ee93776f4a7dca2c0e421903b3944253519b6dd6a032bc452aa03d93d52c1a68599ed6b629488fbc1139fbf98682e14d37aba9e2caaaad5d0fea356900c03b1b90535c0c2b8a63ad3752b72220102bf9ebd8468f238d81ccc52d6482028ef3bf66a424bfeefd1f26faa8af3d74f6165cb3d43c6320023ab9fd9f77910442f4c9f4c7a2edcc6cb7e36223851757c37876f7101f51dcd6d1eed13bf218626a716c4653b8cf7f36b888e05745d4a9b7761a24ce172dc4d7aa7a0b77b33f7a48868be042bf67afda8e42980bc12c6c03f3789a98497f0d186770d65e1c67e8d33b2a44ff0467631386c412d5971fa8bda2fef8e20788b8d7bbdf30d1179521919a26f49465c4d709ad8a2f32881ca954b88a232d841d5c17293269ba11e7ff3e48ba6fabf52476c72093487b0e1c49292b9354319da5bfc94f37d52723f75f2b96dd74d2009f3b48463cc44641cdcba7bed514041cba0c9f54491c6a36e8e5df847aa996653a4c3367c721629ab70b37335c774f89d26137d2ed72ce0b7a89c3723aa795404203569c4cd428d8ee5d52f3c17ec9213402c461ddd113e065cee757e263c6c40f69d78a0c1987bb4a0ea50025c00ea5e4d0dc81ff5e5b8dc509a4c0b0eef01bd72434ba80aa21adf597694e06a276f73fe997df8754c899e8b712587770df444cd804276b272c85dfadb27cc5f6b87cb3500b958378b2a97cf4dc5aeb93bdc58b88c97a0942d7f2cafb404dfd1099311e19279a19c7a505fa21181b39d362087c5427def086010b57e48a58212266e6b55e8db876a7ae5e25cf13f19c7c31b396b25d5f7cdcad934af029b76cd5202c465bff3cb68a0a557c09ad3ece0d137726dd44a5e7fbc3c547073604ebb80bcccf1a4006c5194440405dbaf603104997c8b3bb3bba7fcf59af1f114ae9fa4a03c27d2a42d878ee0ca3bd0243eb5252637f5aef063375f9adc4e5cb823051028d5efa7be51eb1450dadd93c609fca1875fec4edbd9d97b1e085fdae7dddb13703138f46d56b0601031e9d974de43f0f359bde8f3be6dacf9464d7e57b6fb20e302a58e9d9c43268b64ca401fd618070c845150065b83b43e508bd623013997460c866c979f97992d1fdf1b4b2231503f4893e8a46162640ee7049a1f18bc11a56bdea252bf733f8a96e7b667e565f6841ae7009d60f5a0f682352cf5bd7951c8735a887e5878db116f49538c9cfe9d279a47c4c2b0ac603bc2f8038b955d1eef4204d368dd8eb1a30bf89c269e936aa2fbc6a5597ee2d7a3f16957d15a20ca2d5ad2977b9a5d43af4928ea7aacc5a2352d6f521fedb1ddf0b898a5033842ec54d08a801866b674d1a5794339fa3a8baae5d19508fa9c5934de49bf152f629bfc83e42eff9edcda764af7d27eecd4a1e7cd2657ee6db209f54aaa3e25d394fe0060f68836240ec7c8d8bb4a3a9236aa98f2c9965fad889bd1cf60a60be05f84595cf44d5bf9a8f1faae3eba81bea179c460f2fcb6985d9bd8c60f1bc5f1c5083d7a625ca6c4992e59819b14905f1da2e968d141045bd54925d2170732885e28ae103b3430d15be581f4336811eca883e2037092d7120ab6dce85a515df2eaa4f59039255bd5196d5361a2f9a4e32b185b774f03a357158373ca876ebb72a90b80890fd58eff3aeb4b5c0deada9bf60050ee5f5b5c375ec3896f8a9bbe6d35325a70b71926f7802853c28c5b9c58afef5a9bad515d79a15c010bc17bfb005c38af3c9530604bf324f86afe1d4af1c840706acecb3592223692bf7eeba41e2665aa308705977758880c890a88643aa11d2b1a9488bbe3f37ab72e52d8e1b80439fbd4202a7806e8653725c0ad3860bae593f204736a9c3b06d6e7423ce2d601c904c9d12a58ec777e0199610256d5f9209542088d4628d7347e7bd3579918d6a329654c5c1decd492f5976d4cd973841c36586dc99d69ea08a6511b8681018d9e216e81553fd6ceffb8a51d3a9a59b5d48fda6167067a8a5a2209411a7fa249bca1597c6518a2cf94e56e81658bd5fb44fbd3bd35cf304d102a70c424d61235a912418497195cc31464d92b838fbc606d70e7deeca74ffb7dbeae7d156b4f937207880a937aeb5274cda68c93092fe400663f3b274f229a9f66dc0232ee4d9a5f4784a103853ec4e82fef80baa1bcfe8c9a2f340a6f38c8f9c60ac3f998d8b1284e3dc6283c1f21aadf18a3c12b10dd2dc7d3acc1fac55ff41ee33731df953667310777edae819d985ffcdd331f3d7e5505247003fc1fb3d5fc9e6aa1a19dbdd0780932ef0db97f529facbc2f0a05bc4edde4074a589181440488f827dd5e4f72c1d6cd67fba520726abba35aeceb95e378c38ca9d55a8e37f85875a877be0d56c3f7de26f8a8b9c050d70150eb168b48f1d89f8e876cd3188bd01a54a78d2139d81d2cbfa6d057ff6e962a2c39e9588b6a72c8e2c94d49ea949e01657509de59d05dc26b2311e57572deb81f132b48334fddbf9e9cf57e8381a3f68f80a55484bdd4e37639ee7dc040b889001c91ba2f50938b02b7246121e6ff9ac83cdd1d4234b77a4dd993cdfcce08dd7fd3cce1e2e49a37fe9f67712963e23c47cd702a61575123e8e439fa16dc77ef4e97946757c43301e3e68fc61b57204c5f0fbb7b337ef764f4bc0ce0698c3a7ace79177d5ac94adbc3a1013accdae31255037be0ae9cad14076da3ec0fd6482895f9f4a73f1df7d0d53ba70ed764ac7320491cd584e2e8543cb9e8f87f49e3c31f8a896f2e7d19e222682196ee3f59411500e8d0bcd12975f964ed520fe4859ecee151b381604175ed375df355322d2e5194d05832e45e02d6eec35aeb5c7a817f7943a8895ff44951542d5093e188d20b9bc5a63661f52ccea6035db3edce143d46b6e73cdb8d4fd706ee64edd7f2d96a8768ac111ab08cb226e1b68607ec9a4b7ee737a4ea567a5953e67e524bd495fc236765120f2c73af0efefa47f9e46a28e38e4586c704ffe8e46b36d4cea958319d1b7154b9bd620eafdafc05bdd35748a4d6f225ff2eff2b7e9f05a23ef180af816e3b2574d64fab1cb0109669a2fd5b24f29be88b57099ebe426c836618bbe95ed3a653efd3467f744fed5efe1e3344029c50ad5f88cf659cf7b7b1f80c469b1e0b22975bc5b34524b4f46477ba6663e6da7f837f4dc978fddf136cd7c4882ab0231dd08a094fcb74846644cd3d9af0b97daf626bb919825b22cdefeba038c96fe16887b7477adf0c389183f5206417ae3409231655f3912440bd7911c032cd66835b27446649dd3976b86730cd1dd81e77cc620c2cea201266efed14599eecd31f334242b32ed000adc87a9405d42dd00ca348130aec1fe949ecc57d67ec79cba8c05538c4546f21953512d7aae1d7474868c79e32fa4a1b88bddffae8cfe0f2c2f166832847165ac35b2bbb6b4f7fd534ca5ff1d47bda8fc349a2bf187a4bd7b7dc14683e2205d4b29e1c917fbfee3532a504a5ba3b03e8a6aa261545ac5b6c31bb3a7364abfcfc45e3dee251f1692492642ec68dc20b93ae3622c97ff02efbfda64c065c19982a4da25e7834f8550c708c0e0c217909783edc4457454a700c5f122d9c39c805100c18c2a4e1985b7b1aee306a8e1e8bd5d3583955071df36b390c1b8d773f72af4c2566b71380997b8f66d85588bf0e8ee0f92650f4c93720060404cfe6e50495840ecb6b57c95cc8adbe4ceb38ccf1ef1cdd90abf3d1ffdfe3c8e2c8a5e33c9e3fe5f342946f095a5d2950c642f839bef0a36c506bfbabf1a56bcb9927a5a79c75524883c3ad3a0ce43cab464c7bfc46eb32b682778c2741c61e821208ba7346cc6407230666b2cc72d2b92c1f747de294859211ba107c2913c509de8f71e735de555e1de65a934d166023183381424f9797aa6f78d4a451682b29f035133303b3e5310ba2c195d7c10fe2839f6af8a215a693aebfee6811b20a4ec9c58a70a0f84378bb3dfb26d019c0994485aadb1de862608f1f571a819f5db7bd06c5bee4d770da250381fbcb0e6f5d6dd4dd9e88223ea129ae8dc1760d82cf740c7f775a77a568d786694f929e474e05493f4a4e286066a0287cb8b0e98756dc1f4db47c5297a8076ff65cb32583a65c07c70b2d0e4b96ec42910186703f177efa51af307f76d9f3c1de4d1e5e97a5b5702d287a7607e44fcc540a182ed6531d337f4a00608f67fe6da3a6c4980dbfb4f76ad6e9acb6f57ced8e547687de3a7af81c72968c27a84c314aacc63d8d181daec1a88de74d98f34a0d786dd3b7c7079aaad19247c9ddb461677b6dc9b8004aedae0d638f570ef2fbd885b78c4b1d5c23d827bf813ec95ad5ce87c51cca18991f35a5390432b0b727ac7a45836dd09922c0f5a46d0b73783cb2048809c7ba2bfbad35286c76efab8338bc4db18ccc9d2d2f3d5bc389a79dee01046cc1e03375b09e33096dda1e40c2c8caba90ace5f4c1af81aae93c15978cbac2073c6022d5804fd3f54961f23d3cb37ae0a63346e62691b7a5da596efcf806fc04598d852f7ab856f3e116a5fe7037edf8851888e72b588a6bca668bae0d3f90ee670018649a02e08b27260f2c44d780082b721e3f43d6f2fb877298bc60d17714df3cb24cde64c44e66954c9dd2d48c5465bb672ead855bc2e0fc6fdbf9c1115813950733c6fed9fa3a75b10ed8cb2d53ae2f2e4c4588e65b0fd1d3ffc748017bcd85d4776eb1c1a913b7e4230f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
