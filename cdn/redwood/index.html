<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ff244e66afe98621ac1658132a8b307ccdce529f45cde000d19e3b9bf50dbb6ec0642c86756206208b1fbcd09e9e95766e96128ed8100db64d880a4047a24a3b805742bdaf867aee7ee8ebb1524e6e547555db5e47a859d4bf3cc746d19ad28e7c2413cd50e7835c184faa775bb77b646823af40a3464b65846db83b42dbe9691f3499d1e2a559ee48e954c7b7bcb5e5d540d9d12a443a15153ccba9b38988bc90a650c08a3d92ccfe32470d3cb80b646b91487cc0315779a3ebf4d3cee551d7bf7982988759e0f35b93d8c11da928aba1389adf94fbdf9def111f1a8280c12879d6ae6a42e3d3d1e77765119cb63c61b12befc076807c9f3dcf16cacee6261135c852fba070d0a2606d2e8a562cf96ba505b81b42e816f4b7b9d0d9f2a23f2e6c9dd1cdf53ad623ef0b3ac73548496cf1bb2a1410281a3404db713c75a1d6997cd8082de28feb0e2d6f9748e0fd04e86ef21455beae1ddfbd426ac73c61663ac5f88f2cc2154a5d50d4992653135f604602e3d3c45618674dccec540b85041cb40c00a7339068c9e5fc7ea6d4e30a32a237ce5838e5d4b1824e327e3961a1f5f7bbc33797b8befac855622082c7b4a7d0c04503dc2c9023d08f9d73fe45fd0fb027d6a95898b0c28289779aeb6340d927ade21ee0e6c715918ad320f0eba4df33cbb8a07671c2f22168284b6b7e7ce4f4e3ac226f1be173f75c837113fb303879d2871c948fcfb225f3b32744ec33561dbe54de70a84fcdef77629d2901e9de53e8fdb84ea58c6ba88a902c6fbe544f9ec65506fa959858fc5391f49586fc72c3badb88383206b67b19b97fdcbe565d4a9fdfb9f0bd0708e2965d413a3a21cad948ac576449b027dc4322873d5e35ccca1c9b616ee1b0b12137cc7762c3c5f0c23ff8dc9484cb459788c2f61e5aa3d526fa3ac6eb2fa7a383702ff41cb91767f7b4c73e9f3d6422ac976072066af87af2f0b531d8bec11dc31bbe832016c416f42da0817c2b26dc158f530f1386cd51c3967967d13ae386f427a3c07b2350a272ea78633d087df25cc54e65d0d6c6b87646ff77d8a03f4515d3da2eba3df989e7201b354df4f01627fc7b2273a273861658011f176a39e840157d2d320bc5b92cc4ea3ee56e7ea016c117757de0ca27586688aa03f695bab44557c6461a87cff7a2829522f7a625b84c506411aacd51f0a84e70e1c8002dd85791c4f34bd36d6d95adc923f9a1efd45b73c6c7814fe62921faca13c156879b037b1f1ce3665f50e92cc145405e4590c9bf00669b10c3cc27d30740c39019bc4c2d339ade8d206492d1c801b2d514ecd2d20f99e1332f20ce5f8dc23e48d4ddafe823eb8ccca6256d66b0a54925b7a42ebeef022ab9786ff8c900b8eb9a9f0e540c3f720953b3e7e5124d853b0c2e6ed18bdece7f9d7915a44879f8f561f41c84b2f384a8224b89919f0bbddc981c2e29de661940a88beaa196ce6a302432ee1861d041fc76b27052ed95ca2658b34a30933b1867008d5d336aa419df583efeb3b3acf11840e93de037aa03935bd2df761ef995980c0e82190943642e2ab4665ce3e9866ccd27b521cf2fd6af06eeb4305a97b88f71f1568cfc640af07b779c00fe375bc5b6ebf44d0e35f6501ae6cd960c0a2758df7624df7ad8cf1145835e5138cfbabb66561dfb657f8d48dd3ea422ec35e7d408d7717dae9300d7cd01649f6a4a246a32e9cd10a1c654ee7ee1e636bc2e0432f0ed9aef84422eb23231cc334c01e64c4613b1f21b54468ff8873c01332f7c23a8f91ac8f5413542ff0a71f25c062c4749b098d5ce9c72900b9405d09680972e473318d74fb46f3bb1d71cf4356a629dffab2397378dd212b6d368a0518da0c5606af0fd21edf9fc6de007c794684107112efea489e12e77c36d8442b6d24e03cacc558170a0a6e783a32c9e869646d6509cb8e618b99ed9ef32603d1b2619e0eefe9d95a2603032ec8e34853ec1d9c04cc3890a00bf13f512438185ebfec5f29dec47119f1d6d7a33a2565b209c5372aa114f75dd9360dac5c61b2c44c5c1955dedfba5ef1408bb897907e2b3db988ff523192104183460b2c0d844b82996aa842dff0c2b4bfaf1138c74d5401e7083c11d6a9d0d4a47b3cf22b14b0139505d55643186dca4e764194fceb793ea9299ae07fb13aabcfe64803e63975db71c67644d21d874f5990f67eb2119d8882cc78750a46d4b6e0d19a2868477b1467809491f9e0fabcea8d1590752ea64a6531e5b2f2a5b6befaad969a1327fae69fc19b7ab208c907caa975107adf3a69ad024f357f1773bf7aba0e35d5605b5013f31af6946dced5f97fa80a64e87e8560ddcd5fd8b265cb6049dd763e487c2811657bf265abbdb9cd99259d5fa307ef04cebac9597bfce16ea79b0d3d9ef484a35afbbb1ee60fa27db23e61d944aebb49cb2f949cf1c19fe5dd0739cfe13e516a34f604f39007c8e175527709521ae3a4d356ea683c4fdcd5984226de04850c537129a8c043099d6440a4a4bd738fcc15d7b5418f07deaea5e604000dde5ba5b6591cd6b4089c96833fc0a446c1152a51e30f9fb3d30a807410e79dc806b45f8e5f0426a425d7b1bed6da84927fdd7d5a05fbfe44c2c5d210e8103b3163e9756ee15022f40ea70494c33e60a9718d4c8766cab490b133e0841e9051b4158bf92ba9dc239dfcda1ff78225c0e5234be89db25a8b3a53a2fb4715f19d27d7ce73098c689badf01d7199b2b4aedcd4d9fe8ff9151145f0fe2edea6dfc9d5e52580380c5eaa836c84d4f6c32a94488de7eaa3aadbb3d232ec7bc102e761197b90a6405531f59ec9880d6371a89dabe2d75bf8b714a656711a858bc99141b317b8bc25bc20d5c60af6c1ace067afec15fcea0621578f45698018838b116b6b3c8d76854bc109a96f379acbd8a37b6d9590cfb24dfa411975b61c8ee599dcee732a410f3795afd482a76a9f2c4c502276fba16a12d373d600fba36590540001cac52eb06e27fe05646982edd8103314bd80a664f205f65f9c0fbfdeef23cba57685f7adef7d967509ca7b04bbd067a428e1e5313ee2bbd9912513bcecb1e8103c168bd1ab22b10ec183440f7d5cfc73aa38878ee832fcec1a56a98f1b2d202537ebbb799d8bc0dd0b83a94f93bcb7d8c601ab0a839b947f929c3edf0120819750595ffbea6eda908c9315bf36387cf01df0805833b1e4a46a85a53a5b2c99ac63cc2a2377a6b8402b260cda67166c15ab5d22fc031bb6edfbaa460376e2d080452de9d3065ffb6fc7fe8a60d391bfcfa1bc0030c1763f1be497884b5a183adb6eb6f9bd847d294e52237b20af3cbb55151043cb6ea2b8582c3d76fb1c60ef8e91f7973e0fd16c1b5d643557c6fe7d9d2fcdfa838b1262913bf87d4da3e9c5538d5a34fb6634b858f42842b17c18ec7a692b24c3c97d03706827394e343157322c7d304a34bafd2b9ee8b9d73f10e17634847634e97123b27c13039e766d193efda276bf948292c2d5041530a684a3825fdb85b792ab728bdeba3281000e01eca02f78dabab639e6747d60e3ad94b3b3ca1edf0013ce50f5feb1b6df08a84fd270ba88855b2e9336f427c3486c5a6af277c2919c9dc7e40707c1e691db457e0d1a4ec252399f8bd5d2eb80edf7266c6268ed3450d7b53bf4e5575005523a93ff6680af6b0339a99b5ea58d3c7950bab77dd3ff57f84598947644f2f35e4e78002506e49a95e111a9b9b4b26b6cdbf55d98a551ad480f758758ed8b8f55ccf2ecfaa6b51db9e7778381f1388ef16074d4ceba7408bb493306c2edd862e0f1c56bb7aa08464f5a694f7c0c66639925a13c6af6279007409c8250be53dbee2dc61944b53785b544280f5828b2f9e88c53a5fa56d50bf6689f35b6c860b71f5c24ae1bed2b5929123da28ea21047c0ac55e7b0473ba1df2b93464635505680c2ad867debff0987c98a62d6f2992c73555c05e080bedcd99baa4259c05d524f0c0fe543816a62c14e5f9dfc9877e18316c49b1c958f0df3a428f6ae7e348233160207208ada9f4ea1d285c57dbe5335b4b2f8dc47270006f16b8ea443f6328fd3cdb211e49f39259f4ab9598182ca358dd3a6944b6eb7c220fbe8b7d71f4053524a82ef94e1c834be2c9df4c6b4588f56e05658892a19272d9c35cfb5f4eb59a2480102a3ece1ae05f28b081354cf3deeda82a90a83d68ecc2de165959e8bc5e12e5f96d6a6e8d79169c725ca5d1c56d8906fd2b5b5478abebec04d5339c7778d3d75430bc834d2dfb064be466ed5a5898bfa253a7e55f756b568ab58e4ec6f598bfc10802cbb4c26393ab2e958b6a4a0ad32967c3b753cffe27ec778325eec3179a0a4a187885f30d793053388cd320e927e20dd3f6c7a005ba3800d7052f551caa652e26fa439a0e313ca63551b57f547201386051e4804e6eca445b576b28a36b30ebfe1f9b6e3ea94924d06d56cde2e71d5783d61f2e7bf030a7bfd40da7330f53a9f1ab9e4b7bbc77f8f9cdc01a870b033ccbcef865ced07a7d1e1e7d0c3d31af5983183a6781ec96ff6f604f496f46839130fe84036eacefa438024fbc023b3a6f28e527420677e0bb65de85e737b93df832dd1eabbd5199d0721d66a8b69f61eb951c35e6c3613c984b8163361f6d0b680676c332ead75ea1886611101578ae5096ae5f5fa8196de9832a1530a30bb7f990030557fd64dc9a1e7ecadf8de77104187efbe61e840304705ec15d553d5ef6754a74faf58a52a3f32bd6052e8f1a9e25d78e3c6b7c9751029a4a1a296b42ab8add7989e111b0a5d03a119b4c667d03ebc92c27793029f8e2cf83369fa3a484772b1f401a529566470d1fcb6a27a16852dbb5b19b634c88fd4fe68efa29b0c8bff0d85fc0d20c7689d1fe043a6b354ae0eede34ea793d30f77cc2af812459d04638538d5cbe6a8965448a8ffb604dd574e3e6afa6aaea389408d3667f6f36dbf7a72e8a433b5a0d86a7bfffc5196efab37046c5d8a919411e9b8b86bb7e9669b4243fe1db9185e062ab6fb3da48f42e6eb50f5228f8853175708042119b50c8a30bbb16367f9ac3ee9eff2e941391ad2dccf8db50d752c8fe7bd6b4eb191df036bc736aa353e16057f0a3ca317de1fa8289b5ffd68bc36edf1782e3f985ae2134b80a52d42f3050f2e49eabe48cbea2b3a0f755d31e2ae6215c0e0dfca6235ff08ff6b6bc46936c6778167a593048ffcb494257088076e8d4cc1321436c2cb430196b26650cbf782dd4fd40bc7c43ae1d1628be6e01606b41b68db4f30945db8fb3abfefac2540488a07926ab1996f54b565ed32b1ecfbac859d12b991d943b7d9953e0954b84a0a38cf904506cb5fec8d9055e9684eee4b7d78cfc2cd433f7086866c977c027faf00ed13a08dab000311f5feeb79a5f06e583f49b54f7912c6e91bfbba7d097f694180f0351a28264107ad7c0bb3755311cc098839876732aa338bafaf3f1d9880b87209cdec0aacf64694b1eea0739bede5a5e26d8cbedee29f910fdb1179d6f38aeb0bc5baaeabd0cee713f70d0e183a3a00b79618d40c6c1750636be495da6b0ec280b7c88ebe979619c1faf2abb0508e21ed06bf898dc652fcf42194a4475e107f828ffe475db2d2415b3df4149b6e82cd4b251001f024d97d2abcb7d0ae38430ec76adbf755eb879c84d1ddaaf76b0cf2af61b856fe6f67af6e9b2ea3e2884fe5254f3906433d9213853dd4f07e883fecdd96f58a2d8ec742c965b172284b3aed056206d018c681c523ddc51485ade7f807d03f980d3d2888cea05b7c24fbd748c03a98f9ddc0bb1b17a384e415856bf7a7469a31d3b5143c1abe088af21ecaaa70f9e0d0649449d60888e7c6d9ee1bae51dcd833a0042f0a285e026e5f968704fb7f71333b7c33b24b3eaa62013d3ba4f2d508e8305ea72fc1acf99179e1b97a6c6451909497b8be8c2dab44ba9016c2a66ae377e0a29b5b374b4cb334faf7f7edea34c636f4cc4f372fa3f6a61201ea1c2fc7bd42fa5dc212d451dc33edd28ba426462c96e2c80cb1160d709c79491f49775b1bc8a2ba989a6e11c7d29dd5a255d45f7fccf12c8e5fd1d1115f17542985d6283f99f675c794d012f1413125e7cc0b89e9ac65da9028fac9f502ce85cbfce89acc1da9af3f64f38344e34165c4c0b9bf19dfe96bee59cfc71b390ff5eb01d961bfbbde4a3ccbcd7203598fd5abf0aa55da33b2d53171848153b7fd035fb3ffeb9cf7b229f043a49bd7623ed80db3f3e363ebc0174634e8a97cc298547437a46b567670679b38bc6073192c42b5e7310d3369a372ba13b2ccacdbd71d7dc90329edd7f673a413f5df36a01c60b2cb9b882988c8e4f6cdac3950fd925c1879d309f8e54257b5ce678c202deda48593337c8bca90a84a9bc7da27d90b17089d65eab80ebe4faece0ebdd7e6730149b4751b45210d5a56462ba3a48c7aa6fa6391a424b39cb073c4d6160e3ccde0e8ac053bdddef25842e913ed5d4d4b1a1dc35aedf2bcff80f373f76e7a1221e002e7848f1fbbfa2141b973f1e24d92c2c57fbb7e20c4930be1318d3bcd0ccafe89495ef618f536c6a078e416c31062c87246d9cab777f35b91bd7e9563798154cea154a666048af3194ad8048d4b43f39ebca9bd77703f109aba114f26537efc3c9604a94fb76ab4578ae96a5564fed0c1e8971ba24e99cd935ce217910950f5f099fd6db5e68d6e0b3bc01060941c99be0bf38b9b99ab20cad59037409e6238eae87fca7ac4404cb223046612b7cd906e708ef28d4c87974b6afb17f5c1fc36d4502122f7827527914bacf964535b41b02a381f6a37be3592910ab7914446714f64693b725c2eedbb58ff6caddbf99534154391a7608fbf19bb55d4bb3b21137e9ed9d57f877eeb46b3718352a1e07be2dcc35a6af84efaf9dcd1b1853573a4686da8d837bf98095230a1da5a96bed062d8d28ace052d122b5639d70017cf863546c7cc96861aa3f0c9134403d24fc952be1af6fb30277d2bb6610dc6566d9d8facd84a6d8b259045509158bee86d2e5cdf961d443268b2a808c53ae08b96850f01a57ba20d13c2d77a91bba77c55f2d47e3a5bc4ca9efb0c92325217fc557b6ad6c398f46d9b1552d6bd2c7cdf223501eaa261ea90ac83e4354bd0e51a0fdcfc887e9b1586dfc5861297ce7c445d4cf48c0c6e057ce701170705d80721b1231a6d119cf9f9303105ea9a43c16803a8cc142d81bb9d5163bfb876dc9c4e9e985e1dd0105893e431b8772fde0c9a3fff2c339ee5fb0dc314c5b972a2214f3bc6ae39a136c49487cf68df3bd8c1b772de2a447f434f38178f58eea7d151060c9804a35e00892dc0f06fcc735976f11085cd1662bd6540aa22eb76dc536ede76d6f1dcbb4c1bb82e15417388715956e11b5993babc62cf4d6ba37a1b8179b2984b1cdc115c378e6263bf88497930770256c7628b6246753c3a83f6a59d3ecc5a30d32d383c92fb1c4d701923285edf2cc66b6023c36b1ed4bb91dcc5b397de59e1190a009e6ab44cf483f11f8718a7e6cce95abb4b3fb249e75c26a45d25f3369c67e03094c8a4cf7de3cd5cbb03e16b9ed2a950946aaadc71b79a660febd3b459034531748000d0a8e3a0ef87a07b648d565da3e69fa487cd2dad3cb5189cf7978e12baaa369bdac4b2f64f344a1a9aafc564bb1af2e5967b0c05785874971db1281db5f3937f83a0ad938a97b0bf054f79ac31c9515cb7941fc0ad98d0418707a524fee6b33bb0d8661880442bf18e8d70a1dd0c9a15813de703c3b5f076df64025853ee6e465b8f9fb85076128537c63ad3c71c0fb11c83c7af3a698cc21c79e5492d7cbc552e1d476cef8374867142aec4876cef70b75e3b6496dd4505345f4752e537aec326b092c06f31fb3a208aaa33e7961145adf1165528af9f051333bfc7b3909987d0158f6c39de84f06f657c1d9ab2c78bc5621b6b5ccf1b04484837e3be08b5fe25a7eda2ac588ad407aa7e2558899dd072d7b4d5a1d4bb3572afa459de6fbc90261461186e93fb6e1e2fb8d778433faec03c4dadc45057f9f8bb975da50d8531f9895d17e28c300870a2d2137b2964f236f2d491b665ef20c4d23fcc96052eff8f7344910d7a59918c6dd042cbcc0103527b48d745dc541613ec0e0a4e3b6fa3dc7e9efb3cd2f2df46b25ccf8823580a6eb3fbee86171bdf99ed9f74b4a689c97b01fe27f9b7f4c8373c92f4d15ade709d2075ef4bced09ad75c540a95791b4b0363ebdfc96d59948a7d36ec5c9909bcfa82b2d7aa2f478cd70123288bd8ba28ffca9fe60f668cede99d69c4c7d9821ee3329f044f093e8ee8d8148fd11be45c2f41c6003b860b119723f7ed740ee923f11179b7faa366a6121c5865c6d615ad042fadf795a23fce6993db4171c1e774a9efc39ac795a747ecfeee8e063536745a44afe4e8383febb50688313035ba80f1b5504942c31aa4da16ca519fbf83e1284dc2cd7676a694c847504c59b0d3dd149d6d04ad5bf1759b4b0b11c5336a6c9fa5c459827daab2f578b5349e1868b823baa9d87cc734307ed66c0365964db5333f1f47de71f0b6b429ddf81dadf51c7e86e47c09a83f382d12464c36770426b3ed631264eefb6cc9fee8e7b2d0f37c6f7b07cd3e969feffed2ca22342f7922497513085702a037fa89147af61a2d742a4041d2a1e96150456c05d2e6aafc23b78cc8d1c2359e5f14c20be35947ec836e9a3c2c4899409aefb068552df29d91378af60a4688a6eb73e5357b73ee32be6d686090c05c0eb1f15418e9dd186c0597f94dcbaa533351807bc2f5f82940784bb9aa2085986002a4587b3916433fade69a02948d7b978101318af24c6ee38397a352764d5afc7e945fd7b2d02b0e64ed96ea0eddab9b2441a5caf9e8996f629b6139371ad4535cda1c52ad96701b155eafaa5cf3118ceb7488ee20cf2448d95a5e35095630770bac00cf9293e7cfb24e2c2dac23c4f161756c9ca374ceec34e06cdb2790de37134a3b8559b32e1df3b8cb0b695d55d9fe1060406cf8367a8e4fab7760ae445272856558c5fa29febdc68effb4d33a6874db8eb163c85ca3591557346f428d63ca185d86a56a5090321bb461a735307601f2394ea97c82ebd94890d1345729b623314bae700438525e6619715c2bc63f23f3f96085b8816c67e09019ad4ab56048181d8db2065f21b1f3fbea6a3a8049525befcc908099f6f08c70d10cbcb2f5beb3006ba973d671220581c72d7ef875081f3554ce7ed19e8a793c64949c7ebe8f564ca0482dad1871d7bf809dbf6e6d9af7bb2b391289105a421d4bc222240dc59ee7268252a47f59d67615f4bc7e3c3e7abdeb543cc3493a51db49dcbaf440c002503b514b705c31ec939f52b6b52105228477dc6146becf9aba3eb6f620905653b851f7cfbead0aebc9821263d11fba13a3f2ccf14960dd18417760975107f0c420a14da54c55ec211b14833cf2ac60161f97db7f227f1e3a9a0c383270fa4e3c9441c83da1dc12ffea0bb9f668ea7b725a1b19b7ee60f0655d35900f48a3eeb48813c1d4e54588d197e519b7a2fadbfd6060e698f8cc4062f672986f28d91d0280ac599ab7ec265a55c0dee08445ac8f3d62867d3138bdea9a8db3e517fad5bb1f0c8747a7d6348b5e44ce098b693a25cb0385789ece60fb640acaa945b059fbed2eaba7d7060ca518fbdf5dcab57ddd0928f553912d0fbed0ca2ce76abe2960edea0591a5df60b69edab9c44a7aaf4a75ff48f952f4d418eb503560cf67a7bf7a8af0b0060b1f69091d0662a75a8ae794a41344ec6831f214da7cb80e4c5c6b44b50ca80954fb871bf88d44db7a728e23101d88355b0d84b75ed4cc0929a86c775fc9f10cffd05001b91b304d66fc48524232d40db90863a73ee9ea17902ac061554910f64fae10fe5d7153d3f34f46be737ad5735d8607f4526b2d0045ccb9b5f2c24f4ff72382cd579a6647d84e1084de2a7bfe906758be6d4ed40b0fa79cb566bb2917fe70721436974514df7a3ddc37d84682bd5c88142ca0b6c942e990ce1f2ff78a1ec0730da89015cbd2a044db27f87afbf12d5adac3f6e6121873cb0e33843d4bd54659fb9250127ba0fad11a992be9baf51fc1a898c7d1830ac918d72688700fc182520e0b33f50d5251d02c202a4287d6d988b582707e6bfac7cc61b63937760c226a06f9c9fb91196a8cbbcff7e9b9f80730117b2854efc65d1305066e64fab5f0ff2ec4d77da688d98bc05d9c1b2804efb31f6e7014b7a8c0abb52a10795fefae079ae4d413fa94afd225f67e2736d6917f961e97e7877d2ab2f0c430ee56c4a8dbb1c8c21fac578dcc1041d4be0ef3d4ff26cbd1b000e2973602ebff1a4969f675a21b76181e40868dabbc21b7425b0b2e36a0706acae53eead89b3178d9505a6e00f8a996064f5d6e841a9b64e576423c76efe1bfbf6eaf76c617809d85cfa6bdd0f616b0ad96faee87cee27caaaf1f860d4d5abcce4260eb03121a7efd292fa4054a0147eb799cb06dd9a21777ddc7a95e26cefaa0ebdc7bc6bfc3a734b5f23f4503449ea90606ebbff9700af010d2734a51256e89ba5a09c34287ad4483864863922e7e12b8ecc15613095f35b2dbb66b68d90e6ee13b93ed0d012d1916164dce5ef2732d1a90006dac029e7de8d59878e382ba9fe2165592abc67e166cadb58c42b420a1bed7b08f58f7384b79be1e545b0595154b61d1a2ac6fd988b0f0e87afa0fe1331eea6942648946bbbe7d49591e199280976fa048a898cf8fd86452c2d9537f94548cff5d5eb650ac957436c0bce0fd2a95cbd7601696e0dfff5d20f6b375337d27d24efd6f89837b483f8d622392999e7ce562624afb61e1caae595afec099abde37b6fcd65d84f7d7048e3b7c94a648453b1aac4e72c179109be49c452d9f03f6064be54f00d43e74d840e6600a701d31ae69c468035ad7a8f8ebfebb625a9a9eb7957a3291bf5338853e765e106f15eebefb0e9d65327a486c73ab425fec118512579a67363626ad04fbf1985109e948d8b2f7f1158371bf4dc936ea5482813eba762cdf9e1f297f650b9fa2371d6594434635b84f421d02957124c5cff01d1a24726da0ef6ea5f20c9dc2e2099d2b2a4c5fd607a687224d3e30f4818d6b20201cba79527303792b5123ad40e171d93550aafe294a0cfe609896a8747aded9775712c6f6b8c16ff7c8164e0c4fb8838d9956bba56889622163a5579ded5aff1ee8d32fc4dbf47aafb1c1bfe792c5d1b6b3bdc1a987243bd09a63bff62a4e4c8b1d2295b0365621bae5304f32c9739d9d46d702d598fd04bb5c8d0afa8212b3d2c7e429faa0d6d81abaf55dfcd98af2ed40b729ae4c61e3eecb77b1b117d8968d3f7b8a64f45f824d72dbf7b29e61bac49592bb4e463be898459fbc73172da05415f7b01b885c652d11db712eaeb437c7ef79ca1a8204a0a6c9d0ab4bea66830a5d64d621ada34fa9769a5b037ab0c9d3b46af10b86941ec5d761910467129921a2e6de7a24f8cfcb52cd1455ffc2033702ee1a973e4772d9e149f1f2190fa0924c75f6449ea19435b7a92b292b228f691a46731ac894697cc454c90fb9984b1e4691732789df433b8cbb7133df4e9341f523ae15d634dc6c369476c84fb08818b56aac295bbcde1da268d65ffb15971311137cd56584e339741ae738d8dfce4f23800ef845d9ee1345bcbc811f3234737323accecd4138b3766d298ac089b6b949cf087d429d5bb5ea5381a0832e7e59acae20c1080b620451120cd681fced13f9d426bf24df013f2950303e49321d7dcf648fd36546b46331277d1f50d8e21735ad4ce1b3777dc392ca60fa5c69786d4384270a3345ea54c2ac45c01690e4b710c4576e746bc8f5d5f5b0074f6693e878f4d10365249d7fb14ccb4f95a973a735939aba63f9fd4c11d2224a49bf0043e48bf99d0b5d26b5cc5d646d01a665149732c8c4faccb89a1fea977435d96ae2039db0c7c933e6fd588798fd85b61c7336efd610324178d17105dd47c600e9a706b89f6671e49e92fa0b69c081dc1e2e5bbe0ee16ac1b7aa81a139505d1be89ea8bb3bc32acc8c0215236117894c9215c34fbc29a452a95577971a6e2f4117454afc12bdcd927ae7d2faac5c82a6628c8f4e48e48861417d7eb0a15582bbe41b7087069a2fdcc0d32e5d6ac7fa994ad0fd1db6086662896734f8ab8ecf42ea3b2deba7d547cb58da7fccc29e5798cd70b19989038cddc1d1f22de529125682f67123b5c8f7bc2c80cd2308fe2c23b8c6588bf63d534d75b0535edf368e460709ef0b86c70caa7003733788fafb3f3e119277e9a001cfd2e551c4da5bf6317091f70099e908f848dfcf06daf7280421a7ef36cbfd626a5f2f914b0fb7c486d46be7a4ede2a3a249d62a7f8ee5cb751687b8853e1c27b0ef41a205a4262565dc72db7786754d3c5511f8bf5e994aac41fa7ecff25902aa82742a31f99fbfd959ba427352d63078a9f42bef9c3c0376ebec1b3e31a710c5ba18478f182ee4b8236e186b0dea12926fc4153c1f3dce6123f96e6e65a5c3e5d9bc2fd7e2a2c76f44556b393174ea31a539bae99e5d6f58eded2558d5954a870deb2d7c28f45c6e003541948009168cd548f65ed2e402999dcb8e9e07a40c18593b33ae018e68f5ba37d23b493ac752b63aff6ec818164b11249e070dca4bfb8a2a5a3a587e0d1682f0702f3134762406c19a09771e9b3a29c108ce542b020cc7d2c164ea68bfc6c44696bae367debae3dbcb2a226851f708fd5e9fe0c2eb2a8a3b522089a2f3b20dc8bb24d8e5c3253838e0a7e3e17e38b7afd418baa362521eed8699c4d43c6f0283d84776baf8687816294ed8f2ca3ded00c84d8fae95f22cffe72743f6456e2576c5eee8ffd6c2fcc8a57db45d609080c1c227b43e11dd7c60d6c0fc5e65a89d62996360374ae453f714a77db00aa7a876a3f79a8b18fd7f870412645ca85638eff7cbb3cc967ed138fad9178edda6d7b0180bb1ac6148c290d5dd1505e55b59ebde946c4d70413b9a3e1733aeb7b81380e3fb69f05e35d770b12ca499f426f699b160269073fc520ab155913807048c0c8943dce28d6192365c9834b289e050d28cd59f5ad798a5ad27f126ea13ec602935bd6b9c7646ed250436300957bc7ed9c9f7de87f7f142a277366349ca1473ee847a990f58371372b987dc23c59a5837d18f5b58b40689e5f636fce10cccd1f735e94fe2c3169b4cd480371e25f59f6c9e21ba5441dd32d01195a8221d9579d9d3f5951a13670ea72ce42e64aa745712c53a64131edf18d6e819f14d4e4391fae9a17d3547db92f8c0df8675add0addaf6b9bff34075179ac0fbcc9980e80fd599ce427b497568d10dbc433487a7b2d922d57e1914ee75dcb220e73910839db2a2d49c5875d18920a1dc8b3670590fd4e26e5b9c04e3d5a0971be5c9cda4b3bd21a2f3ed53f3f6040138e1f9f02ab1b699714c4b48907eaf6e969c96f04e8ae1e225f4569051c02573292ebae6bcdc3a12e24ba26540e822ab6c0676df32fcb08c42f3a811d6a426e598d51af17d3f9a03b038b42c6daeaf6ca4270f8380da80d97a111cf8d92f414a965717129c5b213ad8206b4c56aeb8abc85a2d40d107ec083cb9ba4bc7a5e291af6986a66aa2d7dfb34095cd854559e8c23f7519bea61ff67d8d2672bae2b44e0dc5c6582171ff079ce548d688499a5c25b8a51b970b362052de1eb62e7c870bf452cc7c9b0fb11a1a085f3d74b979f4b393fe4ceb04e053930c992414492afe8d337315eb6c4b7c621e492aa5d137c76ec689dd25f1cb3c352391c378df280449b48c198d8e15829f74bbd871455fde34aa7ccd6dce5b0cebb2d23e3c6236ffe029ee00b498d69e4738e35043fdfa87de21ecbf5d33238f8b56abd6084e47a02ae0178ff51f9bad69f09966a5e92b910409dace4aef81715bb4934beb6130633f6363afb10fbd86632e9688fa1801f8a0e5bce9874bd436234660d2722bbc7ab15ec79ac59b584eb63b3bca0c68316456d524a5c7507bb294abc753ccd7b1b1878ad0966f84edbc7126d340c734f867cddf5233594b16f2d857a16c0fd720b65e754140b9d1a34f45a3670274711c0edd0179195d29bcafbbf7f74349087fa83eafcdbcd8c5bdf85a4cd23ceb395f4054fb405e40aebf0c8d0dca4a59326c8cae6ceb58c60d09d985b54069d561f4636e91eb3c8784c584a7186a660104fc300e9884af789efd6452c0d2fb28a570b5e2f826134865e29eb30f8745554dae39c52c60867326fcab9aca538a653340af6a6e4564ae3ce81062dafc18be3932a7d87da3bc2608f9707bcb62f48166a6e257acfc8b88fd79322d44fa018cf0c9df74e25ad81bb4cb0dbcabcff8c6484e50525bd9e2fbd87df650ef7a67173047d2712c338135a9637d630da7fca2405552c5cba8f0c14b001f9177d2bff865559ee38aeb53de2a9759a43626fdef3cd37b85cdfc4400cf21fc31ccfad37e585e82dc0fc75517835c9446c5656b0bb0ecb84331be41174a626a006ee2186d65975c07701450ca8540e1b4c15798571b8a0fcc27c263ed5d822d67ada92483759e0da9802fa9f30491905e5b6963725118f7e54d7507f1b39fc6a246bdbc8b42f0c2dfa9c8bfd5cd5d5f82703395181a1f188504616bb32c5ecf3dc3839431c01aac4d8322e91ed54cdde0d9a7a2bcc96b82188ecf50857120e268b308ec8af21e8ad494caa36a71ddc7428feb1e1c73918fea38675b19f5a6bb26fe80c55791d1e573108bb3f0cae4404095bac0638f03509bbde6d1e4d064863ae70dd14c3c8b15d8857575c321e0185f042112fdd682fe85535a2dff9a05913e3d0b663f4de45b734edf49b8f95f86d9a734793582c525c487653f9bf8dcb10070cd40d29999830726d4fbf76f9d4d30ffaffbc414966448d712cc1c3c34e771efc4abb39cbbd5f45775e9de813e775ff2ed5a18456bff58e193edef65d34eb4ec31d0de915a1c17b0e98a496875daa9985904058e388fb2b77630026994c4032364a96184916c1a45669aa53f976128b0e63bac646ad7af115bc375b694698a0a0980815c49c6a01c00448a5c1d23a6edbf312baab4d09ba6a48b2992677442dfca57d9f948a2a02d714ab63ad885783b5b8de913aaaeebc1aa75fbcd72b09c17fd999e24732d123b598b12b8467f9bf3ec5d5c94a9a6a8f250df04a5592000eda072587429c849d971004485755e3b7aa885428ce9e8d3bac66a82899238c5a6b9730770f3c23473c5eaa7c2243dbaad5fc03e225657efac04d7b8ecb09755d263e9bbd7be6dfc97ee3c3a0a0d5d9c429042b8c069111fefe9c975f4b049287b7f3c6eb9d9125794fd1c74d7d11cd54cd75bdc6110fe0b36c2084e08007556385030b29671409d1607adf4c618494b9c30a7f2d3fee7e8deab1a3b5a8c44b14232dc5e53c5e9de172162137bb39df511f1182b6aecc18cf941d941eec7e2d2a040f4655378bfdd09bc36aaa8ab0a42466e3df52f2e6460d2dd2191ca7f07b8b3e3683f3707b5d2c87dc1f1733e543cdd7d784564e2a8473762a6108c122b466d55182271925259a404ec8db21fa16348e75778e9ea39ab5aed454375a7b7607a21c0d8af36a23a74a2ea849a229127df5fbbe512995479c8d0f5d81d77121ad92659345c5d4a23a56dac8ca59f8d3d74ba6d126a5650dd784731b60559ede17269ec047eac7b5faa424b220ac92baf884139804b491507043f1ce1210adcfe4a151c495f5ab27dfc72bc43424948fcd19f6529f629cd130b83f1d0ced71b7591824a9b515fa90fe36b8636995b775d0313faa1e787d672d3c25d96a3e3c4ef8ed9559334d4486076b10b312089b3302a2467ae3da9d02bad936a705fdb39bb7cf4a3cd0f22cce025cc312a04c76925e86886160c01f6085a701faa262506c6f05dcfc721526aa80641b937bb263fed9facb6cbe6307aed3062c3b0967f955922ac522a1eede86a74014bd7d2db56b205a1e658d272287d2c0a55b873282e4c0095047065289f23702d171ae0965aa081a91f6c147ee8e7282197b819680907305b681414359259b9ddc09c2527d3003fbd69a2e3976e33bf255abf6e5ea658c48b92b71d6b4005e054af8e07c23aa32679e9ce70d5c7b70efa0689b52d378d87253de3f9567d63d8b3a9ce6e92b2729fda155562a97f4a4ea637fb99db9ec69be26f7bfb9436e5cd33c7ef4a0a2f5c8230ffce32846bdb6e6142d97ac212eb45d62f61662b22b1cadbee1882b61968b61d0e3fa26f2354ba6c87f4acac170efc4d24e5c902493a9e069dc78e755e17332540776703ff618daa40eea4e24b2539313606f39d3917b7cf5f2902c39a9cb47da8d9f7148c079cf32c38e4405b3c91dde834ef3847d2ba12bf5fba0f3c3ca782808ea451ada818d64abb2f42a5cd984ca71130841c263b79994c9c43ae5ef9e79674e58a09a72232d7cc57b95f763eb3ecbd9755bbf9ede090f82be1a856b703ca60960d2d576107bd68011a02e340c8b5c51cd8f7972748f65f2aa6e24e7b0a774dabb2a1b1f1a0f82b3fd0eefda81a637cc9136457c1549ec2c2443a44affbc7443a7bf955a1278df8f5dc8df6e5a59bf6801ba854da49a4944c2228b289ea7ebfe9650371287a1c015bef50ae50674ea4b2b703225e825a77fb003550357ad358526e36c4933c238ec1996ac368ccab5d00f5eafa108e72fa10f199141e840d45e141875fc3f78ff6e03ec2645f70613dc808180cc6996534e396958113dab03e04b7192bf70c9e66c4151633a1e091183b89d18689766f69bcc0a57c74c7177de84e3e30babe4ea08d6e84d256baa08f8af8931acceda531c95e2793657110c83ede51e4f66962a571d5b05a83fd962641355e1da296683615338b6a7558a24cd828def16361e9a4a11d864e14e85c2e9606a5962625a8e6ad56251113721057cc91e637ebf6c1a3e0f56e1721c9ab232e928792e5382a10c7aa3194c830597598bd7fcff1c16c647b6e73912c56982e26a9546f6a27485b22e8e60060d33e714cd5236cbf0bcf3eb839d65c7eeb0037ec5029d5799fdb0977311dd620cf0f977683894dfa46a46b32086acfff57fd3f2746ad557184fd2bd8bfba5d3782a395bd2303d925b94f666997f8033f618a50590de26550dedf5b226891e7d2b7248e8daaac25be527322e8a212c89811e575b6ed10099b44d114afb318cd33246ecb7a3aa63e8ead3286659a27a92e4f778608b644fe5cad56eb89ed66fa825c6d942d8a019ee26afc59409375bda0673c9ca9d167c3d09b002b15f6a2f019a013ada031b6faa393d96b43f73acd746fa187a2550eabd018d0bec90d2a5b357e040a126eb65c9659423f2d4df7f24cff5783276582d087bcbfdbb55a225d7e8931cd42474f1ad21ad756a08ea1a35f9f7e7c9ef1795561870d3003a768dc635bdb79e2e678265297d7ab9a321e52f3f5cd4df056cbe98548b177c7ef04eea5d1a96b09146cc7bd8045a9ba7dd6395c9ba0c88793bd229a02470b12f804575bf7538328e577c4f107b91fe0406a72dc06bb7618b0c6d2148479aa1dfae902a1d2ac06f2e4b940c9d1fb3c2009e0ca6c3deb08775d091d26a912952f5b4a7ce4623b6242aeb774da321a4001f498e5f1da3460ad910d9b67344ec8042af945b5bd8acd57b9b59efa1a13328dc610af835d86d8b6bcfd232bd9b767c6ee469964aac2a708f273b4f10ff26a86417f1a4b60ea1b17c805883fc2b48e00d06a1b7351f0a5631d2b3dbcd6c9142d4554eb0f8f4a4f0abb73e5e6b35766487ccd342945f354722c8b1d35f043097167238716216fdd40ca7458bfbb9ebd048e445f59d1d9c567b00ded0ed1d74367686e1580fbdae95d83f65afb7404df5c2ba40d81b41a6ed85d1cfc465554c08c9f58746d692614d831213d98be7ab659fa835c44257b94e3397b9228500fdde907c1d128ecac346135bd7cddb3f121c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
