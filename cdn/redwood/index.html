<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d548a26768061125ad252e5e95bf772405a9bba88c3bb14093f9e9893e2fd2b03b228661c9918b01d64136b10d26dc69bc07c1ba37359dac66a894d2d975ca3bc7fb27b1fdc70150c2bb94c0648659b283a408633ed3b66fa00105a3c0416393e956735f7f12f84d46270e8b7777020116f671b444a2cb7fc259730cf0ff2b0703929d175fad4e976cf14262139d7511bda8112f25e31af0a82a475ab13c5aca188186717829e9e5169df55d9a0b29d5e391433aad95e54fa76cb2c8d22faf7a8e266a0e6be601fe1eebbb6585f9e8951deefa40dbfb33ac603dbc1ce45d9c59ba61e2fb4026f5e2cb392b2b277ea69093c5fbb1d157bd8f0491fe416b82c630bffe8927d2eb352e04a7449806095532c58fe4e5c46daed28655ada571360d26a562a6b4e967689c4b4db999d387b5ee3c78b0f88d807099eff55b95ae8c7e93506f486f989382f89dc8232d783ba812855238f752e1dd95d55450f9d7c0100551121362f41b0386052c6eaa789d4fc01b4863747147694f5b24c67cbcee4b68b7505ed502ddef99e33aa40b7ad4c819e1918d0da2a1152db4df16fb4d2b941c07a2092367a0cc21786e36857b9287baa44b50fac4870bbc78fbd649a8c4c06cc57b3f283c80572d8677bf8886a3489b388fef2229fab6b1e90d563add108f3585a1d9158e2d9ff70a74da498a00670380b5660de077f2f05c1633b6608b9b9577f457268533690c15e6338c2ca8515622343a2ae4e8d293ae8b3d61c167a6e5c81d02f6ff43000a78d161015dc944f67e60e8e11844a7e1cc20cec417d4a736400b0ada32ae2a24cdbd9533c86b2dd6ae806effeb7a1bcf39b936156f470c88f9ba639b338379e11916ffa9134b2f9804ef6ebca32d691cef3adaee7367e0ed485496cb2c6c091e257518a70d3c80113e86f3e72dc9f07da682e7a4b970ece89b7e01e28fa5c892ca7a582585d92de81cd77aa374ffce66abc2031544a3b99c8d6440c8a2a547b235ff0474022b44fea2f7f376270cfa99b7f659f37ffadf51cc485db6d9c4f9b2f6dacf252a409e4782c8e75811caf226db97113f9a6048e67c558b7531b302796e4fa9e3e1b304efa87fcbd919cee078d4615d887343c113a1d0bcb019d8bb7918015a6740ffb871ea28d3f94f2370a8b847ecdfebbb7548491d96c6720c5cdbb0a3eeb0d49fd65f2a1bdf1e73a6e467f51ef3a471737aa03d1246298baffb3262aa6f7b850a16e11c2753593d61afcfffe538065bfe29f2f303e2a8f19612dce4ab21ad3c73be5cab4489f3bd196cdea364a5c87c32734d572ffb402f83c1c1c1ef94a464324c38fb72f7b9a05b2f97783b156194304b84f4ff9b9f3993f05f2a8e91ab5165699b690518cb3f8543bc9e9224f8b0ebf33c4ed0e5124d8644aacda0440050061c6037945bd9a77dde2c80e101e76d17552c1ca7eab4fa9f75d4f41193467108e2fb1d992eafe51cd6e38656e0c45994ee80b59c6c83eed987270be75e6284f1f98bafc629164921e76cc6fab918a3b50fb16a79f198854829b97235ecd0f9a21d70b8ac77b145e0871938fc9de4d35ef06672419f53534362451737c0cdaba41ea7e2d3ae37b2eef3a6f326eac16ec1e4779bdce7ff4953b906730d9f520f5dba066aea146856bf8a834fc46886ff7bd4f29a1fcbd0896236cbe74c942e5b9bf79d9136f09f89292769398df2c01e17e50ebc06fc01249991e7e57226ce272c726c2f930465a348e24727bb8753c33bcf28a9798d5bb632a7aaae34b20127c8e55d6147a59648b30e42ff9a72f47b03acd0a92faf400ffcd50dcbebd7c0bab252a48241c7b4a1f0f424e55b63f2b5e6fb8d61c1b25c31e5043430a449b508c80a693cec79a1aa77223131ba3d67cae560305e6726c5a0ae240c7df3c30239abdd5e9910061affbf1511b707a56fb2881585fb1f85050e87540be26aaa58d5970b51542334e37f4aefdf92de36f9480c287029c86347e7c4c2f46235f788fdb8e9d1d28601993b90410bb0b3ab73cd7928eec084394addd5dc55e440c0db734e08c5c58bfcad8c0f10875a0d9b4d80bb38c43522c373959b1ef5c2d95d2c21912d6d39555c7041a2077ede111d09aecccec84bfcb74ccb512d8788fe2616be5e85e8ad3a06cb758b06db0236b8ed70e8074fb8f89a8c3d64ac82dd4d3b1ad0ef9f517ffbfb89a5ff26cc6191493228daa74b8bfa33cda7c3aa535e1afa49692298b6558de417ce0ae7cdfaa28f3941d90d7b2100740b1457b2a29d8936e7d66fa71f696abcd519b59d9c884effe66df928aeec30a277e9a968139cad826d999025fc1c19be75a80a05085dd257441163e25c1ee2105654e3d56f3ceafa1d71f52b04cb5f94e99438c0c97dcacc5add6105fe2e22e92bb0394c89b3b474b023d0fd253e03794d6e79fdef51642c357fe15cb261887185588bf3618849b15d6facd48646fb774a02556a11683fb09485e70f0617fdca8a688eebe502463272b2486a793ae9f9a77a8960a5fcf7c1ccd9c807618a2c9f27d112b82c75b199a0f1385b3d3c0437d778d28b5409cefa931e2eb70854dc14d49ea4f62bbb22d27ca3d5bc246fa902d5faa63fc9c51fb4a01455c51dacb5f8b09d32c0a41538c0349593daf1fc877e02bcdc65828a3f51c580450fae8fa2a7a0509bc8f08c5077543d1124c76d8b50750da16b9c3bb0969416167de1005c35881adb26c6386b16f5259b0712dfc2ac7ca08f403727ed982574635f6e3f5dcff39b5725fbbd65972eb2fba5deeed246d4de0a5ae526fddbc3c18d90e5a2fca440f3ea6ad172e80c1d8a6d6811f1c07e920dcac7b13542fdea32ae5ddfa0cb9137ed0c9c46f6c1c2f622a2fab06c731edcdb9b36ec2f8aef29dd24a64e0675a9c913efe04621de765c70025ad3fd8e3449f9487cee2405758746e91332919fe109c39620c81ed19921ef5df42ba5a8a269733f455422de797427202bccef613b56e400f97f0ea0d84b058bde113587e115ea96477f7b74d89d0f4b93dd0d1bf87261f341768b1a249d1c6b8ae24ce4807b6fc51134acba7a72f2fceec4f5061810639b8b08f8caa5efc3721b92f6a2488bd5652ceee175120a4fcb205c794fa7035f506e1281c404c6dab76a07f166e2c878505aa9f7968d65245b6cbcf6a495d2c935cec7e285a44ff6f22609d2b26f1c36f585b6d3187bdd68d970a2aa3e4841ffe715d15e319a3c4497f77d1e43fc7d1224c0034da04f12c837e866a0db155d102fba2ba5ea0f849266cea6401bf6d69090a491ec2e60005fb675c461aabd347d7351042a76c6f4c791b9dc49165ba03d0c8f2a47a25543294fed8133969c21c0c5bcf4442bf604c47f902989f1d8b4d7187a2f3fd5dc26be275466f6663f736f644d0ced2594b3770482d0a217051fa9122d1161ff9d9dbeef90419a6c7226a609a58b43bf3dae9d4d5e553dec0a2e712300ef790ba2323600a0462b4eeaf097b72a705678e1537a140f27de611238ed3bb5b857b2dd596d63b002404c0966bd5494fea2df51d396655c8f2b8f79f4581d0ef1cfd31a248a8774c89aaaf7dc8c8e06d1dc43235f67e63cc4c000b66da7087b339be6132860e77597f55392e7e238a3f95078709ae6964742c60733cb38259945bef37f340707e928bbbb460021d7b531969027acc38171cb6e344671f26c3e4003249b0421c3689f0beacea5486ef210e644724962f292adf4e9fe208d8485cb5822d801f9304db269bfac757a56895b343a3722a62644ccd823a31d4bb8d74e9b2163fca220af6878e8261605ae2d478580969171439e45bdbb4823eec2d708f74ed23d904c3e2ccfb637dfd81c5102b04bee4f6cfb3b1f394579d8504d8a965a12ef79c088ed5c22c8e19574e5ea9f8c2174e18e45132407752a1620f9e96e73cdd55b9c2262ba08ab3d27a91dea44ac827f2274a22831788cc9428859dadbbf11d94e548e240c0588119866d571f58b2e5c123c5f83ac4c224ad2523dd169e9e25845e7555cd42e7c5f1c61bc9bb73cff81627285338a074cbe77d6ee17e92cd36a364308f074007b3b8f78ae6e3e8421c1a50eb3298885120140592f665b042ceb60135069b3abf11108c2e3bbb26e71d02d8f8f617b7e7b3221c430fc0e6414421a0b3bd7d3f32c5c1062b9461bd1d9079640aaea6f23ecc234705880dd0135040dcb8604f4aef0c650edc11b5cace5e917005ed76d03d4fdcb74dbbc63990ae76e19cc44e443f63273f137e15f14db8ccc5643b2992ffcfdd5ea3a9e99e472ab3b183e1dd0d9d04bbebfa2c65a8673b3b841cb60e8f875b4a06135c1cc1b5c253adffb3a85fe105810f3ed4b44b0d1b3a628563920eeefba3b9a926d612e2ff8a24fb1817b67d72feac547ce84a10c15ebfbbee87ec588a0e8dc7f3f3e45cb0140e73a48d046fab159ba214d5444dd2a2163480479a8d52f1390e71c7c268a5d4f41256f5ee3406d8aa07a15315e59c463ac2ce0929341f8b85027ffe2d27c99c09eab571a3b3165e8e482794acab5d01874b64af7b840c5d7af4da020235db9cd82f262a066ee5c2fe3e3453e9069e6ac45229a41a0c8d7a45495c7ce845bb91a58768df425e7f3f9ba792e486f001a6bbe0e1d01b1d565bb61bb63d13b3ca46cc92e07569b62c3071df4011b5019599b7b6373738dd2fa50caf8de72feb64dcd41a76502af9c823dc6dab25df19e3d72ab453dcb029ba67a720118891adc5a832e860601d473cf01c78d92ba6ac27d8091199af37d20ed450d02b3260674a606bb81c682cab31dced4c5d0deab3d71fddee0ad5c9da90566dfeaa1fda6fa94b897cfecaee4ba7eed48836b030f3582e36e06c0bfb84bf9d89acf6a80e64a8ff2948954b531eb1fa8e07f8a9af777bd7ef400a9cf9e3e3a118b323c8f8d5f70619dcb6aa288627548d98b21a2877c429c5299ad9495c2369ac39135f6d5506eea2f0b333c0bcc7e2ab69727a83a18a808d8507bf83e6eb50ab28bf0cd8530701a1dd6cf4207ae4bd32e0ea1ec59b7d4d9982a5650689ee40c045569b54450aa3bc99e0d9797751479e7073c6caf6a1907ec4a0eaccf4cf69da5d2436aba403966c314d5186c55661c93cc0044b2cfbc8ff3fa49901a6dc3560451cd53bb0cf2ddeb07234d520b40e4e2a45221ecd26fde7137d9608771211fce823a59b596301cd72671f7fa435508fa1243a317fa5e1e02ab2932e2cec8f7f28eec1d0ee2763afa88f3e2812d516c8d463e53cae6a37b3b142ca6dc7c1efb8ecc165b667e7883c2c5edb516bac9c1697ff289063de8bffae9307ce13757fe1e3436298442d07f95cf0793e5e50e0f04605767cf2a12395029b6468486502f0ef6d9198d18ef31e704ea2b3b5647749261617a7b4a531f848deeebfa652e30a9d47fdbf4deefc7bae1bf492137f8574e13579398c9ba8bd631be02197fec29cd34a2df1c165cf490baa99be6b1076d1838101c0e939ade43d229c69343fe102d9d0c1a5e130ed24dc80c1539b498b473fe431540c438be7c679f3ed77e9307a36117c2bf5d6b63bc5a4c2847382a16d8ef7d4f470ca2254b3cc4d0a330221de73e8e50437edfc75a1b79073980d5492f909ca8f1c55f215e945ef0e96c980759f8bc81f3e03e1ffcc7f035b1dcf040bc42b867517a0ee2061e681d1a0bd6d3332644bee81e2a0cf44f93b8432874f4f7fd4867511ba58921157b2877ed8c552fc54e68410c6226f67d9c6d8de3a3901cb47b8fb4db2df4449bde695f41b1b1242799db9e986b98e80ccbc59a5c83a44905e4156f7c66409d862a3e59c24fcc0c773532b920a7ebf0260de0ae6d43d18e190d910ef5273d77dca5f5e9fbbadda98378f27ecb29a5ad9169d011301a9346a4098acf8b111a2a12682de1c6a9061162215bfdbce8c5e0cedd110e85567d7eec3aaef35f6a6829100e33e6f6aa5de391cec739338f300d47217f3050b221a5f8006297cbf837e318b6095ed1e1e10b8c87fbd2c079c1f4ffceb46a885bdae642a11111230a3ebcab4aed8eaee1ee57f28836f3740355c551b27608d8de6214ec88ebcd912c5263b4d89f34ca82363081671b8abeef5ef0a84d5f56dc98d6088c1bee1525d6d9aadf3a7931039373d0fc6ac0149e88e10be882f6d74f079c6f7975b5da641d4d35edc434eff55c0d11bae69078a64f53f05209de53d636c578f68fd487a07e3812f58f41fa1a84f8856a601c06b65c2258e6402205b7bfdce642a17a5805c2c4025f4d6170051c933f6fce6769e3ce07cf82b0971bf2336ac4a08ca1fab621cda224e1379b6ab6795a7a5ff8bc9f3de07e7492238bd7004ba2dae65516fbd62d810fd2763e6bd38379fc3bd608379d6a88759994041aa8c95e6376da4b93590de415b0dcd11b233e990c169da078e4d73e3bd250a528da55d3e113539b7638cf0a8262d3f7a22811594eb8231295defa7b9333d812e0f079e8343ed570f2cad2694176497359cbe123852548875e76fef2abf5263667fd4e93f827ddea17cc80adcc660b4859e143beb6ab12ca8bfeaf90ea8dbe6f74e7e659ec52e348b6cb34bfc3e67f6bd07ff9d41ee0c45533624377b8a274ecf1f3e8e92d892ff8cad805d4ba797b7cb33f2497e3f9a1199c8a11d7340c4624b9cc2ff2a46c79f68c52af041cb65fff83ed4202ccc97be3d38c372a0ac124d10ea0235899db4faf736b086bef777b14497461e877897f9da4a926f7f1c2055dd0c138f012a5aa5485db921eab3851b7ec5ae85d7afbbbaf97ab55b34ca6d5368bc661139387a1d74444e9c8b7dcfc4618e04f8a8158b6fad1f1f365dc3d24acfc3748a279800996ed0dce11cfba1c2afc208f018825e717816ddf690a829eb877620d7de58a041f8dc36c0e0f38fcfec4ceab2c22c2291d7c9069e0ba251a4594d814f21481820d0712a939d5f9704f8ff76e60564ca933b17e1569b3f73e4cb47f0250b09290095f124a56280b12cdf1513d668fb84662c0149ea19428bfdac580346fe95ce428468a8603989c4641eb4e2782c1d83f6326c51fb6559fb8394b70dc5385058ec89e91d557008cd8210db7fe6f4b917e61b418ff6457f1b7caf267da375a926940ce921ddb140acb9e73358b4899b656af3cdfc9deaf5bf1c828c6058c87e4e4db0996dac4b63588af07793edad5807669adf06474ddba6d70549084a8d7702b370f7f9019df6f549f7d338a40cbd9e2d8bde9608b7b97df4719f05a55cfe699ebe066d981a17d2e62cc39f2732fd1c11192bbfb12c8b976d87c38061b587754bc94327d5b5ecfd62b8b0c5e3bda6291620c493f94cdce5ad5f745c97e638f6155eb49ef6927dd1183feb82b1fca84ac60b323aa37ac0cf895b63ea17916b3c1e5b70351497f4fd7e24842094d7ed000ec5cf8e8f20c2aba3621cf162cadc5d0fb530605abf50d5fe4e5605757031067b02af58da942efa4ca93ac36737d5312e8d145d42a5cee2d61a913b2cf69d6732b3ad8fabc2bccfa1276dea5c8d8bc005b9d9bd956bf6cc78fb3e567f55ccc6a7115ad457a94e7e5d1d7edeedd3fafb7c1704778516ef4a2ac3ad6b83c96d18e259786bc51de1964a968d16a63ddb5e9ae1619c64324e0b5b7435f635bcdd5c7917524ab57927d3bf5c9b0fff87b6603b83eb998c0c6e80cd4fe334fae89028512602587083a1b4f357198ad89f83c2a9f35424a8f7257983415a92975460525bd1013f1b8ed0bee98d5cb0527cdc34820fbdb89c95397d6577b777750525ae048ddbaca466eebdfb6051969c7fdb10b531bbf79fe46330d6a8adb17aef9193ce1bdcdfd7225f6d934e8ec1a0321c96c382cd2241896e2fc26c68cc7ddd79b071d6eca49193e8f3a3f7ecdbbd001b07ec5afeedbbabd9960704291558b9627c27a66f2c4fe9a05cbceab3207ff74ef9183d1e21ec4d81636d3147dce1a810e28b67488dffe710fa21fec8adaf09252d99ad1d8ba4f2b8700b719cc08af9a0b40f44066552a60d58be7aeaa39a6b1d8815abe116c7b55159b1fbcddfa0d9b1a58b7f288af2da8c9c87da5ec63929d8f87112179feacbb8a39ff597dfb6daefcd2e5441bb57581ea567d313256eec4d6423d4eacb96382b08fe4588fbd4723a753bdfcfc9ab2c3cc288d2deba98294b4b66b7a7e9c288dad7b8e0b2f90eb43016becda0e6907a7614f24db13006c9f49591397a4d3c82668154e6e58c24b09fb14de3893c63931fefea6332450b6802b0b164a5cd767aa5ad20c328d1d50d7dc4588c8b24a00a06246f7ad4b916d713f896c157bf66bf21fa8d6cf898ac358d363e0670a1a6e093d3540f362472b4b93ec401abbda4e3102d506c08ec1bd674f4ac88eeb6e870c633c914e3b96e39b568b3d3885ec0af86eb163051bd42e7f437eeeb69b80b8bc5e754be060f647c783a1e84a7239db13a6181340d1129ea851a572fe79b0b2cb7944929bd131cbc3d11a9f50488b8442d4c244ca3396a6b388a703681957e2607dac954b178515669bd567769b35500febfc88708a9758a2cdbb5f49ca98124ba4c6f2fedbad5f4df1f7780e0464cb0503ec8d6869cc29a4d620f5d4772d61dbc850c8f148405059d85123e8e9bf2e61ebf05c264688254ebf7ab5fbf48d904330af73a335bd997a39ad8cd84d4fd69953b8baf5373033f7e12eca5b1472c615e631bf80ce078afd308f9228d21b1a7622a8bc34298efe32c7bea13ae385a3616a3053f51b40377166eade4c36e0ddb8f997c8d4f299c35a1b85509b0dc8c03a6b0449b2af4d025482a2731fafb6d88fa02e8be133c3d80f050e3f4779f64874f02d09b83f6b6c6b83850404d40a4475a8653ad365496b904a68200489920bb6070dc31c5e4ebcb3b16f0e72d588b760b6395f6ad7545a8507a1de1536a44d8a4686b1c03adf251aaea5c3cd43ac34f23a0c323225f6bc41edaf254f72904ce752c3a3494cd1c90a4ddc619e523209f7c53576cdcdca3b3ad5a6e4c83847cc4d1aa2235078d844a919f4e620d06f03635340e17fa67263f49add4c40aa256c5b09551687f61a85caaf10bd9c08478fdec2814bb15b50f9574d703425b2b7be331221be2d352c2506d64cecacf11525a545d1efbb6df91d7c77256abdf718c21ed4678022a27a167660ab7079f0fef9c3b1ff92e53b53f2f20173b78d20a2b57e2b31e36c409b5ea26969baeeac2b4073e805c6eaca6dbe4aa8a431e6447469a14e45fda5ff532cf1f82d28cc6f4647b1b602ac92579f3c7340a8ec95fc68ef281dfac90b7012a7191ba0697f8c5377cb87569a069cde9f9fb9812de36525e87fe78d1890fd00684146e016f76d0f06b3453c76c91eeec770cdff9ebaf0b23b45ddd0b7c738e7777fe85e23dc9d0371abcf034d78ca076afb8046ae3b1ab79646597537b8a520e8934a96151b2a023f9471544da3f9dbfea6f6f66f6f76ed1fe40594f95f19ca2d15f5b2b965e792697fdbcfbb92aef95560940eb460baa9381c4b29a9d9aa9803ca7f98fe6d73107a41b66773b5234ca9b9b338158ad53111a6ab25362bf1e56f2172d7d4b662f9d37d0384ab632bd271af214297977c5c7e0c5347f405faf8cd52f3e19d02099280a1e31e771ac562ae726ee016a7ce6939cc61a674c0c22804c573532d7d487452395bed74ea75d0322d8990b84c242afbcf49b4335feb6f9cac38b00213f704d7b69499e376508d46434456387e86ded350796597e431a33343867a58b7f0e6e2f679fdc25f8c0b361098e48232e39206ac1b4cd40b799987efb6dc1c490bddd1feb5c45959975e9e3e160a16faf0942e256c7010e325b61f5621d8a9689fbd5a902cf4d4aca165e20e1b4384ccea7d05db19babe8eadd01c90c23b0392b134ff3af8d46682dce753203bc60bb724c23d7547ed928452342f66744c52e5adec9dd65b71efc45c11481101fefaa99a8ef92371ffe5e0511c75fc03e3faff98fca0f0156363c358e5cf1fb56f2da2157ec1eb811fab5d9f4f2fd8d8ea82040527c76b1b8287a8659a0be1507e8a94c21f3185742b63d05ab657ec616e242d15dc6728495a632a43106fcfe5630149b83b386a00a2fcffc2442ea49ac32973843702bca69e5d71c90af015a66fe01d1b570ea06854e33b102ed72bce940b44722f64fd513f7387913f7f481f53efb1cf0a87a6468bfdaa0a8d2b5cfa8d71a4dd154dead4c002bb1e5fabfd34f4afa826ae4e7996cd18ed83d041b2ed52f575aa1a0afa3f79c4a4e4d87442c8fbf3da52c1313c7465b40d77323c2d0bea910660d7e2d6f8cb62a29b9f759b90a56a00ef67f14a4c1d5d3a613e11b76d2864386598e56d77c1ad78a2d751b3992967c364bcb267d95a15fca4551ec0d1dee38b2da0508f2a3f1dbb9e2fb32fb72a46a68ca30d6b7e75768c84c822de50e297c14c286f059768a8d9872190bb50840bb3f23a47b119c1caa198c29fc2d4bc63763a73741cc4828b62e336d1bdeedffe028820ae25f8dbed8cd6d0876fd8bcf9bc21311420d8f9462e74e714541b3838ce8b48961c38a0851125b64c7f8c80e1fc3af086947ae9f3ea11ce5c0bd4a30edd2f5d832e5ee09b6e8848ec3e1e12dea40219689ae42aacfb253ecd1aa064380518e2d8eb5b9416859158e0f84edf39b088fba403388fb348b42ce343bed474a2e15a22ae166a8efbd770b6dbbb3ca8f6c5a0c19bcdeecd382ac597e5b2212981ae9c742129470ab32988c6492e44a69a9bdf9df825db6561f27520389d20fa265b8b444cf39d9745ffcaeb3fee96975b1b01ca7adccd3e21b8932d23edeeb6e41d90f06e1adef284fadb4c77039a2cf439fcf3110add53c614815ba457f9046af9fec290672259887b4ca6fadf26330371b9c7173a85fe4c4b9ba25e6e4fe2aa157b7c5748fca7ad2e93cd3380287753c11600e490bff9a52c8f8e1e578f5b2e9ca6521d58cf614b3e589f147809f5d92352bc3f3f894a6ed153df59f7f9da7645df06c804abc99f2959d7765204baec3ba19b1c5bf718fbfa292e78ff9115ad6f37f6bd4c158506accc5e3a39c9cfa186ba70c55ac0a0fc2548e48b55d52b6ceab9e3236b4d60f6f68d139615ee788d794bb119dd07492410701a2862837d30067bd2333912605feed8a7dc476f355195d88dabfb7fc94f93aee2b9ddb12274381f8672438449680e2df5843154bd412a31f9a697b83ba7c5228108b87590a5e7b18a1d4498feb752c1c342a5b006a42109ccc491f39e39729ed1fecece2b90ec7ce9416c7842e4b47e62dc5ac7484cb37d48999115dbc28b9974f62c0c789bbfce46bfce34a42ac3065fdd43a2f6e4e77c3ebb7ef7bfeac3a3d4645d9e1fc964ccd395c3d8c4cd0b1227ab108118ca0756cbd1d8b20eecd0744a80f1e72f59a7c84578d8a9d832ab1abd8256d1f931a90714f68a30acd6db04fe8b6fda70636c1ac3163e3a2601cd84e96ac33bdb2001ca4c71ed1b63e9b6e55ba15926aeb2b365d4f77cdd0f8c9809c6fe7d10f033cee280097df7c10a671ac55f31176b4acb7b85a26f7f2bdd9061819006db6eeedd3ab6ac83179c3565d56effb791ed842d857ca8eb0da9767ded34aead9db03b147a461bbe5c4cc7f45400fc22d3f002435690dcc9da6e91ffdc82a36db2c7dc1e2725f5a5a72f04dcfdf4498e64ddc53b0373e5f6e7ab78ecae2bf7e3b8ec8035c09cd53e3010fe3f557f2d22eefe523af56fc6d7934424c9166f42b24d9c05614f0bc219b523a9e7d313349de50baab2d2d814e5dfccd217e6912880fd49d32999bc620836fc2cc7bb9d8091f51cd7f89fd46288223b7d9dbec6d4f0049f63a473f89113bd931df398d53584726f73ba3d126ef6d19d37fdbd6b6a9329f2d0caedc9c1a9b1053314ef701a10d8f8ac766ce42316e839fcfe7a589b23b5e43443ca91a54a8da55fe0369816cef8c340c9d5ab807d9f1e00f801fadba93cbe0085e225e4904f44c2f0f27ecf84361f6cb69d9ff7e133dc082e6ecef89016d70ca011e7887725ca2bd9ccb754ae53ae6996657a16ade18bbc4a55990501a66902449739fd3f93e622d05959ac4fb2b378575cb5462a4debed337b675133ace8138a52287756602837070b3fa60ad8244cc49b8fe52ee47be3218a089a694fb57860c0b092391feecf743581a8dbc3c85afb4fa21ea8344982f90f50bd750b96b98d5fe62eb5c254dad34d8064066a3d858dcdacd43f79a95656b22bdb763366062208206b18082b14ec0233495fffc9fbf8cef3fcee9736158c1dcfb4cee19483b17fbcee78055ac58470670357917b49d5303f8baad4c05ad398cc98a3ce1d07485c463ff526d18712494bcf3a93dff39195f903e9256cec1d980161a8802c7290f3951d407f917428fc049dba02938e8fad232b6554bf2c8b9bdcb6571c5e84a80e6dabec073e5bf06b59efa353b1ebfcbb3cbd15aa4644977d28b98d788c7c9ee9c5da63ee8c204c005055bbf9fa17b3654e1c8d5d4390ae065bada559d428eae6a1f484548a59e61a1b893704bd061fe81235efd33c91038b560605abc1c79da32a633323e7d2d8412c2bc97f57f71fa5f5395f9056616be0b928db7dcfd7cef921651caa77300436fdc80da711f02cfe288e31e99b213bef9ebc015df371fcad86a0706d2a745cea29b68e24504be2ade031b889d7f50770cd5680151aa4c03cc58bc08c383154f9b3beeb5737600c3c513ef52dce8c5a801a4dfef92a2ec4a6251ef87ae887b3010beafbd4d799a3d040c2842a66deb83319ad608f08560093f622c90a27dcaeb7b891a9752e9deb3342aba80743e02e65c349a3d29fb615eb2ad234fbc6e8ef3248687d264a08513942774da133c31e2f2e40c63a37a49cd614933221760caecc0260d7dda1bd2797bd4ad7569ea489157229ded7b8271e14f5f0649524122b3c448e9445333d076a024a5fa70cdb23dcd4646ac6fae5c4c0e9f1a5cd51e1e7b735f902fa11923c08070be0d652d95954e532698abe79c9df2599dc9579faf11e98aacdcc566392074a5f311bd4ba0e3211a26e081cc87a9d31a699ec729de016cdf3ed452757cb178660c95b68dfd39b785af8655ac2570b42ec6372f558ad863928ab959bd0e63d367e29c068e0fed0f69ecaf96494dae57060ab8389f7a8a5e431ac94eb24f1a44a6fb158ff69f657f4ccae41f2d60c13fdb91dc7bfa60f04abaf639e39c0130f1a2ced39a8f5e0de0179552c1c16c2402a8ffedb500c24851fe6c9d01816261dbb9f8a2f709ec2d67a3b8a1ec061d0117f0c45922e2318e8d6ee4b6c2255c36e5dad93d459b712b091ad280b3c12e85934b5e72d9a4409eaa92d481a429b722fa177a8dbe146ef5fe6367e52616a91ca94927aaa8330c4d8f20f3703f9bdc2ebdcb3c65e2954d2c54e75f05a17f473e49212cc4763656dc3460220f0ace2b3e72602f1cbfc7467b1238a20bc7a426822714b91e3e054d26defbb92f0264b9b7662fffb66a01d4ec6e1dc72c5ad670ddb279a9c5a96b64bc53b7fdc83e79ddc73e6b27ce1c83d72e0c7371d144c2b529a7264530fb17c6ada7f8104d5ca7645d7b55f73773bc2ad09911df010306a70133e6d5144b57ee2b37825cb6b1b2c27ec5d5980c2aca4113fcc39a5609cb1bdd3ef21cc2770809b75176e464316dfae330b024a3feccf04b06e53606a91ec6f27bda7aa526a001544f6f8371b9ad31ece907fbbac8a7e40830a0bd4d7877327c9ae2929688e897384b4187c6d3ba4bba9a497b1d5586f01fe4edc7c961f5a34ea49dcecc49ea44deb6293a49fc8a1731ff46061c697c2520e6badbac00950063363253ad30a68c5941bb739618a94d82cc8792d9377b98f613b31b6cf4762c0259725aafcd6605fb8f3dc8cfe1406452685331fcaa663c40d541b099b49102f27690129946e8488a364d5f700164676f55eb5dc9854639d2bf260e87a2fffcf08dfed15b26b8628ed254b542e3c90d692b72954d09a4dbab7884f6e50eb7e71883b0f1116bbd36a9bca232064f7af4b58a5e0c77b2cc00c3d64b63f6b1137f635cdb26ce8df8f5a8b41bfeab0c104df6a60fed857eb128ab522f055c2a4aa56187ac6c35723a4129a839fcbfbc41c2da7e88362dc9a6e716dc0c66b97ec62e876d18eef1c701fc169a0161222a8a61d8d49d036fa959fd0ec592574b7e1601b13cefa43d735cd9fa41d452674f0484bd714a91b4629e7b84b4cbb3592ab802750794c4639371232470b406db3728cc9bb6c260fae4305594453e8434af7bb02b7694cd2b575ce6153e1291feb28c62ddee53e49797fbdb7c9bf87d01f12b2104a384ca1c45d18bc01e3bb064fa16f63cee5dd6974b960d954b59e7903bf0469a9b8ce6655136176f06fcd191ff31c2634cd62a5cbe6229943c2cb42bf081f04ef28e640fd565ce20ed71d861e6cafba56cdcbb73457a8bf9ef5ec2e0bf675c531ca9f37b236c6af1c73337647880a3db71b06d8d8290657d3c95710c1e816fc3aa544539d078ae4f45e14efa522a2e73da7a67d1211d4f3c6584ae55899e38719b3720fa251227fb720e11d73c90107aa3effc523a9fad26ba98a3285d5c5fd77f4f1d316aac39d274c71bf8876a24648e3a0bc874284959ce79e6d7f08c0960c97777a14a241d5b11da825b9146c8294e2d863462cd95fd53f33216c1f622c54da46465b33ff7736e1f2ad08713665391987bb1d514e4ab4e3cdd34b1cc744d57c7eb1af111ad1ad6858a9ce3c79857fa47def52f6a8069e669cfc4fb696c13c6bea7b4bd6c3c3cede25b01a5d8010405d813fd2f114a921f4f74dd0774afe224dbc8942e01108215441e767cad7080a9030e472793094a08cd1ccc3b5246c52b2dcdffc05b730f0adb1b332ebaeeb304074308d0ed148877830224835da0e908c83e5ba57c371574d389f7f0e8eddd5266e7d9cb4323b2b040658dbcaffce4fcd45406e9d48bfcf1f8517a6d146ffecfc2f9738cf49072ab4c4855763684c250df10b5c45b5fc43520d9bfef5820c3d9ffb8ed78988b869a4272b818ffae4a5ad6053a1797867583d118d1ef37aca4fd93b67cb825881dd067dc70e70a1351690d106585161e64f94117447d05e0e5f03c24d5ce09b75b17988e9031a45402b8066688de8c5556d450e479c476d8bc8915fb70e9cd7310c9ba820b126c2dfeeb3f2ee376a2c9d77cf945d5d1db1835964e2f91d91375731e1fdeb49cfe489f0455cea66d2083a82759f32bdc1d25fba7ba818442e7bfc951ab33dcec8fbfea36f8fd85f2a177178f854aa71cbeca2167ef25acdc34e1f16216c29642e25707004b01afc643b1d62849b6642c305ee10db9c12a2424baa602fa1a5530aabf3d5b7fa1891ef3e2c263f64baa44f4b33ac6620d0f54cf23b7a7a6606b6eb72f5cf90f799e306db1bd4a68344787d5fcd0ce33e072c9e0a18b09a912b0c91dd0a0da240df1c64960852ce5c1adf37b07f81408d21e0cb3cf38b141752387702cb29d9aed991abc8a92f885b9c245eba0186b93b66f7e8ee23b65fc32940bbb8d39fb20b64b66cad5e7ec2cae536b2af479bca9ee0c5463bd19639d195b7334ce31288af1648ec34befa6496391468bab9686c5806b6fd6b005de6e23090a6c19dbee27a5fc4b5a06668023f2d2b7c1f575689bd47b4cf72b41f6e4ec5899d151269e6dbf36b148a2132c0d3da7cf2206df55540d0bbdb14b544aeef49f1dc7ef548129b0b85d508c4e97ccfb20b642f73b6e408a307fc89f78604451ddea055d2cd9f145ce3c1bd4b6f9da4c26d21e34ee5bae459aaac608d8ae135a2de7e0f900f165ca6086f42bb49c518b94141a20aa2476ab8d3bc23e8036b731071188d4762628ca84cbfed6320c7ca27e2388996d74b016aef0322aa63cb8b41c49b709a57378d482f07b9a5f17ece4cd8d59b1228e4b84cec4ec0a6b08c5d83b68d70582f2473a22ca37fb18cf8ed1ec24270f87ae98123b9fb16dd453263cf0b642f0d81d812b03388c24426c0c66096f009c978925f19e59ea69467c0964f362763f6718f82e6dbf89d5c2de4bed580c16f45381ad29dd8273b1521bd6dfd24619d4ede34ccf85a9e158000b710100bf247050f32fe5dd08d4968c97df83b3e5230670146d65cb9ee25ea15ee3009d2b476f8b0954e532b15827dbf754d9f6bb274159debae2d635bedc4dec8338affeba64f8d0226b2938ed66dfe76ea71bd40756564a46741aabefb62e703cc1a1e3e65a20f3d7e29babaa1e4f0657ddc4e1e62439d54c86e6ee326430c4be572e7c117a0f2ae62528e2de26ae812a9e65376c363a3ff7844045017c5744005ee014c93b4602ac0156a4fbcae9a68733ef91698e2199e0a293bd90de22c970425de2e91d5669a0d2ea8e130a418dd416ae525e59b6a04a74ae18ab328ba8e84f9c51b510896ea5c64dd62451c93eaf569d22bd74add1e10cbb2f10a8c99fe6f1fa40e87d69633fbca989f93f981675085d32f50f8d304c593aa11a5906c213afdb35bbab3e5f42c7bd13fd6a6bf5916d6abab82488923bb9d444542949eade51c82be3fbeea9dcd76ac5fc0e2f8bdc2e785f5a5a8662aed93f8a130b6a70432a385a6111b4f7ccf5af5dd65ec1451be4992cc3fe3e296205c968beb8e9229fa991520f85d2cbc4374623fcdc28772363b02a49c26b9f9284f6f67d487e407a40f89e82d6ddda3f64060a461cea0d67b50cde6fba1da7d53ebf2ba2dc6471b5c47d70ca232838ad169852ecc1538842a9d8eb68ae251bebac6d84e4e36decacf3d10ef387f65e7c5e48174c144dee3990584dd730dec0a1835bb3e37275d2bf406c54b638640ee14e3210f22a2a5d95347bb523c6e3edc3e049a0c05cb635990ccfb5bc28baf172391425f736627a473531226fbc63a4f52a604a58522625724a0f6edf70981d37a482e28196136215c3d315a84fef9ddd28dc1137d9597638ab94279ea8359a62a3219c3a79c308a2917e4040c0299991b3dec47e018137660feb567ad21e1ab1116bda15c3fad6cc865c7f8986ae5aff38b39c14fc4d4b874a7c162539f88cbd9aac16fb7d1ca547548460c81b7b9ff8ad80c0ab1b539c8343bd6e56360cb7cf8c7e72531f734ed1969f5e8d7b61e62a400b166d0cf52545702107e936ea27a7784bc3199f21d663e939332fd6a606b9568bc27144e7392b9824cff58730ff37d7a4dadac07aaf88672ece61d35d2780f556a840c93784cacbc34a904677765d78b3ccb1adcb3ba01c291c7b1b975c0028bf4dae7a12d794b7a110ab1e53850083ba1732fbf58590170381215094dd925e5c97d916af1b061ddd82c6cde2cc0eca825147c835d9c527f35209a4ddc50f7eaf889e17dcb93304ca608ba9c2533052416baf97d8b11794e6453da08b591f7afa782fae8cbf3212ca650d619a17687a816310f1b0fd7aebbd9e5a108b85193ba9d7940ed895f97b1807b24dd7c86f464cf50aa753ccdf3ed183ca19fd0f5a97ef7063d3972cf64df5b3931ace443e883b70faa1cd1dc483f9579bdc7ecb2fdec126ef8ca1fc6c38dc664158f146e96ec96aa0820528e2421af8ffe9c5a4a62f2c65155094b6cc54ea0bcc7b690b53b65756fccddead0034c623484b48b5c08c428fe2dea800755ae994e2638cee9f46bdcef9cc3581494f556a54f95fdde65e812f30a2aee524dcda4b2ee999966bf0fb0e8a754d67de11e787fa1611a206fe36a0e27b199104fc27fadba18a2e1349f7ccfce6aa8616800a5cf256ecaa097183ac8d53fc7b79ed4e47eaa970413183029749321b9a31756c03fb111fc0d14b422bf92d0084164b2fcb7a7b231eb657c067cf031d2248571c77ec9edbd852d1bf68e0da3627364322429d384770afd45209567061e91a5255133734f722495c239c051bc4c03d4005f37bfd5376afbf9c3fd9a540a1286b7866f044683142340ee12f677889f8844c861b8e2eb1acff32c76336dcb3b844420f5c9c3759fe2512c140e5ed8f12c2f571319abc3925a5df4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
