<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1638e2355c7e61a472dc90da1aea8d87dafd03b91a66638bcd86b55ae45142b55e60e5e37fef41668e59406ead60209bc9df6b14b4a3716966b2b8294fa8834e41fb316b13f586aa116f0f593a4214e5e43e331c3f0a97556e8b7464b8fd8b20ccf95580b730c4d01faaa52d28beeaf0d693a8a95fb5fc02ffee15b5282598f12edb35fb32192461fb16b6838f80ab494dae763be707d22fbadeb2d2913f67c62123fcd7c3ce47a74e0aa1a172b04a895baeea2515219f0a4e58a3f9b6a6bd3fbb79bd2b750e1cfee64f5f89ed55e0eabee0020a4547db5fb61f88b54b205d5b7b2014581da453e316a7dbd49e3ca1f2ada3c356b94efcc74060dede4a7eafe7083522534c40b9201255804a2a8cb3b01c72f934676f905a4455ed004e95a6debada5678ef05085d567bdd0fcd761013be5310f3dc19195b80ceb558f6cf8782755fe6e10f2e7f43c349d75c3c458600a4f9179c374ab1aca57a7c0741fba4978ec663b3e8162fe0981b057f42b2c0f782476ea683ef22d9123d54ef25c050e2dd79578b04158dec04df69173abff146247ed5f86f7641cd8e694cf61854a8ce941957cdf01264246300ca72b49358ad1a6a669299f83d41f4742d8f5df576848ed3785d05c40520b0fd8ca31016f80c38d915cdf5c7dee10e5f554459b4e0131aadac537c1263bc4e053232f2e82f9c40c18e8bdf2deef6d184c6c208afb02ebbb2892c7807a4923c192b8121c6150a3cbe37d2774f04aa3aafa5428f67d5fcee9b2b146a0395e068d405c42ce32530c07d0c0db3226ad720f7422f6b794daa92075aa63571b4c8312c4fa3ebcc578bc40b9f5eb34e0fdb5e689b7cc64c3eae3c22af3656fdee8d5023df804a69faddcab65b06d16e672a009c3e24d3deac89e10e121e9248d5c1a165f03cc02c64867be92f8c947d19b39d57af058d9e9e30261cb40d1fda21e01913a1e588e8e94980ef85b7bf4f5e60680be9127efb0765964aadb07f04719398648e79a66b607b9c3bfbf3c25915cb4848658241609b3801b87f1a01bfcd8dd88763076c050bddd828560e40f827ccc09030b278b4c70ec274e80d6e9835b3bb462d5faf64b27f8fee3d21b85abe61b9835f353b944490f08ef7fae4d7da0a40a5b0842bfcb06d68c563fd791c5b24cf36338dbf7415e693e3fc87aba75c851e21a228bfbd16bc7613096e3b4037406ae5a280f7cb9e2d4c4a54914bc6aef00224012a3b2d1349fa438ddbbd021db28eaf670cf72953e2887db9aae3ae6c61297ea90077dab0feff3ba5c85431409bbf6b6c80a15f3c81eb60954bdac4f47b3422ef9c02a2ffb1679a84cdb4dd80d20a08e401c36c0aba9e3189adefaf39fddb31f744b9c2cffa7ebd11d2dff3bb2efc00a93a6aefa3382de8d8eb99fee2c779b0d0028680f59650f8d961e3e30f891aed6d4a19b785309b0b1c51d2748bda0b909b8d3fc4e81f173b560d7cdf42224987b1605c07a876148023851f642e4572ed7eb3dc055f9c76c5a0badd9482e4cee5b9436699dcedf72adcedac0a82d490fd9bf07b372710e45f49efb28dc0a24150d02b65cc21b771e774174295f41e174def71c485eed6e20bb02dff0e73daa37f9c1b9b1460a140274a24b67f0ed0c7828e30fc1df0bfe7b0cfc78303e6720d74bfacd52f3ed9001ebf8269301c10e947a934cf1b98f5d2b8ac626b9f51d4aab000fd324d361aa149b554b089fdbe25091b3eff6136e6aad3a0f9e556bf724fb030e30de21cece3cc9afff1a8277ca919828686d60afe1dfa99e82a132dc51b77021fdeab99a03b663ce1fb322e4255aba696f646e25791adbbb9d4bae610d568d1b0f9387c14bc99b58df5a8db720061a8664a43decb3a446335d6edaf14e306c8f25b98f1d9b4c689d49fa6143f0c16ee10e5625595d338279f0572fedca1bfadf2a1f8ae6eb0cea37c7bb10e3852744711adcd5212483f68699efe7d965e82089ba056a5113c4539c147c06086e481640a5fccd6b776d75a25a48763e2b7b367822f217ec1fb93c04c5d9a7beb38e229131acfbeecebe1c4da43ee0c9c5081727be81c40103551d2ce588397b0139d505b0c4f75e3149247284be7a0d6d83504344a57f59ae6bf83e764d6259ae44de538fbc9cbf935413a09af6b7b0d04ddbdf0cf87d886b9587ca6b9e7f337db37bc98ee9092e4913d4a2568933b1eb165f032049dcece37d463860d83b2e4fd332310ea6eb924ebc3a5ba8848f4c218263cbc575d3b6746ae1c12c232434c9b155a25da8a7b0d3424edca66f62b4ee6136519df66db8c862b42d3d328d0b83f3fda00aa80c676e1cb3aa96fa649db1725782ae0c95869be95994a60789efdfc2271f219cff0392d590fc0f43d41fd04dbd86c9ab37c9ab8ede5aaac9c1d39e7233e1a18f07687171fc99ad7243708bc1daa80813192ca622291177d5aa56c9f8db2d1bf90ee9d38c48716815d243d227c7f95330ab9d604016aec0efc4ccece1fd6000b1dc415f109d3412a3350d502856630cb83bc95239f62f068981dab4795636af98d507d91eed1a23da1780f012f04fb027f7c5c6c5e7464399ed8b7eb468276dd0042a907d0c1ebd9e5630f75e4e6ae07cf6ab645b7c963d21d23e5ff92a6d1f71fffeaa390e9d2873aa98896862057e8bf3cf1ec5df12a74d2946146ef0139e6683e402742871641c79ac6e24ffb466a42a5dfe8d9598e62d2a6ae527efbb11e52bd967b56cc6add431433585a3ec477b170a987da86eaa1e8cde8762b99387ba94368a611f5a3862fb2b3a68839fa1a59b89c99ab0a9a146e0cfe538663eb23f304d6ba35a6160f8c432e755d5c2bd5d5e8611f647466f3116693de1aebda8e4ad1911899bc90e565803c0a915e295bae4c00b64a55f9f8cb4b39ccddd182683dcf8bf5354ff8c8073fb348573d6fa7ea215440ee424dab97425f2e9c0ff5a5da654c42f18dc89a86b210f041baedbc2c7e7e4b7acb1d1e5a5d80d3a621cd093c5d8150fa48b8d13114012c06781cd481db4bfba92e9650d51b5f2328384b9f1611bbb7ef967a54259d43e5374b9190127410f22c1ca8fdaf875ab387b0feaa31faa46eada35938a08ec7a36d8b8aa16565b56d657206a44364100fab02c4f5e9d3716b38ce64883b84d6bf1d0b20062b990a0c59d5e9f377c3fac673b50b49304288eb7b4a3c007f73562b109bb29da849c542e05914faff4242e767128ae7c18b4b40a5872cfa7ffa1234153c8d1919e67747bb6a0f5aa8c2e53196838d0f3ef5bd105a976f8f81e7404a5cd6fed8419e5eba67ecc4375610360106a9a405f848fb57d5f3f36cc8fe1010dd61f251134f299abfd2c49e6927de6b5b7714e63a33c91b9ba90e47e280516a19335cc176f541956db75810ffbf174ec7d8f3772fe3a67bf3610c30e12af3255e6232d7cea640a4068fc7e7ff74bcd4bf1cea8c82e3bc561c6e900ef49c931cf0b8d7872324b277cff9a5f87b553cc8c6501f34032ffc358944fac9fd86b2050c35b9e0902f59ab97eb5181374d6c1db2b6c4641cff800a28cfc72e6976f502cbbc351edff6dbe72d66d7a4036f89eba06400bf9b3402ca06e8afa966d8bde5cefda6d299af8abf249ff3e49591e84221680ac52f56ea01d5bbd394d0edd4776badc3aa9f26934cac02f37b7727ec93346aff16afc84f9ea821c47d7b6b684ce4ae0302a8f74ce3031c202546852916f4d02990fabccc65db86d5b52cef97d29a8d8cf5146ab94e43a082d285dd7d40a1f726c0a8eb5115efee7d8bde029ba9f2b19a6f72c8ec118ea357d9631b3375e4c61345aa0ecab7ca6f6f7ff3877fb5f9f9cebd237bfee33a457ddc27360d1dbbbcd0aab6d361bc8f632bd179df5734bfb3236219413f7c6db3d2fc35daeb1d9dae1fbc9cef74ec485ac6503652a3236c4dbfb77c87fff6e0ea6c00adee6ce0d5e012c50f83455524b0d5bae59d031e7e296461e5844e2447706fdcda1f308ceacec4528e0b03e94b0fc879406d90d5052a35ab5cfbdbd292f74a2739eeabe302e4b89cb121e152deb521623b749165c479b88a8b145f89c75c1d06e3a05b7144e6b9dbb4b4d3374ba34e53fff326e9fde5866dd0d3f1cc6692997fe85171cfb9d52498a65d68c22ba60b8d34d8d8f4f80c70c8a0925b9bf141b42e04df7497382b63d0ddab96cf0bbb9a16eedf97c3879b2774061da160a2efaf1b361838444e72b8d6774247db2501108c487fe4a15e534be5cfbf55a54a7ded2da031922344efca5fa67f6c32758f1f12d87ad558dcb26fa984d6e214d9c33878ebec478fdd6c00c3040e9f996a8aeedaf5f7818cf0bfa89dd42e07f3b142bc85c2c10a1e88c6c6db7fd55f1e29fff6836336d0fcd696456a34c0f323c0a9b50ecd1ff3718c7d6c8d448f21838674d0b1e38c03d1854908f12f4ac6d883bc35e623e46df4a13ce92a6430b172c314b2924187c92c64a601f60954156762445f8134e0f8f26ee20f946682ca46a1c15fd1587024e45741f4fc27d061ed150b76bae59545ceb30d955261715e551d738ff0fbe36e33484d5f2ad6582b93571a17cc76dd2acedd61b4f610d7d3efaef9ba3bda794cabfa480f5aa88a2ee17c04b52e68ac40b4ee7f3f39dff87af4023ca031b366d0f248291d6b4cf762f85b45f235d878f183e92c69906084df575e4e0b1ea7dd9b6c11d21e56085c9285658bf4b194fd28c3021933eec9c236aba9f7f3c8f5ea67d07c1151c19921bae49b743c32d39b6296b078dd4b21912d3219f8ccd80bf26f707ed9c0a51a25cadac102a96ecd0f62291d3566ef62869d3d1d8f8af0bf5cbec9c2c03c70f393e0fa6ae8fac02e1047962f5e9be36e89efae5b7e6c519ca8beeff6674a3163b963cf6f535ba6c59d41f810100752927f68b2fe070bb19d1b476d012ead1c46f297e654c4ebc0ce29f3fb1a62873a5dba5b7251e54ecde091aba04e06d317797d8826d7a34ea6d398ed54b6542beb3b6b5261396ad1e3be446dfb28449045511c34b995e23549bbfbb07b2ff6d3d99edf55bd0187ccc0244ad40d7fd9537b86401bfd0975ba0cbd90cb762982470637f266d97e4d4f9fe4548d4b885ee3dfc0c0b8083f694a4e2a37053629922d1db5c7698a377558acf48af7ea79e787088eab3eaa09caa292fde308811dd95a784106ccef29d2c70cb673f06b9a83cd78e4afd0bb8eb164bf49835f7d2377df6e23859f607d7948c43bbfb3b1cc279e7a1006bae28b25ebcb3dcdc06be569c301ce4c138c9ffc523fa02337119391058f64e9865d8177951daabb0074260a91ac00bc5efc909905799c475c8aab909e854865c53fe0b6f465a60098a1d37ca0d545a603aaeb4dcc84362b6b24bf711bd665deacc154b0c86a588bf7480b521879c4e8f7ab47db9c13f44f27e9b407a69f0dafc5d8b1c238b854ac80790ded5e2537eaea01e1246bed1310a17ba124cb5429a6591f38f438d562e561bf1c7f23e2caa070ce6a4a6b83e4a8b3d009f708363376dc36690b7125a69bd1e886f01070067a8f018f5c19bc42e35049c5bd09b9dfe02572cd155d4c43c3bad36163bbc4b02f7b17421756ddb72f41c66cd565cd7e10df7ae12f18a52b7aac77309acc605baf507989d814fad322bcaec30ad375ca7b0cd49b5503ffa2349f315c357ae22ccdb879e2274be976cb00011d077d2fa5a55e865c16bbaddcf0220f02dbbee9922f6167829ee811c11655024333193de211910a993708fe645cc50d80f257120121480d71fc6b8a9761cfeb844d595087976dfd1ec70c3a94cd36231865474a1d1cea1531524ba43f0b415baa1daee8be38537a38c081de2991c62354a236750a6027327b2df88bd6ad9080cff1f5af3760fd7556cb873af72040c3bba5d332c5fae48d23475df7f9f62c937be3232a93ede08d6399404767a68bc14f999cb4205d478781907729e09eb94db56d81fe714a29756386a90bb25475b0fd09ad052bd5dfbabad39002daf8b20d1fef23bfdf4211d18c5063161a4f2445d7caa74452b8bf9ed778550b032f34a72489552e8b4e72af85f1886c7d2318272e90bcecf1c3d1a7cf620416b25a7b6dd09c3283136df3d61d0971fa416c75d7f4fcdd676eab81bbcb3f246daf679295878fc3f2d183fb255407fd4dda0710f51657cae140454f96f736621e4bdbfe7dcc8f5e5e8b76f6bc37bfa5beddaa81f016d7e1c6c046b74bca68ccfcb6596b7285c986266a4af46f437f67be322d36f4353d03b3a1471b35c72d9b880e582989c260a548f3df1e302d74043f1c50b20fd71f581f36d2ac044d0a06c82489617207698573f94f30dd981ddfdeed63383cf19d3419c8428f3394136d1d2dc4350162b16387ecea5ab9d43404fd9bd18f9120c8f7620e1a61622a823583c27722ace086376c1a96a70e4167ce97441ad80dbc2d83b47b66a7cc4588a75e24a312c22f62d4696edea6dcbb4f4b34d708b3b499ef7c31caf04da107fd4bf5844d9da5b775fe4492d244b5309cbf03c184c9dff94cd8cd3c8451776ddba894a9d7f37577ad188cb77d429da6d76cf3dd388e5064661ba6fb05aedc700252f3dc20dfa58f666945dd959a149e324812db44a9f88acee16d54c5e5e149b9b5607ea2840465353813e0a4528beb9a38f16b41528de8fd44e32eb03fc38d3738fde5fe101064c5f00099a682ea9fc04c62beec4b17ecb0a5de404a16906945dfc1529c25a818b994ced53c62b8b80064f6d51c4006baa2de29029377d04d74b9db005383b3c714b59c6a8c4ab81572bfa787215d9b7fa1c7a5667f61c0d26dda301dc36ddbf5a7a3190ad1c7927429bd295650404b7deffb0911a776be624cf8bd17cf6efd8621c10bb62acf2d13e3eae9bd835e56610c60135c25e860e017fbdd221ba3e24fe066f8c03e948deadcb40294abc540300b1028a3584ea6d5eb90c408ce74e2deebd66123c91e83b892907a848b83e492187c4740c591629dbe0bc54e6171fc966fd3c99dc8ba78e03fe8f58f208ea2288807adc01f71b8df9fb6ae4f4d99ec0176250cffc82a3ec6fa84255e3c42a3aa8e9732d775785c2724a6144b95f1be93ffb839b75f38de87ebe46a1b6f35e2b597f6f07077c7332ccf2260ef83608581bcde9170e6dd597b84406d34e28ec9c59ac60ab5947247e4f7aa08d80bbb1847d6d6f97b0d707edcc850558f840442bfb325a4db478e61620a6b49a9d6447976df42c46b0d36ffd0c093f677b279f0cfa3b79303d90933b3c05116185cbb300e76ba1e36706a155a98ae1fe18069cb277671b5005655a66f890a49e3a6390ad77f59a368d03a6dce7934f68e78fc3895b0388fb413810a6e123ab1ce5f672fdd430cc1e651eff62ea759d5b4c6bf025ac7f95ba30619f4c8b2cc56a8d73cb483e3e0e8292119ca30b1c5870ff5af7a94c73237a69433266b87e037abe4ee2a32969420178705f3298a717d6fa33c4ca5abc62244d5138007682778d23527fb8693dffa9ee8b0cd98e7667c20e59485147eff9fb4e2d0aa8ffc718097ba2d09f13ef73d87bfe3739f4df3948365cfde79bb412ab0938ef5c5559eb65bd7ddcbb31cc763ba0eecfeee23e7360e7736f5e4e55c5c48ed64ae5dac369e41c572ca13a9e413a680f03c6d6769cbb1fadd3a3b137b3947bfd0c4707b5e5f977f855bbf8823ea9b8f8c0e04fe6a029111c5f0e7a21f08d911926aa6dce6e509529542cbbd68512daca676d352773ee4cc5a1720ac8782b8ad200dfe80d713030ca8bf72bd24a7300968d8f3c19b6aa0e9ba434874b8017a84ab894ee04d7c0e2a29a3794ec589246463c2612a9752360ba016c5197c2e37536dfa5355d65018ebd6f573bab1b917b8e62a11bb9aa6b2f000d08895a16f8c5d2b18692d3df7a145b476bfa6116d29a8deb12eef263020093ae22978d37d93cd0e56f15641bcc1d7bd924280a5a24452587e0f33b6fc1cd30696b1b019e0b821f49961c4f0750d31fe88145f7dc59e24b80ec0ebde3eea522ee4b0773aa61df9672ce4057beba1efd7986345cf56bb762b0ba3fa327c5dcc40aa4725c95b99d573d40b30cf4d6627903b444debe060f4fec63bb7dad049ca14a752ff192b8cdb6c7538e103ec8c06beabd01f1c1be73ea9155609b16181dc0e3fe1fdcab9c52788a8aac9e3d9695f25a6a25ad075479f1c7ef19447c6b7ffd487a8fa2007caa3c78ab585871cc06dc7c16ccead083158cee1ce0b593b6aedf5b9c8b2c3e4f19d8db3f3f0b88e4e8515d8a2e239062bca55649ac5e5eb74a0199d80e5a3cda906bd2d4af1e7daef51f3192a908adceac911cc8fe21ca582aa66593eebc6f3908d6234c8b47c0058ec4df268ad3fb4b1b9cb50215a273b356b36a54c453cfb4995c4335dd37cc33a882ebd51164f90415cf2ae5171565b495f443053aff5b814171a86ebb492b64a1982ee6dc3917d9a4de251737bbadef0d71ec6da7bbf6076507b8858612870c6c020da0cb492fcfdd68cc362364ca3e87c2efceae8386aebe97eb58cd3762e82b0337f0723739bdbd4bde6ca35410607b3b08185dcb2ff9496d2d9bfbe6dbf5c406482a9a0e37d2fbab645b2cf381282fe069478a03ba5424ef60be08f8cec61a5638aa19fa486ffd958cab651942fb1f6f1fa4e7aa7b20014dc2088245a560e1b6b54896ac901158e93dd112e530c5870090d4cc835c455f348d08d75403ce35b9a9fee00de4d5625e70ade890b669f40802b5f7b7960234ccc5ac2b7d7bf6397fce8fb8fa8b1f5a90538db638d0bd225276c5058a7be46563a5646f727eca1c45235f7564eb0f31df4db4d735c3e427a534993fc685f4261725674814ff1f71c5764aa75b57eb1713d55fd91119c413c53e42a8142389ba16c62263f7e1a14fdf5cb64310effe74ad77ec0e4c2ba96baa70639c2b375087d50494a52360528178f19bd842e5c32be60c7cb8c6de47cace6e720ae3ada6c4fcb5415943f76754806bfa6c2f0cf44731e5a8cdba0605c34a484bfa6e65c37ee96bec717eb878f3ea0fa5c06a9622e90c66ca2a4852141d51d43538476cc9d71365be9ab4b93c214d38fdaabc9b36570f30a867431be7541e69a1abcbabf1b2ddaae5cd5aa1e063ca4238337fe2006ddd578e639c6f216e6213b4c37d7773b5f2c60e7e40a108b8886b6b572d8078bfa62440d3d2d102366cc5e80da8f2cbc050d8842b823248572f0040cf527f49ad423120e918e997312ffb2707d20f4a34ed7128324c06f4cd456399e792dcead683924659b2b48ca5becf36b7118fe6b6f1ee2bb5dcae2a675953e2923625a2d06275e13a000fe54ab3e793a24c5b5ea600768c8005ae42d63ba6277d805b99dc7c6ab20ef39a7d1dcab641f46cddd99b81d82aca8edcf2dd13312ca71152079798782bff68e70ba454c2501a3b6a42e348cd04a24717b2239dcdcbe5107ab3833d981ba17b168bc4c993daedee76d88958ab6bbfdd2ba5797b8c33c43fc7fd6e155aba96e76138271b7f0af562a011e2a24a578f56b5d116e82b6b105b2b783a2cbc41e80ba76e07b8ee59e82a91e12e1848aa26bbfe2f3fd313a16a9abf3c1144248220458537d373f0ac8250ac1c2d7b8782892eaab45adcdf9db2db5babd3743c87bafc76b916fa245265d9bb7036e9b1cb12ff1fd5812f1c9635a2c456a92f63dcf9afc584b485ea81d9f432477c4e1ada8d076a0ec94f3e04e5541d12fc520dd9cdccf95f60cc56fbfdd06340fa89ebdc6792a0851a8754fcadf4852fef521605dc828bf3ecfabc954c8eee02f5e9e2cdc0d47de7e09b9f32af24db0575994a49c0741828d7fc288a8c42fa76a9b90c84e2835b373f8dcb91b2a6f3f2ba10ac5ffdb434b9da19edb37cf6e11ff76bd7e17e22d87ffe12a8edd0f04351b48831b69b0b2650d4539c7899f3e9eea0a30d06b68b3ac5e1338eda9ca8c2c8ee0dc51e1410e4f243cbe679ca356c646c9916c99d8348525c16d987b1278b87e08b47d206b144e870186ff61df2385774d58d93ac4a996b80e76fec29c44dc38d04323d26bd7c0cce9569a6ded099b358109b7b0839c88e23ea6f02815a3db9fd0d204b030f502a91f9cf8cd9b5cfdeca10d7306434ce827a05a8af924df3b45f68d12755c19bbe23d2f589b76d4804240ce75b95606c7c190841b2039ac96867d41eb3c0c9e1e91a74efa3d4079516e41a3483641bbc6bfdde05a0ab5c8ed34fa9148c2257a4db7b6f1f36ae615dd17eafdc6aa1bd4da9b1e8f795a9d3f62e0508d3b43820793dad81d2702d66f25408aac950d25591dfc856c4b99d3de17f909c1914c12a4f7e6f5ed4855d07c886a724c1f6086c98ba66a6919945d3cc21a4b192debfa1fbf6e90262df957210329e7be4a4cf184ec2ee426d59f844499f97099917004fa02032366b6ed5f55f150b3915f95a9a855544481a53f853d9d0e416d607ea911278eeb61d5243e6ead317b9030d2c34f254488c491680da489e24a3e68659c81624ff6fd05336ef6f370c3c5bc37eaee6cd011480d57358f2a458148419806df85b92926a8668fc8158301c6addd4d809f040da2b53c84fd9bcabcbdc960c8f0655ade21ad0c8b90c1223a90cec9318378a3967c58851a19d6ca16ff9aab2a81574c04902e003afd3dc5a0a2f7082a380896f4eec3296d1c06c5b166e7dc92e632b79995bfeb432c4fa47bf44d61bd47dd06b1e98e1a9f2a027e38e597184dcda3bb438d2af7e975cca862bf9b7754d2eab224edb61061d38db58360838bb8c001335c420a6306ff3a6f114712030ae6899b59cbe180ddf4d7740e91821a5ed86684526b70d7e6054fa9731c95f8aaecd091e6a98d8f3d08bbc3681ca2f6a9d9a8f82d1577e5834a84797e041342e66868fb7e4a563a122a266c6f379e15e3161ace816fd17cd0daff02cada3fd6e4e45a80906dea40a7532e6c4eb3dd54ed20a3fb2298b5ea59c33dc722b260928cb6544e0bd094e03ac87e94657380ddf70860004171b1218b93ed6fadd54b3be0c4b42fa475eebf49bdd4ee8c61c4f0c203c53a89845110ccbea16ea458cb91f4f7762a8f5ab352482cebc7d14ce30f7a772753d3d1643c44c99403490294cbc4479e196a8fd93f333c8e998eac2d438948a939f40d5cf87792515c8e6016fd2cb7bce3975a5702dd6c0b7a44c6a1b9d1d20b5f35cc74a88ab41dd89ee26a3cf84eac264db38509db0601a8825f37a0e69b31c0e424e7e9c0f1c9bc873c6d3fbd8a50c9741ac7147ff60b04726a3da047b55415c78fc6f142580912107a66f060eec1f4d0db6a0ef0702b5c8f8d7b4cf734e557e5123a04b23e37a503a13fb882a876354298cbe92a6467217a39a9cc66b2b8bf72b4eb8e7416d8ea419e1de3789fafb64b5898a95b1781078035ef8675d6838dfeb245aab5b433340d8a6643b02644bb4ceceaebea2504294d0942cd55c7b3d21685a82a0e0689da2b4ad83269b4a1a445c8a1d6c76c93aeed68eb60082456734da3252f026e2c6ecfc27a0c4228b050474b0229b07cb99b1d0139942db0d71510371f752c6e005f14a5f5e1d6e00e47039d3cef1a1ca3cfebb2529d6c4b86cfac9b7751b85de3a89978d79f283b31d7e15dc3b2637e80a5a6b608493bd10af4a656e9bffcafd427fc432b23e0481adb3480c01508f5631b59562793384b9d5a1c7aca72195f30193967f560fdb50538841fcaf6b47e494cd3eccdc66e90df27c96add7f4820a710284e217f9b314eec730eb8a00aa06b19d9602b2fec86c27c11ebc1aedaf797e83039d679fdaadbe1de23e874ef7238fc2f07bc033aa1eeec422d98618a1c97706812347f1db77387c144f7eaebc777942978ea45a2b9a2f05fe67b89ac050fbda078986a21236525ea9767e7c2717e56533eca33b82a566a175fd1a57f48327161b4b9aa9f46ca183081a6d1dd6fcc9c0b57e13720c7ba2f3ae5d3d60ec4e5493b040134e74179396c594176e7f105c7cacb4fdbab399de6893aebea334ca396b25f959a313f2c4cd2bdceb74e67f7776e88129d874eac25555a369b541332ff34b0809c6ed0027164a657999d1b2d4f77f709bf275f95ce3ef9cbd50da20f7928d69fdac9b77eeb66bc186ab368f54e2726ba51c345f9cb41ff9b2692a349b0392c5ea87c5dab11d2c87035eb72fed247486f349009caa7cd139b37a97aafe58a8c34273024afe0c7f1d840763db9f68641d67d60709113b86af0883c9dcf070e0d563cb832b020c748873901cedefe35f9af7435c7caf9a4a84f430ac43ed11dbd9ba9e2dcbf110298f9c844692de9256d8e402ee31a354344e78c5486587b32e14d85b02c65252eda4935b3f8500e92c2d4aab8ced217b18e8864fcb7dd5523ebcb202dad34b241f2706ba39b772418090b70e2f59dd3eef86e8c0af17a4510ee78c751663f64d77c5e83e01b99c6b856943495159bceae87bd829bd284fb5d40874fbe8709703858b877c9e7b9022c1e31ce738061e294a1432218b5b5ffd4d0e1cecbab5726a8ee19ede0d937cfbfca340cc8b241ae0f5455500e12196917fc2b30387c6481be648de80cc60b6d8e0bb7f6951711e88a31bed9484b2f284cdfd5d9cc2b9bda84245a44ce3b174ba3e631f920978068e2c17dc589f2b55b9bc75506cd87ef010e11f737966ae09592eeaa92d6deb33adce2f272ce4cbcbb68e7ee1e61365dd5ca329253bead786317bd44198644b3e27b6a4c8442ddf881f230778cab98d522fef65f169a0ef8f2bc55523d31a0e6de158ae3d2ace87aa44284329dfbc65092deab37f28df37c02bf3c51198941cc3c4cdcdec0323359b2ac7033930b7bac63c3ce7c20d4a06a106c00a0e8ca1d63a7e638b62ff9725bcda5edd20cdb34607775352e84d31fcfcc6768157b869e0240b256936dc1ba954f1e49502d12e59c3406530532f7f460f3c606c3d859d8b049e7d64296a4d8bd2f7bdb7c14508dfe3b8844db4f43d163189c3f11c1ee892bce880284de27003ecfac63282e178638bc1ec667a719bf60387c79b6663cc0b6cd8d13f2710f9386ffafcd32872cee80265eaeaf94afb3cf7332335f2746bf3b057f523994e707157ecb58504103b28691eeacb1b75432fdd9e838d6c001fe2a54abd4fa90156eb2e852c124a9441aaf8dbee7c420a8948dbe04692429479cf372f85fdc5d75f76d61f677875409a8a5eed8042b798646be43f3a35353e24a17ee5acefcdf151003f473add2d123348d711dbbfac15a896a626667febb571d7914f9a4b89ac6939eddf55b32f4a6527465be14060890177a3d4a8144f0b4d4023c0da80041c890cdb38eec98f11033bfbf348ba17d362f01c42a8b658b2a5fa6c26979b6ab0bf4cd8a38b0b98e1d961935a595e0f59ff3e523776964fc6334233b8a4bc6cfb6b94a57714a9e6e62105a39cb9946ce41640f56d4dfb4a1f40d03f79e4f7ef1e76655babda695d5cf1d88ee38486861f2ec098733aed041dacb7d3e813b27b2b9149323a4eeb6d4b2be6d0b90379f868540e5978acbbc0e703ac6c38292c1ba90bfbc522f9ffd1074ee7881f270958ca8c05f467a25cb32b13b7df3e3524ebd1c902b97c969ed9040a4e82e8f50e29265f3a8872553a1504357bdc35966f6ce17de60d5a8617e185cf588f730bad478a8fed2872aa92002523649941b7705f223bd8650cbb864ea10e652dbe66fb915bf7fc812a228d4298bab3bbd8a38cd4c223b45e3aa6b6c73c29ce1b1e79460a8cfa64cd357a6aca9e9b3514c56a4a52dfe6f7d4bc84ca12ed8a9d2c50b6f5eaa15edfaf68def3decd98b29a1d7ea550fc0a829405a93702c7e770248a4e02c652a3e3c91b52afbb8531df45358935b96a304f1db44f45b5cb40708281fdc9abed3919581a2a01ac9b858378ed594a27d18de954b4139cacc6e4b76b0906f179515938f070e209df3fa117c98c16736456b784a2e5ad735e7d05f62c3b36ebe2ea42b64fa5277dd605de038c5a08fd0288dca64efdd627e79f42b8ca1670c1afda2772f1bdb24e516b6a6863c4f1b2f873bcd89d19cdfeebbacce1ead4e45ca6e38f432e46e3fa3740ee9296bd5190400896ac8b1119b69855ea008c480979569f2260e37b10574d56526f7eb7cc7b8add38111c0672a3d5c7f70759c31b8eeb4a0269a489484eb92cbe6c1a543ba7f93294aea8602182f3ba137a09a8e8b6cfc4264f5db518e7726c77244c4fb3127b371188a2c95942232f2092b2d365d774c9b81ecd522bdc22a7fdf479f55dd108f691c995b89b7c1414bcdff27a9d09ed00eaac97dc38fbcf76723a203f5969b700fa577623b50fc7f299aad0c07c7a835230931033aa4e1f7ae8f8184d473deb6fd84a8140b31022ad6f75d4bfc5aa6bd523078b71cc0a7aad03937a45b7d0d88b4006508e401f985c366b34be6fcbbeb1d5d7a9518209ba3513a031c349d467c91c71dbb1306fb855c88eee10810a2ed19444c2d5bfe3bca69350fd55f6b9d62266ec06d88f755d168aff305a5b5df7d9056d88a9e95b8e83bfc35f20d5cb9365439ee3f5f2df62fe3c39d66d0205b232ddc63b518ee314a3cc541e3837ed0fbc3f842771c92edf6aa34bb7b34cdead9680de3b90a8a23e9af171309aef9ea2e1592b43960d874ec183b6ffcedf1e204e198d0acac4a074ed7547ca1aa6084a7756d6213dff084b8e346c93bd91242d444a94b1fcd4afc249914118cb5080926af8fd9cbaf12a5e60edf4bb6565d8abedc095145998cda8f99d9bcbafc984e25e135027eeb109373a0ba024706db55dfab782553eff15ba70989e542ff9344682f33f64675a1bd725b89b75c619baad21e7b10fe0a439a6d68f49120cb2afd12a950a442bd4d2ef0534dec8f77bef9d4a7f6e922b3651708e7f61f474cc3585a3d5d7efb1192676d188f33d95477fa14a819afc8bb37b1850e0ccf6e9a5dccc8f5b6d7ed2f9628a32dfabfd41038a727b307812d4eef752ea6c9e2b7a5893926ae009ef31ffccc8eac9fc04987eb59e68181d51697cd27733de0ecc729a32179186bd00ce6902e28f87b1aeb132b42f9a2942a68d81536260f8244451d3b702a70e5c2af854769eda352da0db118ed8928619be2aec564ba697cc4fd92f1b1c8bbebbbcd400dec39b9d852e6606e750e588799e206b564f1179b9c051e2e6ed962b93af3de28ed01179f28ceeb8e96f7226a65755784f8d364053eac71dde0283e92d400d9c2d7117677d365bee9dd5ada972e1d8c949f7e9136e06bae6db6983a28daec50e0257b5e5b0f7dd391f004d22b8154327bbd1cf47dc6eb0547caee38004b71a559f67022c8ec07dadb12eb93e93023a7508980003da1b75ffcf0133a7389dd20a234885f6bcc73963bdfda4aef06aae60887b3a1bf3144e82b92151752ef08dfd39c0d0c61d8c45c38e1f6dd09c373dd55b90c92de2998d1433d2ae04587b4ac93bc57c1b0b703deefa5cb0c5017b6eb75e1477387d1d8bcbf1d6e52013d936b89f3f00b971a902483480b0a0906990d01cb039c8298c4d591a853959d37d67ac14a27ed87127ce180fc8b040d02af12175d86f551f84229be26f3a72f14cc1e55e7dfee00c6fc5cfc1da0534d44ef2214f1eeb28a3e52915d74ae8e8170df68e4c9b05ae44486fce7c3c244d2071c5ab39edc21d6493403f5f53339f99c99e7f68e668dc61ba594861ca465125b490e230b17c28763bde920e6d4b205b3f34c2ecc89b5cca807c6747c6047b5c5b83d0fe1a54da8ca51aa678e0a579e395be2ad3acffd824810d4d2592dc3161d8fa662dbf6980160747486c5d165b7526140529e76132c257c9de2163e6d02e6c7ad0266742a4b3bc51470a1049c23a3eb4c78f1d0d22fa9f4c5724cab5767d7b1a8842b72695df93e98e027388792921102e21f4edfedcb0d88803dbba04ca735b1e0fd350af52ee5534376bd93175f590ef3b4db8cfc8fec78b1418a05b136960df8901d153b1b5f7768750e2a1e7fdaf69ccf55527cef9a04a0ed05f8b76851b188d5fc2be8f42b3943ee0829cad364b802e26c1885e7fe30705c5c9055cbf35dc1366cc4b4433003449770cda255ae4c2fa527b2b38ea679329ca23e1d87d3e2d8d51522a77151d3178e1f1c4e089b29caa6e4a7fe6c24d3d17de33df6bd723739c6c0f1a755e39e4d12880cfa4376a78fa806e419a15540e93fae051465bbb93bdef7ae3487779a07ee4d4cc138c8cd7de1860dff46885620697ded5762e6ca923975bd178dad591e59735353db99ac78246f0f30cd74a30b537361174d34eb23296373b866b3f2e23b83fa47b28280829fe75812186ede546eaa3ae14fb02da8d6d2bd1ce20f201793f03f1b873571c13e2292f589b7a3d19afa3dc7875aae03f3208c8dce7c680b331d2ab04c0a0201716db7eaebb41ad8415399e6ac3dc34f94894fb0b593b100df3ecb3e649d19fc206e15d210563e15cfccf01bdde30dc009ac39e46e820d30cda80690bfa98bab3d13a58deeca6f97aad764ffcee949b6fe2462db0005eb85241b0cf249a4fc07bd382f5232b47de869401c8175a9fd08f2242fd149b3062e4166933a5938841a80b3a8fb9121c0984f688161eaba4ad54a2104cb8a51cca0d2a56c8bf328b38f9157f2595b0016d3f91a02b6b237df3e8ad00d4c4c8b70aa9d1346620bf96162206d74b128e3306970111a48b69db30531d4f9ed1c81b20ea5320e7b2bf42759d7a5fd294c13987915a4d6134d62b6f26516844aa790eaa131e99b935c8b8704e1220f66a4adfb19e9e77bf38cc3573c04c6015db1bf1178ac1c965ea2e76aa8ae7bef1732a21190625c37b57ea34cf05a6fd22eac67f244904f12351fcf3be6f08eb800e42ed9a4d6bd6a82ca9919600a1a3c99babca8c2fe1bd9e301a97f461d219b9920b6ea5edca7427f0e9a1e218b9a7f35ba0110cf4bbe7597cc20a49e06ca81fef1a5e8675185c17719946082e0bac9500caa57ba2711c6b5f8ca905c4a13c10d604f33e02b24eda31c1936211f6d4557fa4df9b29a80e874a351620b812ab9caaae02b75c2cc6ee999147c95825f6d1f3ac82f998c901b3914aaa46e0635662a7a0053885bbf9d26dde34034192d387661acb3da52bf010b0371fa4512468b56c9d926749ee759afdc22ee02985054578cfe9ced14f31e93fe5dcee9e842e3a7f284206e79f56697f02e9290346530f9d211a5e017852b4c8c19d70486fe7b46a7cc85718464396ce554ff467ea7e62c190b5123fc2a03a32894c8ae34720294fa0abebc61c0dd721730145067246789de4f2827eaae2c418b426796e7c329adac9d157626b3ab8fec9b9f74befb3f4fa38c2afa42516dd5bfe40a63c8a20f8e4a1274df32e1d9559ed2724d67e6c9ff7bacc6705cf5534ab9de724fd94e6e628cd05c2a5cab5f7ada68ee598d7889e8bc0221759e853b9d35fdce4acbc3e0ac129c0f0cacf5cd73a997d1c8a8b414dd112e2a33caafe14d226a1ed7c18a738207c68a14731c97a20fdffaf9a4aee61b41a6c63ca9f4526d81870c2def36c3cc583842a4a01ccce2a64047706a559683d4908da67d722b805815ab83451cd7fb3b0a88ec8efd6c64951f228605b8ea391cbda2949bc4a2ed31bc41c272fdc89ef470a94d0c8ffa9c24d9ef48a0d50a089bb6c8cc0769d66c461fb75723b2eae5d2f3d9931a577ba76dd85dbac7120fdd189db35ee0b9785f49299e82cbe91939c5062be128a24bea1e47b11fa0a8f3085e4ecde91ffaa663919c5e3417c8f953be67e711f9401cd835ba2d2d16dea2367091cfff5cdd68bf1ab825fbb78701eb17dbd1d314b1ba0d7896e2f0ce8a8dc5b26b546c8eeea96f4280d4fc0dba2651a8a9eaf567bb60a89e441d53c90e4c896b28a1b5bcd4519a027db1e52162479d0c7fdb270f2b317513ca61f76a7b531cfb6ca7ea2f6b6121d47f2ea7feda4f7d944f58de5c07d65e3fc3146dd12d78afe79cd469b76d17cbe10f67fcc90078c10ea3358ef6a40a8e8f82f31","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
