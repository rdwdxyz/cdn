<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9bf75c4e95d8a78d2a12e038c01d7802a401eb22733e549797d1e83ea349cf2ac43a631a4ad88c798c61994360717b024687f25a883415712ee5f51714aaf2339c56c30dbe2512ad4b2131e229ef0633184aae3732c55ff7351d018467797f8263fc3a4513a17b98362aa129f7e590fc219027fbde6179299f3ec4c7ec3833b7914500168153acb79e49791349a91844e0b52dffb1157d443381803795d78721873421fb7f51c6a452750f557b749b04d9e5f401e9960b7552ebe46e71d78a80b32ea0d64c6203743f84b73bce89c06ff2fe8b0b6f0b51cffcd878aca23cc6556b5e59fa7886bb5f18764128c9520e4969e94eb39f311f9cabdb820e46914991246549895d6b694cbc67f308e001776e409cf94d74364ed2c4f894b2fa7a1db5460e5090349ae8b38f12115dc5aba76927d2b630e07eeb737687acb815d4c61d0f20cd05f1d499e1c7b3d3647db7b50b835d8dc3db3a63874079533b8a44970dbf4ba915b9b0d8702b09ff592a71a4adfd424d2986039069744d50a1a33f0f9bf2ee272139cf0b8a8902f509f9df83df98077e7b3598ea0a591d331646744fc88622ac1cf143e65abb9fcb95bf16665f4bd8597ee5acd0ad2521fc81213d0855009a64068f36f229cd81600d732960118162845707e845d8e770539a2dbb50cd20907dff0b03fd3f826d47cbef4fb2587c4496fddeefafffff09ba2bd24d1464f6312f9e3c08b104fcf2e40e1a54cdb369269e6e14c70384418f196bc0ba3a128076cac5fdab6062da2f3e9731f3f4b03dc8676770fd4194b00fb9733e100878b721813902e434e0faac9ab5e9f7004fc15ef2b43e20607421718b649e2ec7925410a9bcb085bb5a5be6e7fbe16645fdef06304ef674b26fa902549a9fa5f480b0e4faa75fdc72e3f5e190aac2cd1a957ff1e96bfb5df9bd2488345c7c8c5b76cc19e4dcaa4cef96a49cd9f06b3a7e233e5b37c87936d7e1d4dcb3c516d9a9d655cd622f0ea9b4dae305e7f93c5aba7fa2adf2eb7b2d4b7cbb2d685012aa8c494c8fe326301082bcd92e43639ef07c93e9ed18b5b1d12b85c1f1c4c4f9e1b7f579af60f8897b9d7a94b6f0b46d8bd26bf94c21a29c56b900634a2eafae153216aaf5bdc92ccbe705701dad1205c1d91aa3406c6160e5d2b16394332c661818dc037847c3301dc5748a2a4c6d6a0c9507376636d22fde5f6ed95675adb5b0ac3893b8b5540e1cc91d7f01c6324d623c3627b8a91dff93de4b23e487dd0e11188d8cb54b2a20b0384d9b9bb01e4a77d3a2cac664e9ec0bb3d979fec6c40a119fec3423cdfc3d150bf6993b9389748f840bc88474518f00d3eb210f83a2fb49afdc8d5dac65481debcea6b79824639ab1ea8f10afb01dad4682a054654f4ebaaffd1797a1e1b702d57e2713926aca79ef8cc9ca16678c84c90f8ea157cdce7ca46e65808195a43f257abaec5ae812ea93f44226e871f7270af0f4e70f51390a6c14c8c6a162af87cb6e4f7d874943b686f335643bc99046ab96cb1704396ad64678c28ca09adefacd774202ddeec2a4e7bdeefc22a5ec4b3c6bb62eee87b91522e593a727d29017a2caac30b857565c07a031bf39f1f637d262c1d11ec1067a475e43938edd52105c219f8890ddd8228782f989e3a79270adb9d8bf966e947f501254477f4b81e0e23e1233076f64abdca652b396325ae884c965bdffb6b7c47f5a30cbd5de351cccf84a8da2f316ed11a5961c90309c1014d8dfb168fba5b823bb6ef61db672cd96f400af6e3f908d429248d58f5eae84a5f82657a9e418013752edc19518ba5c3c656d62b0b53b5710d0d2d6df1560faadb5ba2b45708acb3b8906a84ddbaa4de60ba927bb3486ef87ce7a7743cc7141824396dd3b66f81424681f9e3101ea7b3355e3e8ecf01aa75c564a2cd96fc75632b26cefe6e4c20998725137496f072f856b1d1dfe4e35fc5416168e69daca47af947dc2a03887d29b53f5ab621fd8a29dabf6f0393b8666d01cc9d59546d67d49975a61a17c0bc99237c6001b466125aec963daf37ac6101e75cc745b92be2fbf8748de463123b1a373227a8e74fc12864a27520e903e749d3e79588137b16b2d1126f190f3d8a6c4fb7275662d6f924fed717c94759575f25cb4a411f14be3875690e6b305a345e57cee92fe57722e7744c03840053fd852b72d0489935ade9fdd293bfbf81d5ca679c481bc2573e6cd7a505d7ce5474f17c7a8baf42b4d30bdeb8cf0af11abb66195f4ca3b2debe226e4dda9ac9b527a12a9834cda40bdfb48c1399dbd78ee21bbeeb59124e7d02dc311837acb602025dbb147c5a699fa21f6858b0b49f45a66c729063ba1c3a21f41a2d59475752129b2fcf173f243621043a023de062b44db38852685c174dd168b5036fea51d53b1881a42fe473cb5a495c04a102b2966428fe11c402be5c3fa7a03278eaadd492a0d0dcf4350686588b281070d65b86dbf2378465371848789ff20fe6f8e3e9cb75b348c63a73bb12388489127e1fb79271d21491134c94c34ef6c0dff1c7513073d297ce1668fe94516da5c05e43ac38949688dcf656d89de3061b0a1fe6e5ea3e5f487b0edeebf4e33d01c8d03af65a7c41d9dd7cc1e253d3d34f82443a0394f7c0d52fc9c5601f230b1791e1fd03fac92e06e05797b96f873acaaf02861b9280f59aeabe1b1e56141c3e14e708e2d7e82903971ce4b2b687821632dfaa0f7c0491c5fb49f62c296e5b512486fb5e31c413d093d22f272d7e9fd7c0f18cce595f3d23e43a51fdab829b53b6f11b914b40c90351c74f53c0b6b1c708ad584b775355471964890116d747b94cfeee3c7cb740887cac6be94aca8898a4b2d2eaca1f2a6c6d450d429324a0636c6d1899e09668b4873b2579011e6782dd1eef386d3411047b372408b573e3b93b70709cf4c3d2113b8168112a46e85348f1e7b5928903b306705577c1bc5dd241d22270248c859d07267994aa32655aab6bac3ae9c504c155b5635bb12d5bf6bff65cc46fd4a75753596432ad28f62a5f8f8e71e2412113102fe609d3d98e327dde49ff6cfb42be3a3e513fac83dadb10d617505bf62965182f0a92b593a92ac8e0943228fc2e957f733dbbc199ae8a5ae3760225f6bf6128c279ac2eccabaaa7d53f426ae56aef48a32bc7bc185a3d7127efa5908ebaa78e4641733e3c27c845b70d11a02f8ca7fc174c92f225d9b5744cb2baeaac0ad059b3d535613abcc463c6eacb15fed94196a16a12936903fc9a04ada31acb10993577ebf9d9cf8cb0e64eaaacfc8efc847815251ec5d2469a869356d65356bdd644f84db72180e64f36404290b53cd48e69e53e2685683ce2265a2d70a512991c713f446cffd030a379c1c4a7adc4cc2ffd3bfbbc83f500eeffbba6a97fd05ed12052e514c6bffa760790e137e75e1f0179d5b64b499353ecfd45933082ec1799088821f1ba968fd7391b1117ddb860ec5e15d1c05ab551b5a9b9407b919710ed7c5e96faf3dd2328064103ab38f833a02ea6c412c5fb1afcf2cb96e7b654a7191d83967c8b34906d33c910963efc291531b487d4b3e63c91cb76fe2ed93037f856a6389d7229c11184a0decaf05a95ad2f697fdd37a6cf8807c3cd3f3ca7cd14b56222752433a281b7a50c5e1066cf4936cbc2f4e2e1794d0c1835c0a092b52fdfaedad731ea2eb2d97f1c33993041e34efc0b36fb8225a5d17bde67b6d1860c1e200f20ec43d25da52244431e27e7dc7418a13ad61f6d634dad4546790c192069055ba2746d625b815a4d5da497778fbc86bf58120f256e77d289fc4b91d671e6fa28fb092cb21d06c06ab2df82cef16910f7c07560371d69a36e7c33f8227e3255aa2b88b5b54d9dd8fde5470fcfadfc3c6f8a33b7d525fb31e374cf62f0e2ed6e1e0d1dad400dd85846a59b0574c3d02e6656185a37ab8afe47b3bb2b9786f0c17bdc1efe34cd540a185225e6b3c0c5ad363342663fa3332da35ac679e9d33e6eda04a5d624cfb4cbf99c9fcc5a37bf37a91c69b20addf4b1370ed3bf3625097810a0d4b58177cd288df072d30d6cbc41549d33210174db038b88e92db2b278a282f35fe7b6db655473764ea4ba756817363c2c3fec8ac7807bb60181746500b600ed203b5143a8421bd9c605cad329667ac1c856a7d996620838a82ac8c53582eb36394e5eea9d692be8c49cc50075dcdf4d38defff35dc2309f947db7ebb7822bb2a2c2f40f068d9ad1058e62cf91f541d87fc2f0a543db0a5130d228ec188c23b08b755f6ce645cc547604349a2b6edf06f926f5113d1c304ce4d04e13e6a52a349decc9c5af92e2a1aae4383ca6ef95d4b7a33950d38d88a9c7d66515f45399038da630c7ed94e0c536052fe149795a202639fccbadb24c6e0f5a875136987d23da5fc08546bdb4be77049a2f3e7a4070f0ebfdb3e33e747664d0e0671c8ea3c050456d882bceb87861c89c1def970c4d60954957d2c01baa31dd3a06fa5e87adc4141d8d3fa7368423e44a7c7b063fd820d0eb425b92345194a0fb84a777250cc9302bfed934fb7cde394095c0859b08e1f4a360e8095f85b5e8ef3d4016e2aeccb3719a8c4cd75c3b35492821ea66341d5ab714a7ed21b6bf38d8a4e08623c5416af7647595e0dcd34bacdccc0a5693537f7225a552d9e4539008bd8ee4ef31165dc6d166dff7e84f7173b3787c6ec04256bd7cd1e805a3b087d9cbab7dd333ba06224cc3d00e910b01c27c21578a7c0a77edfc5cb5b9195833e02f7cf598214ad450e97aea87981b1980c592e20710b877671404461a94eccc1302100bfcea4c159f417ed3ab3d0a529575b513498cee2d2821568ba2ddc31f5530df64633252dc53bf44c4f27c475bc933590322c55652d2898fefcc43603a34500a0264f67f7154dddbe002c9192b6aa3502c72d475f794bdda9e05652bd978dac9d4e1859017145f24033acbd98e11d2c0d7f2bf768c725dce78f418591c49837fd0dc800bc30ebb10136af68d542557988c135adb37807ea7ca88109a013564080b590b1e44d19d739cf8893bea37f68e4068ae298682bb723d8a0984d2863ab9002a6a6602d8a25945e1de5f0f2831d9edb0d69c0e8574577e52c2d0f51a7ba9a4679539f7757a11e5d9e7645cdc7f5430e8610d340debcda68a08364dd4e0d146d5afaeefea98a45566498e385a0edb1afbc8ef3b90abd5ddaed4f55950ee8dea82fb85fd226175f6c70ce8e9995f2a4727697d5f6388e006109e89e1c1c79aae0107bf88511e3faa35629ca91a5d4e5fd5c91890d2617d2334e8ff01e16f13f98aad42f69d7174b5b272566d4fba2f2870f82700618c402aebd2d94deda13269f63d93f29dbb26620bba10d78d5fb72799924e7fe61b03a75a3472128525d09119ba9d06420d6a86350953048d9ea7e5391b0d633455aedcdcc45e8979e205ff552b100930f588a63246c5d95f496051559e29e8c2af98ee169a7f88d252cf4d03d9407424f2a2298f866433f496544f2be7f4bc462f5b4b7394b30ce5dd9dfd4faefb3f092242aac0d64bbb0761aa100f40411ee56b06920f285194c0a5ed3109d7197bddc0727525f3fcc55f6e162ebda49615279aee9924ee4345337eb24d2fdfce9a3770d5e3ccc9bbb05ae8019bb8485fdf63fff82dae2b287bca0755f7ff528c66a2083d3a998e4a82ef3ab49fe56836009cc453a88103446482d0168916cfb792da6d8cb8016a9ed854a3fbbd5c2cb04514ed11cfd4c61e1c6151f765b5bd94533f619e03cb53b599cf98e25c8bc4229e57111e918b9ff78535995e4c699a148019daab053c9e2fad6bd1051f0408cf9ddff1fb953d4f8a6e73db2a60f1687699a552971fcffa6654b75604aedb3c74213b1e9cbfd175cc5a543d1b020713d6fa4c0b3439585245d915581ddcf8d91cd3675639d4ad7a25bcf7d3c4def80ba1a6613fde953a0fdfc3677777e2228313e43b3ec5031949076cbb40d50552cf9eb86c50e7d253903f7afa9d633aac19a45a768dfbd2a8b7a360f3ec68960ed5d0e9fbbb2421e3f3aff8456769ca1e8794fa6498024d000ea092bc2ffc00ff18be635cde46fff5cc8bef2fe22e73a241756ca2674aa19841e380f5d6dcfdf0007fd19ea8710c55384a7c3105ddacb5b08ce7a535de816ac3a9bc52fe984c94d9ea141de605abdb76718558598583a220fa8b9b303730acdbccde8c2095b7b9fc66e41fe0a08f751c654dc1a794100053ea2a1d9afd7a2bb4841c574c3d3bd3e6bf0254fbc2a58cc12de618a9de572f574138230a85e2e451ce0cf84801ec3d4cea6cf871b986d27f1311de0ff5c5fac4e99bc48bb44aad5fdb1865d07e80f1b530d3cfa95b9cd5a8e1f4bc5cf2c0971bb5f661451540bb9827f9034276ec685cd530eaca1263aa2db1bcfa039597c410880035da657e682f8cf862a6e86ce2cb11597ca1a0982e7b272afb537dd9c25b80ced45bf7866deb9be33d3f70e0d1c5cb20d0ffa2a69f1ed7957dc952dd0b1a50be92e479b187ad222dab94341de3283a9c7165c9e782a7edce130ab734ac5fc0e0953837159e440fbda915a50d827d3793f3fd0bdfc41a863b215da0a329cfb686ee2b50deaa9ba3e3e2439a4b2859936fb4c5876f6cedae7818f07427196bd8d1a811efae5f8fec5708087b2e1e2fb0b58747c2fc6d69bc7e3fef98eab999caff162199ce6a38bdbf92df98fbf39d1e56234bb8f1d644ba1cd9d8277625b474199c52a3b562ea6516dbe1331c8355dc077cff6e40a9dfd540d94d6a03951cea9ff3a850a4de04626e9ff9d020621f83d61dbc54cb9498dc998c2ec7e11c635a0abe1e9d165d22b99691cf0020e096a892c2ca4c1589556f1b1cfd9222a2cea2668c05bf22993cf510262df09c028cd8fb29c66fa417c1129d9ef5295c54c9cd4f2b05d57a8011c8883cb4dd2eb1a194da919ddf3e8f92a09c9479fd4496697b773d94da35920facabb15098e77327a66b1bf7cb88c0a5bf92ec33f65e9d3948632d6f81dd31511287546c024e9a465abe472b9ecf02532957a949434a7e6e5242b1669c4bd93a4fbf2a444484f02a25140472a5f6440746b0adbb23b7ca94c86b475a7161e13f0d7b6b9f471c3b5dab1b313dea4327dbc6773000a9b376fd7d249b34ed8914c7a41a9787288cbc3be0e3b1e186278efaf3f35af0dd5db5b719e644dda30729cc238d5010cd6de085b2bca16f68942cf3f9611e7c7f2e82c8e2befd1b655d2102c3f6e77b22483bb24fed9371e2824d748546d63da9e5e358ad978f1c57822a0abe1aee87c81514ee463aff5329cb17432cb81fde1389957e1be8dba52747c7f50e7eb72ac9a2999e0dc89ccb2e4a51bb9604455f051584efffd17350db86cc867cf7000f356fb2facc918b784ee37fdcf93751e16ab958b8788374406ac447150f624e1b745b0f8c1653240e1cffdccfb8f8f29e8891ba0c3bbffdca28111af4bc5565de18bdfe9dd17c736fb26343b41c791a6af3339be6b2a6ff172fcb3884d72c35a283b0e4659db9c665aa1503ac3b1dce8b3135f8b133f16545c6ee1074b990dfe675d07fb68bdea52cc4ca3441bf78ad730b5454361ecf89d66782c27675ec319aa459e39be6342b1ddc5b504b036233b1af78e3f9e2e56ad9bc33f89f635fdf8e5fe73858314cc90797c10112fa21b1ff385db2eff40049a86074b87764d659de269aa0852774605615958de9095cfc28b63c93ccb336c5194d69fb86076020625ea0814e53663c4fd01efdfe926ccbef6acb4e92d77df290bbc2ee43916799f0c76a098ccc91043237ee9c9386e0afe60229aab8134cc1d4b3e77c497dfcff48801f4184473b9ba7395dc25dbd9fcf5a010badc9dbd5e4fc51e1b29a13713d55a371451db7abf8c3e744363847e219275fd395452224a06df91d229b2efc7eb0d8d25b2b18af022074bc3750ccd4cbe7be45d6de97fa68cf988c09eb43bdc594f05ea626c69919a45fe38556e3e8a9fed949b808da130b49738cd21f4e2315a7e63055a3567056fa3bb472738c4ee4c36c868a685ee8125055253487bc60f7ecfe1f19d2c38e291e673d0ad59cf4e57ca6fbe6a1dfc38fd32b14ca2f36bf576e0e0fd2d8011e50639d40aaec45b3cd44c7e86dbb37769adb6c0a78a1021f0ce47a9956cf76469f2d47552f4044045d2c1b072c279c6f406acabff1f0ec16dd5cdd18b033c3210bf8ffe91962c703d17275c96a0406dc904b76da42c977f65d6342b90057d7c5ea103592d9a329ced19cd936af2babac6b20bf1bf8bd6af7bb6687550ae53c96b625dfeea14b01a67dbf025f1e6b71812fada6926fbf3ca308750e2f1b6a9f8a37bd6d5c0e3114e436766ebf2bded51b3dda9de8a91f70c3f219a00fa752f16420d5b1b0175b931d78ce791c015bb14d9e9c144f125a1209944a2e31f7fd0ce66e42568e5edde18dcf9dac30429949610cb5f5eb22d6e00a2949f3a1e491ac9bff04b014af86fc7ac1b8de2a29203dace4eb0a0f9370b768e378cbe1549d7d4f171f1556b43e178314297d9da8feaad4179c1a708cc5c8155f775c46745e88797be973fc74af7f08735a9e18e1d2f58d9ab71f8cbc8c580bc28f83a583b100f624f934f3833c675b70ef6972c3dc7f9a4794b314616163b64ce38ac97e1de8de2d14740173f3e758b43a11f2f034bc817581d251360ab7f410808997fefd7be0afcb2ea69a0f00ea9cc3229f64630278f9105dd8612f41b530bc802ad3030be672f2e24249989d302a1be0d6dbc2206e78c7ecf65fc0ccff93859193d2aa108f811a32411ef7a9b1db78e100f67422730edbf116f6d4877b920e97e588de24fb1987d0438982265b067d64f4bee05db9f6e3cf6963780ecadfba03a1ea9b0681cb1f1d44665733998034f8b33bad17353109eb3f1e519cd4d0074f0873d7bcc929df9a37788d6697e2cf98aa9c658da08764423567d9e708994cb32a33bb926d928a3f1cc47d094d83c8fa7646a1d96a7cfbcf72661fbf2b022de0b8a3792704c63539fcd7e9409bb260fb0fade9b0af14dbccd5c8f46070d47d0b747682ecb3cc2a6909c35bffbb104aae8bb712be8e567f6595a6bd18963beb0d80030a27f80bc218b06c690788a7d2582af938b648ac52fa66299acb0c4048b45768b0e193b6654d2ebc03f4dedaf736a40d46b777c90424facda9c0724267ac5f44728b9078499d3da9cdeceda0ff141b130af87cea06c4182a1a615646f48ffb669119240bc01d7da2f12648b31e287ca571719c4f58db3b8744339713d6139fd95663cf4919f0d90e53f7fddf46d40ba2a4146d8b9bb2663c02adc004b4967602e15fa0753f1ddb1c0ce820fdcf64f4e1c519a21aa9279e866bce4b7efab762cb8b686ea215705127db4a8436e89e9463eef6edce85542a369da5206d6150b133b4d24650f1b74ecabfeb834bea5bae426791ad00001fa1e3ddfb01eb1bf4f36ba61ce164fdc1df988edbc2a45c199f9d5c2cd06ca19bb1a9bd6569e127111e4aad14b0a0138971a0f816c2cdca8da358252bdc765c1308e9f055c163ce1cc2f1eb1cc09b9d9f8a2a0f9d3111ab4c0953fe0ff7072674f23953349a6cdbc9a4ee7032300f82dc90f8942f9697ac3d0dc4ebc33a90abff79deb955b91a4f9957852a917b3f1fe43b6208b2c4a831fbcfa7eea28777e87fc85ce0e2690ff10dad56d0600594a7c515528ca0ac3439d2aa086aa089e81766b1bd3740cf3cabf143dc57bb94dc26bbb908bd3190f0720146bc71c6f4daba22018ac5ab2d6956e5e1f3b590a64eff0df8031c4ec3b050230555bb0e2b98b30683f472d2bb5228f100aebafaf24aeb8299c0fd166a42f2de29227bf829761acbd27da4a6d469953e92b02d774773f8b38816148d864f59235a3afa61fa27ce05e0ae4e6f54966cb7ac8d74f2a3e1c99576a98ae52e8a7f95af90bafc5e740b3b6afa0348daf14cb00f59a8e64966a000fc8d6c6c905e4b1327a22940701f3dd55613de5322455a46d7db3786f80e40b8cfd7a0f210915014d3e569d6888046f8322171dc81c9798f6fe5a65da9548a8a905a29c3d11d402bf03aca88c22c1d5d0ffe412ebaa26147764ff69b3540834d927cfb0bc8c9ae0b333abddb2dc66565365b9bba95a48d0c291393383c52da98a75b21d176a7df0a26a7e2b7d240820ffaecdee1ed01cf453e1a8f4c1db2ad66071e83f44997b507506a42ff0eac063855fa6e81c393f639c8714de7ce4b0a8d472f351a656dc0edd40fee71717d296fcd3db9a7ad89b31ef7b6467006abedabf16ec02651dca3133ef20a268c25a37683cc14e0dd69c803859fb1d5e9361965426711b18e64a56c4f09642f69a891d35c50e020ce484d90ef1627e28f4d2beec630647ecfd0b3df75799f2c5bb02e2b1cab0a20010e6a16b84f64c75f86f4902ba06fed4722644d54d5086b9b8f88c2e0b2aa8edd13bc04870c4a742a584a144145d95822f89766e8ef715e2f9408a1dc3f87fe696446225114c1b14021d46c782315526fd79c21766b7d671124767d7636797099165338d39aadabd0d1b16e0684949e86d72ae1a23a9a692f8eed5c74917e31e1c52fb47198c2b6baaa880d235cb4852ab16d2b4f0848452000f14c41addf5142fb649852df1439627fc02e9796668c3c8a7a2b0524940a34b339f1946b37ee9ed72d5cacbc30b1ef9de044e0ebbea0b304b3583701ab1d3f464b346cea6217fc706482529eb5fa36afdf3b0a2aedabcf80aaeb438b7b75d07b9fd4fbfe39d060dcb6a5198e3f9cc49f9e3c0bdc96ff29e67e68c7f4de9fdaed19a9dcce3a8f4ae0ac1a887cb628c5630fb70dc88fd2a2352611ae96c9e0798f29674a43098a32b8226ba6f7fc5759193e1bb894cf6ad931b77b21efbe9caab351b5d511e0e0a8161582a01c8fbd22eb21349bb8cba951f4594fd3266e3c7eab0d0d652cc70760d4a34a1bb283d18183836f55d8474f85bc1fa3484315dae43f400a98ca79bd9253520a32fdf245bb990577e23296772b353dc127a6352ae3ba69ea373c4067ce8b4ee1ec4719b3726f35d3f5d12659053b0474f2a3f2ae0346c68e51b3d65340e1f85f9ab20bb11a16c5ae12ee340c026ee8d9507c0864a717c1839064080dfaad739c25be202717eb6cfce7646a33387603fe72493f9c12bb960cc31906993d8b03dfacdaf9b0dfe44bb71ee5f585f2013cd04cccb1de16c90abbe73285ca95511f56d24a09f3b3100b5a615bc6b974be5f58891aae21062534c172c2c50719dab44c4587f55ef881eb311e3c3f90c021bb12379af3045b26d79432baba9c6d221814cb7cfa75729b3c5f3081187e66b3328a4f89bd250fef745d10af0e92f6186bedfd71a532edead7c0ddeb9c1b00495f2478609632b52fadc8e56cd090fff1f61d4d34c2df3ef64b54b46239fab6bd2ccedde048f19450c5ead7f2151e40e2ac84dec229c55ce69ade958696f5f8b3fb67feb20201e79242cc218cbd30d9b0a2e8478f51c6c8e47ddbf8cdd627db47bc2f6634893b3d37d81d8e763e6f597f8296126d04df592179e1f6c12a30445794f4caa2209bcb341c94fd68256973563cd6bbf8b57f9c5dbced40d67287724bdbac63b63adec2a1818721ef4aed23edbb5344061ad5a7b71aa17a8963e1dd6d1fd94f58f9a5dee1bc81ca4f27c2ccf0cec59e5f19b2fff4b3fcadd46d848386c07c3fbd1fb92a9f6b1abd1ca23c5addb7212458bdfc6824a42777ecc471d19bd999676f3c281839d8887d7433b50971bb97ff008a014d8accc883e366df0ea3ca83f2ad1cfc5205f83af6f9f433f1bc90c5a7a4fe277b7c80db32768ccc39a9ba7d4033428c224b8d0ac475b261fd772a4b522a8113fab1be7da3d928e760922b84968ec2adbd9ef4ee808b7f71a129c038ea54b7ea026566f92a15addfb83d62e2ff981fdd0424fd3fc0383a7e2173be9f23a42b930288fcd31b1ce9d7e324bdd5667c2f7de73747fb64bb866c32bfddf612a3eb94118e6e49aa534b99c48e4a614f8dcdb69f8aa598ee13a8b70841f3700b4d0c5f3aae3d6e3d3c64335f9639af3fc58235df8c5e88932412310b014bf4da1ac09ae90d0494ed173bf6a57c9faa157bf4989d791ceb460681711b965c5bdd9ef9c6f8446833ef53d85afac6a74d69e8332e0abe9c95d1a7cb02dd171116c59128d343a0abb7d46062179099c987fc9e41a544921ec819ce695eeb0fa3a81f6def1f78e543ddbe6b2a76ec2e9425c2020a8ebd48f46cd27026514a3d75491faad818cce644d601c78f17f503f41b66b87223ff7077379591e5f264bf79f66faf2e44adc736abe73724c81f639cb665e6fd1484faf036b3a8d6e55824b0b543080f2bff7697ce51b4272883a835b9d244746716c96096e56cbd422941f2817751d85e78fa857672ad3a781b175297783ab7000325a54c74d75db77e601c228d501b3225c546f5a61655e4d697e116e4830330409d8884ac9c7c4bdf31d04c279b41f9eaaa0976a19fd8696c9413b484ad42a010f9a66c63f3ab9cdbf32414ab504e6515c5efffee63b25542d08228f2dde90568ab6dd371e041c7b3481544749a101e6e5734d7504645a6a2ac0983c53e26c141f5b62db6517ac144c2f4da5bbda93a1bbf85f6acb03ae3caf96717c998ebc59c68f2fd3296f290fb4aeb869d6f4d748e16fb804048ea63efd2278c5785c7998a878adafa167a0d77c003ef5364f54b5e54cbacb728de66d146d169152898ad2e70a18625e61e4b0be2d13407b6e624253e368dc6aa4b5c590d866d0bd2b3bb207d8314a47f6ff01f70119812787208ef9ddbc015bb99893a65ff76a779c03018d52bfdcea938974a92c47936e41f7d7ad1bb5daa81bbad65cf2ab49ebe3d2502801927626fa243ca92b2e5a95583c09765551cad1a272ef0ca54c8f3da3cace75f8fbc78cdb36ba6098af8779132569ea2e0a9b3f92d44305ae9f854ea3ff4697dba1d523c79362de85a674eae16f2db44b3ef70a854068bc84be71f2f40eacd1fb7c8a06b3cac0019f63e1f3a52b393461d2c64cc58fc3d055b9220435da5ec968aaf1e87a17ba9d478ba31f0b1fbc2861102d17cec222d7855902c7872931133e161d787ad33ad0d789bdecbdc2c393ff4f0bfb77404b0473115976feb818bf1c97faa6aa64e1eb979692ae8ccd7380853867deb59991151f2bf28b79deb5ff012e9bf1c54f3be6fdc275cbe8e8d47980e565f8c50bdc946275e98f4749eefe71f26c3c974a875249147bc58ab8ba1ff25bcfcef7bada6a5e68ee2f3232130446011d8b9c0601fccda21c4193c927013d9b3d9ef7d8865f72dbccd12de7eadc259507fe62882d5640f7a76cf5ce1ee73fc6eef6e115fe5a4431bb0dc1964179f49abe333f7cadfcf3f4772fcae31e416149a37632dab71cb11a09b6f647ba60b540e41f671c7f4d3cec178cff67f12ad24a6493b67d5a5d19e05d91c128519eecfce9765c32d0fac6868fce4a2ca1d985bdab788020d3fecfbe97ddb16c7fcc50fb42c73d620940de2ef31f13c0fe11a73165a32ea10dbe15895c85b96a46be3d540212e5afdef45176b35aa7226211c68b08569b0a60d9d3dc4f5ef5cc28495021b7c1df134b29e7ff8bb26e00b2aa444e19183731a15bd2375681b751fc929860168db3901214ec4e645c5c6073a9ef0d12875050a15852534ca680d5ef8a98c61d6df2bccdf4944914b5e16a844e17f52b9af3a1dd67f7385f100cd38d227fd1bcc5e263b0a9f7a7ea7c23586dc65dea7b8f2f5f89309e346a0fe3ef370871624875301b5664987c63c75dc31b40f86a754ad196009505926ddfc2989851d5fc84b69827c687e5473ea19ba884a954a1b6821fc87658a5621194fa591841b2bfd69e6c369cadcd7185d5da4ca55293304c5916a46e4516805e4a28975500d902e33183c638a9e25499074542761750eaf6b0391557c290d65009ec228b127695bc46ab5ee85f9399b26b6aecae7e9c39be2201e50a1e69d842f836717a55f6b0c585ee49a8d4cf5925ae8de777a873d7a56fe21825fc23f6b36f728e86945fdb203e8cd645aa86f20d52c9bb62a4fc6a2c6566ef184e8513cd413b570cd6465b10a42399764ea46d8df7d85708b9737326da79935421dfac62d8cd87089e63f9637d79f7bb2267e499fa25b423826003a1fb35ae46699e066ecdfe3fbdf59cf68acdf3f923c929c0a441c68ae9ae146221849f435ab7d2c8021b9d149ea6dc6a69ec1ef6d6b184108c29ce9f20bec7c00049c0e5f38fdd6f1b9ab4be1e93c12c1a22b6a4522850daf1a1e0ea3f6f21de290d3cfac0b4375e3f9f51cdd94da60199c56dc7383f7efcb5d2ff5725d4e494f7ad3eac331239233975f0d9b98fc398dbdceb7d2818b05d94dffac866c1df5eb4fcd330df17df698dc0e196e8ff626fee1454fd04d7eab54e7a228392cd04e11cd2dcc65263bf38c83a5e022a78466ca375cb909021ca5e954470edc353f8584fc8957c35e3e936a77eefeb8dcee42f4ff1d99910f7e1ef9395ba0c323356a8b74233a69e610bdc9ae4ee7c2c67d143a8be80167ba8f3689d7320b8a4e3a51b7daf75f7c6a7a0ab228f36b465d8e9607afe1e95b57fb450c2f0af975a90041b8bf01d9073e7199d2776acebfaa5d323922ad7618df767bd9164ab04f1cb0255f0265769b56dd18f8b78eb093593e434ed1081e8ac45b1f80b392918e5a44ac48f33f852b4b984fc168c53f9f680e5badaf883899fdd43f9e10105ebb83400b5d4aa180d1b1eef39ab5909baf4e50bc4f224be8e200f9059719a20105004cf3d6572a83aae545937e24710c91de42ae4de7afa92faac7bbd15b9d1d852522d2999fd291f3e7b90495056c1a59d325a2122c5716aa7ddfed89efb29d90e34898bafb416e557772be07b24806658cf27339a05b0344dd29ad90db02b2c15d0a8766aa6f2df895a913cc14f59297679e834d9925525cfe35b120ff8285ab5c846f9adf50371373560e3b91e35a9a08784adae50ae47cad0bc5d62e6a44a3f5d5a8b465b41ee7e96cd36707a367cc43ecfc519cd03ce01437458438b38d9b8f8db6e06b1ac38b49adf76c6499b0e7ad6d4dd730ecb7851dda59af4bd92f1f97da96c380c190ea77068a0ae1eccb0d966f95806c465ebc1842d37ed5448d9744f361e73de0cc94e16080b8315ffda9176d5f00a5950b7beb8cadcff1febe11c8631963bb489241aacbab8082c41110667b59b7d2d7ae0acc23e4b41eb935f13999949e1effd49901733426c8a81dbfcc82630d3a7017a8359523b4667305e083bd7907f4c31ac39ce43e8c3450f084a7093d7977d3fe147e78af267828ec6e6d444fe71b0be8f8353ea41fe58b94ac64e1f1d054a56a384473170a9c15f9e03824229ca936aa7a9a1f0fde3b2bc4f889584fe10e2acef11223d8275bf8c220a7f8b45321d898595c69af73cf1c9b4cabf1d5b1b05ae562c1527750ac92303119fadd510552fb1d1e9dfcd33ed5d3f9fb3e0ffc97e47f0aebc75df1cdf757b873ad6be4574b46b54e7f7db90c65e88ac461eaab49f8aff17dde7e7fa43605cf5970897c3f7d5e8f30783096715f9dea23e66885d8d138e9341a3127023b76a676c404c80de47b4c2405e06d4aa74dd27f0c03380ac8f9f76cc66b53d539e38b63d5ed1c61350c67c61199c1385c9cff69efee7008d777a6eda1f449575c7d43944caed9a06618f127d0a9e34f35e9471dfcae058af3dd996340adc7fdd3a3cf4030b4295a9ecd53fb245f85747aa31fdae4ed9165b2ad2b08aa7f6155486136b79a4a3d34a9a8b6cff2cb14badf708be94c116cabaa72c741b6e48c25275bd5808d25a17b1dcbde995227ec948de89e047abca8eb76c30ca77642a5c08cd8155847e169fc7b29f6572b3999085d04e90af7c543c11d9a3fa23707e4a02777b6e9118a209391c3c6c16ed9ecf25d055b84c468e252d37bc3b6d7bb12bb85a0f28075cd0f1c51253f374edf99f1acf8bb70a74a327ee01770d07caddff8abb3597442f4c6d55174c6ee1083591b3a90980e2aaffb2559b5c7730bf8b12bc2fb00a4baf6efca7af56373c5bf851ffa054c5f5fbbe2ab3490d85475a1124b442d2b0424fe37f56fd10890ee4c41a95f72145045912a25ba5522caf09e7fafb7e05f6b90a560d091c05e549eb995c0a3919504e3f02100c68e4dd90924547c6495447cbe995726fe77b2b4ab8c3a53a12a78782c3381cb1075d71f29a7d59b38cee4b736cd58c181ac8f50991ce849cd05cf0665843e4a3ed4fa4d326ee6a2adaa969c6927b61d6ccd60348ed577f6d357b33f8b24f2e4c126557b8833bc3be7bd923fc65b0bc3edaf69e4a2208140e0c822ae169340f33eb12de61b454bee01268213fa516b4b349c22b51066aa13f3a477df16dbcec2e537f0642da92f37f4d54f1797f42a05d062ff8c0cc5f31be03646b9b5e151f1bb53bde76db6242c30ef42673a213699cee08a68fdd6cd6f7888d5f016ce1d48dea239a7bbac0503d9f65de0f8ff201f153886af69d6b4f5e3d09b11dd7f9dba32c0e1ac31ea3e82ae88f6c49226cb7d2e7ccbddfd6700b60dce285c705c48b82ceb8886c97cec831384f727e169b4397872e5432219355634caf1a6d54af25181c5f4369f6c4ae5790293e871766eea76659d18745c29b98c92fbeca2711edfa0ae5057748c5e443cb8610b26e70035b81ab94d0255b111376377c4de44d3c870afa70c27bcee66f11bd66b9c22bcc8f3b78df1fc2eb1938730aadade4d872f8acfbdd700d68cd5c7f412bc9e199521cd14e0999208b0e5b0960beadb9b059a401f5f526e416483790056c85ee66cb5de02a3eb1855f0f8f85b540082a79a4b13a9557ceb2bd54f9cb1dac619a69d8ea22c9756b3aa825e49655dc9e6d19eee5934563d77c65517bc401d3043a63a65752bf731e91a32a096292addf07f241dd37c4fe734830af4f3822764959021575663a42557ac43161b0689a59295e0e6129a49d42fbbe01535ab2ac8034a24e9fcd34360eefdf7841ad7cbc2a2c680eca6fdbd3e3840ffea202ee56199b627e2a5146a3e1dca29109f0f52f19632cc0e48c32dcd8976f2e5436fcd6556b9fa3211509e80c8cf33ab4e1b1888463d0135041381be0485ea1da277ed7ddc090c1f4b65358a2cc0363fac326b5d4079d6451f62b5c3353ab14414a9382a0f8377f0554b887d668e44e3dcb13b89c99696301145cf5e124bde8be37186bd3873330308f048b84a2d14ab6df69def9f0c6233ccef4a284947365b9242de82effb3243affe8c3cc3b1e2c58e4b7c24c8bcc1e595483a4b6b1bc0979e0aed4d3390798513b6ccaa4a6cc30fa4f3df1fcd87e02244bea5daf54924338173ce8593d2d2b5b64154e6be9308136dfe7fbee6b6db3655db998d0c8f8bfed7ee8160a10e52b38af4888af4f4de12202318e18d390cb2f14e103ab0a89af7d24d5f59883cfe5c38a5f37ac22cfe4100d9c69c93a598633219edbdc7fb16cbfef5b7f6c9ad383a6602d9722b7ee34983e65404de8a465ff953edd384d282d6b1a440b3b0fb3d1d0deb66d753a1682f4f14311ea79cebb1c00fa47cd7dab1f96ac46afdf34a0a563cd906ba5652f91c90a816d864f5256e9bfe13bd178013247f7800e253bb38e732509fcfd24c4e1dab3c475c22d6983514d4f2a459f2f8b45c61cb9fea6b6da0d6b50ed4cc2fbf72a102e1fbecf5ba8f3b49ad141d5c0655cee21b9f97066355235e72e722718c738c2465757113b500d15685fcd6aae53c12ff7a36e5299d7b123c71c9b9bcec41fb1123c270365f0863a777821be2ef5677b347cb0effbebec3ea13fe2d4b6449431f3faa76670f921a54f7c144403dc6cce74cbc027f6ffac50f520aebef759e78099009e9b484eda9ad05163d1d529a316563e23fcdcc4be1dd4869827cf8abed2a7cb40261b2b7909d3e607b5ed52aa12d32f3977ce38fc8cd8c828e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
