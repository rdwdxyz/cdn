<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"59fdc9161f8917de5138c836247898b1c6a9196a0d8d81beae2f53ee09e5e22014bebef579cf0aa8ffc70bef45f1af00cecfac27c9ec9068e6954bd2c8767345984a99639de3f1b1b42b02143e0b52d4d1df1452dd65d2285ce4da1d2b726fd810b4dcee0d2399a4c0eeb6ad751dc7ede3f0727c124b56c7e0c161ed74ca2073c475ede1056e184a730ba29ee2cde5b4ae3ea937d325baa7dd488ced5b4b97d73018c1fcde1392ce6afe7385e601e9b6eb42b400cb6727e3df424f0187ea704631f00533860f5ce284608f150e94b0c413dfee2a11dc34be340cbd2b64ccd11762ce622f79327c523d581e42e47b12b8c1aae214867d2c8e75a8d5ff4214dd2943be5e1f1fdab112ee1c785776632bb5609bad49dcf138edb5190827e0049015cabeabb2e278568fff94267377abc8c2b04055c34aebc3d1f04948d34a2ba27f90a8d563fdd2fd1a450c18bd9be7d6ca149f703be4b5140f3b21897d940bffe2b51a565a490a5f29b147cbea80b7c90ff0a836d2d584133d635e03bc95ba5851a79d5098ac138578939883cb323cd6397c6e75f37012e60cc01ddaacb7fc1acd1a07f4e6ddbd8e8db50916cfbde1c94201de4f2132841563f5ffeb7d9ed7106df45ad0060a5e44fdda3b8450adec56db161f9c4cba3d271c9f5bd2eb685f02fdf0a4a03ddf2198fedc65fa18711689c45c94918a252680ff21660f5e40ba7320545ba388cbef4fac4e395199302409a5d183b3ec17539a0de76a8d557990c53e5c1ce7d9b9b010051a11b5f573b925204e337bcf297878db28f8a46f4e47f91396b4e4ae21ffb526b0b05c9e416d97df6fcbb71aac98fd3ffb6de5c79517d8fce475f05b4e0a86dba3e8068976a0f1c905767397933bc88a52c6fa711e0aff2a2561f3b11093d3905f66dfb362cb5dfb6af2357d0ba64945e9d4b519c3b2edfa57e9e64d4bf7aa908190b1ebe7d86d1841d02ff00c6c76f0d2ccda85b55f72045cb83c32c6b8462c08fcb6565b3a46a407f0b82c9962a941668d609c1c4fe910402ffcff68751ba48b5eccbf0dba64f6abc78bcb45411d547e7fc999099fff11011771aeacdb91f14a511b8260daff920043e1ea4e4bd498cad5889bf51b96f76a0b29284f52f339cfe1d42efde2b123cf94d1371ab1930c21a3b4b30e738ec5d84f57ba9749701a808f867d492c5be4c76e5de5ef4ad2107d451d336493bc05f5343fbd5dd237f4388d5ffcd2dd26f085b7e720f27ea47cb1aadeeeb4a1931bcdf0ef29b1bacb123005944c0cfd89d754d82397e031f5d7bf8b08b464f8d7d526c6c1d0de88eb8cd186619936d3c95eba993727dd8b42c5554d02e61d5daed79ed4d5c77b3757cd8d371cc345fca1fe9463682dce32d392fa212a4039b16f0e24902de784a0e17728e19702089cc31a15b81c84faaaaa422cd01d264f55f13062baf60b8742df2f40b3a754977f5641844f672af87db3d426c4763a5a45b1b4fe40def620ca72d591da9cac61338e5cc38fb6573b14c150d62800edce3163c857a7acecfd7686827e7e01fd0f6f713c36d66862be76120268b8b079ec0c298ea0402ed5403a49493d40007278f10e373f2d27d0e3a59e5e4abe0e9eb8dd5b29d006fdba8c470fd8151860ec06e21c42c80bdea2735f5b657ee1d6ac3ec89388dc743fa34675dce7ec7c4b559ddcb4e9537febee008a58743c6cc827212999c54498451951a99851d407f3db84a28d7cae780cac996a3e8a38f61bf87471141f8d2c6be3f641bd24a01d213abdd7c4879036f6d85a7fb56ae1c3b2a2d2c6284dd180b8dc377332a219a900c0a704d7f7f72fa70822cd47ad8efdf0d047228bb00dfc33b04b2d10067ad5fb6f74fe32d693e01db1aea902deb16ad8cdf3d7f0c5dc85868a9a5ee8b538ff91c5503d348d0f459357a30b09afa05f31cf1a0e4fe4def514c5f0458053a8df1ecbc6a31ebf39f35e3949f4f3512ffab03ec753265054696dbd49b8e318637d10c5a5ee3e480426fc8f80544dacbbe982907d02dc2b402053bd4513841449da566677c79a5ae19a53f1c94d546cd174c7d916c12b0e9caf20373461f0288e895333c85007ca34764043ec785af3382c7d03e41bb48636423b2ff60d1948b010d6aa407051ad45f42a4c7588f759212e65825ed61551df2852e31ad3bde46c06ff2e09dd6d14ab34c381503534db75b82452f78e832d11a7961d81c67d545f4cd97389d5782022b232465babb9eac10ed3aae4a7e94147adf429766d5761986f3a4884d1581932b8b00aafe575ea641177e5fe89ebf2a3ef203e7225b31c4a044fd4ae8c1a17404c97738ccca587e69c637bdd4ee9e6af139a372ba00e4d30ef7942977af80bfa845d1e018ea6e7f82c3989d9baab81f3f83b20f4c1020b4bc16b4a1cd391672042ad6fca7408b15249908ab66de17c448578d2d846984290462fb68fbdfb104aa26f6b426f8c164487d334df524dfffbe7276efee0bdc3a66478e4ec08f0bc1593d973fb65d6af648a264a4a68168d515a2bb8522682313382b5c613e4ed42311c875350b8bfb6afa03463ddf8a1b73bfe874d93c1468cd877ba384be5ff059e43c96d756d8901e72c8d22f1ee275570f4bb1e199f1b23fb9c5d720d1efcd8e50be5520bafcb595b3cc25d216cee4003c9759c515e4800dbde8f1bbbbb9d26ceb183ccef0dc8760ea420410dfaffcf11cc8140ea91d724ba86a30bc495e515ae2a646b593d7011e1898652e5893b5d3ac5d0f831b110d92d09425e294538509427dbb3509fcd5f6698299ae2c64cb40f85d34f1e61a034878681a612b2a8254c94aea7d05cfac82abc8630383a0a6cab184d13f47987fb656060ee1608193ec013f254a7fb73a56edbf55211b878f6a47738de90ee7c3358eeb84ad0d310fc675ff6871e6e3f064c70633115b693436d80390279d9b3744c962aaabc2f1ff6c679911e1de0d2fef2d244c848d0ea13ad778c3e639990d3a8545c44d71916527081ac1d14643803e970eec9cf2a6bc5e15edf822b0f8c679e3079e09bf5c1ead523b7e4d66831c1f49b76f816cb14d5b783a81d0ded8554e632fcb01d551ce0b629fcccde7be8097671e57b2af54f76fc4e5d93b9e3c24daa5e1c2ff9b6b6a137e731c1602fd0f1b013c24b295dd842c2616d12610b2a143e76dd2bff889eb71c083759548ea85c0f13a4f31002ba9a1e82f7fa5e6056fd44621ab1f56713323489de89fad50f6951f2ca6ecb31e81c1270ba9de177004aa08b3171baa81c6f04de137cd47bc1d0f478d1fd0a3d0330ea1fd4c33ac68c252ddc34e3aaca5f6c8f5749638c6826cb540ea31ccedaf7b39d7aea16b6f55a9a8059fa7e07875571104550dadeb4896628627ceb4abf5de31034dd3132980d0fb06b71d9e64a9a5426b2255e6af56662ef46323094fad2c27ca22066d5916a8dd621db4a0fc2d343b096920a33423dbbac3c3332e41b4c324ebcfa977a3c8960b515bb302a7c96d74fc32d7601e0beff936d0fe3c36d61f206f386554fa8c93d0debef907871541e8ba4e591bb2e6323ddbc88bf9152f733208189e6a834310a836dcc6266aa2542817429f00a902d09abc6273de3efca75bcb04398c26a72a6f72a5851521c45053a26a594c3e2be3f783eaae0c5783e78004aeea4c870a8f67b15e6e77703694821f890909925f262cc6147a4d7012884513ea959d7f3c559f44f142a66e0760037b51e53b44a9f9293067ca22f04b61a352f068f54a23f15f50cb7b394d53c546294e5d55d16605522477d50b159aab616cff5fe035cd95ff8ae755a83a4fa4e42155a643f672b21001bb121e9e7f56fecd8aef59572bed36a0e9ee20cd13103b6549fbbcd0ce5e5a72ed6480cced3083242026b3b6a6fbe887054b08518e1a6f69352a7c13f31400d96ddebad978ae7ce3aca607a233088ad764d31662831f319ff46a93ee4dc8f1127994b3e5dc918954269bfe732c3895fc45ceb88636ccfd46276f64b9660b3c7394da925321108e21a226e701fad4a568a293091870e5bc6bcaab40b11f6881727f11ec5166ee34f21592438f4aef629889daa6b7cfa7f09eca67fba0de040be94773399417ab7d5e5d3bc5bd10e776b233b020fea6a902220d6b80f1c325a76e27371214d6113ef9f9bd54568d6d3072c4437be9a84ae947cd67dd258d4a4ea22592afe75eec333980e1e68c58ef0decaccefc3b8f91180913c60af1e13df6b36b95a81cf7acdb4acdbaf4165c3c7800501aa62c8d4a6246ac9986a56f7bb0a58e872ddd02a1ba943380473ef8b1648981a1895d97ad10ee901611b82af6e5196deade8e515a1fba042265d7800704c15fedc8862e70238cc287abc3de295ba9dc695b4760c3fa42ad10da34534ddffc3af6927fbecc1ee929741578c2cd606e363ad6b9b561b0fdf4f7921436ab16b87d27e0b74492f65d7cdf64d7592ea43e52bb3ea8545dd6b3d69a5bd0675c6929df30a0fc0ad7f70e9b3b487f9ad8efe6b19245676c699a368da7dbd9115ad887ce3fc3e4411e8972f1c586fb9198fac6e106333fd45cede1b79180a933dfaeb536cd5f0ce8b56af3a6e81775570f37449dff85441434da91ef7686f7994f64d8a3c4d1557801c90177f9e7cb4e520ff1b39b0735bd44eed611740bfda2836c2e0438db7df0a48019261adeaadff597e4d710732d9dd3e3d6b12d66c74b6f8a4129ba184592ad262e54bbf6bfb970a8cce20bdc8ad57db3518e2060c7a9eca89f9caa5db72e5d0548e66ca7f2f0cf754872b82858e8500e4680d91b61966455cf90cb447aed1b2b091d3b73cd6fc989e6ce25355a97d14a3fc6feefd1e74965359408bcd43bf1a8203424fe669edd10456c1a43503875ace12dd6737e1e6272de127f2e36bde0473157ffab063896c30eddd463a66228091db768c61455de6ea8acc3a65568682c5a59058bed1fd2aa6dd3c4a9fa2219621c1832c8743a0e53d0d62b625f195ddf91f666c84ac864f728db5051ed0cdf08ce62bccdb4580f9fa2f98f1c98f964a31a7535c76177651d8b12ce15b6fae2a4f2e5f296eef5996efa4d24adc7716ac75b507c1da9c8d3c04c5eeb725f33f2f8edff39e8a693778430aa5ec6f5e99af2ea7dd9e91e0e36d6fdd85b21b9a293c71c5e0a76a6c458ef0a2c91ad7b12d29b9fca9aba4b753db8f4c4fb12fa93d0d0389de7027483ddb42f0f4c0ec417c76229f6557202e610cf1b52c1b0119a1089a918708e9fd77c33fc2e9d684314a54020340efd6f027e8d2bf91504cf0c5c8edab76f19fde09de25ac45cd075a1ef846c05271682d842a2497e4a6fcbe21c6b41171d52889bbb23eac4529c62ef450cd14230bfece2d28507f196a737baee7aa98597b9e7bc5e50cde13ada2cc72b6ffa259676b201d7e1a57f05ae037a8032db667761e42f6d3589a736e78403f3f8b5a6b2d8b3de81d16aaf63fff4d3fe2f8d6247a82ea4a1acd654ef0c7e4c8bb230fd72e12ec08e04709f54f49f08cf07998e54194605484774a081f915f6f8666433d013c8a939eed609cf1c35e3c4b147e8d7d91e9f18e313cc7a7531755364f4ebe97dc864318ec704093a079c377241adf97e871e0ca7801c99ef670f667a31376bf3c081a5efe822438bb294515da3cb83410bca29d5d5e64a990292aedd2ac88428801da2be46d4f7e75cd1181456bfa517ec2e7faf2b282843129b90090d6b8d76aa1bb231be50f8932e83220043d1a0f784dbc49b70a1ae2dbce3e44d26f16f5564eb8d1c000c941e5f2161af1f3e0f30a5304ebd9beb4ef13acb4d4f0c1e790ad778598831e328fd7347278623b165f1a435089eea3f62ccb4b97ffeecfc9e3979e89bcbc7979c86bf1c5f8065437a5afcf73b89868e2526054c65a33f48dc5a061efc9a3e4572d80c7b132851abf3648e07450195d11d391041fd9c55a9415b5b428512b973b66c380d8a92fa8be6fbf79cc5b4314f404c782917f3f52674abcdf0fd9884dbd4f1b560f7ffb11d9487f61f9c9b5bbd7d44d29aacf77dc11d76aeee9e9e74b6fb5e34f353b4fd0ef14f9de06884a1524c9565cc63c12bd6f73ceac8ff02666eeb9e0df1f4ea4854de580de9dca649c8be9ab72a2bd41feef4d1c0e90601c4bf4f3a3a341537b47eea0b2488ce618e64319ba74f64fe59164a2b1f690e81e304fe42a65850857764291beaacffb5701801247a19c49efa4c8e152be1f5c682642d54ca9d5ce57aca70a37cfcff2a3bd818d4bd786c417e4e03dd26a75f4cb37b543601583eb834ab0139a22e2be32560f51bd2de86202e7065eb4c101311fa7d353ccfc956c9e815392d09f3d388e244730ef89eac3a82cc0e5b5e62019459b6bab181008555daa60c7fbc75d902d0b77a484a0ee220f09a8c0d2343625b9672048919ceec15201ef774795a1cb84d5207760c68e3793dcf213451e38a0df6100e5852286dda378ac3fbf3eeea958acdc6552467d2d1677e292fefe0a5886ab4df6fa20dd99e46d3f743df4820ca369b6729a1de7b01ea86b4de1d97d6f898f92cef6eb50a043ec1ef1193e9de1127098d6f14ecfa9b528848f5728a5b8ba3534981da22c7456796823421d68e1f09bbfb4110bc8962532bf0f398e34cf8f3cf50d47381be2f8a05f7eb92d0f3a64925993d04f4e6a6f15e5b4c9abde0799c76f35e9f48fbdda65c068130b7e3f702588834fa6d179891c4575bccdaa3424ea8da81e52c8855fe6b3fcbfb19c378272d09e91e2b442445a6cf7f0934a086c021b6e65f50500ec5911b684bd5978216a166d03995acd418ff3442f8042d1ac6e86d0ec18d6dd6e1691f7bf15dd8807664f023d9158f5139bebc413727e3a4314459954fb8f8aa0c3cc5c061cb77184880eaf7c6736ff88df89ffc7a0d8f9156addf8a075894c6249ff58fe694c354c6c51da5c2b97ce10c9815aca068922c116e5e86cb2954e13734ec8f56a83beef8ad9d263ee2d1764e1e64aa3c6958febcc11ba3290dc09ba110fa0ecc0523469217f745ba647e4b63a7da3097b00c257800b655ce05a63f2ee11d1db58c4ae9fba7461d9166cc0d1626ef5111609922c74cb90a0303c2e68432ea470c4e66c1b4584d13408e395770145af760fba692a1e72ef109ba245b511095f1f56723a89342945407d87658f39ffe07e237b7ea4bbf78eeadd3c7c875640d7085a371c2274a3aca506b2b1b8085d76d7b423262e4a2bb8e0b8f07cfe864f0c20d597b7a50302e30fb752b131f6c216d5614a5c698e5cf06a9f125c62d3cc4a901fe58172889135c0ecbad3a3204576f448e3f6a38045dd097b00baa721098c338c033f03be9d4b1b1580c25c73b3ff503e4165fd8150c50f3ec7c41a8da741803cd7a1bb0ac15bd5bd415ad7de7d20cc334add4dc3e3946f89d1f552c03814774f089d64e8a36397715589d7c71f83af4e6a4ffef55a66b8594566b85024157b99a6bec42e58e0d42427d33a3b9913363458953f2496905767b6310af701e4db4b322937a327fd75a26444d2472d4ec1bf8a7644923ada18413f9acc3d121a4f5f46edf2c122ef925fa6d8c284b520cef93c94680d6eae0db47053cad86dd7bd38540879b2a5ae6c14618321a5526596354e091fd19e45c0da5b9cc948c25472a6506adf4cb192c57baa502e2a3fa64964c8174c2702a57d54a3120354c7ccc9b942a74873078c8fc20b6ce1d50b29603b64924e729591f06a0b61f48543c035b520a5ec5417fce5d4c9b76812c06ef9b5097583379bee09ca822b38e5838dc1620bcec3b678d61cb42699a915074c08829a06c2204ebc7326dc02385ac16fd57a24ed5301098336483009a946dafac3ef4371eb4f37b569a91768f1fcdb1ba1a72c9aff5e7127eddcbfc5049e963b785ed62668bf5b02e1695ce16d185c51b214e527c5c6803c4777b4694237a7c8bbfd186eadc7c297995f96e07eed22c10817b607e6fc7d9d46edd29be47b11d3cdc321a74cab65dd8d551abb092450a7bd3f41e1d41a08e486e906e7a8841008ec649062e0a37e39f1a82cff0563d12b9ee7b921fb1a0621efd52630cbb0d2c5d45acaa9ca3bf2d7d7293d7fb94e04ce3e8744ad3565724e008891aca5c7cfe20b92d762cb1aad016ef81a3a4e138f6c1c0d7a17f4590f9ad6f5a751cfe76990fae2462ee53961dae9c04cf8dd9ac97ddd8c80608c69c55f661b4e9b89fd20c63920b642ad84851e5fa6d72630c8aeacd3bc6ce1362c77c2ec3739d0a507b712d5db60c322cae578189478102b625af76c07ece45ee96e21c571889eb85e004a3fa2dd51453383dfe815452c175f7d5837f689d4e4f7c781e9c387f12baf72d7826633f9987b934b385be84284d8657abce3e79a9801a6dfa1984c7b052899daf89f21b79c3574d739e35fb3ae9ddda5c168ae67d4c6b3329a8f2cf5e1a4f62f96420de233916b135eb90106e02b0a5b8596ebaaf1cbe5786a62acd4be47d76b06af68318b47543056c03a59585fcd572d913d8b6a8a47fb3d632e3e0fa9f10cbf5d36f124144107d19d2eec92a2a0eeffea6608aad1e081e6df9560448235e6aaff8882223318b6e219499271fa5af649da4d79fcb57acd141cb0ad2277214e2ff0226436fee28714be6f5e35dd37cfa53c2a4f97dd31af01322b9033ece364b5b01cb270b01aec173a65dabe9a75d86afc43eab63ca998d52349d843612b5e24fe9b8dfc301167d05d6c8c27e66dde4e1b79ab5feebd3b0aba5dae5f05b38a62a53c41fe9436a12acd3d2182dc3ec5664f85407e5158504cc7210aee29845fbd8a85471da6b7032b5d1f5df7b603ba6a910b3b7df7137448de2e6fcd2b4a0e38414cc8ecdbdd054012d5c454c4cf070dd233b795c5b88a6da466e511b9628b377154f2cfdbbd112463943de9ee00279ce40fe4cd684c1032cb999a2aec10188113f5b22a8ab70ef0d4c553ba065ca6fd910cc0a255cb0d2bd3e70572600fc8f063fa109d2a29ed3ff028f9599164678b9dfc1e6abf4ae1f2f8dcd7804735f4d5739042b85d46b8eb1d54b239f8f4a11c8eca8958a43f7c0f9b8bfa5b1d5a423c165d46d9608b26cdf18b0a7792d0101c62371418c66de3b8c8ac3c6f30d50d61d2c36032ca56ff640752b59818f7132a8198dbf01d6749b70f7eeaedb091f7ded23993ee5a62baa517d2e94b422448757b9e21e3bc6fee594a8a5ed55a16ee92a1a1c334d4e6413dd9b0d56d65c7b7234fdd27184e0e9265fc2ba3b79a87ca6e0637f36e704aed1def83da9bf56f0eda21e64809bc514294f3c9869cb0ec0192644c5d7d9fadaf082f7c001a0389eaf9ab2a53a1ac9df4afae3877931850694138dff6f58010b81685361ef54fc8b9e538a40d9654e6176cb1f6fac94a654e06947bbe93022dbe1e074c6f30e7332a4862c27d3403c63f64c7d2892ae9677db4adb96a4a5222d1d67eca714e27a3067250b161802756a2d2484f05e21e82330f1f0348efb1bafe188f371599b2c745dd1bfaa2bbde254f0d09763a14922cc018d7aebead3b514e204dde188b02b7519dda9873b71819d0a5e1639fa374bb2a5aa34db8c390e75e94f92588e9e0d3c281df29ca9ee70daeb55005b07cfa34886eaf5d6fcd67e1b6b4d7064150be6ca3f2ae33a8f7c7fad75013e5dace30f19c718c1b6027cc45b3172bc06fb53550c15b77b9ef6c14b333600c9e47dd75be99adbe34edd93d6938215f4efd3fa3fc8d7697b8f38900277e01f0017517d280fd5bd188378e92e72193c9145208530a8b70cee697104a9b2b828b48081752b5f814062e0039f40d7ce5bbf880da4d6e3b1e3b05e2892a77d7671e308697b674dc246ca9c4d1e47e668fa4e688fd749705055f79d1931b2e1e7a9379f4235ba18cd4e2033c142a6db879b7c1dd4b387a4e69e0c86d72260fc6f4f2be635fde5ea4d58f888660c040621db8c93e6af177fcd43cb7fd7191007ceb7f78534e77471306c4c372e678038898363bc9425fdc6ed4147191e23338ba077e2ff57ceae003907c79a82900e548b57e80125135271905027c5fc76c3528dda1672b4e872da7f3a15ec9c8a6b7482cd59558d927c1bbe691855a022738651979eb0c681ba895b843b7ff67c006ff5268344fbbdd55bf6a54f71a38da68e03b0ae742ca8b61d694ec57948058b721c180de2dff8cc3c79b0dcec6d519a054c20b5d800f733250f25cfcf7cadb379ab58b62dbb4cce5d860c87e9c6b6a851b2804ceada7b6df94bc19341b2fc686bcbbd3d301c5d115c632041bcee79e52dd1febe2a2334e381f73ec344c03dddc43b37274cf063f43edfe2a86bd7a857d58ac49ca3a8fc7a24a7b788604f0969480aca53d43ed61980619b41fb8f972f6c91cefd7ace1b2a93d45dcdf63b49cdce12fa5e45e9b5d9c9dda7dac23aca913f48762f6c84d224f9c5139b1f8f9b2643bafd41a55b634fd302e1afb5f4c46599f215c29b3ea216d3b04168c7f6553be7e370b4cac433362a8cb560409f574908c8ef487c8ee613e412d2e6c3014431cd03524a80108f6686e9dd174126ba91bcde670f586774cda0c28ef2e97c79bf80b37564413a20c39d00be2cbb7364dccd9e0162fa0389f0db35b3e4729c4cd9710fe8cd1c29a5a64e4ad930c9d20013d4c63fd1a77c7d2b30644dd9366780a4ea5c7d426d56a9effa3ec3c1577fb64d7926629d1f9f07e3a167fc4ed4e23d95ac24ce42efbabcd6945330c77676a3610eee0a95c2e44f231203535794bdd456b7231be52d4d3910e61734dcddcb1772e94c46d869112f8f6d79519fa48feeb7d77ab186b4f0afa219c69fc138c26ad73f768228e0b321fa50784602232de19f17fb147a9f64a1623bfeb3ef8a9a1e22d2a5af239f597505b9dca63ee4ff7e8123467a2680fc06279213a270f40c61408e84a1c7fe91904410bbb6c51c45735d60158018f67898d7c785fefe0a15af0d6b520c576202c6cd22f9ea6bc1133b27fe03f5eca2488d6a7044cf3748c4cb90ad42945d6e3108e79f5b3519f101f38c5ec9a0123c3d429d0667c72ee707074893b875b02fd932d85eeef72dbb9559353e4d04177cbe4e5cdca5c9e5a71e00615e3ab000aff749397e84dc901a2b57d80e1e7cce35c5675e96cd5e372810765d3df740cc69c234080630d290cbba6de29a00e1e289f58a1aa757d3b0ce61aa8ac3275f1d0d0d0d5eed741a6cfb83c24e830ce7435490ca11b1a49feebf61f21e17780fe4aab1e63740a0e53ae50fd7e19bfa97b8786c7049f3cd76208ab7d3aa1008b261604add97d93b925b286a864fe62df40ca1417090a0b9c739e7b5094ce54a799781c06914772f6878efc2b5de3c6aee801c6dc4b746383fd8f74e0ce164cdab0ac1102b5d9845f056ae5617a5c3d2a093276545ce3f7bc5cbb47fd92da5183e1fa356a9e0e79721ef9a7bcc58d78135c2900549fdd51db9072ba3088f0d58e9783df172ed9dd378e8afff80bb58ac1dd2e2103200f364571bf087c96de564df2c2b2e548d6da9c8a65a5c81069dc4ca2bf5824ce906a9e85c97d62d69ec237e0571dc9c50b8a2a694fe71767cf69d0eb38eed50472e65611c6cd567cb76f24b5fed6e3f1da1fa88981dd4da74a9b615e5a373fd4434e1cf4aa6a0d7c905dd5c38356aa76c65c136c918062186098944a5ac7457d5c519b22c22ef4cbe4503cc0bd5c31ec019191440397e86d5df52290c748994aef619087b1ba12533e73f699d8f7f65379e6b0f88e26c2fa096c916b1163be51688ce1f306807d9d44ecad94c743b535d31236d950ddca469e86b2286c345c3304778b2875b44f8fef61c8c71238f4068a18510541941c0a785f0a941a513b103c967865577d8c716536b1951af634272c7f8c11410ef5e21402c51e040d6d68913cfd42a76d7891c3e35ae3638e55a3808062927ef1208c68c9f93c180f89680d4c14a582b6ce520fa1c5203dae29c8a8b4898f3444e2f84536280824c8a056f71ab93e1e4633ff538b6749fd0d37effe3dc0b27d4e9bc764d901e3c041fd7b4d869b4a57c6dec6b2872034dfc12e0cb73ec3802a4dce03d2afad40252d51057c155d3e4c57513344d034cc0ab2cab1967a69def77974b1d80858bfb86196c319480d03f003080afd2b8119a3cfae8404c1892436d98ceba4f35ec0e9106af9e5dc4635c6a810c6fffbe52f3b29e8dc74f5cb6143280fadc7001e80eebea2ae8458da8d17fcb8ac40987e85de483c14ab9ec97ce466cd3fdc53e371137898f9074edb4121fe6ad12827a2593334f62aa6985209b5cd3663bfc6d21cbffe38f058e2833d012d5e69c6e3fef078b5d26c8dc7bf9eaa9ee0d353a4dcd222b00096b7dbdbd938a9ab3032f32ad74c22be896f4e2d160bd21eab8ecaf54fc53b5a4074974fb3ac118d415ef8fa2c2e5572c4d9550ee834ef47dc7af0fc936db2f7b80c20f148bb7b0a049a364d51f637cfc8c86bd6df40dd72bd0d65697980ff3666e5bb870f5898a68cadba1e89104f9608b887a3dc5c15f03aad33482dea1de980a48ea64b208e7ee3bca302c725a9df532d218d55986b5647e01d8a67d8ae6cce3d4532ba9b7ac151565e7f56739c6d6a593a3b228fd804e5bf8fa40ccd41d6cacca2f80d00ac2e12abecef9a34aa3809abf196402b6b7ea4418eb828fb31689e0e73e33625bf9598f69e17514f3389d986ae050993c0b9c9fec1838f4ce7f0bde356b54418e54e7b5af86581d8a4f894f3bfe988f359b8e9a641fad5eb39a9f79dcf3a771e1f1b30bd1a821f5aa71e5ec1f65ab848391c8ff9c9c398f648e0da46b30038ac33f502aa7c6b9698407c7c9e122771e49c6f4e16292d04d8926aa120d012c4548615a18d1bdc939513b7e784fb08531c2c7ad61009fd9d32d03c6885d2447edabaf608519b36e27f473aac3f61569a4027937db7f529fc623acea01e174c234ecae73847d35a6a4935fdbca58d064e3b5072a0374fbae440e3624873fd12d00d866f76ccaebfdcb9c65dbd8b598a2114730bef5a80c0896779835756cc989e51c2440a20dfeeeafc8367578440e8c4beae29c2abba005c0190535600c83404f22c2ae89a1c4e880d1429c0f621d4de4db617f6a8cb0c8edfb80ee2681d29294041ce83a0725b747fdde70b386696137f4db7093c18566d9568cb021f0563dfb6b86adaadeebec309b409c3f9de69659bbd747399dad72578a10e02585845badeffa45fed2c7b9ef4c63d4a4905839a5d75f0c85651fa3e5173d85f49434439bc42ba16587091a5ae7b37191053720cfcf921e7a0a0711c6f0cbd7b2c16b9f4a980166abb61a8838396cebd27e3c368396d75b57569595e6420f2b8bf3371a68308510d82c0d403aca18587d09a404932a52117d3ce846b7d00689b529015824ca828aea9c2cb5cacfaa551c0da5ec96e0ce2cb9fd25b8dce14e39b534e0785a96c982600464934b738dc8f2789c4928a9caad025e78c90d84cf4e30a39eb7c0d7db32c7abf2495cacfd9d7569a5efc0c34ad737f70c8a3fe3e34a253198a03555017144a3db6347e06f988f26de1f1bc1b08680f4b3d57fc1eba5cf64e070df9681b09be48cf304530358b7d4b956036a1cf9ad4a9d16230fb89d7040604f63f65df1c2afa4d3c112148eb5f95eccd63f8d7f15445d446d943db13e558eb23ff3c24c3eb9cdb03ecf403069759ce25c046cff60ffe313819376fe1875f710f77e1a9756e2cb8a86f5855f66d6cdef876e5591d62a8a13450602906b46c94541be809d24069afcb03571af9324cc09e1cf8cffca2d0a82f6b67036c1e802eb6046735c6b88ad09f4ea55d1c094b9b07bcfc8eb2fbeb04587ffaeea544874a0c661443521c315ba0485ddff72b05ce86ca3328d8da2005633b98420765034d2a6e434718496e3389d8dc127db540869c3da5623dea9b5ff79d4fcef77ffee28b738ab8f5e7d8ca0b3c7ce59ef6bbf3e492187871981342087152bc31817bae875777070867f52ba0521f1a4b0eebe6edac7a547dff9536421ada6272693970aa7f2cd4439c5d20ac4b34a02eeb7f3f8bb4bf53a45e12b043bb58a6f973c47721b32182db5965071848640d3f75b6a5ed1c69acfe921118ed4879f691fc1747bee6536f7c96c25905db8f8f5720ad8b58d00736be3d5ddb799b5c3c7f5638e8279f04d80bd3f052a1769a59923da4dd353c8acba5a3554d777acadef6ee4c07e6d6027948faac068dbed036058b2daf826f3aa983f8c81dd2904d18ff8c96885d9829753ee9e701ae792fdec02602044799793827c3c1cf730e27f0caade359cd6cdc31522a694aebf23ede27a62506769302be7bc076754c4a3c08297010d86248d6393fccf1aa4b63d4018b29d6b8b6c134f678b3779664a2beb18878a90867428eb4ad311a681a5bd807bb6daf89f053af409f363e6cb56927612db0d3933e405db94d5732fb8dcd946ace19aae5012b76eb34ea7ab7e7f9aabe6649bfa86d515f208ddbabdd76253ba370650372ae233a7c2fa1a7f3caab3041468803f04684a8c253c279300269212a8f97500c15189f1b41a0194c87358818909f66c60b44dedcd53e0ebe616f945ef005d79512a70f6ec87a60034d5f6920bd69dd8dcdf4ac0ef74a030099c4e9d9ca5d4adc3c40f2aa2496016e68703fb1ce8103b2824e99455025547ec4c94632d88bef34fc29f9c4afe1c629666926dcb341e82c779dd2fc813067d5dd7de48be68dfec9513f7d02dd98921460076351b5aff06be606dfd18abe8228ba2de5def36604232a15e709e95b38f365df2ba716f1c5cd3c632258881a27b2d125ac0b3445e8fe9ce9adfe5611c7ba280930ac0f77727010595b13c94e0cee59ef3fbbd9fde55799459613af7a3ffb313685b61bbec49a7e2979e4dcf20e276c7595e96806fe670806e4e60b73c4d4c8b41aa840c5ff4e3d3b7ee3563b8549888ef2d26b57b4f9af4059d51e1da28c54293d081f0372a2945310c549e6f1b3bb8fc2d304796ae2c96b382b8c96d7561a2d6e13b4b74780517b80ed7b6fd27c3decbfebb72692154c29b281112f1e79288534d7535632f5c617bcf650ef25c7182d3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
