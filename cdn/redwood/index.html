<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"504188242384aa79875e75ef735f3f4065c1dab4ea90231f69a3d3b2493b460d90d4bdc8b75273410d0af787f9d1c390e6e4889e77b3cb6ce9998aac23cf9d7a919d8ef3e80fecb608971e257ea035b73c8b9ddca395f33452afe18c64d551b6ebd016ec34600a963edb58ce096f050356e0625e1a43f98bcdce27539ada00b787078c4bf60a305d1c571d44caea58489b6c37f349241bc2afe683fa055cca59e58dcee284032f1d2d749564b2b14acb5eb86a3ca7c0c7fa81ebf6632dd2d808eb880efab11b73cabaacf559aaa5e7b63dc3f36020d2c85fa3fe08936dc28cc95937abd9de31206cfc9f4cb2efb5ca0d1115ec5b1318c8be74253ba9fce54daacc9400392259b088b130391ff77cdfc70ebc8d3f954e6f90428db94fbeb20d55b4ddf2a740df642f95263c3b904d4d62a09bb13db1de334a8f208389834dc23d91a8df1af0402e79601aac626ba7a722b7ffb8b0f85690801b3cd6d0a2727d8d926c8fda7443b1ebd36e7daa5fb9b8609f299deaf65a131d491a95c70d7e5f91af1fafbc94d120f31cea4a0db4b05581b1550f964016647b18a3080254309865a2f64503238d27b402705ad79ac4d867bde38e42a40a15543651c0e969899e2f6d2dc5e46f1e1a17add98ce2345e3701ed2e03e7c6dd0b5ed01413bad2035f32575c7b7171a5f0726a617eecfae305503e19d193975be076475a5f72aa97a4b9e0926318dcd12ed53a97633d1d60796e049d2c5f730297a48b9aef133b4ea415da855a3fe35a92d54aa4d8713bafccfaa8b9c1a49eb939d1a565668294c35ed71af6f6eebe27c6ff5b891d77f81d61787dc61ef4a7a584ec5216b5942e32d9ff217b103c231d91dde19f673939cb12ce2f03f9b37f805d552023b3eb61f30388917085342e6b8163b5d3074f177cc1e59765a63e8edbb006afdb58cc85105e4bef94b3254c20204d554859b7fe3f69e1aaff3adbbae3ab8bdc8cb35ac94e953b3ca8f7152618f5486a60e3c8d8454287f8980f58f2b82083275b309b5bb72e0ca06344fcf4e9be8869a0de504fce8e88ac8edff69ea84b119643096e6173d522a47153d3147ff0736de329c9cc217bfa58e08674b1ce366006d4bd97d9eedba5476cd812f00ee396b2fb6c5a8f037dfa23f1193944afaa56899ba386ccd7d1bc4c8b9e59bf057fcfa38d1ca6b5fb5343a471ba9672dd2aafe8dec7232e92873fa9c4f515ca0eccb0e13ee41a8c143c5eeb5ca599912f2d3e27b48209a0e94f7b8c2743fd65f53f449c7c3edb0c5b8461d2a7e7f378b4d2bd6326f7a512724624c63ee10e4a051929fa9be47a2696454c73d8099e1010dd90e23a517266da10279db5d9abf9f65adc04c2b08c086aa82270a7ff7bc09f0d49b0660c971eebff74b3e20f4067511ef15e8f3f0641f031fe0cdf3636677c379f0b1daca0bdd845e4c64a2fcea3f5bdf0f26910ddd13fe358c36d425d48700cd4e1ef09d8c2cb753cd3df33617bc6e6ac25fbcc3048281859f1c5e91badffbef5543f7bc4a4922dd50266f84174d0875c2e66d99173704b66cdce4809116896240b030a3aa64d5b5efd870a533b46227e7d9ad6411bbfa140fd3f787106c8abbe85ccf898cbe9368624bf6daa218cad737a1eea2bcafe5c81721e97d10e84d0e1ecb004ed297ecba54ca499d3b8b45c5c5b7028c3d40af5719841bdac72e0f5435bb4f6ebcf6e181b0d25f6a566ccd13923153caff8e1139365b46449d0688d0802835da76b2b9ffb52718d9a9e1386ab1d2b558fc10544e8ded6fdaecc201db097e55f50df074b98955803a19732622d6ea7fcfdb4cea0334cc6ec6bc771dca5a1161c7dd5c36bdb1c75f14230e1afc68892263e884a5dafc891120cbe93d08cd0f50172ce3cadc3753473e9b4c977acb32d8dc5206953b475d794ae6b38a8beee6011a349519b4a217ec96d375228198a9bfdb22b263d43957c21d490efad035e9494ed5ba109f71ed4e3584252fb306645a5ea324d3ec6346767274c14e32d1de2b1dd2c32f1182dd62d530b353eff2a1abdfb7544a5545ecce1355841914fc7ad96ada271569602c5ba49c4357aa722061b4f328a3eb12f0712b9e1d62911706e73fbb1bfd606058beb93e7ba1a24dad467e411fbb076d01b69103d77e9e81d2a7b8f5a3b6ff21cc0a8aeb114d3ae99dc36e97f7b144e5b8280804830ede5ab2b9278e1f14b888357938ab4172379ff886aeb5885bb70f6faae2cec715b3d1da58406a0f86a8813340adae1d543b0a94052a9b80ed7fbf99a164257da2a57ac159319becde6fecfb2ca3b83e6cb1ee63aa55974a0466c027702d3de5329a280173c7ccffb3f25e4c5c44be7a24674bf79ce2b9c505c4a1ba3e5ab3e9eeac61e0e75806cfd7306bb0f329a429acfac47a2ae4c5d1775b837acc938864c6fc97df5437770631f0e022fe2ec71af843398b040e76b8a95db63dcb1922bbb227ef197c6285b919ec0f3acc9b2f3e55f2a22a3a161a4f79ec83c2286dc818328ac13cb165299717ea9e4f04566c2847d3f15afaaaf539846f4c774174138c1ec72c5d06f865f95fcba454238e3f2548bea7122edcdf832c5e586c465460f78cf2a459fb36fdfcafa12ff3ed9c584e989f184d4887f9c94d3cba9d0e9ebb0b621617e0f8aa7bc7f62117013d62f694f73f1242c780751486d40f9b9bdf96c0cae35811feb44b88d944235d62072b9e2cf59653af010f1d806242caa92fe29ec5b687718a3538dff52f5dac448345abb80fa857c79f704af9111c9a27c5592c47d9e8b45a18e044b47c38b5459419b4cf23cee9826533f5564b12a332f4cf3ab2437fc74bd74e6a9d638e1c9708ecc8f2d903b1b66019c653d01b8a12a2e191a9ad23f21787d810f94b3195cfb126234681546d67a0a4ecb0819a6beb6512498a9b0d47bae97746649fbe368b53f7dc448fb71a33fa5b9f73b6c2209c96c04767f2858f2c1739d8e162ae4b05b9e7ab85782a0a39f111c0576ff5912cd3c6af52331e3f3d393a6c703603a7f916a0ff7b389db206e957002fdc5ee5922214b09ae622eea28faaa66c4b7b10af32578a0a919dd847bb2abf8929e605e508e9c235e1b88e3733078a107b5ca4c7ee581cc97495cf81642e9df7f791f195ff58bcf15d6484b6c494ccd2db6735baf2be84cd1411bb1495bb79355b4556fc86d6d03cada707c0d3efd5e99c4228fbd2958f99dce3579907b35b00501eb81b5a8be19310ca4b41463fe7e48845fa1d457e84fe5490b5572bad891b24d14d36570d891b510c6aa77a28f7355d95e3badb173c7b43acb7d90c5e2d7cecdd61b8fa5a1f3217614365ebe3778472f3fc5d7427d712a46aa6d22ba49434b63980d25961fa6228e7132c46580cee7aec0ba02692d122782c27618cbf9b77d83de78132eaef859895e209ef5bc1c7d9e22bcf6d86119c6d48e3a40d7a068ce28213f6703fc27948615aef6ec98c232d51978349300aa72ed8406b744fcaac6630ef7604238d07e2b138a45e3add29a645aba4b89465a628bea6d6d5aa7fd9d83a9b608e3da0cd6e283d94e092bc58abc5c9731ec4ca025ea0d38b8149022db105bd00b4c32468caf4ba3eb229e2b9e5c25f778b6f7cc5b8603e718413593ed6be397763bef8435936dd7a2ae598639b1aa346d869085dda81499506c47f59bdaf28b63a3511c691fe2354d377d8ea31790acf410c13d1041beb3bba4874fc5fbe1f04cb15afffbbfa2d19acbce80313137cc8e8129a18c63b8ce3b75e4bf8d662a94c1740639cd35c5feb38a11f5c597a42bbc52ddd652933f5bd358346cbca6813a5d03cf3ba7195ca9654a5a69b81626ba1a6d1255e616b2564972582e0ed12da235360438829ad84c40cc1abfe36c50e476a2ce7d5c2a9881baaec48802ca951a932e2a82ce085c56b7a41d6d5bbeb21952af01a9414ce21e7f643276cc06ee76869998798a4b81c7153bd08a394f5a12f2e3b825c8546b9d7e298477c4e903f9917484e1f94f25084b679fc25bd5c6358fc9491b3354a5ea8f7e3c751525ffd1853b90f0fb35dabca060d785d4c5cb374529d45c87fd6dbb6410777df2d3c79c4ac7a1fd496830b8d6df2be143c869a5860f417dc03ebcc7c78c0099f503d6a1ef2a6feb2e56526f558f530ac2918e855ca1ea2543409cfaa1856a80e6ba344726ccc9fb4e6b4e375fab8740c91621a8a778b80af6c7f852b1bc3b90d344c9ad91e8cf3631b55be4a73d17a48929039d80a75e330979f8b30b9a4f85034e82b7ebebdc13fae68f47e307816f810f4bea60162f78804b1d2e8295277635cb0dcda42bffc512f1653eb6cf4335e7cab22b9cddf0b0336d48cc772532826dbd6d3bfb00c245e2a9f1b22a8fadc5bf3ce994f2bd09275f2294d3d08286d05d43e787230fcac68f8a67026c959cc02d654b5b7a3657395a285407dfd6ed41b00e93aa640a72b5777d73dfe0947523e8813e950202c828f5fe25000bf88bacad649cc8f1aa2327b1174c724e12f20965749fc6070c53ee66a2a4e7433c0ff4899586a54e1abad5d6fb48d218095566ae313ae8ee896ea0f407258304d71a85cfbd96d18adc54088f39235493cc78f4920324b3d900a361d4c496f92dcc35290c719a97de2eec6029c6bf34deb0bfe26664f936fe432722f8408095c820f15351f7f1782ff507ea59a44828beb7b39cf54de56ce55a7680a03e83599e80af5f0e36d352f9e05187d747323b8320b82645bb25d4ae7dd0f0f68e990bc951dd3125202da953bd6d8b190c194c8517e733b80b49a90504deb95c615286a908992ea6200d538dbd04606fed76416f52959adae96b2dabfb38bbe4c6607e624329f91fd42abf77428066b9dcf2729a80ad4dfa3063ea580c6236a3200aa88db31cded931f7e33001611828430a35aab1966cf647d00a3820891dac9286f09f43c0aaa22059a3de8808f08e96faacd93e925b24ceabf277f27d08aa781aa458ebe7ce53c9d083a7a9b14fcc3f630453419e5d5ce220215d2529573e62701b6fedb3e0973a7688f0e0d802dea4e421d25a16646e5d52ef215585d45a6e77222900d2c89c6137e40c08a46a4c846b948ee2a1afeaa8a53c13707821ef096aa3208dd1742b2073dab795ee6d270457efcc1ffea402b2c01e8da988b860539a17b015c20c77c4586aa3607a7d6ea497fd89dda0f6c9742bb76c34ea9d883acd47909a50524d082660a03a2fedb8af30fccb122e38d3c3d05824198992117d909544b1882bf22c0716d654fca365590f6db18a54e4cb62b707fd7c2d9eac756c83239496889724238dac47a7dac0eb7645237171d32e99b910be098b7aaf8bfc50c90ba709a46e7d95fc8bcaf291ac95f23c440d27f811854e31da388af57e9b299f06a6a98caaa84319be9fc5e1ac5092c23c53faa14166738e2c0ce34744bf396d40d419e83c4cde8779e79646140b3e42b4c5d6a9b2faf8297185c2c68253b478e112d8e1847e27c738361ae6d98d23634749667bd0de4cb99f9c383604704a877f32b7391550fb624eca5a01c2eab5b957bb731fad96c8cf64680efb0f4574606f4afdcc58112792b24bdf7a9539c676bde3b260dfe7b371af57229e17fd364e2a8c5b831c97f981adf490d1d6fdd21abae9849dfede526827c6c3db5789f7f3f91dbd9d3b305dadddf31e05bcaf97fe3e4534f3afe01102a429219c2056337928ad8a6a04f00fcad08224528a2a7ee7fde4b1b9a3101d113526ef4b293355ee0811178a6651da44210efc3bd9a9a153b0ec82e9fb49e16ea28856863fd0220e4f7c53b58af837c55ba50a3d3126f0f0ad32a874bcc07d5812bdedbaaf3a362713cb106406a5615dc82ab7d846872d0608853b3cf0322ec37f6c161501f007a755a18b25860c2513dacbc9b9c3ed4004227dda30cc90f95dfdb1eccf5cc1e9e52136181fabdcdef29db4bf0ddb5cd1331b96960478d9ae2c9d8722d88998fdf75aef0e928a55e9ece95646c290de5d10df0f74d704cb7a4e491ce585bc83272c0969affd2a0629be4df12ab5a438f9016dca1f4d9012c36878ab35f87c2d523a9fbe76e4c0d3bcf6b72d1624dd2713a35badf0e42e0271d28c52b47ec9dc3f9611033b2f1382730b168f236a576fe8ac48d1bab99aee54f8fbd775170e23d6db30bbe3a0e80fcd959f7f533992a0fb7b0df598d84dfbde3011db9031c4ad9c5d03381d9e89a757f04a3cb83056dde3ec337f01023703d04392d373738b8bf59c4b7c30d3467bc71299a0c7cfe42d1e8638005890e2b0154cb62faf7a2cda3e9da034b48f312fe0af0441c2a1c127fead6f02053ed5bf0c83fe6cd2e2416080ae5d81b198f0300015afc9ad93da2921d10a4e3a5866a3840ab3aaee07e6523ad7a4033af840ac36b672e2422c9f16e8e90b9590b4cfca0fd15508bba647e4081db14923491f9ba4faf8820d9068d6784c46fa5314861925007028904d420cfe588468a9cb41f5353655e287486755cd814032f147115730592bb050026504a2aa08fdacd929000de60fcea0f578b07d8c3c423b3b59ab10b996052d7036eddb07ad647a12eac7986a9213699557024a6c07b5ae8cb4bdab605602c45586135fb81144680c1289d78f77e2634fb554bc85ba3e9f53c4e4edbbc5f7f86594a06119fb58a3528580e9a3dcf9b13dfd89441850b137eef9358a539900e6bc69867e8a2ea83bc79dc4566af5d68074d9ccde244a320556234a8baa88f3a0e4159f7d4317ea4ad9e52dd013951e8310ef71e38e712a95cbf5dade05069cfe2a543e41784361847dc584d5d359e21ec5524355c74bb6e34915da6d3afb8bda86cbfff71e7ec2247f3fdc7d3631bf6f774ac4ce9e6dba63550e729ec0fd97fa1671581089dcd3171c7ac5c3c59788cce465054e992eb91984a5df8a0a0700445be1224bcad1f3534c4a3e4d938fdfb3d0705f6235e5842cb0bfe323d902ba0b4763bea8e72f94101eba9f9e3285eff8c4b50934c9cbbd83e3dea26145ce19e966872abf38d7ff510c118626c1b6fde6aa97012cd6023aef66653b38db0f7f7a8f1110e3a47d63b59e6b0799ddc6046b9088264c0617e5d32c4d469608c336478f9b0dbb1cb80ca2f62c79d034aaca89db767c267efedc8f26507b97a47baf27f5126d027369cca94b7e9b0adb7bdee5156c252ae904e7ce90f7e6ea2fdc63af3d639e67cb159cc3e043817d81b0812fa9045e8cc82f412547956319869a342e91bd58254f527354da03d37729134a95f4e6bc6c38d6a5332e28a51c8db79d02b1cd716340ccc9781201089b34fffbfe99bd72899d30382565ca522960214879d99e3a8fa05063baa51efc18c72c783c10a21583435f7cf182caf34dc5b7b8fe02451ece1123013698502fc40304bf822fe52dc9b9b9de62780650104babe35e9b0fb3fe4bac49504005939d0a91999e77ffd6b633b8e40f69090a15109e9c244652207c9eed694908132f31eb6a043abbd035f87f29a04034c6679df337412345bb1b3f8e4c1436746fd83a8e594e9cd10adecf6fbf4a4474d440b3ec22716b84e245449b7b4c3cabecceec5f240152e2b0180503a2556c33a4d9d3443667be2e745ed0dc49c3bc4e41292fabd629f39b62e6fa9a5fbb5d6f30dcbe5f8c2812f0486fd636da403898585e5d52ff60ed0d27af07c78725e176639dd14951b4851c83639b467e0c25e5050f15eda152f77d815c2c2088537d6c37a33c14f084cc61788c3d713c2203a3336d1fa719baa76cceedc913a32020e97c3618098fcc4f5c7ee658d0b6e50ef4d27c00bab4b244218dd9d7a2ff921fa9d4f99a4afc3d399e72d8d4de79b18e2b4b4b36c3538026c794bc1206565e1c62482816b4cc36769e3847a1d0936e0e72fea9a18c419758dba538f8e4f77032fd804507ee21b93b28f9f13393ac83df421d5785ca9cd02604dafd37f040b806b3a4f28ad0d6578a90286f530df06e95fa73c990a75f1e24b5cda759909996f78aafda5edb61f5d6ef41056bdd6baf6ea9d7b3c4ab5c45425e59f0a7feaa8f9594f9f8d6546691d7f0c933b4762e0fa521b2ddcde4540b1e3507e17f96d1dc76a83742c346ed2d0dca6b2e20d082f291595ec19288fe0ae7c7e996848899e39f02cea4df3b0895586d1962ddb6c6bff28e26f3327c4fba8ff4ba573731ccf0e6c0312ac0728be83d86db9e4e09aa4fe0b02a5a2e24e6410f9237c6705266f12e34312e621eb7f0b113f13eecb2100b17abc7eb8e209de65bc25f79d029fa02679085b6dce9fbea34945789c751028f55bad43e1d68cf4fba65c7bc32b384bb3c3e32dfbac3f56867895421e767a3809dae773f8534baa9391e2ddafce4dc4329038ec2d39b28cd595235b9a76ad73f48190edb60f282d80bc28c24eb6265de373ecb20381916b580db1200f223842ec6b2fb9576ed9050673fa2eca89e44c1b2526055536314ea1d4a1820e28a8ced9ae2700d9b53c29ab75f97f0be3c4b3e1b2ec6014764f6d259bb1f197ca57faf6c7a4ee1d6ecfd9d830433efb19ea28f422bb60f0749493d9272b252bec77cea667446fcfa0a34f438888f018edffce19c9f98d221496ae202494dd2da1e9eedd7c21a2c476f7c1f40be417e2d9bee26ee7b1f7055254a01f251596271a93731b60e6406d441b4c8a15d1fd2cfcb44bb4bc86df86c13fcbe0d6911e564a547a6b6179fac65b368a770cbb3bab7978d2a2a0559c9c80e4ed6d397e7eb36e01363b7b29d31cea219b6f6c77198cd24e226515fa97c90c5737e66ecd9cb02634b138947e823be5aad0889475d401ba78d08717ae3f6559c602fb311f964b01942f5b3fff52b3e2f32678bcf8f47d04fdef7e56604f4caabf8aae4d9cb1ab643acda2cd26befe67806f72d1ff180ea766dc215f56bb815e4836adc8192b4836aa90a218760a7061309f25740cd24ad894891075e3b88adc31e6607d9620969b46027974545ad300eb2f31f779ba6db260e21e1e63ebdeabc82686a9e55850fc791f47e5f14c950b3d31be1c6446a8b4a21b11f4931f33de59f8f7e0ef20a100d468c42678ec321b6ba1823027dbc7248ac8005c8e43a18581194bb0637753288bbcf47ef45e293a22e80b9ded4baebe953201629ebb1b987731c1cb6f51250c275b6f4cf50d590d70f7bb9b180c62c7c634d419bef3917414b7a660065b04c904f8b4fc2a75274b9f47da1d595191f11e065fbe7882a580126b15517f1891c8a8cdb1b8531bfd0684045639f9dc3db045b7a37981dd5a0103def4897b0d4e0658b04d2b3ef8a31f21ace7c70d88ce100ab8a43c0d6a42b46a6cc0982a716cbc50f408306400f3531c33cc2d58566b1c57d379e5ab0bbbe3a16890652c345bd57ee605411415717981e92d0bb51f2004a45e46006c99c5377d820830e16c747714660e62145faa3a1efa456c8720ed0f13161a13753532338aa7a34bae6bb01010eee36ff139b4864bb4664e64eba660755b11fbd124aa4f421a48ea7922081a3ee9af583b0a350d9a2c872bc3c7d89967f86e7b3ade30fe638dc11773b74c09cf0c2217a20ce8c00adea2845e2803d57ade194ead9cb4f913e5aae4b4bd5828646bd43994833dfabcc4e947d6e59e03ae5b2d6a647801e81dc78c87b9a70e078f2691cd0e6c79d97a8f3fdd41efa51e2d0ad0f6143071d0f3de40246992e11d0cf34f9b173cf8146965db1cc11eec9878823e6f34173611cdb9a81bab6e4a4624f74e8be1419851b56ce80c182249b7ccb4b1acc262c17a090db867347dac35087f114e2c49612325ae630dbcf1a4c99a8644601e40493f4a2fb908b5e7c59dbe0b1c199cba57ae48a52135d54760d27fa47317d2876c615712a3bacc204a5bd88a9459d7aa92a5c536f3ba47950cfa13a8f9c1036426806a1e744c218f9b92220290735a16cb05f4dfd87d3f237f9c0bd1a902d86115b9a1a9a5ebc76a339b00a85ad9b244137cbb77ba8c0ef0c1ecd69ad6f9a4d2901873d51053672ea77cf08e5cd16647282073f2e4889d47410bca07e0e0eb79f416f4bdc8c08ef14810aac602aa9bfdbb5ffa755036c6215e6b79a611b21a74423e1cad23b1258db5d3d11e0a71c7137f4bccbbc973b60b29c5592f6ec94ef47ba97c46508edcfb38e0801f62c0daf2981df1929bbe9682d0eb33c9b0bb0d3fb017cdbce61b45f6251ffcad3a43c63dcd8f8b1766678978126a1caad9aea2e280c2741b29d6c1558802842cff21215a582bd4f87b3f46a2e8e01ca6553f38a872993b3b07576e3d727a347b1b107da8c2454b28a3f5f4d3d73ed8a182844094b7036d6653e3ea36df1010a1edc2bce6fe2d1697e81b2fdbbfceb8114838b1bc9012fa583af72b16992d2acd9081110f49da7857f0dcd7d8ecb8d26730eb7dded428682786dc1b5aa07515eb5c827dc41bc7b2e25a83713314cc7d79d3b59289cecde1eec41c674112492692763f0318c6b8476a4bd8b277cb8b87f60adaed65fb67fa5de7ac0642c704b33f677c4402acf1f79edb9e2f9858cbde9bc5361716b795c21df033e9087f2e0c43850a9bb714e2d6589fd3b609f03905ff8963fa16e9cfd27331f1eb2ce268f77e85c84034a7255497bfdba8c7beda5a31907687ee7d8a24bb0a88c2d36a8da4f919ba2ee48bae82abe79b35bce662fd524993b08eebff13eb92ba4890bff5f1f6caf24e89c70e4d54f382c6cd25570dea8b966fadca0a0679705c1ea086f558fbbb097d08c08b1ac27fcbeaea280045e266c99055f5d4f99e40c5913f37a095ef2f6415f011a187aa0f7d924c6857b36f3aa7ef89743706d12c383ecbfeb3268d8fe876832dba3b9b7495ea45982cb11559bdfe490a9540a776d7c9d76b9b3b94c6282ed1f98194f084106f208a7eb595a2af610880d75432db786b1af659e41d8aac0c0364723607e39b35cdd4a7ad2cdd3fc8adc18dbca79338a3f61b0b174e5de89f022d2cc015574c5efcffdebe25d84f23b8683cacbfc2ba54afb42701a529441a6a9dbfb1e3801be00831b31384789ef5869d9b93ada0b42fcf0218698e7ccb395f1b5e64ed70ab6e039fad49989026360b323ec6cb6677ce03507d9043dc1cedd0401d05a8debad5dfaf9d8a1582d8fa5b725aa5e94a3eee5f230c6fc209074da50864019e64ade6c1d678f6b407f07ddbb7435fe8448c32d8031ae6bc5ed998a0c759a506541abd4af5de1ed8d73fb47cc8959ee9d1bc059fcc2bee4f58367a490f34493239822e36ba6dc4390041fa83d35791bc68274ca1b4082316199bd10ea06b699961f77e9340373e2d8d4ec77d26a7ec1920f9d80a799dcfcbc5aaebcd457dbaaf0db568460fe3d5860932d32ea1403b18914a93859018a7dae6f2dda8c21c04c79fde9db4eeb87825aa50fefd4fd6e8584d6acf440a33478feee0af04823ff48f12d768741a8e68675e2ce696efd8c4307ec41cd7b6afff5320747908d350757ca4d49eb32b1ad13cbeaaa63d9add1e9a63f93fa35ddbecb1e8614b5bc7aab57b5954693132a9908a831393394bc6e816bbf9eb3408e096655c34adfc136d43d8e2464d56fc4d82bd1c68fa3b05caf85030b31e14d50c899367cd4285e34247e63114c9ffbae3e7723a38965a13d9fb1b51579198f0dff21a2c6215720bcdbcff53f54e08f68e0a2902721682f37616e23744ab28ab4b8725da29105fd044fb2cbf7326f95961bee28084bfe60002a5152ccc90ceee4232641c88f89bee200b7d5d5aa624bd7899c851d2be9c5c1b2c5183c24bfffebaa70cb1c9b0d336bc02be6d3296fc2e2505ccd41cd2e578a88e3229092daae2888def850c8011eb18e126c3db57d904db72fc8a11527a105421b5f43bfcd9cf066b2fec216b0f26f8f6db1e3e04201c4a054aeb60b5d1e947148ce4e2beb784f2ddc0a2439bb64b4ad576c7a8dcd2b62df356ae57c26d34c07f6ca1f67563310f23e1fd16370d954fce064584f9f852a8593aaef407c63f25da1780c7b8868e7072f5be7c39ace54198ac9e3ac764624ba7cd0c9d95e2ecb69c4dd422dbd8bebb135f09439eb3d6283806aa1b76862d893eefa582632912faacf39421c846867b721975d1e8e10506a4270b5ce3ebafef477cb85c331f8f8b164dbffb1ab77084ddd3c22ab7a154a83a5b8c2819229125cc7f347acf9b72b2cd52827c6a5fbeadb054e4a276aea12912c9a5caf894779b8a82dd8030fd22554269a36285f51c538c6b35a1780940e7c5010150130ca30e2ac3f57249e70469b9e921a44eadcb6954d0d47e055b3b54ff83da904c7d061d1aaaee2181886e055c4e4bab385fa78bcc703b649b9cea0b3613261674cc6ddef4a99f426065ee88efcef9824a81a608be7543d322e178c335be320bb520a43bb4417a3b8687b71021e233a85a75856078eb54d8878aae380335543994849c67e05b45e823cda94c727d059d7b9003082d3ef0b58b16aaaa20b390bd8ff412964658e31a53e9cf0b0f0e1e437ee7292bc17410ef1bd371fb1e49517b005613619a558336f2fe9bb0b7cc6f8f81535eec17a3acf7c6a86edf6d7239c64ae8dd9ac0bed3bad273c76abc9f5677dcbe582d0b337805f6d2977232dfee6bc35a8d24ebef155fdbd4120e63505fa06d658f42481a659f0374093551f6a4465f2dcf67f69cb20389c28765fe71d10903f7ffed385382c4726aac21181439c9237cdca93ffa5359f61d6c04b382bb903eae2922029047b05c7a953a79fbd8e711e26e04c5895dc06728eca6debbad55beb8a545994ef8a7ab56ab053d1ebf6454352ba261b71adbcf35889785fd6e70a61c0adeac4033614b11f3f7f287ea75b3ce816aa208bdf09e6a18dd9bf221e9a21d1f8265c86986f8d0d8ac293e77c2c183052105f298efcdbcf295809acf1f34896fdee1c8516d80b91fb25178e07e33a04fc226c4033451c23e4ce31024f05454b5cd392137f52a4bebee752114657ae112a26bd52788517ad6d0ed7a3e22654e602fe8076799ea4937a9fbe506e192f5ebe19540b543019ff7a902a510f25e18cb5b94f0ad682878480336c52a3ad54e839a7d4ff8d7c7fb6ab450ad03c016ab8457fb1941181b5153ba6dc0e7b95c913a4124294993775ed98868949ebff9229ce5d667c1dff425f2dab3f9ec8d85c1626058d57af828375d16590d6b49f40781eac767fdd38d326a579f7e2823a05b5b1a52de0fa3a48373a1558c057e7b4ec1044313b32dac00a01bf2d8b872510913b5a69f6bb931fa4ee201538f692c1a9c1ab7d41088c5a7025567a01d64af8164672247695bf176bb198f66ff4f62574980f0b526a4b1e8a8a552704e21e0125c22e95ed40462b64ae8d86f2d19f27e36bf12c582a954f0e98a6eafa0a8a9f3b58f8703616d3136190d1af5803841656263845717e24c0e457df3f14ae48e8053837436cd376a1bff6cc5455ec0c3d65f8fa36d5bf7abfe8bc0fd2102b43cd37aa4afe917ea2b405df293fdc8dbec35f22fe2eb2f45d220ae63210eed5f38f61d4f3eee5e5075679bd616b490d32d000e28117549f1b8a57a0ac057615a2be1049f817b149688b407479a82b77c65e782a7443dd9e9a71178482d17c8635a00f72f11a3a2e0179953b71698ddf714d34a169b01196250b314849b41e1221cb944467031f76253dd551e6c1e08500c70e48a41314492b77fa6e747087641ddf361ba93aa7ef412a377dd371d25aa8e640e3a76aa52dc8bfea0aa1c6bcb074652468aaebffb6d2ac0a00f8eb99e148328fffc24ba9833e7effd01b2d80a29083d7dc83a8ad57ca0d49dabecff5ed8b58dac0943eac2f33b592258055f07be88af55c3212f74b5ec68b0ca42a3b93a1d80361d379276e3e550d1d77cd0d427d0f5c4c071392d58670b810bd511bf5e2c7c4e5157c8b9382d6e3fbfe1c805d4bf07bff683b17fde8fc30114a37532f76d6d39ecc435a1f05971ea33488f99efa6709fc06b0516fc1378ab6746bbc8f1a297c917892dd869613bfa0e8b146a60d92ecdd59f243773491d4978a72b1a421fdaedd32d326dd150519e00c5255bb5c75a0a5d5b3eeb637f9345a8153961ef09976525ed5edd56a975140c29db349cf5cb97ffcf44acebcf623112d39c9d63d6c8dabe3ec2250462cdb1c600227b57ab8a827bc12327daa52536bc95ede09210fe218ba9a965eb0af2e35b5c7c685ba92bc45e3d3a80cbab858439688cac7cbeb40b07a136184bc1e4e7c0c817648ca96476e081b4dee8f467f35a89056d780b87068def9b1b245e58beb64a37d2448299d59b9220b4e9ab19da37e7356b98afc591a0d35cd62cc3b4c86c1dc70d03d922a0d1799eb2316900f24285174506898efba46aed08949db70981d31d6117be995925520547bea5f47219a2592c85015c0191e3fc6c2f983d5716a7a8a557d8d34067684709d556b9aadd0494ead80413f3188d30c3d59d066b92528082c7548c740fb30248364f7b4ae9b745b1350d1bf44f107eb3eba79e11fec1abb3e122bfa89dbc40f7abe2315bcba4077aee231bb039acb7a51acbeb88c722b29c5bc0b0ab61a1ddfce203a1d28ca2f856586c63476ece5f1ed4e7ca65f6adfa5a3c0f1872c69441dad735a456cdf4821f47a92af483db2f04f902320b783f9f5bf799bb767504132698af7a59615d79bb54be3877393ea1017c8039a53fa72a5ca2c672fffb89f0b0a02c56fa64430e9817606260f4fac00993e1736186290be064fe5ca9c5e234b4dd72a7fa93a46cff8c91332253b869b492f2fefacc314a82125c96cfa78e75cda89c33072a700a0aecc95dfc38dc655b0413ea25959d144acc6f21fffbb4ea1163d852a2521cc75bff6942b9f99cecc710624aa6b75c28150aab1dd79d3866fc73a7925e8ae62573d678549518d7632b9efd6dc38273208d650bf9906b50edcfbaa180e16c1258352201e98343cefbe188460888f945ddc4572a1aabceb5dc74b9a5ffa63585a71e2fc2032368991e310cf661350b9382b34f37db38f3d26ecc7648b5fd3ce1dff65feaadb1e942638310a74052a3538a3dc23ce2deee9d12c8ca362111a0a32864671ac81a9c56922d23674491308f5bb9fd25df6cd836978517c3f59c78ee5d4e7cee16b040f1c697191d2242e8b1e8254c5b2c7f42447b4b732b6895f7006f1346b85e2ba6a0a6e14e38a8daa326a366a00d02df2ee93763c38db33007e12d0ba50c59dd4f60e93eab941b042185d8e1fc249ee3e7becf6851f43a4fd50c32efa63b0831342ca6b83fedfc9353f756862e12b65f58bd148399fb66faab04bb791bafe40db08a668b9ff40d07f08f2248044d910c871a236c19815a0d1f1b7c4d060f899255539a7b25e7d28ea3e8d581ef0f7c910f963b65c08be71205b26164c18e8f8ab6118098c8f69ad3d8e6ec965567ab16e91c822273314c81df305d4785204f8e8db0b9cb60ddfe8b59fd66eeaced56399979fa3a55ffca38261016a44f0e6550e753a449c7d29ff70ebb58b021f360b3b7bca1dfe857e19e8c854f16ed31173e8eb74ba94a4c12d1e37e2592520b00a92e97273781eb032ace469ec51ae8b1f39d338c0d2af6bac7edbcc22d28e07fd4e6509abae18202d60f806330cb68da87b5f2e494a6da104b5876c8e2423a484f4f81408c9f7d872c7ffa52b016f49dfc5d8d553f3ce709e504bcde1ef5683f96c0f0ed9d878b54659894eddc895b60e3acc296733a664710fc537ecb494638ca6361ad14f0574aaee21129aeb30de541be7aaf1ae1003d39411285cbc6c11c7eb02cf661fe0e16808fde53f34c38debb2053e93e59762016203c6bd508bca58269e823847e9ba84f62a5677573b39b1bc9152d1629ed0315771ee10deff3c8c2b364ae6cd2a7ca1ef2de02f6f9f1f326573d2c0704f1bcc26af38c9e2a66ef11500f19281c84dbba4eb8b43bf4aee8d81b48ec6cdb81ab9554da4abf0900efe5ee00a7cc24e76cbd50c84a173471081ab936e7181f130b55249f334216cebdb1f9388794f5b04a38ea59276617acce99384e78883707dbf9cf5f5eb43d62bf12279de975a045735b3ffed61d67edf7c86d4f8a38f09302ca8e7a12a19784ba487667233b07a171e22897ac85d7920c7f5d4e2cbe6ef52e90597a4e0808bbc3f99172707ff3fcb443ca250101667afd70add87ad7e201f62c62272f5a4b8df18d9121201e52566a2362d96d578002113dbc40f51c7b91f505dc613ffdd1fc2c03729d56577088631b6b410ab3ef39299549da1776d968fd93b15c650949d7a643cf23c8159a1435dda7af9fa50ba5ff0b6a7a45b6372cad657d03dfb3b236f2f692dba4976280f079b93ad4a2326a464dadc4e71bc772d58dc2350ac271af0dff4d1517071225fb72df0d23ea1c5606ff066d237688677c3f10ea1f0d52c17baa77f870fb1499bec00232dc410e804ea2c3d727b2b6eace8d98f69012603566b40fc299bb2d148498e54ba3c8fe43848a6a126d8fcdf1db7d66e551c9b5ca39b2abd1136ba2789a352fb77580e628cec710ed5dae8efe613761306ff751749b00660e4bf5ab4645dfe0d611a2e12105d64c157da0c223d6bb125f6b576c09807eef642f1db568b74dd75fc11fa65c6a6155d6d5805399f3ee23629741d96ba255f92fc0d4d3a682bba7976d8596751da891bdfc9cb4de78918b6bbd1d12ba76879ec4746d3b98b171220ef85a14c73d1e10280c0453294a38f2ea65f22210111ad87b24f728734d58916048c23a025f8ed86c37ce344f53781866731ba8b7d37f84cfc801385ea88d5ee140a120d0ffbeb906618810826efdba7d9e6d7686d371b24561e6b9cdaa31f19b9a8861dae39a5883b1a55ecafb4f5292d05f6afe143e22c9a0fcd55a6d7f6d5b2c6ed5c55a1d3f7c520f2f271039871b046f0235c17c06402f2d4f7a4623624f09b96b320b89a1ba75a5dc6a696131f192b52a67112f41adf40275cd6ea2fa1324ae0c7e08396ad645663c7216e319c6cefafc05c269d50bf7614effa8b0b2179f7f4de06ba8c73bcce9708a932a153b2d49773600533983a318cedd6b50497ef2ee226aae52740b453b5d853ff6d8abeca19aebf3af5bec893b2f4bf83f2029f08274f77d28e94352fd8de50ff57e0f7d87607d5597ff973597b8dd4a1fa6c1a8215889fbc8afb7eb85365916da10a83f2ddabc81176ed49cd67e6b7af3ebc6760e1e9888ecec1dd08c726c2cd4c8e45326ff9fc33aeba95db3e981bf250a5282aa8f50de92f10d67421ff3ab1b12bf288cd3013ceb9ab52d3c9998c04d6db3c0cca08d07dd4c47a79d9739ad3c82d56ea208165c1c8bf88251033ee078b828869088ea491b655dc02199138b555289d99c777e4d64b4ab00a7188cd1ccece5bd4fe934c76a2b0d3147bfaacfa14ff37a502381a7cc4fd10074964b8d86dedad63a293fb4136952454a5671c5dd5d55d85356a5e1be05feb078b2f691047358bcf36814192e6d07ecd393ae0d384bc1804dd31b6f75252ba8a30632433a968683054d8669e9a6d66bf1224cca9527f4ed7a00c7225ec56e97bf02cbcdf648afb12776d73db5856137495e3d4216ab9681e18c06ff05abebb9dd3fb58340f3632df2da2fae8cf0adfa0b3a9a1064f6dcf3c601d9918e7bccf36bd05ec4025fde7a7e40bec500ae5e340b839fa906b91089ded244ad1aaec50cc7fd04ae49a4341f3370c5fc07d3f2e91de41b90f61428ddee2f9df6e9d12743c8dae681d1993eee40c9c6b30bdb6c409d13f1bbb7b9849264a8768e86babdf3c331e7c5ccc6d88a4752b89fc08d1ecd199db3af63afee8a636ece1a4a572318b1be45d857e32e056d165f5c8fab88e4886a62c9b8f77e25065075a2272b0ef5828bdaa45fa53c70192011af12c5e7b4d2159bdf209a3e7c8a0cef78d5c80ff6a4c251ec08700359b6acff8ec4d6484114ef4da4e32045860ef5a38287ee9d29e17e038951b3098088a62124c79e6ea96655651c4baa87cefa51cf906a0ca0f20c12990","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
