<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6272fc99a001f401455c4c9a3712e4cbb7b8ec086db75b8499d5f99b221e6e9866619cae05971d1d6d65f05bce5d24d671e3bd1825942abfa884670a6ece6d4c2ad1b15540b42421f834f04e4c11913c4bc63d1f8cb08b6b919b92b43bc3f5875a4b0128617adb77f9426000f68d809799416c90f97bc04fe4000a938de5d66e78b0d6efb00b8b118b07b802c35751685d68f0bd1cd9b76be97d16f17557316955c56632bd62ab676de57518a5b288037a20df05a74941b0251dd98a28705e4e9e5f5efd3f79bca9c02b9422588fc442b23ee40c6cc401b6e45ac28d4ec820f8bf5753da3709a82336ffc3f3496a879628306469a7001f125323e1735893d026d4cd46613795b235a45daceb6e7d9674c036436c82f92fc6fccb2914d8fceae8280743f7a0c28313bad3d2ed45c226ad81232997ac76a68918578f3d9110614f3b12488fd453cd7dfcce765462839b81209bd1ee1d0d3c17186b92a9893cba941f423551861f667f53fe60f9919f0fc30bc0454a8b33817f2e6c8c153ded5a100aa29fdb9e1cab6e8692e10eecae6c97e951ee980422be73ab8c6f4b6b4bed8ab7936861fb6f2563c108ae13309d36c14c3100168e87b06dc077b3b51501db79a532b69fa8f94b044a0d62213ab12d8dfa0a2a52f4f28740b225b99ed04fbed16ba301ccec3d0f37d8f83904882408565f75097329fb940410e4ca5a25dc42548edad57074a64a09268d4f10467f2644e39a286a511f9d22683143bce7186f2aee8a2f40ed7f27255a5baccdc40e5813db0d971a68d3dfd79b383ad7b1f42c5d83e0947baa406483fe8fdc5aea84ba2210c5d89c69cd0a767dc475e245505ea071320eccb90458d640a872ddf804318a4b4f9bd31483d3953a0a6f90b782aab0ed7699e5457944ad42c832b74ea45ba202c4d131f30160c4fda0b535516d2f3366f61255cd0d92561c3bb344798526876e6f9c62fef920b4ec400fb4b25dca58b24f8f10997f1b6b90276dd7a247adc7d5000d7505ff77baae11e1dbeb6021691a0da23ac4df8377449792ee2e4090c95c9190306cd84709db3cd634d3b7bbd3ab8751923a96c375a93988a4d712213f6b405dc4d460061ab9a2e2c8d3b9ccfd61dcdc645a7ff9b5ba5b1e0c506eba2794029c692ef9faed9753e1733ea6767df576ff0cb526cc402b67060ec1e6dc8ac01febd227d88c6cb009f31ef6da36103370d8dcdc00e8273f2ba6b3b7da88c35f62a1a746123c5f6d51e39eed2bd4af14ed2b1f5699c183a661602543456194f4e1828c3bcb306e1e3e16f02580cadf677a3654b9d5abad93a94261534cd664b0826b93b373101661284db5c76dc9e10420b9d4127b333fda341c8335a68f2c7de6315fac592ef90cc31135991979570a695e823fcfdcc36fac9e6bc4c2b7dffa397eb7b5761136a36054d76b06041d8feff26cb3b00d69f9e86525cb925631a20c3734addb3f7f179cce5df80789f0763754829a35103ae774ec583cb4393adfee1e78abd0307a7e8f133956be9a77f33c8e3b178952efc833e41d246017fac96b4f6b0e3d8b9d1d8f15a55426d5c70efda70f3b90b231801f0dda01185332ca542204920e53d35fe89b127142715b3fedc4d851e253b491b1abc14dc6c2722cf2a40523ed09e31ec50f5237f2f2528061f65e1c79b1b0e8c0cc6f1a3e21b767adb0ff9e8ea97dbc58774278f4bf3ccd434b6adbe77ffecd430e47fae86ed0c66cf626fb554ce2077bf92c6be20f3b6b0276fb1f7b264792a2f040d369889532d69895c619cf2ac54d6922bca0652c16eb82d19ddfa831308b81f412bc2542d49a3d997730b9c0402973ba5b0c31bfd6915de898ed226db721bb2bb513ba234c0903f1568f0d4339d54d2ac159c31e001e2d3ecc5afb4417737c87c9ee4bab3d2f5adb9328c1112ec764e0f428f1bb68d753d0ebb022c6fd381f1135ba6c71756f1b3d9a5f2440c5c94db2de4a2fab75076bbc0551b79c517c3283297bb27b732bba43395805e0057f29d3c8dc5e2abbcb44d8fb350676a97791f58f1006dbf502f915ada5744061d1bb31683023c1ecb88a5538c526ff4edb1c9d2c2b2e2b615692d86c5dd263cb38821834c5944331c8965a2c99d3f6e1735b7125a29709b496cd0cb9ad59650d711c172be11dba7e1423ca172caac926cf26e0c5f2a376612ecc40c950f8485ff12f53f2357afe22101858f53a4697580df5b01412cabfe90e83dcade18b3012828cc52131ebf4061f2c8a5822b1e46d01293d92fd1ee81118196f4869f64db8c28b9b2ff9a457aa59a901fcf4926b1e091ee526242a3c88b232b324fe38fc509cfd0626a43e32ad7babb6a43c5b9a9c00a58218a1e19518bbb36a09c00f45dd88c177dd7a30ed6dbe3cf15ed3e7d8d218acaa7d7eb35a8d2d1d76d18ea0e3c370aa22f63e96da805ff2cd9ce32ea28c05aa15f49bb06c6d507becf512cd1ad3213dbaee1398617dcf7bf01f93635378ebb0069c7212fa02012eb28547b490a04508cb82dafd26608349ced956020dfafeef9d03291893ec94c17ecbe49081a4d8248c4b7d5cf080c1e07dbb15cf70eb03ef68a5186820d53aeb12a5387329e2d156eb0b8f209721b226cd9d70b0da20b4e8a65089dde8053d713aa837b40bdc72c06f44ab2d379a0130b927d5de7e1f565bf7724197d4942b89fe85a955fbfe2953e8ac184167019e87f65c0977987e03effa41b5990788e274944d8d73a13d74682ce9b7f81fbf4282d19edb3ae891bfe5156f9c82b6ccb69433bbbb55b469b297691dd873f2b8221bf5408927ec239fc429beecf81eb1c544cf5a32e4d9082b1fbdd84c14c13d4c064c6d00025c1975c2bd512d16fef3bfdc390c6188871458b0e68ba071475174ebfb106a4b2d79cf396757a295fdc745bed76983e13c349ff313018f8dd30cd955735ce1583b1cbd2524bf6791a7c99de6c39ec278edf9bcc5a0a5906bbc5123416fa25c6182246b4f183fed6a708eeb3a97de84c8158ebfa54e9b2c1d2347b186cfd342ba8845fe42a80dbf6c0976330a00b4301b88e0022b7cece43837f470f8e71591163f5c1f9752506a772e00830012f86df165ef5286e6c986e7895d67a2f47c8707eedf9b160d0717be5f5c3dc5415f93d404dcef71b4e95cbd516599b0f7b5e0c9dd722ad9000dfb87e315253e2ee88d8ebfdb2355047341e928d116d480c77f8b1d494553e47d4ee8dbb1dfd97ca16e04b40f7c6ae1f09aa004b7eddd74d0913f41a19e3856c5017ebd4f9500a486a33844bb548b27006292bb717340ba03bb64c7a6336a6f738e535d5434f211d666184885ef7945e9fee88f9541641d0bb58ec43ad090312c2d807113f06692b5172881b97cc70ec0116e0321f63ad7865f116883c45058164debd928c5fbc028ef01b6042afde474e4cf46dc0cb902d67442d75f00cbe2958af1d75cc3c0664355f989c558124f063f5582075e768f85a8f294a9de756e1707e606709f77072192eef9bd9f7ba548299d6c4277936faf0602b52f4e25c2f7d8bc78acf1beec37ce1051b3921f0a0836661a66f11bc8e85c951005dffb6c00cca8b4ab25d7a9ec79e61f27865e0203e36588453e45eff3f6985a2678db8875362d4fc98a2c1a721905fc51be293935c5817e19a2fe2bb2ab8c72b4b44301509e962cde29ff014b11642c5b2507e63594afa1e9cf1b597b1f7725ada37069495ba955ec8fb803c9dfa6f6d56e019f13fdb5e61db047591d04001ef227297aa3b874f0ae19c53308913d944f1d8f7ff8428d9b7df06d665abd9641613121ac5ad4d0c1a409a2b15f6a7cb03deb41e4f9690bd579b4ee1246dbccf606653690a0e2e491a51c4f91bfd599e33bb794063cc35cbb5da6e873c16292c1de4e2f0900be8f303ba6444e1e8ea67db661660135d5ee57c25233c67dad42852d12e2beeda299e43f7d8eacf8eef3624e2dc4391c86b5d3e1e3265f4e9d8f1b865a8fa20fcf3cb4f8c4002198b02a83ba14e9e7ae3f6941d8a1b28079f55d7c0e695f14bf070194909c4a0248e1b2cc8367785779ff7b2b200fcda12e424250b2f40a6e1fbed1cc871a6e643f02682309c580c41e0fc1edf5c9e36e6b73c544d80300157ec543f47d89db819a78f373adef015cd71dbb669e2657a94c2bfb589326e07f73698e3f2811a1a2af1ddc516b2570fe1d3e3d62bf1d564309eff28e5de72f480e38c21f5a5fbfc93b5e7a96dbdd2be87176001c17523aa175e4a72e6f8e5204a8276e2e562b56cec1908efc0b950da2e906a4873dae807ffe41f3fa2c4b31f58139de80be2bbfa6c759e5b60b75c447910803b3d048e2bb016413f1bb94d1f929d21a0e404d66bca07e3b9adc291ce3ff165fefef97e8dd7b12f37df8baa63ebbf7110e5b065b78a7a58c3f015dc4be874130ef039f89e36e85fddce88da036dbd17bdeefd141202658a362c0c30af72323a85d83066f8ec92ea0f2ea6e18ca3fdbc6e6f0ac56d0e1af135f04998dff739ad2080354b70bb23f723e2279248bcd92cc44d16a035d05e22c3c56e445ce9da56146f2058eb9fc938d5f0da6f7675e5a24d6cc6cbf21006793db06114675dd660538bf5bcfb0f8394f95f601884ae78cac9fa98827e884688bb5a16e28ce69ded28dc5b6b47e38ea281247fbfae625b38f0c9bbc9903fb3a8573b08afd0487d90e1f451a8164efc476b7cecef0230df75c92d606f3aaea3f60736361cccbf80e4c7a035c36101c2778b86b989874fe703937d763396841dc782a269f5b2bf7ff8001808b76f60fa4124457aa280ae10f59017b235fbec6d7c0000ebabe257b12dcd9924af539ba0218f2120f518725b54025b9f6cc0212fc7c1a593981e24d38c7a4173263761aa53624163c10a6ecc5e60c5c63f99cb952603ed2feca3e75ad6f105e52ade3aba0bfb28b134bef3a7c71c6b93f1b3866ab210fd6bbaadb0be95559f2e1515b2d80be0397d16e31eba8f41d0c7ffdc982e73d5639b8d861984136adc12e3d56df446a7b8b666cfcf17f056a7ba2ed68435855300de09c05ae975b5c90783aa7c465821140e28c0fdd780a43b27c167f883eb40568a9a7611a386bfc6d5945cf14c97c1a6414a476334e32a6ff3706fdb83e25d6f048c35bcec67e39b396fac2927b8b2445e6ce15ff01a247b22911996a60cf597aa914e6cc2b4509f19090675e19719cd7b069e382e4e13204b232b503f885482b576d2bbfb2f277b1c8b692f386ddbdeabc1a769a474aff42ea59fc3c5391e905abac41c58577aae13790fe18e0c03c297002e71a8928b84c4ea0e5136f2a28074298c65c488b1bbcc785ecc0ba8a24d76ac269bc276d1a49eacae89334abfa3b9c5ce110d9b61086c51d2d7bf67971185a1b53203ea5756ac217b58ec13233e187abb8a0a17093439e4c768d3b02394f90e69813368d8c6460437e777909ade91fd46b3e2980466bd5059c6d845ca10726629494e63b2b27ea63790333b12506a13a03a9dfd8bf1b00bd7b11abb9c5c37feddbb54d36a2c3bba9eb04609200b2bfa574c2c062bb92271d8186af1fe05cef5f564c4164a1803d3e32e718e1f7a81bf9325401df937e08d98f9be96b7061f97f1dea4a3434e90979d8c7f5089a372c35bbde4a81df74506302fee171153cdca190e79b28d1acce8724c81a81cb810c07c15bd13316139cec64e0205ff4770b0727e47f53a7db5fc967743d957c241364d3a16ef62075e31beb787b86612599635e41619e68183e6d4365e122fd640eb028e3e108d3fb8870bcad853fb79bfd07ad18b62ae830402a38d933b5e8081e581c204d1a730b8a44733a55fe4a46ed030bb2b08ec70493ccc0df5b6025b5b63a5071ead8dc9e6a5938bdb676837e95537bbf7aff0d2a42a1083aedc439e29c5cf9b3690a0c2cf6cd4bc651e91f88fb640ce5971492aa218fa71ffa41550de6e357b2a4f00c0dffc15c3df9be467513f1810b9c9d07b196649f483e0ec88377ca436c9a02574f3dc570f234fb6f0d8b18f3b45fb52365aaeda0cd60214a487ae092ef78957a0e7139a38a637ce35f83d4341239502b29762f77700f22128e8200c34183f053731a330b21a3bbc0dfa9b8a2045d9fa7236d6e13008a60d1c77b489426357d0df7c82d234f1a977e37992238191081146026d4e14d3b239baf74724bf51c953bb4b24bb22ba88ba0f4cf6cc08ae3cf6ecf8d4403bd0b1c31df9f47f2140d9c753519be223b77f29cffec0600761c157e7683ebb6244c88fd2146f258455ae62d2d073eb0d80726c3981b67450cfc8f6f74842dd96776eb12a7817532b81327583cb5f4602bdafa07bf01aa9e53ede86008e4b3ac437b86b19162262364cd896c863c9a8696a5a637d257b1067b9e0930ec682bbb3cae1fd9370e136bccc630bc3edb1219dbf3899120f8743d4fe2c88a08a2a68ca49e9ae5c3a320b04705ff0f5a48dc1bdd1882a0f9852540b28c040d4b00a14c1fd558fe1a820869f3ce4687aea851bf929509658debe81800e08e16dc8739c0b5b023b1f6fc67f3574435aede54572241261887bb620b022c88ef24a94e048efa807dae18b760a983a6c154374102f80006ed649e3e80b038f9a3e9ff8faaf6c7b71d66cd3dc289e53bf2f6806f80fedb1860899d4523475530e69aed0e3928e6a8ff113de78b4d53df3f55a5b3c0393bcbdfea67e3955ad97610a7c59831cd095d1a247aa4b19c81417e0aeed5d41da8ef745498a88dd8040a7776d70898126b82fc76054d4dc9101f6efe7659a30cfd86288615be21e9a9741aacf2c7da7a43d46466f00d65c8ca7c0d7fccb02ce9c0c1dacf4ab657f2c11c2779318607e5c7572a0d0c8de21ade5ac6314df41663c0b0dc56ccea76f1b019cc3c1c0839997f29044de1cd2758588aa7ffe9964683b321019d0580d3a7f939007658d6bc6467d970aab9b738f24c6a46b97566d3cad39093530e5e09aeba1af29b4b61722faf9955ab25846faf71a453f819b1cdb8f6b1a9fa7b4ad414cd6d1d8674e31763ac1af3a49e94c2be0849c995b84cdb24b64f1029c132cd89e2b801c6ccaca06a0a992d2ca29f51988ad960795f1c35651102c5b4a34a3a2d79856174b502995d72423c53e0d7a3ca14882d9e77efd6139c24f58873b1306cf76c3ed164c84508e46899559c8de4a5c8822421966cfe7e5dfa61f79865de92597ebd0c27ff0fbdc67a36132176528b6c643fc356998d45224486461b61043e70e8d874bd8d3be3331bbe43d3bf002e4f00bbe54954dbf9d8ff3fa3d43d34327872f42a6aeb359207f5917766afaec4c0172c8ae3eae212cf2391a6309be5ef24e2ab1ca5979faa791474fce64f18afc7d111fb96c205c89891a68b537ea23c33e57b57c981aa682402d8cc06870e5bd3ebf3f92cf369dfee0b1f3efe9a3a40e5cd877122f02a80f7e44cd96af85320a2de5ca0c51d6186639dd710a2aad8b08c8f2f85540983de215c68a5f8708130361a8ede3d0ddcd60e5491a9da63545b23af7879e117a96190e1cae8dbde4e9df1ef5e579a5b3c67f9b9b6ed4b916f40ba86c06af90890e7d90cc539587f45808bfeadc05800bc899d1ec88f81e97891db8d270da364e1393449ff096f111a9149941f7c1fc86cf2d5c040dbfe7df6f5c44b287269994c64bfed99cd88779f42036cecd7fc3fe7a652ec6a39b79cb7d238c859fba90df63d8aa56d9f3d5d37de07f7c3f3f3dc534fe09033cb86eee4f84a96143bd7725eec25986f8ad3a620ab61b0053055ecb7d7dad57af302a22ba1029d7b6f22f260f83784b6ad3067b899375aaf0f7b66825c861ebfb897031738de8138839fb142fddc0386d99e6f0bcb678a5c466f8b462b9d24b4c8e9dfeaa4fa902d74f0b4ace6fe91e17c32cc54f7347a9938bfed555d1689cf74e00989f1ea2970a1a0fb33d7ce864043dfe3e754839eaa162a0901633e61c20e69fe8516413e1baca311ffc8591b3f4cddacbeb4405264b72a2ea230d008cb43fcf7f4c2dbc3a35ac7ea7a688979ea8d7ffb636a1796f47a25d73bf7d08066bb88a54be476d30b24079531508fff07c726f676fb4b5c18bef7701a224f860ccc8be00224489f0e4f8f79822037d90493871d38e824ecba14c6bcf4d361ee12a5d1ee77b4f72bacc45cf29aaa77c2370d2f4caa7cb0f3eb84b78e3d4af2bbc2735eaebc6c7c07663dff62982c04d272adb038449113438d56d7e9d11e2b34b717075be6873455cb9c542cbd4c86c81fe41cbe3e0d4c48238f424b5a4030e903d46c1cd8f52b40a9fc2a29f038d89d6658b34fe38d19d1a262eb65fcb7bc93e97a953ad9d9fc4b1fdca64a30e15597c554086190c49f3423d7fc4c0de1b99ec1a594501e8e789696e953bb71b482a79e850041a813b22313bb74a3885a32e512249bd18a9920c09665ea7e77117fb80de9d1924488e35f20bdee9042aef51cee10f80a74513be71627c8a846b7d119bb57b2f2ed794ef6d43b5de255c7dd139369383673d334ad31f0b4ecc91f97bde65e151163520042ddd18c889073aeb22ffb8473ebdee6a4135074921634318d60f9f8d2b4075c90442eb192fcd08fd8bcb2fb47ee0595ab12db35d707a625baa0b8b8a10eb71976a66d31f06e1ecc01a0ff2de85c86c80b0fc08806f8822ff4b8cb0d6039d9fa845512a3517785b85e1803597992fcba2352a07ee1d3450408afd21acc01716753b76c62c8d65e1dccf079aea31ab6f0ea9c3ce487e6e9c1828ad88acc5708bae42ed727e6aeedd15cc8ce4e07db0b5ab6aa487a2a619129c33790439c26b19cb9f7c6491dd13217dbd3808062823f954797f758a5f1c743c6101d872e9e145c4718a1d9a42a5bd0b2a9f9827d8ba2221f882ede0d91415691afc9d71d0a5b46a162872a4d93e69b1db2c4795e28c6baa109c4fa5d4c88e657ab1e443d4a1e4d86ab3b0be88155e4a024ce96e194a8d32f567a7c551501cc6c95ba55313438434cb2187885e26cb35ec6360352233459c3803c426528ac0612f76959dc82c81af535a61734fdb91ece8bb0a0b3f537b160d789743adeac97b9850d28c9b10c01c137a9fe8e28033365516b2402363765905f40e168be2f6803c45d5fc0ec844931d8fea8c0e961b50e80e1c2300332a631df95ce824d7dcd5b79af988cb778815a2f865ffb62220da95c0ff1414f88e027ff2fed5286e6880dbe54671ec75a03426ce8e4dc0fa4f910bdf2972c42d63c66ad2327ea77dba72ae4d29e8042d9204fb980184484b7678105e529cd60c5716c93dde98849c713b8b3e3053f2194977f9391978e62ad93a13335c6064f2ebea1599ebc8b47ba698987945a447cd5f73783ebd492628a44dd8e23109adfb5f7d894543824dc3c88c0fdb1abac7f98565d77e30f8551da5b04e7d0985ac9875e5b6bb2f219f11f631577c921e9f4f89d29b4ea72b4bfee7e3d2013101903edd0379af1eab1e9ae11bb42c8d3c97c175c71ab78d1343c34f372dca797b475c53d1ac336e53edf06b5ddf1a43ab6a8ffa5e08124a9ac606d5918acb9eed991ad81ce55a5378ceeedb92008b038b83eb9c0340b644320c2a11fed322e0e894dad0cb70c97ab0b584f8ac760740e5dda42b9e1093c4103ab360f8ca9b7dc921c116e24171b04b8f80e44afc991c6bf0a108533c395f264509e715f1b3e49e893e3110dd031d716c115bbc0b12844a415a84a6eb5a9ef9172516183a4ce8e103ba2a157bea85225f60a19d2149c4864e02ae3b37498b7b42522f2bbad3d5b9a674bf55384bf57eac7ece6e7cad1363d891e874702b3d58cdb69dc62f009b7c9306cbbf015357e19791230ad452e9b7f869be9937f8c27acecb9871a7ca2df80a37c83c54c72340e8e8eeaae3d38c2cafd90f4f28b545fac1afa5ce3190eac6d6621dee7f6e8791afcc2cd53e167502e36211a29ed554f38cdb381d0c8b5fca137817733b38d82ef3dab1909a98a8624aa6f99dbd712091137bbf09b4933573c0b07b28148d5d872906bc15e24c40bff31a07bada39a6ddfbbdb6eb0e76a69e216ef5a28bec67c47e2e7832d0a8f05af05e999438a12495d13bb549d1c94c9e5413643328a604eedb9799f229bd7a846d188f1dcd5b345db36bebf8e2cb54ef6a1741cd51fbc97820e4787ea53b00c4e098cf2a217d82151c9dfb0c090ea713a2c28ed8d648aa80f25d24ac7622061a1b02fe0da04d6aa1495016fa26ad5fba8b4d94888c6acc77f48c00a9771009bfa3713536e90d338f6ac71b42a4a75dd7c52137ce7fbb65061923dfe4d16d4ccd933de53a82f60638275f3af65e0b4aef8fe057388ace2e10c6745a616cb8691e602d5c1190bb0534e90382bfcc417692f1cbf73976812f3e90ced3be508ae4c9668986ef1bec2d1dd20400d588d25627c061b9bd1e6f2ff27d2f21d7aa64d8ebb10c8f34e3e9ea59b18842523b2181e98a3efd3ffcc75269b605356f4fe2f279e676955d2e40da105a1d5b7dbcafc60d8877f3a9b49516d7b891817e5d602d45ee241944170c94005b4ada288fd9a34604b5a5f41e20ffce1d0ccfab49a49562736c3c55e8dc34db94d1e3b60dbab6ec1c08871c24a2459220cca4cc2a3b9cd7799e689af1a7817df0cab926d54bac637aba0eb165e4a56037e1f1aea444b6f6cd800d743a2b40ae0b8494c187a259bc30e7bb89c37039ed4d9fb64c371fec249fb01cdafad28241d4c7f26fe97b52c6038d8ad7947929603c29f7b11ffa7636931479bef8f324de3781872d60bb771287931dd3c76ead84363c29a125a15ca7c3058801eca97734ffdaa3902448737d010af7e7e22975c7cda0d6db08d89d298ad8ae83cd01d18419a0c6505af4fbb04126fb3e44d3d95444cb6b6026a9787195e19dd22abe3c5d0394f9f7d79285655d03d20fd60697ceaa2b47c7be2953d2adf5f3db2efb6057d29df596382625df7d47bfc5f37089f06692808f890100eda0f4a520b6e071fc7ac7e3dffb509fccac8353623136afc31aeaea2153a7b75267f45056d7736ddfb0dda1247125d8658427e31355d7ffcf27a0faf51439bfa768d2ba3a113e762a333c4a03cde30404b4573e94543d6fd543f9c6a0d29819665e1a2332ec481cb08d672ffc05b0bd0e117bc236154f2a16240bf472c180b457d773357ab1bd35598d794b39a5f9db2793477b789385b72b7f91c910f1957d89f11237f41d8230bd3776245a56c59bbc5ce24eea898cb1f4497b0e492a89bcaee032a042f25d8777f3e332c5f8e3543e2f1999730bb3788ddf93872b6ffa8b1c59f3b4cab6b4163bde4e7e575a5a5499ec68cfec9ec5512915f6af1d41e8288686151331bece1e62de7789ab5010a38ddd19ef0a8810402789d3169456d516f39adc20ba7344ac4f54300d27f1a73a58491b63e6df18c796dba6a81510e3b0dd6b3855dfa1619e9d17c8efc54f00fb78f664ef96454fb65fd4c434b1bc0fe25fddbf509bdb00e35712283c327812eefb0441cf776e794e3c0ac0bb0f5f34a8cd2ef81dae5565a7c0ef2cb911aeda5b1d8a5d5cccbe43b90a7d4336a5d8e7a39601fc79ea7706aa9100746270192b57b0a61d1695e77a71bf0f0ba0b81e004476cc3f51811b73cd748a3124f8d853b95448f51238ee37a44a9f351ee5b9bf32af21601bdbbe551e121c261b17ea1cb63fe2b6dbddedbb6195e329c71fd1341df0d690c4c1480ff9199ee039bd5885d703dc299d0479e2a121b499b8f2fe85f0d150d56c78c8a240a7eb24cff5b4b2825b1896aee972e4a9affdc14fee8928d77f56e416b581159ae9a1454c27d12bf9617fbd901dde61479306867fcacbc17dccd9af74118547cf4afc3bd2b71d28d1dda15e5c3a2e957b9ad0cd8d1ee436a55312174022c95b3c8b2d308e2aa50946ad989b591efcf1b0f80a1a97e211e3c76337c55c87bb386aba64ead698d1a15dd8d361500fe30433f64e1217e7345a71768a2a36652e42f0f41f06cf915ceef7c12c7456e88f2ef2146a3a0940fdddd63c89acd25b5afdef98d79da743d622b92a74757200b0c579731e489b6d4bb2930a66365327cca877c110552d84566c87152cb45382d2c9a163ecc88a12716a6123878dcf1e9ffb5cf14d1937ddce0b58043ff7b618f97145feadeaf81c7aab15dcd695491e5534bc3f502dc1d4e8e66769bf74c9656577fe9a21ad127e81a4328514e1c4f343beebc2455464a175fa691c5374981597375ee10903644ad7e8f9556006c77e18becde1db063ba2eb21a7c9efe24a43fcb37ff3a8704c2a0f80a5ed7101012b627474ebe7484fff2202f131a7e520c48ce3ae54785125ebe44af7b0949b8541c75ced6ed0438ad57a43b1a1dec0eff423fd2193249ea848e8894fb0afe177e1f4b2160f3d5d360b8e73389d8399e4357d3c357091834a848bbe6f58fe2b7e33d3d1dcf6c93cafeab8543889af8e3a890170eb06de81e4f60ecc7d54ee42275c808b8836ce14cdf76086db6943789661b96895305054dcb40954c8359ad1fdefd35c87f845f16ed8f4713b7c2af7373d4d64f358acc89433397b8bc52b4ced58e9410321ec2eb3873fa5a43b7268f1cc570ac76f3319ce60a02b2c7c35aa0827221a2e356daa1f83716de737371c11c48ade82397fe2aa890aaed11e18a3451de800b7f8dab4a611027953955c6267a072411971250d275a2436540082299ada9a430fed406ffd76b8c98cd2cb3b5dfeed595ecb3c19106a33ac20d16cc9b5de8c92638676b4dc913cebd4b95406814608c86400fe6ba14956c131bb5fea6685e74cf519a4105661df8f3165b5b0b836f8dd4ab21b4ba0ffbbe016a8f838bde911bf02afcdff4a0e21e6f44d424819112fbd63b865aa8500e2857c428cee173b5f6d9d506771e7afb4bea51eb4ce4a419a1d13a620cbac15a2675a0bf9669ea5e9d62a9e07ea53a5a44c1da148fb582862a3b0ff6f93270e590f8393c33ff015481bff49db510bc64a1c36056397b07bb98c315c1183fb153d954b4bf140fcf0e5887764ec17b8a894781c0cf02ef804425e4dc08d9a6cbec347aacf042b0ac693d25faa081367a8ddea6d23dc5c8a6e105c20bb044a959b32cb0d3e59ebba030f80a471ec975cdc8964724d6ea1fc215524e639be763457270b07882f46dafba824dfae1fc2af405fab7f84bca3624f5b61891e652ac9fc296ed07d365c00d599992d4027d1342f3ff42d6a012e73c23589b04aa481db59206e2064886fbdf2b24593e123e233ca9fd2ebba02cfc83af6e5b2e093ed82d3a4b26a8e7c9a0b12c1786c280fb26b1949cf5abc00ae31844f0697f696383aae59932e266bd8cd1966cfd55c030d8b6b363e1a3b47629ebf906bf30b91d6a38249fb6f28413d34db3793b60124bb133c7edf6b59bdeb6a776556421e6ac158534ad36b3e403e6132169415096a150f659b4977b94dd8692a052e14c439884de675ec6bf09e150d4f442c4bdba21440cfcb222827617fa5ee67d72b0e73073593ec6b13bcc6d06d258aa1360017117d273504030935d9699f4a03c02e6227e9455631cb559889a25604c55bb12d0f5b9316538f4b9e892df881d806e61eced10ed0da48755ee047b80e568b08091eedcca8107396a13e84841dfca9eec12f873bf822cbaf8d5915d8b3b65336f27836e24226cbd9985c9597f72e1768d2b73b414a4fdceddab866203251c2d9379722cd758b888033a10f4f756ca8ab83d08facbdaa0e7983c96e6dd341ea05cfc16fbb9091ad8ad5135fc05df1ee7f8ad827e177e4021371c8a1eca0a38f6fdeb81afd3f4764aff2f539178af912a9ee3a67350cc5a6df439bcb0cc4316481f23939531c05684fd3b92264b14e25158d3b0245ff8b733574ba812fc8fa668304e16f32f6d2adc9736551678566c8b18603f400791e8d1b792253d40f9c742f26bfdf312e5e95841f04caa10033f72e8dbdd3303a529b3913639e883acbad6939594261973fb2c035ee3fd3822bf9665cdfacdff8e950fdd31844e3f96f8c6a75fade7757007ba09da83144c4ddba476e4e137ea199a7b185af4d3c6f7866a6b6642d2f3af3a1fc5d1835acc20191a4a4332c00b1ae3292e1953cfe4a1dd06a8900e13e31565bbc8af11f4f30ba8c8b8612899ae47d11487fb4b290832e057a1d2e93010f022dafc6e3945f743634e8728882b8a223f453e66474b89737c8464f512879370b00b127f4aa632f8446a7f4b8a187605bbde8da387e0f294c8f668fa749ac5fdbc1e4fc65cf7279db79530de4452d443155d6a78ed7aa43631c67f70f0d1c866b0323023ae556e5a5f208efb91e553964d94b298b9ec0a494f86497535e3e4b08f3c802756c5162a7123cc3500b7a32a6b7519fa8cad1b8b01f9d48c5e45fa219b9ba8f4b8bf46a815354ebab03add789c3bbe01ecc293fe5d2a67a789c9bcd2a10476aa7659c1dc8325d784938d5590306b0d03db657502e04bfb46bd61b024d160150ef831ec8c98c1fc3b37352e44518fb7358ae40936e5198e54c968ff12bec30b76fb0ad863d0decec63a26a4c4de6323c708dc6871417cd4c1344c5885cbfdb79cc395fb28f5ed1baec06baf7882caef9aea982416b3e482b82cf00a4a3807b91935ed4bbd9638adbe94c05ed71c1e6e9e7bf4d434fe04d83a868ad7b93a9e11a8faff817e2cd0dbb3dcb9d5af13e36eb258aecfb0c5c93f4a49ea457a07bb7ac1cbd605ba4b6c59a178143d95bdf8eb9f77548d580899fe70a2e6801f7600287c12bbca02262c096ad6084c723905495dcfe4bfdc25c3be8bba414ec99cd124d83d2cf9344b814c4effc26f5ba807e982a5cf32f00dbe436de8fb50d1351bce4904c553209034765e0972b02b2ab2f511f767375195b7d0c731c0774eac6ec21e9b5ce7c6affc83f5e9e683056c8e9c2d095f9a4d9fe43133201be96c58074cd3dba4260c67e75441c7c187e0377235eca66f1b11bbc3c1a76ab9d1636fb0358e1255c5fbe2aae5279bd750c83411ea40706dc8f3f1ff25312e27bf3511070ddab1c6e764d88469012bd6de47ce83e921c060019b2fad655812fc78a2e7d3f3d7f35598b91e954dca2b5e6f222ff6f95ccf4d19afc64fd96059d69ad6be3033209511cf9e8a5d7ca5063acce4ee507e4d172258db24a51bb71c0ebcd0605ac4ed4a07c4425de1d0c85490d83a4b60d46ee7410f8a5b2eec532d776c9be2bd219e5ded2bb9174c56a84589233f69591be8140a979723393e4c7be3b0c718ffac6e8f60abc787b2bc749a429f6817ba7515edd1dfc9a95ce506da110989ecf73a7947dda21d6797b7833dff82bcd34f397e04d55578fa6a11b8b30f0c19710e15307c104fe5f86be0cb6888964a886b6db3a00baf31ae58843ddd0ddda28673489165a42c072930f4bac3dde9e6d6f75209d010abd64df630d7c0e7da374e1786d4ff6f5c6a73a0cf59bc3cf6b5ee27a9abee5fe270224f988b6b4474bf0286f663cac8e7b71ba1de4fee95e0b9c2da62c8d0885e397d8327f0607c59811b7fc1a0b7a8ebb859f7b8d640dcbd12b28d6871cd79fe9009190d5c7f7c87b3901002d1350e46ba9c27f5d9058de5cd718bc4a729233b858e7a4a8b4c0466ad0a4e037f1a44ec3ca32fcb14c2837ff82611e43e2d05f487a682aa5fe4fc4ff551012179361e09d096b76fd8e3967bf905cbafa15256089371bcd343ab4b8ad73b0ef944ab610736f80c898e242940875c3524941404a391d1cf20568094119ed0947e24e40f40df6f333c6472342b555bc6f3904627616c2777741efd8b4f51f610950f2ee838cca823e5ccf816113751b7b9802087d03086ab0623a53dd0e0eb8e95a11d383792fac5eba2fc6725c83d0e385d51792ce83cb12044264fb3a3890e8896420f862737cc7a6195f15d7cdb322f99785c3f69d4d961afc9d9951a0df6fc169abb9ff8ed76cc52a8b828adf1f9e5740a5d6cbce44a2ce6f7a227ab93c048268e58ed4eab12b131aeae7b57306ebe9ad08ff7045c52decfec9b302d2cd0c05fda44ffdbc6dc4388f375492cf3dbf56659ca039220d256da2805cbcc87baefcbbb3c34c64f5ec7bc5ba8e8ba2dc643f2c83b682537fb5f6704c45f6125fe2dce9fb688f9762cf72f2758344dcd7ba57b8ca99f5c602efabe10e95fede3d55040bf48ad3bc771b24a122bcf6f3ce2f28b9b1448300c2c4856918f60ec9e98e97e7ca86cfc947f7390cdb1b20dc9595fc3aa9fa66fa2a054d697ae8c1272876fd257502c0ce3606c6e5a2bc3bf4cf5ae6a78faac6189f0d7a127c69a37a6775ad3d38e5ee16fa612178969c81ee0fc40a50405cac0e595eec6a1d69112430d63f328c8d111aa9bfceb5320418cae58c5a781b83091ef93e5b7027594a306cad23e3f2ea88556977f8de01f2ece42ff1c4b6cfcd9fefefc5acd5700d672ea76252828797f05f4c83bb696f31dd9c3cd50b6b5d3ea61231ef5d4bb336ddb6a8e692367f2869b28b15888341d34e9e1424f11cf49fdf324d86f2c7dbddb25a5dc6fb295266de594c8f008b7c6295e0d0a537db13675d5a662b1c7d86a217377cfb3850f2414f1e2f8424a3f52e8c0c6d6ba44c3f8f7a08a912726b2b1a77aa820c6f94283d7d7cd79d4becf27052d760fc6dcd9f2396998cecee5bebc8819aa086a6cad48edd7fba818a34cbfc9c1534362b5b5b08281cad8866428277d20f45b0babe0bf9ac97323997a447d3b9e51c09f5d366a9a1cc296bdabc3d4ec35b36cf3b87301612afd3b3d6aa612acb5a836edd72c87b802c24bd091fb5cfff7ac6ade54270e3c179485c99f3074d99ab40a2dd06f81bccda270752e136a078eeabfaae1b8c19a0f9cf73363b6cb2e10c9967299cfb15767c587a22100e10aed715ca67a77f2d2a7f69089b31103233f96617b93fd62b7fefb79e24f2f83e3c0b46e229851716721fa5105714860657d783d6346eef30d3eb5619c49703d7eb93ec13d5b097a68e3fc3a5802fb5601480be73af1bb3b0183cc09483b06447a92824aaf7a300d25cd96888a81c9c585fa7c6b72f44092ba49a62323153950f16d45b9cbc82a1fe8491daaaaec913057b993264ec1d3427d20ad6bd476ea6908d6203b9d0d6fec367f1d1f3b1890227f7b2c12d03b6cb364b43dcea5f47c5129b21089820dba28ea3368df45a6440b75641593542c0b55d1f870be7f35d48147a4ca076b483991176c8a5fda7b00e86125b64bc665b54c27a26a8e5fc1958d6c7f184242dbfe64d9f1152d84da8d684821354bd022579ead851d6244075bf852a181f39029984e0a6cd19b8afbeb93a98820e5c648b3d608881420797edf6f5486125602f987b7d4941cc9791efd26a3789b134d990e05206c53d5cd9368a8b1c2eeaf2fc7b212ce805049fca48e3d3bc9893a1456de0deeb1958436f9eb3fee6a1bdb366dee17c3d1c5a30b3ba655f899b8030f4a70dadd15f0c20bb9242ffbf038dfa60e9115e0fa2b437b58408599c63696a1854dd80a54e73c8b850aa1bb43994b6e7b3fe483912b0aa4d70382a44213697fde1593e461364e2a6f103f64e3f60cee76186bf218939f21c9bc0cf5e46f3bd900f7616d03c66db33ff61a5853f26d8143864133b7def68e6de18affa15d18da478ea288427d8b6179b2090d545f2f96208601a28452c0fbeaaccb31189a9704273af52faac5a889ef9edfa003323cb2b46be8f6d6b147cc592746684f50a7ecb4ae3f179aee46d9e223546b9bf455873970dd638094c925f6b761e0c3c56880d131f95cb279b24c40642f6edeee97a40938caa6299cc15e95a6d8562dd36977b3df3490f3de259ee5319bf7aad7d9afc3b4b84a5f789edae31318e146cb4934592bfd23c71c4b05cbc9bca32656f4bebed8ce5ea0a291431a6c83ec1ce808be90ba0c072649f8ae605051d7855a60844a39d2f076352d27b2b7334ef55aca71102884809efa8aa28ff1c5d26febbec80b02d5847a3ad321e6c3765bc273ad8f771a30ed9011","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
